"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_flow_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/flow.js":
/*!************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/flow.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"flow\": function() { return /* binding */ flow; },\n/* harmony export */   \"FlowLayout\": function() { return /* binding */ FlowLayout; }\n/* harmony export */ });\n/* harmony import */ var _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared/SizeCache.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\");\n/* harmony import */ var _shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/BaseLayout.js */ \"./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\nvar flow = function flow(config) {\n  return Object.assign({\n    type: FlowLayout\n  }, config);\n};\n\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a, b) {\n  var m = [a, b].sort();\n  return m[1] <= 0 ? Math.min.apply(Math, _toConsumableArray(m)) : m[0] >= 0 ? Math.max.apply(Math, _toConsumableArray(m)) : m[0] + m[1];\n}\n\nvar MetricsCache = /*#__PURE__*/function () {\n  function MetricsCache() {\n    _classCallCheck(this, MetricsCache);\n\n    this._childSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._marginSizeCache = new _shared_SizeCache_js__WEBPACK_IMPORTED_MODULE_0__.SizeCache();\n    this._metricsCache = new Map();\n  }\n\n  _createClass(MetricsCache, [{\n    key: \"update\",\n    value: function update(metrics, direction) {\n      var _this = this;\n\n      var _a, _b;\n\n      var marginsToUpdate = new Set();\n      Object.keys(metrics).forEach(function (key) {\n        var k = Number(key);\n\n        _this._metricsCache.set(k, metrics[k]);\n\n        _this._childSizeCache.set(k, metrics[k][(0,_shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.dim1)(direction)]);\n\n        marginsToUpdate.add(k);\n        marginsToUpdate.add(k + 1);\n      });\n\n      var _iterator = _createForOfIteratorHelper(marginsToUpdate),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var k = _step.value;\n          var a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n          var b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n\n          this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"averageChildSize\",\n    get: function get() {\n      return this._childSizeCache.averageSize;\n    }\n  }, {\n    key: \"totalChildSize\",\n    get: function get() {\n      return this._childSizeCache.totalSize;\n    }\n  }, {\n    key: \"averageMarginSize\",\n    get: function get() {\n      return this._marginSizeCache.averageSize;\n    }\n  }, {\n    key: \"totalMarginSize\",\n    get: function get() {\n      return this._marginSizeCache.totalSize;\n    }\n  }, {\n    key: \"getLeadingMarginValue\",\n    value: function getLeadingMarginValue(index, direction) {\n      var _a;\n\n      return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n  }, {\n    key: \"getChildSize\",\n    value: function getChildSize(index) {\n      return this._childSizeCache.getSize(index);\n    }\n  }, {\n    key: \"getMarginSize\",\n    value: function getMarginSize(index) {\n      return this._marginSizeCache.getSize(index);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._childSizeCache.clear();\n\n      this._marginSizeCache.clear();\n\n      this._metricsCache.clear();\n    }\n  }]);\n\n  return MetricsCache;\n}();\n\nvar FlowLayout = /*#__PURE__*/function (_BaseLayout) {\n  _inherits(FlowLayout, _BaseLayout);\n\n  var _super = _createSuper(FlowLayout);\n\n  function FlowLayout() {\n    var _this2;\n\n    _classCallCheck(this, FlowLayout);\n\n    _this2 = _super.apply(this, arguments);\n    /**\n     * Initial estimate of item size\n     */\n\n    _this2._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n\n    _this2._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n\n    _this2._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n\n    _this2._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n\n    _this2._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n\n    _this2._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n\n    _this2._stable = true;\n    /**\n     * Whether to remeasure children during the next reflow.\n     */\n\n    _this2._needsRemeasure = false;\n    _this2._measureChildren = true;\n    _this2._estimate = true;\n    return _this2;\n  } // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n\n  _createClass(FlowLayout, [{\n    key: \"measureChildren\",\n    get: function get() {\n      return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n\n  }, {\n    key: \"updateItemSizes\",\n    value: function updateItemSizes(sizes) {\n      this._metricsCache.update(sizes, this.direction); // if (this._nMeasured) {\n      // this._updateItemSize();\n\n\n      this._scheduleReflow(); // }\n\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n\n  }, {\n    key: \"_getPhysicalItem\",\n    value: function _getPhysicalItem(idx) {\n      var _a;\n\n      return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n  }, {\n    key: \"_getSize\",\n    value: function _getSize(idx) {\n      var item = this._getPhysicalItem(idx);\n\n      return item && this._metricsCache.getChildSize(idx);\n    }\n  }, {\n    key: \"_getAverageSize\",\n    value: function _getAverageSize() {\n      return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n\n  }, {\n    key: \"_getPosition\",\n    value: function _getPosition(idx) {\n      var _a;\n\n      var item = this._getPhysicalItem(idx);\n\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n      return idx === 0 ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize : item ? item.pos : averageMarginSize + idx * (averageMarginSize + this._getAverageSize());\n    }\n  }, {\n    key: \"_calculateAnchor\",\n    value: function _calculateAnchor(lower, upper) {\n      if (lower <= 0) {\n        return 0;\n      }\n\n      if (upper > this._scrollSize - this._viewDim1) {\n        return this._totalItems - 1;\n      }\n\n      return Math.max(0, Math.min(this._totalItems - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n  }, {\n    key: \"_getAnchor\",\n    value: function _getAnchor(lower, upper) {\n      if (this._physicalItems.size === 0) {\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (this._first < 0) {\n        console.error('_getAnchor: negative _first');\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (this._last < 0) {\n        console.error('_getAnchor: negative _last');\n        return this._calculateAnchor(lower, upper);\n      }\n\n      var firstItem = this._getPhysicalItem(this._first),\n          lastItem = this._getPhysicalItem(this._last),\n          firstMin = firstItem.pos,\n          lastMin = lastItem.pos,\n          lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n\n      if (lastMax < lower) {\n        // Window is entirely past physical items, calculate new anchor\n        return this._calculateAnchor(lower, upper);\n      }\n\n      if (firstMin > upper) {\n        // Window is entirely before physical items, calculate new anchor\n        return this._calculateAnchor(lower, upper);\n      } // Window contains a physical item\n      // Find one, starting with the one that was previously first visible\n\n\n      var candidateIdx = this._firstVisible - 1;\n      var cMax = -Infinity;\n\n      while (cMax < lower) {\n        var candidate = this._getPhysicalItem(++candidateIdx);\n\n        cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n      }\n\n      return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n\n  }, {\n    key: \"_getActiveItems\",\n    value: function _getActiveItems() {\n      if (this._viewDim1 === 0 || this._totalItems === 0) {\n        this._clearItems();\n      } else {\n        this._getItems();\n      }\n    }\n    /**\n     * Sets the range to empty.\n     */\n\n  }, {\n    key: \"_clearItems\",\n    value: function _clearItems() {\n      this._first = -1;\n      this._last = -1;\n      this._physicalMin = 0;\n      this._physicalMax = 0;\n      var items = this._newPhysicalItems;\n      this._newPhysicalItems = this._physicalItems;\n\n      this._newPhysicalItems.clear();\n\n      this._physicalItems = items;\n      this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n\n  }, {\n    key: \"_getItems\",\n    value: function _getItems() {\n      var _a, _b;\n\n      var items = this._newPhysicalItems;\n      this._stable = true;\n      var lower, upper; // The anchorIdx is the anchor around which we reflow. It is designed to\n      // allow jumping to any point of the scroll size. We choose it once and\n      // stick with it until stable. first and last are deduced around it.\n      // If we have a scrollToIndex, we anchor on the given\n      // index and set the scroll position accordingly\n\n      if (this._scrollToIndex >= 0) {\n        this._anchorIdx = Math.min(this._scrollToIndex, this._totalItems - 1);\n        this._anchorPos = this._getPosition(this._anchorIdx);\n\n        this._scrollIfNeeded();\n      } // Determine the lower and upper bounds of the region to be\n      // rendered, relative to the viewport\n\n\n      lower = this._scrollPosition - this._overhang; //leadingOverhang;\n\n      upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n      if (upper < 0 || lower > this._scrollSize) {\n        this._clearItems();\n\n        return;\n      } // If we are scrolling to a specific index or if we are doing another\n      // pass to stabilize a previously started reflow, we will already\n      // have an anchor. If not, establish an anchor now.\n\n\n      if (this._anchorIdx === null || this._anchorPos === null) {\n        this._anchorIdx = this._getAnchor(lower, upper);\n        this._anchorPos = this._getPosition(this._anchorIdx);\n      }\n\n      var anchorSize = this._getSize(this._anchorIdx);\n\n      if (anchorSize === undefined) {\n        this._stable = false;\n        anchorSize = this._getAverageSize();\n      }\n\n      var anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n      var anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n\n      if (this._anchorIdx === 0) {\n        this._anchorPos = anchorLeadingMargin;\n      }\n\n      if (this._anchorIdx === this._totalItems - 1) {\n        this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n      } // Anchor might be outside bounds, so prefer correcting the error and keep\n      // that anchorIdx.\n\n\n      var anchorErr = 0;\n\n      if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n        anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n      }\n\n      if (this._anchorPos - anchorLeadingMargin > upper) {\n        anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n      }\n\n      if (anchorErr) {\n        this._scrollPosition -= anchorErr;\n        lower -= anchorErr;\n        upper -= anchorErr;\n        this._scrollError += anchorErr;\n      }\n\n      items.set(this._anchorIdx, {\n        pos: this._anchorPos,\n        size: anchorSize\n      });\n      this._first = this._last = this._anchorIdx;\n      this._physicalMin = this._anchorPos;\n      this._physicalMax = this._anchorPos + anchorSize;\n\n      while (this._physicalMin > lower && this._first > 0) {\n        var size = this._getSize(--this._first);\n\n        if (size === undefined) {\n          this._stable = false;\n          size = this._getAverageSize();\n        }\n\n        var margin = this._metricsCache.getMarginSize(this._first + 1);\n\n        if (margin === undefined) {\n          this._stable = false;\n          margin = this._metricsCache.averageMarginSize;\n        }\n\n        this._physicalMin -= size + margin;\n        var pos = this._physicalMin;\n        items.set(this._first, {\n          pos: pos,\n          size: size\n        });\n\n        if (this._stable === false && this._estimate === false) {\n          break;\n        }\n      }\n\n      while (this._physicalMax < upper && this._last < this._totalItems - 1) {\n        var _margin = this._metricsCache.getMarginSize(++this._last);\n\n        if (_margin === undefined) {\n          this._stable = false;\n          _margin = this._metricsCache.averageMarginSize;\n        }\n\n        var _size = this._getSize(this._last);\n\n        if (_size === undefined) {\n          this._stable = false;\n          _size = this._getAverageSize();\n        }\n\n        var _pos = this._physicalMax + _margin;\n\n        items.set(this._last, {\n          pos: _pos,\n          size: _size\n        });\n        this._physicalMax += _margin + _size;\n\n        if (this._stable === false && this._estimate === false) {\n          break;\n        }\n      } // This handles the cases where we were relying on estimated sizes.\n\n\n      var extentErr = this._calculateError();\n\n      if (extentErr) {\n        this._physicalMin -= extentErr;\n        this._physicalMax -= extentErr;\n        this._anchorPos -= extentErr;\n        this._scrollPosition -= extentErr;\n        items.forEach(function (item) {\n          return item.pos -= extentErr;\n        });\n        this._scrollError += extentErr;\n      }\n\n      if (this._stable) {\n        this._newPhysicalItems = this._physicalItems;\n\n        this._newPhysicalItems.clear();\n\n        this._physicalItems = items;\n      }\n    }\n  }, {\n    key: \"_calculateError\",\n    value: function _calculateError() {\n      var _a, _b;\n\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n\n      if (this._first === 0) {\n        return this._physicalMin - ((_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize);\n      } else if (this._physicalMin <= 0) {\n        return this._physicalMin - this._first * this._delta;\n      } else if (this._last === this._totalItems - 1) {\n        return this._physicalMax + ((_b = this._metricsCache.getMarginSize(this._totalItems)) !== null && _b !== void 0 ? _b : averageMarginSize) - this._scrollSize;\n      } else if (this._physicalMax >= this._scrollSize) {\n        return this._physicalMax - this._scrollSize + (this._totalItems - 1 - this._last) * this._delta;\n      }\n\n      return 0;\n    } // TODO: Can this be made to inherit from base, with proper hooks?\n\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      var _first = this._first,\n          _last = this._last,\n          _scrollSize = this._scrollSize;\n\n      this._updateScrollSize();\n\n      this._getActiveItems();\n\n      if (this._scrollSize !== _scrollSize) {\n        this._emitScrollSize();\n      }\n\n      this._updateVisibleIndices();\n\n      this._emitRange();\n\n      if (this._first === -1 && this._last === -1) {\n        this._resetReflowState();\n      } else if (this._first !== _first || this._last !== _last || this._needsRemeasure) {\n        this._emitChildPositions();\n\n        this._emitScrollError();\n      } else {\n        this._emitChildPositions();\n\n        this._emitScrollError();\n\n        this._resetReflowState();\n      }\n    }\n  }, {\n    key: \"_resetReflowState\",\n    value: function _resetReflowState() {\n      this._anchorIdx = null;\n      this._anchorPos = null;\n      this._stable = true;\n    }\n  }, {\n    key: \"_updateScrollSize\",\n    value: function _updateScrollSize() {\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n      this._scrollSize = Math.max(1, this._totalItems * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n\n  }, {\n    key: \"_delta\",\n    get: function get() {\n      var averageMarginSize = this._metricsCache.averageMarginSize;\n      return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(idx) {\n      var _ref;\n\n      var _a;\n\n      return _ref = {}, _defineProperty(_ref, this._positionDim, this._getPosition(idx)), _defineProperty(_ref, this._secondaryPositionDim, 0), _defineProperty(_ref, offset(this.direction), -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)), _ref;\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n\n  }, {\n    key: \"_getItemSize\",\n    value: function _getItemSize(idx) {\n      var _ref2;\n\n      var _a;\n\n      return _ref2 = {}, _defineProperty(_ref2, this._sizeDim, (this._getSize(idx) || this._getAverageSize()) + ((_a = this._metricsCache.getMarginSize(idx + 1)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)), _defineProperty(_ref2, this._secondarySizeDim, this._itemSize[this._secondarySizeDim]), _ref2;\n    }\n  }, {\n    key: \"_viewDim2Changed\",\n    value: function _viewDim2Changed() {\n      this._needsRemeasure = true;\n\n      this._scheduleReflow();\n    }\n  }, {\n    key: \"_emitRange\",\n    value: function _emitRange() {\n      var remeasure = this._needsRemeasure;\n      var stable = this._stable;\n      this._needsRemeasure = false;\n\n      _get(_getPrototypeOf(FlowLayout.prototype), \"_emitRange\", this).call(this, {\n        remeasure: remeasure,\n        stable: stable\n      });\n    }\n  }]);\n\n  return FlowLayout;\n}(_shared_BaseLayout_js__WEBPACK_IMPORTED_MODULE_1__.BaseLayout);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvZmxvdy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFtQkE7QUFBQTtBQUNBO0FBREE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBbURBOzs7O0FBakRBO0FBQUE7Ozs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQVJBO0FBQUE7O0FBQUE7QUFTQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBOzs7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7OztBQUNBOztBQUVBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7OztBQUdBOztBQUNBO0FBRUE7OztBQUdBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7OztBQUlBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7QUFFQTtBQS9DQTtBQW1hQTtBQWhYQTtBQUVBO0FBQ0E7QUFDQTs7O0FBdkRBO0FBQUE7QUFBQTtBQTBEQTtBQUNBO0FBRUE7OztBQUdBOztBQWhFQTtBQUFBO0FBQUE7QUFrRUE7QUFFQTs7O0FBQ0E7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFoRkE7QUFBQTtBQUFBOzs7QUFtRkE7QUFDQTtBQXBGQTtBQUFBO0FBQUE7QUF1RkE7O0FBQ0E7QUFDQTtBQXpGQTtBQUFBO0FBQUE7QUE0RkE7QUFDQTtBQUVBOzs7QUFHQTs7QUFsR0E7QUFBQTtBQUFBOzs7QUFvR0E7O0FBQ0E7QUFDQTtBQUtBO0FBM0dBO0FBQUE7QUFBQTtBQThHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBS0E7QUF6SEE7QUFBQTtBQUFBO0FBNEhBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU1BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7O0FBcEtBO0FBQUE7QUFBQTtBQXNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUEvS0E7QUFBQTtBQUFBO0FBaUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUE5TEE7QUFBQTtBQUFBOzs7QUFnTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFsVUE7QUFBQTtBQUFBOzs7QUFxVUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBbFZBO0FBQUE7QUFBQTtBQXNWQTtBQUFBO0FBQUE7O0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUE3V0E7QUFBQTtBQUFBO0FBZ1hBO0FBQ0E7QUFDQTtBQUNBO0FBblhBO0FBQUE7QUFBQTtBQXNYQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7O0FBN1hBO0FBQUE7QUFBQTtBQStYQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFyWUE7QUFBQTtBQUFBO0FBc1lBOzs7O0FBQ0E7QUFLQTtBQUVBOztBQUVBOztBQWhaQTtBQUFBO0FBQUE7QUFpWkE7Ozs7QUFDQTtBQUlBO0FBdFpBO0FBQUE7QUFBQTtBQXlaQTs7QUFDQTtBQUNBO0FBM1pBO0FBQUE7QUFBQTtBQThaQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQWxhQTs7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2xheW91dHMvZmxvdy50cz8xODRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQgeyBTaXplQ2FjaGUgfSBmcm9tICcuL3NoYXJlZC9TaXplQ2FjaGUuanMnO1xuaW1wb3J0IHtCYXNlTGF5b3V0LCBCYXNlTGF5b3V0Q29uZmlnLCBkaW0xfSBmcm9tICcuL3NoYXJlZC9CYXNlTGF5b3V0LmpzJztcbmltcG9ydCB7SXRlbUJveCwgUG9zaXRpb25zLCBTaXplLCBNYXJnaW5zLCBtYXJnaW4sIFNjcm9sbERpcmVjdGlvbiwgb2Zmc2V0QXhpc30gZnJvbSAnLi9zaGFyZWQvTGF5b3V0LmpzJztcblxudHlwZSBJdGVtQm91bmRzID0ge1xuICBwb3M6IG51bWJlcixcbiAgc2l6ZTogbnVtYmVyXG59O1xuXG50eXBlIEZsb3dMYXlvdXRDb25zdHJ1Y3RvciA9IHtcbiAgcHJvdG90eXBlOiBGbG93TGF5b3V0LFxuICBuZXcoY29uZmlnPzogQmFzZUxheW91dENvbmZpZyk6IEZsb3dMYXlvdXRcbn1cblxudHlwZSBGbG93TGF5b3V0U3BlY2lmaWVyID0gQmFzZUxheW91dENvbmZpZyAmIHtcbiAgdHlwZTogRmxvd0xheW91dENvbnN0cnVjdG9yXG59XG5cbnR5cGUgRmxvd0xheW91dFNwZWNpZmllckZhY3RvcnkgPSAoY29uZmlnPzogQmFzZUxheW91dENvbmZpZykgPT4gRmxvd0xheW91dFNwZWNpZmllcjtcblxuZXhwb3J0IGNvbnN0IGZsb3c6IEZsb3dMYXlvdXRTcGVjaWZpZXJGYWN0b3J5ID0gKGNvbmZpZz86IEJhc2VMYXlvdXRDb25maWcpID0+IE9iamVjdC5hc3NpZ24oe1xuICB0eXBlOiBGbG93TGF5b3V0XG59LCBjb25maWcpO1xuXG5mdW5jdGlvbiBsZWFkaW5nTWFyZ2luKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogbWFyZ2luIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblRvcCc7XG59XG5cbmZ1bmN0aW9uIHRyYWlsaW5nTWFyZ2luKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogbWFyZ2luIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ21hcmdpblJpZ2h0JyA6ICdtYXJnaW5Cb3R0b20nO1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBvZmZzZXRBeGlzIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3hPZmZzZXQnIDogJ3lPZmZzZXQnO1xufVxuXG5mdW5jdGlvbiBjb2xsYXBzZU1hcmdpbnMoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICBjb25zdCBtID0gW2EsIGJdLnNvcnQoKTtcbiAgcmV0dXJuIG1bMV0gPD0gMFxuICA/IE1hdGgubWluKC4uLm0pXG4gIDogbVswXSA+PSAwXG4gICAgPyBNYXRoLm1heCguLi5tKVxuICAgIDogbVswXSArIG1bMV07XG59XG5cbmNsYXNzIE1ldHJpY3NDYWNoZSB7XG4gIHByaXZhdGUgX2NoaWxkU2l6ZUNhY2hlID0gbmV3IFNpemVDYWNoZSgpO1xuICBwcml2YXRlIF9tYXJnaW5TaXplQ2FjaGUgPSBuZXcgU2l6ZUNhY2hlKCk7XG4gIHByaXZhdGUgX21ldHJpY3NDYWNoZTogTWFwPG51bWJlciwgU2l6ZSAmIE1hcmdpbnM+ID0gbmV3IE1hcCgpO1xuXG4gIHVwZGF0ZShtZXRyaWNzOiB7W2tleTogbnVtYmVyXTogU2l6ZSAmIE1hcmdpbnN9LCBkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbikge1xuICAgIGNvbnN0IG1hcmdpbnNUb1VwZGF0ZTogU2V0PG51bWJlcj4gPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmtleXMobWV0cmljcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBrID0gTnVtYmVyKGtleSk7XG4gICAgICB0aGlzLl9tZXRyaWNzQ2FjaGUuc2V0KGssIG1ldHJpY3Nba10pO1xuICAgICAgdGhpcy5fY2hpbGRTaXplQ2FjaGUuc2V0KGssIG1ldHJpY3Nba11bZGltMShkaXJlY3Rpb24pXSk7XG4gICAgICBtYXJnaW5zVG9VcGRhdGUuYWRkKGspO1xuICAgICAgbWFyZ2luc1RvVXBkYXRlLmFkZChrICsgMSk7XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBrIG9mIG1hcmdpbnNUb1VwZGF0ZSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX21ldHJpY3NDYWNoZS5nZXQoayk/LltsZWFkaW5nTWFyZ2luKGRpcmVjdGlvbildIHx8IDA7XG4gICAgICBjb25zdCBiID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldChrIC0gMSk/Llt0cmFpbGluZ01hcmdpbihkaXJlY3Rpb24pXSB8fCAwO1xuICAgICAgdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLnNldChrLCBjb2xsYXBzZU1hcmdpbnMoYSwgYikpXG4gICAgfVxuICB9XG5cbiAgZ2V0IGF2ZXJhZ2VDaGlsZFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRTaXplQ2FjaGUuYXZlcmFnZVNpemU7XG4gIH1cblxuICBnZXQgdG90YWxDaGlsZFNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRTaXplQ2FjaGUudG90YWxTaXplO1xuICB9XG5cbiAgZ2V0IGF2ZXJhZ2VNYXJnaW5TaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmdpblNpemVDYWNoZS5hdmVyYWdlU2l6ZTtcbiAgfVxuXG4gIGdldCB0b3RhbE1hcmdpblNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLnRvdGFsU2l6ZTtcbiAgfVxuXG4gIGdldExlYWRpbmdNYXJnaW5WYWx1ZShpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0KGluZGV4KT8uW2xlYWRpbmdNYXJnaW4oZGlyZWN0aW9uKV0gfHwgMDtcbiAgfVxuXG4gIGdldENoaWxkU2l6ZShpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLmdldFNpemUoaW5kZXgpO1xuICB9XG5cbiAgZ2V0TWFyZ2luU2l6ZShpbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmdpblNpemVDYWNoZS5nZXRTaXplKGluZGV4KTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2NoaWxkU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fbWFyZ2luU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fbWV0cmljc0NhY2hlLmNsZWFyKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEZsb3dMYXlvdXQgZXh0ZW5kcyBCYXNlTGF5b3V0PEJhc2VMYXlvdXRDb25maWc+IHtcbiAgLyoqXG4gICAqIEluaXRpYWwgZXN0aW1hdGUgb2YgaXRlbSBzaXplXG4gICAqL1xuICBfaXRlbVNpemU6IFNpemUgPSB7d2lkdGg6IDEwMCwgaGVpZ2h0OiAxMDB9O1xuXG4gIC8qKlxuICAgKiBJbmRpY2VzIG9mIGNoaWxkcmVuIG1hcHBlZCB0byB0aGVpciAocG9zaXRpb24gYW5kIGxlbmd0aCkgaW4gdGhlIHNjcm9sbGluZ1xuICAgKiBkaXJlY3Rpb24uIFVzZWQgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiB0aGF0IGFyZSBpbiByYW5nZS5cbiAgICovXG4gIF9waHlzaWNhbEl0ZW1zOiBNYXA8bnVtYmVyLCBJdGVtQm91bmRzPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogVXNlZCBpbiB0YW5kZW0gd2l0aCBfcGh5c2ljYWxJdGVtcyB0byB0cmFjayBjaGlsZHJlbiBpbiByYW5nZSBhY3Jvc3NcbiAgICogcmVmbG93cy5cbiAgICovXG4gIF9uZXdQaHlzaWNhbEl0ZW1zOiBNYXA8bnVtYmVyLCBJdGVtQm91bmRzPiA9IG5ldyBNYXAoKTtcblxuICAvKipcbiAgICogV2lkdGggYW5kIGhlaWdodCBvZiBjaGlsZHJlbiBieSB0aGVpciBpbmRleC5cbiAgICovXG4gIF9tZXRyaWNzQ2FjaGUgPSBuZXcgTWV0cmljc0NhY2hlKCk7XG5cbiAgLyoqXG4gICAqIGFuY2hvcklkeCBpcyB0aGUgYW5jaG9yIGFyb3VuZCB3aGljaCB3ZSByZWZsb3cuIEl0IGlzIGRlc2lnbmVkIHRvIGFsbG93XG4gICAqIGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kIHN0aWNrIHdpdGhcbiAgICogaXQgdW50aWwgc3RhYmxlLiBfZmlyc3QgYW5kIF9sYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cbiAgICovXG4gIF9hbmNob3JJZHg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiBvZiB0aGUgYW5jaG9yIGNoaWxkLlxuICAgKi9cbiAgX2FuY2hvclBvczogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYWxsIGNoaWxkcmVuIGluIHJhbmdlIHdlcmUgaW4gcmFuZ2UgZHVyaW5nIHRoZSBwcmV2aW91cyByZWZsb3cuXG4gICAqL1xuICBfc3RhYmxlID0gdHJ1ZTtcblxuICAvKipcbiAgICogV2hldGhlciB0byByZW1lYXN1cmUgY2hpbGRyZW4gZHVyaW5nIHRoZSBuZXh0IHJlZmxvdy5cbiAgICovXG4gIF9uZWVkc1JlbWVhc3VyZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX21lYXN1cmVDaGlsZHJlbiA9IHRydWU7XG5cbiAgX2VzdGltYXRlID0gdHJ1ZTtcblxuICAvLyBwcm90ZWN0ZWQgX2RlZmF1bHRDb25maWc6IEJhc2VMYXlvdXRDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBzdXBlci5fZGVmYXVsdENvbmZpZywge1xuXG4gIC8vIH0pXG5cbiAgLy8gY29uc3RydWN0b3IoY29uZmlnOiBMYXlvdXQxZENvbmZpZykge1xuICAvLyAgIHN1cGVyKGNvbmZpZyk7XG4gIC8vIH1cblxuICBnZXQgbWVhc3VyZUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWFzdXJlQ2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHRoZSBhdmVyYWdlIHNpemUgb2YgYWxsIGNoaWxkcmVuIHJlcHJlc2VudGVkIGluIHRoZSBzaXplc1xuICAgKiBhcmd1bWVudC5cbiAgICovXG4gIHVwZGF0ZUl0ZW1TaXplcyhzaXplczoge1trZXk6IG51bWJlcl06IEl0ZW1Cb3h9KSB7XG4gICAgdGhpcy5fbWV0cmljc0NhY2hlLnVwZGF0ZShzaXplcyBhcyBTaXplICYgTWFyZ2lucywgdGhpcy5kaXJlY3Rpb24pO1xuICAgIC8vIGlmICh0aGlzLl9uTWVhc3VyZWQpIHtcbiAgICAgIC8vIHRoaXMuX3VwZGF0ZUl0ZW1TaXplKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIC8vIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGF2ZXJhZ2UgaXRlbSBzaXplIGJhc2VkIG9uIHRoZSB0b3RhbCBsZW5ndGggYW5kIG51bWJlciBvZiBjaGlsZHJlblxuICAgKiBpbiByYW5nZS5cbiAgICovXG4gIC8vIF91cGRhdGVJdGVtU2l6ZSgpIHtcbiAgLy8gICAvLyBLZWVwIGludGVnZXIgdmFsdWVzLlxuICAvLyAgIHRoaXMuX2l0ZW1TaXplW3RoaXMuX3NpemVEaW1dID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VDaGlsZFNpemU7XG4gIC8vIH1cblxuICBfZ2V0UGh5c2ljYWxJdGVtKGlkeDogbnVtYmVyKTogSXRlbUJvdW5kcyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMuZ2V0KGlkeCkgPz8gdGhpcy5fcGh5c2ljYWxJdGVtcy5nZXQoaWR4KTtcbiAgfVxuXG4gIF9nZXRTaXplKGlkeDogbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKGlkeCk7XG4gICAgcmV0dXJuIGl0ZW0gJiYgdGhpcy5fbWV0cmljc0NhY2hlLmdldENoaWxkU2l6ZShpZHgpO1xuICB9XG5cbiAgX2dldEF2ZXJhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlQ2hpbGRTaXplIHx8IHRoaXMuX2l0ZW1TaXplW3RoaXMuX3NpemVEaW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICogRXN0aW1hdGVzIGl0IGlmIHRoZSBpdGVtIGF0IGlkeCBpcyBub3QgaW4gdGhlIERPTS5cbiAgICovXG4gIF9nZXRQb3NpdGlvbihpZHg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2dldFBoeXNpY2FsSXRlbShpZHgpO1xuICAgIGNvbnN0IHsgYXZlcmFnZU1hcmdpblNpemUgfSA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICByZXR1cm4gaWR4ID09PSAwXG4gICAgICA/IHRoaXMuX21ldHJpY3NDYWNoZS5nZXRNYXJnaW5TaXplKDApID8/IGF2ZXJhZ2VNYXJnaW5TaXplXG4gICAgICA6IGl0ZW1cbiAgICAgICAgPyBpdGVtLnBvc1xuICAgICAgICA6IGF2ZXJhZ2VNYXJnaW5TaXplICsgaWR4ICogKGF2ZXJhZ2VNYXJnaW5TaXplICsgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSk7XG4gIH1cblxuICBfY2FsY3VsYXRlQW5jaG9yKGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChsb3dlciA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHVwcGVyID4gdGhpcy5fc2Nyb2xsU2l6ZSAtIHRoaXMuX3ZpZXdEaW0xKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtcyAtIDE7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgTWF0aC5taW4oXG4gICAgICAgICAgICB0aGlzLl90b3RhbEl0ZW1zIC0gMSxcbiAgICAgICAgICAgIE1hdGguZmxvb3IoKChsb3dlciArIHVwcGVyKSAvIDIpIC8gdGhpcy5fZGVsdGEpKSk7XG4gIH1cblxuICBfZ2V0QW5jaG9yKGxvd2VyOiBudW1iZXIsIHVwcGVyOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9waHlzaWNhbEl0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2ZpcnN0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignX2dldEFuY2hvcjogbmVnYXRpdmUgX2ZpcnN0Jyk7XG4gICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlQW5jaG9yKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXN0IDwgMCkge1xuICAgICAgY29uc29sZS5lcnJvcignX2dldEFuY2hvcjogbmVnYXRpdmUgX2xhc3QnKTtcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEl0ZW0gPSB0aGlzLl9nZXRQaHlzaWNhbEl0ZW0odGhpcy5fZmlyc3QpLFxuICAgICAgICAgIGxhc3RJdGVtID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKHRoaXMuX2xhc3QpLFxuICAgICAgICAgIGZpcnN0TWluID0gZmlyc3RJdGVtIS5wb3MsXG4gICAgICAgICAgbGFzdE1pbiA9IGxhc3RJdGVtIS5wb3MsXG4gICAgICAgICAgbGFzdE1heCA9IGxhc3RNaW4gKyB0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0Q2hpbGRTaXplKHRoaXMuX2xhc3QpITtcblxuICAgIGlmIChsYXN0TWF4IDwgbG93ZXIpIHtcbiAgICAgIC8vIFdpbmRvdyBpcyBlbnRpcmVseSBwYXN0IHBoeXNpY2FsIGl0ZW1zLCBjYWxjdWxhdGUgbmV3IGFuY2hvclxuICAgICAgcmV0dXJuIHRoaXMuX2NhbGN1bGF0ZUFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RNaW4gPiB1cHBlcikge1xuICAgICAgLy8gV2luZG93IGlzIGVudGlyZWx5IGJlZm9yZSBwaHlzaWNhbCBpdGVtcywgY2FsY3VsYXRlIG5ldyBhbmNob3JcbiAgICAgIHJldHVybiB0aGlzLl9jYWxjdWxhdGVBbmNob3IobG93ZXIsIHVwcGVyKTtcbiAgICB9XG4gICAgLy8gV2luZG93IGNvbnRhaW5zIGEgcGh5c2ljYWwgaXRlbVxuICAgIC8vIEZpbmQgb25lLCBzdGFydGluZyB3aXRoIHRoZSBvbmUgdGhhdCB3YXMgcHJldmlvdXNseSBmaXJzdCB2aXNpYmxlXG4gICAgbGV0IGNhbmRpZGF0ZUlkeCA9IHRoaXMuX2ZpcnN0VmlzaWJsZSAtIDE7XG4gICAgbGV0IGNNYXggPSAtSW5maW5pdHk7XG4gICAgd2hpbGUgKGNNYXggPCBsb3dlcikge1xuICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5fZ2V0UGh5c2ljYWxJdGVtKCsrY2FuZGlkYXRlSWR4KTtcbiAgICAgIGNNYXggPSBjYW5kaWRhdGUhLnBvcyArIHRoaXMuX21ldHJpY3NDYWNoZS5nZXRDaGlsZFNpemUoY2FuZGlkYXRlSWR4KSE7XG4gICAgfVxuICAgIHJldHVybiBjYW5kaWRhdGVJZHg7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBfZmlyc3QgYW5kIF9sYXN0IGJhc2VkIG9uIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50XG4gICAqIHZpZXdlZCByYW5nZS5cbiAgICovXG4gIF9nZXRBY3RpdmVJdGVtcygpIHtcbiAgICBpZiAodGhpcy5fdmlld0RpbTEgPT09IDAgfHwgdGhpcy5fdG90YWxJdGVtcyA9PT0gMCkge1xuICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9nZXRJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYW5nZSB0byBlbXB0eS5cbiAgICovXG4gIF9jbGVhckl0ZW1zKCkge1xuICAgIHRoaXMuX2ZpcnN0ID0gLTE7XG4gICAgdGhpcy5fbGFzdCA9IC0xO1xuICAgIHRoaXMuX3BoeXNpY2FsTWluID0gMDtcbiAgICB0aGlzLl9waHlzaWNhbE1heCA9IDA7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMuY2xlYXIoKTtcbiAgICB0aGlzLl9waHlzaWNhbEl0ZW1zID0gaXRlbXM7XG4gICAgdGhpcy5fc3RhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gICAqIFVwZGF0ZXMgX2ZpcnN0IGFuZCBfbGFzdCBiYXNlZCBvbiBpdGVtcyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAqL1xuICBfZ2V0SXRlbXMoKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9uZXdQaHlzaWNhbEl0ZW1zO1xuICAgIHRoaXMuX3N0YWJsZSA9IHRydWU7XG4gICAgbGV0IGxvd2VyLCB1cHBlcjtcblxuICAgIC8vIFRoZSBhbmNob3JJZHggaXMgdGhlIGFuY2hvciBhcm91bmQgd2hpY2ggd2UgcmVmbG93LiBJdCBpcyBkZXNpZ25lZCB0b1xuICAgIC8vIGFsbG93IGp1bXBpbmcgdG8gYW55IHBvaW50IG9mIHRoZSBzY3JvbGwgc2l6ZS4gV2UgY2hvb3NlIGl0IG9uY2UgYW5kXG4gICAgLy8gc3RpY2sgd2l0aCBpdCB1bnRpbCBzdGFibGUuIGZpcnN0IGFuZCBsYXN0IGFyZSBkZWR1Y2VkIGFyb3VuZCBpdC5cblxuICAgIC8vIElmIHdlIGhhdmUgYSBzY3JvbGxUb0luZGV4LCB3ZSBhbmNob3Igb24gdGhlIGdpdmVuXG4gICAgLy8gaW5kZXggYW5kIHNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFjY29yZGluZ2x5XG4gICAgaWYgKHRoaXMuX3Njcm9sbFRvSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5fYW5jaG9ySWR4ID0gTWF0aC5taW4odGhpcy5fc2Nyb2xsVG9JbmRleCwgdGhpcy5fdG90YWxJdGVtcyAtIDEpO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24odGhpcy5fYW5jaG9ySWR4KTtcbiAgICAgIHRoaXMuX3Njcm9sbElmTmVlZGVkKCk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmRzIG9mIHRoZSByZWdpb24gdG8gYmVcbiAgICAvLyByZW5kZXJlZCwgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gICAgbG93ZXIgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIHRoaXMuX292ZXJoYW5nOy8vbGVhZGluZ092ZXJoYW5nO1xuICAgIHVwcGVyID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSArIHRoaXMuX292ZXJoYW5nOy8vIHRyYWlsaW5nT3Zlcmhhbmc7XG5cbiAgICBpZiAodXBwZXIgPCAwIHx8IGxvd2VyID4gdGhpcy5fc2Nyb2xsU2l6ZSkge1xuICAgICAgdGhpcy5fY2xlYXJJdGVtcygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBzY3JvbGxpbmcgdG8gYSBzcGVjaWZpYyBpbmRleCBvciBpZiB3ZSBhcmUgZG9pbmcgYW5vdGhlclxuICAgIC8vIHBhc3MgdG8gc3RhYmlsaXplIGEgcHJldmlvdXNseSBzdGFydGVkIHJlZmxvdywgd2Ugd2lsbCBhbHJlYWR5XG4gICAgLy8gaGF2ZSBhbiBhbmNob3IuIElmIG5vdCwgZXN0YWJsaXNoIGFuIGFuY2hvciBub3cuXG4gICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gbnVsbCB8fCB0aGlzLl9hbmNob3JQb3MgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2FuY2hvcklkeCA9IHRoaXMuX2dldEFuY2hvcihsb3dlciwgdXBwZXIpO1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fZ2V0UG9zaXRpb24odGhpcy5fYW5jaG9ySWR4KTtcbiAgICB9XG5cbiAgICBsZXQgYW5jaG9yU2l6ZSA9IHRoaXMuX2dldFNpemUodGhpcy5fYW5jaG9ySWR4KTtcbiAgICBpZiAoYW5jaG9yU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgIGFuY2hvclNpemUgPSB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpO1xuICAgIH1cblxuICAgIGxldCBhbmNob3JMZWFkaW5nTWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fYW5jaG9ySWR4KSA/PyB0aGlzLl9tZXRyaWNzQ2FjaGUuYXZlcmFnZU1hcmdpblNpemU7XG4gICAgbGV0IGFuY2hvclRyYWlsaW5nTWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fYW5jaG9ySWR4ICsgMSkgPz8gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuXG4gICAgaWYgKHRoaXMuX2FuY2hvcklkeCA9PT0gMCkge1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gYW5jaG9yTGVhZGluZ01hcmdpbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYW5jaG9ySWR4ID09PSB0aGlzLl90b3RhbEl0ZW1zIC0gMSkge1xuICAgICAgdGhpcy5fYW5jaG9yUG9zID0gdGhpcy5fc2Nyb2xsU2l6ZSAtIGFuY2hvclRyYWlsaW5nTWFyZ2luIC0gYW5jaG9yU2l6ZTtcbiAgICB9XG5cbiAgICAvLyBBbmNob3IgbWlnaHQgYmUgb3V0c2lkZSBib3VuZHMsIHNvIHByZWZlciBjb3JyZWN0aW5nIHRoZSBlcnJvciBhbmQga2VlcFxuICAgIC8vIHRoYXQgYW5jaG9ySWR4LlxuICAgIGxldCBhbmNob3JFcnIgPSAwO1xuXG4gICAgaWYgKHRoaXMuX2FuY2hvclBvcyArIGFuY2hvclNpemUgKyBhbmNob3JUcmFpbGluZ01hcmdpbiA8IGxvd2VyKSB7XG4gICAgICBhbmNob3JFcnIgPSBsb3dlciAtICh0aGlzLl9hbmNob3JQb3MgKyBhbmNob3JTaXplICsgYW5jaG9yVHJhaWxpbmdNYXJnaW4pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmNob3JQb3MgLSBhbmNob3JMZWFkaW5nTWFyZ2luID4gdXBwZXIpIHtcbiAgICAgIGFuY2hvckVyciA9IHVwcGVyIC0gKHRoaXMuX2FuY2hvclBvcyAtIGFuY2hvckxlYWRpbmdNYXJnaW4pO1xuICAgIH1cblxuICAgIGlmIChhbmNob3JFcnIpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uIC09IGFuY2hvckVycjtcbiAgICAgIGxvd2VyIC09IGFuY2hvckVycjtcbiAgICAgIHVwcGVyIC09IGFuY2hvckVycjtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yICs9IGFuY2hvckVycjtcbiAgICB9XG5cbiAgICBpdGVtcy5zZXQodGhpcy5fYW5jaG9ySWR4LCB7cG9zOiB0aGlzLl9hbmNob3JQb3MsIHNpemU6IGFuY2hvclNpemV9KTtcblxuICAgIHRoaXMuX2ZpcnN0ID0gKHRoaXMuX2xhc3QgPSB0aGlzLl9hbmNob3JJZHgpO1xuICAgIHRoaXMuX3BoeXNpY2FsTWluID0gdGhpcy5fYW5jaG9yUG9zO1xuICAgIHRoaXMuX3BoeXNpY2FsTWF4ID0gdGhpcy5fYW5jaG9yUG9zICsgYW5jaG9yU2l6ZTtcblxuICAgIHdoaWxlICh0aGlzLl9waHlzaWNhbE1pbiA+IGxvd2VyICYmIHRoaXMuX2ZpcnN0ID4gMCkge1xuICAgICAgbGV0IHNpemUgPSB0aGlzLl9nZXRTaXplKC0tdGhpcy5fZmlyc3QpO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEF2ZXJhZ2VTaXplKCk7XG4gICAgICB9XG4gICAgICBsZXQgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUodGhpcy5fZmlyc3QgKyAxKTtcbiAgICAgIGlmIChtYXJnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGh5c2ljYWxNaW4gLT0gc2l6ZSArIG1hcmdpbjtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3BoeXNpY2FsTWluO1xuICAgICAgaXRlbXMuc2V0KHRoaXMuX2ZpcnN0LCB7cG9zLCBzaXplfSk7XG4gICAgICBpZiAodGhpcy5fc3RhYmxlID09PSBmYWxzZSAmJiB0aGlzLl9lc3RpbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuX3BoeXNpY2FsTWF4IDwgdXBwZXIgJiYgdGhpcy5fbGFzdCA8IHRoaXMuX3RvdGFsSXRlbXMgLSAxKSB7XG4gICAgICBsZXQgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUoKyt0aGlzLl9sYXN0KTtcbiAgICAgIGlmIChtYXJnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgbWFyZ2luID0gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplO1xuICAgICAgfVxuICAgICAgbGV0IHNpemUgPSB0aGlzLl9nZXRTaXplKHRoaXMuX2xhc3QpO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9zdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc2l6ZSA9IHRoaXMuX2dldEF2ZXJhZ2VTaXplKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3MgPSB0aGlzLl9waHlzaWNhbE1heCArIG1hcmdpbjtcbiAgICAgIGl0ZW1zLnNldCh0aGlzLl9sYXN0LCB7cG9zLCBzaXplfSk7XG4gICAgICB0aGlzLl9waHlzaWNhbE1heCArPSBtYXJnaW4gKyBzaXplO1xuICAgICAgaWYgKHRoaXMuX3N0YWJsZSA9PT0gZmFsc2UgJiYgdGhpcy5fZXN0aW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZXMgd2hlcmUgd2Ugd2VyZSByZWx5aW5nIG9uIGVzdGltYXRlZCBzaXplcy5cbiAgICBjb25zdCBleHRlbnRFcnIgPSB0aGlzLl9jYWxjdWxhdGVFcnJvcigpO1xuICAgIGlmIChleHRlbnRFcnIpIHtcbiAgICAgIHRoaXMuX3BoeXNpY2FsTWluIC09IGV4dGVudEVycjtcbiAgICAgIHRoaXMuX3BoeXNpY2FsTWF4IC09IGV4dGVudEVycjtcbiAgICAgIHRoaXMuX2FuY2hvclBvcyAtPSBleHRlbnRFcnI7XG4gICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtPSBleHRlbnRFcnI7XG4gICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiBpdGVtLnBvcyAtPSBleHRlbnRFcnIpO1xuICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gZXh0ZW50RXJyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdGFibGUpIHtcbiAgICAgIHRoaXMuX25ld1BoeXNpY2FsSXRlbXMgPSB0aGlzLl9waHlzaWNhbEl0ZW1zO1xuICAgICAgdGhpcy5fbmV3UGh5c2ljYWxJdGVtcy5jbGVhcigpO1xuICAgICAgdGhpcy5fcGh5c2ljYWxJdGVtcyA9IGl0ZW1zO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVFcnJvcigpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYXZlcmFnZU1hcmdpblNpemUgfSA9IHRoaXMuX21ldHJpY3NDYWNoZTtcbiAgICBpZiAodGhpcy5fZmlyc3QgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9waHlzaWNhbE1pbiAtICh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSgwKSA/PyBhdmVyYWdlTWFyZ2luU2l6ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9waHlzaWNhbE1pbiA8PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGh5c2ljYWxNaW4gLSAodGhpcy5fZmlyc3QgKiB0aGlzLl9kZWx0YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0ID09PSB0aGlzLl90b3RhbEl0ZW1zIC0gMSkge1xuICAgICAgcmV0dXJuICh0aGlzLl9waHlzaWNhbE1heCArICh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TWFyZ2luU2l6ZSh0aGlzLl90b3RhbEl0ZW1zKSA/PyBhdmVyYWdlTWFyZ2luU2l6ZSkpIC0gdGhpcy5fc2Nyb2xsU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3BoeXNpY2FsTWF4ID49IHRoaXMuX3Njcm9sbFNpemUpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHRoaXMuX3BoeXNpY2FsTWF4IC0gdGhpcy5fc2Nyb2xsU2l6ZSkgK1xuICAgICAgICAgICgodGhpcy5fdG90YWxJdGVtcyAtIDEgLSB0aGlzLl9sYXN0KSAqIHRoaXMuX2RlbHRhKSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gVE9ETzogQ2FuIHRoaXMgYmUgbWFkZSB0byBpbmhlcml0IGZyb20gYmFzZSwgd2l0aCBwcm9wZXIgaG9va3M/XG4gIF9yZWZsb3coKSB7XG4gICAgY29uc3Qge19maXJzdCwgX2xhc3QsIF9zY3JvbGxTaXplfSA9IHRoaXM7XG5cbiAgICB0aGlzLl91cGRhdGVTY3JvbGxTaXplKCk7XG4gICAgdGhpcy5fZ2V0QWN0aXZlSXRlbXMoKTtcblxuICAgIGlmICh0aGlzLl9zY3JvbGxTaXplICE9PSBfc2Nyb2xsU2l6ZSkge1xuICAgICAgdGhpcy5fZW1pdFNjcm9sbFNpemUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVWaXNpYmxlSW5kaWNlcygpO1xuICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgJiYgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX3Jlc2V0UmVmbG93U3RhdGUoKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0aGlzLl9maXJzdCAhPT0gX2ZpcnN0IHx8IHRoaXMuX2xhc3QgIT09IF9sYXN0IHx8XG4gICAgICAgIHRoaXMuX25lZWRzUmVtZWFzdXJlKSB7XG4gICAgICB0aGlzLl9lbWl0Q2hpbGRQb3NpdGlvbnMoKTtcbiAgICAgIHRoaXMuX2VtaXRTY3JvbGxFcnJvcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0Q2hpbGRQb3NpdGlvbnMoKTtcbiAgICAgIHRoaXMuX2VtaXRTY3JvbGxFcnJvcigpO1xuICAgICAgdGhpcy5fcmVzZXRSZWZsb3dTdGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXNldFJlZmxvd1N0YXRlKCkge1xuICAgIHRoaXMuX2FuY2hvcklkeCA9IG51bGw7XG4gICAgdGhpcy5fYW5jaG9yUG9zID0gbnVsbDtcbiAgICB0aGlzLl9zdGFibGUgPSB0cnVlO1xuICB9XG5cbiAgX3VwZGF0ZVNjcm9sbFNpemUoKSB7XG4gICAgY29uc3QgeyBhdmVyYWdlTWFyZ2luU2l6ZSB9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHRoaXMuX3Njcm9sbFNpemUgPSBNYXRoLm1heCgxLCB0aGlzLl90b3RhbEl0ZW1zICogKGF2ZXJhZ2VNYXJnaW5TaXplICsgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSkgKyBhdmVyYWdlTWFyZ2luU2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXZlcmFnZSBzaXplIChwcmVjaXNlIG9yIGVzdGltYXRlZCkgb2YgYW4gaXRlbSBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbixcbiAgICogaW5jbHVkaW5nIGFueSBzdXJyb3VuZGluZyBzcGFjZS5cbiAgICovXG4gIHByb3RlY3RlZCBnZXQgX2RlbHRhKCk6IG51bWJlciB7XG4gICAgY29uc3QgeyBhdmVyYWdlTWFyZ2luU2l6ZSB9ID0gdGhpcy5fbWV0cmljc0NhY2hlO1xuICAgIHJldHVybiB0aGlzLl9nZXRBdmVyYWdlU2l6ZSgpICsgYXZlcmFnZU1hcmdpblNpemU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9uaW5nIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIF9nZXRJdGVtUG9zaXRpb24oaWR4OiBudW1iZXIpOiBQb3NpdGlvbnMge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fcG9zaXRpb25EaW1dOiB0aGlzLl9nZXRQb3NpdGlvbihpZHgpLFxuICAgICAgW3RoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltXTogMCxcbiAgICAgIFtvZmZzZXQodGhpcy5kaXJlY3Rpb24pXTogLSh0aGlzLl9tZXRyaWNzQ2FjaGUuZ2V0TGVhZGluZ01hcmdpblZhbHVlKGlkeCwgdGhpcy5kaXJlY3Rpb24pID8/IHRoaXMuX21ldHJpY3NDYWNoZS5hdmVyYWdlTWFyZ2luU2l6ZSlcbiAgICB9IGFzIFBvc2l0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIF9nZXRJdGVtU2l6ZShpZHg6IG51bWJlcik6IFNpemUge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fc2l6ZURpbV06ICh0aGlzLl9nZXRTaXplKGlkeCkgfHwgdGhpcy5fZ2V0QXZlcmFnZVNpemUoKSkgKyAodGhpcy5fbWV0cmljc0NhY2hlLmdldE1hcmdpblNpemUoaWR4ICsgMSkgPz8gdGhpcy5fbWV0cmljc0NhY2hlLmF2ZXJhZ2VNYXJnaW5TaXplKSxcbiAgICAgIFt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTogdGhpcy5faXRlbVNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV1cbiAgICB9IGFzIFNpemU7XG4gIH1cblxuICBfdmlld0RpbTJDaGFuZ2VkKCkge1xuICAgIHRoaXMuX25lZWRzUmVtZWFzdXJlID0gdHJ1ZTtcbiAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICB9XG5cbiAgX2VtaXRSYW5nZSgpIHtcbiAgICBjb25zdCByZW1lYXN1cmUgPSB0aGlzLl9uZWVkc1JlbWVhc3VyZTtcbiAgICBjb25zdCBzdGFibGUgPSB0aGlzLl9zdGFibGU7XG4gICAgdGhpcy5fbmVlZHNSZW1lYXN1cmUgPSBmYWxzZTtcbiAgICBzdXBlci5fZW1pdFJhbmdlKHtyZW1lYXN1cmUsIHN0YWJsZX0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/flow.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SizeCache\": function() { return /* binding */ SizeCache; }\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SizeCache = /*#__PURE__*/function () {\n  function SizeCache(config) {\n    _classCallCheck(this, SizeCache);\n\n    this._map = new Map();\n    this._roundAverageSize = true;\n    this.totalSize = 0;\n\n    if ((config === null || config === void 0 ? void 0 : config.roundAverageSize) === false) {\n      this._roundAverageSize = false;\n    }\n  }\n\n  _createClass(SizeCache, [{\n    key: \"set\",\n    value: function set(index, value) {\n      var prev = this._map.get(index) || 0;\n\n      this._map.set(index, value);\n\n      this.totalSize += value - prev;\n    }\n  }, {\n    key: \"averageSize\",\n    get: function get() {\n      if (this._map.size > 0) {\n        var average = this.totalSize / this._map.size;\n        return this._roundAverageSize ? Math.round(average) : average;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize(index) {\n      return this._map.get(index);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._map.clear();\n\n      this.totalSize = 0;\n    }\n  }]);\n\n  return SizeCache;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL1NpemVDYWNoZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBSUE7QUFLQTtBQUFBOztBQUpBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQUFBO0FBQUE7QUFZQTs7QUFDQTs7QUFDQTtBQUNBO0FBZkE7QUFBQTtBQUFBO0FBa0JBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUF6QkE7QUFBQTtBQUFBO0FBNEJBO0FBQ0E7QUE3QkE7QUFBQTtBQUFBO0FBZ0NBOztBQUNBO0FBQ0E7QUFsQ0E7O0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL3NyYy9sYXlvdXRzL3NoYXJlZC9TaXplQ2FjaGUudHM/N2NiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgaW50ZXJmYWNlIFNpemVDYWNoZUNvbmZpZyB7XG4gICAgcm91bmRBdmVyYWdlU2l6ZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFNpemVDYWNoZSB7XG4gICAgcHJpdmF0ZSBfbWFwOiBNYXA8bnVtYmVyIHwgc3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICAgIHByaXZhdGUgX3JvdW5kQXZlcmFnZVNpemUgPSB0cnVlO1xuICAgIHRvdGFsU2l6ZTogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZz86IFNpemVDYWNoZUNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnPy5yb3VuZEF2ZXJhZ2VTaXplID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fcm91bmRBdmVyYWdlU2l6ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICBcbiAgICBzZXQoaW5kZXg6IG51bWJlciB8IHN0cmluZywgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX21hcC5nZXQoaW5kZXgpIHx8IDA7XG4gICAgICB0aGlzLl9tYXAuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgICB0aGlzLnRvdGFsU2l6ZSArPSB2YWx1ZSAtIHByZXY7XG4gICAgfVxuICBcbiAgICBnZXQgYXZlcmFnZVNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX21hcC5zaXplID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXZlcmFnZSA9IHRoaXMudG90YWxTaXplIC8gdGhpcy5fbWFwLnNpemU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRBdmVyYWdlU2l6ZVxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKGF2ZXJhZ2UpXG4gICAgICAgICAgICA6IGF2ZXJhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICBcbiAgICBnZXRTaXplKGluZGV4OiBudW1iZXIgfCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGluZGV4KTtcbiAgICB9XG4gIFxuICAgIGNsZWFyKCkge1xuICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICB0aGlzLnRvdGFsU2l6ZSA9IDA7XG4gICAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js\n");

/***/ })

}]);