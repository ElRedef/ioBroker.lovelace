"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dim1\": function() { return /* binding */ dim1; },\n/* harmony export */   \"dim2\": function() { return /* binding */ dim2; },\n/* harmony export */   \"pos1\": function() { return /* binding */ pos1; },\n/* harmony export */   \"pos2\": function() { return /* binding */ pos2; },\n/* harmony export */   \"BaseLayout\": function() { return /* binding */ BaseLayout; }\n/* harmony export */ });\n/* harmony import */ var _polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../polyfillLoaders/EventTarget.js */ \"./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nfunction dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nfunction dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nfunction pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nfunction pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nvar BaseLayout = /*#__PURE__*/function () {\n  function BaseLayout(config) {\n    var _this = this;\n\n    _classCallCheck(this, BaseLayout);\n\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    /**\n     * Index of the item that has been scrolled to via the public API. When the\n     * viewport is otherwise scrolled, this value is set back to -1.\n     */\n\n    this._scrollToIndex = -1;\n    /**\n     * When a child is scrolled to, the offset from the top of the child and the\n     * top of the viewport. Value is a proportion of the item size.\n     */\n\n    this._scrollToAnchor = 0;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n\n    this._lastVisible = 0;\n    this._eventTargetPromise = (0,_polyfillLoaders_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().then(function (Ctor) {\n      _this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n\n    this._totalItems = 0;\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n\n    this._overhang = 1000;\n    this._eventTarget = null; // Delay setting config so that subclasses do setup work first\n\n    Promise.resolve().then(function () {\n      return _this.config = config || _this._defaultConfig;\n    });\n  }\n\n  _createClass(BaseLayout, [{\n    key: \"_defaultConfig\",\n    get: function get() {\n      return {\n        direction: 'vertical'\n      };\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return {\n        direction: this.direction\n      };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    ,\n    set: function set(config) {\n      Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n  }, {\n    key: \"totalItems\",\n    get: function get() {\n      return this._totalItems;\n    },\n    set: function set(num) {\n      var _num = Number(num);\n\n      if (_num !== this._totalItems) {\n        this._totalItems = _num;\n\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    },\n    set: function set(dir) {\n      // Force it to be either horizontal or vertical.\n      dir = dir === 'horizontal' ? dir : 'vertical';\n\n      if (dir !== this._direction) {\n        this._direction = dir;\n        this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n        this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n        this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n        this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n\n        this._triggerReflow();\n      }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n\n  }, {\n    key: \"viewportSize\",\n    get: function get() {\n      return this._viewportSize;\n    },\n    set: function set(dims) {\n      var _viewDim1 = this._viewDim1,\n          _viewDim2 = this._viewDim2;\n      Object.assign(this._viewportSize, dims);\n\n      if (_viewDim2 !== this._viewDim2) {\n        // this._viewDim2Changed();\n        this._scheduleLayoutUpdate();\n      } else if (_viewDim1 !== this._viewDim1) {\n        this._checkThresholds();\n      }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n\n  }, {\n    key: \"viewportScroll\",\n    get: function get() {\n      return this._latestCoords;\n    },\n    set: function set(coords) {\n      Object.assign(this._latestCoords, coords);\n      var oldPos = this._scrollPosition;\n      this._scrollPosition = this._latestCoords[this._positionDim];\n\n      if (oldPos !== this._scrollPosition) {\n        this._scrollPositionChanged(oldPos, this._scrollPosition);\n\n        this._updateVisibleIndices({\n          emit: true\n        });\n      }\n\n      this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n\n  }, {\n    key: \"reflowIfNeeded\",\n    value: function reflowIfNeeded() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (force || this._pendingReflow) {\n        this._pendingReflow = false;\n\n        this._reflow();\n      }\n    }\n    /**\n     * Scroll to the child at the given index, and the given position within that\n     * child.\n     */\n\n  }, {\n    key: \"scrollToIndex\",\n    value: function scrollToIndex(index) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'start';\n      if (!Number.isFinite(index)) return;\n      index = Math.min(this.totalItems, Math.max(0, index));\n      this._scrollToIndex = index;\n\n      if (position === 'nearest') {\n        position = index > this._first + this._num / 2 ? 'end' : 'start';\n      }\n\n      switch (position) {\n        case 'start':\n          this._scrollToAnchor = 0;\n          break;\n\n        case 'center':\n          this._scrollToAnchor = 0.5;\n          break;\n\n        case 'end':\n          this._scrollToAnchor = 1;\n          break;\n\n        default:\n          throw new TypeError('position must be one of: start, center, end, nearest');\n      }\n\n      this._scheduleReflow();\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function () {\n      var _dispatchEvent = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(evt) {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._eventTargetPromise;\n\n              case 2:\n                this._eventTarget.dispatchEvent(evt);\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function dispatchEvent(_x) {\n        return _dispatchEvent.apply(this, arguments);\n      }\n\n      return dispatchEvent;\n    }()\n  }, {\n    key: \"addEventListener\",\n    value: function () {\n      var _addEventListener = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(type, listener, options) {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._eventTargetPromise;\n\n              case 2:\n                this._eventTarget.addEventListener(type, listener, options);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function addEventListener(_x2, _x3, _x4) {\n        return _addEventListener.apply(this, arguments);\n      }\n\n      return addEventListener;\n    }()\n  }, {\n    key: \"removeEventListener\",\n    value: function () {\n      var _removeEventListener = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(type, callback, options) {\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._eventTargetPromise;\n\n              case 2:\n                this._eventTarget.removeEventListener(type, callback, options);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function removeEventListener(_x5, _x6, _x7) {\n        return _removeEventListener.apply(this, arguments);\n      }\n\n      return removeEventListener;\n    }()\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout() {// Override\n    } // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n\n  }, {\n    key: \"_viewDim1\",\n    get: function get() {\n      return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n\n  }, {\n    key: \"_viewDim2\",\n    get: function get() {\n      return this._viewportSize[this._secondarySizeDim];\n    }\n  }, {\n    key: \"_scheduleReflow\",\n    value: function _scheduleReflow() {\n      this._pendingReflow = true;\n    }\n  }, {\n    key: \"_scheduleLayoutUpdate\",\n    value: function _scheduleLayoutUpdate() {\n      this._pendingLayoutUpdate = true;\n\n      this._scheduleReflow();\n    } // For triggering a reflow based on incoming changes to\n    // the layout config.\n\n  }, {\n    key: \"_triggerReflow\",\n    value: function _triggerReflow() {\n      var _this2 = this;\n\n      this._scheduleLayoutUpdate(); // TODO graynorton@: reflowIfNeeded() isn't really supposed\n      // to be called internally. Address in larger cleanup\n      // of virtualizer / layout interaction pattern.\n      // this.reflowIfNeeded(true);\n\n\n      Promise.resolve().then(function () {\n        return _this2.reflowIfNeeded();\n      });\n    }\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      if (this._pendingLayoutUpdate) {\n        this._updateLayout();\n\n        this._pendingLayoutUpdate = false;\n      }\n\n      this._updateScrollSize();\n\n      this._getActiveItems();\n\n      this._scrollIfNeeded();\n\n      this._updateVisibleIndices();\n\n      this._emitScrollSize();\n\n      this._emitRange();\n\n      this._emitChildPositions();\n\n      this._emitScrollError();\n    }\n  }, {\n    key: \"_scrollIfNeeded\",\n    value: function _scrollIfNeeded() {\n      if (this._scrollToIndex === -1) {\n        return;\n      }\n\n      var index = this._scrollToIndex;\n      var anchor = this._scrollToAnchor;\n\n      var pos = this._getItemPosition(index)[this._positionDim];\n\n      var size = this._getItemSize(index)[this._sizeDim];\n\n      var curAnchorPos = this._scrollPosition + this._viewDim1 * anchor;\n      var newAnchorPos = pos + size * anchor; // Ensure scroll position is an integer within scroll bounds.\n\n      var scrollPosition = Math.floor(Math.min(this._scrollSize - this._viewDim1, Math.max(0, this._scrollPosition - curAnchorPos + newAnchorPos)));\n      this._scrollError += this._scrollPosition - scrollPosition;\n      this._scrollPosition = scrollPosition;\n    }\n  }, {\n    key: \"_emitRange\",\n    value: function _emitRange() {\n      var inProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n      var detail = Object.assign({\n        first: this._first,\n        last: this._last,\n        num: this._num,\n        stable: true,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      }, inProps);\n      this.dispatchEvent(new CustomEvent('rangechange', {\n        detail: detail\n      }));\n    }\n  }, {\n    key: \"_emitScrollSize\",\n    value: function _emitScrollSize() {\n      var detail = _defineProperty({}, this._sizeDim, this._scrollSize);\n\n      this.dispatchEvent(new CustomEvent('scrollsizechange', {\n        detail: detail\n      }));\n    }\n  }, {\n    key: \"_emitScrollError\",\n    value: function _emitScrollError() {\n      if (this._scrollError) {\n        var _detail2;\n\n        var detail = (_detail2 = {}, _defineProperty(_detail2, this._positionDim, this._scrollError), _defineProperty(_detail2, this._secondaryPositionDim, 0), _detail2);\n        this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n          detail: detail\n        }));\n        this._scrollError = 0;\n      }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n\n  }, {\n    key: \"_emitChildPositions\",\n    value: function _emitChildPositions() {\n      var detail = {};\n\n      for (var idx = this._first; idx <= this._last; idx++) {\n        detail[idx] = this._getItemPosition(idx);\n      }\n\n      this.dispatchEvent(new CustomEvent('itempositionchange', {\n        detail: detail\n      }));\n    }\n    /**\n     * Number of items to display.\n     */\n\n  }, {\n    key: \"_num\",\n    get: function get() {\n      if (this._first === -1 || this._last === -1) {\n        return 0;\n      }\n\n      return this._last - this._first + 1;\n    }\n  }, {\n    key: \"_checkThresholds\",\n    value: function _checkThresholds() {\n      if (this._viewDim1 === 0 && this._num > 0) {\n        this._scheduleReflow();\n      } else {\n        var min = Math.max(0, this._scrollPosition - this._overhang);\n        var max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n\n        if (this._physicalMin > min || this._physicalMax < max) {\n          this._scheduleReflow();\n        }\n      }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n\n  }, {\n    key: \"_updateVisibleIndices\",\n    value: function _updateVisibleIndices(options) {\n      if (this._first === -1 || this._last === -1) return;\n      var firstVisible = this._first;\n\n      while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n        firstVisible++;\n      }\n\n      var lastVisible = this._last;\n\n      while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n        lastVisible--;\n      }\n\n      if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n        this._firstVisible = firstVisible;\n        this._lastVisible = lastVisible;\n\n        if (options && options.emit) {\n          this._emitRange();\n        }\n      }\n    }\n  }, {\n    key: \"_scrollPositionChanged\",\n    value: function _scrollPositionChanged(oldPos, newPos) {\n      // When both values are bigger than the max scroll position, keep the\n      // current _scrollToIndex, otherwise invalidate it.\n      var maxPos = this._scrollSize - this._viewDim1;\n\n      if (oldPos < maxPos || newPos < maxPos) {\n        this._scrollToIndex = -1;\n      }\n    }\n  }]);\n\n  return BaseLayout;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBV0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUErSEE7QUFBQTs7QUFBQTs7QUE5SEE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFFQTs7QUFDQTtBQUVBO0FBRUE7OztBQUdBOztBQUNBO0FBRUE7OztBQUdBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBOztBQVVBO0FBQUE7QUFBQTtBQUNBOztBQWxJQTtBQUFBO0FBQUE7QUEwSEE7QUFDQTtBQURBO0FBR0E7QUE3SEE7QUFBQTtBQUFBO0FBeUlBO0FBQ0E7QUFEQTtBQUdBO0FBRUE7OztBQUdBO0FBakpBO0FBQUE7QUFxSUE7QUFDQTtBQXRJQTtBQUFBO0FBQUE7QUFtSkE7QUFDQTtBQXBKQTtBQXNKQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBOztBQS9KQTtBQUFBO0FBQUE7QUFpS0E7QUFDQTtBQWxLQTtBQW9LQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFsTEE7QUFBQTtBQUFBO0FBb0xBO0FBQ0E7QUFyTEE7QUF1TEE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7O0FBbk1BO0FBQUE7QUFBQTtBQXFNQTtBQUNBO0FBdE1BO0FBd01BO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7QUFwTkE7QUFBQTtBQUFBO0FBcU5BOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBOztBQS9OQTtBQUFBO0FBQUE7QUFnT0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVhBOztBQWNBO0FBQ0E7QUF2UEE7QUFBQTtBQUFBO0FBQUE7QUF5UEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBRUE7O0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBelBBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUE4UEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBRUE7O0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBOVBBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFtUUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBRUE7O0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBblFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ1NBO0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUF4U0E7QUFBQTtBQUFBO0FBMFNBO0FBQ0E7QUFFQTs7QUFFQTs7QUEvU0E7QUFBQTtBQUFBO0FBaVRBO0FBQ0E7QUFsVEE7QUFBQTtBQUFBO0FBcVRBO0FBQ0E7QUF0VEE7QUFBQTtBQUFBO0FBeVRBOztBQUNBO0FBQ0E7QUFHQTs7QUE5VEE7QUFBQTtBQUFBO0FBK1RBOztBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQXRVQTtBQUFBO0FBQUE7QUF5VUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFyVkE7QUFBQTtBQUFBO0FBd1ZBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUF4V0E7QUFBQTtBQUFBO0FBMFdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQUE7QUFBQTtBQUNBO0FBdFhBO0FBQUE7QUFBQTtBQXlYQTs7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQTdYQTtBQUFBO0FBQUE7QUFnWUE7QUFBQTs7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7QUE3WUE7QUFBQTtBQUFBO0FBK1lBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUVBOztBQXhaQTtBQUFBO0FBQUE7QUEwWkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUE5WkE7QUFBQTtBQUFBO0FBaWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7QUFqYkE7QUFBQTtBQUFBO0FBbWJBO0FBRUE7O0FBQ0E7QUFTQTtBQUNBOztBQUVBOztBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5kQTtBQUFBO0FBQUE7QUFzZEE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNWRBOztBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi8uLi9zcmMvbGF5b3V0cy9zaGFyZWQvQmFzZUxheW91dC50cz9kZDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQgRXZlbnRUYXJnZXQgZnJvbSAnLi4vLi4vcG9seWZpbGxMb2FkZXJzL0V2ZW50VGFyZ2V0LmpzJztcbmltcG9ydCB7TGF5b3V0LCBQb3NpdGlvbnMsIFNjcm9sbERpcmVjdGlvbiwgU2l6ZSwgZGltZW5zaW9uLCBwb3NpdGlvbn0gZnJvbSAnLi9MYXlvdXQuanMnO1xuXG50eXBlIFVwZGF0ZVZpc2libGVJbmRpY2VzT3B0aW9ucyA9IHtcbiAgZW1pdD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlTGF5b3V0Q29uZmlnIHtcbiAgZGlyZWN0aW9uPzogU2Nyb2xsRGlyZWN0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW0xKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogZGltZW5zaW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJzogJ2hlaWdodCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW0yKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogZGltZW5zaW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hlaWdodCc6ICd3aWR0aCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3MxKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogcG9zaXRpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbGVmdCc6ICd0b3AnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zMihkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IHBvc2l0aW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3RvcCc6ICdsZWZ0Jztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VMYXlvdXQ8QyBleHRlbmRzIEJhc2VMYXlvdXRDb25maWc+IGltcGxlbWVudHMgTGF5b3V0IHtcbiAgLyoqXG4gICAqIFRoZSBsYXN0IHNldCB2aWV3cG9ydCBzY3JvbGwgcG9zaXRpb24uXG4gICAqL1xuICBwcml2YXRlIF9sYXRlc3RDb29yZHM6IFBvc2l0aW9ucyA9IHtsZWZ0OiAwLCB0b3A6IDB9O1xuXG4gIC8qKlxuICAgKiBTY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogRGltZW5zaW9ucyBvZiB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF92aWV3cG9ydFNpemU6IFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIGRlYm91bmNpbmcgYXN5bmNobnJvbm91cyByZWZsb3cgcmVxdWVzdHMuXG4gICAqL1xuICBwcml2YXRlIF9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfcGVuZGluZ0xheW91dFVwZGF0ZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgaXRlbSB0aGF0IGhhcyBiZWVuIHNjcm9sbGVkIHRvIHZpYSB0aGUgcHVibGljIEFQSS4gV2hlbiB0aGVcbiAgICogdmlld3BvcnQgaXMgb3RoZXJ3aXNlIHNjcm9sbGVkLCB0aGlzIHZhbHVlIGlzIHNldCBiYWNrIHRvIC0xLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zY3JvbGxUb0luZGV4ID0gLTE7XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBjaGlsZCBpcyBzY3JvbGxlZCB0bywgdGhlIG9mZnNldCBmcm9tIHRoZSB0b3Agb2YgdGhlIGNoaWxkIGFuZCB0aGVcbiAgICogdG9wIG9mIHRoZSB2aWV3cG9ydC4gVmFsdWUgaXMgYSBwcm9wb3J0aW9uIG9mIHRoZSBpdGVtIHNpemUuXG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxUb0FuY2hvciA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9maXJzdFZpc2libGUgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0VmlzaWJsZSA9IDA7XG5cbiAgcHJpdmF0ZSBfZXZlbnRUYXJnZXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+ID0gKEV2ZW50VGFyZ2V0KCkudGhlbigoQ3RvcikgPT4ge1xuICAgIHRoaXMuX2V2ZW50VGFyZ2V0ID0gbmV3IEN0b3IoKTtcbiAgfSkpO1xuXG4gIC8qKlxuICAgKiBQaXhlbCBvZmZzZXQgaW4gdGhlIHNjcm9sbCBkaXJlY3Rpb24gb2YgdGhlIGZpcnN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9waHlzaWNhbE1pbiA9IDA7XG5cbiAgLyoqXG4gICAqIFBpeGVsIG9mZnNldCBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgbGFzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfcGh5c2ljYWxNYXggPSAwO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2ZpcnN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2l6ZURpbTogZGltZW5zaW9uID0gJ2hlaWdodCc7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBpbiB0aGUgbm9uLXNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlY29uZGFyeVNpemVEaW06IGRpbWVuc2lvbiA9ICd3aWR0aCc7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9wb3NpdGlvbkRpbTogcG9zaXRpb24gPSAndG9wJztcblxuICAvKipcbiAgICogUG9zaXRpb24gaW4gdGhlIG5vbi1zY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZWNvbmRhcnlQb3NpdGlvbkRpbTogcG9zaXRpb24gPSAnbGVmdCc7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Nyb2xsIG9mZnNldCBpbiBwaXhlbHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFBvc2l0aW9uID0gMDtcblxuICAvKipcbiAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgc2Nyb2xsIG9mZnNldCBhbmQgc2Nyb2xsIG9mZnNldCBjYWxjdWxhdGVkIGR1ZVxuICAgKiB0byBhIHJlZmxvdy5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsRXJyb3IgPSAwO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgaXRlbXMgdGhhdCBjb3VsZCBwb3NzaWJseSBiZSBkaXNwbGF5ZWQuIFVzZWQgdG8gaGVscFxuICAgKiBjYWxjdWxhdGUgdGhlIHNjcm9sbCBzaXplLlxuICAgKi9cbiAgcHJvdGVjdGVkIF90b3RhbEl0ZW1zID0gMDtcblxuICAvKipcbiAgICogVGhlIHRvdGFsIChlc3RpbWF0ZWQpIGxlbmd0aCBvZiBhbGwgaXRlbXMgaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFNpemUgPSAxO1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJleW9uZCB0aGUgdmlld3BvcnQgdG8gc3RpbGwgaW5jbHVkZVxuICAgKiBpbiB0aGUgYWN0aXZlIHJhbmdlIG9mIGl0ZW1zLlxuICAgKi9cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFByb2JhYmx5IHdhbnQgdG8gbWFrZSB0aGlzIHNvbWV0aGluZyB3ZSBjYWxjdWxhdGUgYmFzZWRcbiAgLy8gb24gdmlld3BvcnQgc2l6ZSwgaXRlbSBzaXplLCBvdGhlciBmYWN0b3JzLCBwb3NzaWJseSBzdGlsbCB3aXRoIGEgZGlhbCBvZiBzb21lIGtpbmRcbiAgcHJvdGVjdGVkIF9vdmVyaGFuZyA9IDEwMDA7XG5cbiAgcHJpdmF0ZSBfZXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJvdGVjdGVkIGdldCBfZGVmYXVsdENvbmZpZygpIDogQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJ1xuICAgIH0gYXMgQ1xuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlnPzogQykge1xuICAgIC8vIERlbGF5IHNldHRpbmcgY29uZmlnIHNvIHRoYXQgc3ViY2xhc3NlcyBkbyBzZXR1cCB3b3JrIGZpcnN0XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB0aGlzLl9kZWZhdWx0Q29uZmlnKTtcbiAgfVxuXG4gIHNldCBjb25maWcoY29uZmlnOiBDKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kZWZhdWx0Q29uZmlnLCBjb25maWcpKTtcbiAgfVxuXG4gIGdldCBjb25maWcoKTogQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb25cbiAgICB9IGFzIEM7XG4gIH1cblxuICAvKipcbiAgICogTWF4aW11bSBpbmRleCBvZiBjaGlsZHJlbiArIDEsIHRvIGhlbHAgZXN0aW1hdGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBzY3JvbGxcbiAgICogc3BhY2UuXG4gICAqL1xuICBnZXQgdG90YWxJdGVtcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl90b3RhbEl0ZW1zO1xuICB9XG4gIHNldCB0b3RhbEl0ZW1zKG51bSkge1xuICAgIGNvbnN0IF9udW0gPSBOdW1iZXIobnVtKTtcbiAgICBpZiAoX251bSAhPT0gdGhpcy5fdG90YWxJdGVtcykge1xuICAgICAgdGhpcy5fdG90YWxJdGVtcyA9IF9udW07XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmltYXJ5IHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBnZXQgZGlyZWN0aW9uKCk6IFNjcm9sbERpcmVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbiE7XG4gIH1cbiAgc2V0IGRpcmVjdGlvbihkaXIpIHtcbiAgICAvLyBGb3JjZSBpdCB0byBiZSBlaXRoZXIgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbC5cbiAgICBkaXIgPSAoZGlyID09PSAnaG9yaXpvbnRhbCcpID8gZGlyIDogJ3ZlcnRpY2FsJztcbiAgICBpZiAoZGlyICE9PSB0aGlzLl9kaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuX3NpemVEaW0gPSAoZGlyID09PSAnaG9yaXpvbnRhbCcpID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbSA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICB0aGlzLl9wb3NpdGlvbkRpbSA9IChkaXIgPT09ICdob3Jpem9udGFsJykgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHRoaXMuX3NlY29uZGFyeVBvc2l0aW9uRGltID0gKGRpciA9PT0gJ2hvcml6b250YWwnKSA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgdGhpcy5fdHJpZ2dlclJlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGdldCB2aWV3cG9ydFNpemUoKTogU2l6ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZTtcbiAgfVxuICBzZXQgdmlld3BvcnRTaXplKGRpbXMpIHtcbiAgICBjb25zdCB7X3ZpZXdEaW0xLCBfdmlld0RpbTJ9ID0gdGhpcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3ZpZXdwb3J0U2l6ZSwgZGltcyk7XG4gICAgaWYgKF92aWV3RGltMiAhPT0gdGhpcy5fdmlld0RpbTIpIHtcbiAgICAgIC8vIHRoaXMuX3ZpZXdEaW0yQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKF92aWV3RGltMSAhPT0gdGhpcy5fdmlld0RpbTEpIHtcbiAgICAgIHRoaXMuX2NoZWNrVGhyZXNob2xkcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGdldCB2aWV3cG9ydFNjcm9sbCgpOiBQb3NpdGlvbnMge1xuICAgIHJldHVybiB0aGlzLl9sYXRlc3RDb29yZHM7XG4gIH1cbiAgc2V0IHZpZXdwb3J0U2Nyb2xsKGNvb3Jkcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fbGF0ZXN0Q29vcmRzLCBjb29yZHMpO1xuICAgIGNvbnN0IG9sZFBvcyA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gdGhpcy5fbGF0ZXN0Q29vcmRzW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICBpZiAob2xkUG9zICE9PSB0aGlzLl9zY3JvbGxQb3NpdGlvbikge1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb25DaGFuZ2VkKG9sZFBvcywgdGhpcy5fc2Nyb2xsUG9zaXRpb24pO1xuICAgICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoe2VtaXQ6IHRydWV9KTtcbiAgICB9XG4gICAgdGhpcy5fY2hlY2tUaHJlc2hvbGRzKCk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHJlZmxvdyBpZiBvbmUgaGFzIGJlZW4gc2NoZWR1bGVkLlxuICAgKi9cbiAgcmVmbG93SWZOZWVkZWQoZm9yY2U6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGlmIChmb3JjZSB8fCB0aGlzLl9wZW5kaW5nUmVmbG93KSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIHRvIHRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2l0aGluIHRoYXRcbiAgICogY2hpbGQuXG4gICAqL1xuICBzY3JvbGxUb0luZGV4KGluZGV4OiBudW1iZXIsIHBvc2l0aW9uID0gJ3N0YXJ0Jykge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGluZGV4KSlcbiAgICAgIHJldHVybjtcbiAgICBpbmRleCA9IE1hdGgubWluKHRoaXMudG90YWxJdGVtcywgTWF0aC5tYXgoMCwgaW5kZXgpKTtcbiAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0gaW5kZXg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbmVhcmVzdCcpIHtcbiAgICAgIHBvc2l0aW9uID0gaW5kZXggPiB0aGlzLl9maXJzdCArIHRoaXMuX251bSAvIDIgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgfVxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9BbmNob3IgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvQW5jaG9yID0gMC41O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvQW5jaG9yID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ3Bvc2l0aW9uIG11c3QgYmUgb25lIG9mOiBzdGFydCwgY2VudGVyLCBlbmQsIG5lYXJlc3QnKTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgfVxuXG4gIGFzeW5jIGRpc3BhdGNoRXZlbnQoZXZ0OiBFdmVudCkge1xuICAgIGF3YWl0IHRoaXMuX2V2ZW50VGFyZ2V0UHJvbWlzZTtcbiAgICB0aGlzLl9ldmVudFRhcmdldCEuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG5cbiAgYXN5bmMgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyIHwgRXZlbnRMaXN0ZW5lck9iamVjdCB8IG51bGwsIG9wdGlvbnM/OiBib29sZWFuIHwgQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCB1bmRlZmluZWQpIHtcbiAgICBhd2FpdCB0aGlzLl9ldmVudFRhcmdldFByb21pc2U7XG4gICAgdGhpcy5fZXZlbnRUYXJnZXQhLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG5cbiAgYXN5bmMgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlOiBzdHJpbmcsIGNhbGxiYWNrOiBFdmVudExpc3RlbmVyIHwgRXZlbnRMaXN0ZW5lck9iamVjdCB8IG51bGwsIG9wdGlvbnM/OiBib29sZWFuIHwgRXZlbnRMaXN0ZW5lck9wdGlvbnMgfCB1bmRlZmluZWQpIHtcbiAgICBhd2FpdCB0aGlzLl9ldmVudFRhcmdldFByb21pc2U7XG4gICAgdGhpcy5fZXZlbnRUYXJnZXQhLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG9wIGFuZCBsZWZ0IHBvc2l0aW9uaW5nIG9mIHRoZSBpdGVtIGF0IGlkeC5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0SXRlbVBvc2l0aW9uKGlkeDogbnVtYmVyKTogUG9zaXRpb25zO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgX2ZpcnN0IGFuZCBfbGFzdCBiYXNlZCBvbiBpdGVtcyB0aGF0IHNob3VsZCBiZSBpbiB0aGUgY3VycmVudFxuICAgKiByYW5nZS5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0QWN0aXZlSXRlbXMoKTogdm9pZFxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0SXRlbVNpemUoX2lkeDogbnVtYmVyKTogU2l6ZVxuXG4gICAgLyoqXG4gICAqIENhbGN1bGF0ZXMgKHByZWNpc2VseSBvciBieSBlc3RpbWF0aW5nLCBpZiBuZWVkZWQpIHRoZSB0b3RhbCBsZW5ndGggb2YgYWxsIGl0ZW1zIGluXG4gICAqIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLCBpbmNsdWRpbmcgc3BhY2luZywgY2FjaGluZyB0aGUgdmFsdWUgaW4gdGhlIGBfc2Nyb2xsU2l6ZWAgZmllbGQuXG4gICAqIFxuICAgKiBTaG91bGQgcmV0dXJuIGEgbWluaW11bSB2YWx1ZSBvZiAxIHRvIGVuc3VyZSBhdCBsZWFzdCBvbmUgaXRlbSBpcyByZW5kZXJlZC5cbiAgICogVE9ETyAoZ3JheW5vcnRvbik6IFBvc3NpYmx5IG5vIGxvbmdlciByZXF1aXJlZCwgYnV0IGxlYXZpbmcgaGVyZSB1bnRpbCBpdCBjYW4gYmUgdmVyaWZpZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX3VwZGF0ZVNjcm9sbFNpemUoKTogdm9pZFxuXG4gIHByb3RlY3RlZCBfdXBkYXRlTGF5b3V0KCk6IHZvaWQge1xuICAgIC8vIE92ZXJyaWRlXG4gIH1cblxuICAvLyBwcm90ZWN0ZWQgX3ZpZXdEaW0yQ2hhbmdlZCgpOiB2b2lkIHtcbiAgLy8gICB0aGlzLl9zY2hlZHVsZUxheW91dFVwZGF0ZSgpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIHZpZXdwb3J0LCB3aGljaGV2ZXIgY29ycmVzcG9uZHMgdG8gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IF92aWV3RGltMSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNpemVbdGhpcy5fc2l6ZURpbV07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgdmlld3BvcnQsIHdoaWNoZXZlciBkb2VzIE5PVCBjb3JyZXNwb25kIHRvIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBfdmlld0RpbTIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplW3RoaXMuX3NlY29uZGFyeVNpemVEaW1dO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zY2hlZHVsZVJlZmxvdygpIHtcbiAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVMYXlvdXRVcGRhdGUoKSB7XG4gICAgdGhpcy5fcGVuZGluZ0xheW91dFVwZGF0ZSA9IHRydWU7XG4gICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgfVxuXG4gIC8vIEZvciB0cmlnZ2VyaW5nIGEgcmVmbG93IGJhc2VkIG9uIGluY29taW5nIGNoYW5nZXMgdG9cbiAgLy8gdGhlIGxheW91dCBjb25maWcuXG4gIHByb3RlY3RlZCBfdHJpZ2dlclJlZmxvdygpIHtcbiAgICB0aGlzLl9zY2hlZHVsZUxheW91dFVwZGF0ZSgpO1xuICAgIC8vIFRPRE8gZ3JheW5vcnRvbkA6IHJlZmxvd0lmTmVlZGVkKCkgaXNuJ3QgcmVhbGx5IHN1cHBvc2VkXG4gICAgLy8gdG8gYmUgY2FsbGVkIGludGVybmFsbHkuIEFkZHJlc3MgaW4gbGFyZ2VyIGNsZWFudXBcbiAgICAvLyBvZiB2aXJ0dWFsaXplciAvIGxheW91dCBpbnRlcmFjdGlvbiBwYXR0ZXJuLlxuICAgIC8vIHRoaXMucmVmbG93SWZOZWVkZWQodHJ1ZSk7XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnJlZmxvd0lmTmVlZGVkKCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9yZWZsb3coKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdMYXlvdXRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUxheW91dCgpO1xuICAgICAgdGhpcy5fcGVuZGluZ0xheW91dFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVTY3JvbGxTaXplKCk7XG4gICAgdGhpcy5fZ2V0QWN0aXZlSXRlbXMoKTtcbiAgICB0aGlzLl9zY3JvbGxJZk5lZWRlZCgpO1xuICAgIHRoaXMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG4gICAgdGhpcy5fZW1pdFNjcm9sbFNpemUoKTtcbiAgICB0aGlzLl9lbWl0UmFuZ2UoKTtcbiAgICB0aGlzLl9lbWl0Q2hpbGRQb3NpdGlvbnMoKTtcbiAgICB0aGlzLl9lbWl0U2Nyb2xsRXJyb3IoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2Nyb2xsSWZOZWVkZWQoKSB7XG4gICAgaWYgKHRoaXMuX3Njcm9sbFRvSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc2Nyb2xsVG9JbmRleDtcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLl9zY3JvbGxUb0FuY2hvcjtcbiAgICBjb25zdCBwb3MgPSB0aGlzLl9nZXRJdGVtUG9zaXRpb24oaW5kZXgpW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0SXRlbVNpemUoaW5kZXgpW3RoaXMuX3NpemVEaW1dO1xuXG4gICAgY29uc3QgY3VyQW5jaG9yUG9zID0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSAqIGFuY2hvcjtcbiAgICBjb25zdCBuZXdBbmNob3JQb3MgPSBwb3MgKyBzaXplICogYW5jaG9yO1xuICAgIC8vIEVuc3VyZSBzY3JvbGwgcG9zaXRpb24gaXMgYW4gaW50ZWdlciB3aXRoaW4gc2Nyb2xsIGJvdW5kcy5cbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IE1hdGguZmxvb3IoTWF0aC5taW4oXG4gICAgICAgIHRoaXMuX3Njcm9sbFNpemUgLSB0aGlzLl92aWV3RGltMSxcbiAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSBjdXJBbmNob3JQb3MgKyBuZXdBbmNob3JQb3MpKSk7XG4gICAgdGhpcy5fc2Nyb2xsRXJyb3IgKz0gdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSBzY3JvbGxQb3NpdGlvbjtcbiAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IHNjcm9sbFBvc2l0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0UmFuZ2UoaW5Qcm9wczogdW5rbm93biA9IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGRldGFpbCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBmaXJzdDogdGhpcy5fZmlyc3QsXG4gICAgICAgICAgbGFzdDogdGhpcy5fbGFzdCxcbiAgICAgICAgICBudW06IHRoaXMuX251bSxcbiAgICAgICAgICBzdGFibGU6IHRydWUsXG4gICAgICAgICAgZmlyc3RWaXNpYmxlOiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICAgICAgbGFzdFZpc2libGU6IHRoaXMuX2xhc3RWaXNpYmxlLFxuICAgICAgICB9LFxuICAgICAgICBpblByb3BzKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdyYW5nZWNoYW5nZScsIHtkZXRhaWx9KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2VtaXRTY3JvbGxTaXplKCkge1xuICAgIGNvbnN0IGRldGFpbCA9IHtcbiAgICAgIFt0aGlzLl9zaXplRGltXTogdGhpcy5fc2Nyb2xsU2l6ZSxcbiAgICB9O1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3Njcm9sbHNpemVjaGFuZ2UnLCB7ZGV0YWlsfSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lbWl0U2Nyb2xsRXJyb3IoKSB7XG4gICAgaWYgKHRoaXMuX3Njcm9sbEVycm9yKSB7XG4gICAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX3Njcm9sbEVycm9yLFxuICAgICAgICBbdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW1dOiAwLFxuICAgICAgfTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3Njcm9sbGVycm9yY2hhbmdlJywge2RldGFpbH0pKTtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG9yIGVzdGltYXRlIHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25zIG9mIGl0ZW1zIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgKiBFbWl0IGFuIGl0ZW1wb3NpdGlvbmNoYW5nZSBldmVudCB3aXRoIHRoZXNlIHBvc2l0aW9ucy5cbiAgICovXG4gIHByb3RlY3RlZCBfZW1pdENoaWxkUG9zaXRpb25zKCkge1xuICAgIGNvbnN0IGRldGFpbDoge1trZXk6IG51bWJlcl06IFBvc2l0aW9uc30gPSB7fTtcbiAgICBmb3IgKGxldCBpZHggPSB0aGlzLl9maXJzdDsgaWR4IDw9IHRoaXMuX2xhc3Q7IGlkeCsrKSB7XG4gICAgICBkZXRhaWxbaWR4XSA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpZHgpO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdpdGVtcG9zaXRpb25jaGFuZ2UnLCB7ZGV0YWlsfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBpdGVtcyB0byBkaXNwbGF5LlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgX251bSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgfHwgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGFzdCAtIHRoaXMuX2ZpcnN0ICsgMTtcbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrVGhyZXNob2xkcygpIHtcbiAgICBpZiAodGhpcy5fdmlld0RpbTEgPT09IDAgJiYgdGhpcy5fbnVtID4gMCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWluID0gTWF0aC5tYXgoMCwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSB0aGlzLl9vdmVyaGFuZyk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbihcbiAgICAgICAgICB0aGlzLl9zY3JvbGxTaXplLFxuICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uICsgdGhpcy5fdmlld0RpbTEgKyB0aGlzLl9vdmVyaGFuZyk7XG4gICAgICBpZiAodGhpcy5fcGh5c2ljYWxNaW4gPiBtaW4gfHwgdGhpcy5fcGh5c2ljYWxNYXggPCBtYXgpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kaWNlcyBvZiB0aGUgZmlyc3QgYW5kIGxhc3QgaXRlbXMgdG8gaW50ZXJzZWN0IHRoZSB2aWV3cG9ydC5cbiAgICogRW1pdCBhIHZpc2libGVpbmRpY2VzY2hhbmdlIGV2ZW50IHdoZW4gZWl0aGVyIGluZGV4IGNoYW5nZXMuXG4gICAqL1xuICAgcHJvdGVjdGVkIF91cGRhdGVWaXNpYmxlSW5kaWNlcyhvcHRpb25zPzogVXBkYXRlVmlzaWJsZUluZGljZXNPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSB8fCB0aGlzLl9sYXN0ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgbGV0IGZpcnN0VmlzaWJsZSA9IHRoaXMuX2ZpcnN0O1xuICAgIHdoaWxlIChcbiAgICAgIGZpcnN0VmlzaWJsZSA8IHRoaXMuX2xhc3QgJiZcbiAgICAgIE1hdGgucm91bmQoXG4gICAgICAgIHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihmaXJzdFZpc2libGUpW3RoaXMuX3Bvc2l0aW9uRGltXSArXG4gICAgICAgIHRoaXMuX2dldEl0ZW1TaXplKGZpcnN0VmlzaWJsZSlbdGhpcy5fc2l6ZURpbV1cbiAgICAgIClcbiAgICAgIDw9XG4gICAgICBNYXRoLnJvdW5kICh0aGlzLl9zY3JvbGxQb3NpdGlvbilcbiAgICAgKSB7XG4gICAgICBmaXJzdFZpc2libGUrKztcbiAgICB9XG5cbiAgICBsZXQgbGFzdFZpc2libGUgPSB0aGlzLl9sYXN0O1xuICAgIHdoaWxlIChcbiAgICAgIGxhc3RWaXNpYmxlID4gdGhpcy5fZmlyc3QgJiZcbiAgICAgIE1hdGgucm91bmQodGhpcy5fZ2V0SXRlbVBvc2l0aW9uKGxhc3RWaXNpYmxlKVt0aGlzLl9wb3NpdGlvbkRpbV0pXG4gICAgICA+PVxuICAgICAgTWF0aC5yb3VuZCh0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xKVxuICAgICkge1xuICAgICAgbGFzdFZpc2libGUtLTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RWaXNpYmxlICE9PSB0aGlzLl9maXJzdFZpc2libGUgfHwgbGFzdFZpc2libGUgIT09IHRoaXMuX2xhc3RWaXNpYmxlKSB7XG4gICAgICB0aGlzLl9maXJzdFZpc2libGUgPSBmaXJzdFZpc2libGU7XG4gICAgICB0aGlzLl9sYXN0VmlzaWJsZSA9IGxhc3RWaXNpYmxlO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbWl0KSB7XG4gICAgICAgIHRoaXMuX2VtaXRSYW5nZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbFBvc2l0aW9uQ2hhbmdlZChvbGRQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIpIHtcbiAgICAvLyBXaGVuIGJvdGggdmFsdWVzIGFyZSBiaWdnZXIgdGhhbiB0aGUgbWF4IHNjcm9sbCBwb3NpdGlvbiwga2VlcCB0aGVcbiAgICAvLyBjdXJyZW50IF9zY3JvbGxUb0luZGV4LCBvdGhlcndpc2UgaW52YWxpZGF0ZSBpdC5cbiAgICBjb25zdCBtYXhQb3MgPSB0aGlzLl9zY3JvbGxTaXplIC0gdGhpcy5fdmlld0RpbTE7XG4gICAgaWYgKG9sZFBvcyA8IG1heFBvcyB8fCBuZXdQb3MgPCBtYXhQb3MpIHtcbiAgICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ EventTarget; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _ET;\n\nvar ET;\nfunction EventTarget() {\n  return _EventTarget.apply(this, arguments);\n}\n\nfunction _EventTarget() {\n  _EventTarget = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n    return regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", ET || init());\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _EventTarget.apply(this, arguments);\n}\n\nfunction init() {\n  return _init.apply(this, arguments);\n}\n\nfunction _init() {\n  _init = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ET = window.EventTarget;\n            _context2.prev = 1;\n            new _ET();\n            _context2.next = 10;\n            break;\n\n          case 5:\n            _context2.prev = 5;\n            _context2.t0 = _context2[\"catch\"](1);\n            _context2.next = 9;\n            return __webpack_require__.e(/*! import() */ \"vendors-node_modules_event-target-shim_dist_event-target-shim_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! event-target-shim */ \"./node_modules/event-target-shim/dist/event-target-shim.js\", 19));\n\n          case 9:\n            _ET = _context2.sent[\"default\"].EventTarget;\n\n          case 10:\n            return _context2.abrupt(\"return\", ET = _ET);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[1, 5]]);\n  }));\n  return _init.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3BvbHlmaWxsTG9hZGVycy9FdmVudFRhcmdldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7O0FBSUE7QUFRQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7O0FBSUE7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUtBOztBQUxBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcG9seWZpbGxMb2FkZXJzL0V2ZW50VGFyZ2V0LnRzP2MxYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbnR5cGUgRXZlbnRUYXJnZXRNb2R1bGUgPSB0eXBlb2YgaW1wb3J0KCdldmVudC10YXJnZXQtc2hpbScpO1xuXG5pbnRlcmZhY2UgRXZlbnRUYXJnZXRDb25zdHJ1Y3RvciB7XG4gICAgbmV3KCk6IEV2ZW50VGFyZ2V0XG59XG5cbmxldCBfRVQ6IEV2ZW50VGFyZ2V0TW9kdWxlIHwgRXZlbnRUYXJnZXRDb25zdHJ1Y3RvcjtcbmxldCBFVDogRXZlbnRUYXJnZXRDb25zdHJ1Y3RvcjtcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIEVUIHx8IGluaXQoKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBfRVQgPSB3aW5kb3cuRXZlbnRUYXJnZXQ7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IF9FVCgpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIF9FVCA9IChhd2FpdCBpbXBvcnQoJ2V2ZW50LXRhcmdldC1zaGltJykpLkV2ZW50VGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gKEVUID0gX0VUKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/polyfillLoaders/EventTarget.js\n");

/***/ })

}]);