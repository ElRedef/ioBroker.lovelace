"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLayout: function() { return /* binding */ BaseLayout; },\n/* harmony export */   dim1: function() { return /* binding */ dim1; },\n/* harmony export */   dim2: function() { return /* binding */ dim2; },\n/* harmony export */   pos1: function() { return /* binding */ pos1; },\n/* harmony export */   pos2: function() { return /* binding */ pos2; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nfunction dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nfunction pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nfunction pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nvar BaseLayout = /*#__PURE__*/function () {\n  function BaseLayout(hostSink, config) {\n    var _this = this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, BaseLayout);\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(function () {\n      return _this.config = config || _this._defaultConfig;\n    });\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(BaseLayout, [{\n    key: \"_defaultConfig\",\n    get: function get() {\n      return {\n        direction: 'vertical'\n      };\n    }\n  }, {\n    key: \"config\",\n    get: function get() {\n      return {\n        direction: this.direction\n      };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */,\n    set: function set(config) {\n      Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n  }, {\n    key: \"items\",\n    get: function get() {\n      return this._items;\n    },\n    set: function set(items) {\n      if (items !== this._items) {\n        this._items = items;\n        this._scheduleReflow();\n      }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    },\n    set: function set(dir) {\n      // Force it to be either horizontal or vertical.\n      dir = dir === 'horizontal' ? dir : 'vertical';\n      if (dir !== this._direction) {\n        this._direction = dir;\n        this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n        this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n        this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n        this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n        this._triggerReflow();\n      }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n  }, {\n    key: \"viewportSize\",\n    get: function get() {\n      return this._viewportSize;\n    },\n    set: function set(dims) {\n      var _viewDim1 = this._viewDim1,\n        _viewDim2 = this._viewDim2;\n      Object.assign(this._viewportSize, dims);\n      if (_viewDim2 !== this._viewDim2) {\n        // this._viewDim2Changed();\n        this._scheduleLayoutUpdate();\n      } else if (_viewDim1 !== this._viewDim1) {\n        this._checkThresholds();\n      }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n  }, {\n    key: \"viewportScroll\",\n    get: function get() {\n      return this._latestCoords;\n    },\n    set: function set(coords) {\n      Object.assign(this._latestCoords, coords);\n      var oldPos = this._scrollPosition;\n      this._scrollPosition = this._latestCoords[this._positionDim];\n      var change = Math.abs(oldPos - this._scrollPosition);\n      if (change >= 1) {\n        this._checkThresholds();\n      }\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n  }, {\n    key: \"reflowIfNeeded\",\n    value: function reflowIfNeeded() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (force || this._pendingReflow) {\n        this._pendingReflow = false;\n        this._reflow();\n      }\n    }\n  }, {\n    key: \"pin\",\n    get: function get() {\n      if (this._pin !== null) {\n        var _this$_pin = this._pin,\n          index = _this$_pin.index,\n          block = _this$_pin.block;\n        return {\n          index: Math.max(0, Math.min(index, this.items.length - 1)),\n          block: block\n        };\n      }\n      return null;\n    },\n    set: function set(options) {\n      this._pin = options;\n      this._triggerReflow();\n    }\n  }, {\n    key: \"_clampScrollPosition\",\n    value: function _clampScrollPosition(val) {\n      return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n  }, {\n    key: \"unpin\",\n    value: function unpin() {\n      if (this._pin !== null) {\n        this._sendUnpinnedMessage();\n        this._pin = null;\n      }\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout() {\n      // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n  }, {\n    key: \"_viewDim1\",\n    get: function get() {\n      return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n  }, {\n    key: \"_viewDim2\",\n    get: function get() {\n      return this._viewportSize[this._secondarySizeDim];\n    }\n  }, {\n    key: \"_scheduleReflow\",\n    value: function _scheduleReflow() {\n      this._pendingReflow = true;\n    }\n  }, {\n    key: \"_scheduleLayoutUpdate\",\n    value: function _scheduleLayoutUpdate() {\n      this._pendingLayoutUpdate = true;\n      this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n  }, {\n    key: \"_triggerReflow\",\n    value: function _triggerReflow() {\n      var _this2 = this;\n      this._scheduleLayoutUpdate();\n      // TODO graynorton@: reflowIfNeeded() isn't really supposed\n      // to be called internally. Address in larger cleanup\n      // of virtualizer / layout interaction pattern.\n      // this.reflowIfNeeded(true);\n      Promise.resolve().then(function () {\n        return _this2.reflowIfNeeded();\n      });\n    }\n  }, {\n    key: \"_reflow\",\n    value: function _reflow() {\n      if (this._pendingLayoutUpdate) {\n        this._updateLayout();\n        this._pendingLayoutUpdate = false;\n      }\n      this._updateScrollSize();\n      this._setPositionFromPin();\n      this._getActiveItems();\n      this._updateVisibleIndices();\n      this._sendStateChangedMessage();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n  }, {\n    key: \"_setPositionFromPin\",\n    value: function _setPositionFromPin() {\n      if (this.pin !== null) {\n        var lastScrollPosition = this._scrollPosition;\n        var _this$pin = this.pin,\n          index = _this$pin.index,\n          block = _this$pin.block;\n        this._scrollPosition = this._calculateScrollIntoViewPosition({\n          index: index,\n          block: block || 'start'\n        }) - this.offsetWithinScroller[this._positionDim];\n        this._scrollError = lastScrollPosition - this._scrollPosition;\n      }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n  }, {\n    key: \"_calculateScrollIntoViewPosition\",\n    value: function _calculateScrollIntoViewPosition(options) {\n      var block = options.block;\n      var index = Math.min(this.items.length, Math.max(0, options.index));\n      var itemStartPosition = this._getItemPosition(index)[this._positionDim];\n      var scrollPosition = itemStartPosition;\n      if (block !== 'start') {\n        var itemSize = this._getItemSize(index)[this._sizeDim];\n        if (block === 'center') {\n          scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n        } else {\n          var itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n          if (block === 'end') {\n            scrollPosition = itemEndPosition;\n          } else {\n            // block === 'nearest'\n            var currentScrollPosition = this._scrollPosition;\n            scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n          }\n        }\n      }\n      scrollPosition += this.offsetWithinScroller[this._positionDim];\n      return this._clampScrollPosition(scrollPosition);\n    }\n  }, {\n    key: \"getScrollIntoViewCoordinates\",\n    value: function getScrollIntoViewCoordinates(options) {\n      return (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, this._positionDim, this._calculateScrollIntoViewPosition(options));\n    }\n  }, {\n    key: \"_sendUnpinnedMessage\",\n    value: function _sendUnpinnedMessage() {\n      this._hostSink({\n        type: 'unpinned'\n      });\n    }\n  }, {\n    key: \"_sendVisibilityChangedMessage\",\n    value: function _sendVisibilityChangedMessage() {\n      this._hostSink({\n        type: 'visibilityChanged',\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      });\n    }\n  }, {\n    key: \"_sendStateChangedMessage\",\n    value: function _sendStateChangedMessage() {\n      var _scrollSize;\n      var childPositions = new Map();\n      if (this._first !== -1 && this._last !== -1) {\n        for (var idx = this._first; idx <= this._last; idx++) {\n          childPositions.set(idx, this._getItemPosition(idx));\n        }\n      }\n      var message = {\n        type: 'stateChanged',\n        scrollSize: (_scrollSize = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_scrollSize, this._sizeDim, this._scrollSize), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_scrollSize, this._secondarySizeDim, null), _scrollSize),\n        range: {\n          first: this._first,\n          last: this._last,\n          firstVisible: this._firstVisible,\n          lastVisible: this._lastVisible\n        },\n        childPositions: childPositions\n      };\n      if (this._scrollError) {\n        var _message$scrollError;\n        message.scrollError = (_message$scrollError = {}, (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_message$scrollError, this._positionDim, this._scrollError), (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_message$scrollError, this._secondaryPositionDim, 0), _message$scrollError);\n        this._scrollError = 0;\n      }\n      this._hostSink(message);\n    }\n    /**\n     * Number of items to display.\n     */\n  }, {\n    key: \"_num\",\n    get: function get() {\n      if (this._first === -1 || this._last === -1) {\n        return 0;\n      }\n      return this._last - this._first + 1;\n    }\n  }, {\n    key: \"_checkThresholds\",\n    value: function _checkThresholds() {\n      if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n        this._scheduleReflow();\n      } else {\n        var min = Math.max(0, this._scrollPosition - this._overhang);\n        var max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n        if (this._physicalMin > min || this._physicalMax < max) {\n          this._scheduleReflow();\n        } else {\n          this._updateVisibleIndices({\n            emit: true\n          });\n        }\n      }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n  }, {\n    key: \"_updateVisibleIndices\",\n    value: function _updateVisibleIndices(options) {\n      if (this._first === -1 || this._last === -1) return;\n      var firstVisible = this._first;\n      while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n        firstVisible++;\n      }\n      var lastVisible = this._last;\n      while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n        lastVisible--;\n      }\n      if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n        this._firstVisible = firstVisible;\n        this._lastVisible = lastVisible;\n        if (options && options.emit) {\n          this._sendVisibilityChangedMessage();\n        }\n      }\n    }\n  }]);\n  return BaseLayout;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUF3SEE7QUFBQTtBQUFBO0FBdkhBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7O0FBR0E7QUFFQTtBQUVBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7O0FBSUE7QUFFQTs7O0FBR0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQVRBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQUE7QUFBQTtBQVRBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFhQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7OztBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFiQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFjQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBeUJBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUVBOzs7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBUUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FBR0E7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUtBO0FBRUE7QUFDQTtBQU9BOztBQUdBO0FBQ0E7QUFLQTs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL3NyYy9sYXlvdXRzL3NoYXJlZC9CYXNlTGF5b3V0LnRzPzZjMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7XG4gIExheW91dCxcbiAgQ2hpbGRQb3NpdGlvbnMsXG4gIFBvc2l0aW9ucyxcbiAgU2Nyb2xsRGlyZWN0aW9uLFxuICBTaXplLFxuICBkaW1lbnNpb24sXG4gIHBvc2l0aW9uLFxuICBQaW5PcHRpb25zLFxuICBTY3JvbGxUb0Nvb3JkaW5hdGVzLFxuICBCYXNlTGF5b3V0Q29uZmlnLFxuICBTdGF0ZUNoYW5nZWRNZXNzYWdlLFxuICBMYXlvdXRIb3N0U2luayxcbn0gZnJvbSAnLi9MYXlvdXQuanMnO1xuXG50eXBlIFVwZGF0ZVZpc2libGVJbmRpY2VzT3B0aW9ucyA9IHtcbiAgZW1pdD86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZGltMShkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IGRpbWVuc2lvbiB7XG4gIHJldHVybiBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd3aWR0aCcgOiAnaGVpZ2h0Jztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpbTIoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBkaW1lbnNpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3MxKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogcG9zaXRpb24ge1xuICByZXR1cm4gZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbGVmdCcgOiAndG9wJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvczIoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBwb3NpdGlvbiB7XG4gIHJldHVybiBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICd0b3AnIDogJ2xlZnQnO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUxheW91dDxDIGV4dGVuZHMgQmFzZUxheW91dENvbmZpZz4gaW1wbGVtZW50cyBMYXlvdXQge1xuICAvKipcbiAgICogVGhlIGxhc3Qgc2V0IHZpZXdwb3J0IHNjcm9sbCBwb3NpdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX2xhdGVzdENvb3JkczogUG9zaXRpb25zID0ge2xlZnQ6IDAsIHRvcDogMH07XG5cbiAgLyoqXG4gICAqIFNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIF9kaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBEaW1lbnNpb25zIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByaXZhdGUgX3ZpZXdwb3J0U2l6ZTogU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcblxuICBwdWJsaWMgdG90YWxTY3JvbGxTaXplOiBTaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG4gIHB1YmxpYyBvZmZzZXRXaXRoaW5TY3JvbGxlcjogUG9zaXRpb25zID0ge2xlZnQ6IDAsIHRvcDogMH07XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIGRlYm91bmNpbmcgYXN5bmNocm9ub3VzIHJlZmxvdyByZXF1ZXN0cy5cbiAgICovXG4gIHByaXZhdGUgX3BlbmRpbmdSZWZsb3cgPSBmYWxzZTtcblxuICBwcml2YXRlIF9wZW5kaW5nTGF5b3V0VXBkYXRlID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIF9waW46IFBpbk9wdGlvbnMgfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2ZpcnN0VmlzaWJsZSA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgbGFzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3RWaXNpYmxlID0gMDtcblxuICAvKipcbiAgICogUGl4ZWwgb2Zmc2V0IGluIHRoZSBzY3JvbGwgZGlyZWN0aW9uIG9mIHRoZSBmaXJzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfcGh5c2ljYWxNaW4gPSAwO1xuXG4gIC8qKlxuICAgKiBQaXhlbCBvZmZzZXQgaW4gdGhlIHNjcm9sbCBkaXJlY3Rpb24gb2YgdGhlIGxhc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3BoeXNpY2FsTWF4ID0gMDtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9maXJzdCA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfbGFzdCA9IC0xO1xuXG4gIC8qKlxuICAgKiBMZW5ndGggaW4gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NpemVEaW06IGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuXG4gIC8qKlxuICAgKiBMZW5ndGggaW4gdGhlIG5vbi1zY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZWNvbmRhcnlTaXplRGltOiBkaW1lbnNpb24gPSAnd2lkdGgnO1xuXG4gIC8qKlxuICAgKiBQb3NpdGlvbiBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfcG9zaXRpb25EaW06IHBvc2l0aW9uID0gJ3RvcCc7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIGluIHRoZSBub24tc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Vjb25kYXJ5UG9zaXRpb25EaW06IHBvc2l0aW9uID0gJ2xlZnQnO1xuXG4gIC8qKlxuICAgKiBDdXJyZW50IHNjcm9sbCBvZmZzZXQgaW4gcGl4ZWxzLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zY3JvbGxQb3NpdGlvbiA9IDA7XG5cbiAgLyoqXG4gICAqIERpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IHNjcm9sbCBvZmZzZXQgYW5kIHNjcm9sbCBvZmZzZXQgY2FsY3VsYXRlZCBkdWVcbiAgICogdG8gYSByZWZsb3cuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbEVycm9yID0gMDtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY291bGQgcG9zc2libHkgYmUgZGlzcGxheWVkLiBVc2VkIHRvIGhlbHBcbiAgICogY2FsY3VsYXRlIHRoZSBzY3JvbGwgc2l6ZS5cbiAgICovXG4gIHByb3RlY3RlZCBfaXRlbXM6IHVua25vd25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgdG90YWwgKGVzdGltYXRlZCkgbGVuZ3RoIG9mIGFsbCBpdGVtcyBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsU2l6ZSA9IDE7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBwaXhlbHMgYmV5b25kIHRoZSB2aWV3cG9ydCB0byBzdGlsbCBpbmNsdWRlXG4gICAqIGluIHRoZSBhY3RpdmUgcmFuZ2Ugb2YgaXRlbXMuXG4gICAqL1xuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUHJvYmFibHkgd2FudCB0byBtYWtlIHRoaXMgc29tZXRoaW5nIHdlIGNhbGN1bGF0ZSBiYXNlZFxuICAvLyBvbiB2aWV3cG9ydCBzaXplLCBpdGVtIHNpemUsIG90aGVyIGZhY3RvcnMsIHBvc3NpYmx5IHN0aWxsIHdpdGggYSBkaWFsIG9mIHNvbWUga2luZFxuICBwcm90ZWN0ZWQgX292ZXJoYW5nID0gMTAwMDtcblxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIGRlbGl2ZXIgbWVzc2FnZXMgKGUuZy4gc3RhdGVDaGFuZ2VkLCB1bnBpbm5lZCkgdG8gaG9zdFxuICAgKi9cbiAgcHJpdmF0ZSBfaG9zdFNpbms6IExheW91dEhvc3RTaW5rO1xuXG4gIHByb3RlY3RlZCBnZXQgX2RlZmF1bHRDb25maWcoKTogQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICB9IGFzIEM7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihob3N0U2luazogTGF5b3V0SG9zdFNpbmssIGNvbmZpZz86IEMpIHtcbiAgICB0aGlzLl9ob3N0U2luayA9IGhvc3RTaW5rO1xuICAgIC8vIERlbGF5IHNldHRpbmcgY29uZmlnIHNvIHRoYXQgc3ViY2xhc3NlcyBkbyBzZXR1cCB3b3JrIGZpcnN0XG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiAodGhpcy5jb25maWcgPSBjb25maWcgfHwgdGhpcy5fZGVmYXVsdENvbmZpZykpO1xuICB9XG5cbiAgc2V0IGNvbmZpZyhjb25maWc6IEMpIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2RlZmF1bHRDb25maWcsIGNvbmZpZykpO1xuICB9XG5cbiAgZ2V0IGNvbmZpZygpOiBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbixcbiAgICB9IGFzIEM7XG4gIH1cblxuICAvKipcbiAgICogTWF4aW11bSBpbmRleCBvZiBjaGlsZHJlbiArIDEsIHRvIGhlbHAgZXN0aW1hdGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBzY3JvbGxcbiAgICogc3BhY2UuXG4gICAqL1xuICBnZXQgaXRlbXMoKTogdW5rbm93bltdIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gIH1cbiAgc2V0IGl0ZW1zKGl0ZW1zOiB1bmtub3duW10pIHtcbiAgICBpZiAoaXRlbXMgIT09IHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJpbWFyeSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgZ2V0IGRpcmVjdGlvbigpOiBTY3JvbGxEaXJlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLl9kaXJlY3Rpb24hO1xuICB9XG4gIHNldCBkaXJlY3Rpb24oZGlyKSB7XG4gICAgLy8gRm9yY2UgaXQgdG8gYmUgZWl0aGVyIGhvcml6b250YWwgb3IgdmVydGljYWwuXG4gICAgZGlyID0gZGlyID09PSAnaG9yaXpvbnRhbCcgPyBkaXIgOiAndmVydGljYWwnO1xuICAgIGlmIChkaXIgIT09IHRoaXMuX2RpcmVjdGlvbikge1xuICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyO1xuICAgICAgdGhpcy5fc2l6ZURpbSA9IGRpciA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbSA9IGRpciA9PT0gJ2hvcml6b250YWwnID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgICAgdGhpcy5fcG9zaXRpb25EaW0gPSBkaXIgPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW0gPSBkaXIgPT09ICdob3Jpem9udGFsJyA/ICd0b3AnIDogJ2xlZnQnO1xuICAgICAgdGhpcy5fdHJpZ2dlclJlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGdldCB2aWV3cG9ydFNpemUoKTogU2l6ZSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZTtcbiAgfVxuICBzZXQgdmlld3BvcnRTaXplKGRpbXMpIHtcbiAgICBjb25zdCB7X3ZpZXdEaW0xLCBfdmlld0RpbTJ9ID0gdGhpcztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3ZpZXdwb3J0U2l6ZSwgZGltcyk7XG4gICAgaWYgKF92aWV3RGltMiAhPT0gdGhpcy5fdmlld0RpbTIpIHtcbiAgICAgIC8vIHRoaXMuX3ZpZXdEaW0yQ2hhbmdlZCgpO1xuICAgICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgICB9IGVsc2UgaWYgKF92aWV3RGltMSAhPT0gdGhpcy5fdmlld0RpbTEpIHtcbiAgICAgIHRoaXMuX2NoZWNrVGhyZXNob2xkcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgb2Zmc2V0IG9mIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGdldCB2aWV3cG9ydFNjcm9sbCgpOiBQb3NpdGlvbnMge1xuICAgIHJldHVybiB0aGlzLl9sYXRlc3RDb29yZHM7XG4gIH1cbiAgc2V0IHZpZXdwb3J0U2Nyb2xsKGNvb3Jkcykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fbGF0ZXN0Q29vcmRzLCBjb29yZHMpO1xuICAgIGNvbnN0IG9sZFBvcyA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gdGhpcy5fbGF0ZXN0Q29vcmRzW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLmFicyhvbGRQb3MgLSB0aGlzLl9zY3JvbGxQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZSA+PSAxKSB7XG4gICAgICB0aGlzLl9jaGVja1RocmVzaG9sZHMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhIHJlZmxvdyBpZiBvbmUgaGFzIGJlZW4gc2NoZWR1bGVkLlxuICAgKi9cbiAgcmVmbG93SWZOZWVkZWQoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmIChmb3JjZSB8fCB0aGlzLl9wZW5kaW5nUmVmbG93KSB7XG4gICAgICB0aGlzLl9wZW5kaW5nUmVmbG93ID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICB9XG4gIH1cblxuICBzZXQgcGluKG9wdGlvbnM6IFBpbk9wdGlvbnMgfCBudWxsKSB7XG4gICAgdGhpcy5fcGluID0gb3B0aW9ucztcbiAgICB0aGlzLl90cmlnZ2VyUmVmbG93KCk7XG4gIH1cblxuICBnZXQgcGluKCkge1xuICAgIGlmICh0aGlzLl9waW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtpbmRleCwgYmxvY2t9ID0gdGhpcy5fcGluO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1zLmxlbmd0aCAtIDEpKSxcbiAgICAgICAgYmxvY2ssXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9jbGFtcFNjcm9sbFBvc2l0aW9uKHZhbDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgLXRoaXMub2Zmc2V0V2l0aGluU2Nyb2xsZXJbdGhpcy5fcG9zaXRpb25EaW1dLFxuICAgICAgTWF0aC5taW4odmFsLCB0aGlzLnRvdGFsU2Nyb2xsU2l6ZVtkaW0xKHRoaXMuZGlyZWN0aW9uKV0gLSB0aGlzLl92aWV3RGltMSlcbiAgICApO1xuICB9XG5cbiAgdW5waW4oKSB7XG4gICAgaWYgKHRoaXMuX3BpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2VuZFVucGlubmVkTWVzc2FnZSgpO1xuICAgICAgdGhpcy5fcGluID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0b3AgYW5kIGxlZnQgcG9zaXRpb25pbmcgb2YgdGhlIGl0ZW0gYXQgaWR4LlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRJdGVtUG9zaXRpb24oaWR4OiBudW1iZXIpOiBQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBfZmlyc3QgYW5kIF9sYXN0IGJhc2VkIG9uIGl0ZW1zIHRoYXQgc2hvdWxkIGJlIGluIHRoZSBjdXJyZW50XG4gICAqIHJhbmdlLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRBY3RpdmVJdGVtcygpOiB2b2lkO1xuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBfZ2V0SXRlbVNpemUoX2lkeDogbnVtYmVyKTogU2l6ZTtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyAocHJlY2lzZWx5IG9yIGJ5IGVzdGltYXRpbmcsIGlmIG5lZWRlZCkgdGhlIHRvdGFsIGxlbmd0aCBvZiBhbGwgaXRlbXMgaW5cbiAgICogdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24sIGluY2x1ZGluZyBzcGFjaW5nLCBjYWNoaW5nIHRoZSB2YWx1ZSBpbiB0aGUgYF9zY3JvbGxTaXplYCBmaWVsZC5cbiAgICpcbiAgICogU2hvdWxkIHJldHVybiBhIG1pbmltdW0gdmFsdWUgb2YgMSB0byBlbnN1cmUgYXQgbGVhc3Qgb25lIGl0ZW0gaXMgcmVuZGVyZWQuXG4gICAqIFRPRE8gKGdyYXlub3J0b24pOiBQb3NzaWJseSBubyBsb25nZXIgcmVxdWlyZWQsIGJ1dCBsZWF2aW5nIGhlcmUgdW50aWwgaXQgY2FuIGJlIHZlcmlmaWVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF91cGRhdGVTY3JvbGxTaXplKCk6IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIF91cGRhdGVMYXlvdXQoKTogdm9pZCB7XG4gICAgLy8gT3ZlcnJpZGVcbiAgfVxuXG4gIC8vIHByb3RlY3RlZCBfdmlld0RpbTJDaGFuZ2VkKCk6IHZvaWQge1xuICAvLyAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogVGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgdmlld3BvcnQsIHdoaWNoZXZlciBjb3JyZXNwb25kcyB0byB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBnZXQgX3ZpZXdEaW0xKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZVt0aGlzLl9zaXplRGltXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCwgd2hpY2hldmVyIGRvZXMgTk9UIGNvcnJlc3BvbmQgdG8gdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IF92aWV3RGltMigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFNpemVbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV07XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NjaGVkdWxlUmVmbG93KCkge1xuICAgIHRoaXMuX3BlbmRpbmdSZWZsb3cgPSB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zY2hlZHVsZUxheW91dFVwZGF0ZSgpIHtcbiAgICB0aGlzLl9wZW5kaW5nTGF5b3V0VXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICB9XG5cbiAgLy8gRm9yIHRyaWdnZXJpbmcgYSByZWZsb3cgYmFzZWQgb24gaW5jb21pbmcgY2hhbmdlcyB0b1xuICAvLyB0aGUgbGF5b3V0IGNvbmZpZy5cbiAgcHJvdGVjdGVkIF90cmlnZ2VyUmVmbG93KCkge1xuICAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCk7XG4gICAgLy8gVE9ETyBncmF5bm9ydG9uQDogcmVmbG93SWZOZWVkZWQoKSBpc24ndCByZWFsbHkgc3VwcG9zZWRcbiAgICAvLyB0byBiZSBjYWxsZWQgaW50ZXJuYWxseS4gQWRkcmVzcyBpbiBsYXJnZXIgY2xlYW51cFxuICAgIC8vIG9mIHZpcnR1YWxpemVyIC8gbGF5b3V0IGludGVyYWN0aW9uIHBhdHRlcm4uXG4gICAgLy8gdGhpcy5yZWZsb3dJZk5lZWRlZCh0cnVlKTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMucmVmbG93SWZOZWVkZWQoKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3JlZmxvdygpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0xheW91dFVwZGF0ZSkge1xuICAgICAgdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG4gICAgICB0aGlzLl9wZW5kaW5nTGF5b3V0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVNjcm9sbFNpemUoKTtcbiAgICB0aGlzLl9zZXRQb3NpdGlvbkZyb21QaW4oKTtcbiAgICB0aGlzLl9nZXRBY3RpdmVJdGVtcygpO1xuICAgIHRoaXMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKCk7XG4gICAgdGhpcy5fc2VuZFN0YXRlQ2hhbmdlZE1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBhcmUgc3VwcG9zZWQgdG8gYmUgcGlubmVkIHRvIGEgcGFydGljdWxhclxuICAgKiBpdGVtIG9yIHNldCBvZiBjb29yZGluYXRlcywgd2Ugc2V0IGBfc2Nyb2xsUG9zaXRpb25gXG4gICAqIGFjY29yZGluZ2x5IGFuZCBhZGp1c3QgYF9zY3JvbGxFcnJvcmAgYXMgbmVlZGVkXG4gICAqIHNvIHRoYXQgdGhlIHZpcnR1YWxpemVyIGNhbiBrZWVwIHRoZSBzY3JvbGxcbiAgICogcG9zaXRpb24gaW4gdGhlIERPTSBpbiBzeW5jXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NldFBvc2l0aW9uRnJvbVBpbigpIHtcbiAgICBpZiAodGhpcy5waW4gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGxhc3RTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgICAgY29uc3Qge2luZGV4LCBibG9ja30gPSB0aGlzLnBpbjtcbiAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlU2Nyb2xsSW50b1ZpZXdQb3NpdGlvbih7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgYmxvY2s6IGJsb2NrIHx8ICdzdGFydCcsXG4gICAgICAgIH0pIC0gdGhpcy5vZmZzZXRXaXRoaW5TY3JvbGxlclt0aGlzLl9wb3NpdGlvbkRpbV07XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IGxhc3RTY3JvbGxQb3NpdGlvbiAtIHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBjb29yZGluYXRlcyB0byBzY3JvbGwgdG8sIGdpdmVuXG4gICAqIGEgcmVxdWVzdCB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgYXQgYSBzcGVjaWZpY1xuICAgKiBpbmRleC5cbiAgICpcbiAgICogU3VwcG9ydHMgdGhlIHNhbWUgcG9zaXRpb25pbmcgb3B0aW9ucyAoYHN0YXJ0YCxcbiAgICogYGNlbnRlcmAsIGBlbmRgLCBgbmVhcmVzdGApIGFzIHRoZSBzdGFuZGFyZFxuICAgKiBgRWxlbWVudC5zY3JvbGxJbnRvVmlldygpYCBtZXRob2QsIGJ1dCBjdXJyZW50bHlcbiAgICogb25seSBjb25zaWRlcnMgdGhlIHByb3ZpZGVkIHZhbHVlIGluIHRoZSBgYmxvY2tgXG4gICAqIGRpbWVuc2lvbiwgc2luY2Ugd2UgZG9uJ3QgeWV0IGhhdmUgYW55IGxheW91dHNcbiAgICogdGhhdCBzdXBwb3J0IHZpcnR1YWxpemF0aW9uIGluIHR3byBkaW1lbnNpb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9jYWxjdWxhdGVTY3JvbGxJbnRvVmlld1Bvc2l0aW9uKG9wdGlvbnM6IFBpbk9wdGlvbnMpIHtcbiAgICBjb25zdCB7YmxvY2t9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpbmRleCA9IE1hdGgubWluKHRoaXMuaXRlbXMubGVuZ3RoLCBNYXRoLm1heCgwLCBvcHRpb25zLmluZGV4KSk7XG4gICAgY29uc3QgaXRlbVN0YXJ0UG9zaXRpb24gPSB0aGlzLl9nZXRJdGVtUG9zaXRpb24oaW5kZXgpW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICBsZXQgc2Nyb2xsUG9zaXRpb24gPSBpdGVtU3RhcnRQb3NpdGlvbjtcbiAgICBpZiAoYmxvY2sgIT09ICdzdGFydCcpIHtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gdGhpcy5fZ2V0SXRlbVNpemUoaW5kZXgpW3RoaXMuX3NpemVEaW1dO1xuICAgICAgaWYgKGJsb2NrID09PSAnY2VudGVyJykge1xuICAgICAgICBzY3JvbGxQb3NpdGlvbiA9XG4gICAgICAgICAgaXRlbVN0YXJ0UG9zaXRpb24gLSAwLjUgKiB0aGlzLl92aWV3RGltMSArIDAuNSAqIGl0ZW1TaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbUVuZFBvc2l0aW9uID0gaXRlbVN0YXJ0UG9zaXRpb24gLSB0aGlzLl92aWV3RGltMSArIGl0ZW1TaXplO1xuICAgICAgICBpZiAoYmxvY2sgPT09ICdlbmQnKSB7XG4gICAgICAgICAgc2Nyb2xsUG9zaXRpb24gPSBpdGVtRW5kUG9zaXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmxvY2sgPT09ICduZWFyZXN0J1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3Njcm9sbFBvc2l0aW9uO1xuICAgICAgICAgIHNjcm9sbFBvc2l0aW9uID1cbiAgICAgICAgICAgIE1hdGguYWJzKGN1cnJlbnRTY3JvbGxQb3NpdGlvbiAtIGl0ZW1TdGFydFBvc2l0aW9uKSA8XG4gICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50U2Nyb2xsUG9zaXRpb24gLSBpdGVtRW5kUG9zaXRpb24pXG4gICAgICAgICAgICAgID8gaXRlbVN0YXJ0UG9zaXRpb25cbiAgICAgICAgICAgICAgOiBpdGVtRW5kUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsUG9zaXRpb24gKz0gdGhpcy5vZmZzZXRXaXRoaW5TY3JvbGxlclt0aGlzLl9wb3NpdGlvbkRpbV07XG4gICAgcmV0dXJuIHRoaXMuX2NsYW1wU2Nyb2xsUG9zaXRpb24oc2Nyb2xsUG9zaXRpb24pO1xuICB9XG5cbiAgcHVibGljIGdldFNjcm9sbEludG9WaWV3Q29vcmRpbmF0ZXMoXG4gICAgb3B0aW9uczogUGluT3B0aW9uc1xuICApOiBTY3JvbGxUb0Nvb3JkaW5hdGVzIHtcbiAgICByZXR1cm4ge1xuICAgICAgW3RoaXMuX3Bvc2l0aW9uRGltIGFzIHBvc2l0aW9uXTpcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlU2Nyb2xsSW50b1ZpZXdQb3NpdGlvbihvcHRpb25zKSxcbiAgICB9IGFzIFNjcm9sbFRvT3B0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgX3NlbmRVbnBpbm5lZE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5faG9zdFNpbmsoe1xuICAgICAgdHlwZTogJ3VucGlubmVkJyxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3NlbmRWaXNpYmlsaXR5Q2hhbmdlZE1lc3NhZ2UoKSB7XG4gICAgdGhpcy5faG9zdFNpbmsoe1xuICAgICAgdHlwZTogJ3Zpc2liaWxpdHlDaGFuZ2VkJyxcbiAgICAgIGZpcnN0VmlzaWJsZTogdGhpcy5fZmlyc3RWaXNpYmxlLFxuICAgICAgbGFzdFZpc2libGU6IHRoaXMuX2xhc3RWaXNpYmxlLFxuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zZW5kU3RhdGVDaGFuZ2VkTWVzc2FnZSgpIHtcbiAgICBjb25zdCBjaGlsZFBvc2l0aW9uczogQ2hpbGRQb3NpdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ICE9PSAtMSAmJiB0aGlzLl9sYXN0ICE9PSAtMSkge1xuICAgICAgZm9yIChsZXQgaWR4ID0gdGhpcy5fZmlyc3Q7IGlkeCA8PSB0aGlzLl9sYXN0OyBpZHgrKykge1xuICAgICAgICBjaGlsZFBvc2l0aW9ucy5zZXQoaWR4LCB0aGlzLl9nZXRJdGVtUG9zaXRpb24oaWR4KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2U6IFN0YXRlQ2hhbmdlZE1lc3NhZ2UgPSB7XG4gICAgICB0eXBlOiAnc3RhdGVDaGFuZ2VkJyxcbiAgICAgIHNjcm9sbFNpemU6IHtcbiAgICAgICAgW3RoaXMuX3NpemVEaW1dOiB0aGlzLl9zY3JvbGxTaXplLFxuICAgICAgICBbdGhpcy5fc2Vjb25kYXJ5U2l6ZURpbV06IG51bGwsXG4gICAgICB9IGFzIFNpemUsXG4gICAgICByYW5nZToge1xuICAgICAgICBmaXJzdDogdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhc3Q6IHRoaXMuX2xhc3QsXG4gICAgICAgIGZpcnN0VmlzaWJsZTogdGhpcy5fZmlyc3RWaXNpYmxlLFxuICAgICAgICBsYXN0VmlzaWJsZTogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICB9LFxuICAgICAgY2hpbGRQb3NpdGlvbnMsXG4gICAgfTtcbiAgICBpZiAodGhpcy5fc2Nyb2xsRXJyb3IpIHtcbiAgICAgIG1lc3NhZ2Uuc2Nyb2xsRXJyb3IgPSB7XG4gICAgICAgIFt0aGlzLl9wb3NpdGlvbkRpbV06IHRoaXMuX3Njcm9sbEVycm9yLFxuICAgICAgICBbdGhpcy5fc2Vjb25kYXJ5UG9zaXRpb25EaW1dOiAwLFxuICAgICAgfSBhcyBQb3NpdGlvbnM7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2hvc3RTaW5rKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBpdGVtcyB0byBkaXNwbGF5LlxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgX251bSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgfHwgdGhpcy5fbGFzdCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbGFzdCAtIHRoaXMuX2ZpcnN0ICsgMTtcbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrVGhyZXNob2xkcygpIHtcbiAgICBpZiAoKHRoaXMuX3ZpZXdEaW0xID09PSAwICYmIHRoaXMuX251bSA+IDApIHx8IHRoaXMuX3BpbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWluID0gTWF0aC5tYXgoMCwgdGhpcy5fc2Nyb2xsUG9zaXRpb24gLSB0aGlzLl9vdmVyaGFuZyk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1pbihcbiAgICAgICAgdGhpcy5fc2Nyb2xsU2l6ZSxcbiAgICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gKyB0aGlzLl92aWV3RGltMSArIHRoaXMuX292ZXJoYW5nXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3BoeXNpY2FsTWluID4gbWluIHx8IHRoaXMuX3BoeXNpY2FsTWF4IDwgbWF4KSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91cGRhdGVWaXNpYmxlSW5kaWNlcyh7ZW1pdDogdHJ1ZX0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBmaXJzdCBhbmQgbGFzdCBpdGVtcyB0byBpbnRlcnNlY3QgdGhlIHZpZXdwb3J0LlxuICAgKiBFbWl0IGEgdmlzaWJsZWluZGljZXNjaGFuZ2UgZXZlbnQgd2hlbiBlaXRoZXIgaW5kZXggY2hhbmdlcy5cbiAgICovXG4gIHByb3RlY3RlZCBfdXBkYXRlVmlzaWJsZUluZGljZXMob3B0aW9ucz86IFVwZGF0ZVZpc2libGVJbmRpY2VzT3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9maXJzdCA9PT0gLTEgfHwgdGhpcy5fbGFzdCA9PT0gLTEpIHJldHVybjtcblxuICAgIGxldCBmaXJzdFZpc2libGUgPSB0aGlzLl9maXJzdDtcbiAgICB3aGlsZSAoXG4gICAgICBmaXJzdFZpc2libGUgPCB0aGlzLl9sYXN0ICYmXG4gICAgICBNYXRoLnJvdW5kKFxuICAgICAgICB0aGlzLl9nZXRJdGVtUG9zaXRpb24oZmlyc3RWaXNpYmxlKVt0aGlzLl9wb3NpdGlvbkRpbV0gK1xuICAgICAgICAgIHRoaXMuX2dldEl0ZW1TaXplKGZpcnN0VmlzaWJsZSlbdGhpcy5fc2l6ZURpbV1cbiAgICAgICkgPD0gTWF0aC5yb3VuZCh0aGlzLl9zY3JvbGxQb3NpdGlvbilcbiAgICApIHtcbiAgICAgIGZpcnN0VmlzaWJsZSsrO1xuICAgIH1cblxuICAgIGxldCBsYXN0VmlzaWJsZSA9IHRoaXMuX2xhc3Q7XG4gICAgd2hpbGUgKFxuICAgICAgbGFzdFZpc2libGUgPiB0aGlzLl9maXJzdCAmJlxuICAgICAgTWF0aC5yb3VuZCh0aGlzLl9nZXRJdGVtUG9zaXRpb24obGFzdFZpc2libGUpW3RoaXMuX3Bvc2l0aW9uRGltXSkgPj1cbiAgICAgICAgTWF0aC5yb3VuZCh0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xKVxuICAgICkge1xuICAgICAgbGFzdFZpc2libGUtLTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBmaXJzdFZpc2libGUgIT09IHRoaXMuX2ZpcnN0VmlzaWJsZSB8fFxuICAgICAgbGFzdFZpc2libGUgIT09IHRoaXMuX2xhc3RWaXNpYmxlXG4gICAgKSB7XG4gICAgICB0aGlzLl9maXJzdFZpc2libGUgPSBmaXJzdFZpc2libGU7XG4gICAgICB0aGlzLl9sYXN0VmlzaWJsZSA9IGxhc3RWaXNpYmxlO1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbWl0KSB7XG4gICAgICAgIHRoaXMuX3NlbmRWaXNpYmlsaXR5Q2hhbmdlZE1lc3NhZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\n");

/***/ })

}]);