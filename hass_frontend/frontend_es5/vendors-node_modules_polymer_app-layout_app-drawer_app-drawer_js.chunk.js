"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_polymer_app-layout_app-drawer_app-drawer_js"],{

/***/ "./node_modules/@polymer/app-layout/app-drawer/app-drawer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@polymer/app-layout/app-drawer/app-drawer.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_polymer_legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/polymer-legacy.js */ \"./node_modules/@polymer/polymer/polymer-legacy.js\");\n/* harmony import */ var _polymer_iron_flex_layout_iron_flex_layout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/iron-flex-layout/iron-flex-layout.js */ \"./node_modules/@polymer/iron-flex-layout/iron-flex-layout.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer-fn.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer-fn.js\");\n/* harmony import */ var _polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polymer/polymer/lib/legacy/polymer.dom.js */ \"./node_modules/@polymer/polymer/lib/legacy/polymer.dom.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag.js */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polymer/polymer/lib/utils/render-status.js */ \"./node_modules/@polymer/polymer/lib/utils/render-status.js\");\nvar _templateObject;\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n/**\napp-drawer is a navigation drawer that can slide in from the left or right.\n\nExample:\n\nAlign the drawer at the start, which is left in LTR layouts (default):\n\n```html\n<app-drawer opened></app-drawer>\n```\n\nAlign the drawer at the end:\n\n```html\n<app-drawer align=\"end\" opened></app-drawer>\n```\n\nTo make the contents of the drawer scrollable, create a wrapper for the scroll\ncontent, and apply height and overflow styles to it.\n\n```html\n<app-drawer>\n  <div style=\"height: 100%; overflow: auto;\"></div>\n</app-drawer>\n```\n\n### Styling\n\nCustom property                  | Description                            | Default\n---------------------------------|----------------------------------------|--------------------\n`--app-drawer-width`             | Width of the drawer                    | 256px\n`--app-drawer-content-container` | Mixin for the drawer content container | {}\n`--app-drawer-scrim-background`  | Background for the scrim               | rgba(0, 0, 0, 0.5)\n\n**NOTE:** If you use `<app-drawer>` with `<app-drawer-layout>` and specify a\nvalue for\n`--app-drawer-width`, that value must be accessible by both elements. This can\nbe done by defining the value on the `:host` that contains `<app-drawer-layout>`\n(or `html` if outside a shadow root):\n\n```css\n:host {\n  --app-drawer-width: 300px;\n}\n```\n\n@element app-drawer\n@demo app-drawer/demo/left-drawer.html Simple Left Drawer\n@demo app-drawer/demo/right-drawer.html Right Drawer with Icons\n*/\n\n(0,_polymer_polymer_lib_legacy_polymer_fn_js__WEBPACK_IMPORTED_MODULE_2__.Polymer)({\n  /** @override */\n  _template: (0,_polymer_polymer_lib_utils_html_tag_js__WEBPACK_IMPORTED_MODULE_4__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    <style>\\n      :host {\\n        position: fixed;\\n        top: -120px;\\n        right: 0;\\n        bottom: -120px;\\n        left: 0;\\n\\n        visibility: hidden;\\n\\n        transition-property: visibility;\\n      }\\n\\n      :host([opened]) {\\n        visibility: visible;\\n      }\\n\\n      :host([persistent]) {\\n        width: var(--app-drawer-width, 256px);\\n      }\\n\\n      :host([persistent][position=left]) {\\n        right: auto;\\n      }\\n\\n      :host([persistent][position=right]) {\\n        left: auto;\\n      }\\n\\n      #contentContainer {\\n        position: absolute;\\n        top: 0;\\n        bottom: 0;\\n        left: 0;\\n\\n        width: var(--app-drawer-width, 256px);\\n        padding: var(--app-drawer-content-padding, 120px 0);\\n\\n        transition-property: -webkit-transform;\\n        transition-property: transform;\\n        -webkit-transform: translate3d(-100%, 0, 0);\\n        transform: translate3d(-100%, 0, 0);\\n\\n        background-color: #FFF;\\n\\n        @apply --app-drawer-content-container;\\n      }\\n\\n      #contentContainer[persistent] {\\n        width: 100%;\\n      }\\n\\n      #contentContainer[position=right] {\\n        right: 0;\\n        left: auto;\\n\\n        -webkit-transform: translate3d(100%, 0, 0);\\n        transform: translate3d(100%, 0, 0);\\n      }\\n\\n      #contentContainer[swipe-open]::after {\\n        position: fixed;\\n        top: 0;\\n        bottom: 0;\\n        left: 100%;\\n\\n        visibility: visible;\\n\\n        width: 20px;\\n\\n        content: '';\\n      }\\n\\n      #contentContainer[swipe-open][position=right]::after {\\n        right: 100%;\\n        left: auto;\\n      }\\n\\n      #contentContainer[opened] {\\n        -webkit-transform: translate3d(0, 0, 0);\\n        transform: translate3d(0, 0, 0);\\n      }\\n\\n      #scrim {\\n        position: absolute;\\n        top: 0;\\n        right: 0;\\n        bottom: 0;\\n        left: 0;\\n\\n        transition-property: opacity;\\n        -webkit-transform: translateZ(0);\\n        transform:  translateZ(0);\\n\\n        opacity: 0;\\n        background: var(--app-drawer-scrim-background, rgba(0, 0, 0, 0.5));\\n      }\\n\\n      #scrim.visible {\\n        opacity: 1;\\n      }\\n\\n      :host([no-transition]) #contentContainer {\\n        transition-property: none;\\n      }\\n    </style>\\n\\n    <div id=\\\"scrim\\\" on-click=\\\"close\\\"></div>\\n\\n    <!-- HACK(keanulee): Bind attributes here (in addition to :host) for styling to workaround Safari\\n    bug. https://bugs.webkit.org/show_bug.cgi?id=170762 -->\\n    <div id=\\\"contentContainer\\\" opened$=\\\"[[opened]]\\\" persistent$=\\\"[[persistent]]\\\" position$=\\\"[[position]]\\\" swipe-open$=\\\"[[swipeOpen]]\\\">\\n      <slot></slot>\\n    </div>\\n\"], [\"\\n    <style>\\n      :host {\\n        position: fixed;\\n        top: -120px;\\n        right: 0;\\n        bottom: -120px;\\n        left: 0;\\n\\n        visibility: hidden;\\n\\n        transition-property: visibility;\\n      }\\n\\n      :host([opened]) {\\n        visibility: visible;\\n      }\\n\\n      :host([persistent]) {\\n        width: var(--app-drawer-width, 256px);\\n      }\\n\\n      :host([persistent][position=left]) {\\n        right: auto;\\n      }\\n\\n      :host([persistent][position=right]) {\\n        left: auto;\\n      }\\n\\n      #contentContainer {\\n        position: absolute;\\n        top: 0;\\n        bottom: 0;\\n        left: 0;\\n\\n        width: var(--app-drawer-width, 256px);\\n        padding: var(--app-drawer-content-padding, 120px 0);\\n\\n        transition-property: -webkit-transform;\\n        transition-property: transform;\\n        -webkit-transform: translate3d(-100%, 0, 0);\\n        transform: translate3d(-100%, 0, 0);\\n\\n        background-color: #FFF;\\n\\n        @apply --app-drawer-content-container;\\n      }\\n\\n      #contentContainer[persistent] {\\n        width: 100%;\\n      }\\n\\n      #contentContainer[position=right] {\\n        right: 0;\\n        left: auto;\\n\\n        -webkit-transform: translate3d(100%, 0, 0);\\n        transform: translate3d(100%, 0, 0);\\n      }\\n\\n      #contentContainer[swipe-open]::after {\\n        position: fixed;\\n        top: 0;\\n        bottom: 0;\\n        left: 100%;\\n\\n        visibility: visible;\\n\\n        width: 20px;\\n\\n        content: '';\\n      }\\n\\n      #contentContainer[swipe-open][position=right]::after {\\n        right: 100%;\\n        left: auto;\\n      }\\n\\n      #contentContainer[opened] {\\n        -webkit-transform: translate3d(0, 0, 0);\\n        transform: translate3d(0, 0, 0);\\n      }\\n\\n      #scrim {\\n        position: absolute;\\n        top: 0;\\n        right: 0;\\n        bottom: 0;\\n        left: 0;\\n\\n        transition-property: opacity;\\n        -webkit-transform: translateZ(0);\\n        transform:  translateZ(0);\\n\\n        opacity: 0;\\n        background: var(--app-drawer-scrim-background, rgba(0, 0, 0, 0.5));\\n      }\\n\\n      #scrim.visible {\\n        opacity: 1;\\n      }\\n\\n      :host([no-transition]) #contentContainer {\\n        transition-property: none;\\n      }\\n    </style>\\n\\n    <div id=\\\"scrim\\\" on-click=\\\"close\\\"></div>\\n\\n    <!-- HACK(keanulee): Bind attributes here (in addition to :host) for styling to workaround Safari\\n    bug. https://bugs.webkit.org/show_bug.cgi?id=170762 -->\\n    <div id=\\\"contentContainer\\\" opened\\\\$=\\\"[[opened]]\\\" persistent\\\\$=\\\"[[persistent]]\\\" position\\\\$=\\\"[[position]]\\\" swipe-open\\\\$=\\\"[[swipeOpen]]\\\">\\n      <slot></slot>\\n    </div>\\n\"]))),\n  is: 'app-drawer',\n  properties: {\n    /**\n     * The opened state of the drawer.\n     */\n    opened: {\n      type: Boolean,\n      value: false,\n      notify: true,\n      reflectToAttribute: true\n    },\n\n    /**\n     * The drawer does not have a scrim and cannot be swiped close.\n     */\n    persistent: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true\n    },\n\n    /**\n     * The transition duration of the drawer in milliseconds.\n     */\n    transitionDuration: {\n      type: Number,\n      value: 200\n    },\n\n    /**\n     * The alignment of the drawer on the screen ('left', 'right', 'start' or\n     * 'end'). 'start' computes to left and 'end' to right in LTR layout and\n     * vice versa in RTL layout.\n     */\n    align: {\n      type: String,\n      value: 'left'\n    },\n\n    /**\n     * The computed, read-only position of the drawer on the screen ('left' or\n     * 'right').\n     */\n    position: {\n      type: String,\n      readOnly: true,\n      reflectToAttribute: true\n    },\n\n    /**\n     * Create an area at the edge of the screen to swipe open the drawer.\n     */\n    swipeOpen: {\n      type: Boolean,\n      value: false,\n      reflectToAttribute: true\n    },\n\n    /**\n     * Trap keyboard focus when the drawer is opened and not persistent.\n     */\n    noFocusTrap: {\n      type: Boolean,\n      value: false\n    },\n\n    /**\n     * Disables swiping on the drawer.\n     */\n    disableSwipe: {\n      type: Boolean,\n      value: false\n    }\n  },\n  observers: ['resetLayout(position, isAttached)', '_resetPosition(align, isAttached)', '_styleTransitionDuration(transitionDuration)', '_openedPersistentChanged(opened, persistent)'],\n  _translateOffset: 0,\n  _trackDetails: null,\n  _drawerState: 0,\n  _boundEscKeydownHandler: null,\n  _firstTabStop: null,\n  _lastTabStop: null,\n\n  /** @override */\n  attached: function attached() {\n    (0,_polymer_polymer_lib_utils_render_status_js__WEBPACK_IMPORTED_MODULE_5__.afterNextRender)(this, function () {\n      this._boundEscKeydownHandler = this._escKeydownHandler.bind(this);\n      this.addEventListener('keydown', this._tabKeydownHandler.bind(this)); // Only listen for horizontal track so you can vertically scroll\n      // inside the drawer.\n\n      this.listen(this, 'track', '_track');\n      this.setScrollDirection('y');\n    });\n    this.fire('app-reset-layout');\n  },\n\n  /** @override */\n  detached: function detached() {\n    document.removeEventListener('keydown', this._boundEscKeydownHandler);\n  },\n\n  /**\n   * Opens the drawer.\n   */\n  open: function open() {\n    this.opened = true;\n  },\n\n  /**\n   * Closes the drawer.\n   */\n  close: function close() {\n    this.opened = false;\n  },\n\n  /**\n   * Toggles the drawer open and close.\n   */\n  toggle: function toggle() {\n    this.opened = !this.opened;\n  },\n\n  /**\n   * Gets the width of the drawer.\n   *\n   * @return {number} The width of the drawer in pixels.\n   */\n  getWidth: function getWidth() {\n    return this._savedWidth || this.$.contentContainer.offsetWidth;\n  },\n  _isRTL: function _isRTL() {\n    return window.getComputedStyle(this).direction === 'rtl';\n  },\n  _resetPosition: function _resetPosition() {\n    switch (this.align) {\n      case 'start':\n        this._setPosition(this._isRTL() ? 'right' : 'left');\n\n        return;\n\n      case 'end':\n        this._setPosition(this._isRTL() ? 'left' : 'right');\n\n        return;\n    }\n\n    this._setPosition(this.align);\n  },\n  _escKeydownHandler: function _escKeydownHandler(event) {\n    var ESC_KEYCODE = 27;\n\n    if (event.keyCode === ESC_KEYCODE) {\n      // Prevent any side effects if app-drawer closes.\n      event.preventDefault();\n      this.close();\n    }\n  },\n  _track: function _track(event) {\n    if (this.persistent || this.disableSwipe) {\n      return;\n    } // Disable user selection on desktop.\n\n\n    event.preventDefault();\n\n    switch (event.detail.state) {\n      case 'start':\n        this._trackStart(event);\n\n        break;\n\n      case 'track':\n        this._trackMove(event);\n\n        break;\n\n      case 'end':\n        this._trackEnd(event);\n\n        break;\n    }\n  },\n  _trackStart: function _trackStart(event) {\n    this._drawerState = this._DRAWER_STATE.TRACKING;\n    var rect = this.$.contentContainer.getBoundingClientRect();\n    this._savedWidth = rect.width;\n\n    if (this.position === 'left') {\n      this._translateOffset = rect.left;\n    } else {\n      this._translateOffset = rect.right - window.innerWidth;\n    }\n\n    this._trackDetails = []; // Disable transitions since style attributes will reflect user track\n    // events.\n\n    this._styleTransitionDuration(0);\n\n    this.style.visibility = 'visible';\n  },\n  _trackMove: function _trackMove(event) {\n    this._translateDrawer(event.detail.dx + this._translateOffset); // Use Date.now() since event.timeStamp is inconsistent across browsers\n    // (e.g. most browsers use milliseconds but FF 44 uses microseconds).\n\n\n    this._trackDetails.push({\n      dx: event.detail.dx,\n      timeStamp: Date.now()\n    });\n  },\n  _trackEnd: function _trackEnd(event) {\n    var x = event.detail.dx + this._translateOffset;\n    var drawerWidth = this.getWidth();\n    var isPositionLeft = this.position === 'left';\n    var isInEndState = isPositionLeft ? x >= 0 || x <= -drawerWidth : x <= 0 || x >= drawerWidth;\n\n    if (!isInEndState) {\n      // No longer need the track events after this method returns - allow them\n      // to be GC'd.\n      var trackDetails = this._trackDetails;\n      this._trackDetails = null;\n\n      this._flingDrawer(event, trackDetails);\n\n      if (this._drawerState === this._DRAWER_STATE.FLINGING) {\n        return;\n      }\n    } // If the drawer is not flinging, toggle the opened state based on the\n    // position of the drawer.\n\n\n    var halfWidth = drawerWidth / 2;\n\n    if (event.detail.dx < -halfWidth) {\n      this.opened = this.position === 'right';\n    } else if (event.detail.dx > halfWidth) {\n      this.opened = this.position === 'left';\n    }\n\n    if (isInEndState) {\n      this.debounce('_resetDrawerState', this._resetDrawerState);\n    } else {\n      this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);\n    }\n\n    this._styleTransitionDuration(this.transitionDuration);\n\n    this._resetDrawerTranslate();\n\n    this.style.visibility = '';\n  },\n  _calculateVelocity: function _calculateVelocity(event, trackDetails) {\n    // Find the oldest track event that is within 100ms using binary search.\n    var now = Date.now();\n    var timeLowerBound = now - 100;\n    var trackDetail;\n    var min = 0;\n    var max = trackDetails.length - 1;\n\n    while (min <= max) {\n      // Floor of average of min and max.\n      var mid = min + max >> 1;\n      var d = trackDetails[mid];\n\n      if (d.timeStamp >= timeLowerBound) {\n        trackDetail = d;\n        max = mid - 1;\n      } else {\n        min = mid + 1;\n      }\n    }\n\n    if (trackDetail) {\n      var dx = event.detail.dx - trackDetail.dx;\n      var dt = now - trackDetail.timeStamp || 1;\n      return dx / dt;\n    }\n\n    return 0;\n  },\n  _flingDrawer: function _flingDrawer(event, trackDetails) {\n    var velocity = this._calculateVelocity(event, trackDetails); // Do not fling if velocity is not above a threshold.\n\n\n    if (Math.abs(velocity) < this._MIN_FLING_THRESHOLD) {\n      return;\n    }\n\n    this._drawerState = this._DRAWER_STATE.FLINGING;\n    var x = event.detail.dx + this._translateOffset;\n    var drawerWidth = this.getWidth();\n    var isPositionLeft = this.position === 'left';\n    var isVelocityPositive = velocity > 0;\n    var isClosingLeft = !isVelocityPositive && isPositionLeft;\n    var isClosingRight = isVelocityPositive && !isPositionLeft;\n    var dx;\n\n    if (isClosingLeft) {\n      dx = -(x + drawerWidth);\n    } else if (isClosingRight) {\n      dx = drawerWidth - x;\n    } else {\n      dx = -x;\n    } // Enforce a minimum transition velocity to make the drawer feel snappy.\n\n\n    if (isVelocityPositive) {\n      velocity = Math.max(velocity, this._MIN_TRANSITION_VELOCITY);\n      this.opened = this.position === 'left';\n    } else {\n      velocity = Math.min(velocity, -this._MIN_TRANSITION_VELOCITY);\n      this.opened = this.position === 'right';\n    } // Calculate the amount of time needed to finish the transition based on the\n    // initial slope of the timing function.\n\n\n    var t = this._FLING_INITIAL_SLOPE * dx / velocity;\n\n    this._styleTransitionDuration(t);\n\n    this._styleTransitionTimingFunction(this._FLING_TIMING_FUNCTION);\n\n    this._resetDrawerTranslate();\n\n    this.debounce('_resetDrawerState', this._resetDrawerState, t);\n  },\n  _styleTransitionDuration: function _styleTransitionDuration(duration) {\n    this.style.transitionDuration = duration + 'ms';\n    this.$.contentContainer.style.transitionDuration = duration + 'ms';\n    this.$.scrim.style.transitionDuration = duration + 'ms';\n  },\n  _styleTransitionTimingFunction: function _styleTransitionTimingFunction(timingFunction) {\n    this.$.contentContainer.style.transitionTimingFunction = timingFunction;\n    this.$.scrim.style.transitionTimingFunction = timingFunction;\n  },\n  _translateDrawer: function _translateDrawer(x) {\n    var drawerWidth = this.getWidth();\n\n    if (this.position === 'left') {\n      x = Math.max(-drawerWidth, Math.min(x, 0));\n      this.$.scrim.style.opacity = 1 + x / drawerWidth;\n    } else {\n      x = Math.max(0, Math.min(x, drawerWidth));\n      this.$.scrim.style.opacity = 1 - x / drawerWidth;\n    }\n\n    this.translate3d(x + 'px', '0', '0', this.$.contentContainer);\n  },\n  _resetDrawerTranslate: function _resetDrawerTranslate() {\n    this.$.scrim.style.opacity = '';\n    this.transform('', this.$.contentContainer);\n  },\n  _resetDrawerState: function _resetDrawerState() {\n    var oldState = this._drawerState; // If the drawer was flinging, we need to reset the style attributes.\n\n    if (oldState === this._DRAWER_STATE.FLINGING) {\n      this._styleTransitionDuration(this.transitionDuration);\n\n      this._styleTransitionTimingFunction('');\n\n      this.style.visibility = '';\n    }\n\n    this._savedWidth = null;\n\n    if (this.opened) {\n      this._drawerState = this.persistent ? this._DRAWER_STATE.OPENED_PERSISTENT : this._DRAWER_STATE.OPENED;\n    } else {\n      this._drawerState = this._DRAWER_STATE.CLOSED;\n    }\n\n    if (oldState !== this._drawerState) {\n      if (this._drawerState === this._DRAWER_STATE.OPENED) {\n        this._setKeyboardFocusTrap();\n\n        document.addEventListener('keydown', this._boundEscKeydownHandler);\n        document.body.style.overflow = 'hidden';\n      } else {\n        document.removeEventListener('keydown', this._boundEscKeydownHandler);\n        document.body.style.overflow = '';\n      } // Don't fire the event on initial load.\n\n\n      if (oldState !== this._DRAWER_STATE.INIT) {\n        this.fire('app-drawer-transitioned');\n      }\n    }\n  },\n\n  /**\n   * Resets the layout.\n   *\n   * @method resetLayout\n   */\n  resetLayout: function resetLayout() {\n    this.fire('app-reset-layout');\n  },\n  _setKeyboardFocusTrap: function _setKeyboardFocusTrap() {\n    if (this.noFocusTrap) {\n      return;\n    } // NOTE: Unless we use /deep/ (which we shouldn't since it's deprecated),\n    // this will not select focusable elements inside shadow roots.\n\n\n    var focusableElementsSelector = ['a[href]:not([tabindex=\"-1\"])', 'area[href]:not([tabindex=\"-1\"])', 'input:not([disabled]):not([tabindex=\"-1\"])', 'select:not([disabled]):not([tabindex=\"-1\"])', 'textarea:not([disabled]):not([tabindex=\"-1\"])', 'button:not([disabled]):not([tabindex=\"-1\"])', 'iframe:not([tabindex=\"-1\"])', '[tabindex]:not([tabindex=\"-1\"])', '[contentEditable=true]:not([tabindex=\"-1\"])'].join(',');\n    var focusableElements = (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__.dom)(this).querySelectorAll(focusableElementsSelector);\n\n    if (focusableElements.length > 0) {\n      this._firstTabStop = focusableElements[0];\n      this._lastTabStop = focusableElements[focusableElements.length - 1];\n    } else {\n      // Reset saved tab stops when there are no focusable elements in the\n      // drawer.\n      this._firstTabStop = null;\n      this._lastTabStop = null;\n    } // Focus on app-drawer if it has non-zero tabindex. Otherwise, focus the\n    // first focusable element in the drawer, if it exists. Use the tabindex\n    // attribute since the this.tabIndex property in IE/Edge returns 0 (instead\n    // of -1) when the attribute is not set.\n\n\n    var tabindex = this.getAttribute('tabindex');\n\n    if (tabindex && parseInt(tabindex, 10) > -1) {\n      this.focus();\n    } else if (this._firstTabStop) {\n      this._firstTabStop.focus();\n    }\n  },\n  _tabKeydownHandler: function _tabKeydownHandler(event) {\n    if (this.noFocusTrap) {\n      return;\n    }\n\n    var TAB_KEYCODE = 9;\n\n    if (this._drawerState === this._DRAWER_STATE.OPENED && event.keyCode === TAB_KEYCODE) {\n      if (event.shiftKey) {\n        if (this._firstTabStop && (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__.dom)(event).localTarget === this._firstTabStop) {\n          event.preventDefault();\n\n          this._lastTabStop.focus();\n        }\n      } else {\n        if (this._lastTabStop && (0,_polymer_polymer_lib_legacy_polymer_dom_js__WEBPACK_IMPORTED_MODULE_3__.dom)(event).localTarget === this._lastTabStop) {\n          event.preventDefault();\n\n          this._firstTabStop.focus();\n        }\n      }\n    }\n  },\n  _openedPersistentChanged: function _openedPersistentChanged(opened, persistent) {\n    this.toggleClass('visible', opened && !persistent, this.$.scrim); // Use a debounce timer instead of transitionend since transitionend won't\n    // fire when app-drawer is display: none.\n\n    this.debounce('_resetDrawerState', this._resetDrawerState, this.transitionDuration);\n  },\n  _MIN_FLING_THRESHOLD: 0.2,\n  _MIN_TRANSITION_VELOCITY: 1.2,\n  _FLING_TIMING_FUNCTION: 'cubic-bezier(0.667, 1, 0.667, 1)',\n  _FLING_INITIAL_SLOPE: 1.5,\n  _DRAWER_STATE: {\n    INIT: 0,\n    OPENED: 1,\n    OPENED_PERSISTENT: 2,\n    CLOSED: 3,\n    TRACKING: 4,\n    FLINGING: 5\n  }\n  /**\n   * Fired when the layout of app-drawer has changed.\n   *\n   * @event app-reset-layout\n   */\n\n  /**\n   * Fired when app-drawer has finished transitioning.\n   *\n   * @event app-drawer-transitioned\n   */\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBcUhBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUEzQ0E7QUE4Q0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFOQTs7QUFRQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQVRBO0FBV0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBR0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUNBO0FBV0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7O0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUEva0JBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvYXBwLWxheW91dC9hcHAtZHJhd2VyL2FwcC1kcmF3ZXIuanM/NTUyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTUgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZVxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXNcbnBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnRcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWxlZ2FjeS5qcyc7XG5pbXBvcnQgJ0Bwb2x5bWVyL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5cbmltcG9ydCB7UG9seW1lcn0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHtkb219IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5pbXBvcnQge2h0bWx9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2h0bWwtdGFnLmpzJztcbmltcG9ydCB7YWZ0ZXJOZXh0UmVuZGVyfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcblxuLyoqXG5hcHAtZHJhd2VyIGlzIGEgbmF2aWdhdGlvbiBkcmF3ZXIgdGhhdCBjYW4gc2xpZGUgaW4gZnJvbSB0aGUgbGVmdCBvciByaWdodC5cblxuRXhhbXBsZTpcblxuQWxpZ24gdGhlIGRyYXdlciBhdCB0aGUgc3RhcnQsIHdoaWNoIGlzIGxlZnQgaW4gTFRSIGxheW91dHMgKGRlZmF1bHQpOlxuXG5gYGBodG1sXG48YXBwLWRyYXdlciBvcGVuZWQ+PC9hcHAtZHJhd2VyPlxuYGBgXG5cbkFsaWduIHRoZSBkcmF3ZXIgYXQgdGhlIGVuZDpcblxuYGBgaHRtbFxuPGFwcC1kcmF3ZXIgYWxpZ249XCJlbmRcIiBvcGVuZWQ+PC9hcHAtZHJhd2VyPlxuYGBgXG5cblRvIG1ha2UgdGhlIGNvbnRlbnRzIG9mIHRoZSBkcmF3ZXIgc2Nyb2xsYWJsZSwgY3JlYXRlIGEgd3JhcHBlciBmb3IgdGhlIHNjcm9sbFxuY29udGVudCwgYW5kIGFwcGx5IGhlaWdodCBhbmQgb3ZlcmZsb3cgc3R5bGVzIHRvIGl0LlxuXG5gYGBodG1sXG48YXBwLWRyYXdlcj5cbiAgPGRpdiBzdHlsZT1cImhlaWdodDogMTAwJTsgb3ZlcmZsb3c6IGF1dG87XCI+PC9kaXY+XG48L2FwcC1kcmF3ZXI+XG5gYGBcblxuIyMjIFN0eWxpbmdcblxuQ3VzdG9tIHByb3BlcnR5ICAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IERlZmF1bHRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5gLS1hcHAtZHJhd2VyLXdpZHRoYCAgICAgICAgICAgICB8IFdpZHRoIG9mIHRoZSBkcmF3ZXIgICAgICAgICAgICAgICAgICAgIHwgMjU2cHhcbmAtLWFwcC1kcmF3ZXItY29udGVudC1jb250YWluZXJgIHwgTWl4aW4gZm9yIHRoZSBkcmF3ZXIgY29udGVudCBjb250YWluZXIgfCB7fVxuYC0tYXBwLWRyYXdlci1zY3JpbS1iYWNrZ3JvdW5kYCAgfCBCYWNrZ3JvdW5kIGZvciB0aGUgc2NyaW0gICAgICAgICAgICAgICB8IHJnYmEoMCwgMCwgMCwgMC41KVxuXG4qKk5PVEU6KiogSWYgeW91IHVzZSBgPGFwcC1kcmF3ZXI+YCB3aXRoIGA8YXBwLWRyYXdlci1sYXlvdXQ+YCBhbmQgc3BlY2lmeSBhXG52YWx1ZSBmb3JcbmAtLWFwcC1kcmF3ZXItd2lkdGhgLCB0aGF0IHZhbHVlIG11c3QgYmUgYWNjZXNzaWJsZSBieSBib3RoIGVsZW1lbnRzLiBUaGlzIGNhblxuYmUgZG9uZSBieSBkZWZpbmluZyB0aGUgdmFsdWUgb24gdGhlIGA6aG9zdGAgdGhhdCBjb250YWlucyBgPGFwcC1kcmF3ZXItbGF5b3V0PmBcbihvciBgaHRtbGAgaWYgb3V0c2lkZSBhIHNoYWRvdyByb290KTpcblxuYGBgY3NzXG46aG9zdCB7XG4gIC0tYXBwLWRyYXdlci13aWR0aDogMzAwcHg7XG59XG5gYGBcblxuQGVsZW1lbnQgYXBwLWRyYXdlclxuQGRlbW8gYXBwLWRyYXdlci9kZW1vL2xlZnQtZHJhd2VyLmh0bWwgU2ltcGxlIExlZnQgRHJhd2VyXG5AZGVtbyBhcHAtZHJhd2VyL2RlbW8vcmlnaHQtZHJhd2VyLmh0bWwgUmlnaHQgRHJhd2VyIHdpdGggSWNvbnNcbiovXG5Qb2x5bWVyKHtcbiAgLyoqIEBvdmVycmlkZSAqL1xuICBfdGVtcGxhdGU6IGh0bWxgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogLTEyMHB4O1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAtMTIwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG5cbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IHZpc2liaWxpdHk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtvcGVuZWRdKSB7XG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XSkge1xuICAgICAgICB3aWR0aDogdmFyKC0tYXBwLWRyYXdlci13aWR0aCwgMjU2cHgpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbcGVyc2lzdGVudF1bcG9zaXRpb249bGVmdF0pIHtcbiAgICAgICAgcmlnaHQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtwZXJzaXN0ZW50XVtwb3NpdGlvbj1yaWdodF0pIHtcbiAgICAgICAgbGVmdDogYXV0bztcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHdpZHRoOiB2YXIoLS1hcHAtZHJhd2VyLXdpZHRoLCAyNTZweCk7XG4gICAgICAgIHBhZGRpbmc6IHZhcigtLWFwcC1kcmF3ZXItY29udGVudC1wYWRkaW5nLCAxMjBweCAwKTtcblxuICAgICAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiAtd2Via2l0LXRyYW5zZm9ybTtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTtcblxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGO1xuXG4gICAgICAgIEBhcHBseSAtLWFwcC1kcmF3ZXItY29udGVudC1jb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3BlcnNpc3RlbnRdIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW3Bvc2l0aW9uPXJpZ2h0XSB7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2NvbnRlbnRDb250YWluZXJbc3dpcGUtb3Blbl06OmFmdGVyIHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMTAwJTtcblxuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuXG4gICAgICAgIHdpZHRoOiAyMHB4O1xuXG4gICAgICAgIGNvbnRlbnQ6ICcnO1xuICAgICAgfVxuXG4gICAgICAjY29udGVudENvbnRhaW5lcltzd2lwZS1vcGVuXVtwb3NpdGlvbj1yaWdodF06OmFmdGVyIHtcbiAgICAgICAgcmlnaHQ6IDEwMCU7XG4gICAgICAgIGxlZnQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgICNjb250ZW50Q29udGFpbmVyW29wZW5lZF0ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNzY3JpbSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuXG4gICAgICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IG9wYWNpdHk7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVaKDApO1xuICAgICAgICB0cmFuc2Zvcm06ICB0cmFuc2xhdGVaKDApO1xuXG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLWFwcC1kcmF3ZXItc2NyaW0tYmFja2dyb3VuZCwgcmdiYSgwLCAwLCAwLCAwLjUpKTtcbiAgICAgIH1cblxuICAgICAgI3NjcmltLnZpc2libGUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbbm8tdHJhbnNpdGlvbl0pICNjb250ZW50Q29udGFpbmVyIHtcbiAgICAgICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cInNjcmltXCIgb24tY2xpY2s9XCJjbG9zZVwiPjwvZGl2PlxuXG4gICAgPCEtLSBIQUNLKGtlYW51bGVlKTogQmluZCBhdHRyaWJ1dGVzIGhlcmUgKGluIGFkZGl0aW9uIHRvIDpob3N0KSBmb3Igc3R5bGluZyB0byB3b3JrYXJvdW5kIFNhZmFyaVxuICAgIGJ1Zy4gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDc2MiAtLT5cbiAgICA8ZGl2IGlkPVwiY29udGVudENvbnRhaW5lclwiIG9wZW5lZFxcJD1cIltbb3BlbmVkXV1cIiBwZXJzaXN0ZW50XFwkPVwiW1twZXJzaXN0ZW50XV1cIiBwb3NpdGlvblxcJD1cIltbcG9zaXRpb25dXVwiIHN3aXBlLW9wZW5cXCQ9XCJbW3N3aXBlT3Blbl1dXCI+XG4gICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgPC9kaXY+XG5gLFxuXG4gIGlzOiAnYXBwLWRyYXdlcicsXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIGRyYXdlci5cbiAgICAgKi9cbiAgICBvcGVuZWQ6XG4gICAgICAgIHt0eXBlOiBCb29sZWFuLCB2YWx1ZTogZmFsc2UsIG5vdGlmeTogdHJ1ZSwgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkcmF3ZXIgZG9lcyBub3QgaGF2ZSBhIHNjcmltIGFuZCBjYW5ub3QgYmUgc3dpcGVkIGNsb3NlLlxuICAgICAqL1xuICAgIHBlcnNpc3RlbnQ6IHt0eXBlOiBCb29sZWFuLCB2YWx1ZTogZmFsc2UsIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZX0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBvZiB0aGUgZHJhd2VyIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IHt0eXBlOiBOdW1iZXIsIHZhbHVlOiAyMDB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGFsaWdubWVudCBvZiB0aGUgZHJhd2VyIG9uIHRoZSBzY3JlZW4gKCdsZWZ0JywgJ3JpZ2h0JywgJ3N0YXJ0JyBvclxuICAgICAqICdlbmQnKS4gJ3N0YXJ0JyBjb21wdXRlcyB0byBsZWZ0IGFuZCAnZW5kJyB0byByaWdodCBpbiBMVFIgbGF5b3V0IGFuZFxuICAgICAqIHZpY2UgdmVyc2EgaW4gUlRMIGxheW91dC5cbiAgICAgKi9cbiAgICBhbGlnbjoge3R5cGU6IFN0cmluZywgdmFsdWU6ICdsZWZ0J30sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29tcHV0ZWQsIHJlYWQtb25seSBwb3NpdGlvbiBvZiB0aGUgZHJhd2VyIG9uIHRoZSBzY3JlZW4gKCdsZWZ0JyBvclxuICAgICAqICdyaWdodCcpLlxuICAgICAqL1xuICAgIHBvc2l0aW9uOiB7dHlwZTogU3RyaW5nLCByZWFkT25seTogdHJ1ZSwgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlfSxcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhcmVhIGF0IHRoZSBlZGdlIG9mIHRoZSBzY3JlZW4gdG8gc3dpcGUgb3BlbiB0aGUgZHJhd2VyLlxuICAgICAqL1xuICAgIHN3aXBlT3Blbjoge3R5cGU6IEJvb2xlYW4sIHZhbHVlOiBmYWxzZSwgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlfSxcblxuICAgIC8qKlxuICAgICAqIFRyYXAga2V5Ym9hcmQgZm9jdXMgd2hlbiB0aGUgZHJhd2VyIGlzIG9wZW5lZCBhbmQgbm90IHBlcnNpc3RlbnQuXG4gICAgICovXG4gICAgbm9Gb2N1c1RyYXA6IHt0eXBlOiBCb29sZWFuLCB2YWx1ZTogZmFsc2V9LFxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgc3dpcGluZyBvbiB0aGUgZHJhd2VyLlxuICAgICAqL1xuICAgIGRpc2FibGVTd2lwZToge3R5cGU6IEJvb2xlYW4sIHZhbHVlOiBmYWxzZX1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAncmVzZXRMYXlvdXQocG9zaXRpb24sIGlzQXR0YWNoZWQpJyxcbiAgICAnX3Jlc2V0UG9zaXRpb24oYWxpZ24sIGlzQXR0YWNoZWQpJyxcbiAgICAnX3N0eWxlVHJhbnNpdGlvbkR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbiknLFxuICAgICdfb3BlbmVkUGVyc2lzdGVudENoYW5nZWQob3BlbmVkLCBwZXJzaXN0ZW50KSdcbiAgXSxcblxuICBfdHJhbnNsYXRlT2Zmc2V0OiAwLFxuICBfdHJhY2tEZXRhaWxzOiBudWxsLFxuICBfZHJhd2VyU3RhdGU6IDAsXG4gIF9ib3VuZEVzY0tleWRvd25IYW5kbGVyOiBudWxsLFxuICBfZmlyc3RUYWJTdG9wOiBudWxsLFxuICBfbGFzdFRhYlN0b3A6IG51bGwsXG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgYWZ0ZXJOZXh0UmVuZGVyKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlciA9IHRoaXMuX2VzY0tleWRvd25IYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl90YWJLZXlkb3duSGFuZGxlci5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gT25seSBsaXN0ZW4gZm9yIGhvcml6b250YWwgdHJhY2sgc28geW91IGNhbiB2ZXJ0aWNhbGx5IHNjcm9sbFxuICAgICAgLy8gaW5zaWRlIHRoZSBkcmF3ZXIuXG4gICAgICB0aGlzLmxpc3Rlbih0aGlzLCAndHJhY2snLCAnX3RyYWNrJyk7XG4gICAgICB0aGlzLnNldFNjcm9sbERpcmVjdGlvbigneScpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gIH0sXG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2JvdW5kRXNjS2V5ZG93bkhhbmRsZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPcGVucyB0aGUgZHJhd2VyLlxuICAgKi9cbiAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGRyYXdlci5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBkcmF3ZXIgb3BlbiBhbmQgY2xvc2UuXG4gICAqL1xuICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3BlbmVkID0gIXRoaXMub3BlbmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZHJhd2VyIGluIHBpeGVscy5cbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2F2ZWRXaWR0aCB8fCB0aGlzLiQuY29udGVudENvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgfSxcblxuICBfaXNSVEw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICB9LFxuXG4gIF9yZXNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuYWxpZ24pIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24odGhpcy5faXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbih0aGlzLl9pc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2V0UG9zaXRpb24odGhpcy5hbGlnbik7XG4gIH0sXG5cbiAgX2VzY0tleWRvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBFU0NfS0VZQ09ERSA9IDI3O1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NfS0VZQ09ERSkge1xuICAgICAgLy8gUHJldmVudCBhbnkgc2lkZSBlZmZlY3RzIGlmIGFwcC1kcmF3ZXIgY2xvc2VzLlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH0sXG5cbiAgX3RyYWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy5kaXNhYmxlU3dpcGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIHVzZXIgc2VsZWN0aW9uIG9uIGRlc2t0b3AuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHN3aXRjaCAoZXZlbnQuZGV0YWlsLnN0YXRlKSB7XG4gICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgIHRoaXMuX3RyYWNrU3RhcnQoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RyYWNrJzpcbiAgICAgICAgdGhpcy5fdHJhY2tNb3ZlKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmQnOlxuICAgICAgICB0aGlzLl90cmFja0VuZChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcblxuICBfdHJhY2tTdGFydDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLl9kcmF3ZXJTdGF0ZSA9IHRoaXMuX0RSQVdFUl9TVEFURS5UUkFDS0lORztcblxuICAgIHZhciByZWN0ID0gdGhpcy4kLmNvbnRlbnRDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5fc2F2ZWRXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5fdHJhbnNsYXRlT2Zmc2V0ID0gcmVjdC5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90cmFuc2xhdGVPZmZzZXQgPSByZWN0LnJpZ2h0IC0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhY2tEZXRhaWxzID0gW107XG5cbiAgICAvLyBEaXNhYmxlIHRyYW5zaXRpb25zIHNpbmNlIHN0eWxlIGF0dHJpYnV0ZXMgd2lsbCByZWZsZWN0IHVzZXIgdHJhY2tcbiAgICAvLyBldmVudHMuXG4gICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24oMCk7XG4gICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB9LFxuXG4gIF90cmFja01vdmU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fdHJhbnNsYXRlRHJhd2VyKGV2ZW50LmRldGFpbC5keCArIHRoaXMuX3RyYW5zbGF0ZU9mZnNldCk7XG5cbiAgICAvLyBVc2UgRGF0ZS5ub3coKSBzaW5jZSBldmVudC50aW1lU3RhbXAgaXMgaW5jb25zaXN0ZW50IGFjcm9zcyBicm93c2Vyc1xuICAgIC8vIChlLmcuIG1vc3QgYnJvd3NlcnMgdXNlIG1pbGxpc2Vjb25kcyBidXQgRkYgNDQgdXNlcyBtaWNyb3NlY29uZHMpLlxuICAgIHRoaXMuX3RyYWNrRGV0YWlscy5wdXNoKHtkeDogZXZlbnQuZGV0YWlsLmR4LCB0aW1lU3RhbXA6IERhdGUubm93KCl9KTtcbiAgfSxcblxuICBfdHJhY2tFbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHggPSBldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQ7XG4gICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHZhciBpc1Bvc2l0aW9uTGVmdCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICB2YXIgaXNJbkVuZFN0YXRlID0gaXNQb3NpdGlvbkxlZnQgPyAoeCA+PSAwIHx8IHggPD0gLWRyYXdlcldpZHRoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHggPD0gMCB8fCB4ID49IGRyYXdlcldpZHRoKTtcblxuICAgIGlmICghaXNJbkVuZFN0YXRlKSB7XG4gICAgICAvLyBObyBsb25nZXIgbmVlZCB0aGUgdHJhY2sgZXZlbnRzIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMgLSBhbGxvdyB0aGVtXG4gICAgICAvLyB0byBiZSBHQydkLlxuICAgICAgdmFyIHRyYWNrRGV0YWlscyA9IHRoaXMuX3RyYWNrRGV0YWlscztcbiAgICAgIHRoaXMuX3RyYWNrRGV0YWlscyA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2ZsaW5nRHJhd2VyKGV2ZW50LCB0cmFja0RldGFpbHMpO1xuICAgICAgaWYgKHRoaXMuX2RyYXdlclN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuRkxJTkdJTkcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBkcmF3ZXIgaXMgbm90IGZsaW5naW5nLCB0b2dnbGUgdGhlIG9wZW5lZCBzdGF0ZSBiYXNlZCBvbiB0aGVcbiAgICAvLyBwb3NpdGlvbiBvZiB0aGUgZHJhd2VyLlxuICAgIHZhciBoYWxmV2lkdGggPSBkcmF3ZXJXaWR0aCAvIDI7XG4gICAgaWYgKGV2ZW50LmRldGFpbC5keCA8IC1oYWxmV2lkdGgpIHtcbiAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbC5keCA+IGhhbGZXaWR0aCkge1xuICAgICAgdGhpcy5vcGVuZWQgPSB0aGlzLnBvc2l0aW9uID09PSAnbGVmdCc7XG4gICAgfVxuXG4gICAgaWYgKGlzSW5FbmRTdGF0ZSkge1xuICAgICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJvdW5jZShcbiAgICAgICAgICAnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIHRoaXMuX3Jlc2V0RHJhd2VyVHJhbnNsYXRlKCk7XG4gICAgdGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gIH0sXG5cbiAgX2NhbGN1bGF0ZVZlbG9jaXR5OiBmdW5jdGlvbihldmVudCwgdHJhY2tEZXRhaWxzKSB7XG4gICAgLy8gRmluZCB0aGUgb2xkZXN0IHRyYWNrIGV2ZW50IHRoYXQgaXMgd2l0aGluIDEwMG1zIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWVMb3dlckJvdW5kID0gbm93IC0gMTAwO1xuICAgIHZhciB0cmFja0RldGFpbDtcbiAgICB2YXIgbWluID0gMDtcbiAgICB2YXIgbWF4ID0gdHJhY2tEZXRhaWxzLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZSAobWluIDw9IG1heCkge1xuICAgICAgLy8gRmxvb3Igb2YgYXZlcmFnZSBvZiBtaW4gYW5kIG1heC5cbiAgICAgIHZhciBtaWQgPSAobWluICsgbWF4KSA+PiAxO1xuICAgICAgdmFyIGQgPSB0cmFja0RldGFpbHNbbWlkXTtcbiAgICAgIGlmIChkLnRpbWVTdGFtcCA+PSB0aW1lTG93ZXJCb3VuZCkge1xuICAgICAgICB0cmFja0RldGFpbCA9IGQ7XG4gICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFja0RldGFpbCkge1xuICAgICAgdmFyIGR4ID0gZXZlbnQuZGV0YWlsLmR4IC0gdHJhY2tEZXRhaWwuZHg7XG4gICAgICB2YXIgZHQgPSAobm93IC0gdHJhY2tEZXRhaWwudGltZVN0YW1wKSB8fCAxO1xuICAgICAgcmV0dXJuIGR4IC8gZHQ7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIF9mbGluZ0RyYXdlcjogZnVuY3Rpb24oZXZlbnQsIHRyYWNrRGV0YWlscykge1xuICAgIHZhciB2ZWxvY2l0eSA9IHRoaXMuX2NhbGN1bGF0ZVZlbG9jaXR5KGV2ZW50LCB0cmFja0RldGFpbHMpO1xuXG4gICAgLy8gRG8gbm90IGZsaW5nIGlmIHZlbG9jaXR5IGlzIG5vdCBhYm92ZSBhIHRocmVzaG9sZC5cbiAgICBpZiAoTWF0aC5hYnModmVsb2NpdHkpIDwgdGhpcy5fTUlOX0ZMSU5HX1RIUkVTSE9MRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RyYXdlclN0YXRlID0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HO1xuXG4gICAgdmFyIHggPSBldmVudC5kZXRhaWwuZHggKyB0aGlzLl90cmFuc2xhdGVPZmZzZXQ7XG4gICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHZhciBpc1Bvc2l0aW9uTGVmdCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICB2YXIgaXNWZWxvY2l0eVBvc2l0aXZlID0gdmVsb2NpdHkgPiAwO1xuICAgIHZhciBpc0Nsb3NpbmdMZWZ0ID0gIWlzVmVsb2NpdHlQb3NpdGl2ZSAmJiBpc1Bvc2l0aW9uTGVmdDtcbiAgICB2YXIgaXNDbG9zaW5nUmlnaHQgPSBpc1ZlbG9jaXR5UG9zaXRpdmUgJiYgIWlzUG9zaXRpb25MZWZ0O1xuICAgIHZhciBkeDtcbiAgICBpZiAoaXNDbG9zaW5nTGVmdCkge1xuICAgICAgZHggPSAtKHggKyBkcmF3ZXJXaWR0aCk7XG4gICAgfSBlbHNlIGlmIChpc0Nsb3NpbmdSaWdodCkge1xuICAgICAgZHggPSAoZHJhd2VyV2lkdGggLSB4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHggPSAteDtcbiAgICB9XG5cbiAgICAvLyBFbmZvcmNlIGEgbWluaW11bSB0cmFuc2l0aW9uIHZlbG9jaXR5IHRvIG1ha2UgdGhlIGRyYXdlciBmZWVsIHNuYXBweS5cbiAgICBpZiAoaXNWZWxvY2l0eVBvc2l0aXZlKSB7XG4gICAgICB2ZWxvY2l0eSA9IE1hdGgubWF4KHZlbG9jaXR5LCB0aGlzLl9NSU5fVFJBTlNJVElPTl9WRUxPQ0lUWSk7XG4gICAgICB0aGlzLm9wZW5lZCA9IHRoaXMucG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdmVsb2NpdHkgPSBNYXRoLm1pbih2ZWxvY2l0eSwgLXRoaXMuX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZKTtcbiAgICAgIHRoaXMub3BlbmVkID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFtb3VudCBvZiB0aW1lIG5lZWRlZCB0byBmaW5pc2ggdGhlIHRyYW5zaXRpb24gYmFzZWQgb24gdGhlXG4gICAgLy8gaW5pdGlhbCBzbG9wZSBvZiB0aGUgdGltaW5nIGZ1bmN0aW9uLlxuICAgIHZhciB0ID0gdGhpcy5fRkxJTkdfSU5JVElBTF9TTE9QRSAqIGR4IC8gdmVsb2NpdHk7XG4gICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uRHVyYXRpb24odCk7XG4gICAgdGhpcy5fc3R5bGVUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb24odGhpcy5fRkxJTkdfVElNSU5HX0ZVTkNUSU9OKTtcblxuICAgIHRoaXMuX3Jlc2V0RHJhd2VyVHJhbnNsYXRlKCk7XG4gICAgdGhpcy5kZWJvdW5jZSgnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0KTtcbiAgfSxcblxuICBfc3R5bGVUcmFuc2l0aW9uRHVyYXRpb246IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gICAgdGhpcy4kLmNvbnRlbnRDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gKyAnbXMnO1xuICAgIHRoaXMuJC5zY3JpbS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiArICdtcyc7XG4gIH0sXG5cbiAgX3N0eWxlVHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBmdW5jdGlvbih0aW1pbmdGdW5jdGlvbikge1xuICAgIHRoaXMuJC5jb250ZW50Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgIHRoaXMuJC5zY3JpbS5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSB0aW1pbmdGdW5jdGlvbjtcbiAgfSxcblxuICBfdHJhbnNsYXRlRHJhd2VyOiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGRyYXdlcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuXG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgeCA9IE1hdGgubWF4KC1kcmF3ZXJXaWR0aCwgTWF0aC5taW4oeCwgMCkpO1xuICAgICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAxICsgeCAvIGRyYXdlcldpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oeCwgZHJhd2VyV2lkdGgpKTtcbiAgICAgIHRoaXMuJC5zY3JpbS5zdHlsZS5vcGFjaXR5ID0gMSAtIHggLyBkcmF3ZXJXaWR0aDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zbGF0ZTNkKHggKyAncHgnLCAnMCcsICcwJywgdGhpcy4kLmNvbnRlbnRDb250YWluZXIpO1xuICB9LFxuXG4gIF9yZXNldERyYXdlclRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kLnNjcmltLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICB0aGlzLnRyYW5zZm9ybSgnJywgdGhpcy4kLmNvbnRlbnRDb250YWluZXIpO1xuICB9LFxuXG4gIF9yZXNldERyYXdlclN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLl9kcmF3ZXJTdGF0ZTtcblxuICAgIC8vIElmIHRoZSBkcmF3ZXIgd2FzIGZsaW5naW5nLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBzdHlsZSBhdHRyaWJ1dGVzLlxuICAgIGlmIChvbGRTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLkZMSU5HSU5HKSB7XG4gICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25EdXJhdGlvbih0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB0aGlzLl9zdHlsZVRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbignJyk7XG4gICAgICB0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLl9zYXZlZFdpZHRoID0gbnVsbDtcblxuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLnBlcnNpc3RlbnQgP1xuICAgICAgICAgIHRoaXMuX0RSQVdFUl9TVEFURS5PUEVORURfUEVSU0lTVEVOVCA6XG4gICAgICAgICAgdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZHJhd2VyU3RhdGUgPSB0aGlzLl9EUkFXRVJfU1RBVEUuQ0xPU0VEO1xuICAgIH1cblxuICAgIGlmIChvbGRTdGF0ZSAhPT0gdGhpcy5fZHJhd2VyU3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLl9kcmF3ZXJTdGF0ZSA9PT0gdGhpcy5fRFJBV0VSX1NUQVRFLk9QRU5FRCkge1xuICAgICAgICB0aGlzLl9zZXRLZXlib2FyZEZvY3VzVHJhcCgpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fYm91bmRFc2NLZXlkb3duSGFuZGxlcik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9ib3VuZEVzY0tleWRvd25IYW5kbGVyKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCBvbiBpbml0aWFsIGxvYWQuXG4gICAgICBpZiAob2xkU3RhdGUgIT09IHRoaXMuX0RSQVdFUl9TVEFURS5JTklUKSB7XG4gICAgICAgIHRoaXMuZmlyZSgnYXBwLWRyYXdlci10cmFuc2l0aW9uZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgbGF5b3V0LlxuICAgKlxuICAgKiBAbWV0aG9kIHJlc2V0TGF5b3V0XG4gICAqL1xuICByZXNldExheW91dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maXJlKCdhcHAtcmVzZXQtbGF5b3V0Jyk7XG4gIH0sXG5cbiAgX3NldEtleWJvYXJkRm9jdXNUcmFwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ub0ZvY3VzVHJhcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IFVubGVzcyB3ZSB1c2UgL2RlZXAvICh3aGljaCB3ZSBzaG91bGRuJ3Qgc2luY2UgaXQncyBkZXByZWNhdGVkKSxcbiAgICAvLyB0aGlzIHdpbGwgbm90IHNlbGVjdCBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHNoYWRvdyByb290cy5cbiAgICB2YXIgZm9jdXNhYmxlRWxlbWVudHNTZWxlY3RvciA9IFtcbiAgICAgICdhW2hyZWZdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgJ2FyZWFbaHJlZl06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSk6bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAnaWZyYW1lOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLFxuICAgICAgJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsXG4gICAgICAnW2NvbnRlbnRFZGl0YWJsZT10cnVlXTpub3QoW3RhYmluZGV4PVwiLTFcIl0pJ1xuICAgIF0uam9pbignLCcpO1xuICAgIHZhciBmb2N1c2FibGVFbGVtZW50cyA9XG4gICAgICAgIGRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZUVsZW1lbnRzU2VsZWN0b3IpO1xuXG4gICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcCA9IGZvY3VzYWJsZUVsZW1lbnRzWzBdO1xuICAgICAgdGhpcy5fbGFzdFRhYlN0b3AgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgc2F2ZWQgdGFiIHN0b3BzIHdoZW4gdGhlcmUgYXJlIG5vIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGVcbiAgICAgIC8vIGRyYXdlci5cbiAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcCA9IG51bGw7XG4gICAgICB0aGlzLl9sYXN0VGFiU3RvcCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gRm9jdXMgb24gYXBwLWRyYXdlciBpZiBpdCBoYXMgbm9uLXplcm8gdGFiaW5kZXguIE90aGVyd2lzZSwgZm9jdXMgdGhlXG4gICAgLy8gZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgaW4gdGhlIGRyYXdlciwgaWYgaXQgZXhpc3RzLiBVc2UgdGhlIHRhYmluZGV4XG4gICAgLy8gYXR0cmlidXRlIHNpbmNlIHRoZSB0aGlzLnRhYkluZGV4IHByb3BlcnR5IGluIElFL0VkZ2UgcmV0dXJucyAwIChpbnN0ZWFkXG4gICAgLy8gb2YgLTEpIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0LlxuICAgIHZhciB0YWJpbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIGlmICh0YWJpbmRleCAmJiBwYXJzZUludCh0YWJpbmRleCwgMTApID4gLTEpIHtcbiAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2ZpcnN0VGFiU3RvcCkge1xuICAgICAgdGhpcy5fZmlyc3RUYWJTdG9wLmZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIF90YWJLZXlkb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5ub0ZvY3VzVHJhcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBUQUJfS0VZQ09ERSA9IDk7XG4gICAgaWYgKHRoaXMuX2RyYXdlclN0YXRlID09PSB0aGlzLl9EUkFXRVJfU1RBVEUuT1BFTkVEICYmXG4gICAgICAgIGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVlDT0RFKSB7XG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0VGFiU3RvcCAmJlxuICAgICAgICAgICAgZG9tKGV2ZW50KS5sb2NhbFRhcmdldCA9PT0gdGhpcy5fZmlyc3RUYWJTdG9wKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9sYXN0VGFiU3RvcC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFRhYlN0b3AgJiYgZG9tKGV2ZW50KS5sb2NhbFRhcmdldCA9PT0gdGhpcy5fbGFzdFRhYlN0b3ApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2ZpcnN0VGFiU3RvcC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9vcGVuZWRQZXJzaXN0ZW50Q2hhbmdlZDogZnVuY3Rpb24ob3BlbmVkLCBwZXJzaXN0ZW50KSB7XG4gICAgdGhpcy50b2dnbGVDbGFzcygndmlzaWJsZScsIG9wZW5lZCAmJiAhcGVyc2lzdGVudCwgdGhpcy4kLnNjcmltKTtcblxuICAgIC8vIFVzZSBhIGRlYm91bmNlIHRpbWVyIGluc3RlYWQgb2YgdHJhbnNpdGlvbmVuZCBzaW5jZSB0cmFuc2l0aW9uZW5kIHdvbid0XG4gICAgLy8gZmlyZSB3aGVuIGFwcC1kcmF3ZXIgaXMgZGlzcGxheTogbm9uZS5cbiAgICB0aGlzLmRlYm91bmNlKFxuICAgICAgICAnX3Jlc2V0RHJhd2VyU3RhdGUnLCB0aGlzLl9yZXNldERyYXdlclN0YXRlLCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gIH0sXG5cbiAgX01JTl9GTElOR19USFJFU0hPTEQ6IDAuMixcbiAgX01JTl9UUkFOU0lUSU9OX1ZFTE9DSVRZOiAxLjIsXG4gIF9GTElOR19USU1JTkdfRlVOQ1RJT046ICdjdWJpYy1iZXppZXIoMC42NjcsIDEsIDAuNjY3LCAxKScsXG4gIF9GTElOR19JTklUSUFMX1NMT1BFOiAxLjUsXG5cbiAgX0RSQVdFUl9TVEFURToge1xuICAgIElOSVQ6IDAsXG4gICAgT1BFTkVEOiAxLFxuICAgIE9QRU5FRF9QRVJTSVNURU5UOiAyLFxuICAgIENMT1NFRDogMyxcbiAgICBUUkFDS0lORzogNCxcbiAgICBGTElOR0lORzogNVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGxheW91dCBvZiBhcHAtZHJhd2VyIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAZXZlbnQgYXBwLXJlc2V0LWxheW91dFxuICAgKi9cblxuICAvKipcbiAgICogRmlyZWQgd2hlbiBhcHAtZHJhd2VyIGhhcyBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nLlxuICAgKlxuICAgKiBAZXZlbnQgYXBwLWRyYXdlci10cmFuc2l0aW9uZWRcbiAgICovXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@polymer/app-layout/app-drawer/app-drawer.js\n");

/***/ })

}]);