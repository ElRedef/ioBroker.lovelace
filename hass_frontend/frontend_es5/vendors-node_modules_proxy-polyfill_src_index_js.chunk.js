/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_proxy-polyfill_src_index_js"],{

/***/ "./node_modules/proxy-polyfill/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/proxy-polyfill/src/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("/*\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n\n(function (scope) {\n  if (scope['Proxy']) {\n    return;\n  }\n\n  scope.Proxy = __webpack_require__(/*! ./proxy.js */ \"./node_modules/proxy-polyfill/src/proxy.js\")();\n  scope.Proxy['revocable'] = scope.Proxy.revocable;\n})('undefined' !== typeof process && '[object process]' === {}.toString.call(process) || 'undefined' !== typeof navigator && navigator.product === 'ReactNative' ? global : self);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJveHktcG9seWZpbGwvc3JjL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3Byb3h5LXBvbHlmaWxsL3NyYy9pbmRleC5qcz8yODQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90XG4gKiB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZlxuICogdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUXG4gKiBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyXG4gKiB0aGUgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICBpZiAoc2NvcGVbJ1Byb3h5J10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2NvcGUuUHJveHkgPSByZXF1aXJlKCcuL3Byb3h5LmpzJykoKTtcbiAgc2NvcGUuUHJveHlbJ3Jldm9jYWJsZSddID0gc2NvcGUuUHJveHkucmV2b2NhYmxlO1xufSkoXG4gICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIHByb2Nlc3MgJiZcbiAgICAnW29iamVjdCBwcm9jZXNzXScgPT09IHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykpIHx8XG4gICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJylcbiAgICA/IGdsb2JhbFxuICAgIDogc2VsZlxuKTtcblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/proxy-polyfill/src/index.js\n");

/***/ }),

/***/ "./node_modules/proxy-polyfill/src/proxy.js":
/*!**************************************************!*\
  !*** ./node_modules/proxy-polyfill/src/proxy.js ***!
  \**************************************************/
/***/ (function(module) {

eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\nmodule.exports = function proxyPolyfill() {\n  var lastRevokeFn = null;\n\n  var _ProxyPolyfill;\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n\n\n  function isObject(o) {\n    return o ? _typeof(o) === 'object' || typeof o === 'function' : false;\n  }\n\n  function validateProto(proto) {\n    if (proto !== null && !isObject(proto)) {\n      throw new TypeError('Object prototype may only be an Object or null: ' + proto);\n    }\n  }\n\n  var $Object = Object; // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.\n\n  var canCreateNullProtoObjects = Boolean($Object.create) || !({\n    __proto__: null\n  } instanceof $Object);\n  var objectCreate = $Object.create || (canCreateNullProtoObjects ? function create(proto) {\n    validateProto(proto);\n    return {\n      __proto__: proto\n    };\n  } : function create(proto) {\n    validateProto(proto);\n\n    if (proto === null) {\n      throw new SyntaxError('Native Object.create is required to create objects with null prototype');\n    } // nb. cast to convince Closure compiler that this is a constructor\n\n\n    var T = function T() {};\n\n    T.prototype = proto;\n    return new T();\n  });\n\n  var noop = function noop() {\n    return null;\n  };\n\n  var getProto = $Object.getPrototypeOf || ([].__proto__ === Array.prototype ? function getPrototypeOf(O) {\n    // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,\n    // as it's inherited from `Object.prototype`\n    var proto = O.__proto__;\n    return isObject(proto) ? proto : null;\n  } : noop);\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n\n  _ProxyPolyfill = function ProxyPolyfill(target, handler) {\n    var newTarget = this && this instanceof _ProxyPolyfill ? this.constructor : undefined;\n\n    if (newTarget === undefined) {\n      throw new TypeError(\"Constructor Proxy requires 'new'\");\n    }\n\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    } // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n\n\n    var throwRevoked = function throwRevoked() {};\n\n    lastRevokeFn = function lastRevokeFn() {\n      /** @suppress {checkTypes} */\n      target = null; // clear ref\n\n      throwRevoked = function throwRevoked(trap) {\n        throw new TypeError(\"Cannot perform '\".concat(trap, \"' on a proxy that has been revoked\"));\n      };\n    };\n\n    setTimeout(function () {\n      lastRevokeFn = null;\n    }, 0); // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n\n    var unsafeHandler = handler;\n    handler = {\n      'get': null,\n      'set': null,\n      'apply': null,\n      'construct': null\n    };\n\n    for (var k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(\"Proxy polyfill does not support trap '\".concat(k, \"'\"));\n      }\n\n      handler[k] = unsafeHandler[k];\n    }\n\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    } // Define proxy as an object that extends target.[[Prototype]],\n    // or a Function (if either it's callable, or apply is set).\n\n\n    var proto = getProto(target); // can return null in old browsers\n\n    var proxy;\n    var isMethod = false;\n    var isArray = false;\n\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        var usingNew = this && this.constructor === proxy;\n        var args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply'); // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        } // since the target was a function, fallback to calling it directly.\n\n\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target); // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n\n          var f = target.bind.apply(target, args);\n          return new f();\n        }\n\n        return target.apply(this, args);\n      };\n\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } else {\n      proxy = canCreateNullProtoObjects || proto !== null ? objectCreate(proto) : {};\n    } // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n\n\n    var getter = handler.get ? function (prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function (prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    var setter = handler.set ? function (prop, value) {\n      throwRevoked('set');\n      var status = handler.set(this, prop, value, proxy); // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n      // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n      // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function (prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    }; // Clone direct properties (i.e., not part of a prototype).\n\n    var propertyNames = $Object.getOwnPropertyNames(target);\n    var propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n\n      var real = $Object.getOwnPropertyDescriptor(target, prop);\n      var desc = {\n        enumerable: Boolean(real.enumerable),\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop)\n      };\n      $Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    }); // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n\n    var prototypeOk = true;\n\n    if (isMethod || isArray) {\n      // Arrays and methods are special: above, we instantiate boring versions of these then swap\n      // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old\n      // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.\n      var setProto = $Object.setPrototypeOf || ([].__proto__ === Array.prototype ? function setPrototypeOf(O, proto) {\n        validateProto(proto);\n        O.__proto__ = proto;\n        return O;\n      } : noop);\n\n      if (!(proto && setProto(proxy, proto))) {\n        prototypeOk = false;\n      }\n    }\n\n    if (handler.get || !prototypeOk) {\n      for (var _k in target) {\n        if (propertyMap[_k]) {\n          continue;\n        }\n\n        $Object.defineProperty(proxy, _k, {\n          get: getter.bind(target, _k)\n        });\n      }\n    } // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n\n\n    $Object.seal(target);\n    $Object.seal(proxy);\n    return proxy; // nb. if isMethod is true, proxy != this\n  };\n\n  _ProxyPolyfill.revocable = function (target, handler) {\n    var p = new _ProxyPolyfill(target, handler);\n    return {\n      'proxy': p,\n      'revoke': lastRevokeFn\n    };\n  };\n\n  return _ProxyPolyfill;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wcm94eS1wb2x5ZmlsbC9zcmMvcHJveHkuanM/Nzk2ZSJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicHJveHlQb2x5ZmlsbCIsImxhc3RSZXZva2VGbiIsIlByb3h5UG9seWZpbGwiLCJpc09iamVjdCIsIm8iLCJ2YWxpZGF0ZVByb3RvIiwicHJvdG8iLCJUeXBlRXJyb3IiLCIkT2JqZWN0IiwiT2JqZWN0IiwiY2FuQ3JlYXRlTnVsbFByb3RvT2JqZWN0cyIsIkJvb2xlYW4iLCJjcmVhdGUiLCJfX3Byb3RvX18iLCJvYmplY3RDcmVhdGUiLCJTeW50YXhFcnJvciIsIlQiLCJwcm90b3R5cGUiLCJub29wIiwiZ2V0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIkFycmF5IiwiTyIsInRhcmdldCIsImhhbmRsZXIiLCJuZXdUYXJnZXQiLCJjb25zdHJ1Y3RvciIsInVuZGVmaW5lZCIsInRocm93UmV2b2tlZCIsInRyYXAiLCJzZXRUaW1lb3V0IiwidW5zYWZlSGFuZGxlciIsImsiLCJhcHBseSIsImJpbmQiLCJwcm94eSIsImlzTWV0aG9kIiwiaXNBcnJheSIsInVzaW5nTmV3IiwiYXJncyIsInNsaWNlIiwiY2FsbCIsImFyZ3VtZW50cyIsInVuc2hpZnQiLCJmIiwiZ2V0dGVyIiwiZ2V0IiwicHJvcCIsInNldHRlciIsInNldCIsInZhbHVlIiwic3RhdHVzIiwicHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU1hcCIsImZvckVhY2giLCJyZWFsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVzYyIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZU9rIiwic2V0UHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsInNlYWwiLCJyZXZvY2FibGUiLCJwIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFD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LEdBQWNQLEtBQWQ7QUFDQSxlQUFPZ0IsQ0FBUDtBQUNELE9BTEosR0FNR0osSUFQSixDQURGOztBQVNBLFVBQUksRUFBRVosS0FBSyxJQUFJd0QsUUFBUSxDQUFDM0IsS0FBRCxFQUFRN0IsS0FBUixDQUFuQixDQUFKLEVBQXdDO0FBQ3RDdUQsUUFBQUEsV0FBVyxHQUFHLEtBQWQ7QUFDRDtBQUNGOztBQUNELFFBQUlyQyxPQUFPLENBQUNzQixHQUFSLElBQWUsQ0FBQ2UsV0FBcEIsRUFBaUM7QUFDL0IsV0FBSyxJQUFJN0IsRUFBVCxJQUFjVCxNQUFkLEVBQXNCO0FBQ3BCLFlBQUkrQixXQUFXLENBQUN0QixFQUFELENBQWYsRUFBb0I7QUFDbEI7QUFDRDs7QUFDRHhCLFFBQUFBLE9BQU8sQ0FBQ29ELGNBQVIsQ0FBdUJ6QixLQUF2QixFQUE4QkgsRUFBOUIsRUFBaUM7QUFBRWMsVUFBQUEsR0FBRyxFQUFFRCxNQUFNLENBQUNYLElBQVAsQ0FBWVgsTUFBWixFQUFvQlMsRUFBcEI7QUFBUCxTQUFqQztBQUNEO0FBQ0YsS0FqSnVDLENBbUp4Qzs7O0FBQ0F4QixJQUFBQSxPQUFPLENBQUN3RCxJQUFSLENBQWF6QyxNQUFiO0FBQ0FmLElBQUFBLE9BQU8sQ0FBQ3dELElBQVIsQ0FBYTdCLEtBQWI7QUFFQSxXQUFPQSxLQUFQLENBdkp3QyxDQXVKekI7QUFDaEIsR0F4SkQ7O0FBMEpBakMsRUFBQUEsY0FBYSxDQUFDK0QsU0FBZCxHQUEwQixVQUFTMUMsTUFBVCxFQUFpQkMsT0FBakIsRUFBMEI7QUFDbEQsUUFBTTBDLENBQUMsR0FBRyxJQUFJaEUsY0FBSixDQUFrQnFCLE1BQWxCLEVBQTBCQyxPQUExQixDQUFWO0FBQ0EsV0FBTztBQUFFLGVBQVMwQyxDQUFYO0FBQWMsZ0JBQVVqRTtBQUF4QixLQUFQO0FBQ0QsR0FIRDs7QUFLQSxTQUFPQyxjQUFQO0FBQ0QsQ0EzTkQiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdFxuICogdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2ZcbiAqIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVFxuICogV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlclxuICogdGhlIExpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwcm94eVBvbHlmaWxsKCkge1xuICBsZXQgbGFzdFJldm9rZUZuID0gbnVsbDtcbiAgbGV0IFByb3h5UG9seWZpbGw7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoaXMgaXMgcHJvYmFibHkgYSAobm9uLW51bGwpIE9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICAgIHJldHVybiBvID8gKHR5cGVvZiBvID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJykgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUHJvdG8ocHJvdG8pIHtcbiAgICBpZiAocHJvdG8gIT09IG51bGwgJiYgIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0IHByb3RvdHlwZSBtYXkgb25seSBiZSBhbiBPYmplY3Qgb3IgbnVsbDogJyArIHByb3RvKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCAkT2JqZWN0ID0gT2JqZWN0O1xuXG4gIC8vIENsb3N1cmUgYXNzdW1lcyB0aGF0IGB7X19wcm90b19fOiBudWxsfSBpbnN0YW5jZW9mIE9iamVjdGAgaXMgYWx3YXlzIHRydWUsIGhlbmNlIHdoeSB3ZSBjaGVjayBhZ2FpbnN0IGEgZGlmZmVyZW50IG5hbWUuXG4gIGNvbnN0IGNhbkNyZWF0ZU51bGxQcm90b09iamVjdHMgPSBCb29sZWFuKCRPYmplY3QuY3JlYXRlKSB8fCAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbiAgY29uc3Qgb2JqZWN0Q3JlYXRlID1cbiAgICAkT2JqZWN0LmNyZWF0ZSB8fFxuICAgIChjYW5DcmVhdGVOdWxsUHJvdG9PYmplY3RzXG4gICAgICA/IGZ1bmN0aW9uIGNyZWF0ZShwcm90bykge1xuICAgICAgICAgIHZhbGlkYXRlUHJvdG8ocHJvdG8pO1xuICAgICAgICAgIHJldHVybiB7IF9fcHJvdG9fXzogcHJvdG8gfTtcbiAgICAgICAgfVxuICAgICAgOiBmdW5jdGlvbiBjcmVhdGUocHJvdG8pIHtcbiAgICAgICAgICB2YWxpZGF0ZVByb3RvKHByb3RvKTtcbiAgICAgICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignTmF0aXZlIE9iamVjdC5jcmVhdGUgaXMgcmVxdWlyZWQgdG8gY3JlYXRlIG9iamVjdHMgd2l0aCBudWxsIHByb3RvdHlwZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5iLiBjYXN0IHRvIGNvbnZpbmNlIENsb3N1cmUgY29tcGlsZXIgdGhhdCB0aGlzIGlzIGEgY29uc3RydWN0b3JcbiAgICAgICAgICB2YXIgVCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyAoZnVuY3Rpb24gVCgpIHt9KTtcbiAgICAgICAgICBULnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgIHJldHVybiBuZXcgVCgpO1xuICAgICAgICB9KTtcblxuICBjb25zdCBub29wID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9O1xuXG4gIGNvbnN0IGdldFByb3RvID1cbiAgICAkT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8XG4gICAgKFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlXG4gICAgICA/IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKE8pIHtcbiAgICAgICAgICAvLyBJZiBPLltbUHJvdG90eXBlXV0gPT09IG51bGwsIHRoZW4gdGhlIF9fcHJvdG9fXyBhY2Nlc3NvciB3b24ndCBleGlzdCxcbiAgICAgICAgICAvLyBhcyBpdCdzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYFxuICAgICAgICAgIGNvbnN0IHByb3RvID0gTy5fX3Byb3RvX187XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgOiBub29wKTtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7e2FwcGx5LCBjb25zdHJ1Y3QsIGdldCwgc2V0fX0gaGFuZGxlclxuICAgKi9cbiAgUHJveHlQb2x5ZmlsbCA9IGZ1bmN0aW9uKHRhcmdldCwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5ld1RhcmdldCA9IHRoaXMgJiYgdGhpcyBpbnN0YW5jZW9mIFByb3h5UG9seWZpbGwgPyB0aGlzLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkO1xuICAgIGlmIChuZXdUYXJnZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnN0cnVjdG9yIFByb3h5IHJlcXVpcmVzICduZXcnXCIpO1xuICAgIH1cblxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSB8fCAhaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgcHJveHkgd2l0aCBhIG5vbi1vYmplY3QgYXMgdGFyZ2V0IG9yIGhhbmRsZXInKTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgcmV2b2tlIGZ1bmN0aW9uLCBhbmQgc2V0IGxhc3RSZXZva2VGbiBzbyB0aGF0IFByb3h5LnJldm9jYWJsZSBjYW4gc3RlYWwgaXQuXG4gICAgLy8gVGhlIGNhbGxlciBtaWdodCBnZXQgdGhlIHdyb25nIHJldm9rZSBmdW5jdGlvbiBpZiBhIHVzZXIgcmVwbGFjZXMgb3Igd3JhcHMgc2NvcGUuUHJveHlcbiAgICAvLyB0byBjYWxsIGl0c2VsZiwgYnV0IHRoYXQgc2VlbXMgdW5saWtlbHkgZXNwZWNpYWxseSB3aGVuIHVzaW5nIHRoZSBwb2x5ZmlsbC5cbiAgICBsZXQgdGhyb3dSZXZva2VkID0gZnVuY3Rpb24oKSB7fTtcbiAgICBsYXN0UmV2b2tlRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8qKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9ICovXG4gICAgICB0YXJnZXQgPSBudWxsOyAgLy8gY2xlYXIgcmVmXG4gICAgICB0aHJvd1Jldm9rZWQgPSBmdW5jdGlvbih0cmFwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBwZXJmb3JtICcke3RyYXB9JyBvbiBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZGApO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBsYXN0UmV2b2tlRm4gPSBudWxsO1xuICAgIH0sIDApO1xuXG4gICAgLy8gRmFpbCBvbiB1bnN1cHBvcnRlZCB0cmFwczogQ2hyb21lIGRvZXNuJ3QgZG8gdGhpcywgYnV0IGVuc3VyZSB0aGF0IHVzZXJzIG9mIHRoZSBwb2x5ZmlsbFxuICAgIC8vIGFyZSBhIGJpdCBtb3JlIGNhcmVmdWwuIENvcHkgdGhlIGludGVybmFsIHBhcnRzIG9mIGhhbmRsZXIgdG8gcHJldmVudCB1c2VyIGNoYW5nZXMuXG4gICAgY29uc3QgdW5zYWZlSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IHsgJ2dldCc6IG51bGwsICdzZXQnOiBudWxsLCAnYXBwbHknOiBudWxsLCAnY29uc3RydWN0JzogbnVsbCB9O1xuICAgIGZvciAobGV0IGsgaW4gdW5zYWZlSGFuZGxlcikge1xuICAgICAgaWYgKCEoayBpbiBoYW5kbGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQcm94eSBwb2x5ZmlsbCBkb2VzIG5vdCBzdXBwb3J0IHRyYXAgJyR7a30nYCk7XG4gICAgICB9XG4gICAgICBoYW5kbGVyW2tdID0gdW5zYWZlSGFuZGxlcltrXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1bnNhZmVIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyBoYW5kbGVyIHRvIGJlIGEgZnVuY3Rpb24gKHdoaWNoIGhhcyBhbiAnYXBwbHknIG1ldGhvZCkuIFRoaXMgbWF0Y2hlcyB3aGF0IGlzXG4gICAgICAvLyBwcm9iYWJseSBhIGJ1ZyBpbiBuYXRpdmUgdmVyc2lvbnMuIEl0IHRyZWF0cyB0aGUgYXBwbHkgY2FsbCBhcyBhIHRyYXAgdG8gYmUgY29uZmlndXJlZC5cbiAgICAgIGhhbmRsZXIuYXBwbHkgPSB1bnNhZmVIYW5kbGVyLmFwcGx5LmJpbmQodW5zYWZlSGFuZGxlcik7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHByb3h5IGFzIGFuIG9iamVjdCB0aGF0IGV4dGVuZHMgdGFyZ2V0LltbUHJvdG90eXBlXV0sXG4gICAgLy8gb3IgYSBGdW5jdGlvbiAoaWYgZWl0aGVyIGl0J3MgY2FsbGFibGUsIG9yIGFwcGx5IGlzIHNldCkuXG4gICAgY29uc3QgcHJvdG8gPSBnZXRQcm90byh0YXJnZXQpOyAgLy8gY2FuIHJldHVybiBudWxsIGluIG9sZCBicm93c2Vyc1xuICAgIGxldCBwcm94eTtcbiAgICBsZXQgaXNNZXRob2QgPSBmYWxzZTtcbiAgICBsZXQgaXNBcnJheSA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm94eSA9IGZ1bmN0aW9uIFByb3h5UG9seWZpbGwoKSB7XG4gICAgICAgIGNvbnN0IHVzaW5nTmV3ID0gKHRoaXMgJiYgdGhpcy5jb25zdHJ1Y3RvciA9PT0gcHJveHkpO1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdGhyb3dSZXZva2VkKHVzaW5nTmV3ID8gJ2NvbnN0cnVjdCcgOiAnYXBwbHknKTtcblxuICAgICAgICAvLyBUT0RPKHNhbXRob3IpOiBDbG9zdXJlIGNvbXBpbGVyIGRvZXNuJ3Qga25vdyBhYm91dCAnY29uc3RydWN0JywgYXR0ZW1wdHMgdG8gcmVuYW1lIGl0LlxuICAgICAgICBpZiAodXNpbmdOZXcgJiYgaGFuZGxlclsnY29uc3RydWN0J10pIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlclsnY29uc3RydWN0J10uY2FsbCh0aGlzLCB0YXJnZXQsIGFyZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKCF1c2luZ05ldyAmJiBoYW5kbGVyLmFwcGx5KSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXJbJ2FwcGx5J10odGFyZ2V0LCB0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbmNlIHRoZSB0YXJnZXQgd2FzIGEgZnVuY3Rpb24sIGZhbGxiYWNrIHRvIGNhbGxpbmcgaXQgZGlyZWN0bHkuXG4gICAgICAgIGlmICh1c2luZ05ldykge1xuICAgICAgICAgIC8vIGluc3BpcmVkIGJ5IGFuc3dlcnMgdG8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE2MDY3OTdcbiAgICAgICAgICBhcmdzLnVuc2hpZnQodGFyZ2V0KTsgIC8vIHBhc3MgY2xhc3MgYXMgZmlyc3QgYXJnIHRvIGNvbnN0cnVjdG9yLCBhbHRob3VnaCBpcnJlbGV2YW50XG4gICAgICAgICAgLy8gbmIuIGNhc3QgdG8gY29udmluY2UgQ2xvc3VyZSBjb21waWxlciB0aGF0IHRoaXMgaXMgYSBjb25zdHJ1Y3RvclxuICAgICAgICAgIGNvbnN0IGYgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8gKHRhcmdldC5iaW5kLmFwcGx5KHRhcmdldCwgYXJncykpO1xuICAgICAgICAgIHJldHVybiBuZXcgZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgICAgaXNNZXRob2QgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHByb3h5ID0gW107XG4gICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJveHkgPSAoY2FuQ3JlYXRlTnVsbFByb3RvT2JqZWN0cyB8fCBwcm90byAhPT0gbnVsbCkgPyBvYmplY3RDcmVhdGUocHJvdG8pIDoge307XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGRlZmF1bHQgZ2V0dGVycy9zZXR0ZXJzLiBDcmVhdGUgZGlmZmVyZW50IGNvZGUgcGF0aHMgYXMgaGFuZGxlci5nZXQvaGFuZGxlci5zZXQgY2FuJ3RcbiAgICAvLyBjaGFuZ2UgYWZ0ZXIgY3JlYXRpb24uXG4gICAgY29uc3QgZ2V0dGVyID0gaGFuZGxlci5nZXQgPyBmdW5jdGlvbihwcm9wKSB7XG4gICAgICB0aHJvd1Jldm9rZWQoJ2dldCcpO1xuICAgICAgcmV0dXJuIGhhbmRsZXIuZ2V0KHRoaXMsIHByb3AsIHByb3h5KTtcbiAgICB9IDogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgdGhyb3dSZXZva2VkKCdnZXQnKTtcbiAgICAgIHJldHVybiB0aGlzW3Byb3BdO1xuICAgIH07XG4gICAgY29uc3Qgc2V0dGVyID0gaGFuZGxlci5zZXQgPyBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgdGhyb3dSZXZva2VkKCdzZXQnKTtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGhhbmRsZXIuc2V0KHRoaXMsIHByb3AsIHZhbHVlLCBwcm94eSk7XG4gICAgICAvLyBUT0RPKHNhbXRob3IpOiBJZiB0aGUgY2FsbGluZyBjb2RlIGlzIGluIHN0cmljdCBtb2RlLCB0aHJvdyBUeXBlRXJyb3IuXG4gICAgICAvLyBpZiAoIXN0YXR1cykge1xuICAgICAgICAvLyBJdCdzIChzb21ldGltZXMpIHBvc3NpYmxlIHRvIHdvcmsgdGhpcyBvdXQsIGlmIHRoaXMgY29kZSBpc24ndCBzdHJpY3QtIHRyeSB0byBsb2FkIHRoZVxuICAgICAgICAvLyBjYWxsZWUsIGFuZCBpZiBpdCdzIGF2YWlsYWJsZSwgdGhhdCBjb2RlIGlzIG5vbi1zdHJpY3QuIEhvd2V2ZXIsIHRoaXMgaXNuJ3QgZXhoYXVzdGl2ZS5cbiAgICAgIC8vIH1cbiAgICB9IDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgIHRocm93UmV2b2tlZCgnc2V0Jyk7XG4gICAgICB0aGlzW3Byb3BdID0gdmFsdWU7XG4gICAgfTtcblxuICAgIC8vIENsb25lIGRpcmVjdCBwcm9wZXJ0aWVzIChpLmUuLCBub3QgcGFydCBvZiBhIHByb3RvdHlwZSkuXG4gICAgY29uc3QgcHJvcGVydHlOYW1lcyA9ICRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICAgIGNvbnN0IHByb3BlcnR5TWFwID0ge307XG4gICAgcHJvcGVydHlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgIGlmICgoaXNNZXRob2QgfHwgaXNBcnJheSkgJiYgcHJvcCBpbiBwcm94eSkge1xuICAgICAgICByZXR1cm47ICAvLyBpZ25vcmUgcHJvcGVydGllcyBhbHJlYWR5IGhlcmUsIGUuZy4gJ2JpbmQnLCAncHJvdG90eXBlJyBldGNcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWwgPSAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApO1xuICAgICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgZW51bWVyYWJsZTogQm9vbGVhbihyZWFsLmVudW1lcmFibGUpLFxuICAgICAgICBnZXQ6IGdldHRlci5iaW5kKHRhcmdldCwgcHJvcCksXG4gICAgICAgIHNldDogc2V0dGVyLmJpbmQodGFyZ2V0LCBwcm9wKSxcbiAgICAgIH07XG4gICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBwcm9wLCBkZXNjKTtcbiAgICAgIHByb3BlcnR5TWFwW3Byb3BdID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFNldCB0aGUgcHJvdG90eXBlLCBvciBjbG9uZSBhbGwgcHJvdG90eXBlIG1ldGhvZHMgKGFsd2F5cyByZXF1aXJlZCBpZiBhIGdldHRlciBpcyBwcm92aWRlZCkuXG4gICAgLy8gVE9ETyhzYW10aG9yKTogV2UgZG9uJ3QgYWxsb3cgcHJvdG90eXBlIG1ldGhvZHMgdG8gYmUgc2V0LiBJdCdzIChldmVuIG1vcmUpIGF3a3dhcmQuXG4gICAgLy8gQW4gYWx0ZXJuYXRpdmUgaGVyZSB3b3VsZCBiZSB0byBfanVzdF8gY2xvbmUgbWV0aG9kcyB0byBrZWVwIGJlaGF2aW9yIGNvbnNpc3RlbnQuXG4gICAgbGV0IHByb3RvdHlwZU9rID0gdHJ1ZTtcbiAgICBpZiAoaXNNZXRob2QgfHwgaXNBcnJheSkge1xuICAgICAgLy8gQXJyYXlzIGFuZCBtZXRob2RzIGFyZSBzcGVjaWFsOiBhYm92ZSwgd2UgaW5zdGFudGlhdGUgYm9yaW5nIHZlcnNpb25zIG9mIHRoZXNlIHRoZW4gc3dhcFxuICAgICAgLy8gb3VyIHRoZWlyIHByb3RvdHlwZSBsYXRlci4gU28gd2Ugb25seSBuZWVkIHRvIHVzZSBzZXRQcm90b3R5cGVPZiBpbiB0aGVzZSBjYXNlcy4gU29tZSBvbGRcbiAgICAgIC8vIGVuZ2luZXMgc3VwcG9ydCBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBidXQgbm90IGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgLlxuICAgICAgY29uc3Qgc2V0UHJvdG8gPVxuICAgICAgICAkT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgIChbXS5fX3Byb3RvX18gPT09IEFycmF5LnByb3RvdHlwZVxuICAgICAgICAgID8gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVQcm90byhwcm90byk7XG4gICAgICAgICAgICAgIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgICAgICAgIHJldHVybiBPO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIDogbm9vcCk7XG4gICAgICBpZiAoIShwcm90byAmJiBzZXRQcm90byhwcm94eSwgcHJvdG8pKSkge1xuICAgICAgICBwcm90b3R5cGVPayA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFuZGxlci5nZXQgfHwgIXByb3RvdHlwZU9rKSB7XG4gICAgICBmb3IgKGxldCBrIGluIHRhcmdldCkge1xuICAgICAgICBpZiAocHJvcGVydHlNYXBba10pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAkT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrLCB7IGdldDogZ2V0dGVyLmJpbmQodGFyZ2V0LCBrKSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgUHJveHkgcG9seWZpbGwgY2Fubm90IGhhbmRsZSBhZGRpbmcgbmV3IHByb3BlcnRpZXMuIFNlYWwgdGhlIHRhcmdldCBhbmQgcHJveHkuXG4gICAgJE9iamVjdC5zZWFsKHRhcmdldCk7XG4gICAgJE9iamVjdC5zZWFsKHByb3h5KTtcblxuICAgIHJldHVybiBwcm94eTsgIC8vIG5iLiBpZiBpc01ldGhvZCBpcyB0cnVlLCBwcm94eSAhPSB0aGlzXG4gIH07XG5cbiAgUHJveHlQb2x5ZmlsbC5yZXZvY2FibGUgPSBmdW5jdGlvbih0YXJnZXQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBwID0gbmV3IFByb3h5UG9seWZpbGwodGFyZ2V0LCBoYW5kbGVyKTtcbiAgICByZXR1cm4geyAncHJveHknOiBwLCAncmV2b2tlJzogbGFzdFJldm9rZUZuIH07XG4gIH07XG5cbiAgcmV0dXJuIFByb3h5UG9seWZpbGw7XG59XG4iXSwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Byb3h5LXBvbHlmaWxsL3NyYy9wcm94eS5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/proxy-polyfill/src/proxy.js\n");

/***/ })

}]);