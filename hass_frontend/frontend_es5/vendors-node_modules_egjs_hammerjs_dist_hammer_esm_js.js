"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_egjs_hammerjs_dist_hammer_esm_js"],{

/***/ "./node_modules/@egjs/hammerjs/dist/hammer.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@egjs/hammerjs/dist/hammer.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttrRecognizer: function() { return /* binding */ AttrRecognizer; },\n/* harmony export */   DIRECTION_ALL: function() { return /* binding */ DIRECTION_ALL; },\n/* harmony export */   DIRECTION_DOWN: function() { return /* binding */ DIRECTION_DOWN; },\n/* harmony export */   DIRECTION_HORIZONTAL: function() { return /* binding */ DIRECTION_HORIZONTAL; },\n/* harmony export */   DIRECTION_LEFT: function() { return /* binding */ DIRECTION_LEFT; },\n/* harmony export */   DIRECTION_NONE: function() { return /* binding */ DIRECTION_NONE; },\n/* harmony export */   DIRECTION_RIGHT: function() { return /* binding */ DIRECTION_RIGHT; },\n/* harmony export */   DIRECTION_UP: function() { return /* binding */ DIRECTION_UP; },\n/* harmony export */   DIRECTION_VERTICAL: function() { return /* binding */ DIRECTION_VERTICAL; },\n/* harmony export */   INPUT_CANCEL: function() { return /* binding */ INPUT_CANCEL; },\n/* harmony export */   INPUT_END: function() { return /* binding */ INPUT_END; },\n/* harmony export */   INPUT_MOVE: function() { return /* binding */ INPUT_MOVE; },\n/* harmony export */   INPUT_START: function() { return /* binding */ INPUT_START; },\n/* harmony export */   Input: function() { return /* binding */ Input; },\n/* harmony export */   Manager: function() { return /* binding */ Manager; },\n/* harmony export */   MouseInput: function() { return /* binding */ MouseInput; },\n/* harmony export */   Pan: function() { return /* binding */ PanRecognizer; },\n/* harmony export */   Pinch: function() { return /* binding */ PinchRecognizer; },\n/* harmony export */   PointerEventInput: function() { return /* binding */ PointerEventInput; },\n/* harmony export */   Press: function() { return /* binding */ PressRecognizer; },\n/* harmony export */   Recognizer: function() { return /* binding */ Recognizer; },\n/* harmony export */   Rotate: function() { return /* binding */ RotateRecognizer; },\n/* harmony export */   STATE_BEGAN: function() { return /* binding */ STATE_BEGAN; },\n/* harmony export */   STATE_CANCELLED: function() { return /* binding */ STATE_CANCELLED; },\n/* harmony export */   STATE_CHANGED: function() { return /* binding */ STATE_CHANGED; },\n/* harmony export */   STATE_ENDED: function() { return /* binding */ STATE_ENDED; },\n/* harmony export */   STATE_FAILED: function() { return /* binding */ STATE_FAILED; },\n/* harmony export */   STATE_POSSIBLE: function() { return /* binding */ STATE_POSSIBLE; },\n/* harmony export */   STATE_RECOGNIZED: function() { return /* binding */ STATE_RECOGNIZED; },\n/* harmony export */   SingleTouchInput: function() { return /* binding */ SingleTouchInput; },\n/* harmony export */   Swipe: function() { return /* binding */ SwipeRecognizer; },\n/* harmony export */   Tap: function() { return /* binding */ TapRecognizer; },\n/* harmony export */   TouchAction: function() { return /* binding */ TouchAction; },\n/* harmony export */   TouchInput: function() { return /* binding */ TouchInput; },\n/* harmony export */   TouchMouseInput: function() { return /* binding */ TouchMouseInput; },\n/* harmony export */   addEventListeners: function() { return /* binding */ addEventListeners; },\n/* harmony export */   assign: function() { return /* binding */ assign$1; },\n/* harmony export */   bindFn: function() { return /* binding */ bindFn; },\n/* harmony export */   boolOrFn: function() { return /* binding */ boolOrFn; },\n/* harmony export */   defaults: function() { return /* binding */ defaults$1; },\n/* harmony export */   each: function() { return /* binding */ each; },\n/* harmony export */   extend: function() { return /* binding */ extend; },\n/* harmony export */   hasParent: function() { return /* binding */ hasParent; },\n/* harmony export */   inArray: function() { return /* binding */ inArray; },\n/* harmony export */   inherit: function() { return /* binding */ inherit; },\n/* harmony export */   merge: function() { return /* binding */ merge; },\n/* harmony export */   off: function() { return /* binding */ removeEventListeners; },\n/* harmony export */   on: function() { return /* binding */ addEventListeners; },\n/* harmony export */   prefixed: function() { return /* binding */ prefixed; },\n/* harmony export */   removeEventListeners: function() { return /* binding */ removeEventListeners; },\n/* harmony export */   splitStr: function() { return /* binding */ splitStr; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   uniqueArray: function() { return /* binding */ uniqueArray; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\nvar assign$1 = assign;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n  abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n  if (!obj) {\n    return;\n  }\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(val) === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction = /*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n  var _proto = TouchAction.prototype;\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n  var x = 0;\n  var y = 0;\n  var i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n  var firstInput = session.firstInput,\n    firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input = /*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n  var _proto = Input.prototype;\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\nvar PointerEventInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n  function PointerEventInput() {\n    var _this;\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n  var _proto = PointerEventInput.prototype;\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n  return results;\n}\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n  function TouchInput() {\n    var _this;\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n  var _proto = TouchInput.prototype;\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return TouchInput;\n}(Input);\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n  if (!changedTargetTouches.length) {\n    return;\n  }\n  return [\n  // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n  function MouseInput() {\n    var _this;\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n  var _proto = MouseInput.prototype;\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n    touch = _eventData$changedPoi[0];\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n  return false;\n}\nvar TouchMouseInput = /*#__PURE__*/\nfunction () {\n  var TouchMouseInput = /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n      _this = _Input.call(this, _manager, callback) || this;\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n        _this.callback(manager, inputEvent, inputData);\n      };\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n    return TouchMouseInput;\n  }(Input);\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer = /*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n  var _proto = Recognizer.prototype;\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n  _proto.reset = function reset() {};\n  return Recognizer;\n}();\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n  function TapRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n  var _proto = TapRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n  _proto.process = function process(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  };\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n  var _proto = AttrRecognizer.prototype;\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  };\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n  function PanRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n  var _proto = PanRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  };\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && (\n    // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n  var _proto = SwipeRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n    this.manager.emit(this.options.event, input);\n  };\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = RotateRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n  function PressRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n  var _proto = PressRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n  _proto.process = function process(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return PressRecognizer;\n}(Recognizer);\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n  if (!element.style) {\n    return;\n  }\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Manager = /*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n  var _proto = Manager.prototype;\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n    var i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && (\n      // 1\n      !curRecognizer || recognizer === curRecognizer ||\n      // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n    var recognizers = this.recognizers;\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n    var existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    data.type = event;\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n    var i = 0;\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n  return Manager;\n}();\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n  function SingleTouchInput() {\n    var _this;\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n  var _proto = SingleTouchInput.prototype;\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n    if (!this.started) {\n      return;\n    }\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return SingleTouchInput;\n}(Input);\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer = /*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\n//  style loader but by script tag, not by the loader.\n\nvar defaults$1 = Hammer.defaults;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hammer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvaGFtbWVyanMvZGlzdC9oYW1tZXIuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFoQkE7QUFEQTtBQW9CQTs7QUFHQTtBQy9CQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFBQTtBQUNBOztBQ05BOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7QUN2QkE7QUFFQTtBQUVBOztBQUVBO0FBRkE7QUFJQTs7QUNKQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBSUE7QUFKQTtBQU1BOztBQ2RBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1JBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FDaENBOzs7Ozs7O0FBT0E7QUFDQTtBQUVBOzs7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFKQTtBQU9BO0FBQ0E7Ozs7O0FDdkJBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7OztBQ2JBOzs7Ozs7O0FBT0E7QUFDQTs7O0FDQ0E7Ozs7Ozs7QUFNQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQWRBOztBQWtCQTtBQUNBO0FBbkJBOztBQXVCQTtBQUNBOztBQUdBOzs7QUN0QkE7Ozs7Ozs7OztBQVFBOztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7O0FBRUE7QUFDQTs7QUFHQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUZBO0FBS0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7QUFLQTs7OztBQUtBO0FBR0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7Ozs7QUM1SEE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQ2JBOzs7Ozs7O0FBTUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUZBOzs7QUN6QkE7Ozs7Ozs7QUFNQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7O0FDcEJBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7QUNmQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FDYkE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7O0FDaEJBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFGQTs7QUFNQTtBQUNBOzs7QUN2QkE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7O0FDUEE7Ozs7Ozs7OztBQVFBO0FBQ0E7OztBQ1JBOzs7Ozs7OztBQU9BO0FBQ0E7OztBQ05BOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFWQTs7QUFhQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQVBBOztBQVdBO0FBQ0E7QUFEQTtBQUdBOztBQUdBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7O0FBR0E7QUFDQTs7QUFFQTs7O0FDNUVBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVZBOzs7QUFlQTs7QUFHQTs7QUFHQTtBQUVBO0FBQ0E7OztBQ2xDQTs7Ozs7O0FBT0E7QUFDQTs7O0FDTkE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBREE7OztBQ1JBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQURBOzs7QUNWQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOzs7QUNIQTs7Ozs7Ozs7O0FBUUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7O0FBRkE7QUFNQTs7Ozs7Ozs7O0FBUUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeERBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBOztBQUNBOztBQUVBOztBQUVBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBR0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBSEE7QUFNQTtBQXBCQTs7QUF3QkE7O0FBeEJBOztBQTZCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BOztBQUVBOzs7O0FBdkRBOztBQzdDQTs7Ozs7O0FBTUE7QUFDQTs7O0FDTEE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTs7O0FBTUE7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BOzs7Ozs7OztBQVFBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7O0FBZEE7QUE4QkE7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFEQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTFCQTs7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFNQTtBQUNBOztBQUVBOztBQUdBOzs7QUFJQTtBQUFBO0FBRUE7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBVEE7O0FBYUE7OztBQUlBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7QUFwQ0E7O0FDWkE7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBSkE7QUFRQTs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBOztBQUlBOztBQUFBOzs7QUFDQTs7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUVBOztBQUpBOztBQVNBO0FBQ0E7QUFEQTs7O0FBTUE7QUEvQkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ0E7QUFDQTtBQUNBOzs7QUF6Q0E7QUFBQTs7O0FDbEVBOzs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTs7QUFFQTs7O0FDNUJBOzs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQ1BBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQ0xBOzs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBOztBQUVBOzs7QUNOQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFTQTtBQUNBOztBQUdBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFMQTs7QUFTQTtBQUNBOztBQUdBOztBQUVBOztBQUNBO0FBaEJBOztBQW9CQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUZBOztBQUtBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBUUE7OztBQUdBOztBQUdBO0FBQ0E7QUFDQTs7QUFSQTs7QUFhQTtBQUNBOztBQUdBOzs7QUFJQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBOzs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7O0FBUUE7Ozs7QUNoU0E7Ozs7Ozs7Ozs7OztBQVdBOzs7QUFDQTs7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOzs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTs7QUFHQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQVZBOzs7QUFlQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTs7QUFHQTs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7OztBQUlBOztBQUdBOztBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEvRkE7O0FDUkE7Ozs7Ozs7QUFNQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBOztBQUVBOztBQUVBOzs7QUE3Q0E7O0FDWkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7O0FBRUE7OztBQ1JBOzs7Ozs7OztBQU9BOzs7QUFDQTs7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUVBOzs7QUFoRUE7O0FDZkE7Ozs7Ozs7O0FBT0E7OztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQURBO0FBR0E7O0FBR0E7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7OztBQXpDQTs7QUNWQTs7Ozs7Ozs7QUFPQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7O0FBR0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBeEJBOztBQ1BBOzs7Ozs7OztBQU9BOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFHQTtBQUNBOzs7QUFmQTs7QUNFQTs7Ozs7Ozs7QUFPQTs7O0FBQ0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBR0E7QUFDQTs7QUFHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFJQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTs7QUFFQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7OztBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7Ozs7QUF0REE7QUNYQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFTQTs7Ozs7O0FBT0E7Ozs7Ozs7OztBQVVBOzs7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7OztBQU9BOzs7Ozs7O0FBUUE7Ozs7Ozs7OztBQVVBOzs7Ozs7O0FBUUE7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFTQTs7QUFwR0E7Ozs7Ozs7OztBQStHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUM3R0E7QUFDQTs7Ozs7Ozs7QUFTQTtBQUNBO0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBTkE7QUFTQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVdBOztBQUNBOztBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFKQTs7Ozs7Ozs7OztBQWNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUVBOztBQUhBOztBQVFBO0FBRUE7QUFDQTs7OztBQUtBOzs7QUFJQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBOzs7Ozs7O0FBUUE7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUhBO0FBS0E7QUFkQTs7O0FBbUJBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTtBQUZBOztBQU1BO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBSUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQUpBO0FBT0E7Ozs7Ozs7O0FBUUE7O0FBRUE7QUFDQTtBQUhBOztBQU9BO0FBRUE7OztBQUlBO0FBQ0E7QUFDQTtBQURBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBR0E7QUFDQTs7QUFHQTtBQUNBOztBQUdBOzs7QUFJQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7O0FBN0JBO0FBNkNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7OztBQ2hGQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBVkE7OztBQ1RBOzs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBVEE7O0FDUkE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFEQTs7QUNUQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FDakJBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBREE7OztBQ2tEQTs7Ozs7Ozs7QUFPQTs7QUFBQTs7Ozs7QUE2REE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFJQTs7QUFuRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQTREQTtBQUFBO0FBNURBOzs7QUNIQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9hc3NpZ24uanM/ZTc5OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvdXRpbHMtY29uc3RzLmpzP2M3MTUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3ByZWZpeGVkLmpzPzYzZDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2Jyb3dzZXIuanM/NTVmYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdG91Y2hhY3Rpb25qcy9nZXQtdG91Y2hhY3Rpb24tcHJvcHMuanM/MmM0OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHMuanM/YjMwMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9pbnB1dC1jb25zdHMuanM/MDQ5NCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvZWFjaC5qcz8yZjFlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9ib29sLW9yLWZuLmpzPzAzMDkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2luLXN0ci5qcz82OGE4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy90b3VjaGFjdGlvbmpzL2NsZWFuLXRvdWNoLWFjdGlvbnMuanM/MDIxMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1jb25zdHJ1Y3Rvci5qcz8yN2ExIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9oYXMtcGFyZW50LmpzP2EwMmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LWNlbnRlci5qcz9jMzQ5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL3NpbXBsZS1jbG9uZS1pbnB1dC1kYXRhLmpzP2MyYTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LWRpc3RhbmNlLmpzPzA2NmYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LWFuZ2xlLmpzPzcyMmQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvZ2V0LWRpcmVjdGlvbi5qcz8zMDQ2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2NvbXB1dGUtZGVsdGEteHkuanM/ZDhmYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtdmVsb2NpdHkuanM/N2YwZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtc2NhbGUuanM/MDUxMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtcm90YXRpb24uanM/M2EwNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9jb21wdXRlLWludGVydmFsLWlucHV0LWRhdGEuanM/MmEyZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9jb21wdXRlLWlucHV0LWRhdGEuanM/M2VjNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9pbnB1dC1oYW5kbGVyLmpzP2UyNTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3NwbGl0LXN0ci5qcz9mOTU1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9hZGQtZXZlbnQtbGlzdGVuZXJzLmpzPzMwOGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3JlbW92ZS1ldmVudC1saXN0ZW5lcnMuanM/Y2MyYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvZ2V0LXdpbmRvdy1mb3ItZWxlbWVudC5qcz82ZDdiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yLmpzPzRhMTkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2luLWFycmF5LmpzPzMzMzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0L3BvaW50ZXJldmVudC5qcz9hODQ0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy90by1hcnJheS5qcz85OGIzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy91bmlxdWUtYXJyYXkuanM/Yzc2MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXQvdG91Y2guanM/ZGUyNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXQvbW91c2UuanM/YmY2OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXQvdG91Y2htb3VzZS5qcz9kNGYzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2NyZWF0ZS1pbnB1dC1pbnN0YW5jZS5qcz82ODE1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9pbnZva2UtYXJyYXktYXJnLmpzP2ExZGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cy5qcz9hNjgyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy91bmlxdWUtaWQuanM/MzBiZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcmpzL2dldC1yZWNvZ25pemVyLWJ5LW5hbWUtaWYtbWFuYWdlci5qcz85MDhhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVyanMvc3RhdGUtc3RyLmpzPzBkZTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yLmpzP2NiYTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL3RhcC5qcz9kZGJkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy9hdHRyaWJ1dGUuanM/YzM5ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcmpzL2RpcmVjdGlvbi1zdHIuanM/Y2EyNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvcGFuLmpzP2FhMzIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL3N3aXBlLmpzP2MzNTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL3BpbmNoLmpzP2RjZjYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL3JvdGF0ZS5qcz83NDYwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy9wcmVzcy5qcz8zYzc4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9kZWZhdWx0cy5qcz82YzYxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9tYW5hZ2VyLmpzP2I5MmUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0L3NpbmdsZXRvdWNoLmpzPzE3MTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2RlcHJlY2F0ZS5qcz9iMTNlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9leHRlbmQuanM/ODBhYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvbWVyZ2UuanM/NTYzZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvaW5oZXJpdC5qcz82MzNlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9iaW5kLWZuLmpzP2U2ZjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2hhbW1lci5qcz8xY2I4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbmRleC5qcz81YTYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByaXZhdGVcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbmxldCBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGxldCBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn0gZWxzZSB7XG4gIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbjsiLCJcbmNvbnN0IFZFTkRPUl9QUkVGSVhFUyA9IFsnJywgJ3dlYmtpdCcsICdNb3onLCAnTVMnLCAnbXMnLCAnbyddO1xuY29uc3QgVEVTVF9FTEVNRU5UID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8ge3N0eWxlOiB7fX0gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuY29uc3QgVFlQRV9GVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cbmNvbnN0IHsgcm91bmQsIGFicyB9ID0gTWF0aDtcbmNvbnN0IHsgbm93IH0gPSBEYXRlO1xuXG5leHBvcnQge1xuICAgIFZFTkRPUl9QUkVGSVhFUyxcbiAgICBURVNUX0VMRU1FTlQsXG4gICAgVFlQRV9GVU5DVElPTixcbiAgICByb3VuZCxcbiAgICBhYnMsXG4gICAgbm93XG59O1xuIiwiaW1wb3J0IHsgVkVORE9SX1BSRUZJWEVTIH0gZnJvbSAnLi91dGlscy1jb25zdHMnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJlZml4ZWQob2JqLCBwcm9wZXJ0eSkge1xuICBsZXQgcHJlZml4O1xuICBsZXQgcHJvcDtcbiAgbGV0IGNhbWVsUHJvcCA9IHByb3BlcnR5WzBdLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgIHByZWZpeCA9IFZFTkRPUl9QUkVGSVhFU1tpXTtcbiAgICBwcm9wID0gKHByZWZpeCkgPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5cbmxldCB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdC8vIHdpbmRvdyBpcyB1bmRlZmluZWQgaW4gbm9kZS5qc1xuXHR3aW4gPSB7fTtcbn0gZWxzZSB7XG5cdHdpbiA9IHdpbmRvdztcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG5cbmV4cG9ydCB7d2luIGFzIHdpbmRvd307XG4iLCJpbXBvcnQgcHJlZml4ZWQgZnJvbSAnLi4vdXRpbHMvcHJlZml4ZWQnO1xuaW1wb3J0IHsgVEVTVF9FTEVNRU5UIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCB7d2luZG93fSBmcm9tICcuLi9icm93c2VyJztcblxuZXhwb3J0IGNvbnN0IFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG5leHBvcnQgY29uc3QgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvblByb3BzKCkge1xuICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHRvdWNoTWFwID0ge307XG4gIGxldCBjc3NTdXBwb3J0cyA9IHdpbmRvdy5DU1MgJiYgd2luZG93LkNTUy5zdXBwb3J0cztcbiAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaCgodmFsKSA9PiB7XG5cbiAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAvLyBhbGwgdmFsdWVzLiBUaGlzIGlzIHRoZSBjYXNlIGZvciBJRSAxMCBhbmQgMTEuXG4gICAgcmV0dXJuIHRvdWNoTWFwW3ZhbF0gPSBjc3NTdXBwb3J0cyA/IHdpbmRvdy5DU1Muc3VwcG9ydHMoJ3RvdWNoLWFjdGlvbicsIHZhbCkgOiB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHRvdWNoTWFwO1xufVxuIiwiaW1wb3J0IGdldFRvdWNoQWN0aW9uUHJvcHMgZnJvbSAnLi9nZXQtdG91Y2hhY3Rpb24tcHJvcHMnO1xuXG5cblxuLy8gbWFnaWNhbCB0b3VjaEFjdGlvbiB2YWx1ZVxuY29uc3QgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG5jb25zdCBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbmNvbnN0IFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04gPSAnbWFuaXB1bGF0aW9uJzsgLy8gbm90IGltcGxlbWVudGVkXG5jb25zdCBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbmNvbnN0IFRPVUNIX0FDVElPTl9QQU5fWCA9ICdwYW4teCc7XG5jb25zdCBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xuY29uc3QgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcblxuZXhwb3J0IHtcbiAgVE9VQ0hfQUNUSU9OX0FVVE8sXG4gIFRPVUNIX0FDVElPTl9DT01QVVRFLFxuICBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OLFxuICBUT1VDSF9BQ1RJT05fTk9ORSxcbiAgVE9VQ0hfQUNUSU9OX1BBTl9YLFxuICBUT1VDSF9BQ1RJT05fUEFOX1ksXG4gIFRPVUNIX0FDVElPTl9NQVBcbn07XG4iLCJpbXBvcnQgcHJlZml4ZWQgZnJvbSAnLi4vdXRpbHMvcHJlZml4ZWQnO1xuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi9icm93c2VyXCI7XG5cbmNvbnN0IE1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWQvaTtcblxuY29uc3QgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuY29uc3QgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyA9IHByZWZpeGVkKHdpbmRvdywgJ1BvaW50ZXJFdmVudCcpICE9PSB1bmRlZmluZWQ7XG5jb25zdCBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5jb25zdCBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbmNvbnN0IElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG5jb25zdCBJTlBVVF9UWVBFX01PVVNFID0gJ21vdXNlJztcbmNvbnN0IElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbmNvbnN0IENPTVBVVEVfSU5URVJWQUwgPSAyNTtcblxuY29uc3QgSU5QVVRfU1RBUlQgPSAxO1xuY29uc3QgSU5QVVRfTU9WRSA9IDI7XG5jb25zdCBJTlBVVF9FTkQgPSA0O1xuY29uc3QgSU5QVVRfQ0FOQ0VMID0gODtcblxuY29uc3QgRElSRUNUSU9OX05PTkUgPSAxO1xuY29uc3QgRElSRUNUSU9OX0xFRlQgPSAyO1xuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gNDtcbmNvbnN0IERJUkVDVElPTl9VUCA9IDg7XG5jb25zdCBESVJFQ1RJT05fRE9XTiA9IDE2O1xuXG5jb25zdCBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9MRUZUIHwgRElSRUNUSU9OX1JJR0hUO1xuY29uc3QgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG5jb25zdCBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUw7XG5cbmNvbnN0IFBST1BTX1hZID0gWyd4JywgJ3knXTtcbmNvbnN0IFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbmV4cG9ydCB7XG4gICAgTU9CSUxFX1JFR0VYLFxuICAgIFNVUFBPUlRfT05MWV9UT1VDSCxcbiAgICBTVVBQT1JUX1BPSU5URVJfRVZFTlRTLFxuICAgIFNVUFBPUlRfVE9VQ0gsXG4gICAgSU5QVVRfVFlQRV9LSU5FQ1QsXG4gICAgSU5QVVRfVFlQRV9NT1VTRSxcbiAgICBJTlBVVF9UWVBFX1BFTixcbiAgICBJTlBVVF9UWVBFX1RPVUNILFxuICAgIENPTVBVVEVfSU5URVJWQUwsXG4gICAgSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMLFxuICAgIERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEwsXG4gICAgUFJPUFNfWFksXG4gICAgUFJPUFNfQ0xJRU5UX1hZXG59O1xuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogd2FsayBvYmplY3RzIGFuZCBhcnJheXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlYWNoKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgbGV0IGk7XG5cbiAgaWYgKCFvYmopIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgb2JqLmhhc093blByb3BlcnR5KGkpICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgVFlQRV9GVU5DVElPTiB9IGZyb20gJy4vdXRpbHMtY29uc3RzJztcbi8qKlxuICogQHByaXZhdGVcbiAqIGxldCBhIGJvb2xlYW4gdmFsdWUgYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgbXVzdCByZXR1cm4gYSBib29sZWFuXG4gKiB0aGlzIGZpcnN0IGl0ZW0gaW4gYXJncyB3aWxsIGJlIHVzZWQgYXMgdGhlIGNvbnRleHRcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gdmFsXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJnc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBib29sT3JGbih2YWwsIGFyZ3MpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICByZXR1cm4gdmFsLmFwcGx5KGFyZ3MgPyBhcmdzWzBdIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCwgYXJncyk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIHNtYWxsIGluZGV4T2Ygd3JhcHBlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBmb3VuZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpblN0cihzdHIsIGZpbmQpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG4iLCJpbXBvcnQgaW5TdHIgZnJvbSAnLi4vdXRpbHMvaW4tc3RyJztcbmltcG9ydCB7XG4gICAgVE9VQ0hfQUNUSU9OX05PTkUsXG4gICAgVE9VQ0hfQUNUSU9OX1BBTl9YLFxuICAgIFRPVUNIX0FDVElPTl9QQU5fWSxcbiAgICBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OLFxuICAgIFRPVUNIX0FDVElPTl9BVVRPXG59IGZyb20gJy4vdG91Y2hhY3Rpb24tQ29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsZWFuVG91Y2hBY3Rpb25zKGFjdGlvbnMpIHtcbiAgLy8gbm9uZVxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9XG5cbiAgbGV0IGhhc1BhblggPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICBsZXQgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSk7XG5cbiAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgaWYgKGhhc1BhblggJiYgaGFzUGFuWSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgfVxuXG4gIC8vIHBhbi14IE9SIHBhbi15XG4gIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICByZXR1cm4gaGFzUGFuWCA/IFRPVUNIX0FDVElPTl9QQU5fWCA6IFRPVUNIX0FDVElPTl9QQU5fWTtcbiAgfVxuXG4gIC8vIG1hbmlwdWxhdGlvblxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgfVxuXG4gIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cbiIsImltcG9ydCB7XG4gICAgVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG4gICAgVE9VQ0hfQUNUSU9OX01BUCxcbiAgICBUT1VDSF9BQ1RJT05fTk9ORSxcbiAgICBUT1VDSF9BQ1RJT05fUEFOX1gsXG4gICAgVE9VQ0hfQUNUSU9OX1BBTl9ZXG59IGZyb20gJy4vdG91Y2hhY3Rpb24tQ29uc3RzJztcbmltcG9ydCB7XG4gIE5BVElWRV9UT1VDSF9BQ1RJT04sXG4gIFBSRUZJWEVEX1RPVUNIX0FDVElPTixcbn0gZnJvbSBcIi4vZ2V0LXRvdWNoYWN0aW9uLXByb3BzXCI7XG5pbXBvcnQge1xuICAgIERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgZWFjaCBmcm9tICcuLi91dGlscy9lYWNoJztcbmltcG9ydCBib29sT3JGbiBmcm9tICcuLi91dGlscy9ib29sLW9yLWZuJztcbmltcG9ydCBpblN0ciBmcm9tICcuLi91dGlscy9pbi1zdHInO1xuaW1wb3J0IGNsZWFuVG91Y2hBY3Rpb25zIGZyb20gJy4vY2xlYW4tdG91Y2gtYWN0aW9ucyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRvdWNoIEFjdGlvblxuICogc2V0cyB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkgb3IgdXNlcyB0aGUganMgYWx0ZXJuYXRpdmVcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG91Y2hBY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCB2YWx1ZSkge1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5zZXQodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldCh2YWx1ZSkge1xuICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKHZhbHVlID09PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICB9XG5cbiAgICBpZiAoTkFUSVZFX1RPVUNIX0FDVElPTiAmJiB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZSAmJiBUT1VDSF9BQ1RJT05fTUFQW3ZhbHVlXSkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGVbUFJFRklYRURfVE9VQ0hfQUNUSU9OXSA9IHZhbHVlO1xuICAgIH1cbiAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBqdXN0IHJlLXNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWVcbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnNldCh0aGlzLm1hbmFnZXIub3B0aW9ucy50b3VjaEFjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuICBjb21wdXRlKCkge1xuICAgIGxldCBhY3Rpb25zID0gW107XG4gICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIChyZWNvZ25pemVyKSA9PiB7XG4gICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCBvbiBlYWNoIGlucHV0IGN5Y2xlIGFuZCBwcm92aWRlcyB0aGUgcHJldmVudGluZyBvZiB0aGUgYnJvd3NlciBiZWhhdmlvclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIHByZXZlbnREZWZhdWx0cyhpbnB1dCkge1xuICAgIGxldCB7IHNyY0V2ZW50IH0gPSBpbnB1dDtcbiAgICBsZXQgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgLy8gaWYgdGhlIHRvdWNoIGFjdGlvbiBkaWQgcHJldmVudGVkIG9uY2UgdGhpcyBzZXNzaW9uXG4gICAgaWYgKHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCkge1xuICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgeyBhY3Rpb25zIH0gPSB0aGlzO1xuICAgIGxldCBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICBsZXQgaGFzUGFuWSA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9ZXTtcbiAgICBsZXQgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX1BBTl9YXTtcblxuICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0cyBpZiB0aGlzIGlzIGEgdGFwIGdlc3R1cmVcbiAgICAgIGxldCBpc1RhcFBvaW50ZXIgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IDE7XG4gICAgICBsZXQgaXNUYXBNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgMjtcbiAgICAgIGxldCBpc1RhcFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IDI1MDtcblxuICAgICAgaWYgKGlzVGFwUG9pbnRlciAmJiBpc1RhcE1vdmVtZW50ICYmIGlzVGFwVG91Y2hUaW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAvLyBgcGFuLXggcGFuLXlgIG1lYW5zIGJyb3dzZXIgaGFuZGxlcyBhbGwgc2Nyb2xsaW5nL3Bhbm5pbmcsIGRvIG5vdCBwcmV2ZW50XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhc05vbmUgfHxcbiAgICAgICAgKGhhc1BhblkgJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHx8XG4gICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAqL1xuICBwcmV2ZW50U3JjKHNyY0V2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gKiBAbWV0aG9kIGhhc1BhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgcm91bmQgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGNlbnRlciBvZiBhbGwgdGhlIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludGVyc1xuICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHhgIGFuZCBgeWAgcHJvcGVydGllc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDZW50ZXIocG9pbnRlcnMpIHtcbiAgbGV0IHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRYKSxcbiAgICAgIHk6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFkpXG4gICAgfTtcbiAgfVxuXG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gIH07XG59XG4iLCJpbXBvcnQgeyBub3cscm91bmQgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IGdldENlbnRlciBmcm9tICcuL2dldC1jZW50ZXInO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgYSBzaW1wbGUgY2xvbmUgZnJvbSB0aGUgaW5wdXQgdXNlZCBmb3Igc3RvcmFnZSBvZiBmaXJzdElucHV0IGFuZCBmaXJzdE11bHRpcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqIEByZXR1cm5zIHtPYmplY3R9IGNsb25lZElucHV0RGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCkge1xuICAvLyBtYWtlIGEgc2ltcGxlIGNvcHkgb2YgdGhlIHBvaW50ZXJzIGJlY2F1c2Ugd2Ugd2lsbCBnZXQgYSByZWZlcmVuY2UgaWYgd2UgZG9uJ3RcbiAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gIGxldCBwb2ludGVycyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgfTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgcG9pbnRlcnMsXG4gICAgY2VudGVyOiBnZXRDZW50ZXIocG9pbnRlcnMpLFxuICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgIGRlbHRhWTogaW5wdXQuZGVsdGFZXG4gIH07XG59XG4iLCJpbXBvcnQgeyBQUk9QU19YWSB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMSB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiB7eCwgeX1cbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RGlzdGFuY2UocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuICBsZXQgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgbGV0IHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG5cbiAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG4iLCJpbXBvcnQgeyBQUk9QU19YWSB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuICBsZXQgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgbGV0IHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLmF0YW4yKHksIHgpICogMTgwIC8gTWF0aC5QSTtcbn1cbiIsImltcG9ydCB7IGFicyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgeyBESVJFQ1RJT05fTk9ORSxESVJFQ1RJT05fTEVGVCxESVJFQ1RJT05fUklHSFQsRElSRUNUSU9OX1VQLERJUkVDVElPTl9ET1dOIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gIH1cblxuICBpZiAoYWJzKHgpID49IGFicyh5KSkge1xuICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICB9XG4gIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuIiwiaW1wb3J0IHsgSU5QVVRfU1RBUlQsIElOUFVUX0VORCB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZURlbHRhWFkoc2Vzc2lvbiwgaW5wdXQpIHtcbiAgbGV0IHsgY2VudGVyIH0gPSBpbnB1dDtcbiAgLy8gbGV0IHsgb2Zmc2V0RGVsdGE6b2Zmc2V0ID0ge30sIHByZXZEZWx0YSA9IHt9LCBwcmV2SW5wdXQgPSB7fSB9ID0gc2Vzc2lvbjtcbiAgLy8ganNjcyB0aHJvd2luZyBlcnJvciBvbiBkZWZhbHV0IGRlc3RydWN0dXJlZCB2YWx1ZXMgYW5kIHdpdGhvdXQgZGVmYXVsdHMgdGVzdHMgZmFpbFxuICBsZXQgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgbGV0IHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICBsZXQgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICB9O1xuXG4gICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnlcbiAgICB9O1xuICB9XG5cbiAgaW5wdXQuZGVsdGFYID0gcHJldkRlbHRhLnggKyAoY2VudGVyLnggLSBvZmZzZXQueCk7XG4gIGlucHV0LmRlbHRhWSA9IHByZXZEZWx0YS55ICsgKGNlbnRlci55IC0gb2Zmc2V0LnkpO1xufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgfTtcbn1cbiIsImltcG9ydCB7IFBST1BTX0NMSUVOVF9YWSB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcbmltcG9ydCBnZXREaXN0YW5jZSBmcm9tICcuL2dldC1kaXN0YW5jZSc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvciBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuIiwiaW1wb3J0IGdldEFuZ2xlIGZyb20gJy4vZ2V0LWFuZ2xlJztcbmltcG9ydCB7IFBST1BTX0NMSUVOVF9YWSB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSByb3RhdGlvbiBkZWdyZWVzIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHJvdGF0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuIiwiaW1wb3J0IHsgSU5QVVRfQ0FOQ0VMLENPTVBVVEVfSU5URVJWQUwgfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQgeyBhYnMgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IGdldFZlbG9jaXR5IGZyb20gJy4vZ2V0LXZlbG9jaXR5JztcbmltcG9ydCBnZXREaXJlY3Rpb24gZnJvbSAnLi9nZXQtZGlyZWN0aW9uJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCkge1xuICBsZXQgbGFzdCA9IHNlc3Npb24ubGFzdEludGVydmFsIHx8IGlucHV0O1xuICBsZXQgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXA7XG4gIGxldCB2ZWxvY2l0eTtcbiAgbGV0IHZlbG9jaXR5WDtcbiAgbGV0IHZlbG9jaXR5WTtcbiAgbGV0IGRpcmVjdGlvbjtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgIGxldCBkZWx0YVggPSBpbnB1dC5kZWx0YVggLSBsYXN0LmRlbHRhWDtcbiAgICBsZXQgZGVsdGFZID0gaW5wdXQuZGVsdGFZIC0gbGFzdC5kZWx0YVk7XG5cbiAgICBsZXQgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgZGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgfVxuXG4gIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG4iLCJpbXBvcnQgeyBub3cgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IHsgYWJzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCBoYXNQYXJlbnQgZnJvbSAnLi4vdXRpbHMvaGFzLXBhcmVudCc7XG5pbXBvcnQgc2ltcGxlQ2xvbmVJbnB1dERhdGEgZnJvbSAnLi9zaW1wbGUtY2xvbmUtaW5wdXQtZGF0YSc7XG5pbXBvcnQgZ2V0Q2VudGVyIGZyb20gJy4vZ2V0LWNlbnRlcic7XG5pbXBvcnQgZ2V0RGlzdGFuY2UgZnJvbSAnLi9nZXQtZGlzdGFuY2UnO1xuaW1wb3J0IGdldEFuZ2xlIGZyb20gJy4vZ2V0LWFuZ2xlJztcbmltcG9ydCBnZXREaXJlY3Rpb24gZnJvbSAnLi9nZXQtZGlyZWN0aW9uJztcbmltcG9ydCBjb21wdXRlRGVsdGFYWSBmcm9tICcuL2NvbXB1dGUtZGVsdGEteHknO1xuaW1wb3J0IGdldFZlbG9jaXR5IGZyb20gJy4vZ2V0LXZlbG9jaXR5JztcbmltcG9ydCBnZXRTY2FsZSBmcm9tICcuL2dldC1zY2FsZSc7XG5pbXBvcnQgZ2V0Um90YXRpb24gZnJvbSAnLi9nZXQtcm90YXRpb24nO1xuaW1wb3J0IGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YSBmcm9tICcuL2NvbXB1dGUtaW50ZXJ2YWwtaW5wdXQtZGF0YSc7XG5cbi8qKlxuKiBAcHJpdmF0ZVxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gIGxldCB7IHNlc3Npb24gfSA9IG1hbmFnZXI7XG4gIGxldCB7IHBvaW50ZXJzIH0gPSBpbnB1dDtcbiAgbGV0IHsgbGVuZ3RoOnBvaW50ZXJzTGVuZ3RoIH0gPSBwb2ludGVycztcblxuICAvLyBzdG9yZSB0aGUgZmlyc3QgaW5wdXQgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBhbmQgZGlyZWN0aW9uXG4gIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgc2Vzc2lvbi5maXJzdElucHV0ID0gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpO1xuICB9XG5cbiAgLy8gdG8gY29tcHV0ZSBzY2FsZSBhbmQgcm90YXRpb24gd2UgbmVlZCB0byBzdG9yZSB0aGUgbXVsdGlwbGUgdG91Y2hlc1xuICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgfVxuXG4gIGxldCB7IGZpcnN0SW5wdXQsIGZpcnN0TXVsdGlwbGUgfSA9IHNlc3Npb247XG4gIGxldCBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICBsZXQgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gIGlucHV0LmFuZ2xlID0gZ2V0QW5nbGUob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuICBpbnB1dC5kaXN0YW5jZSA9IGdldERpc3RhbmNlKG9mZnNldENlbnRlciwgY2VudGVyKTtcblxuICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gIGlucHV0Lm9mZnNldERpcmVjdGlvbiA9IGdldERpcmVjdGlvbihpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG5cbiAgbGV0IG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gKGFicyhvdmVyYWxsVmVsb2NpdHkueCkgPiBhYnMob3ZlcmFsbFZlbG9jaXR5LnkpKSA/IG92ZXJhbGxWZWxvY2l0eS54IDogb3ZlcmFsbFZlbG9jaXR5Lnk7XG5cbiAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcblxuICBpbnB1dC5tYXhQb2ludGVycyA9ICFzZXNzaW9uLnByZXZJbnB1dCA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6ICgoaW5wdXQucG9pbnRlcnMubGVuZ3RoID5cbiAgc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogc2Vzc2lvbi5wcmV2SW5wdXQubWF4UG9pbnRlcnMpO1xuXG4gIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgLy8gZmluZCB0aGUgY29ycmVjdCB0YXJnZXRcbiAgbGV0IHRhcmdldCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgY29uc3Qgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgbGV0IHNyY0V2ZW50VGFyZ2V0O1xuXG4gIGlmIChzcmNFdmVudC5jb21wb3NlZFBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9IGVsc2UgaWYgKHNyY0V2ZW50LnBhdGgpIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnBhdGhbMF07XG4gIH0gZWxzZSB7XG4gICAgc3JjRXZlbnRUYXJnZXQgPSBzcmNFdmVudC50YXJnZXQ7XG4gIH1cblxuICBpZiAoaGFzUGFyZW50KHNyY0V2ZW50VGFyZ2V0LCB0YXJnZXQpKSB7XG4gICAgdGFyZ2V0ID0gc3JjRXZlbnRUYXJnZXQ7XG4gIH1cbiAgaW5wdXQudGFyZ2V0ID0gdGFyZ2V0O1xufVxuIiwiaW1wb3J0IHsgSU5QVVRfU1RBUlQsSU5QVVRfRU5ELElOUFVUX0NBTkNFTCB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcbmltcG9ydCBjb21wdXRlSW5wdXREYXRhIGZyb20gJy4vY29tcHV0ZS1pbnB1dC1kYXRhJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgbGV0IHBvaW50ZXJzTGVuID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoO1xuICBsZXQgY2hhbmdlZFBvaW50ZXJzTGVuID0gaW5wdXQuY2hhbmdlZFBvaW50ZXJzLmxlbmd0aDtcbiAgbGV0IGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gIGxldCBpc0ZpbmFsID0gKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIChwb2ludGVyc0xlbiAtIGNoYW5nZWRQb2ludGVyc0xlbiA9PT0gMCkpO1xuXG4gIGlucHV0LmlzRmlyc3QgPSAhIWlzRmlyc3Q7XG4gIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgaWYgKGlzRmlyc3QpIHtcbiAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgfVxuXG4gIC8vIHNvdXJjZSBldmVudCBpcyB0aGUgbm9ybWFsaXplZCB2YWx1ZSBvZiB0aGUgZG9tRXZlbnRzXG4gIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7XG5cbiAgLy8gY29tcHV0ZSBzY2FsZSwgcm90YXRpb24gZXRjXG4gIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gIC8vIGVtaXQgc2VjcmV0IGV2ZW50XG4gIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuXG4gIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgbWFuYWdlci5zZXNzaW9uLnByZXZJbnB1dCA9IGlucHV0O1xufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcGxpdFN0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG4iLCJpbXBvcnQgZWFjaCBmcm9tICcuL2VhY2gnO1xuaW1wb3J0IHNwbGl0U3RyIGZyb20gJy4vc3BsaXQtc3RyJztcbi8qKlxuICogQHByaXZhdGVcbiAqIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgKHR5cGUpID0+IHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IGVhY2ggZnJvbSAnLi9lYWNoJztcbmltcG9ydCBzcGxpdFN0ciBmcm9tICcuL3NwbGl0LXN0cic7XG4vKipcbiAqIEBwcml2YXRlXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgZWFjaChzcGxpdFN0cih0eXBlcyksICh0eXBlKSA9PiB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9KTtcbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgd2luZG93IG9iamVjdCBvZiBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RG9jdW1lbnRWaWV3fFdpbmRvd31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93Rm9yRWxlbWVudChlbGVtZW50KSB7XG4gIGxldCBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcbiAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuIiwiaW1wb3J0IGJvb2xPckZuIGZyb20gJy4uL3V0aWxzL2Jvb2wtb3ItZm4nO1xuaW1wb3J0IGFkZEV2ZW50TGlzdGVuZXJzIGZyb20gJy4uL3V0aWxzL2FkZC1ldmVudC1saXN0ZW5lcnMnO1xuaW1wb3J0IHJlbW92ZUV2ZW50TGlzdGVuZXJzIGZyb20gJy4uL3V0aWxzL3JlbW92ZS1ldmVudC1saXN0ZW5lcnMnO1xuaW1wb3J0IGdldFdpbmRvd0ZvckVsZW1lbnQgZnJvbSAnLi4vdXRpbHMvZ2V0LXdpbmRvdy1mb3ItZWxlbWVudCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXQge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgIGlmIChib29sT3JGbihtYW5hZ2VyLm9wdGlvbnMuZW5hYmxlLCBbbWFuYWdlcl0pKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW5pdCgpO1xuXG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICogQHZpcnR1YWxcbiAgICovXG4gIGhhbmRsZXIoKSB7IH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuICBpbml0KCkge1xuICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgICAgaWYgKChmaW5kQnlLZXkgJiYgc3JjW2ldW2ZpbmRCeUtleV0gPT0gZmluZCkgfHwgKCFmaW5kQnlLZXkgJiYgc3JjW2ldID09PSBmaW5kKSkgey8vIGRvIG5vdCB1c2UgPT09IGhlcmUsIHRlc3QgZmFpbHNcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgICBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMLFxuICAgIElOUFVUX01PVkUsXG4gICAgSU5QVVRfVFlQRV9UT1VDSCxcbiAgICBJTlBVVF9UWVBFX01PVVNFLFxuICAgIElOUFVUX1RZUEVfUEVOLFxuICAgIElOUFVUX1RZUEVfS0lORUNUXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCB7d2luZG93fSBmcm9tIFwiLi4vYnJvd3NlclwiO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3InO1xuaW1wb3J0IGluQXJyYXkgZnJvbSAnLi4vdXRpbHMvaW4tYXJyYXknO1xuXG5jb25zdCBQT0lOVEVSX0lOUFVUX01BUCA9IHtcbiAgcG9pbnRlcmRvd246IElOUFVUX1NUQVJULFxuICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgcG9pbnRlcnVwOiBJTlBVVF9FTkQsXG4gIHBvaW50ZXJjYW5jZWw6IElOUFVUX0NBTkNFTCxcbiAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxuY29uc3QgSUUxMF9QT0lOVEVSX1RZUEVfRU5VTSA9IHtcbiAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgMzogSU5QVVRfVFlQRV9QRU4sXG4gIDQ6IElOUFVUX1RZUEVfTU9VU0UsXG4gIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxubGV0IFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xubGV0IFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludGVyRXZlbnRJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHByb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uZXZFbCA9IFBPSU5URVJfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnN0b3JlID0gKHRoaXMubWFuYWdlci5zZXNzaW9uLnBvaW50ZXJFdmVudHMgPSBbXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIGhhbmRsZXIoZXYpIHtcbiAgICBsZXQgeyBzdG9yZSB9ID0gdGhpcztcbiAgICBsZXQgcmVtb3ZlUG9pbnRlciA9IGZhbHNlO1xuXG4gICAgbGV0IGV2ZW50VHlwZU5vcm1hbGl6ZWQgPSBldi50eXBlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnbXMnLCAnJyk7XG4gICAgbGV0IGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgIGxldCBwb2ludGVyVHlwZSA9IElFMTBfUE9JTlRFUl9UWVBFX0VOVU1bZXYucG9pbnRlclR5cGVdIHx8IGV2LnBvaW50ZXJUeXBlO1xuXG4gICAgbGV0IGlzVG91Y2ggPSAocG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXG4gICAgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICBsZXQgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgLy8gc3RhcnQgYW5kIG1vdXNlIG11c3QgYmUgZG93blxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiBzdG9yZSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgIHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3ZlUG9pbnRlcikge1xuICAgICAgLy8gcmVtb3ZlIGZyb20gdGhlIHN0b3JlXG4gICAgICBzdG9yZS5zcGxpY2Uoc3RvcmVJbmRleCwgMSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbn1cbiIsImltcG9ydCBpbkFycmF5IGZyb20gJy4vaW4tYXJyYXknO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVBcnJheShzcmMsIGtleSwgc29ydCkge1xuICBsZXQgcmVzdWx0cyA9IFtdO1xuICBsZXQgdmFsdWVzID0gW107XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICBsZXQgdmFsID0ga2V5ID8gc3JjW2ldW2tleV0gOiBzcmNbaV07XG4gICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgfVxuICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICBpKys7XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwiaW1wb3J0IHtcbiAgSU5QVVRfU1RBUlQsXG4gIElOUFVUX01PVkUsXG4gIElOUFVUX0VORCxcbiAgSU5QVVRfQ0FOQ0VMLFxuICBJTlBVVF9UWVBFX1RPVUNIXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yJztcbmltcG9ydCB0b0FycmF5IGZyb20gJy4uL3V0aWxzL3RvLWFycmF5JztcbmltcG9ydCBoYXNQYXJlbnQgZnJvbSAnLi4vdXRpbHMvaGFzLXBhcmVudCc7XG5pbXBvcnQgdW5pcXVlQXJyYXkgZnJvbSAnLi4vdXRpbHMvdW5pcXVlLWFycmF5JztcblxuY29uc3QgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG5jb25zdCBUT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG91Y2hJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgVG91Y2hJbnB1dC5wcm90b3R5cGUuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50YXJnZXRJZHMgPSB7fTtcbiAgICAvLyB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgfVxuICBoYW5kbGVyKGV2KSB7XG4gICAgbGV0IHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgbGV0IHRvdWNoZXMgPSBnZXRUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgbGV0IGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICBsZXQgeyB0YXJnZXRJZHMgfSA9IHRoaXM7XG5cbiAgLy8gd2hlbiB0aGVyZSBpcyBvbmx5IG9uZSB0b3VjaCwgdGhlIHByb2Nlc3MgY2FuIGJlIHNpbXBsaWZpZWRcbiAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCB0YXJnZXRUb3VjaGVzO1xuICBsZXQgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcbiAgbGV0IGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW107XG4gIGxldCB7IHRhcmdldCB9ID0gdGhpcztcblxuICAvLyBnZXQgdGFyZ2V0IHRvdWNoZXMgZnJvbSB0b3VjaGVzXG4gIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcigodG91Y2gpID0+IHtcbiAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgfSk7XG5cbiAgLy8gY29sbGVjdCB0b3VjaGVzXG4gIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuICAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG4gIGkgPSAwO1xuICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgIH1cblxuICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG5cbiAgaWYgKCFjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gW1xuICAgIC8vIG1lcmdlIHRhcmdldFRvdWNoZXMgd2l0aCBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyBzbyBpdCBjb250YWlucyBBTEwgdG91Y2hlcywgaW5jbHVkaW5nICdlbmQnIGFuZCAnY2FuY2VsJ1xuICAgIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSxcbiAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICBdO1xufVxuIiwiaW1wb3J0IHtcbiAgICBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORCxcbiAgICBJTlBVVF9UWVBFX01PVVNFXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yJztcblxuY29uc3QgTU9VU0VfSU5QVVRfTUFQID0ge1xuICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxuY29uc3QgTU9VU0VfRUxFTUVOVF9FVkVOVFMgPSAnbW91c2Vkb3duJztcbmNvbnN0IE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBNb3VzZSBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW91c2VJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHByb3RvID0gTW91c2VJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcblxuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBoYW5kbGVyKGV2KSB7XG4gICAgbGV0IGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiBldi5idXR0b24gPT09IDApIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggIT09IDEpIHtcbiAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICB9XG5cbiAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfTU9VU0UsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IElucHV0IGZyb20gXCIuLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgVG91Y2hJbnB1dCBmcm9tIFwiLi90b3VjaFwiO1xuaW1wb3J0IE1vdXNlSW5wdXQgZnJvbSBcIi4vbW91c2VcIjtcbmltcG9ydCB7XG5cdElOUFVUX1NUQVJULFxuXHRJTlBVVF9FTkQsXG5cdElOUFVUX0NBTkNFTCxcblx0SU5QVVRfVFlQRV9UT1VDSCxcblx0SU5QVVRfVFlQRV9NT1VTRSxcbn0gZnJvbSBcIi4uL2lucHV0anMvaW5wdXQtY29uc3RzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENvbWJpbmVkIHRvdWNoIGFuZCBtb3VzZSBpbnB1dFxuICpcbiAqIFRvdWNoIGhhcyBhIGhpZ2hlciBwcmlvcml0eSB0aGVuIG1vdXNlLCBhbmQgd2hpbGUgdG91Y2hpbmcgbm8gbW91c2UgZXZlbnRzIGFyZSBhbGxvd2VkLlxuICogVGhpcyBiZWNhdXNlIHRvdWNoIGRldmljZXMgYWxzbyBlbWl0IG1vdXNlIGV2ZW50cyB3aGlsZSBkb2luZyBhIHRvdWNoLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG5jb25zdCBERURVUF9USU1FT1VUID0gMjUwMDtcbmNvbnN0IERFRFVQX0RJU1RBTkNFID0gMjU7XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcblx0Y29uc3QgeyBjaGFuZ2VkUG9pbnRlcnM6IFt0b3VjaF0gfSA9IGV2ZW50RGF0YTtcblxuXHRpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5wcmltYXJ5VG91Y2gpIHtcblx0XHRjb25zdCBsYXN0VG91Y2ggPSB7IHg6IHRvdWNoLmNsaWVudFgsIHk6IHRvdWNoLmNsaWVudFkgfTtcblx0XHRjb25zdCBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuXG5cdFx0dGhpcy5sYXN0VG91Y2hlcy5wdXNoKGxhc3RUb3VjaCk7XG5cblxuXHRcdGNvbnN0IHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc3QgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG5cblx0XHRcdGlmIChpID4gLTEpIHtcblx0XHRcdFx0bHRzLnNwbGljZShpLCAxKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0c2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuXHR9XG59XG5cblxuZnVuY3Rpb24gcmVjb3JkVG91Y2hlcyhldmVudFR5cGUsIGV2ZW50RGF0YSkge1xuXHRpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpIHtcblx0XHR0aGlzLnByaW1hcnlUb3VjaCA9IGV2ZW50RGF0YS5jaGFuZ2VkUG9pbnRlcnNbMF0uaWRlbnRpZmllcjtcblx0XHRzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuXHR9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG5cdFx0c2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcblx0fVxufVxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcblx0Y29uc3QgeCA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRYO1xuXHRjb25zdCB5ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG5cdFx0Y29uc3QgZHggPSBNYXRoLmFicyh4IC0gdC54KTtcblx0XHRjb25zdCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuXG5cdFx0aWYgKGR4IDw9IERFRFVQX0RJU1RBTkNFICYmIGR5IDw9IERFRFVQX0RJU1RBTkNFKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoTW91c2VJbnB1dCBleHRlbmRzIElucHV0IHtcblx0Y29uc3RydWN0b3IobWFuYWdlciwgY2FsbGJhY2spIHtcblx0XHRzdXBlcihtYW5hZ2VyLCBjYWxsYmFjayk7XG5cblx0XHR0aGlzLnRvdWNoID0gbmV3IFRvdWNoSW5wdXQodGhpcy5tYW5hZ2VyLCB0aGlzLmhhbmRsZXIpO1xuXHRcdHRoaXMubW91c2UgPSBuZXcgTW91c2VJbnB1dCh0aGlzLm1hbmFnZXIsIHRoaXMuaGFuZGxlcik7XG5cdFx0dGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuXHRcdHRoaXMubGFzdFRvdWNoZXMgPSBbXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuXHQgKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXRFdmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG5cdCAqL1xuXHRoYW5kbGVyID0gKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkgPT4ge1xuXHRcdGNvbnN0IGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX1RPVUNIKTtcblx0XHRjb25zdCBpc01vdXNlID0gKGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cblx0XHRpZiAoaXNNb3VzZSAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMuZmlyZXNUb3VjaEV2ZW50cykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG5cdFx0aWYgKGlzVG91Y2gpIHtcblx0XHRcdHJlY29yZFRvdWNoZXMuY2FsbCh0aGlzLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuXHRcdH0gZWxzZSBpZiAoaXNNb3VzZSAmJiBpc1N5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgaW5wdXREYXRhKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuY2FsbGJhY2sobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLnRvdWNoLmRlc3Ryb3koKTtcblx0XHR0aGlzLm1vdXNlLmRlc3Ryb3koKTtcblx0fVxufVxuIiwiaW1wb3J0IHsgU1VQUE9SVF9QT0lOVEVSX0VWRU5UUyxTVVBQT1JUX09OTFlfVE9VQ0gsU1VQUE9SVF9UT1VDSCB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcbmltcG9ydCBpbnB1dEhhbmRsZXIgZnJvbSAnLi9pbnB1dC1oYW5kbGVyJztcbmltcG9ydCBQb2ludGVyRXZlbnRJbnB1dCBmcm9tICcuLi9pbnB1dC9wb2ludGVyZXZlbnQnO1xuaW1wb3J0IFRvdWNoSW5wdXQgZnJvbSAnLi4vaW5wdXQvdG91Y2gnO1xuaW1wb3J0IE1vdXNlSW5wdXQgZnJvbSAnLi4vaW5wdXQvbW91c2UnO1xuaW1wb3J0IFRvdWNoTW91c2VJbnB1dCBmcm9tICcuLi9pbnB1dC90b3VjaG1vdXNlJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIGNhbGxlZCBieSB0aGUgTWFuYWdlciBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIYW1tZXJ9IG1hbmFnZXJcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gIGxldCBUeXBlO1xuICAvLyBsZXQgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuICBsZXQgeyBvcHRpb25zOnsgaW5wdXRDbGFzcyB9IH0gPSBtYW5hZ2VyO1xuICBpZiAoaW5wdXRDbGFzcykge1xuICAgIFR5cGUgPSBpbnB1dENsYXNzO1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMpIHtcbiAgICBUeXBlID0gUG9pbnRlckV2ZW50SW5wdXQ7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9PTkxZX1RPVUNIKSB7XG4gICAgVHlwZSA9IFRvdWNoSW5wdXQ7XG4gIH0gZWxzZSBpZiAoIVNVUFBPUlRfVE9VQ0gpIHtcbiAgICBUeXBlID0gTW91c2VJbnB1dDtcbiAgfSBlbHNlIHtcbiAgICBUeXBlID0gVG91Y2hNb3VzZUlucHV0O1xuICB9XG4gIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG4iLCJpbXBvcnQgZWFjaCBmcm9tICcuL2VhY2gnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5LCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIGZuIG9uIGVhY2ggZW50cnlcbiAqIGlmIGl0IGFpbnQgYW4gYXJyYXkgd2UgZG9uJ3Qgd2FudCB0byBkbyBhIHRoaW5nLlxuICogdGhpcyBpcyB1c2VkIGJ5IGFsbCB0aGUgbWV0aG9kcyB0aGF0IGFjY2VwdCBhIHNpbmdsZSBhbmQgYXJyYXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp8QXJyYXl9IGFyZ1xuICogQHBhcmFtIHtTdHJpbmd9IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHRdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW52b2tlQXJyYXlBcmcoYXJnLCBmbiwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgZWFjaChhcmcsIGNvbnRleHRbZm5dLCBjb250ZXh0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJjb25zdCBTVEFURV9QT1NTSUJMRSA9IDE7XG5jb25zdCBTVEFURV9CRUdBTiA9IDI7XG5jb25zdCBTVEFURV9DSEFOR0VEID0gNDtcbmNvbnN0IFNUQVRFX0VOREVEID0gODtcbmNvbnN0IFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbmNvbnN0IFNUQVRFX0NBTkNFTExFRCA9IDE2O1xuY29uc3QgU1RBVEVfRkFJTEVEID0gMzI7XG5cbmV4cG9ydCB7XG4gICAgU1RBVEVfUE9TU0lCTEUsXG4gICAgU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9GQUlMRURcbn07XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1bmlxdWUgaWRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHVuaXF1ZUlkXG4gKi9cbmxldCBfdW5pcXVlSWQgPSAxO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XG4gIHJldHVybiBfdW5pcXVlSWQrKztcbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHJlY29nbml6ZXIgYnkgbmFtZSBpZiBpdCBpcyBib3VuZCB0byBhIG1hbmFnZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IG90aGVyUmVjb2duaXplclxuICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG4gKiBAcmV0dXJucyB7UmVjb2duaXplcn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHJlY29nbml6ZXIpIHtcbiAgbGV0IHsgbWFuYWdlciB9ID0gcmVjb2duaXplcjtcbiAgaWYgKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gbWFuYWdlci5nZXQob3RoZXJSZWNvZ25pemVyKTtcbiAgfVxuICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuIiwiaW1wb3J0IHtcbiAgICBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfRU5ERUQsXG4gICAgU1RBVEVfQ0hBTkdFRCxcbiAgICBTVEFURV9CRUdBTlxufSBmcm9tICcuL3JlY29nbml6ZXItY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge2NvbnN0YW50fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgaWYgKHN0YXRlICYgU1RBVEVfQ0FOQ0VMTEVEKSB7XG4gICAgcmV0dXJuICdjYW5jZWwnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfRU5ERUQpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9DSEFOR0VEKSB7XG4gICAgcmV0dXJuICdtb3ZlJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0JFR0FOKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuIiwiaW1wb3J0IHtcbiAgICBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9GQUlMRUQsXG4gICAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgICBTVEFURV9DQU5DRUxMRUQsXG4gICAgU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfQ0hBTkdFRFxufSBmcm9tICcuL3JlY29nbml6ZXItY29uc3RzJztcbmltcG9ydCBhc3NpZ24gZnJvbSAnLi4vdXRpbHMvYXNzaWduJztcbmltcG9ydCB1bmlxdWVJZCBmcm9tICcuLi91dGlscy91bmlxdWUtaWQnO1xuaW1wb3J0IGludm9rZUFycmF5QXJnIGZyb20gJy4uL3V0aWxzL2ludm9rZS1hcnJheS1hcmcnO1xuaW1wb3J0IGluQXJyYXkgZnJvbSAnLi4vdXRpbHMvaW4tYXJyYXknO1xuaW1wb3J0IGJvb2xPckZuIGZyb20gJy4uL3V0aWxzL2Jvb2wtb3ItZm4nO1xuaW1wb3J0IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIgZnJvbSAnLi9nZXQtcmVjb2duaXplci1ieS1uYW1lLWlmLW1hbmFnZXInO1xuaW1wb3J0IHN0YXRlU3RyIGZyb20gJy4vc3RhdGUtc3RyJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBlbmFibGU6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIHRoaXMuc2ltdWx0YW5lb3VzID0ge307XG4gICAgdGhpcy5yZXF1aXJlRmFpbCA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAqL1xuICBzZXQob3B0aW9ucykge1xuICAgIGFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cbiAgcmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAncmVjb2duaXplV2l0aCcsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgeyBzaW11bHRhbmVvdXMgfSA9IHRoaXM7XG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGlmICghc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0pIHtcbiAgICAgIHNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdID0gb3RoZXJSZWNvZ25pemVyO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlY29nbml6ZVdpdGgodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRyb3AgdGhlIHNpbXVsdGFuZW91cyBsaW5rLiBpdCBkb2VzbnQgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cbiAgZHJvcFJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZWNvZ25pemVyIGNhbiBvbmx5IHJ1biB3aGVuIGFuIG90aGVyIGlzIGZhaWxpbmdcbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG4gIHJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgeyByZXF1aXJlRmFpbCB9ID0gdGhpcztcbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICovXG4gIGRyb3BSZXF1aXJlRmFpbHVyZShvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICBsZXQgaW5kZXggPSBpbkFycmF5KHRoaXMucmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFzIHJlcXVpcmUgZmFpbHVyZXMgYm9vbGVhblxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1JlcXVpcmVGYWlsdXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGlmIHRoZSByZWNvZ25pemVyIGNhbiByZWNvZ25pemUgc2ltdWx0YW5lb3VzIHdpdGggYW4gb3RoZXIgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGNhblJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBZb3Ugc2hvdWxkIHVzZSBgdHJ5RW1pdGAgaW5zdGVhZCBvZiBgZW1pdGAgZGlyZWN0bHkgdG8gY2hlY2tcbiAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqL1xuICBlbWl0KGlucHV0KSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyAncGFuc3RhcnQnIGFuZCAncGFubW92ZSdcbiAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cblxuICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIHRyeUVtaXQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgIH1cbiAgICAvLyBpdCdzIGZhaWxpbmcgYW55d2F5XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYW4gd2UgZW1pdD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjYW5FbWl0KCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cbiAgcmVjb2duaXplKGlucHV0RGF0YSkge1xuICAgIC8vIG1ha2UgYSBuZXcgY29weSBvZiB0aGUgaW5wdXREYXRhXG4gICAgLy8gc28gd2UgY2FuIGNoYW5nZSB0aGUgaW5wdXREYXRhIHdpdGhvdXQgbWVzc2luZyB1cCB0aGUgb3RoZXIgcmVjb2duaXplcnNcbiAgICBsZXQgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cbiAgICBpZiAoIWJvb2xPckZuKHRoaXMub3B0aW9ucy5lbmFibGUsIFt0aGlzLCBpbnB1dERhdGFDbG9uZV0pKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJlc2V0IHdoZW4gd2UndmUgcmVhY2hlZCB0aGUgZW5kXG4gICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfUkVDT0dOSVpFRCB8IFNUQVRFX0NBTkNFTExFRCB8IFNUQVRFX0ZBSUxFRCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9QT1NTSUJMRTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gdGhpcy5wcm9jZXNzKGlucHV0RGF0YUNsb25lKTtcblxuICAgIC8vIHRoZSByZWNvZ25pemVyIGhhcyByZWNvZ25pemVkIGEgZ2VzdHVyZVxuICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICogdGhlIGFjdHVhbCByZWNvZ25pemluZyBoYXBwZW5zIGluIHRoaXMgbWV0aG9kXG4gICAqIEB2aXJ0dWFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICogQHJldHVybnMge2NvbnN0YW50fSBTVEFURVxuICAgKi9cblxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIHByb2Nlc3MoaW5wdXREYXRhKSB7IH1cbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAqIEB2aXJ0dWFsXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGdldFRvdWNoQWN0aW9uKCkgeyB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGxlZCB3aGVuIHRoZSBnZXN0dXJlIGlzbid0IGFsbG93ZWQgdG8gcmVjb2duaXplXG4gICAqIGxpa2Ugd2hlbiBhbm90aGVyIGlzIGJlaW5nIHJlY29nbml6ZWQgb3IgaXQgaXMgZGlzYWJsZWRcbiAgICogQHZpcnR1YWxcbiAgICovXG4gIHJlc2V0KCkgeyB9XG59IiwiaW1wb3J0IFJlY29nbml6ZXIgZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3InO1xuaW1wb3J0IHsgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiB9IGZyb20gJy4uL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzJztcbmltcG9ydCB7SU5QVVRfU1RBUlQsSU5QVVRfRU5EIH0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IHtcbiAgICBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0ZBSUxFRFxufSBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMnO1xuaW1wb3J0IGdldERpc3RhbmNlIGZyb20gJy4uL2lucHV0anMvZ2V0LWRpc3RhbmNlJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQSB0YXAgaXMgcmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhcFJlY29nbml6ZXIgZXh0ZW5kcyBSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZXZlbnQ6ICd0YXAnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0YXBzOiAxLFxuICAgICAgaW50ZXJ2YWw6IDMwMCwgLy8gbWF4IHRpbWUgYmV0d2VlbiB0aGUgbXVsdGktdGFwIHRhcHNcbiAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgIHRocmVzaG9sZDogOSwgLy8gYSBtaW5pbWFsIG1vdmVtZW50IGlzIG9rLCBidXQga2VlcCBpdCBsb3dcbiAgICAgIHBvc1RocmVzaG9sZDogMTAsIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICAvLyBwcmV2aW91cyB0aW1lIGFuZCBjZW50ZXIsXG4gICAgLy8gdXNlZCBmb3IgdGFwIGNvdW50aW5nXG4gICAgdGhpcy5wVGltZSA9IGZhbHNlO1xuICAgIHRoaXMucENlbnRlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2lucHV0ID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuXG4gIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gIH1cblxuICBwcm9jZXNzKGlucHV0KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcztcblxuICAgIGxldCB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgIGxldCB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICBsZXQgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBpZiAoKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSAmJiAodGhpcy5jb3VudCA9PT0gMCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG4gICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWxUaW1lb3V0KCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWxpZEludGVydmFsID0gdGhpcy5wVGltZSA/IChpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCkgOiB0cnVlO1xuICAgICAgbGV0IHZhbGlkTXVsdGlUYXAgPSAhdGhpcy5wQ2VudGVyIHx8IGdldERpc3RhbmNlKHRoaXMucENlbnRlciwgaW5wdXQuY2VudGVyKSA8IG9wdGlvbnMucG9zVGhyZXNob2xkO1xuXG4gICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAgIC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG4gICAgICBsZXQgdGFwQ291bnQgPSB0aGlzLmNvdW50ICUgb3B0aW9ucy50YXBzO1xuICAgICAgaWYgKHRhcENvdW50ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIGZhaWxpbmcgcmVxdWlyZW1lbnRzLCBpbW1lZGlhdGVseSB0cmlnZ2VyIHRoZSB0YXAgZXZlbnRcbiAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgIGlmICghdGhpcy5oYXNSZXF1aXJlRmFpbHVyZXMoKSkge1xuICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgIH0sIG9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9XG5cbiAgZmFpbFRpbWVvdXQoKSB7XG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgfSwgdGhpcy5vcHRpb25zLmludGVydmFsKTtcbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9XG5cbiAgcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfVxuXG4gIGVtaXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IFJlY29nbml6ZXIgZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3InO1xuaW1wb3J0IHtcbiAgICBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9GQUlMRURcbn0gZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzJztcbmltcG9ydCB7XG4gICAgSU5QVVRfQ0FOQ0VMLFxuICAgIElOUFVUX0VORFxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdHRyUmVjb2duaXplciBleHRlbmRzIFJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAqL1xuICBhdHRyVGVzdChpbnB1dCkge1xuICAgIGxldCBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICByZXR1cm4gb3B0aW9uUG9pbnRlcnMgPT09IDAgfHwgaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25Qb2ludGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICovXG4gIHByb2Nlc3MoaW5wdXQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcztcbiAgICBsZXQgeyBldmVudFR5cGUgfSA9IGlucHV0O1xuXG4gICAgbGV0IGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgbGV0IGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTtcblxuICAgIC8vIG9uIGNhbmNlbCBpbnB1dCBhbmQgd2UndmUgcmVjb2duaXplZCBiZWZvcmUsIHJldHVybiBTVEFURV9DQU5DRUxMRURcbiAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgfSBlbHNlIGlmIChpc1JlY29nbml6ZWQgfHwgaXNWYWxpZCkge1xuICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgIH1cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICAgIERJUkVDVElPTl9MRUZULFxuICAgIERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV05cbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fRE9XTikge1xuICAgIHJldHVybiAnZG93bic7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fVVApIHtcbiAgICByZXR1cm4gJ3VwJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9SSUdIVCkge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cbiIsImltcG9ydCAgQXR0clJlY29nbml6ZXIgZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHtcbiAgICBESVJFQ1RJT05fQUxMLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICBESVJFQ1RJT05fTk9ORSxcbiAgICBESVJFQ1RJT05fVVAsXG4gICAgRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hUXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCB7IFNUQVRFX0JFR0FOIH0gZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzJztcbmltcG9ydCB7IFRPVUNIX0FDVElPTl9QQU5fWCxUT1VDSF9BQ1RJT05fUEFOX1kgfSBmcm9tICcuLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5pbXBvcnQgZGlyZWN0aW9uU3RyIGZyb20gJy4uL3JlY29nbml6ZXJqcy9kaXJlY3Rpb24tc3RyJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGFuXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG93biBhbmQgbW92ZWQgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYW5SZWNvZ25pemVyIGV4dGVuZHMgQXR0clJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBldmVudDogJ3BhbicsXG4gICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9BTEwsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xuICB9XG5cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgbGV0IHsgb3B0aW9uczp7IGRpcmVjdGlvbiB9IH0gPSB0aGlzO1xuICAgIGxldCBhY3Rpb25zID0gW107XG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb25zO1xuICB9XG5cbiAgZGlyZWN0aW9uVGVzdChpbnB1dCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgbGV0IGhhc01vdmVkID0gdHJ1ZTtcbiAgICBsZXQgeyBkaXN0YW5jZSB9ID0gaW5wdXQ7XG4gICAgbGV0IHsgZGlyZWN0aW9uIH0gPSBpbnB1dDtcbiAgICBsZXQgeCA9IGlucHV0LmRlbHRhWDtcbiAgICBsZXQgeSA9IGlucHV0LmRlbHRhWTtcblxuICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICBpZiAoIShkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbikpIHtcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICBoYXNNb3ZlZCA9IHggIT09IHRoaXMucFg7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICh5ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICBoYXNNb3ZlZCA9IHkgIT09IHRoaXMucFk7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFZKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIHJldHVybiBoYXNNb3ZlZCAmJiBkaXN0YW5jZSA+IG9wdGlvbnMudGhyZXNob2xkICYmIGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uO1xuICB9XG5cbiAgYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmIC8vIHJlcGxhY2Ugd2l0aCBhIHN1cGVyIGNhbGxcbiAgICAgICAgKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTiB8fCAoISh0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pICYmIHRoaXMuZGlyZWN0aW9uVGVzdChpbnB1dCkpKTtcbiAgfVxuXG4gIGVtaXQoaW5wdXQpIHtcblxuICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgdGhpcy5wWSA9IGlucHV0LmRlbHRhWTtcblxuICAgIGxldCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQuZGlyZWN0aW9uKTtcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICB9XG4gICAgc3VwZXIuZW1pdChpbnB1dCk7XG4gIH1cbn1cbiIsImltcG9ydCBBdHRyUmVjb2duaXplciBmcm9tICcuLi9yZWNvZ25pemVycy9hdHRyaWJ1dGUnO1xuaW1wb3J0IHsgYWJzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCB7IERJUkVDVElPTl9IT1JJWk9OVEFMLERJUkVDVElPTl9WRVJUSUNBTCB9IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCBQYW5SZWNvZ25pemVyIGZyb20gJy4vcGFuJztcbmltcG9ydCB7IElOUFVUX0VORCB9IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCBkaXJlY3Rpb25TdHIgZnJvbSAnLi4vcmVjb2duaXplcmpzL2RpcmVjdGlvbi1zdHInO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpcGVSZWNvZ25pemVyIGV4dGVuZHMgQXR0clJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICB9XG5cbiAgYXR0clRlc3QoaW5wdXQpIHtcbiAgICBsZXQgeyBkaXJlY3Rpb24gfSA9IHRoaXMub3B0aW9ucztcbiAgICBsZXQgdmVsb2NpdHk7XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmF0dHJUZXN0KGlucHV0KSAmJlxuICAgICAgICBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiZcbiAgICAgICAgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmXG4gICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiZcbiAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gIH1cblxuICBlbWl0KGlucHV0KSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5vZmZzZXREaXJlY3Rpb24pO1xuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbiwgaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgaW5wdXQpO1xuICB9XG59XG4iLCJpbXBvcnQgQXR0clJlY29nbml6ZXIgZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHsgVE9VQ0hfQUNUSU9OX05PTkUgfSBmcm9tICcuLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5pbXBvcnQgeyBTVEFURV9CRUdBTiB9IGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpbmNoUmVjb2duaXplciBleHRlbmRzIEF0dHJSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gIH1cblxuICBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgfVxuXG4gIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmF0dHJUZXN0KGlucHV0KSAmJlxuICAgICAgICAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfVxuXG4gIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgIGxldCBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgIH1cbiAgICBzdXBlci5lbWl0KGlucHV0KTtcbiAgfVxufVxuIiwiaW1wb3J0IEF0dHJSZWNvZ25pemVyIGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCB7IFRPVUNIX0FDVElPTl9OT05FIH0gZnJvbSAnLi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHMnO1xuaW1wb3J0IHsgU1RBVEVfQkVHQU4gfSBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSb3RhdGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVyIGFyZSBtb3ZpbmcgaW4gYSBjaXJjdWxhciBtb3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdGF0ZVJlY29nbml6ZXIgZXh0ZW5kcyBBdHRyUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCB7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMixcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gIH1cblxuICBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgfVxuXG4gIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmF0dHJUZXN0KGlucHV0KSAmJlxuICAgICAgICAoTWF0aC5hYnMoaW5wdXQucm90YXRpb24pID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICB9XG59IiwiaW1wb3J0IFJlY29nbml6ZXIgZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3InO1xuaW1wb3J0IHtcbiAgICBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0ZBSUxFRFxufSBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMnO1xuaW1wb3J0IHsgbm93IH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCB7IFRPVUNIX0FDVElPTl9BVVRPIH0gZnJvbSAnLi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHMnO1xuaW1wb3J0IHtcbiAgICBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNzUmVjb2duaXplciBleHRlbmRzIFJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBldmVudDogJ3ByZXNzJyxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgdGltZTogMjUxLCAvLyBtaW5pbWFsIHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgcHJlc3NlZFxuICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICB9XG5cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gIH1cblxuICBwcm9jZXNzKGlucHV0KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBsZXQgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICBsZXQgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgbGV0IHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG5cbiAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICBpZiAoIXZhbGlkTW92ZW1lbnQgfHwgIXZhbGlkUG9pbnRlcnMgfHwgKGlucHV0LmV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmICF2YWxpZFRpbWUpKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgfSwgb3B0aW9ucy50aW1lKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgfVxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG5cbiAgZW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlucHV0ICYmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChgJHt0aGlzLm9wdGlvbnMuZXZlbnR9dXBgLCBpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9XG59XG5cbiIsImltcG9ydCB7IFRPVUNIX0FDVElPTl9DT01QVVRFIH0gZnJvbSBcIi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHNcIjtcbmltcG9ydCBUYXBSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3RhcFwiO1xuaW1wb3J0IFBhblJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcGFuXCI7XG5pbXBvcnQgU3dpcGVSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3N3aXBlXCI7XG5pbXBvcnQgUGluY2hSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3BpbmNoXCI7XG5pbXBvcnQgUm90YXRlUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9yb3RhdGVcIjtcbmltcG9ydCBQcmVzc1JlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcHJlc3NcIjtcbmltcG9ydCB7RElSRUNUSU9OX0hPUklaT05UQUx9IGZyb20gXCIuL2lucHV0anMvaW5wdXQtY29uc3RzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIHNldCBpZiBET00gZXZlbnRzIGFyZSBiZWluZyB0cmlnZ2VyZWQuXG5cdCAqIEJ1dCB0aGlzIGlzIHNsb3dlciBhbmQgdW51c2VkIGJ5IHNpbXBsZSBpbXBsZW1lbnRhdGlvbnMsIHNvIGRpc2FibGVkIGJ5IGRlZmF1bHQuXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKi9cblx0ZG9tRXZlbnRzOiBmYWxzZSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogVGhlIHZhbHVlIGZvciB0aGUgdG91Y2hBY3Rpb24gcHJvcGVydHkvZmFsbGJhY2suXG5cdCAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuXHQgKiBAdHlwZSB7U3RyaW5nfVxuXHQgKiBAZGVmYXVsdCBjb21wdXRlXG5cdCAqL1xuXHR0b3VjaEFjdGlvbjogVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEB0eXBlIHtCb29sZWFufVxuXHQgKiBAZGVmYXVsdCB0cnVlXG5cdCAqL1xuXHRlbmFibGU6IHRydWUsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEVYUEVSSU1FTlRBTCBGRUFUVVJFIC0tIGNhbiBiZSByZW1vdmVkL2NoYW5nZWRcblx0ICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG5cdCAqIElmIE51bGwsIHRoZW4gaXQgaXMgYmVpbmcgc2V0IHRoZSB0byBtYWluIGVsZW1lbnQuXG5cdCAqIEB0eXBlIHtOdWxsfEV2ZW50VGFyZ2V0fVxuXHQgKiBAZGVmYXVsdCBudWxsXG5cdCAqL1xuXHRpbnB1dFRhcmdldDogbnVsbCxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogZm9yY2UgYW4gaW5wdXQgY2xhc3Ncblx0ICogQHR5cGUge051bGx8RnVuY3Rpb259XG5cdCAqIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdGlucHV0Q2xhc3M6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIFNvbWUgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSB0aGUgd29ya2luZyBvZiBIYW1tZXIuXG5cdCAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cblx0ICogQG5hbWVzcGFjZVxuXHQgKi9cblx0Y3NzUHJvcHM6IHtcblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xuXHRcdCAqL1xuXHRcdHVzZXJTZWxlY3Q6IFwibm9uZVwiLFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBEaXNhYmxlIHRoZSBXaW5kb3dzIFBob25lIGdyaXBwZXJzIHdoZW4gcHJlc3NpbmcgYW4gZWxlbWVudC5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xuXHRcdCAqL1xuXHRcdHRvdWNoU2VsZWN0OiBcIm5vbmVcIixcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogRGlzYWJsZXMgdGhlIGRlZmF1bHQgY2FsbG91dCBzaG93biB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldC5cblx0XHQgKiBPbiBpT1MsIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0IHN1Y2ggYXMgYSBsaW5rLCBTYWZhcmkgZGlzcGxheXNcblx0XHQgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgJ25vbmUnXG5cdFx0ICovXG5cdFx0dG91Y2hDYWxsb3V0OiBcIm5vbmVcIixcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogU3BlY2lmaWVzIHdoZXRoZXIgem9vbWluZyBpcyBlbmFibGVkLiBVc2VkIGJ5IElFMTA+XG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCAnbm9uZSdcblx0XHQgKi9cblx0XHRjb250ZW50Wm9vbWluZzogXCJub25lXCIsXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIFNwZWNpZmllcyB0aGF0IGFuIGVudGlyZSBlbGVtZW50IHNob3VsZCBiZSBkcmFnZ2FibGUgaW5zdGVhZCBvZiBpdHMgY29udGVudHMuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xuXHRcdCAqL1xuXHRcdHVzZXJEcmFnOiBcIm5vbmVcIixcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcblx0XHQgKiBjbGlja2FibGUgZWxlbWVudCBpbiBpT1MuIFRoaXMgcHJvcGVydHkgb2JleXMgdGhlIGFscGhhIHZhbHVlLCBpZiBzcGVjaWZpZWQuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcblx0XHQgKi9cblx0XHR0YXBIaWdobGlnaHRDb2xvcjogXCJyZ2JhKDAsMCwwLDApXCIsXG5cdH0sXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gKiBUaGlzIGlzIHNlcGFyYXRlZCB3aXRoIG90aGVyIGRlZmF1bHRzIGJlY2F1c2Ugb2YgdHJlZS1zaGFraW5nLlxuICogQHR5cGUge0FycmF5fVxuICovXG5leHBvcnQgY29uc3QgcHJlc2V0ID0gW1xuICBbUm90YXRlUmVjb2duaXplciwgeyBlbmFibGU6IGZhbHNlIH1dLFxuICBbUGluY2hSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfSwgWydyb3RhdGUnXV0sXG4gIFtTd2lwZVJlY29nbml6ZXIsIHsgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB9XSxcbiAgW1BhblJlY29nbml6ZXIsIHsgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB9LCBbJ3N3aXBlJ11dLFxuICBbVGFwUmVjb2duaXplcl0sXG4gIFtUYXBSZWNvZ25pemVyLCB7IGV2ZW50OiAnZG91YmxldGFwJywgdGFwczogMiB9LCBbJ3RhcCddXSxcbiAgW1ByZXNzUmVjb2duaXplcl1cbl07XG4iLCJpbXBvcnQgYXNzaWduIGZyb20gXCIuL3V0aWxzL2Fzc2lnblwiO1xuaW1wb3J0IFRvdWNoQWN0aW9uIGZyb20gXCIuL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tY29uc3RydWN0b3JcIjtcbmltcG9ydCBjcmVhdGVJbnB1dEluc3RhbmNlIGZyb20gXCIuL2lucHV0anMvY3JlYXRlLWlucHV0LWluc3RhbmNlXCI7XG5pbXBvcnQgZWFjaCBmcm9tIFwiLi91dGlscy9lYWNoXCI7XG5pbXBvcnQgaW5BcnJheSBmcm9tIFwiLi91dGlscy9pbi1hcnJheVwiO1xuaW1wb3J0IGludm9rZUFycmF5QXJnIGZyb20gXCIuL3V0aWxzL2ludm9rZS1hcnJheS1hcmdcIjtcbmltcG9ydCBzcGxpdFN0ciBmcm9tIFwiLi91dGlscy9zcGxpdC1zdHJcIjtcbmltcG9ydCBwcmVmaXhlZCBmcm9tIFwiLi91dGlscy9wcmVmaXhlZFwiO1xuaW1wb3J0IFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3JcIjtcbmltcG9ydCB7XG4gIFNUQVRFX0JFR0FOLFxuICBTVEFURV9FTkRFRCxcbiAgU1RBVEVfQ0hBTkdFRCxcbiAgU1RBVEVfUkVDT0dOSVpFRCxcbn0gZnJvbSBcIi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzXCI7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSBcIi4vZGVmYXVsdHNcIjtcblxuY29uc3QgU1RPUCA9IDE7XG5jb25zdCBGT1JDRURfU1RPUCA9IDI7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ3NzUHJvcHMobWFuYWdlciwgYWRkKSB7XG4gIGNvbnN0IHsgZWxlbWVudCB9ID0gbWFuYWdlcjtcblxuICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHByb3A7XG5cbiAgZWFjaChtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHMsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgIHByb3AgPSBwcmVmaXhlZChlbGVtZW50LnN0eWxlLCBuYW1lKTtcbiAgICBpZiAoYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgXCJcIjtcbiAgICB9XG4gIH0pO1xuICBpZiAoIWFkZCkge1xuICAgIG1hbmFnZXIub2xkQ3NzUHJvcHMgPSB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgY29uc3QgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtcblxuICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG5cblxuLyoqXG4qIEBwcml2YXRlXG4gKiBNYW5hZ2VyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCA9IHRoaXMub3B0aW9ucy5pbnB1dFRhcmdldCB8fCBlbGVtZW50O1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMucmVjb2duaXplcnMgPSBbXTtcbiAgICB0aGlzLm9sZENzc1Byb3BzID0ge307XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcblxuICAgIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIHRydWUpO1xuXG4gICAgZWFjaCh0aGlzLm9wdGlvbnMucmVjb2duaXplcnMsIGl0ZW0gPT4ge1xuICAgICAgY29uc3QgcmVjb2duaXplciA9IHRoaXMuYWRkKG5ldyAoaXRlbVswXSkoaXRlbVsxXSkpO1xuXG4gICAgICBpdGVtWzJdICYmIHJlY29nbml6ZXIucmVjb2duaXplV2l0aChpdGVtWzJdKTtcbiAgICAgIGl0ZW1bM10gJiYgcmVjb2duaXplci5yZXF1aXJlRmFpbHVyZShpdGVtWzNdKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBzZXQgb3B0aW9uc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJucyB7TWFuYWdlcn1cblx0ICovXG4gIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG4gICAgaWYgKG9wdGlvbnMudG91Y2hBY3Rpb24pIHtcbiAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmlucHV0VGFyZ2V0KSB7XG4gICAgICAvLyBDbGVhbiB1cCBleGlzdGluZyBldmVudCBsaXN0ZW5lcnMgYW5kIHJlaW5pdGlhbGl6ZVxuICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmlucHV0LnRhcmdldCA9IG9wdGlvbnMuaW5wdXRUYXJnZXQ7XG4gICAgICB0aGlzLmlucHV0LmluaXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogc3RvcCByZWNvZ25pemluZyBmb3IgdGhpcyBzZXNzaW9uLlxuXHQgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuXHQgKiBXaGVuIGZvcmNlZCwgdGhlIHJlY29nbml6ZXIgY3ljbGUgaXMgc3RvcHBlZCBpbW1lZGlhdGVseS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdXG5cdCAqL1xuICBzdG9wKGZvcmNlKSB7XG4gICAgdGhpcy5zZXNzaW9uLnN0b3BwZWQgPSBmb3JjZSA/IEZPUkNFRF9TVE9QIDogU1RPUDtcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBydW4gdGhlIHJlY29nbml6ZXJzIVxuXHQgKiBjYWxsZWQgYnkgdGhlIGlucHV0SGFuZGxlciBmdW5jdGlvbiBvbiBldmVyeSBtb3ZlbWVudCBvZiB0aGUgcG9pbnRlcnMgKHRvdWNoZXMpXG5cdCAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG5cdCAqL1xuICByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgY29uc3QgeyBzZXNzaW9uIH0gPSB0aGlzO1xuXG4gICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHJ1biB0aGUgdG91Y2gtYWN0aW9uIHBvbHlmaWxsXG4gICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgIGxldCByZWNvZ25pemVyO1xuICAgIGNvbnN0IHsgcmVjb2duaXplcnMgfSA9IHRoaXM7XG5cbiAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAvLyBzbyB0aGUgcmVjb2duaXplcidzIHN0YXRlIG5lZWRzIHRvIGJlIEJFR0FOLCBDSEFOR0VELCBFTkRFRCBvciBSRUNPR05JWkVEXG4gICAgLy8gaWYgbm8gcmVjb2duaXplciBpcyBkZXRlY3RpbmcgYSB0aGluZywgaXQgaXMgc2V0IHRvIGBudWxsYFxuICAgIGxldCB7IGN1clJlY29nbml6ZXIgfSA9IHNlc3Npb247XG5cbiAgICAvLyByZXNldCB3aGVuIHRoZSBsYXN0IHJlY29nbml6ZXIgaXMgcmVjb2duaXplZFxuICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgIGlmICghY3VyUmVjb2duaXplciB8fCAoY3VyUmVjb2duaXplciAmJiBjdXJSZWNvZ25pemVyLnN0YXRlICYgU1RBVEVfUkVDT0dOSVpFRCkpIHtcbiAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgICBjdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHJlY29nbml6ZXJzLmxlbmd0aCkge1xuICAgICAgcmVjb2duaXplciA9IHJlY29nbml6ZXJzW2ldO1xuXG4gICAgICAvLyBmaW5kIG91dCBpZiB3ZSBhcmUgYWxsb3dlZCB0cnkgdG8gcmVjb2duaXplIHRoZSBpbnB1dCBmb3IgdGhpcyBvbmUuXG4gICAgICAvLyAxLiAgIGFsbG93IGlmIHRoZSBzZXNzaW9uIGlzIE5PVCBmb3JjZWQgc3RvcHBlZCAoc2VlIHRoZSAuc3RvcCgpIG1ldGhvZClcbiAgICAgIC8vIDIuICAgYWxsb3cgaWYgd2Ugc3RpbGwgaGF2ZW4ndCByZWNvZ25pemVkIGEgZ2VzdHVyZSBpbiB0aGlzIHNlc3Npb24sIG9yIHRoZSB0aGlzIHJlY29nbml6ZXIgaXMgdGhlIG9uZVxuICAgICAgLy8gICAgICB0aGF0IGlzIGJlaW5nIHJlY29nbml6ZWQuXG4gICAgICAvLyAzLiAgIGFsbG93IGlmIHRoZSByZWNvZ25pemVyIGlzIGFsbG93ZWQgdG8gcnVuIHNpbXVsdGFuZW91cyB3aXRoIHRoZSBjdXJyZW50IHJlY29nbml6ZWQgcmVjb2duaXplci5cbiAgICAgIC8vICAgICAgdGhpcyBjYW4gYmUgc2V0dXAgd2l0aCB0aGUgYHJlY29nbml6ZVdpdGgoKWAgbWV0aG9kIG9uIHRoZSByZWNvZ25pemVyLlxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKC8vIDFcbiAgICAgICAgIWN1clJlY29nbml6ZXIgfHwgcmVjb2duaXplciA9PT0gY3VyUmVjb2duaXplciB8fCAvLyAyXG4gICAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHsgLy8gM1xuICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG4gICAgICBpZiAoIWN1clJlY29nbml6ZXIgJiYgcmVjb2duaXplci5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCkpIHtcbiAgICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgICAgY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG5cdCAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcblx0ICogQHJldHVybnMge1JlY29nbml6ZXJ8TnVsbH1cblx0ICovXG4gIGdldChyZWNvZ25pemVyKSB7XG4gICAgaWYgKHJlY29nbml6ZXIgaW5zdGFuY2VvZiBSZWNvZ25pemVyKSB7XG4gICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHJlY29nbml6ZXJzIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlY29nbml6ZXJzW2ldLm9wdGlvbnMuZXZlbnQgPT09IHJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZSBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG5cdCAqIGV4aXN0aW5nIHJlY29nbml6ZXJzIHdpdGggdGhlIHNhbWUgZXZlbnQgbmFtZSB3aWxsIGJlIHJlbW92ZWRcblx0ICogQHBhcmFtIHtSZWNvZ25pemVyfSByZWNvZ25pemVyXG5cdCAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG5cdCAqL1xuICBhZGQocmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcImFkZFwiLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmdldChyZWNvZ25pemVyLm9wdGlvbnMuZXZlbnQpO1xuXG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICB0aGlzLnJlbW92ZShleGlzdGluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgIHJlY29nbml6ZXIubWFuYWdlciA9IHRoaXM7XG5cbiAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiByZWNvZ25pemVyO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIHJlbW92ZSBhIHJlY29nbml6ZXIgYnkgbmFtZSBvciBpbnN0YW5jZVxuXHQgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG5cdCAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuXHQgKi9cbiAgcmVtb3ZlKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJyZW1vdmVcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFJlY29nbml6ZXIgPSB0aGlzLmdldChyZWNvZ25pemVyKTtcblxuICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIGNvbnN0IHsgcmVjb2duaXplcnMgfSA9IHRoaXM7XG4gICAgICBjb25zdCBpbmRleCA9IGluQXJyYXkocmVjb2duaXplcnMsIHRhcmdldFJlY29nbml6ZXIpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJlY29nbml6ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogYmluZCBldmVudFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuXHQgKi9cbiAgb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkIHx8IGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyBoYW5kbGVycyB9ID0gdGhpcztcblxuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZXZlbnQgPT4ge1xuICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGUgdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cblx0ICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuXHQgKi9cbiAgb2ZmKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyBoYW5kbGVycyB9ID0gdGhpcztcblxuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZXZlbnQgPT4ge1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tldmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVyc1tldmVudF0gJiYgaGFuZGxlcnNbZXZlbnRdLnNwbGljZShpbkFycmF5KGhhbmRsZXJzW2V2ZW50XSwgaGFuZGxlciksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlIGVtaXQgZXZlbnQgdG8gdGhlIGxpc3RlbmVyc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICovXG4gIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gdHJpZ2dlciBkb20gZXZlbnRzXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG4gICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW2V2ZW50XSAmJiB0aGlzLmhhbmRsZXJzW2V2ZW50XS5zbGljZSgpO1xuXG4gICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YS50eXBlID0gZXZlbnQ7XG4gICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRhdGEuc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuXG4gICAgbGV0IGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcblx0ICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcblx0ICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICAgIElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTCxcbiAgICBJTlBVVF9UWVBFX1RPVUNIXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCBJbnB1dCBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yJztcbmltcG9ydCB0b0FycmF5IGZyb20gJy4uL3V0aWxzL3RvLWFycmF5JztcbmltcG9ydCB1bmlxdWVBcnJheSBmcm9tICcuLi91dGlscy91bmlxdWUtYXJyYXknO1xuXG5jb25zdCBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG5jb25zdCBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0JztcbmNvbnN0IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTID0gJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNpbmdsZVRvdWNoSW5wdXQgZXh0ZW5kcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciBwcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuICAgIHByb3RvLmV2VGFyZ2V0ID0gU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBTSU5HTEVfVE9VQ0hfV0lORE9XX0VWRU5UUztcblxuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyKGV2KSB7XG4gICAgbGV0IHR5cGUgPSBTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB0b3VjaGVzID0gbm9ybWFsaXplU2luZ2xlVG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcblxuICAgIC8vIHdoZW4gZG9uZSwgcmVzZXQgdGhlIHN0YXJ0ZWQgc3RhdGVcbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgbGV0IGFsbCA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gIGxldCBjaGFuZ2VkID0gdG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcyk7XG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgIGFsbCA9IHVuaXF1ZUFycmF5KGFsbC5jb25jYXQoY2hhbmdlZCksICdpZGVudGlmaWVyJywgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gW2FsbCwgY2hhbmdlZF07XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICBsZXQgZGVwcmVjYXRpb25NZXNzYWdlID0gYERFUFJFQ0FURUQgTUVUSE9EOiAke25hbWV9XFxuJHttZXNzYWdlfSBBVCBcXG5gO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbGV0IGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgIGxldCBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL15cXHMrYXRcXHMrL2dtLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgIGxldCBsb2cgPSB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUud2FybiB8fCB3aW5kb3cuY29uc29sZS5sb2cpO1xuICAgIGlmIChsb2cpIHtcbiAgICAgIGxvZy5jYWxsKHdpbmRvdy5jb25zb2xlLCBkZXByZWNhdGlvbk1lc3NhZ2UsIHN0YWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiaW1wb3J0IGRlcHJlY2F0ZSBmcm9tICcuL2RlcHJlY2F0ZSc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmNvbnN0IGV4dGVuZCA9IGRlcHJlY2F0ZSgoZGVzdCwgc3JjLCBtZXJnZSkgPT4ge1xuICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBrZXlzLmxlbmd0aCkge1xuICAgIGlmICghbWVyZ2UgfHwgKG1lcmdlICYmIGRlc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICByZXR1cm4gZGVzdDtcbn0sICdleHRlbmQnLCAnVXNlIGBhc3NpZ25gLicpO1xuXG5leHBvcnQgZGVmYXVsdCBleHRlbmQ7XG4iLCJpbXBvcnQgZGVwcmVjYXRlIGZyb20gJy4vZGVwcmVjYXRlJztcbmltcG9ydCBleHRlbmQgZnJvbSAnLi9leHRlbmQnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5jb25zdCBtZXJnZSA9IGRlcHJlY2F0ZSgoZGVzdCwgc3JjKSA9PiB7XG4gIHJldHVybiBleHRlbmQoZGVzdCwgc3JjLCB0cnVlKTtcbn0sICdtZXJnZScsICdVc2UgYGFzc2lnbmAuJyk7XG5cbmV4cG9ydCBkZWZhdWx0IG1lcmdlO1xuIiwiaW1wb3J0IGFzc2lnbiBmcm9tICcuL2Fzc2lnbic7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgbGV0IGJhc2VQID0gYmFzZS5wcm90b3R5cGU7XG4gIGxldCBjaGlsZFA7XG5cbiAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gIGNoaWxkUC5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICBjaGlsZFAuX3N1cGVyID0gYmFzZVA7XG5cbiAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICBhc3NpZ24oY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGZ1bmN0aW9uIGJpbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kRm4oZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCJpbXBvcnQgTWFuYWdlciBmcm9tIFwiLi9tYW5hZ2VyXCI7XG5pbXBvcnQgZGVmYXVsdHMsIHsgcHJlc2V0IH0gZnJvbSBcIi4vZGVmYXVsdHNcIjtcbmltcG9ydCBhc3NpZ24gZnJvbSAnLi91dGlscy9hc3NpZ24nO1xuaW1wb3J0IHtcbiAgSU5QVVRfU1RBUlQsXG4gIElOUFVUX01PVkUsXG4gIElOUFVUX0VORCxcbiAgSU5QVVRfQ0FOQ0VMLFxuICBESVJFQ1RJT05fTk9ORSxcbiAgRElSRUNUSU9OX0xFRlQsXG4gIERJUkVDVElPTl9SSUdIVCxcbiAgRElSRUNUSU9OX1VQLFxuICBESVJFQ1RJT05fRE9XTixcbiAgRElSRUNUSU9OX0hPUklaT05UQUwsXG4gIERJUkVDVElPTl9WRVJUSUNBTCxcbiAgRElSRUNUSU9OX0FMTCxcbn0gZnJvbSBcIi4vaW5wdXRqcy9pbnB1dC1jb25zdHNcIjtcbmltcG9ydCB7XG4gIFNUQVRFX1BPU1NJQkxFLFxuICBTVEFURV9CRUdBTixcbiAgU1RBVEVfQ0hBTkdFRCxcbiAgU1RBVEVfRU5ERUQsXG4gIFNUQVRFX1JFQ09HTklaRUQsXG4gIFNUQVRFX0NBTkNFTExFRCxcbiAgU1RBVEVfRkFJTEVELFxufSBmcm9tIFwiLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHNcIjtcblxuaW1wb3J0IElucHV0IGZyb20gXCIuL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3JcIjtcbmltcG9ydCBUb3VjaEFjdGlvbiBmcm9tIFwiLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgVG91Y2hJbnB1dCBmcm9tIFwiLi9pbnB1dC90b3VjaFwiO1xuaW1wb3J0IE1vdXNlSW5wdXQgZnJvbSBcIi4vaW5wdXQvbW91c2VcIjtcbmltcG9ydCBQb2ludGVyRXZlbnRJbnB1dCBmcm9tIFwiLi9pbnB1dC9wb2ludGVyZXZlbnRcIjtcbmltcG9ydCBTaW5nbGVUb3VjaElucHV0IGZyb20gXCIuL2lucHV0L3NpbmdsZXRvdWNoXCI7XG5pbXBvcnQgVG91Y2hNb3VzZUlucHV0IGZyb20gXCIuL2lucHV0L3RvdWNobW91c2VcIjtcblxuaW1wb3J0IFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3JcIjtcbmltcG9ydCBBdHRyUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9hdHRyaWJ1dGVcIjtcbmltcG9ydCBUYXBSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3RhcFwiO1xuaW1wb3J0IFBhblJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcGFuXCI7XG5pbXBvcnQgU3dpcGVSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3N3aXBlXCI7XG5pbXBvcnQgUGluY2hSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3BpbmNoXCI7XG5pbXBvcnQgUm90YXRlUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9yb3RhdGVcIjtcbmltcG9ydCBQcmVzc1JlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcHJlc3NcIjtcblxuaW1wb3J0IGFkZEV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL3V0aWxzL2FkZC1ldmVudC1saXN0ZW5lcnNcIjtcbmltcG9ydCByZW1vdmVFdmVudExpc3RlbmVycyBmcm9tIFwiLi91dGlscy9yZW1vdmUtZXZlbnQtbGlzdGVuZXJzXCI7XG5pbXBvcnQgZWFjaCBmcm9tIFwiLi91dGlscy9lYWNoXCI7XG5pbXBvcnQgbWVyZ2UgZnJvbSBcIi4vdXRpbHMvbWVyZ2VcIjtcbmltcG9ydCBleHRlbmQgZnJvbSBcIi4vdXRpbHMvZXh0ZW5kXCI7XG5pbXBvcnQgaW5oZXJpdCBmcm9tIFwiLi91dGlscy9pbmhlcml0XCI7XG5pbXBvcnQgYmluZEZuIGZyb20gXCIuL3V0aWxzL2JpbmQtZm5cIjtcbmltcG9ydCBwcmVmaXhlZCBmcm9tIFwiLi91dGlscy9wcmVmaXhlZFwiO1xuaW1wb3J0IHRvQXJyYXkgZnJvbSBcIi4vdXRpbHMvdG8tYXJyYXlcIjtcbmltcG9ydCB1bmlxdWVBcnJheSBmcm9tIFwiLi91dGlscy91bmlxdWUtYXJyYXlcIjtcbmltcG9ydCBzcGxpdFN0ciBmcm9tIFwiLi91dGlscy9zcGxpdC1zdHJcIjtcbmltcG9ydCBpbkFycmF5IGZyb20gXCIuL3V0aWxzL2luLWFycmF5XCI7XG5pbXBvcnQgYm9vbE9yRm4gZnJvbSBcIi4vdXRpbHMvYm9vbC1vci1mblwiO1xuaW1wb3J0IGhhc1BhcmVudCBmcm9tIFwiLi91dGlscy9oYXMtcGFyZW50XCI7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBTaW1wbGUgd2F5IHRvIGNyZWF0ZSBhIG1hbmFnZXIgd2l0aCBhIGRlZmF1bHQgc2V0IG9mIHJlY29nbml6ZXJzLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhhbW1lciB7XG5cdC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICovXG5cdHN0YXRpYyBWRVJTSU9OID0gXCIjX19WRVJTSU9OX18jXCI7XG5cdHN0YXRpYyBESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0FMTDtcblx0c3RhdGljIERJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG5cdHN0YXRpYyBESVJFQ1RJT05fTEVGVCA9IERJUkVDVElPTl9MRUZUO1xuXHRzdGF0aWMgRElSRUNUSU9OX1JJR0hUID0gRElSRUNUSU9OX1JJR0hUO1xuXHRzdGF0aWMgRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuXHRzdGF0aWMgRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcblx0c3RhdGljIERJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9WRVJUSUNBTDtcblx0c3RhdGljIERJUkVDVElPTl9OT05FID0gRElSRUNUSU9OX05PTkU7XG5cdHN0YXRpYyBESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuXHRzdGF0aWMgSU5QVVRfU1RBUlQgPSBJTlBVVF9TVEFSVDtcblx0c3RhdGljIElOUFVUX01PVkUgPSBJTlBVVF9NT1ZFO1xuICBzdGF0aWMgSU5QVVRfRU5EID0gSU5QVVRfRU5EO1xuXHRzdGF0aWMgSU5QVVRfQ0FOQ0VMID0gSU5QVVRfQ0FOQ0VMO1xuXHRzdGF0aWMgU1RBVEVfUE9TU0lCTEUgPSBTVEFURV9QT1NTSUJMRTtcblx0c3RhdGljIFNUQVRFX0JFR0FOID0gU1RBVEVfQkVHQU47XG5cdHN0YXRpYyBTVEFURV9DSEFOR0VEID0gU1RBVEVfQ0hBTkdFRDtcblx0c3RhdGljIFNUQVRFX0VOREVEID0gU1RBVEVfRU5ERUQ7XG5cdHN0YXRpYyBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfUkVDT0dOSVpFRDtcblx0c3RhdGljIFNUQVRFX0NBTkNFTExFRCA9IFNUQVRFX0NBTkNFTExFRDtcblx0c3RhdGljIFNUQVRFX0ZBSUxFRCA9IFNUQVRFX0ZBSUxFRDtcblx0c3RhdGljIE1hbmFnZXIgPSBNYW5hZ2VyO1xuXHRzdGF0aWMgSW5wdXQgPSBJbnB1dDtcblx0c3RhdGljIFRvdWNoQWN0aW9uID0gVG91Y2hBY3Rpb247XG5cdHN0YXRpYyBUb3VjaElucHV0ID0gVG91Y2hJbnB1dDtcblx0c3RhdGljIE1vdXNlSW5wdXQgPSBNb3VzZUlucHV0O1xuXHRzdGF0aWMgUG9pbnRlckV2ZW50SW5wdXQgPSBQb2ludGVyRXZlbnRJbnB1dDtcblx0c3RhdGljIFRvdWNoTW91c2VJbnB1dCA9IFRvdWNoTW91c2VJbnB1dDtcblx0c3RhdGljIFNpbmdsZVRvdWNoSW5wdXQgPSBTaW5nbGVUb3VjaElucHV0O1xuXHRzdGF0aWMgUmVjb2duaXplciA9IFJlY29nbml6ZXI7XG5cdHN0YXRpYyBBdHRyUmVjb2duaXplciA9IEF0dHJSZWNvZ25pemVyO1xuXHRzdGF0aWMgVGFwID0gVGFwUmVjb2duaXplcjtcblx0c3RhdGljIFBhbiA9IFBhblJlY29nbml6ZXI7XG5cdHN0YXRpYyBTd2lwZSA9IFN3aXBlUmVjb2duaXplcjtcblx0c3RhdGljIFBpbmNoID0gUGluY2hSZWNvZ25pemVyO1xuXHRzdGF0aWMgUm90YXRlID0gUm90YXRlUmVjb2duaXplcjtcblx0c3RhdGljIFByZXNzID0gUHJlc3NSZWNvZ25pemVyO1xuXHRzdGF0aWMgb24gPSBhZGRFdmVudExpc3RlbmVycztcblx0c3RhdGljIG9mZiA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuXHRzdGF0aWMgZWFjaCA9IGVhY2g7XG5cdHN0YXRpYyBtZXJnZSA9IG1lcmdlO1xuXHRzdGF0aWMgZXh0ZW5kID0gZXh0ZW5kO1xuXHRzdGF0aWMgYmluZEZuID0gYmluZEZuO1xuXHRzdGF0aWMgYXNzaWduID0gYXNzaWduO1xuXHRzdGF0aWMgaW5oZXJpdCA9IGluaGVyaXQ7XG5cdHN0YXRpYyBiaW5kRm4gPSBiaW5kRm47XG5cdHN0YXRpYyBwcmVmaXhlZCA9IHByZWZpeGVkO1xuXHRzdGF0aWMgdG9BcnJheSA9IHRvQXJyYXk7XG5cdHN0YXRpYyBpbkFycmF5ID0gaW5BcnJheTtcblx0c3RhdGljIHVuaXF1ZUFycmF5ID0gdW5pcXVlQXJyYXk7XG5cdHN0YXRpYyBzcGxpdFN0ciA9IHNwbGl0U3RyO1xuXHRzdGF0aWMgYm9vbE9yRm4gPSBib29sT3JGbjtcblx0c3RhdGljIGhhc1BhcmVudCA9IGhhc1BhcmVudDtcblx0c3RhdGljIGFkZEV2ZW50TGlzdGVuZXJzID0gYWRkRXZlbnRMaXN0ZW5lcnM7XG5cdHN0YXRpYyByZW1vdmVFdmVudExpc3RlbmVycyA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuXHRzdGF0aWMgZGVmYXVsdHMgPSBhc3NpZ24oe30sIGRlZmF1bHRzLCB7IHByZXNldCB9KTtcblx0Y29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7XG5cdFx0cmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIHtcblx0XHRcdHJlY29nbml6ZXJzOiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICAuLi5wcmVzZXRcblx0XHRcdF0sXG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdH0pO1xuXHR9XG59XG4iLCJcbmltcG9ydCBIYW1tZXIgZnJvbSBcIi4vaGFtbWVyXCI7XG5pbXBvcnQgYXNzaWduIGZyb20gXCIuL3V0aWxzL2Fzc2lnblwiO1xuXG5pbXBvcnQge1xuICBJTlBVVF9TVEFSVCxcbiAgSU5QVVRfTU9WRSxcbiAgSU5QVVRfRU5ELFxuICBJTlBVVF9DQU5DRUwsXG4gIERJUkVDVElPTl9OT05FLFxuICBESVJFQ1RJT05fTEVGVCxcbiAgRElSRUNUSU9OX1JJR0hULFxuICBESVJFQ1RJT05fVVAsXG4gIERJUkVDVElPTl9ET1dOLFxuICBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICBESVJFQ1RJT05fQUxMLFxufSBmcm9tIFwiLi9pbnB1dGpzL2lucHV0LWNvbnN0c1wiO1xuaW1wb3J0IHtcbiAgU1RBVEVfUE9TU0lCTEUsXG4gIFNUQVRFX0JFR0FOLFxuICBTVEFURV9DSEFOR0VELFxuICBTVEFURV9FTkRFRCxcbiAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgU1RBVEVfQ0FOQ0VMTEVELFxuICBTVEFURV9GQUlMRUQsXG59IGZyb20gXCIuL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0c1wiO1xuXG5pbXBvcnQgTWFuYWdlciBmcm9tIFwiLi9tYW5hZ2VyXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IFRvdWNoQWN0aW9uIGZyb20gXCIuL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tY29uc3RydWN0b3JcIjtcbmltcG9ydCBUb3VjaElucHV0IGZyb20gXCIuL2lucHV0L3RvdWNoXCI7XG5pbXBvcnQgTW91c2VJbnB1dCBmcm9tIFwiLi9pbnB1dC9tb3VzZVwiO1xuaW1wb3J0IFBvaW50ZXJFdmVudElucHV0IGZyb20gXCIuL2lucHV0L3BvaW50ZXJldmVudFwiO1xuaW1wb3J0IFNpbmdsZVRvdWNoSW5wdXQgZnJvbSBcIi4vaW5wdXQvc2luZ2xldG91Y2hcIjtcbmltcG9ydCBUb3VjaE1vdXNlSW5wdXQgZnJvbSBcIi4vaW5wdXQvdG91Y2htb3VzZVwiO1xuXG5pbXBvcnQgUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IEF0dHJSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL2F0dHJpYnV0ZVwiO1xuaW1wb3J0IFRhcFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvdGFwXCI7XG5pbXBvcnQgUGFuUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9wYW5cIjtcbmltcG9ydCBTd2lwZVJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvc3dpcGVcIjtcbmltcG9ydCBQaW5jaFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcGluY2hcIjtcbmltcG9ydCBSb3RhdGVSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3JvdGF0ZVwiO1xuaW1wb3J0IFByZXNzUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9wcmVzc1wiO1xuXG5pbXBvcnQgYWRkRXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vdXRpbHMvYWRkLWV2ZW50LWxpc3RlbmVyc1wiO1xuaW1wb3J0IHJlbW92ZUV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL3V0aWxzL3JlbW92ZS1ldmVudC1saXN0ZW5lcnNcIjtcbmltcG9ydCBlYWNoIGZyb20gXCIuL3V0aWxzL2VhY2hcIjtcbmltcG9ydCBtZXJnZSBmcm9tIFwiLi91dGlscy9tZXJnZVwiO1xuaW1wb3J0IGV4dGVuZCBmcm9tIFwiLi91dGlscy9leHRlbmRcIjtcbmltcG9ydCBpbmhlcml0IGZyb20gXCIuL3V0aWxzL2luaGVyaXRcIjtcbmltcG9ydCBiaW5kRm4gZnJvbSBcIi4vdXRpbHMvYmluZC1mblwiO1xuaW1wb3J0IHByZWZpeGVkIGZyb20gXCIuL3V0aWxzL3ByZWZpeGVkXCI7XG5pbXBvcnQgdG9BcnJheSBmcm9tIFwiLi91dGlscy90by1hcnJheVwiO1xuaW1wb3J0IHVuaXF1ZUFycmF5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZS1hcnJheVwiO1xuaW1wb3J0IHNwbGl0U3RyIGZyb20gXCIuL3V0aWxzL3NwbGl0LXN0clwiO1xuaW1wb3J0IGluQXJyYXkgZnJvbSBcIi4vdXRpbHMvaW4tYXJyYXlcIjtcbmltcG9ydCBib29sT3JGbiBmcm9tIFwiLi91dGlscy9ib29sLW9yLWZuXCI7XG5pbXBvcnQgaGFzUGFyZW50IGZyb20gXCIuL3V0aWxzL2hhcy1wYXJlbnRcIjtcblxuLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuXG5jb25zdCBkZWZhdWx0cyA9IEhhbW1lci5kZWZhdWx0cztcblxuZXhwb3J0IHtcbiAgSGFtbWVyIGFzIGRlZmF1bHQsXG4gIElOUFVUX1NUQVJULFxuICBJTlBVVF9NT1ZFLFxuICBJTlBVVF9FTkQsXG4gIElOUFVUX0NBTkNFTCxcbiAgU1RBVEVfUE9TU0lCTEUsXG4gIFNUQVRFX0JFR0FOLFxuICBTVEFURV9DSEFOR0VELFxuICBTVEFURV9FTkRFRCxcbiAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgU1RBVEVfQ0FOQ0VMTEVELFxuICBTVEFURV9GQUlMRUQsXG5cbiAgRElSRUNUSU9OX05PTkUsXG4gIERJUkVDVElPTl9MRUZULFxuICBESVJFQ1RJT05fUklHSFQsXG4gIERJUkVDVElPTl9VUCxcbiAgRElSRUNUSU9OX0RPV04sXG4gIERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICBESVJFQ1RJT05fVkVSVElDQUwsXG4gIERJUkVDVElPTl9BTEwsXG4gIE1hbmFnZXIsXG4gIElucHV0LFxuICBUb3VjaEFjdGlvbixcbiAgVG91Y2hJbnB1dCxcbiAgTW91c2VJbnB1dCxcbiAgUG9pbnRlckV2ZW50SW5wdXQsXG4gIFRvdWNoTW91c2VJbnB1dCxcbiAgU2luZ2xlVG91Y2hJbnB1dCxcbiAgUmVjb2duaXplcixcbiAgQXR0clJlY29nbml6ZXIsXG4gIFRhcFJlY29nbml6ZXIgYXMgVGFwLFxuICBQYW5SZWNvZ25pemVyIGFzIFBhbixcbiAgU3dpcGVSZWNvZ25pemVyIGFzIFN3aXBlLFxuICBQaW5jaFJlY29nbml6ZXIgYXMgUGluY2gsXG4gIFJvdGF0ZVJlY29nbml6ZXIgYXMgUm90YXRlLFxuICBQcmVzc1JlY29nbml6ZXIgYXMgUHJlc3MsXG4gIGFkZEV2ZW50TGlzdGVuZXJzIGFzIG9uLFxuICByZW1vdmVFdmVudExpc3RlbmVycyBhcyBvZmYsXG4gIGVhY2gsXG4gIG1lcmdlLFxuICBleHRlbmQsXG4gIGFzc2lnbixcbiAgaW5oZXJpdCxcbiAgYmluZEZuLFxuICBwcmVmaXhlZCxcbiAgdG9BcnJheSxcbiAgaW5BcnJheSxcbiAgdW5pcXVlQXJyYXksXG4gIHNwbGl0U3RyLFxuICBib29sT3JGbixcbiAgaGFzUGFyZW50LFxuICBhZGRFdmVudExpc3RlbmVycyxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMsXG4gIGRlZmF1bHRzLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@egjs/hammerjs/dist/hammer.esm.js\n");

/***/ })

}]);