"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_fullcalendar_core_locales-all_js-node_modules_fullcalendar_core_main_js--5760cd"],{

/***/ "./node_modules/@fullcalendar/common/main.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component; },\n/* harmony export */   \"Fragment\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment; },\n/* harmony export */   \"createContext\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext; },\n/* harmony export */   \"createElement\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement; },\n/* harmony export */   \"createPortal\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createPortal; },\n/* harmony export */   \"createRef\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef; },\n/* harmony export */   \"flushToDom\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.flushToDom; },\n/* harmony export */   \"render\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.render; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* reexport safe */ _vdom_js__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode; },\n/* harmony export */   \"BASE_OPTION_DEFAULTS\": function() { return /* binding */ BASE_OPTION_DEFAULTS; },\n/* harmony export */   \"BASE_OPTION_REFINERS\": function() { return /* binding */ BASE_OPTION_REFINERS; },\n/* harmony export */   \"BaseComponent\": function() { return /* binding */ BaseComponent; },\n/* harmony export */   \"BgEvent\": function() { return /* binding */ BgEvent; },\n/* harmony export */   \"CalendarApi\": function() { return /* binding */ CalendarApi; },\n/* harmony export */   \"CalendarContent\": function() { return /* binding */ CalendarContent; },\n/* harmony export */   \"CalendarDataManager\": function() { return /* binding */ CalendarDataManager; },\n/* harmony export */   \"CalendarDataProvider\": function() { return /* binding */ CalendarDataProvider; },\n/* harmony export */   \"CalendarRoot\": function() { return /* binding */ CalendarRoot; },\n/* harmony export */   \"ContentHook\": function() { return /* binding */ ContentHook; },\n/* harmony export */   \"CustomContentRenderContext\": function() { return /* binding */ CustomContentRenderContext; },\n/* harmony export */   \"DateComponent\": function() { return /* binding */ DateComponent; },\n/* harmony export */   \"DateEnv\": function() { return /* binding */ DateEnv; },\n/* harmony export */   \"DateProfileGenerator\": function() { return /* binding */ DateProfileGenerator; },\n/* harmony export */   \"DayCellContent\": function() { return /* binding */ DayCellContent; },\n/* harmony export */   \"DayCellRoot\": function() { return /* binding */ DayCellRoot; },\n/* harmony export */   \"DayHeader\": function() { return /* binding */ DayHeader; },\n/* harmony export */   \"DaySeriesModel\": function() { return /* binding */ DaySeriesModel; },\n/* harmony export */   \"DayTableModel\": function() { return /* binding */ DayTableModel; },\n/* harmony export */   \"DelayedRunner\": function() { return /* binding */ DelayedRunner; },\n/* harmony export */   \"ElementDragging\": function() { return /* binding */ ElementDragging; },\n/* harmony export */   \"ElementScrollController\": function() { return /* binding */ ElementScrollController; },\n/* harmony export */   \"Emitter\": function() { return /* binding */ Emitter; },\n/* harmony export */   \"EventApi\": function() { return /* binding */ EventApi; },\n/* harmony export */   \"EventRoot\": function() { return /* binding */ EventRoot; },\n/* harmony export */   \"EventSourceApi\": function() { return /* binding */ EventSourceApi; },\n/* harmony export */   \"Interaction\": function() { return /* binding */ Interaction; },\n/* harmony export */   \"MoreLinkRoot\": function() { return /* binding */ MoreLinkRoot; },\n/* harmony export */   \"MountHook\": function() { return /* binding */ MountHook; },\n/* harmony export */   \"NamedTimeZoneImpl\": function() { return /* binding */ NamedTimeZoneImpl; },\n/* harmony export */   \"NowIndicatorRoot\": function() { return /* binding */ NowIndicatorRoot; },\n/* harmony export */   \"NowTimer\": function() { return /* binding */ NowTimer; },\n/* harmony export */   \"PositionCache\": function() { return /* binding */ PositionCache; },\n/* harmony export */   \"RefMap\": function() { return /* binding */ RefMap; },\n/* harmony export */   \"RenderHook\": function() { return /* binding */ RenderHook; },\n/* harmony export */   \"ScrollController\": function() { return /* binding */ ScrollController; },\n/* harmony export */   \"ScrollResponder\": function() { return /* binding */ ScrollResponder; },\n/* harmony export */   \"Scroller\": function() { return /* binding */ Scroller; },\n/* harmony export */   \"SegHierarchy\": function() { return /* binding */ SegHierarchy; },\n/* harmony export */   \"SimpleScrollGrid\": function() { return /* binding */ SimpleScrollGrid; },\n/* harmony export */   \"Slicer\": function() { return /* binding */ Slicer; },\n/* harmony export */   \"Splitter\": function() { return /* binding */ Splitter; },\n/* harmony export */   \"StandardEvent\": function() { return /* binding */ StandardEvent; },\n/* harmony export */   \"TableDateCell\": function() { return /* binding */ TableDateCell; },\n/* harmony export */   \"TableDowCell\": function() { return /* binding */ TableDowCell; },\n/* harmony export */   \"Theme\": function() { return /* binding */ Theme; },\n/* harmony export */   \"ViewApi\": function() { return /* binding */ ViewApi; },\n/* harmony export */   \"ViewContextType\": function() { return /* binding */ ViewContextType; },\n/* harmony export */   \"ViewRoot\": function() { return /* binding */ ViewRoot; },\n/* harmony export */   \"WeekNumberRoot\": function() { return /* binding */ WeekNumberRoot; },\n/* harmony export */   \"WindowScrollController\": function() { return /* binding */ WindowScrollController; },\n/* harmony export */   \"addDays\": function() { return /* binding */ addDays; },\n/* harmony export */   \"addDurations\": function() { return /* binding */ addDurations; },\n/* harmony export */   \"addMs\": function() { return /* binding */ addMs; },\n/* harmony export */   \"addWeeks\": function() { return /* binding */ addWeeks; },\n/* harmony export */   \"allowContextMenu\": function() { return /* binding */ allowContextMenu; },\n/* harmony export */   \"allowSelection\": function() { return /* binding */ allowSelection; },\n/* harmony export */   \"applyMutationToEventStore\": function() { return /* binding */ applyMutationToEventStore; },\n/* harmony export */   \"applyStyle\": function() { return /* binding */ applyStyle; },\n/* harmony export */   \"applyStyleProp\": function() { return /* binding */ applyStyleProp; },\n/* harmony export */   \"asCleanDays\": function() { return /* binding */ asCleanDays; },\n/* harmony export */   \"asRoughMinutes\": function() { return /* binding */ asRoughMinutes; },\n/* harmony export */   \"asRoughMs\": function() { return /* binding */ asRoughMs; },\n/* harmony export */   \"asRoughSeconds\": function() { return /* binding */ asRoughSeconds; },\n/* harmony export */   \"binarySearch\": function() { return /* binding */ binarySearch; },\n/* harmony export */   \"buildClassNameNormalizer\": function() { return /* binding */ buildClassNameNormalizer; },\n/* harmony export */   \"buildEntryKey\": function() { return /* binding */ buildEntryKey; },\n/* harmony export */   \"buildEventApis\": function() { return /* binding */ buildEventApis; },\n/* harmony export */   \"buildEventRangeKey\": function() { return /* binding */ buildEventRangeKey; },\n/* harmony export */   \"buildHashFromArray\": function() { return /* binding */ buildHashFromArray; },\n/* harmony export */   \"buildIsoString\": function() { return /* binding */ buildIsoString; },\n/* harmony export */   \"buildNavLinkData\": function() { return /* binding */ buildNavLinkData; },\n/* harmony export */   \"buildSegCompareObj\": function() { return /* binding */ buildSegCompareObj; },\n/* harmony export */   \"buildSegTimeText\": function() { return /* binding */ buildSegTimeText; },\n/* harmony export */   \"collectFromHash\": function() { return /* binding */ collectFromHash; },\n/* harmony export */   \"combineEventUis\": function() { return /* binding */ combineEventUis; },\n/* harmony export */   \"compareByFieldSpec\": function() { return /* binding */ compareByFieldSpec; },\n/* harmony export */   \"compareByFieldSpecs\": function() { return /* binding */ compareByFieldSpecs; },\n/* harmony export */   \"compareNumbers\": function() { return /* binding */ compareNumbers; },\n/* harmony export */   \"compareObjs\": function() { return /* binding */ compareObjs; },\n/* harmony export */   \"computeEarliestSegStart\": function() { return /* binding */ computeEarliestSegStart; },\n/* harmony export */   \"computeEdges\": function() { return /* binding */ computeEdges; },\n/* harmony export */   \"computeFallbackHeaderFormat\": function() { return /* binding */ computeFallbackHeaderFormat; },\n/* harmony export */   \"computeHeightAndMargins\": function() { return /* binding */ computeHeightAndMargins; },\n/* harmony export */   \"computeInnerRect\": function() { return /* binding */ computeInnerRect; },\n/* harmony export */   \"computeRect\": function() { return /* binding */ computeRect; },\n/* harmony export */   \"computeSegDraggable\": function() { return /* binding */ computeSegDraggable; },\n/* harmony export */   \"computeSegEndResizable\": function() { return /* binding */ computeSegEndResizable; },\n/* harmony export */   \"computeSegStartResizable\": function() { return /* binding */ computeSegStartResizable; },\n/* harmony export */   \"computeShrinkWidth\": function() { return /* binding */ computeShrinkWidth; },\n/* harmony export */   \"computeSmallestCellWidth\": function() { return /* binding */ computeSmallestCellWidth; },\n/* harmony export */   \"computeVisibleDayRange\": function() { return /* binding */ computeVisibleDayRange; },\n/* harmony export */   \"config\": function() { return /* binding */ config; },\n/* harmony export */   \"constrainPoint\": function() { return /* binding */ constrainPoint; },\n/* harmony export */   \"createDuration\": function() { return /* binding */ createDuration; },\n/* harmony export */   \"createEmptyEventStore\": function() { return /* binding */ createEmptyEventStore; },\n/* harmony export */   \"createEventInstance\": function() { return /* binding */ createEventInstance; },\n/* harmony export */   \"createEventUi\": function() { return /* binding */ createEventUi; },\n/* harmony export */   \"createFormatter\": function() { return /* binding */ createFormatter; },\n/* harmony export */   \"createPlugin\": function() { return /* binding */ createPlugin; },\n/* harmony export */   \"diffDates\": function() { return /* binding */ diffDates; },\n/* harmony export */   \"diffDayAndTime\": function() { return /* binding */ diffDayAndTime; },\n/* harmony export */   \"diffDays\": function() { return /* binding */ diffDays; },\n/* harmony export */   \"diffPoints\": function() { return /* binding */ diffPoints; },\n/* harmony export */   \"diffWeeks\": function() { return /* binding */ diffWeeks; },\n/* harmony export */   \"diffWholeDays\": function() { return /* binding */ diffWholeDays; },\n/* harmony export */   \"diffWholeWeeks\": function() { return /* binding */ diffWholeWeeks; },\n/* harmony export */   \"disableCursor\": function() { return /* binding */ disableCursor; },\n/* harmony export */   \"elementClosest\": function() { return /* binding */ elementClosest; },\n/* harmony export */   \"elementMatches\": function() { return /* binding */ elementMatches; },\n/* harmony export */   \"enableCursor\": function() { return /* binding */ enableCursor; },\n/* harmony export */   \"eventTupleToStore\": function() { return /* binding */ eventTupleToStore; },\n/* harmony export */   \"filterEventStoreDefs\": function() { return /* binding */ filterEventStoreDefs; },\n/* harmony export */   \"filterHash\": function() { return /* binding */ filterHash; },\n/* harmony export */   \"findDirectChildren\": function() { return /* binding */ findDirectChildren; },\n/* harmony export */   \"findElements\": function() { return /* binding */ findElements; },\n/* harmony export */   \"flexibleCompare\": function() { return /* binding */ flexibleCompare; },\n/* harmony export */   \"formatDate\": function() { return /* binding */ formatDate; },\n/* harmony export */   \"formatDayString\": function() { return /* binding */ formatDayString; },\n/* harmony export */   \"formatIsoTimeString\": function() { return /* binding */ formatIsoTimeString; },\n/* harmony export */   \"formatRange\": function() { return /* binding */ formatRange; },\n/* harmony export */   \"getAllowYScrolling\": function() { return /* binding */ getAllowYScrolling; },\n/* harmony export */   \"getCanVGrowWithinCell\": function() { return /* binding */ getCanVGrowWithinCell; },\n/* harmony export */   \"getClippingParents\": function() { return /* binding */ getClippingParents; },\n/* harmony export */   \"getDateMeta\": function() { return /* binding */ getDateMeta; },\n/* harmony export */   \"getDayClassNames\": function() { return /* binding */ getDayClassNames; },\n/* harmony export */   \"getDefaultEventEnd\": function() { return /* binding */ getDefaultEventEnd; },\n/* harmony export */   \"getElRoot\": function() { return /* binding */ getElRoot; },\n/* harmony export */   \"getElSeg\": function() { return /* binding */ getElSeg; },\n/* harmony export */   \"getEntrySpanEnd\": function() { return /* binding */ getEntrySpanEnd; },\n/* harmony export */   \"getEventClassNames\": function() { return /* binding */ getEventClassNames; },\n/* harmony export */   \"getEventTargetViaRoot\": function() { return /* binding */ getEventTargetViaRoot; },\n/* harmony export */   \"getIsRtlScrollbarOnLeft\": function() { return /* binding */ getIsRtlScrollbarOnLeft; },\n/* harmony export */   \"getRectCenter\": function() { return /* binding */ getRectCenter; },\n/* harmony export */   \"getRelevantEvents\": function() { return /* binding */ getRelevantEvents; },\n/* harmony export */   \"getScrollGridClassNames\": function() { return /* binding */ getScrollGridClassNames; },\n/* harmony export */   \"getScrollbarWidths\": function() { return /* binding */ getScrollbarWidths; },\n/* harmony export */   \"getSectionClassNames\": function() { return /* binding */ getSectionClassNames; },\n/* harmony export */   \"getSectionHasLiquidHeight\": function() { return /* binding */ getSectionHasLiquidHeight; },\n/* harmony export */   \"getSegMeta\": function() { return /* binding */ getSegMeta; },\n/* harmony export */   \"getSlotClassNames\": function() { return /* binding */ getSlotClassNames; },\n/* harmony export */   \"getStickyFooterScrollbar\": function() { return /* binding */ getStickyFooterScrollbar; },\n/* harmony export */   \"getStickyHeaderDates\": function() { return /* binding */ getStickyHeaderDates; },\n/* harmony export */   \"getUnequalProps\": function() { return /* binding */ getUnequalProps; },\n/* harmony export */   \"globalLocales\": function() { return /* binding */ globalLocales; },\n/* harmony export */   \"globalPlugins\": function() { return /* binding */ globalPlugins; },\n/* harmony export */   \"greatestDurationDenominator\": function() { return /* binding */ greatestDurationDenominator; },\n/* harmony export */   \"groupIntersectingEntries\": function() { return /* binding */ groupIntersectingEntries; },\n/* harmony export */   \"guid\": function() { return /* binding */ guid; },\n/* harmony export */   \"hasBgRendering\": function() { return /* binding */ hasBgRendering; },\n/* harmony export */   \"hasShrinkWidth\": function() { return /* binding */ hasShrinkWidth; },\n/* harmony export */   \"identity\": function() { return /* binding */ identity; },\n/* harmony export */   \"interactionSettingsStore\": function() { return /* binding */ interactionSettingsStore; },\n/* harmony export */   \"interactionSettingsToStore\": function() { return /* binding */ interactionSettingsToStore; },\n/* harmony export */   \"intersectRanges\": function() { return /* binding */ intersectRanges; },\n/* harmony export */   \"intersectRects\": function() { return /* binding */ intersectRects; },\n/* harmony export */   \"intersectSpans\": function() { return /* binding */ intersectSpans; },\n/* harmony export */   \"isArraysEqual\": function() { return /* binding */ isArraysEqual; },\n/* harmony export */   \"isColPropsEqual\": function() { return /* binding */ isColPropsEqual; },\n/* harmony export */   \"isDateSelectionValid\": function() { return /* binding */ isDateSelectionValid; },\n/* harmony export */   \"isDateSpansEqual\": function() { return /* binding */ isDateSpansEqual; },\n/* harmony export */   \"isInt\": function() { return /* binding */ isInt; },\n/* harmony export */   \"isInteractionValid\": function() { return /* binding */ isInteractionValid; },\n/* harmony export */   \"isMultiDayRange\": function() { return /* binding */ isMultiDayRange; },\n/* harmony export */   \"isPropsEqual\": function() { return /* binding */ isPropsEqual; },\n/* harmony export */   \"isPropsValid\": function() { return /* binding */ isPropsValid; },\n/* harmony export */   \"isValidDate\": function() { return /* binding */ isValidDate; },\n/* harmony export */   \"joinSpans\": function() { return /* binding */ joinSpans; },\n/* harmony export */   \"listenBySelector\": function() { return /* binding */ listenBySelector; },\n/* harmony export */   \"mapHash\": function() { return /* binding */ mapHash; },\n/* harmony export */   \"memoize\": function() { return /* binding */ memoize; },\n/* harmony export */   \"memoizeArraylike\": function() { return /* binding */ memoizeArraylike; },\n/* harmony export */   \"memoizeHashlike\": function() { return /* binding */ memoizeHashlike; },\n/* harmony export */   \"memoizeObjArg\": function() { return /* binding */ memoizeObjArg; },\n/* harmony export */   \"mergeEventStores\": function() { return /* binding */ mergeEventStores; },\n/* harmony export */   \"multiplyDuration\": function() { return /* binding */ multiplyDuration; },\n/* harmony export */   \"padStart\": function() { return /* binding */ padStart; },\n/* harmony export */   \"parseBusinessHours\": function() { return /* binding */ parseBusinessHours; },\n/* harmony export */   \"parseClassNames\": function() { return /* binding */ parseClassNames; },\n/* harmony export */   \"parseDragMeta\": function() { return /* binding */ parseDragMeta; },\n/* harmony export */   \"parseEventDef\": function() { return /* binding */ parseEventDef; },\n/* harmony export */   \"parseFieldSpecs\": function() { return /* binding */ parseFieldSpecs; },\n/* harmony export */   \"parseMarker\": function() { return /* binding */ parse; },\n/* harmony export */   \"pointInsideRect\": function() { return /* binding */ pointInsideRect; },\n/* harmony export */   \"preventContextMenu\": function() { return /* binding */ preventContextMenu; },\n/* harmony export */   \"preventDefault\": function() { return /* binding */ preventDefault; },\n/* harmony export */   \"preventSelection\": function() { return /* binding */ preventSelection; },\n/* harmony export */   \"rangeContainsMarker\": function() { return /* binding */ rangeContainsMarker; },\n/* harmony export */   \"rangeContainsRange\": function() { return /* binding */ rangeContainsRange; },\n/* harmony export */   \"rangesEqual\": function() { return /* binding */ rangesEqual; },\n/* harmony export */   \"rangesIntersect\": function() { return /* binding */ rangesIntersect; },\n/* harmony export */   \"refineEventDef\": function() { return /* binding */ refineEventDef; },\n/* harmony export */   \"refineProps\": function() { return /* binding */ refineProps; },\n/* harmony export */   \"removeElement\": function() { return /* binding */ removeElement; },\n/* harmony export */   \"removeExact\": function() { return /* binding */ removeExact; },\n/* harmony export */   \"renderChunkContent\": function() { return /* binding */ renderChunkContent; },\n/* harmony export */   \"renderFill\": function() { return /* binding */ renderFill; },\n/* harmony export */   \"renderMicroColGroup\": function() { return /* binding */ renderMicroColGroup; },\n/* harmony export */   \"renderScrollShim\": function() { return /* binding */ renderScrollShim; },\n/* harmony export */   \"requestJson\": function() { return /* binding */ requestJson; },\n/* harmony export */   \"sanitizeShrinkWidth\": function() { return /* binding */ sanitizeShrinkWidth; },\n/* harmony export */   \"setElSeg\": function() { return /* binding */ setElSeg; },\n/* harmony export */   \"setRef\": function() { return /* binding */ setRef; },\n/* harmony export */   \"sliceEventStore\": function() { return /* binding */ sliceEventStore; },\n/* harmony export */   \"sliceEvents\": function() { return /* binding */ sliceEvents; },\n/* harmony export */   \"sortEventSegs\": function() { return /* binding */ sortEventSegs; },\n/* harmony export */   \"startOfDay\": function() { return /* binding */ startOfDay; },\n/* harmony export */   \"translateRect\": function() { return /* binding */ translateRect; },\n/* harmony export */   \"triggerDateSelect\": function() { return /* binding */ triggerDateSelect; },\n/* harmony export */   \"unpromisify\": function() { return /* binding */ unpromisify; },\n/* harmony export */   \"version\": function() { return /* binding */ version; },\n/* harmony export */   \"whenTransitionDone\": function() { return /* binding */ whenTransitionDone; },\n/* harmony export */   \"wholeDivideDurations\": function() { return /* binding */ wholeDivideDurations; }\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/common/main.css\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _vdom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vdom.js */ \"./node_modules/@fullcalendar/common/vdom.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\nvar EventSourceApi = function () {\n  function EventSourceApi(context, internalEventSource) {\n    this.context = context;\n    this.internalEventSource = internalEventSource;\n  }\n\n  EventSourceApi.prototype.remove = function () {\n    this.context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: this.internalEventSource.sourceId\n    });\n  };\n\n  EventSourceApi.prototype.refetch = function () {\n    this.context.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      sourceIds: [this.internalEventSource.sourceId],\n      isRefetch: true\n    });\n  };\n\n  Object.defineProperty(EventSourceApi.prototype, \"id\", {\n    get: function get() {\n      return this.internalEventSource.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"url\", {\n    get: function get() {\n      return this.internalEventSource.meta.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventSourceApi.prototype, \"format\", {\n    get: function get() {\n      return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return EventSourceApi;\n}();\n\nfunction removeElement(el) {\n  if (el.parentNode) {\n    el.parentNode.removeChild(el);\n  }\n} // Querying\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction elementClosest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector); // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n  }\n\n  if (!document.documentElement.contains(el)) {\n    return null;\n  }\n\n  do {\n    if (elementMatches(el, selector)) {\n      return el;\n    }\n\n    el = el.parentElement || el.parentNode;\n  } while (el !== null && el.nodeType === 1);\n\n  return null;\n}\n\nfunction elementMatches(el, selector) {\n  var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n  return method.call(el, selector);\n} // accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\n\n\nfunction findElements(container, selector) {\n  var containers = container instanceof HTMLElement ? [container] : container;\n  var allMatches = [];\n\n  for (var i = 0; i < containers.length; i += 1) {\n    var matches = containers[i].querySelectorAll(selector);\n\n    for (var j = 0; j < matches.length; j += 1) {\n      allMatches.push(matches[j]);\n    }\n  }\n\n  return allMatches;\n} // accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\n\n\nfunction findDirectChildren(parent, selector) {\n  var parents = parent instanceof HTMLElement ? [parent] : parent;\n  var allMatches = [];\n\n  for (var i = 0; i < parents.length; i += 1) {\n    var childNodes = parents[i].children; // only ever elements\n\n    for (var j = 0; j < childNodes.length; j += 1) {\n      var childNode = childNodes[j];\n\n      if (!selector || elementMatches(childNode, selector)) {\n        allMatches.push(childNode);\n      }\n    }\n  }\n\n  return allMatches;\n} // Style\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n\nfunction applyStyle(el, props) {\n  for (var propName in props) {\n    applyStyleProp(el, propName, props[propName]);\n  }\n}\n\nfunction applyStyleProp(el, name, val) {\n  if (val == null) {\n    el.style[name] = '';\n  } else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n    el.style[name] = val + \"px\";\n  } else {\n    el.style[name] = val;\n  }\n} // Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\n\n\nfunction getEventTargetViaRoot(ev) {\n  var _a, _b;\n\n  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n} // Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction getElRoot(el) {\n  return el.getRootNode ? el.getRootNode() : document;\n} // Stops a mouse/touch event from doing it's native browser action\n\n\nfunction preventDefault(ev) {\n  ev.preventDefault();\n} // Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildDelegationHandler(selector, handler) {\n  return function (ev) {\n    var matchedChild = elementClosest(ev.target, selector);\n\n    if (matchedChild) {\n      handler.call(matchedChild, ev, matchedChild);\n    }\n  };\n}\n\nfunction listenBySelector(container, eventType, selector, handler) {\n  var attachedHandler = buildDelegationHandler(selector, handler);\n  container.addEventListener(eventType, attachedHandler);\n  return function () {\n    container.removeEventListener(eventType, attachedHandler);\n  };\n}\n\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n  var currentMatchedChild;\n  return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {\n    if (matchedChild !== currentMatchedChild) {\n      currentMatchedChild = matchedChild;\n      onMouseEnter(mouseOverEv, matchedChild);\n\n      var realOnMouseLeave_1 = function realOnMouseLeave_1(mouseLeaveEv) {\n        currentMatchedChild = null;\n        onMouseLeave(mouseLeaveEv, matchedChild);\n        matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n      }; // listen to the next mouseleave, and then unattach\n\n\n      matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n    }\n  });\n} // Animation\n// ----------------------------------------------------------------------------------------------------------------\n\n\nvar transitionEventNames = ['webkitTransitionEnd', 'otransitionend', 'oTransitionEnd', 'msTransitionEnd', 'transitionend']; // triggered only when the next single subsequent transition finishes\n\nfunction whenTransitionDone(el, callback) {\n  var realCallback = function realCallback(ev) {\n    callback(ev);\n    transitionEventNames.forEach(function (eventName) {\n      el.removeEventListener(eventName, realCallback);\n    });\n  };\n\n  transitionEventNames.forEach(function (eventName) {\n    el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n  });\n}\n\nvar guidNumber = 0;\n\nfunction guid() {\n  guidNumber += 1;\n  return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n// Make the mouse cursor express that an event is not allowed in the current area\n\n\nfunction disableCursor() {\n  document.body.classList.add('fc-not-allowed');\n} // Returns the mouse cursor to its original look\n\n\nfunction enableCursor() {\n  document.body.classList.remove('fc-not-allowed');\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventSelection(el) {\n  el.classList.add('fc-unselectable');\n  el.addEventListener('selectstart', preventDefault);\n}\n\nfunction allowSelection(el) {\n  el.classList.remove('fc-unselectable');\n  el.removeEventListener('selectstart', preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction preventContextMenu(el) {\n  el.addEventListener('contextmenu', preventDefault);\n}\n\nfunction allowContextMenu(el) {\n  el.removeEventListener('contextmenu', preventDefault);\n}\n\nfunction parseFieldSpecs(input) {\n  var specs = [];\n  var tokens = [];\n  var i;\n  var token;\n\n  if (typeof input === 'string') {\n    tokens = input.split(/\\s*,\\s*/);\n  } else if (typeof input === 'function') {\n    tokens = [input];\n  } else if (Array.isArray(input)) {\n    tokens = input;\n  }\n\n  for (i = 0; i < tokens.length; i += 1) {\n    token = tokens[i];\n\n    if (typeof token === 'string') {\n      specs.push(token.charAt(0) === '-' ? {\n        field: token.substring(1),\n        order: -1\n      } : {\n        field: token,\n        order: 1\n      });\n    } else if (typeof token === 'function') {\n      specs.push({\n        func: token\n      });\n    }\n  }\n\n  return specs;\n}\n\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n  var i;\n  var cmp;\n\n  for (i = 0; i < fieldSpecs.length; i += 1) {\n    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n\n    if (cmp) {\n      return cmp;\n    }\n  }\n\n  return 0;\n}\n\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n  if (fieldSpec.func) {\n    return fieldSpec.func(obj0, obj1);\n  }\n\n  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\n\nfunction flexibleCompare(a, b) {\n  if (!a && !b) {\n    return 0;\n  }\n\n  if (b == null) {\n    return -1;\n  }\n\n  if (a == null) {\n    return 1;\n  }\n\n  if (typeof a === 'string' || typeof b === 'string') {\n    return String(a).localeCompare(String(b));\n  }\n\n  return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction padStart(val, len) {\n  var s = String(val);\n  return '000'.substr(0, len - s.length) + s;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction isInt(n) {\n  return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/\n\n\nfunction computeSmallestCellWidth(cellEl) {\n  var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n  var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n\n  if (!allWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n  }\n\n  if (!contentWidthEl) {\n    throw new Error('needs fc-scrollgrid-shrink-cushion className');\n  }\n\n  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n  contentWidthEl.getBoundingClientRect().width;\n}\n\nvar DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat']; // Adding\n\nfunction addWeeks(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n * 7;\n  return arrayToUtcDate(a);\n}\n\nfunction addDays(m, n) {\n  var a = dateToUtcArray(m);\n  a[2] += n;\n  return arrayToUtcDate(a);\n}\n\nfunction addMs(m, n) {\n  var a = dateToUtcArray(m);\n  a[6] += n;\n  return arrayToUtcDate(a);\n} // Diffing (all return floats)\n// TODO: why not use ranges?\n\n\nfunction diffWeeks(m0, m1) {\n  return diffDays(m0, m1) / 7;\n}\n\nfunction diffDays(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\n\nfunction diffHours(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\n\nfunction diffMinutes(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\n\nfunction diffSeconds(m0, m1) {\n  return (m1.valueOf() - m0.valueOf()) / 1000;\n}\n\nfunction diffDayAndTime(m0, m1) {\n  var m0day = startOfDay(m0);\n  var m1day = startOfDay(m1);\n  return {\n    years: 0,\n    months: 0,\n    days: Math.round(diffDays(m0day, m1day)),\n    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n  };\n} // Diffing Whole Units\n\n\nfunction diffWholeWeeks(m0, m1) {\n  var d = diffWholeDays(m0, m1);\n\n  if (d !== null && d % 7 === 0) {\n    return d / 7;\n  }\n\n  return null;\n}\n\nfunction diffWholeDays(m0, m1) {\n  if (timeAsMs(m0) === timeAsMs(m1)) {\n    return Math.round(diffDays(m0, m1));\n  }\n\n  return null;\n} // Start-Of\n\n\nfunction startOfDay(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate()]);\n}\n\nfunction startOfHour(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours()]);\n}\n\nfunction startOfMinute(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes()]);\n}\n\nfunction startOfSecond(m) {\n  return arrayToUtcDate([m.getUTCFullYear(), m.getUTCMonth(), m.getUTCDate(), m.getUTCHours(), m.getUTCMinutes(), m.getUTCSeconds()]);\n} // Week Computation\n\n\nfunction weekOfYear(marker, dow, doy) {\n  var y = marker.getUTCFullYear();\n  var w = weekOfGivenYear(marker, y, dow, doy);\n\n  if (w < 1) {\n    return weekOfGivenYear(marker, y - 1, dow, doy);\n  }\n\n  var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n\n  if (nextW >= 1) {\n    return Math.min(w, nextW);\n  }\n\n  return w;\n}\n\nfunction weekOfGivenYear(marker, year, dow, doy) {\n  var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n  var dayStart = startOfDay(marker);\n  var days = Math.round(diffDays(firstWeekStart, dayStart));\n  return Math.floor(days / 7) + 1; // zero-indexed\n} // start-of-first-week - start-of-year\n\n\nfunction firstWeekOffset(year, dow, doy) {\n  // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n  var fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd\n\n  var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n  return -fwdlw + fwd - 1;\n} // Array Conversion\n\n\nfunction dateToLocalArray(date) {\n  return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];\n}\n\nfunction arrayToLocalDate(a) {\n  return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n  a[3] || 0, a[4] || 0, a[5] || 0);\n}\n\nfunction dateToUtcArray(date) {\n  return [date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()];\n}\n\nfunction arrayToUtcDate(a) {\n  // according to web standards (and Safari), a month index is required.\n  // massage if only given a year.\n  if (a.length === 1) {\n    a = a.concat([0]);\n  }\n\n  return new Date(Date.UTC.apply(Date, a));\n} // Other Utils\n\n\nfunction isValidDate(m) {\n  return !isNaN(m.valueOf());\n}\n\nfunction timeAsMs(m) {\n  return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\n\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n  return {\n    instanceId: guid(),\n    defId: defId,\n    range: range,\n    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n  };\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty; // Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\n\nfunction mergeProps(propObjs, complexPropsMap) {\n  var dest = {};\n\n  if (complexPropsMap) {\n    for (var name_1 in complexPropsMap) {\n      var complexObjs = []; // collect the trailing object values, stopping when a non-object is discovered\n\n      for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n        var val = propObjs[i][name_1];\n\n        if (_typeof(val) === 'object' && val) {\n          // non-null object\n          complexObjs.unshift(val);\n        } else if (val !== undefined) {\n          dest[name_1] = val; // if there were no objects, this value will be used\n\n          break;\n        }\n      } // if the trailing values were objects, use the merged value\n\n\n      if (complexObjs.length) {\n        dest[name_1] = mergeProps(complexObjs);\n      }\n    }\n  } // copy values into the destination, going from last to first\n\n\n  for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n    var props = propObjs[i];\n\n    for (var name_2 in props) {\n      if (!(name_2 in dest)) {\n        // if already assigned by previous props or complex props, don't reassign\n        dest[name_2] = props[name_2];\n      }\n    }\n  }\n\n  return dest;\n}\n\nfunction filterHash(hash, func) {\n  var filtered = {};\n\n  for (var key in hash) {\n    if (func(hash[key], key)) {\n      filtered[key] = hash[key];\n    }\n  }\n\n  return filtered;\n}\n\nfunction mapHash(hash, func) {\n  var newHash = {};\n\n  for (var key in hash) {\n    newHash[key] = func(hash[key], key);\n  }\n\n  return newHash;\n}\n\nfunction arrayToHash(a) {\n  var hash = {};\n\n  for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n    var item = a_1[_i];\n    hash[item] = true;\n  }\n\n  return hash;\n}\n\nfunction buildHashFromArray(a, func) {\n  var hash = {};\n\n  for (var i = 0; i < a.length; i += 1) {\n    var tuple = func(a[i], i);\n    hash[tuple[0]] = tuple[1];\n  }\n\n  return hash;\n}\n\nfunction hashValuesToArray(obj) {\n  var a = [];\n\n  for (var key in obj) {\n    a.push(obj[key]);\n  }\n\n  return a;\n}\n\nfunction isPropsEqual(obj0, obj1) {\n  if (obj0 === obj1) {\n    return true;\n  }\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        return false;\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction getUnequalProps(obj0, obj1) {\n  var keys = [];\n\n  for (var key in obj0) {\n    if (hasOwnProperty.call(obj0, key)) {\n      if (!(key in obj1)) {\n        keys.push(key);\n      }\n    }\n  }\n\n  for (var key in obj1) {\n    if (hasOwnProperty.call(obj1, key)) {\n      if (obj0[key] !== obj1[key]) {\n        keys.push(key);\n      }\n    }\n  }\n\n  return keys;\n}\n\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n  if (equalityFuncs === void 0) {\n    equalityFuncs = {};\n  }\n\n  if (oldProps === newProps) {\n    return true;\n  }\n\n  for (var key in newProps) {\n    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;else {\n      return false;\n    }\n  } // check for props that were omitted in the new\n\n\n  for (var key in oldProps) {\n    if (!(key in newProps)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/\n\n\nfunction isObjValsEqual(val0, val1, comparator) {\n  if (val0 === val1 || comparator === true) {\n    return true;\n  }\n\n  if (comparator) {\n    return comparator(val0, val1);\n  }\n\n  return false;\n}\n\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n  if (startIndex === void 0) {\n    startIndex = 0;\n  }\n\n  if (step === void 0) {\n    step = 1;\n  }\n\n  var res = [];\n\n  if (endIndex == null) {\n    endIndex = Object.keys(hash).length;\n  }\n\n  for (var i = startIndex; i < endIndex; i += step) {\n    var val = hash[i];\n\n    if (val !== undefined) {\n      // will disregard undefined for sparse arrays\n      res.push(val);\n    }\n  }\n\n  return res;\n}\n\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n  for (var i = 0; i < recurringTypes.length; i += 1) {\n    var parsed = recurringTypes[i].parse(refined, dateEnv);\n\n    if (parsed) {\n      var allDay = refined.allDay;\n\n      if (allDay == null) {\n        allDay = defaultAllDay;\n\n        if (allDay == null) {\n          allDay = parsed.allDayGuess;\n\n          if (allDay == null) {\n            allDay = false;\n          }\n        }\n      }\n\n      return {\n        allDay: allDay,\n        duration: parsed.duration,\n        typeData: parsed.typeData,\n        typeId: i\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction expandRecurring(eventStore, framingRange, context) {\n  var dateEnv = context.dateEnv,\n      pluginHooks = context.pluginHooks,\n      options = context.options;\n  var defs = eventStore.defs,\n      instances = eventStore.instances; // remove existing recurring instances\n  // TODO: bad. always expand events as a second step\n\n  instances = filterHash(instances, function (instance) {\n    return !defs[instance.defId].recurringDef;\n  });\n\n  for (var defId in defs) {\n    var def = defs[defId];\n\n    if (def.recurringDef) {\n      var duration = def.recurringDef.duration;\n\n      if (!duration) {\n        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n      }\n\n      var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n\n      for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n        var start = starts_1[_i];\n        var instance = createEventInstance(defId, {\n          start: start,\n          end: dateEnv.add(start, duration)\n        });\n        instances[instance.instanceId] = instance;\n      }\n    }\n  }\n\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n/*\nEvent MUST have a recurringDef\n*/\n\n\nfunction expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n  var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n  var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n    start: dateEnv.subtract(framingRange.start, duration),\n    end: framingRange.end\n  }, dateEnv); // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n\n  if (eventDef.allDay) {\n    markers = markers.map(startOfDay);\n  }\n\n  return markers;\n}\n\nvar INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/; // Parsing and Creation\n\nfunction createDuration(input, unit) {\n  var _a;\n\n  if (typeof input === 'string') {\n    return parseString(input);\n  }\n\n  if (_typeof(input) === 'object' && input) {\n    // non-null object\n    return parseObject(input);\n  }\n\n  if (typeof input === 'number') {\n    return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n  }\n\n  return null;\n}\n\nfunction parseString(s) {\n  var m = PARSE_RE.exec(s);\n\n  if (m) {\n    var sign = m[1] ? -1 : 1;\n    return {\n      years: 0,\n      months: 0,\n      days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n      milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n      (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n      (m[5] ? parseInt(m[5], 10) : 0) * 1000 + (m[6] ? parseInt(m[6], 10) : 0) // ms\n      )\n    };\n  }\n\n  return null;\n}\n\nfunction parseObject(obj) {\n  var duration = {\n    years: obj.years || obj.year || 0,\n    months: obj.months || obj.month || 0,\n    days: obj.days || obj.day || 0,\n    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n    (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n    (obj.seconds || obj.second || 0) * 1000 + (obj.milliseconds || obj.millisecond || obj.ms || 0) // ms\n\n  };\n  var weeks = obj.weeks || obj.week;\n\n  if (weeks) {\n    duration.days += weeks * 7;\n    duration.specifiedWeeks = true;\n  }\n\n  return duration;\n} // Equality\n\n\nfunction durationsEqual(d0, d1) {\n  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\n\nfunction asCleanDays(dur) {\n  if (!dur.years && !dur.months && !dur.milliseconds) {\n    return dur.days;\n  }\n\n  return 0;\n} // Simple Math\n\n\nfunction addDurations(d0, d1) {\n  return {\n    years: d0.years + d1.years,\n    months: d0.months + d1.months,\n    days: d0.days + d1.days,\n    milliseconds: d0.milliseconds + d1.milliseconds\n  };\n}\n\nfunction subtractDurations(d1, d0) {\n  return {\n    years: d1.years - d0.years,\n    months: d1.months - d0.months,\n    days: d1.days - d0.days,\n    milliseconds: d1.milliseconds - d0.milliseconds\n  };\n}\n\nfunction multiplyDuration(d, n) {\n  return {\n    years: d.years * n,\n    months: d.months * n,\n    days: d.days * n,\n    milliseconds: d.milliseconds * n\n  };\n} // Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\n\n\nfunction asRoughYears(dur) {\n  return asRoughDays(dur) / 365;\n}\n\nfunction asRoughMonths(dur) {\n  return asRoughDays(dur) / 30;\n}\n\nfunction asRoughDays(dur) {\n  return asRoughMs(dur) / 864e5;\n}\n\nfunction asRoughMinutes(dur) {\n  return asRoughMs(dur) / (1000 * 60);\n}\n\nfunction asRoughSeconds(dur) {\n  return asRoughMs(dur) / 1000;\n}\n\nfunction asRoughMs(dur) {\n  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n} // Advanced Math\n\n\nfunction wholeDivideDurations(numerator, denominator) {\n  var res = null;\n\n  for (var i = 0; i < INTERNAL_UNITS.length; i += 1) {\n    var unit = INTERNAL_UNITS[i];\n\n    if (denominator[unit]) {\n      var localRes = numerator[unit] / denominator[unit];\n\n      if (!isInt(localRes) || res !== null && res !== localRes) {\n        return null;\n      }\n\n      res = localRes;\n    } else if (numerator[unit]) {\n      // needs to divide by something but can't!\n      return null;\n    }\n  }\n\n  return res;\n}\n\nfunction greatestDurationDenominator(dur) {\n  var ms = dur.milliseconds;\n\n  if (ms) {\n    if (ms % 1000 !== 0) {\n      return {\n        unit: 'millisecond',\n        value: ms\n      };\n    }\n\n    if (ms % (1000 * 60) !== 0) {\n      return {\n        unit: 'second',\n        value: ms / 1000\n      };\n    }\n\n    if (ms % (1000 * 60 * 60) !== 0) {\n      return {\n        unit: 'minute',\n        value: ms / (1000 * 60)\n      };\n    }\n\n    if (ms) {\n      return {\n        unit: 'hour',\n        value: ms / (1000 * 60 * 60)\n      };\n    }\n  }\n\n  if (dur.days) {\n    if (dur.specifiedWeeks && dur.days % 7 === 0) {\n      return {\n        unit: 'week',\n        value: dur.days / 7\n      };\n    }\n\n    return {\n      unit: 'day',\n      value: dur.days\n    };\n  }\n\n  if (dur.months) {\n    return {\n      unit: 'month',\n      value: dur.months\n    };\n  }\n\n  if (dur.years) {\n    return {\n      unit: 'year',\n      value: dur.years\n    };\n  }\n\n  return {\n    unit: 'millisecond',\n    value: 0\n  };\n} // timeZoneOffset is in minutes\n\n\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n  if (stripZeroTime === void 0) {\n    stripZeroTime = false;\n  }\n\n  var s = marker.toISOString();\n  s = s.replace('.000', '');\n\n  if (stripZeroTime) {\n    s = s.replace('T00:00:00Z', '');\n  }\n\n  if (s.length > 10) {\n    // time part wasn't stripped, can add timezone info\n    if (timeZoneOffset == null) {\n      s = s.replace('Z', '');\n    } else if (timeZoneOffset !== 0) {\n      s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n    } // otherwise, its UTC-0 and we want to keep the Z\n\n  }\n\n  return s;\n} // formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\n\n\nfunction formatDayString(marker) {\n  return marker.toISOString().replace(/T.*$/, '');\n} // TODO: use Date::toISOString and use everything after the T?\n\n\nfunction formatIsoTimeString(marker) {\n  return padStart(marker.getUTCHours(), 2) + ':' + padStart(marker.getUTCMinutes(), 2) + ':' + padStart(marker.getUTCSeconds(), 2);\n}\n\nfunction formatTimeZoneOffset(minutes, doIso) {\n  if (doIso === void 0) {\n    doIso = false;\n  }\n\n  var sign = minutes < 0 ? '-' : '+';\n  var abs = Math.abs(minutes);\n  var hours = Math.floor(abs / 60);\n  var mins = Math.round(abs % 60);\n\n  if (doIso) {\n    return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n  }\n\n  return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : '');\n} // TODO: new util arrayify?\n\n\nfunction removeExact(array, exactVal) {\n  var removeCnt = 0;\n  var i = 0;\n\n  while (i < array.length) {\n    if (array[i] === exactVal) {\n      array.splice(i, 1);\n      removeCnt += 1;\n    } else {\n      i += 1;\n    }\n  }\n\n  return removeCnt;\n}\n\nfunction isArraysEqual(a0, a1, equalityFunc) {\n  if (a0 === a1) {\n    return true;\n  }\n\n  var len = a0.length;\n  var i;\n\n  if (len !== a1.length) {\n    // not array? or not same length?\n    return false;\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n  var currentArgs;\n  var currentRes;\n  return function () {\n    var newArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      newArgs[_i] = arguments[_i];\n    }\n\n    if (!currentArgs) {\n      currentRes = workerFunc.apply(this, newArgs);\n    } else if (!isArraysEqual(currentArgs, newArgs)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.apply(this, newArgs);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArgs = newArgs;\n    return currentRes;\n  };\n}\n\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArg;\n  var currentRes;\n  return function (newArg) {\n    if (!currentArg) {\n      currentRes = workerFunc.call(_this, newArg);\n    } else if (!isPropsEqual(currentArg, newArg)) {\n      if (teardownFunc) {\n        teardownFunc(currentRes);\n      }\n\n      var res = workerFunc.call(_this, newArg);\n\n      if (!resEquality || !resEquality(res, currentRes)) {\n        currentRes = res;\n      }\n    }\n\n    currentArg = newArg;\n    return currentRes;\n  };\n}\n\nfunction memoizeArraylike( // used at all?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgSets = [];\n  var currentResults = [];\n  return function (newArgSets) {\n    var currentLen = currentArgSets.length;\n    var newLen = newArgSets.length;\n    var i = 0;\n\n    for (; i < currentLen; i += 1) {\n      if (!newArgSets[i]) {\n        // one of the old sets no longer exists\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n      } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n        if (teardownFunc) {\n          teardownFunc(currentResults[i]);\n        }\n\n        var res = workerFunc.apply(_this, newArgSets[i]);\n\n        if (!resEquality || !resEquality(res, currentResults[i])) {\n          currentResults[i] = res;\n        }\n      }\n    }\n\n    for (; i < newLen; i += 1) {\n      currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n    }\n\n    currentArgSets = newArgSets;\n    currentResults.splice(newLen); // remove excess\n\n    return currentResults;\n  };\n}\n\nfunction memoizeHashlike( // used?\nworkerFunc, resEquality, teardownFunc) {\n  var _this = this;\n\n  var currentArgHash = {};\n  var currentResHash = {};\n  return function (newArgHash) {\n    var newResHash = {};\n\n    for (var key in newArgHash) {\n      if (!currentResHash[key]) {\n        newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n      } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n        if (teardownFunc) {\n          teardownFunc(currentResHash[key]);\n        }\n\n        var res = workerFunc.apply(_this, newArgHash[key]);\n        newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n      } else {\n        newResHash[key] = currentResHash[key];\n      }\n    }\n\n    currentArgHash = newArgHash;\n    currentResHash = newResHash;\n    return newResHash;\n  };\n}\n\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n  week: 3,\n  separator: 0,\n  omitZeroMinute: 0,\n  meridiem: 0,\n  omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n  timeZoneName: 7,\n  era: 6,\n  year: 5,\n  month: 4,\n  day: 2,\n  weekday: 2,\n  hour: 1,\n  minute: 1,\n  second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n\nvar COMMA_RE = /,/g; // we need re for globalness\n\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\n\nvar UTC_RE = /UTC|GMT/;\n\nvar NativeFormatter = function () {\n  function NativeFormatter(formatSettings) {\n    var standardDateProps = {};\n    var extendedSettings = {};\n    var severity = 0;\n\n    for (var name_1 in formatSettings) {\n      if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n        extendedSettings[name_1] = formatSettings[name_1];\n        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n      } else {\n        standardDateProps[name_1] = formatSettings[name_1];\n\n        if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n          // TODO: what about hour12? no severity\n          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n        }\n      }\n    }\n\n    this.standardDateProps = standardDateProps;\n    this.extendedSettings = extendedSettings;\n    this.severity = severity;\n    this.buildFormattingFunc = memoize(buildFormattingFunc);\n  }\n\n  NativeFormatter.prototype.format = function (date, context) {\n    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n  };\n\n  NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    var _a = this,\n        standardDateProps = _a.standardDateProps,\n        extendedSettings = _a.extendedSettings;\n\n    var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n\n    if (!diffSeverity) {\n      return this.format(start, context);\n    }\n\n    var biggestUnitForPartial = diffSeverity;\n\n    if (biggestUnitForPartial > 1 && (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') && (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') && (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n      biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n    }\n\n    var full0 = this.format(start, context);\n    var full1 = this.format(end, context);\n\n    if (full0 === full1) {\n      return full0;\n    }\n\n    var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n    var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n    var partial0 = partialFormattingFunc(start);\n    var partial1 = partialFormattingFunc(end);\n    var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n    var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n\n    if (insertion) {\n      return insertion.before + partial0 + separator + partial1 + insertion.after;\n    }\n\n    return full0 + separator + full1;\n  };\n\n  NativeFormatter.prototype.getLargestUnit = function () {\n    switch (this.severity) {\n      case 7:\n      case 6:\n      case 5:\n        return 'year';\n\n      case 4:\n        return 'month';\n\n      case 3:\n        return 'week';\n\n      case 2:\n        return 'day';\n\n      default:\n        return 'time';\n      // really?\n    }\n  };\n\n  return NativeFormatter;\n}();\n\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n  var standardDatePropCnt = Object.keys(standardDateProps).length;\n\n  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n    return function (date) {\n      return formatTimeZoneOffset(date.timeZoneOffset);\n    };\n  }\n\n  if (standardDatePropCnt === 0 && extendedSettings.week) {\n    return function (date) {\n      return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.locale, extendedSettings.week);\n    };\n  }\n\n  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\n\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n  standardDateProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, standardDateProps); // copy\n\n  extendedSettings = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, extendedSettings); // copy\n\n  sanitizeSettings(standardDateProps, extendedSettings);\n  standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n\n  var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n  var zeroFormat; // needed?\n\n  if (extendedSettings.omitZeroMinute) {\n    var zeroProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, standardDateProps);\n\n    delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n\n    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n  }\n\n  return function (date) {\n    var marker = date.marker;\n    var format;\n\n    if (zeroFormat && !marker.getUTCMinutes()) {\n      format = zeroFormat;\n    } else {\n      format = normalFormat;\n    }\n\n    var s = format.format(marker);\n    return postProcess(s, date, standardDateProps, extendedSettings, context);\n  };\n}\n\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n  // deal with a browser inconsistency where formatting the timezone\n  // requires that the hour/minute be present.\n  if (standardDateProps.timeZoneName) {\n    if (!standardDateProps.hour) {\n      standardDateProps.hour = '2-digit';\n    }\n\n    if (!standardDateProps.minute) {\n      standardDateProps.minute = '2-digit';\n    }\n  } // only support short timezone names\n\n\n  if (standardDateProps.timeZoneName === 'long') {\n    standardDateProps.timeZoneName = 'short';\n  } // if requesting to display seconds, MUST display minutes\n\n\n  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n    delete extendedSettings.omitZeroMinute;\n  }\n}\n\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n  s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n\n  if (standardDateProps.timeZoneName === 'short') {\n    s = injectTzoStr(s, context.timeZone === 'UTC' || date.timeZoneOffset == null ? 'UTC' : // important to normalize for IE, which does \"GMT\"\n    formatTimeZoneOffset(date.timeZoneOffset));\n  }\n\n  if (extendedSettings.omitCommas) {\n    s = s.replace(COMMA_RE, '').trim();\n  }\n\n  if (extendedSettings.omitZeroMinute) {\n    s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n  } // ^ do anything that might create adjacent spaces before this point,\n  // because MERIDIEM_RE likes to eat up loading spaces\n\n\n  if (extendedSettings.meridiem === false) {\n    s = s.replace(MERIDIEM_RE, '').trim();\n  } else if (extendedSettings.meridiem === 'narrow') {\n    // a/p\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase();\n    });\n  } else if (extendedSettings.meridiem === 'short') {\n    // am/pm\n    s = s.replace(MERIDIEM_RE, function (m0, m1) {\n      return m1.toLocaleLowerCase() + \"m\";\n    });\n  } else if (extendedSettings.meridiem === 'lowercase') {\n    // other meridiem transformers already converted to lowercase\n    s = s.replace(MERIDIEM_RE, function (m0) {\n      return m0.toLocaleLowerCase();\n    });\n  }\n\n  s = s.replace(MULTI_SPACE_RE, ' ');\n  s = s.trim();\n  return s;\n}\n\nfunction injectTzoStr(s, tzoStr) {\n  var replaced = false;\n  s = s.replace(UTC_RE, function () {\n    replaced = true;\n    return tzoStr;\n  }); // IE11 doesn't include UTC/GMT in the original string, so append to end\n\n  if (!replaced) {\n    s += \" \" + tzoStr;\n  }\n\n  return s;\n}\n\nfunction formatWeekNumber(num, weekText, locale, display) {\n  var parts = [];\n\n  if (display === 'narrow') {\n    parts.push(weekText);\n  } else if (display === 'short') {\n    parts.push(weekText, ' ');\n  } // otherwise, considered 'numeric'\n\n\n  parts.push(locale.simpleNumberFormat.format(num));\n\n  if (locale.options.direction === 'rtl') {\n    // TODO: use control characters instead?\n    parts.reverse();\n  }\n\n  return parts.join('');\n} // Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\n\n\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n    return 5;\n  }\n\n  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n    return 4;\n  }\n\n  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n    return 2;\n  }\n\n  if (timeAsMs(d0) !== timeAsMs(d1)) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction computePartialFormattingOptions(options, biggestUnit) {\n  var partialOptions = {};\n\n  for (var name_2 in options) {\n    if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n    STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n      partialOptions[name_2] = options[name_2];\n    }\n  }\n\n  return partialOptions;\n}\n\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n  var i0 = 0;\n\n  while (i0 < full0.length) {\n    var found0 = full0.indexOf(partial0, i0);\n\n    if (found0 === -1) {\n      break;\n    }\n\n    var before0 = full0.substr(0, found0);\n    i0 = found0 + partial0.length;\n    var after0 = full0.substr(i0);\n    var i1 = 0;\n\n    while (i1 < full1.length) {\n      var found1 = full1.indexOf(partial1, i1);\n\n      if (found1 === -1) {\n        break;\n      }\n\n      var before1 = full1.substr(0, found1);\n      i1 = found1 + partial1.length;\n      var after1 = full1.substr(i1);\n\n      if (before0 === before1 && after0 === after1) {\n        return {\n          before: before0,\n          after: after0\n        };\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n  var a = calendarSystem.markerToArray(dateInfo.marker);\n  return {\n    marker: dateInfo.marker,\n    timeZoneOffset: dateInfo.timeZoneOffset,\n    array: a,\n    year: a[0],\n    month: a[1],\n    day: a[2],\n    hour: a[3],\n    minute: a[4],\n    second: a[5],\n    millisecond: a[6]\n  };\n}\n\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n  var startInfo = expandZonedMarker(start, context.calendarSystem);\n  var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n  return {\n    date: startInfo,\n    start: startInfo,\n    end: endInfo,\n    timeZone: context.timeZone,\n    localeCodes: context.locale.codes,\n    defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n  };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/\n\n/*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/\n\n\nvar CmdFormatter = function () {\n  function CmdFormatter(cmdStr) {\n    this.cmdStr = cmdStr;\n  }\n\n  CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return CmdFormatter;\n}();\n\nvar FuncFormatter = function () {\n  function FuncFormatter(func) {\n    this.func = func;\n  }\n\n  FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n  };\n\n  FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n  };\n\n  return FuncFormatter;\n}();\n\nfunction createFormatter(input) {\n  if (_typeof(input) === 'object' && input) {\n    // non-null object\n    return new NativeFormatter(input);\n  }\n\n  if (typeof input === 'string') {\n    return new CmdFormatter(input);\n  }\n\n  if (typeof input === 'function') {\n    return new FuncFormatter(input);\n  }\n\n  return null;\n} // base options\n// ------------\n\n\nvar BASE_OPTION_REFINERS = {\n  navLinkDayClick: identity,\n  navLinkWeekClick: identity,\n  duration: createDuration,\n  bootstrapFontAwesome: identity,\n  buttonIcons: identity,\n  customButtons: identity,\n  defaultAllDayEventDuration: createDuration,\n  defaultTimedEventDuration: createDuration,\n  nextDayThreshold: createDuration,\n  scrollTime: createDuration,\n  scrollTimeReset: Boolean,\n  slotMinTime: createDuration,\n  slotMaxTime: createDuration,\n  dayPopoverFormat: createFormatter,\n  slotDuration: createDuration,\n  snapDuration: createDuration,\n  headerToolbar: identity,\n  footerToolbar: identity,\n  defaultRangeSeparator: String,\n  titleRangeSeparator: String,\n  forceEventDuration: Boolean,\n  dayHeaders: Boolean,\n  dayHeaderFormat: createFormatter,\n  dayHeaderClassNames: identity,\n  dayHeaderContent: identity,\n  dayHeaderDidMount: identity,\n  dayHeaderWillUnmount: identity,\n  dayCellClassNames: identity,\n  dayCellContent: identity,\n  dayCellDidMount: identity,\n  dayCellWillUnmount: identity,\n  initialView: String,\n  aspectRatio: Number,\n  weekends: Boolean,\n  weekNumberCalculation: identity,\n  weekNumbers: Boolean,\n  weekNumberClassNames: identity,\n  weekNumberContent: identity,\n  weekNumberDidMount: identity,\n  weekNumberWillUnmount: identity,\n  editable: Boolean,\n  viewClassNames: identity,\n  viewDidMount: identity,\n  viewWillUnmount: identity,\n  nowIndicator: Boolean,\n  nowIndicatorClassNames: identity,\n  nowIndicatorContent: identity,\n  nowIndicatorDidMount: identity,\n  nowIndicatorWillUnmount: identity,\n  showNonCurrentDates: Boolean,\n  lazyFetching: Boolean,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String,\n  timeZone: String,\n  locales: identity,\n  locale: identity,\n  themeSystem: String,\n  dragRevertDuration: Number,\n  dragScroll: Boolean,\n  allDayMaintainDuration: Boolean,\n  unselectAuto: Boolean,\n  dropAccept: identity,\n  eventOrder: parseFieldSpecs,\n  eventOrderStrict: Boolean,\n  handleWindowResize: Boolean,\n  windowResizeDelay: Number,\n  longPressDelay: Number,\n  eventDragMinDistance: Number,\n  expandRows: Boolean,\n  height: identity,\n  contentHeight: identity,\n  direction: String,\n  weekNumberFormat: createFormatter,\n  eventResizableFromStart: Boolean,\n  displayEventTime: Boolean,\n  displayEventEnd: Boolean,\n  weekText: String,\n  progressiveEventRendering: Boolean,\n  businessHours: identity,\n  initialDate: identity,\n  now: identity,\n  eventDataTransform: identity,\n  stickyHeaderDates: identity,\n  stickyFooterScrollbar: identity,\n  viewHeight: identity,\n  defaultAllDay: Boolean,\n  eventSourceFailure: identity,\n  eventSourceSuccess: identity,\n  eventDisplay: String,\n  eventStartEditable: Boolean,\n  eventDurationEditable: Boolean,\n  eventOverlap: identity,\n  eventConstraint: identity,\n  eventAllow: identity,\n  eventBackgroundColor: String,\n  eventBorderColor: String,\n  eventTextColor: String,\n  eventColor: String,\n  eventClassNames: identity,\n  eventContent: identity,\n  eventDidMount: identity,\n  eventWillUnmount: identity,\n  selectConstraint: identity,\n  selectOverlap: identity,\n  selectAllow: identity,\n  droppable: Boolean,\n  unselectCancel: String,\n  slotLabelFormat: identity,\n  slotLaneClassNames: identity,\n  slotLaneContent: identity,\n  slotLaneDidMount: identity,\n  slotLaneWillUnmount: identity,\n  slotLabelClassNames: identity,\n  slotLabelContent: identity,\n  slotLabelDidMount: identity,\n  slotLabelWillUnmount: identity,\n  dayMaxEvents: identity,\n  dayMaxEventRows: identity,\n  dayMinWidth: Number,\n  slotLabelInterval: createDuration,\n  allDayText: String,\n  allDayClassNames: identity,\n  allDayContent: identity,\n  allDayDidMount: identity,\n  allDayWillUnmount: identity,\n  slotMinWidth: Number,\n  navLinks: Boolean,\n  eventTimeFormat: createFormatter,\n  rerenderDelay: Number,\n  moreLinkText: identity,\n  selectMinDistance: Number,\n  selectable: Boolean,\n  selectLongPressDelay: Number,\n  eventLongPressDelay: Number,\n  selectMirror: Boolean,\n  eventMaxStack: Number,\n  eventMinHeight: Number,\n  eventMinWidth: Number,\n  eventShortHeight: Number,\n  slotEventOverlap: Boolean,\n  plugins: identity,\n  firstDay: Number,\n  dayCount: Number,\n  dateAlignment: String,\n  dateIncrement: createDuration,\n  hiddenDays: identity,\n  monthMode: Boolean,\n  fixedWeekCount: Boolean,\n  validRange: identity,\n  visibleRange: identity,\n  titleFormat: identity,\n  // only used by list-view, but languages define the value, so we need it in base options\n  noEventsText: String,\n  moreLinkClick: identity,\n  moreLinkClassNames: identity,\n  moreLinkContent: identity,\n  moreLinkDidMount: identity,\n  moreLinkWillUnmount: identity\n}; // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\n\nvar BASE_OPTION_DEFAULTS = {\n  eventDisplay: 'auto',\n  defaultRangeSeparator: ' - ',\n  titleRangeSeparator: \" \\u2013 \",\n  defaultTimedEventDuration: '01:00:00',\n  defaultAllDayEventDuration: {\n    day: 1\n  },\n  forceEventDuration: false,\n  nextDayThreshold: '00:00:00',\n  dayHeaders: true,\n  initialView: '',\n  aspectRatio: 1.35,\n  headerToolbar: {\n    start: 'title',\n    center: '',\n    end: 'today prev,next'\n  },\n  weekends: true,\n  weekNumbers: false,\n  weekNumberCalculation: 'local',\n  editable: false,\n  nowIndicator: false,\n  scrollTime: '06:00:00',\n  scrollTimeReset: true,\n  slotMinTime: '00:00:00',\n  slotMaxTime: '24:00:00',\n  showNonCurrentDates: true,\n  lazyFetching: true,\n  startParam: 'start',\n  endParam: 'end',\n  timeZoneParam: 'timeZone',\n  timeZone: 'local',\n  locales: [],\n  locale: '',\n  themeSystem: 'standard',\n  dragRevertDuration: 500,\n  dragScroll: true,\n  allDayMaintainDuration: false,\n  unselectAuto: true,\n  dropAccept: '*',\n  eventOrder: 'start,-duration,allDay,title',\n  dayPopoverFormat: {\n    month: 'long',\n    day: 'numeric',\n    year: 'numeric'\n  },\n  handleWindowResize: true,\n  windowResizeDelay: 100,\n  longPressDelay: 1000,\n  eventDragMinDistance: 5,\n  expandRows: false,\n  navLinks: false,\n  selectable: false,\n  eventMinHeight: 15,\n  eventMinWidth: 30,\n  eventShortHeight: 30\n}; // calendar listeners\n// ------------------\n\nvar CALENDAR_LISTENER_REFINERS = {\n  datesSet: identity,\n  eventsSet: identity,\n  eventAdd: identity,\n  eventChange: identity,\n  eventRemove: identity,\n  windowResize: identity,\n  eventClick: identity,\n  eventMouseEnter: identity,\n  eventMouseLeave: identity,\n  select: identity,\n  unselect: identity,\n  loading: identity,\n  // internal\n  _unmount: identity,\n  _beforeprint: identity,\n  _afterprint: identity,\n  _noEventDrop: identity,\n  _noEventResize: identity,\n  _resize: identity,\n  _scrollRequest: identity\n}; // calendar-specific options\n// -------------------------\n\nvar CALENDAR_OPTION_REFINERS = {\n  buttonText: identity,\n  views: identity,\n  plugins: identity,\n  initialEvents: identity,\n  events: identity,\n  eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n  headerToolbar: isBoolComplexEqual,\n  footerToolbar: isBoolComplexEqual,\n  buttonText: isBoolComplexEqual,\n  buttonIcons: isBoolComplexEqual\n};\n\nfunction isBoolComplexEqual(a, b) {\n  if (_typeof(a) === 'object' && _typeof(b) === 'object' && a && b) {\n    // both non-null objects\n    return isPropsEqual(a, b);\n  }\n\n  return a === b;\n} // view-specific options\n// ---------------------\n\n\nvar VIEW_OPTION_REFINERS = {\n  type: String,\n  component: identity,\n  buttonText: String,\n  buttonTextKey: String,\n  dateProfileGeneratorClass: identity,\n  usesMinMaxTime: Boolean,\n  classNames: identity,\n  content: identity,\n  didMount: identity,\n  willUnmount: identity\n}; // util funcs\n// ----------------------------------------------------------------------------------------------------\n\nfunction mergeRawOptions(optionSets) {\n  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\n\nfunction refineProps(input, refiners) {\n  var refined = {};\n  var extra = {};\n\n  for (var propName in refiners) {\n    if (propName in input) {\n      refined[propName] = refiners[propName](input[propName]);\n    }\n  }\n\n  for (var propName in input) {\n    if (!(propName in refiners)) {\n      extra[propName] = input[propName];\n    }\n  }\n\n  return {\n    refined: refined,\n    extra: extra\n  };\n}\n\nfunction identity(raw) {\n  return raw;\n}\n\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n  var eventStore = createEmptyEventStore();\n  var eventRefiners = buildEventRefiners(context);\n\n  for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n    var rawEvent = rawEvents_1[_i];\n    var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n\n    if (tuple) {\n      eventTupleToStore(tuple, eventStore);\n    }\n  }\n\n  return eventStore;\n}\n\nfunction eventTupleToStore(tuple, eventStore) {\n  if (eventStore === void 0) {\n    eventStore = createEmptyEventStore();\n  }\n\n  eventStore.defs[tuple.def.defId] = tuple.def;\n\n  if (tuple.instance) {\n    eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n  }\n\n  return eventStore;\n} // retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\n\n\nfunction getRelevantEvents(eventStore, instanceId) {\n  var instance = eventStore.instances[instanceId];\n\n  if (instance) {\n    var def_1 = eventStore.defs[instance.defId]; // get events/instances with same group\n\n    var newStore = filterEventStoreDefs(eventStore, function (lookDef) {\n      return isEventDefsGrouped(def_1, lookDef);\n    }); // add the original\n    // TODO: wish we could use eventTupleToStore or something like it\n\n    newStore.defs[def_1.defId] = def_1;\n    newStore.instances[instance.instanceId] = instance;\n    return newStore;\n  }\n\n  return createEmptyEventStore();\n}\n\nfunction isEventDefsGrouped(def0, def1) {\n  return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\n\nfunction createEmptyEventStore() {\n  return {\n    defs: {},\n    instances: {}\n  };\n}\n\nfunction mergeEventStores(store0, store1) {\n  return {\n    defs: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, store0.defs), store1.defs),\n    instances: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, store0.instances), store1.instances)\n  };\n}\n\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n  var defs = filterHash(eventStore.defs, filterFunc);\n  var instances = filterHash(eventStore.instances, function (instance) {\n    return defs[instance.defId] // still exists?\n    ;\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeSubEventStore(master, sub) {\n  var defs = master.defs,\n      instances = master.instances;\n  var filteredDefs = {};\n  var filteredInstances = {};\n\n  for (var defId in defs) {\n    if (!sub.defs[defId]) {\n      // not explicitly excluded\n      filteredDefs[defId] = defs[defId];\n    }\n  }\n\n  for (var instanceId in instances) {\n    if (!sub.instances[instanceId] && // not explicitly excluded\n    filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n    ) {\n      filteredInstances[instanceId] = instances[instanceId];\n    }\n  }\n\n  return {\n    defs: filteredDefs,\n    instances: filteredInstances\n  };\n}\n\nfunction normalizeConstraint(input, context) {\n  if (Array.isArray(input)) {\n    return parseEvents(input, null, context, true); // allowOpenRange=true\n  }\n\n  if (_typeof(input) === 'object' && input) {\n    // non-null object\n    return parseEvents([input], null, context, true); // allowOpenRange=true\n  }\n\n  if (input != null) {\n    return String(input);\n  }\n\n  return null;\n}\n\nfunction parseClassNames(raw) {\n  if (Array.isArray(raw)) {\n    return raw;\n  }\n\n  if (typeof raw === 'string') {\n    return raw.split(/\\s+/);\n  }\n\n  return [];\n} // TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n\n\nvar EVENT_UI_REFINERS = {\n  display: String,\n  editable: Boolean,\n  startEditable: Boolean,\n  durationEditable: Boolean,\n  constraint: identity,\n  overlap: identity,\n  allow: identity,\n  className: parseClassNames,\n  classNames: parseClassNames,\n  color: String,\n  backgroundColor: String,\n  borderColor: String,\n  textColor: String\n};\nvar EMPTY_EVENT_UI = {\n  display: null,\n  startEditable: null,\n  durationEditable: null,\n  constraints: [],\n  overlap: null,\n  allows: [],\n  backgroundColor: '',\n  borderColor: '',\n  textColor: '',\n  classNames: []\n};\n\nfunction createEventUi(refined, context) {\n  var constraint = normalizeConstraint(refined.constraint, context);\n  return {\n    display: refined.display || null,\n    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n    constraints: constraint != null ? [constraint] : [],\n    overlap: refined.overlap != null ? refined.overlap : null,\n    allows: refined.allow != null ? [refined.allow] : [],\n    backgroundColor: refined.backgroundColor || refined.color || '',\n    borderColor: refined.borderColor || refined.color || '',\n    textColor: refined.textColor || '',\n    classNames: (refined.className || []).concat(refined.classNames || []) // join singular and plural\n\n  };\n} // TODO: prevent against problems with <2 args!\n\n\nfunction combineEventUis(uis) {\n  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\n\nfunction combineTwoEventUis(item0, item1) {\n  return {\n    display: item1.display != null ? item1.display : item0.display,\n    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n    constraints: item0.constraints.concat(item1.constraints),\n    overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n    allows: item0.allows.concat(item1.allows),\n    backgroundColor: item1.backgroundColor || item0.backgroundColor,\n    borderColor: item1.borderColor || item0.borderColor,\n    textColor: item1.textColor || item0.textColor,\n    classNames: item0.classNames.concat(item1.classNames)\n  };\n}\n\nvar EVENT_NON_DATE_REFINERS = {\n  id: String,\n  groupId: String,\n  title: String,\n  url: String\n};\nvar EVENT_DATE_REFINERS = {\n  start: identity,\n  end: identity,\n  date: identity,\n  allDay: Boolean\n};\n\nvar EVENT_REFINERS = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n  extendedProps: identity\n});\n\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  var _a = refineEventDef(raw, context, refiners),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n  var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n\n  if (recurringRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);\n    def.recurringDef = {\n      typeId: recurringRes.typeId,\n      typeData: recurringRes.typeData,\n      duration: recurringRes.duration\n    };\n    return {\n      def: def,\n      instance: null\n    };\n  }\n\n  var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n\n  if (singleRes) {\n    var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);\n    var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n    return {\n      def: def,\n      instance: instance\n    };\n  }\n\n  return null;\n}\n\nfunction refineEventDef(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventRefiners(context);\n  }\n\n  return refineProps(raw, refiners);\n}\n\nfunction buildEventRefiners(context) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/\n\n\nfunction parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n  var def = {\n    title: refined.title || '',\n    groupId: refined.groupId || '',\n    publicId: refined.id || '',\n    url: refined.url || '',\n    recurringDef: null,\n    defId: guid(),\n    sourceId: sourceId,\n    allDay: allDay,\n    hasEnd: hasEnd,\n    ui: createEventUi(refined, context),\n    extendedProps: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, refined.extendedProps || {}), extra)\n  };\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {\n    var memberAdder = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(def, memberAdder(refined));\n  } // help out EventApi from having user modify props\n\n\n  Object.freeze(def.ui.classNames);\n  Object.freeze(def.extendedProps);\n  return def;\n}\n\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n  var allDay = refined.allDay;\n  var startMeta;\n  var startMarker = null;\n  var hasEnd = false;\n  var endMeta;\n  var endMarker = null;\n  var startInput = refined.start != null ? refined.start : refined.date;\n  startMeta = context.dateEnv.createMarkerMeta(startInput);\n\n  if (startMeta) {\n    startMarker = startMeta.marker;\n  } else if (!allowOpenRange) {\n    return null;\n  }\n\n  if (refined.end != null) {\n    endMeta = context.dateEnv.createMarkerMeta(refined.end);\n  }\n\n  if (allDay == null) {\n    if (defaultAllDay != null) {\n      allDay = defaultAllDay;\n    } else {\n      // fall back to the date props LAST\n      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n    }\n  }\n\n  if (allDay && startMarker) {\n    startMarker = startOfDay(startMarker);\n  }\n\n  if (endMeta) {\n    endMarker = endMeta.marker;\n\n    if (allDay) {\n      endMarker = startOfDay(endMarker);\n    }\n\n    if (startMarker && endMarker <= startMarker) {\n      endMarker = null;\n    }\n  }\n\n  if (endMarker) {\n    hasEnd = true;\n  } else if (!allowOpenRange) {\n    hasEnd = context.options.forceEventDuration || false;\n    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n  }\n\n  return {\n    allDay: allDay,\n    hasEnd: hasEnd,\n    range: {\n      start: startMarker,\n      end: endMarker\n    },\n    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n    forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n  };\n}\n\nfunction computeIsDefaultAllDay(eventSource, context) {\n  var res = null;\n\n  if (eventSource) {\n    res = eventSource.defaultAllDay;\n  }\n\n  if (res == null) {\n    res = context.options.defaultAllDay;\n  }\n\n  return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/\n// given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\n\n\nfunction computeAlignedDayRange(timedRange) {\n  var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n  var start = startOfDay(timedRange.start);\n  var end = addDays(start, dayCnt);\n  return {\n    start: start,\n    end: end\n  };\n} // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\n\n\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n  if (nextDayThreshold === void 0) {\n    nextDayThreshold = createDuration(0);\n  }\n\n  var startDay = null;\n  var endDay = null;\n\n  if (timedRange.end) {\n    endDay = startOfDay(timedRange.end);\n    var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n    // If the end time is actually inclusively part of the next day and is equal to or\n    // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n    // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n\n    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n      endDay = addDays(endDay, 1);\n    }\n  }\n\n  if (timedRange.start) {\n    startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n    // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n\n    if (endDay && endDay <= startDay) {\n      endDay = addDays(startDay, 1);\n    }\n  }\n\n  return {\n    start: startDay,\n    end: endDay\n  };\n} // spans from one day into another?\n\n\nfunction isMultiDayRange(range) {\n  var visibleRange = computeVisibleDayRange(range);\n  return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\n\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n  if (largeUnit === 'year') {\n    return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n  }\n\n  if (largeUnit === 'month') {\n    return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n  }\n\n  return diffDayAndTime(date0, date1); // returns a duration\n}\n\nfunction parseRange(input, dateEnv) {\n  var start = null;\n  var end = null;\n\n  if (input.start) {\n    start = dateEnv.createMarker(input.start);\n  }\n\n  if (input.end) {\n    end = dateEnv.createMarker(input.end);\n  }\n\n  if (!start && !end) {\n    return null;\n  }\n\n  if (start && end && end < start) {\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n} // SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\n\n\nfunction invertRanges(ranges, constraintRange) {\n  var invertedRanges = [];\n  var start = constraintRange.start; // the end of the previous range. the start of the new range\n\n  var i;\n  var dateRange; // ranges need to be in order. required for our date-walking algorithm\n\n  ranges.sort(compareRanges);\n\n  for (i = 0; i < ranges.length; i += 1) {\n    dateRange = ranges[i]; // add the span of time before the event (if there is any)\n\n    if (dateRange.start > start) {\n      // compare millisecond time (skip any ambig logic)\n      invertedRanges.push({\n        start: start,\n        end: dateRange.start\n      });\n    }\n\n    if (dateRange.end > start) {\n      start = dateRange.end;\n    }\n  } // add the span of time after the last event (if there is any)\n\n\n  if (start < constraintRange.end) {\n    // compare millisecond time (skip any ambig logic)\n    invertedRanges.push({\n      start: start,\n      end: constraintRange.end\n    });\n  }\n\n  return invertedRanges;\n}\n\nfunction compareRanges(range0, range1) {\n  return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\n\nfunction intersectRanges(range0, range1) {\n  var start = range0.start,\n      end = range0.end;\n  var newRange = null;\n\n  if (range1.start !== null) {\n    if (start === null) {\n      start = range1.start;\n    } else {\n      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n    }\n  }\n\n  if (range1.end != null) {\n    if (end === null) {\n      end = range1.end;\n    } else {\n      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n    }\n  }\n\n  if (start === null || end === null || start < end) {\n    newRange = {\n      start: start,\n      end: end\n    };\n  }\n\n  return newRange;\n}\n\nfunction rangesEqual(range0, range1) {\n  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\n\nfunction rangesIntersect(range0, range1) {\n  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\n\nfunction rangeContainsRange(outerRange, innerRange) {\n  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\n\nfunction rangeContainsMarker(range, date) {\n  return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n} // If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\n\n\nfunction constrainMarkerToRange(date, range) {\n  if (range.start != null && date < range.start) {\n    return range.start;\n  }\n\n  if (range.end != null && date >= range.end) {\n    return new Date(range.end.valueOf() - 1);\n  }\n\n  return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/\n\n\nfunction sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n  var inverseBgByGroupId = {};\n  var inverseBgByDefId = {};\n  var defByGroupId = {};\n  var bgRanges = [];\n  var fgRanges = [];\n  var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    var ui = eventUis[def.defId];\n\n    if (ui.display === 'inverse-background') {\n      if (def.groupId) {\n        inverseBgByGroupId[def.groupId] = [];\n\n        if (!defByGroupId[def.groupId]) {\n          defByGroupId[def.groupId] = def;\n        }\n      } else {\n        inverseBgByDefId[defId] = [];\n      }\n    }\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = eventStore.defs[instance.defId];\n    var ui = eventUis[def.defId];\n    var origRange = instance.range;\n    var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n    var slicedRange = intersectRanges(normalRange, framingRange);\n\n    if (slicedRange) {\n      if (ui.display === 'inverse-background') {\n        if (def.groupId) {\n          inverseBgByGroupId[def.groupId].push(slicedRange);\n        } else {\n          inverseBgByDefId[instance.defId].push(slicedRange);\n        }\n      } else if (ui.display !== 'none') {\n        (ui.display === 'background' ? bgRanges : fgRanges).push({\n          def: def,\n          ui: ui,\n          instance: instance,\n          range: slicedRange,\n          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n        });\n      }\n    }\n  }\n\n  for (var groupId in inverseBgByGroupId) {\n    // BY GROUP\n    var ranges = inverseBgByGroupId[groupId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n      var invertedRange = invertedRanges_1[_i];\n      var def = defByGroupId[groupId];\n      var ui = eventUis[def.defId];\n      bgRanges.push({\n        def: def,\n        ui: ui,\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  for (var defId in inverseBgByDefId) {\n    var ranges = inverseBgByDefId[defId];\n    var invertedRanges = invertRanges(ranges, framingRange);\n\n    for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n      var invertedRange = invertedRanges_2[_a];\n      bgRanges.push({\n        def: eventStore.defs[defId],\n        ui: eventUis[defId],\n        instance: null,\n        range: invertedRange,\n        isStart: false,\n        isEnd: false\n      });\n    }\n  }\n\n  return {\n    bg: bgRanges,\n    fg: fgRanges\n  };\n}\n\nfunction hasBgRendering(def) {\n  return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n}\n\nfunction setElSeg(el, seg) {\n  el.fcSeg = seg;\n}\n\nfunction getElSeg(el) {\n  return el.fcSeg || el.parentNode.fcSeg || // for the harness\n  null;\n} // event ui computation\n\n\nfunction compileEventUis(eventDefs, eventUiBases) {\n  return mapHash(eventDefs, function (eventDef) {\n    return compileEventUi(eventDef, eventUiBases);\n  });\n}\n\nfunction compileEventUi(eventDef, eventUiBases) {\n  var uis = [];\n\n  if (eventUiBases['']) {\n    uis.push(eventUiBases['']);\n  }\n\n  if (eventUiBases[eventDef.defId]) {\n    uis.push(eventUiBases[eventDef.defId]);\n  }\n\n  uis.push(eventDef.ui);\n  return combineEventUis(uis);\n}\n\nfunction sortEventSegs(segs, eventOrderSpecs) {\n  var objs = segs.map(buildSegCompareObj);\n  objs.sort(function (obj0, obj1) {\n    return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n  });\n  return objs.map(function (c) {\n    return c._seg;\n  });\n} // returns a object with all primitive props that can be compared\n\n\nfunction buildSegCompareObj(seg) {\n  var eventRange = seg.eventRange;\n  var eventDef = eventRange.def;\n  var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n  var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n\n  var end = range.end ? range.end.valueOf() : 0; // \"\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef.extendedProps), eventDef), {\n    id: eventDef.publicId,\n    start: start,\n    end: end,\n    duration: end - start,\n    allDay: Number(eventDef.allDay),\n    _seg: seg\n  });\n}\n\nfunction computeSegDraggable(seg, context) {\n  var pluginHooks = context.pluginHooks;\n  var transformers = pluginHooks.isDraggableTransformers;\n  var _a = seg.eventRange,\n      def = _a.def,\n      ui = _a.ui;\n  var val = ui.startEditable;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n    val = transformer(val, def, ui, context);\n  }\n\n  return val;\n}\n\nfunction computeSegStartResizable(seg, context) {\n  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\n\nfunction computeSegEndResizable(seg, context) {\n  return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\n\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\ndefaultDisplayEventEnd, // defaults to true\nstartOverride, endOverride) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var displayEventTime = options.displayEventTime,\n      displayEventEnd = options.displayEventEnd;\n  var eventDef = seg.eventRange.def;\n  var eventInstance = seg.eventRange.instance;\n\n  if (displayEventTime == null) {\n    displayEventTime = defaultDisplayEventTime !== false;\n  }\n\n  if (displayEventEnd == null) {\n    displayEventEnd = defaultDisplayEventEnd !== false;\n  }\n\n  var wholeEventStart = eventInstance.range.start;\n  var wholeEventEnd = eventInstance.range.end;\n  var segStart = startOverride || seg.start || seg.eventRange.range.start;\n  var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n  var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n  var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n\n  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n    segStart = isStartDay ? wholeEventStart : segStart;\n    segEnd = isEndDay ? wholeEventEnd : segEnd;\n\n    if (displayEventEnd && eventDef.hasEnd) {\n      return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(segStart, timeFormat, {\n      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo // nooooo, same\n\n    });\n  }\n\n  return '';\n}\n\nfunction getSegMeta(seg, todayRange, nowDate) {\n  var segRange = seg.eventRange.range;\n  return {\n    isPast: segRange.end < (nowDate || todayRange.start),\n    isFuture: segRange.start >= (nowDate || todayRange.end),\n    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n  };\n}\n\nfunction getEventClassNames(props) {\n  var classNames = ['fc-event'];\n\n  if (props.isMirror) {\n    classNames.push('fc-event-mirror');\n  }\n\n  if (props.isDraggable) {\n    classNames.push('fc-event-draggable');\n  }\n\n  if (props.isStartResizable || props.isEndResizable) {\n    classNames.push('fc-event-resizable');\n  }\n\n  if (props.isDragging) {\n    classNames.push('fc-event-dragging');\n  }\n\n  if (props.isResizing) {\n    classNames.push('fc-event-resizing');\n  }\n\n  if (props.isSelected) {\n    classNames.push('fc-event-selected');\n  }\n\n  if (props.isStart) {\n    classNames.push('fc-event-start');\n  }\n\n  if (props.isEnd) {\n    classNames.push('fc-event-end');\n  }\n\n  if (props.isPast) {\n    classNames.push('fc-event-past');\n  }\n\n  if (props.isToday) {\n    classNames.push('fc-event-today');\n  }\n\n  if (props.isFuture) {\n    classNames.push('fc-event-future');\n  }\n\n  return classNames;\n}\n\nfunction buildEventRangeKey(eventRange) {\n  return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString(); // inverse-background events don't have specific instances. TODO: better solution\n}\n\nvar STANDARD_PROPS = {\n  start: identity,\n  end: identity,\n  allDay: Boolean\n};\n\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n  var span = parseOpenDateSpan(raw, dateEnv);\n  var range = span.range;\n\n  if (!range.start) {\n    return null;\n  }\n\n  if (!range.end) {\n    if (defaultDuration == null) {\n      return null;\n    }\n\n    range.end = dateEnv.add(range.start, defaultDuration);\n  }\n\n  return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/\n\n\nfunction parseOpenDateSpan(raw, dateEnv) {\n  var _a = refineProps(raw, STANDARD_PROPS),\n      standardProps = _a.refined,\n      extra = _a.extra;\n\n  var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n  var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n  var allDay = standardProps.allDay;\n\n  if (allDay == null) {\n    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n  }\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    range: {\n      start: startMeta ? startMeta.marker : null,\n      end: endMeta ? endMeta.marker : null\n    },\n    allDay: allDay\n  }, extra);\n}\n\nfunction isDateSpansEqual(span0, span1) {\n  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n} // the NON-DATE-RELATED props\n\n\nfunction isSpanPropsEqual(span0, span1) {\n  for (var propName in span1) {\n    if (propName !== 'range' && propName !== 'allDay') {\n      if (span0[propName] !== span1[propName]) {\n        return false;\n      }\n    }\n  } // are there any props that span0 has that span1 DOESN'T have?\n  // both have range/allDay, so no need to special-case.\n\n\n  for (var propName in span0) {\n    if (!(propName in span1)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction buildDateSpanApi(span, dateEnv) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n    allDay: span.allDay\n  });\n}\n\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApi(range, dateEnv, omitTime)), {\n    timeZone: dateEnv.timeZone\n  });\n}\n\nfunction buildRangeApi(range, dateEnv, omitTime) {\n  return {\n    start: dateEnv.toDate(range.start),\n    end: dateEnv.toDate(range.end),\n    startStr: dateEnv.formatIso(range.start, {\n      omitTime: omitTime\n    }),\n    endStr: dateEnv.formatIso(range.end, {\n      omitTime: omitTime\n    })\n  };\n}\n\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n  var res = refineEventDef({\n    editable: false\n  }, context);\n  var def = parseEventDef(res.refined, res.extra, '', // sourceId\n  dateSpan.allDay, true, // hasEnd\n  context);\n  return {\n    def: def,\n    ui: compileEventUi(def, eventUiBases),\n    instance: createEventInstance(def.defId, dateSpan.range),\n    range: dateSpan.range,\n    isStart: true,\n    isEnd: true\n  };\n}\n\nfunction triggerDateSelect(selection, pev, context) {\n  context.emitter.trigger('select', (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildDateSpanApiWithContext(selection, context)), {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  }));\n}\n\nfunction triggerDateUnselect(pev, context) {\n  context.emitter.trigger('unselect', {\n    jsEvent: pev ? pev.origEvent : null,\n    view: context.viewApi || context.calendarApi.view\n  });\n}\n\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(props, transform(dateSpan, context));\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(props, buildDateSpanApi(dateSpan, context.dateEnv));\n\n  return props;\n} // Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\n\n\nfunction getDefaultEventEnd(allDay, marker, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var end = marker;\n\n  if (allDay) {\n    end = startOfDay(end);\n    end = dateEnv.add(end, options.defaultAllDayEventDuration);\n  } else {\n    end = dateEnv.add(end, options.defaultTimedEventDuration);\n  }\n\n  return end;\n} // applies the mutation to ALL defs/instances within the event store\n\n\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n  var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n  var dest = createEmptyEventStore();\n\n  for (var defId in eventStore.defs) {\n    var def = eventStore.defs[defId];\n    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n  }\n\n  for (var instanceId in eventStore.instances) {\n    var instance = eventStore.instances[instanceId];\n    var def = dest.defs[instance.defId]; // important to grab the newly modified def\n\n    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n  }\n\n  return dest;\n}\n\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n  var standardProps = mutation.standardProps || {}; // if hasEnd has not been specified, guess a good value based on deltas.\n  // if duration will change, there's no way the default duration will persist,\n  // and thus, we need to mark the event as having a real end\n\n  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n    standardProps.hasEnd = true; // TODO: is this mutation okay?\n  }\n\n  var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef), standardProps), {\n    ui: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventDef.ui), standardProps.ui)\n  });\n\n  if (mutation.extendedProps) {\n    copy.extendedProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, copy.extendedProps), mutation.extendedProps);\n  }\n\n  for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {\n    var applier = _a[_i];\n    applier(copy, mutation, context);\n  }\n\n  if (!copy.hasEnd && context.options.forceEventDuration) {\n    copy.hasEnd = true;\n  }\n\n  return copy;\n}\n\nfunction applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\neventConfig, mutation, context) {\n  var dateEnv = context.dateEnv;\n  var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n  var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n\n  var copy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventInstance);\n\n  if (forceAllDay) {\n    copy.range = computeAlignedDayRange(copy.range);\n  }\n\n  if (mutation.datesDelta && eventConfig.startEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.datesDelta),\n      end: dateEnv.add(copy.range.end, mutation.datesDelta)\n    };\n  }\n\n  if (mutation.startDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: dateEnv.add(copy.range.start, mutation.startDelta),\n      end: copy.range.end\n    };\n  }\n\n  if (mutation.endDelta && eventConfig.durationEditable) {\n    copy.range = {\n      start: copy.range.start,\n      end: dateEnv.add(copy.range.end, mutation.endDelta)\n    };\n  }\n\n  if (clearEnd) {\n    copy.range = {\n      start: copy.range.start,\n      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n    };\n  } // in case event was all-day but the supplied deltas were not\n  // better util for this?\n\n\n  if (eventDef.allDay) {\n    copy.range = {\n      start: startOfDay(copy.range.start),\n      end: startOfDay(copy.range.end)\n    };\n  } // handle invalid durations\n\n\n  if (copy.range.end < copy.range.start) {\n    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n  }\n\n  return copy;\n} // no public types yet. when there are, export from:\n// import {} from './api-type-deps'\n\n\nvar ViewApi = function () {\n  function ViewApi(type, getCurrentData, dateEnv) {\n    this.type = type;\n    this.getCurrentData = getCurrentData;\n    this.dateEnv = dateEnv;\n  }\n\n  Object.defineProperty(ViewApi.prototype, \"calendar\", {\n    get: function get() {\n      return this.getCurrentData().calendarApi;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"title\", {\n    get: function get() {\n      return this.getCurrentData().viewTitle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n    get: function get() {\n      return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ViewApi.prototype.getOption = function (name) {\n    return this.getCurrentData().options[name]; // are the view-specific options\n  };\n\n  return ViewApi;\n}();\n\nvar EVENT_SOURCE_REFINERS = {\n  id: String,\n  defaultAllDay: Boolean,\n  url: String,\n  format: String,\n  events: identity,\n  eventDataTransform: identity,\n  // for any network-related sources\n  success: identity,\n  failure: identity\n};\n\nfunction parseEventSource(raw, context, refiners) {\n  if (refiners === void 0) {\n    refiners = buildEventSourceRefiners(context);\n  }\n\n  var rawObj;\n\n  if (typeof raw === 'string') {\n    rawObj = {\n      url: raw\n    };\n  } else if (typeof raw === 'function' || Array.isArray(raw)) {\n    rawObj = {\n      events: raw\n    };\n  } else if (_typeof(raw) === 'object' && raw) {\n    // not null\n    rawObj = raw;\n  }\n\n  if (rawObj) {\n    var _a = refineProps(rawObj, refiners),\n        refined = _a.refined,\n        extra = _a.extra;\n\n    var metaRes = buildEventSourceMeta(refined, context);\n\n    if (metaRes) {\n      return {\n        _raw: raw,\n        isFetching: false,\n        latestFetchId: '',\n        fetchRange: null,\n        defaultAllDay: refined.defaultAllDay,\n        eventDataTransform: refined.eventDataTransform,\n        success: refined.success,\n        failure: refined.failure,\n        publicId: refined.id || '',\n        sourceId: guid(),\n        sourceDefId: metaRes.sourceDefId,\n        meta: metaRes.meta,\n        ui: createEventUi(refined, context),\n        extendedProps: extra\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction buildEventSourceRefiners(context) {\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\n\nfunction buildEventSourceMeta(raw, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n\n  for (var i = defs.length - 1; i >= 0; i -= 1) {\n    // later-added plugins take precedence\n    var def = defs[i];\n    var meta = def.parseMeta(raw);\n\n    if (meta) {\n      return {\n        sourceDefId: i,\n        meta: meta\n      };\n    }\n  }\n\n  return null;\n}\n\nfunction reduceCurrentDate(currentDate, action) {\n  switch (action.type) {\n    case 'CHANGE_DATE':\n      return action.dateMarker;\n\n    default:\n      return currentDate;\n  }\n}\n\nfunction getInitialDate(options, dateEnv) {\n  var initialDateInput = options.initialDate; // compute the initial ambig-timezone date\n\n  if (initialDateInput != null) {\n    return dateEnv.createMarker(initialDateInput);\n  }\n\n  return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\n\nfunction getNow(nowInput, dateEnv) {\n  if (typeof nowInput === 'function') {\n    nowInput = nowInput();\n  }\n\n  if (nowInput == null) {\n    return dateEnv.createNowMarker();\n  }\n\n  return dateEnv.createMarker(nowInput);\n}\n\nvar CalendarApi = function () {\n  function CalendarApi() {}\n\n  CalendarApi.prototype.getCurrentData = function () {\n    return this.currentDataManager.getCurrentData();\n  };\n\n  CalendarApi.prototype.dispatch = function (action) {\n    return this.currentDataManager.dispatch(action);\n  };\n\n  Object.defineProperty(CalendarApi.prototype, \"view\", {\n    get: function get() {\n      return this.getCurrentData().viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  CalendarApi.prototype.batchRendering = function (callback) {\n    callback();\n  };\n\n  CalendarApi.prototype.updateSize = function () {\n    this.trigger('_resize', true);\n  }; // Options\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.setOption = function (name, val) {\n    this.dispatch({\n      type: 'SET_OPTION',\n      optionName: name,\n      rawOptionValue: val\n    });\n  };\n\n  CalendarApi.prototype.getOption = function (name) {\n    return this.currentDataManager.currentCalendarOptionsInput[name];\n  };\n\n  CalendarApi.prototype.getAvailableLocaleCodes = function () {\n    return Object.keys(this.getCurrentData().availableRawLocales);\n  }; // Trigger\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.on = function (handlerName, handler) {\n    var currentDataManager = this.currentDataManager;\n\n    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n      currentDataManager.emitter.on(handlerName, handler);\n    } else {\n      console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n    }\n  };\n\n  CalendarApi.prototype.off = function (handlerName, handler) {\n    this.currentDataManager.emitter.off(handlerName, handler);\n  }; // not meant for public use\n\n\n  CalendarApi.prototype.trigger = function (handlerName) {\n    var _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    (_a = this.currentDataManager.emitter).trigger.apply(_a, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([handlerName], args));\n  }; // View\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.changeView = function (viewType, dateOrRange) {\n    var _this = this;\n\n    this.batchRendering(function () {\n      _this.unselect();\n\n      if (dateOrRange) {\n        if (dateOrRange.start && dateOrRange.end) {\n          // a range\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType\n          });\n\n          _this.dispatch({\n            type: 'SET_OPTION',\n            optionName: 'visibleRange',\n            rawOptionValue: dateOrRange\n          });\n        } else {\n          var dateEnv = _this.getCurrentData().dateEnv;\n\n          _this.dispatch({\n            type: 'CHANGE_VIEW_TYPE',\n            viewType: viewType,\n            dateMarker: dateEnv.createMarker(dateOrRange)\n          });\n        }\n      } else {\n        _this.dispatch({\n          type: 'CHANGE_VIEW_TYPE',\n          viewType: viewType\n        });\n      }\n    });\n  }; // Forces navigation to a view for the given date.\n  // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n  // needs to change\n\n\n  CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {\n    var state = this.getCurrentData();\n    var spec;\n    viewType = viewType || 'day'; // day is default zoom\n\n    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n    this.unselect();\n\n    if (spec) {\n      this.dispatch({\n        type: 'CHANGE_VIEW_TYPE',\n        viewType: spec.type,\n        dateMarker: dateMarker\n      });\n    } else {\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: dateMarker\n      });\n    }\n  }; // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n  // Preference is given to views that have corresponding buttons.\n\n\n  CalendarApi.prototype.getUnitViewSpec = function (unit) {\n    var _a = this.getCurrentData(),\n        viewSpecs = _a.viewSpecs,\n        toolbarConfig = _a.toolbarConfig;\n\n    var viewTypes = [].concat(toolbarConfig.viewsWithButtons);\n    var i;\n    var spec;\n\n    for (var viewType in viewSpecs) {\n      viewTypes.push(viewType);\n    }\n\n    for (i = 0; i < viewTypes.length; i += 1) {\n      spec = viewSpecs[viewTypes[i]];\n\n      if (spec) {\n        if (spec.singleUnit === unit) {\n          return spec;\n        }\n      }\n    }\n\n    return null;\n  }; // Current Date\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.prev = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'PREV'\n    });\n  };\n\n  CalendarApi.prototype.next = function () {\n    this.unselect();\n    this.dispatch({\n      type: 'NEXT'\n    });\n  };\n\n  CalendarApi.prototype.prevYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n    });\n  };\n\n  CalendarApi.prototype.nextYear = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n    });\n  };\n\n  CalendarApi.prototype.today = function () {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n    });\n  };\n\n  CalendarApi.prototype.gotoDate = function (zonedDateInput) {\n    var state = this.getCurrentData();\n    this.unselect();\n    this.dispatch({\n      type: 'CHANGE_DATE',\n      dateMarker: state.dateEnv.createMarker(zonedDateInput)\n    });\n  };\n\n  CalendarApi.prototype.incrementDate = function (deltaInput) {\n    var state = this.getCurrentData();\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // else, warn about invalid input?\n      this.unselect();\n      this.dispatch({\n        type: 'CHANGE_DATE',\n        dateMarker: state.dateEnv.add(state.currentDate, delta)\n      });\n    }\n  }; // for external API\n\n\n  CalendarApi.prototype.getDate = function () {\n    var state = this.getCurrentData();\n    return state.dateEnv.toDate(state.currentDate);\n  }; // Date Formatting Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.formatDate = function (d, formatter) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n  }; // `settings` is for formatter AND isEndExclusive\n\n\n  CalendarApi.prototype.formatRange = function (d0, d1, settings) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n  };\n\n  CalendarApi.prototype.formatIso = function (d, omitTime) {\n    var dateEnv = this.getCurrentData().dateEnv;\n    return dateEnv.formatIso(dateEnv.createMarker(d), {\n      omitTime: omitTime\n    });\n  }; // Date Selection / Event Selection / DayClick\n  // -----------------------------------------------------------------------------------------------------------------\n  // this public method receives start/end dates in any format, with any timezone\n  // NOTE: args were changed from v3\n\n\n  CalendarApi.prototype.select = function (dateOrObj, endDate) {\n    var selectionInput;\n\n    if (endDate == null) {\n      if (dateOrObj.start != null) {\n        selectionInput = dateOrObj;\n      } else {\n        selectionInput = {\n          start: dateOrObj,\n          end: null\n        };\n      }\n    } else {\n      selectionInput = {\n        start: dateOrObj,\n        end: endDate\n      };\n    }\n\n    var state = this.getCurrentData();\n    var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n      days: 1\n    }));\n\n    if (selection) {\n      // throw parse error otherwise?\n      this.dispatch({\n        type: 'SELECT_DATES',\n        selection: selection\n      });\n      triggerDateSelect(selection, null, state);\n    }\n  }; // public method\n\n\n  CalendarApi.prototype.unselect = function (pev) {\n    var state = this.getCurrentData();\n\n    if (state.dateSelection) {\n      this.dispatch({\n        type: 'UNSELECT_DATES'\n      });\n      triggerDateUnselect(pev, state);\n    }\n  }; // Public Events API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {\n    if (eventInput instanceof EventApi) {\n      var def = eventInput._def;\n      var instance = eventInput._instance;\n      var currentData = this.getCurrentData(); // not already present? don't want to add an old snapshot\n\n      if (!currentData.eventStore.defs[def.defId]) {\n        this.dispatch({\n          type: 'ADD_EVENTS',\n          eventStore: eventTupleToStore({\n            def: def,\n            instance: instance\n          }) // TODO: better util for two args?\n\n        });\n        this.triggerEventAdd(eventInput);\n      }\n\n      return eventInput;\n    }\n\n    var state = this.getCurrentData();\n    var eventSource;\n\n    if (sourceInput instanceof EventSourceApi) {\n      eventSource = sourceInput.internalEventSource;\n    } else if (typeof sourceInput === 'boolean') {\n      if (sourceInput) {\n        // true. part of the first event source\n        eventSource = hashValuesToArray(state.eventSources)[0];\n      }\n    } else if (sourceInput != null) {\n      // an ID. accepts a number too\n      var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n\n      if (!sourceApi) {\n        console.warn(\"Could not find an event source with ID \\\"\" + sourceInput + \"\\\"\"); // TODO: test\n\n        return null;\n      }\n\n      eventSource = sourceApi.internalEventSource;\n    }\n\n    var tuple = parseEvent(eventInput, eventSource, state, false);\n\n    if (tuple) {\n      var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n      this.dispatch({\n        type: 'ADD_EVENTS',\n        eventStore: eventTupleToStore(tuple)\n      });\n      this.triggerEventAdd(newEventApi);\n      return newEventApi;\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.triggerEventAdd = function (eventApi) {\n    var _this = this;\n\n    var emitter = this.getCurrentData().emitter;\n    emitter.trigger('eventAdd', {\n      event: eventApi,\n      relatedEvents: [],\n      revert: function revert() {\n        _this.dispatch({\n          type: 'REMOVE_EVENTS',\n          eventStore: eventApiToStore(eventApi)\n        });\n      }\n    });\n  }; // TODO: optimize\n\n\n  CalendarApi.prototype.getEventById = function (id) {\n    var state = this.getCurrentData();\n    var _a = state.eventStore,\n        defs = _a.defs,\n        instances = _a.instances;\n    id = String(id);\n\n    for (var defId in defs) {\n      var def = defs[defId];\n\n      if (def.publicId === id) {\n        if (def.recurringDef) {\n          return new EventApi(state, def, null);\n        }\n\n        for (var instanceId in instances) {\n          var instance = instances[instanceId];\n\n          if (instance.defId === def.defId) {\n            return new EventApi(state, def, instance);\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.getEvents = function () {\n    var currentData = this.getCurrentData();\n    return buildEventApis(currentData.eventStore, currentData);\n  };\n\n  CalendarApi.prototype.removeAllEvents = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENTS'\n    });\n  }; // Public Event Sources API\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.getEventSources = function () {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    var sourceApis = [];\n\n    for (var internalId in sourceHash) {\n      sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n    }\n\n    return sourceApis;\n  };\n\n  CalendarApi.prototype.getEventSourceById = function (id) {\n    var state = this.getCurrentData();\n    var sourceHash = state.eventSources;\n    id = String(id);\n\n    for (var sourceId in sourceHash) {\n      if (sourceHash[sourceId].publicId === id) {\n        return new EventSourceApi(state, sourceHash[sourceId]);\n      }\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.addEventSource = function (sourceInput) {\n    var state = this.getCurrentData();\n\n    if (sourceInput instanceof EventSourceApi) {\n      // not already present? don't want to add an old snapshot\n      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n        this.dispatch({\n          type: 'ADD_EVENT_SOURCES',\n          sources: [sourceInput.internalEventSource]\n        });\n      }\n\n      return sourceInput;\n    }\n\n    var eventSource = parseEventSource(sourceInput, state);\n\n    if (eventSource) {\n      // TODO: error otherwise?\n      this.dispatch({\n        type: 'ADD_EVENT_SOURCES',\n        sources: [eventSource]\n      });\n      return new EventSourceApi(state, eventSource);\n    }\n\n    return null;\n  };\n\n  CalendarApi.prototype.removeAllEventSources = function () {\n    this.dispatch({\n      type: 'REMOVE_ALL_EVENT_SOURCES'\n    });\n  };\n\n  CalendarApi.prototype.refetchEvents = function () {\n    this.dispatch({\n      type: 'FETCH_EVENT_SOURCES',\n      isRefetch: true\n    });\n  }; // Scroll\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  CalendarApi.prototype.scrollToTime = function (timeInput) {\n    var time = createDuration(timeInput);\n\n    if (time) {\n      this.trigger('_scrollRequest', {\n        time: time\n      });\n    }\n  };\n\n  return CalendarApi;\n}();\n\nvar EventApi = function () {\n  // instance will be null if expressing a recurring event that has no current instances,\n  // OR if trying to validate an incoming external event that has no dates assigned\n  function EventApi(context, def, instance) {\n    this._context = context;\n    this._def = def;\n    this._instance = instance || null;\n  }\n  /*\n  TODO: make event struct more responsible for this\n  */\n\n\n  EventApi.prototype.setProp = function (name, val) {\n    var _a, _b;\n\n    if (name in EVENT_DATE_REFINERS) {\n      console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.'); // TODO: make proper aliasing system?\n    } else if (name === 'id') {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: {\n          publicId: val\n        } // hardcoded internal name\n\n      });\n    } else if (name in EVENT_NON_DATE_REFINERS) {\n      val = EVENT_NON_DATE_REFINERS[name](val);\n      this.mutate({\n        standardProps: (_a = {}, _a[name] = val, _a)\n      });\n    } else if (name in EVENT_UI_REFINERS) {\n      var ui = EVENT_UI_REFINERS[name](val);\n\n      if (name === 'color') {\n        ui = {\n          backgroundColor: val,\n          borderColor: val\n        };\n      } else if (name === 'editable') {\n        ui = {\n          startEditable: val,\n          durationEditable: val\n        };\n      } else {\n        ui = (_b = {}, _b[name] = val, _b);\n      }\n\n      this.mutate({\n        standardProps: {\n          ui: ui\n        }\n      });\n    } else {\n      console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n    }\n  };\n\n  EventApi.prototype.setExtendedProp = function (name, val) {\n    var _a;\n\n    this.mutate({\n      extendedProps: (_a = {}, _a[name] = val, _a)\n    });\n  };\n\n  EventApi.prototype.setStart = function (startInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var start = dateEnv.createMarker(startInput);\n\n    if (start && this._instance) {\n      // TODO: warning if parsed bad\n      var instanceRange = this._instance.range;\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n\n      if (options.maintainDuration) {\n        this.mutate({\n          datesDelta: startDelta\n        });\n      } else {\n        this.mutate({\n          startDelta: startDelta\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setEnd = function (endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var end;\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        return; // TODO: warning if parsed bad\n      }\n    }\n\n    if (this._instance) {\n      if (end) {\n        var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n        this.mutate({\n          endDelta: endDelta\n        });\n      } else {\n        this.mutate({\n          standardProps: {\n            hasEnd: false\n          }\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.setDates = function (startInput, endInput, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var dateEnv = this._context.dateEnv;\n    var standardProps = {\n      allDay: options.allDay\n    };\n    var start = dateEnv.createMarker(startInput);\n    var end;\n\n    if (!start) {\n      return; // TODO: warning if parsed bad\n    }\n\n    if (endInput != null) {\n      end = dateEnv.createMarker(endInput);\n\n      if (!end) {\n        // TODO: warning if parsed bad\n        return;\n      }\n    }\n\n    if (this._instance) {\n      var instanceRange = this._instance.range; // when computing the diff for an event being converted to all-day,\n      // compute diff off of the all-day values the way event-mutation does.\n\n      if (options.allDay === true) {\n        instanceRange = computeAlignedDayRange(instanceRange);\n      }\n\n      var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n\n      if (end) {\n        var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n\n        if (durationsEqual(startDelta, endDelta)) {\n          this.mutate({\n            datesDelta: startDelta,\n            standardProps: standardProps\n          });\n        } else {\n          this.mutate({\n            startDelta: startDelta,\n            endDelta: endDelta,\n            standardProps: standardProps\n          });\n        }\n      } else {\n        // means \"clear the end\"\n        standardProps.hasEnd = false;\n        this.mutate({\n          datesDelta: startDelta,\n          standardProps: standardProps\n        });\n      }\n    }\n  };\n\n  EventApi.prototype.moveStart = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        startDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveEnd = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        endDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.moveDates = function (deltaInput) {\n    var delta = createDuration(deltaInput);\n\n    if (delta) {\n      // TODO: warning if parsed bad\n      this.mutate({\n        datesDelta: delta\n      });\n    }\n  };\n\n  EventApi.prototype.setAllDay = function (allDay, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var standardProps = {\n      allDay: allDay\n    };\n    var maintainDuration = options.maintainDuration;\n\n    if (maintainDuration == null) {\n      maintainDuration = this._context.options.allDayMaintainDuration;\n    }\n\n    if (this._def.allDay !== allDay) {\n      standardProps.hasEnd = maintainDuration;\n    }\n\n    this.mutate({\n      standardProps: standardProps\n    });\n  };\n\n  EventApi.prototype.formatRange = function (formatInput) {\n    var dateEnv = this._context.dateEnv;\n    var instance = this._instance;\n    var formatter = createFormatter(formatInput);\n\n    if (this._def.hasEnd) {\n      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n        forcedStartTzo: instance.forcedStartTzo,\n        forcedEndTzo: instance.forcedEndTzo\n      });\n    }\n\n    return dateEnv.format(instance.range.start, formatter, {\n      forcedTzo: instance.forcedStartTzo\n    });\n  };\n\n  EventApi.prototype.mutate = function (mutation) {\n    var instance = this._instance;\n\n    if (instance) {\n      var def = this._def;\n      var context_1 = this._context;\n      var eventStore_1 = context_1.getCurrentData().eventStore;\n      var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n      var eventConfigBase = {\n        '': {\n          display: '',\n          startEditable: true,\n          durationEditable: true,\n          constraints: [],\n          overlap: null,\n          allows: [],\n          backgroundColor: '',\n          borderColor: '',\n          textColor: '',\n          classNames: []\n        }\n      };\n      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n      var oldEvent = new EventApi(context_1, def, instance); // snapshot\n\n      this._def = relevantEvents.defs[def.defId];\n      this._instance = relevantEvents.instances[instance.instanceId];\n      context_1.dispatch({\n        type: 'MERGE_EVENTS',\n        eventStore: relevantEvents\n      });\n      context_1.emitter.trigger('eventChange', {\n        oldEvent: oldEvent,\n        event: this,\n        relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n        revert: function revert() {\n          context_1.dispatch({\n            type: 'RESET_EVENTS',\n            eventStore: eventStore_1\n          });\n        }\n      });\n    }\n  };\n\n  EventApi.prototype.remove = function () {\n    var context = this._context;\n    var asStore = eventApiToStore(this);\n    context.dispatch({\n      type: 'REMOVE_EVENTS',\n      eventStore: asStore\n    });\n    context.emitter.trigger('eventRemove', {\n      event: this,\n      relatedEvents: [],\n      revert: function revert() {\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: asStore\n        });\n      }\n    });\n  };\n\n  Object.defineProperty(EventApi.prototype, \"source\", {\n    get: function get() {\n      var sourceId = this._def.sourceId;\n\n      if (sourceId) {\n        return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n      }\n\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"start\", {\n    get: function get() {\n      return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"end\", {\n    get: function get() {\n      return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startStr\", {\n    get: function get() {\n      var instance = this._instance;\n\n      if (instance) {\n        return this._context.dateEnv.formatIso(instance.range.start, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedStartTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"endStr\", {\n    get: function get() {\n      var instance = this._instance;\n\n      if (instance && this._def.hasEnd) {\n        return this._context.dateEnv.formatIso(instance.range.end, {\n          omitTime: this._def.allDay,\n          forcedTzo: instance.forcedEndTzo\n        });\n      }\n\n      return '';\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"id\", {\n    // computable props that all access the def\n    // TODO: find a TypeScript-compatible way to do this at scale\n    get: function get() {\n      return this._def.publicId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"groupId\", {\n    get: function get() {\n      return this._def.groupId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allDay\", {\n    get: function get() {\n      return this._def.allDay;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"title\", {\n    get: function get() {\n      return this._def.title;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"url\", {\n    get: function get() {\n      return this._def.url;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"display\", {\n    get: function get() {\n      return this._def.ui.display || 'auto';\n    } // bad. just normalize the type earlier\n    ,\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"startEditable\", {\n    get: function get() {\n      return this._def.ui.startEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n    get: function get() {\n      return this._def.ui.durationEditable;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"constraint\", {\n    get: function get() {\n      return this._def.ui.constraints[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"overlap\", {\n    get: function get() {\n      return this._def.ui.overlap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"allow\", {\n    get: function get() {\n      return this._def.ui.allows[0] || null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n    get: function get() {\n      return this._def.ui.backgroundColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"borderColor\", {\n    get: function get() {\n      return this._def.ui.borderColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"textColor\", {\n    get: function get() {\n      return this._def.ui.textColor;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"classNames\", {\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get: function get() {\n      return this._def.ui.classNames;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n    get: function get() {\n      return this._def.extendedProps;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  EventApi.prototype.toPlainObject = function (settings) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    var def = this._def;\n    var ui = def.ui;\n\n    var _a = this,\n        startStr = _a.startStr,\n        endStr = _a.endStr;\n\n    var res = {};\n\n    if (def.title) {\n      res.title = def.title;\n    }\n\n    if (startStr) {\n      res.start = startStr;\n    }\n\n    if (endStr) {\n      res.end = endStr;\n    }\n\n    if (def.publicId) {\n      res.id = def.publicId;\n    }\n\n    if (def.groupId) {\n      res.groupId = def.groupId;\n    }\n\n    if (def.url) {\n      res.url = def.url;\n    }\n\n    if (ui.display && ui.display !== 'auto') {\n      res.display = ui.display;\n    } // TODO: what about recurring-event properties???\n    // TODO: include startEditable/durationEditable/constraint/overlap/allow\n\n\n    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n      res.color = ui.backgroundColor;\n    } else {\n      if (ui.backgroundColor) {\n        res.backgroundColor = ui.backgroundColor;\n      }\n\n      if (ui.borderColor) {\n        res.borderColor = ui.borderColor;\n      }\n    }\n\n    if (ui.textColor) {\n      res.textColor = ui.textColor;\n    }\n\n    if (ui.classNames.length) {\n      res.classNames = ui.classNames;\n    }\n\n    if (Object.keys(def.extendedProps).length) {\n      if (settings.collapseExtendedProps) {\n        (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(res, def.extendedProps);\n      } else {\n        res.extendedProps = def.extendedProps;\n      }\n    }\n\n    return res;\n  };\n\n  EventApi.prototype.toJSON = function () {\n    return this.toPlainObject();\n  };\n\n  return EventApi;\n}();\n\nfunction eventApiToStore(eventApi) {\n  var _a, _b;\n\n  var def = eventApi._def;\n  var instance = eventApi._instance;\n  return {\n    defs: (_a = {}, _a[def.defId] = def, _a),\n    instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n  };\n}\n\nfunction buildEventApis(eventStore, context, excludeInstance) {\n  var defs = eventStore.defs,\n      instances = eventStore.instances;\n  var eventApis = [];\n  var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n\n  for (var id in instances) {\n    var instance = instances[id];\n    var def = defs[instance.defId];\n\n    if (instance.instanceId !== excludeInstanceId) {\n      eventApis.push(new EventApi(context, def, instance));\n    }\n  }\n\n  return eventApis;\n}\n\nvar calendarSystemClassMap = {};\n\nfunction registerCalendarSystem(name, theClass) {\n  calendarSystemClassMap[name] = theClass;\n}\n\nfunction createCalendarSystem(name) {\n  return new calendarSystemClassMap[name]();\n}\n\nvar GregorianCalendarSystem = function () {\n  function GregorianCalendarSystem() {}\n\n  GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n    return d.getUTCFullYear();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n    return d.getUTCMonth();\n  };\n\n  GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n    return d.getUTCDate();\n  };\n\n  GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n    return arrayToUtcDate(arr);\n  };\n\n  GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n    return dateToUtcArray(marker);\n  };\n\n  return GregorianCalendarSystem;\n}();\n\nregisterCalendarSystem('gregory', GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n\nfunction parse(str) {\n  var m = ISO_RE.exec(str);\n\n  if (m) {\n    var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n\n    if (isValidDate(marker)) {\n      var timeZoneOffset = null;\n\n      if (m[13]) {\n        timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n      }\n\n      return {\n        marker: marker,\n        isTimeUnspecified: !m[6],\n        timeZoneOffset: timeZoneOffset\n      };\n    }\n  }\n\n  return null;\n}\n\nvar DateEnv = function () {\n  function DateEnv(settings) {\n    var timeZone = this.timeZone = settings.timeZone;\n    var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n\n    if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n    }\n\n    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n    this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n    this.locale = settings.locale;\n    this.weekDow = settings.locale.week.dow;\n    this.weekDoy = settings.locale.week.doy;\n\n    if (settings.weekNumberCalculation === 'ISO') {\n      this.weekDow = 1;\n      this.weekDoy = 4;\n    }\n\n    if (typeof settings.firstDay === 'number') {\n      this.weekDow = settings.firstDay;\n    }\n\n    if (typeof settings.weekNumberCalculation === 'function') {\n      this.weekNumberFunc = settings.weekNumberCalculation;\n    }\n\n    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n    this.cmdFormatter = settings.cmdFormatter;\n    this.defaultSeparator = settings.defaultSeparator;\n  } // Creating / Parsing\n\n\n  DateEnv.prototype.createMarker = function (input) {\n    var meta = this.createMarkerMeta(input);\n\n    if (meta === null) {\n      return null;\n    }\n\n    return meta.marker;\n  };\n\n  DateEnv.prototype.createNowMarker = function () {\n    if (this.canComputeOffset) {\n      return this.timestampToMarker(new Date().valueOf());\n    } // if we can't compute the current date val for a timezone,\n    // better to give the current local date vals than UTC\n\n\n    return arrayToUtcDate(dateToLocalArray(new Date()));\n  };\n\n  DateEnv.prototype.createMarkerMeta = function (input) {\n    if (typeof input === 'string') {\n      return this.parse(input);\n    }\n\n    var marker = null;\n\n    if (typeof input === 'number') {\n      marker = this.timestampToMarker(input);\n    } else if (input instanceof Date) {\n      input = input.valueOf();\n\n      if (!isNaN(input)) {\n        marker = this.timestampToMarker(input);\n      }\n    } else if (Array.isArray(input)) {\n      marker = arrayToUtcDate(input);\n    }\n\n    if (marker === null || !isValidDate(marker)) {\n      return null;\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: false,\n      forcedTzo: null\n    };\n  };\n\n  DateEnv.prototype.parse = function (s) {\n    var parts = parse(s);\n\n    if (parts === null) {\n      return null;\n    }\n\n    var marker = parts.marker;\n    var forcedTzo = null;\n\n    if (parts.timeZoneOffset !== null) {\n      if (this.canComputeOffset) {\n        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n      } else {\n        forcedTzo = parts.timeZoneOffset;\n      }\n    }\n\n    return {\n      marker: marker,\n      isTimeUnspecified: parts.isTimeUnspecified,\n      forcedTzo: forcedTzo\n    };\n  }; // Accessors\n\n\n  DateEnv.prototype.getYear = function (marker) {\n    return this.calendarSystem.getMarkerYear(marker);\n  };\n\n  DateEnv.prototype.getMonth = function (marker) {\n    return this.calendarSystem.getMarkerMonth(marker);\n  }; // Adding / Subtracting\n\n\n  DateEnv.prototype.add = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += dur.years;\n    a[1] += dur.months;\n    a[2] += dur.days;\n    a[6] += dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.subtract = function (marker, dur) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] -= dur.years;\n    a[1] -= dur.months;\n    a[2] -= dur.days;\n    a[6] -= dur.milliseconds;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addYears = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[0] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  };\n\n  DateEnv.prototype.addMonths = function (marker, n) {\n    var a = this.calendarSystem.markerToArray(marker);\n    a[1] += n;\n    return this.calendarSystem.arrayToMarker(a);\n  }; // Diffing Whole Units\n\n\n  DateEnv.prototype.diffWholeYears = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n    var calendarSystem = this.calendarSystem;\n\n    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n    }\n\n    return null;\n  }; // Range / Duration\n\n\n  DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n    var n = this.diffWholeYears(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'year',\n        value: n\n      };\n    }\n\n    n = this.diffWholeMonths(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'month',\n        value: n\n      };\n    }\n\n    n = diffWholeWeeks(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'week',\n        value: n\n      };\n    }\n\n    n = diffWholeDays(m0, m1);\n\n    if (n !== null) {\n      return {\n        unit: 'day',\n        value: n\n      };\n    }\n\n    n = diffHours(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'hour',\n        value: n\n      };\n    }\n\n    n = diffMinutes(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'minute',\n        value: n\n      };\n    }\n\n    n = diffSeconds(m0, m1);\n\n    if (isInt(n)) {\n      return {\n        unit: 'second',\n        value: n\n      };\n    }\n\n    return {\n      unit: 'millisecond',\n      value: m1.valueOf() - m0.valueOf()\n    };\n  };\n\n  DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n    // TODO: can use greatestWholeUnit\n    var diff;\n\n    if (d.years) {\n      diff = this.diffWholeYears(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughYears(d);\n      }\n    }\n\n    if (d.months) {\n      diff = this.diffWholeMonths(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughMonths(d);\n      }\n    }\n\n    if (d.days) {\n      diff = diffWholeDays(m0, m1);\n\n      if (diff !== null) {\n        return diff / asRoughDays(d);\n      }\n    }\n\n    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n  }; // Start-Of\n  // these DON'T return zoned-dates. only UTC start-of dates\n\n\n  DateEnv.prototype.startOf = function (m, unit) {\n    if (unit === 'year') {\n      return this.startOfYear(m);\n    }\n\n    if (unit === 'month') {\n      return this.startOfMonth(m);\n    }\n\n    if (unit === 'week') {\n      return this.startOfWeek(m);\n    }\n\n    if (unit === 'day') {\n      return startOfDay(m);\n    }\n\n    if (unit === 'hour') {\n      return startOfHour(m);\n    }\n\n    if (unit === 'minute') {\n      return startOfMinute(m);\n    }\n\n    if (unit === 'second') {\n      return startOfSecond(m);\n    }\n\n    return null;\n  };\n\n  DateEnv.prototype.startOfYear = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m)]);\n  };\n\n  DateEnv.prototype.startOfMonth = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m)]);\n  };\n\n  DateEnv.prototype.startOfWeek = function (m) {\n    return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(m), this.calendarSystem.getMarkerMonth(m), m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7]);\n  }; // Week Number\n\n\n  DateEnv.prototype.computeWeekNumber = function (marker) {\n    if (this.weekNumberFunc) {\n      return this.weekNumberFunc(this.toDate(marker));\n    }\n\n    return weekOfYear(marker, this.weekDow, this.weekDoy);\n  }; // TODO: choke on timeZoneName: long\n\n\n  DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    return formatter.format({\n      marker: marker,\n      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n    }, this);\n  };\n\n  DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n    if (dateOptions === void 0) {\n      dateOptions = {};\n    }\n\n    if (dateOptions.isEndExclusive) {\n      end = addMs(end, -1);\n    }\n\n    return formatter.formatRange({\n      marker: start,\n      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n    }, {\n      marker: end,\n      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n    }, this, dateOptions.defaultSeparator);\n  };\n  /*\n  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n  might as well use buildIsoString or some other util directly\n  */\n\n\n  DateEnv.prototype.formatIso = function (marker, extraOptions) {\n    if (extraOptions === void 0) {\n      extraOptions = {};\n    }\n\n    var timeZoneOffset = null;\n\n    if (!extraOptions.omitTimeZoneOffset) {\n      if (extraOptions.forcedTzo != null) {\n        timeZoneOffset = extraOptions.forcedTzo;\n      } else {\n        timeZoneOffset = this.offsetForMarker(marker);\n      }\n    }\n\n    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n  }; // TimeZone\n\n\n  DateEnv.prototype.timestampToMarker = function (ms) {\n    if (this.timeZone === 'local') {\n      return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n    }\n\n    if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n      return new Date(ms);\n    }\n\n    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n  };\n\n  DateEnv.prototype.offsetForMarker = function (m) {\n    if (this.timeZone === 'local') {\n      return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n    }\n\n    if (this.timeZone === 'UTC') {\n      return 0;\n    }\n\n    if (this.namedTimeZoneImpl) {\n      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n    }\n\n    return null;\n  }; // Conversion\n\n\n  DateEnv.prototype.toDate = function (m, forcedTzo) {\n    if (this.timeZone === 'local') {\n      return arrayToLocalDate(dateToUtcArray(m));\n    }\n\n    if (this.timeZone === 'UTC') {\n      return new Date(m.valueOf()); // make sure it's a copy\n    }\n\n    if (!this.namedTimeZoneImpl) {\n      return new Date(m.valueOf() - (forcedTzo || 0));\n    }\n\n    return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n  };\n\n  return DateEnv;\n}();\n\nvar globalLocales = [];\nvar RAW_EN_LOCALE = {\n  code: 'en',\n  week: {\n    dow: 0,\n    doy: 4 // 4 days need to be within the year to be considered the first week\n\n  },\n  direction: 'ltr',\n  buttonText: {\n    prev: 'prev',\n    next: 'next',\n    prevYear: 'prev year',\n    nextYear: 'next year',\n    year: 'year',\n    today: 'today',\n    month: 'month',\n    week: 'week',\n    day: 'day',\n    list: 'list'\n  },\n  weekText: 'W',\n  allDayText: 'all-day',\n  moreLinkText: 'more',\n  noEventsText: 'No events to display'\n};\n\nfunction organizeRawLocales(explicitRawLocales) {\n  var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n  var allRawLocales = globalLocales.concat(explicitRawLocales);\n  var rawLocaleMap = {\n    en: RAW_EN_LOCALE // necessary?\n\n  };\n\n  for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n    var rawLocale = allRawLocales_1[_i];\n    rawLocaleMap[rawLocale.code] = rawLocale;\n  }\n\n  return {\n    map: rawLocaleMap,\n    defaultCode: defaultCode\n  };\n}\n\nfunction buildLocale(inputSingular, available) {\n  if (_typeof(inputSingular) === 'object' && !Array.isArray(inputSingular)) {\n    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n  }\n\n  return queryLocale(inputSingular, available);\n}\n\nfunction queryLocale(codeArg, available) {\n  var codes = [].concat(codeArg || []); // will convert to array\n\n  var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n  return parseLocale(codeArg, codes, raw);\n}\n\nfunction queryRawLocale(codes, available) {\n  for (var i = 0; i < codes.length; i += 1) {\n    var parts = codes[i].toLocaleLowerCase().split('-');\n\n    for (var j = parts.length; j > 0; j -= 1) {\n      var simpleId = parts.slice(0, j).join('-');\n\n      if (available[simpleId]) {\n        return available[simpleId];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction parseLocale(codeArg, codes, raw) {\n  var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);\n  delete merged.code; // don't want this part of the options\n\n  var week = merged.week;\n  delete merged.week;\n  return {\n    codeArg: codeArg,\n    codes: codes,\n    week: week,\n    simpleNumberFormat: new Intl.NumberFormat(codeArg),\n    options: merged\n  };\n}\n\nfunction formatDate(dateInput, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var dateEnv = buildDateEnv$1(options);\n  var formatter = createFormatter(options);\n  var dateMeta = dateEnv.createMarkerMeta(dateInput);\n\n  if (!dateMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.format(dateMeta.marker, formatter, {\n    forcedTzo: dateMeta.forcedTzo\n  });\n}\n\nfunction formatRange(startInput, endInput, options) {\n  var dateEnv = buildDateEnv$1(_typeof(options) === 'object' && options ? options : {}); // pass in if non-null object\n\n  var formatter = createFormatter(options);\n  var startMeta = dateEnv.createMarkerMeta(startInput);\n  var endMeta = dateEnv.createMarkerMeta(endInput);\n\n  if (!startMeta || !endMeta) {\n    // TODO: warning?\n    return '';\n  }\n\n  return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n    forcedStartTzo: startMeta.forcedTzo,\n    forcedEndTzo: endMeta.forcedTzo,\n    isEndExclusive: options.isEndExclusive,\n    defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n  });\n} // TODO: more DRY and optimized\n\n\nfunction buildDateEnv$1(settings) {\n  var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n\n  return new DateEnv((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    timeZone: BASE_OPTION_DEFAULTS.timeZone,\n    calendarSystem: 'gregory'\n  }, settings), {\n    locale: locale\n  }));\n}\n\nvar DEF_DEFAULTS = {\n  startTime: '09:00',\n  endTime: '17:00',\n  daysOfWeek: [1, 2, 3, 4, 5],\n  display: 'inverse-background',\n  classNames: 'fc-non-business',\n  groupId: '_businessHours' // so multiple defs get grouped\n\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/\n\nfunction parseBusinessHours(input, context) {\n  return parseEvents(refineInputs(input), null, context);\n}\n\nfunction refineInputs(input) {\n  var rawDefs;\n\n  if (input === true) {\n    rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n  } else if (Array.isArray(input)) {\n    // if specifying an array, every sub-definition NEEDS a day-of-week\n    rawDefs = input.filter(function (rawDef) {\n      return rawDef.daysOfWeek;\n    });\n  } else if (_typeof(input) === 'object' && input) {\n    // non-null object\n    rawDefs = [input];\n  } else {\n    // is probably false\n    rawDefs = [];\n  }\n\n  rawDefs = rawDefs.map(function (rawDef) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, DEF_DEFAULTS), rawDef);\n  });\n  return rawDefs;\n}\n\nfunction pointInsideRect(point, rect) {\n  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n} // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n\n\nfunction intersectRects(rect1, rect2) {\n  var res = {\n    left: Math.max(rect1.left, rect2.left),\n    right: Math.min(rect1.right, rect2.right),\n    top: Math.max(rect1.top, rect2.top),\n    bottom: Math.min(rect1.bottom, rect2.bottom)\n  };\n\n  if (res.left < res.right && res.top < res.bottom) {\n    return res;\n  }\n\n  return false;\n}\n\nfunction translateRect(rect, deltaX, deltaY) {\n  return {\n    left: rect.left + deltaX,\n    right: rect.right + deltaX,\n    top: rect.top + deltaY,\n    bottom: rect.bottom + deltaY\n  };\n} // Returns a new point that will have been moved to reside within the given rectangle\n\n\nfunction constrainPoint(point, rect) {\n  return {\n    left: Math.min(Math.max(point.left, rect.left), rect.right),\n    top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n  };\n} // Returns a point that is the center of the given rectangle\n\n\nfunction getRectCenter(rect) {\n  return {\n    left: (rect.left + rect.right) / 2,\n    top: (rect.top + rect.bottom) / 2\n  };\n} // Subtracts point2's coordinates from point1's coordinates, returning a delta\n\n\nfunction diffPoints(point1, point2) {\n  return {\n    left: point1.left - point2.left,\n    top: point1.top - point2.top\n  };\n}\n\nvar canVGrowWithinCell;\n\nfunction getCanVGrowWithinCell() {\n  if (canVGrowWithinCell == null) {\n    canVGrowWithinCell = computeCanVGrowWithinCell();\n  }\n\n  return canVGrowWithinCell;\n}\n\nfunction computeCanVGrowWithinCell() {\n  // for SSR, because this function is call immediately at top-level\n  // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n  if (typeof document === 'undefined') {\n    return true;\n  }\n\n  var el = document.createElement('div');\n  el.style.position = 'absolute';\n  el.style.top = '0px';\n  el.style.left = '0px';\n  el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n  el.querySelector('table').style.height = '100px';\n  el.querySelector('div').style.height = '100%';\n  document.body.appendChild(el);\n  var div = el.querySelector('div');\n  var possible = div.offsetHeight > 0;\n  document.body.removeChild(el);\n  return possible;\n}\n\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n\nvar Splitter = function () {\n  function Splitter() {\n    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n    this.splitDateSelection = memoize(this._splitDateSpan);\n    this.splitEventStore = memoize(this._splitEventStore);\n    this.splitIndividualUi = memoize(this._splitIndividualUi);\n    this.splitEventDrag = memoize(this._splitInteraction);\n    this.splitEventResize = memoize(this._splitInteraction);\n    this.eventUiBuilders = {}; // TODO: typescript protection\n  }\n\n  Splitter.prototype.splitProps = function (props) {\n    var _this = this;\n\n    var keyInfos = this.getKeyInfo(props);\n    var defKeys = this.getKeysForEventDefs(props.eventStore);\n    var dateSelections = this.splitDateSelection(props.dateSelection);\n    var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n\n    var eventStores = this.splitEventStore(props.eventStore, defKeys);\n    var eventDrags = this.splitEventDrag(props.eventDrag);\n    var eventResizes = this.splitEventResize(props.eventResize);\n    var splitProps = {};\n    this.eventUiBuilders = mapHash(keyInfos, function (info, key) {\n      return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n    });\n\n    for (var key in keyInfos) {\n      var keyInfo = keyInfos[key];\n      var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n      var buildEventUi = this.eventUiBuilders[key];\n      splitProps[key] = {\n        businessHours: keyInfo.businessHours || props.businessHours,\n        dateSelection: dateSelections[key] || null,\n        eventStore: eventStore,\n        eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n        eventDrag: eventDrags[key] || null,\n        eventResize: eventResizes[key] || null\n      };\n    }\n\n    return splitProps;\n  };\n\n  Splitter.prototype._splitDateSpan = function (dateSpan) {\n    var dateSpans = {};\n\n    if (dateSpan) {\n      var keys = this.getKeysForDateSpan(dateSpan);\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        dateSpans[key] = dateSpan;\n      }\n    }\n\n    return dateSpans;\n  };\n\n  Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n    var _this = this;\n\n    return mapHash(eventStore.defs, function (eventDef) {\n      return _this.getKeysForEventDef(eventDef);\n    });\n  };\n\n  Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n    var defs = eventStore.defs,\n        instances = eventStore.instances;\n    var splitStores = {};\n\n    for (var defId in defs) {\n      for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n        var key = _a[_i];\n\n        if (!splitStores[key]) {\n          splitStores[key] = createEmptyEventStore();\n        }\n\n        splitStores[key].defs[defId] = defs[defId];\n      }\n    }\n\n    for (var instanceId in instances) {\n      var instance = instances[instanceId];\n\n      for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n        var key = _c[_b];\n\n        if (splitStores[key]) {\n          // must have already been created\n          splitStores[key].instances[instanceId] = instance;\n        }\n      }\n    }\n\n    return splitStores;\n  };\n\n  Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n    var splitHashes = {};\n\n    for (var defId in eventUiBases) {\n      if (defId) {\n        // not the '' key\n        for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n          var key = _a[_i];\n\n          if (!splitHashes[key]) {\n            splitHashes[key] = {};\n          }\n\n          splitHashes[key][defId] = eventUiBases[defId];\n        }\n      }\n    }\n\n    return splitHashes;\n  };\n\n  Splitter.prototype._splitInteraction = function (interaction) {\n    var splitStates = {};\n\n    if (interaction) {\n      var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents)); // can't rely on defKeys because event data is mutated\n\n\n      var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n\n      var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n\n      var populate = function populate(key) {\n        if (!splitStates[key]) {\n          splitStates[key] = {\n            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n            isEvent: interaction.isEvent\n          };\n        }\n      };\n\n      for (var key in affectedStores_1) {\n        populate(key);\n      }\n\n      for (var key in mutatedStores_1) {\n        populate(key);\n      }\n    }\n\n    return splitStates;\n  };\n\n  return Splitter;\n}();\n\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n  var baseParts = [];\n\n  if (allUi) {\n    baseParts.push(allUi);\n  }\n\n  if (eventUiForKey) {\n    baseParts.push(eventUiForKey);\n  }\n\n  var stuff = {\n    '': combineEventUis(baseParts)\n  };\n\n  if (individualUi) {\n    (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(stuff, individualUi);\n  }\n\n  return stuff;\n}\n\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n  return {\n    dow: date.getUTCDay(),\n    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n  };\n}\n\nfunction getDayClassNames(meta, theme) {\n  var classNames = ['fc-day', \"fc-day-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-day-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-day-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-day-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-day-future');\n    }\n\n    if (meta.isOther) {\n      classNames.push('fc-day-other');\n    }\n  }\n\n  return classNames;\n}\n\nfunction getSlotClassNames(meta, theme) {\n  var classNames = ['fc-slot', \"fc-slot-\" + DAY_IDS[meta.dow]];\n\n  if (meta.isDisabled) {\n    classNames.push('fc-slot-disabled');\n  } else {\n    if (meta.isToday) {\n      classNames.push('fc-slot-today');\n      classNames.push(theme.getClass('today'));\n    }\n\n    if (meta.isPast) {\n      classNames.push('fc-slot-past');\n    }\n\n    if (meta.isFuture) {\n      classNames.push('fc-slot-future');\n    }\n  }\n\n  return classNames;\n}\n\nfunction buildNavLinkData(date, type) {\n  if (type === void 0) {\n    type = 'day';\n  }\n\n  return JSON.stringify({\n    date: formatDayString(date),\n    type: type\n  });\n}\n\nvar _isRtlScrollbarOnLeft = null;\n\nfunction getIsRtlScrollbarOnLeft() {\n  if (_isRtlScrollbarOnLeft === null) {\n    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n  }\n\n  return _isRtlScrollbarOnLeft;\n}\n\nfunction computeIsRtlScrollbarOnLeft() {\n  var outerEl = document.createElement('div');\n  applyStyle(outerEl, {\n    position: 'absolute',\n    top: -1000,\n    left: 0,\n    border: 0,\n    padding: 0,\n    overflow: 'scroll',\n    direction: 'rtl'\n  });\n  outerEl.innerHTML = '<div></div>';\n  document.body.appendChild(outerEl);\n  var innerEl = outerEl.firstChild;\n  var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n  removeElement(outerEl);\n  return res;\n}\n\nvar _scrollbarWidths;\n\nfunction getScrollbarWidths() {\n  if (!_scrollbarWidths) {\n    _scrollbarWidths = computeScrollbarWidths();\n  }\n\n  return _scrollbarWidths;\n}\n\nfunction computeScrollbarWidths() {\n  var el = document.createElement('div');\n  el.style.overflow = 'scroll';\n  el.style.position = 'absolute';\n  el.style.top = '-9999px';\n  el.style.left = '-9999px';\n  document.body.appendChild(el);\n  var res = computeScrollbarWidthsForEl(el);\n  document.body.removeChild(el);\n  return res;\n} // WARNING: will include border\n\n\nfunction computeScrollbarWidthsForEl(el) {\n  return {\n    x: el.offsetHeight - el.clientHeight,\n    y: el.offsetWidth - el.clientWidth\n  };\n}\n\nfunction computeEdges(el, getPadding) {\n  if (getPadding === void 0) {\n    getPadding = false;\n  }\n\n  var computedStyle = window.getComputedStyle(el);\n  var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n  var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n  var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n  var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n  var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n\n  var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n  var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n  var res = {\n    borderLeft: borderLeft,\n    borderRight: borderRight,\n    borderTop: borderTop,\n    borderBottom: borderBottom,\n    scrollbarBottom: scrollbarBottom,\n    scrollbarLeft: 0,\n    scrollbarRight: 0\n  };\n\n  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') {\n    // is the scrollbar on the left side?\n    res.scrollbarLeft = scrollbarLeftRight;\n  } else {\n    res.scrollbarRight = scrollbarLeftRight;\n  }\n\n  if (getPadding) {\n    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n  }\n\n  return res;\n}\n\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n  if (goWithinPadding === void 0) {\n    goWithinPadding = false;\n  }\n\n  var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n  var edges = computeEdges(el, goWithinPadding);\n  var res = {\n    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n    right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n    top: outerRect.top + edges.borderTop,\n    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n  };\n\n  if (goWithinPadding) {\n    res.left += edges.paddingLeft;\n    res.right -= edges.paddingRight;\n    res.top += edges.paddingTop;\n    res.bottom -= edges.paddingBottom;\n  }\n\n  return res;\n}\n\nfunction computeRect(el) {\n  var rect = el.getBoundingClientRect();\n  return {\n    left: rect.left + window.pageXOffset,\n    top: rect.top + window.pageYOffset,\n    right: rect.right + window.pageXOffset,\n    bottom: rect.bottom + window.pageYOffset\n  };\n}\n\nfunction computeClippedClientRect(el) {\n  var clippingParents = getClippingParents(el);\n  var rect = el.getBoundingClientRect();\n\n  for (var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++) {\n    var clippingParent = clippingParents_1[_i];\n    var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n\n    if (intersection) {\n      rect = intersection;\n    } else {\n      return null;\n    }\n  }\n\n  return rect;\n}\n\nfunction computeHeightAndMargins(el) {\n  return el.getBoundingClientRect().height + computeVMargins(el);\n}\n\nfunction computeVMargins(el) {\n  var computed = window.getComputedStyle(el);\n  return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n} // does not return window\n\n\nfunction getClippingParents(el) {\n  var parents = [];\n\n  while (el instanceof HTMLElement) {\n    // will stop when gets to document or null\n    var computedStyle = window.getComputedStyle(el);\n\n    if (computedStyle.position === 'fixed') {\n      break;\n    }\n\n    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n      parents.push(el);\n    }\n\n    el = el.parentNode;\n  }\n\n  return parents;\n} // given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\n\n\nfunction unpromisify(func, success, failure) {\n  // guard against success/failure callbacks being called more than once\n  // and guard against a promise AND callback being used together.\n  var isResolved = false;\n\n  var wrappedSuccess = function wrappedSuccess() {\n    if (!isResolved) {\n      isResolved = true;\n      success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n    }\n  };\n\n  var wrappedFailure = function wrappedFailure() {\n    if (!isResolved) {\n      isResolved = true;\n\n      if (failure) {\n        failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n      }\n    }\n  };\n\n  var res = func(wrappedSuccess, wrappedFailure);\n\n  if (res && typeof res.then === 'function') {\n    res.then(wrappedSuccess, wrappedFailure);\n  }\n}\n\nvar Emitter = function () {\n  function Emitter() {\n    this.handlers = {};\n    this.thisContext = null;\n  }\n\n  Emitter.prototype.setThisContext = function (thisContext) {\n    this.thisContext = thisContext;\n  };\n\n  Emitter.prototype.setOptions = function (options) {\n    this.options = options;\n  };\n\n  Emitter.prototype.on = function (type, handler) {\n    addToHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.off = function (type, handler) {\n    removeFromHash(this.handlers, type, handler);\n  };\n\n  Emitter.prototype.trigger = function (type) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var attachedHandlers = this.handlers[type] || [];\n    var optionHandler = this.options && this.options[type];\n    var handlers = [].concat(optionHandler || [], attachedHandlers);\n\n    for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\n      var handler = handlers_1[_a];\n      handler.apply(this.thisContext, args);\n    }\n  };\n\n  Emitter.prototype.hasHandlers = function (type) {\n    return this.handlers[type] && this.handlers[type].length || this.options && this.options[type];\n  };\n\n  return Emitter;\n}();\n\nfunction addToHash(hash, type, handler) {\n  (hash[type] || (hash[type] = [])).push(handler);\n}\n\nfunction removeFromHash(hash, type, handler) {\n  if (handler) {\n    if (hash[type]) {\n      hash[type] = hash[type].filter(function (func) {\n        return func !== handler;\n      });\n    }\n  } else {\n    delete hash[type]; // remove all handler funcs for this type\n  }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/\n\n\nvar PositionCache = function () {\n  function PositionCache(originEl, els, isHorizontal, isVertical) {\n    this.els = els;\n    var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n\n    if (isHorizontal) {\n      this.buildElHorizontals(originClientRect.left);\n    }\n\n    if (isVertical) {\n      this.buildElVerticals(originClientRect.top);\n    }\n  } // Populates the left/right internal coordinate arrays\n\n\n  PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n    var lefts = [];\n    var rights = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      lefts.push(rect.left - originClientLeft);\n      rights.push(rect.right - originClientLeft);\n    }\n\n    this.lefts = lefts;\n    this.rights = rights;\n  }; // Populates the top/bottom internal coordinate arrays\n\n\n  PositionCache.prototype.buildElVerticals = function (originClientTop) {\n    var tops = [];\n    var bottoms = [];\n\n    for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n      var el = _a[_i];\n      var rect = el.getBoundingClientRect();\n      tops.push(rect.top - originClientTop);\n      bottoms.push(rect.bottom - originClientTop);\n    }\n\n    this.tops = tops;\n    this.bottoms = bottoms;\n  }; // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.leftToIndex = function (leftPosition) {\n    var _a = this,\n        lefts = _a.lefts,\n        rights = _a.rights;\n\n    var len = lefts.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n  // If no intersection is made, returns undefined.\n\n\n  PositionCache.prototype.topToIndex = function (topPosition) {\n    var _a = this,\n        tops = _a.tops,\n        bottoms = _a.bottoms;\n\n    var len = tops.length;\n    var i;\n\n    for (i = 0; i < len; i += 1) {\n      if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n        return i;\n      }\n    }\n\n    return undefined; // TODO: better\n  }; // Gets the width of the element at the given index\n\n\n  PositionCache.prototype.getWidth = function (leftIndex) {\n    return this.rights[leftIndex] - this.lefts[leftIndex];\n  }; // Gets the height of the element at the given index\n\n\n  PositionCache.prototype.getHeight = function (topIndex) {\n    return this.bottoms[topIndex] - this.tops[topIndex];\n  };\n\n  return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */\n\n/*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/\n\n\nvar ScrollController = function () {\n  function ScrollController() {}\n\n  ScrollController.prototype.getMaxScrollTop = function () {\n    return this.getScrollHeight() - this.getClientHeight();\n  };\n\n  ScrollController.prototype.getMaxScrollLeft = function () {\n    return this.getScrollWidth() - this.getClientWidth();\n  };\n\n  ScrollController.prototype.canScrollVertically = function () {\n    return this.getMaxScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollHorizontally = function () {\n    return this.getMaxScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollUp = function () {\n    return this.getScrollTop() > 0;\n  };\n\n  ScrollController.prototype.canScrollDown = function () {\n    return this.getScrollTop() < this.getMaxScrollTop();\n  };\n\n  ScrollController.prototype.canScrollLeft = function () {\n    return this.getScrollLeft() > 0;\n  };\n\n  ScrollController.prototype.canScrollRight = function () {\n    return this.getScrollLeft() < this.getMaxScrollLeft();\n  };\n\n  return ScrollController;\n}();\n\nvar ElementScrollController = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ElementScrollController, _super);\n\n  function ElementScrollController(el) {\n    var _this = _super.call(this) || this;\n\n    _this.el = el;\n    return _this;\n  }\n\n  ElementScrollController.prototype.getScrollTop = function () {\n    return this.el.scrollTop;\n  };\n\n  ElementScrollController.prototype.getScrollLeft = function () {\n    return this.el.scrollLeft;\n  };\n\n  ElementScrollController.prototype.setScrollTop = function (top) {\n    this.el.scrollTop = top;\n  };\n\n  ElementScrollController.prototype.setScrollLeft = function (left) {\n    this.el.scrollLeft = left;\n  };\n\n  ElementScrollController.prototype.getScrollWidth = function () {\n    return this.el.scrollWidth;\n  };\n\n  ElementScrollController.prototype.getScrollHeight = function () {\n    return this.el.scrollHeight;\n  };\n\n  ElementScrollController.prototype.getClientHeight = function () {\n    return this.el.clientHeight;\n  };\n\n  ElementScrollController.prototype.getClientWidth = function () {\n    return this.el.clientWidth;\n  };\n\n  return ElementScrollController;\n}(ScrollController);\n\nvar WindowScrollController = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(WindowScrollController, _super);\n\n  function WindowScrollController() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WindowScrollController.prototype.getScrollTop = function () {\n    return window.pageYOffset;\n  };\n\n  WindowScrollController.prototype.getScrollLeft = function () {\n    return window.pageXOffset;\n  };\n\n  WindowScrollController.prototype.setScrollTop = function (n) {\n    window.scroll(window.pageXOffset, n);\n  };\n\n  WindowScrollController.prototype.setScrollLeft = function (n) {\n    window.scroll(n, window.pageYOffset);\n  };\n\n  WindowScrollController.prototype.getScrollWidth = function () {\n    return document.documentElement.scrollWidth;\n  };\n\n  WindowScrollController.prototype.getScrollHeight = function () {\n    return document.documentElement.scrollHeight;\n  };\n\n  WindowScrollController.prototype.getClientHeight = function () {\n    return document.documentElement.clientHeight;\n  };\n\n  WindowScrollController.prototype.getClientWidth = function () {\n    return document.documentElement.clientWidth;\n  };\n\n  return WindowScrollController;\n}(ScrollController);\n\nvar Theme = function () {\n  function Theme(calendarOptions) {\n    if (this.iconOverrideOption) {\n      this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n    }\n  }\n\n  Theme.prototype.setIconOverride = function (iconOverrideHash) {\n    var iconClassesCopy;\n    var buttonName;\n\n    if (_typeof(iconOverrideHash) === 'object' && iconOverrideHash) {\n      // non-null object\n      iconClassesCopy = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.iconClasses);\n\n      for (buttonName in iconOverrideHash) {\n        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n      }\n\n      this.iconClasses = iconClassesCopy;\n    } else if (iconOverrideHash === false) {\n      this.iconClasses = {};\n    }\n  };\n\n  Theme.prototype.applyIconOverridePrefix = function (className) {\n    var prefix = this.iconOverridePrefix;\n\n    if (prefix && className.indexOf(prefix) !== 0) {\n      // if not already present\n      className = prefix + className;\n    }\n\n    return className;\n  };\n\n  Theme.prototype.getClass = function (key) {\n    return this.classes[key] || '';\n  };\n\n  Theme.prototype.getIconClass = function (buttonName, isRtl) {\n    var className;\n\n    if (isRtl && this.rtlIconClasses) {\n      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n    } else {\n      className = this.iconClasses[buttonName];\n    }\n\n    if (className) {\n      return this.baseIconClass + \" \" + className;\n    }\n\n    return '';\n  };\n\n  Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n    var className;\n\n    if (this.iconOverrideCustomButtonOption) {\n      className = customButtonProps[this.iconOverrideCustomButtonOption];\n\n      if (className) {\n        return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n      }\n    }\n\n    return '';\n  };\n\n  return Theme;\n}();\n\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = '';\nTheme.prototype.iconOverridePrefix = '';\n\nvar ScrollResponder = function () {\n  function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n    var _this = this;\n\n    this.execFunc = execFunc;\n    this.emitter = emitter;\n    this.scrollTime = scrollTime;\n    this.scrollTimeReset = scrollTimeReset;\n\n    this.handleScrollRequest = function (request) {\n      _this.queuedRequest = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, _this.queuedRequest || {}, request);\n\n      _this.drain();\n    };\n\n    emitter.on('_scrollRequest', this.handleScrollRequest);\n    this.fireInitialScroll();\n  }\n\n  ScrollResponder.prototype.detach = function () {\n    this.emitter.off('_scrollRequest', this.handleScrollRequest);\n  };\n\n  ScrollResponder.prototype.update = function (isDatesNew) {\n    if (isDatesNew && this.scrollTimeReset) {\n      this.fireInitialScroll(); // will drain\n    } else {\n      this.drain();\n    }\n  };\n\n  ScrollResponder.prototype.fireInitialScroll = function () {\n    this.handleScrollRequest({\n      time: this.scrollTime\n    });\n  };\n\n  ScrollResponder.prototype.drain = function () {\n    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n      this.queuedRequest = null;\n    }\n  };\n\n  return ScrollResponder;\n}();\n\nvar ViewContextType = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext)({}); // for Components\n\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n  return {\n    dateEnv: dateEnv,\n    options: viewOptions,\n    pluginHooks: pluginHooks,\n    emitter: emitter,\n    dispatch: dispatch,\n    getCurrentData: getCurrentData,\n    calendarApi: calendarApi,\n    viewSpec: viewSpec,\n    viewApi: viewApi,\n    dateProfileGenerator: dateProfileGenerator,\n    theme: theme,\n    isRtl: viewOptions.direction === 'rtl',\n    addResizeHandler: function addResizeHandler(handler) {\n      emitter.on('_resize', handler);\n    },\n    removeResizeHandler: function removeResizeHandler(handler) {\n      emitter.off('_resize', handler);\n    },\n    createScrollResponder: function createScrollResponder(execFunc) {\n      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n    },\n    registerInteractiveComponent: registerInteractiveComponent,\n    unregisterInteractiveComponent: unregisterInteractiveComponent\n  };\n}\n/* eslint max-classes-per-file: off */\n\n\nvar PureComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(PureComponent, _super);\n\n  function PureComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    if (this.debug) {\n      // eslint-disable-next-line no-console\n      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n    }\n\n    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n  };\n\n  PureComponent.addPropsEquality = addPropsEquality;\n  PureComponent.addStateEquality = addStateEquality;\n  PureComponent.contextType = ViewContextType;\n  return PureComponent;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\n\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\n\nvar BaseComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(BaseComponent, _super);\n\n  function BaseComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BaseComponent.contextType = ViewContextType;\n  return BaseComponent;\n}(PureComponent);\n\nfunction addPropsEquality(propEquality) {\n  var hash = Object.create(this.prototype.propEquality);\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(hash, propEquality);\n\n  this.prototype.propEquality = hash;\n}\n\nfunction addStateEquality(stateEquality) {\n  var hash = Object.create(this.prototype.stateEquality);\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(hash, stateEquality);\n\n  this.prototype.stateEquality = hash;\n} // use other one\n\n\nfunction setRef(ref, current) {\n  if (typeof ref === 'function') {\n    ref(current);\n  } else if (ref) {\n    // see https://github.com/facebook/react/issues/13029\n    ref.current = current;\n  }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/\n\n\nvar DateComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DateComponent, _super);\n\n  function DateComponent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.uid = guid();\n    return _this;\n  } // Hit System\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.prepareHits = function () {};\n\n  DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    return null; // this should be abstract\n  }; // Pointer Interaction Utils\n  // -----------------------------------------------------------------------------------------------------------------\n\n\n  DateComponent.prototype.isValidSegDownEl = function (el) {\n    return !this.props.eventDrag && // HACK\n    !this.props.eventResize && // HACK\n    !elementClosest(el, '.fc-event-mirror');\n  };\n\n  DateComponent.prototype.isValidDateDownEl = function (el) {\n    return !elementClosest(el, '.fc-event:not(.fc-bg-event)') && !elementClosest(el, '.fc-more-link') && // a \"more..\" link\n    !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n    !elementClosest(el, '.fc-popover'); // hack\n  };\n\n  return DateComponent;\n}(BaseComponent); // TODO: easier way to add new hooks? need to update a million things\n\n\nfunction createPlugin(input) {\n  return {\n    id: guid(),\n    deps: input.deps || [],\n    reducers: input.reducers || [],\n    isLoadingFuncs: input.isLoadingFuncs || [],\n    contextInit: [].concat(input.contextInit || []),\n    eventRefiners: input.eventRefiners || {},\n    eventDefMemberAdders: input.eventDefMemberAdders || [],\n    eventSourceRefiners: input.eventSourceRefiners || {},\n    isDraggableTransformers: input.isDraggableTransformers || [],\n    eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n    eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n    dateSelectionTransformers: input.dateSelectionTransformers || [],\n    datePointTransforms: input.datePointTransforms || [],\n    dateSpanTransforms: input.dateSpanTransforms || [],\n    views: input.views || {},\n    viewPropsTransformers: input.viewPropsTransformers || [],\n    isPropsValid: input.isPropsValid || null,\n    externalDefTransforms: input.externalDefTransforms || [],\n    viewContainerAppends: input.viewContainerAppends || [],\n    eventDropTransformers: input.eventDropTransformers || [],\n    componentInteractions: input.componentInteractions || [],\n    calendarInteractions: input.calendarInteractions || [],\n    themeClasses: input.themeClasses || {},\n    eventSourceDefs: input.eventSourceDefs || [],\n    cmdFormatter: input.cmdFormatter,\n    recurringTypes: input.recurringTypes || [],\n    namedTimeZonedImpl: input.namedTimeZonedImpl,\n    initialView: input.initialView || '',\n    elementDraggingImpl: input.elementDraggingImpl,\n    optionChangeHandlers: input.optionChangeHandlers || {},\n    scrollGridImpl: input.scrollGridImpl || null,\n    contentTypeHandlers: input.contentTypeHandlers || {},\n    listenerRefiners: input.listenerRefiners || {},\n    optionRefiners: input.optionRefiners || {},\n    propSetHandlers: input.propSetHandlers || {}\n  };\n}\n\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n  var isAdded = {};\n  var hooks = {\n    reducers: [],\n    isLoadingFuncs: [],\n    contextInit: [],\n    eventRefiners: {},\n    eventDefMemberAdders: [],\n    eventSourceRefiners: {},\n    isDraggableTransformers: [],\n    eventDragMutationMassagers: [],\n    eventDefMutationAppliers: [],\n    dateSelectionTransformers: [],\n    datePointTransforms: [],\n    dateSpanTransforms: [],\n    views: {},\n    viewPropsTransformers: [],\n    isPropsValid: null,\n    externalDefTransforms: [],\n    viewContainerAppends: [],\n    eventDropTransformers: [],\n    componentInteractions: [],\n    calendarInteractions: [],\n    themeClasses: {},\n    eventSourceDefs: [],\n    cmdFormatter: null,\n    recurringTypes: [],\n    namedTimeZonedImpl: null,\n    initialView: '',\n    elementDraggingImpl: null,\n    optionChangeHandlers: {},\n    scrollGridImpl: null,\n    contentTypeHandlers: {},\n    listenerRefiners: {},\n    optionRefiners: {},\n    propSetHandlers: {}\n  };\n\n  function addDefs(defs) {\n    for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\n      var def = defs_1[_i];\n\n      if (!isAdded[def.id]) {\n        isAdded[def.id] = true;\n        addDefs(def.deps);\n        hooks = combineHooks(hooks, def);\n      }\n    }\n  }\n\n  if (pluginDefs) {\n    addDefs(pluginDefs);\n  }\n\n  addDefs(globalDefs);\n  return hooks;\n}\n\nfunction buildBuildPluginHooks() {\n  var currentOverrideDefs = [];\n  var currentGlobalDefs = [];\n  var currentHooks;\n  return function (overrideDefs, globalDefs) {\n    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n      currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n    }\n\n    currentOverrideDefs = overrideDefs;\n    currentGlobalDefs = globalDefs;\n    return currentHooks;\n  };\n}\n\nfunction combineHooks(hooks0, hooks1) {\n  return {\n    reducers: hooks0.reducers.concat(hooks1.reducers),\n    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n    contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n    eventRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.eventRefiners), hooks1.eventRefiners),\n    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n    eventSourceRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n    views: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.views), hooks1.views),\n    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n    themeClasses: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.themeClasses), hooks1.themeClasses),\n    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n    initialView: hooks0.initialView || hooks1.initialView,\n    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n    optionChangeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n    contentTypeHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n    listenerRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n    optionRefiners: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.optionRefiners), hooks1.optionRefiners),\n    propSetHandlers: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n  };\n}\n\nvar StandardTheme = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(StandardTheme, _super);\n\n  function StandardTheme() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return StandardTheme;\n}(Theme);\n\nStandardTheme.prototype.classes = {\n  root: 'fc-theme-standard',\n  tableCellShaded: 'fc-cell-shaded',\n  buttonGroup: 'fc-button-group',\n  button: 'fc-button fc-button-primary',\n  buttonActive: 'fc-button-active'\n};\nStandardTheme.prototype.baseIconClass = 'fc-icon';\nStandardTheme.prototype.iconClasses = {\n  close: 'fc-icon-x',\n  prev: 'fc-icon-chevron-left',\n  next: 'fc-icon-chevron-right',\n  prevYear: 'fc-icon-chevrons-left',\n  nextYear: 'fc-icon-chevrons-right'\n};\nStandardTheme.prototype.rtlIconClasses = {\n  prev: 'fc-icon-chevron-right',\n  next: 'fc-icon-chevron-left',\n  prevYear: 'fc-icon-chevrons-right',\n  nextYear: 'fc-icon-chevrons-left'\n};\nStandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n\nStandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\nStandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n  var hash = {};\n  var viewType;\n\n  for (viewType in defaultConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  for (viewType in overrideConfigs) {\n    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  return hash;\n}\n\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  if (hash[viewType]) {\n    return hash[viewType];\n  }\n\n  var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n\n  if (viewDef) {\n    hash[viewType] = viewDef;\n  }\n\n  return viewDef;\n}\n\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n  var defaultConfig = defaultConfigs[viewType];\n  var overrideConfig = overrideConfigs[viewType];\n\n  var queryProp = function queryProp(name) {\n    return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n  };\n\n  var theComponent = queryProp('component');\n  var superType = queryProp('superType');\n  var superDef = null;\n\n  if (superType) {\n    if (superType === viewType) {\n      throw new Error('Can\\'t have a custom view type that references itself');\n    }\n\n    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n  }\n\n  if (!theComponent && superDef) {\n    theComponent = superDef.component;\n  }\n\n  if (!theComponent) {\n    return null; // don't throw a warning, might be settings for a single-unit view\n  }\n\n  return {\n    type: viewType,\n    component: theComponent,\n    defaults: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n    overrides: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n  };\n}\n/* eslint max-classes-per-file: off */\n// NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\n\n\nvar RenderHook = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(RenderHook, _super);\n\n  function RenderHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n\n    _this.handleRootEl = function (el) {\n      setRef(_this.rootElRef, el);\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    };\n\n    return _this;\n  }\n\n  RenderHook.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var hookProps = props.hookProps;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: props.didMount,\n      willUnmount: props.willUnmount,\n      elRef: this.handleRootEl\n    }, function (rootElRef) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHook, {\n        hookProps: hookProps,\n        content: props.content,\n        defaultContent: props.defaultContent,\n        backupElRef: _this.rootElRef\n      }, function (innerElRef, innerContent) {\n        return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n      });\n    });\n  };\n\n  return RenderHook;\n}(BaseComponent); // TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\n\n\nvar CustomContentRenderContext = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createContext)(0);\n\nfunction ContentHook(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(CustomContentRenderContext.Consumer, null, function (renderId) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHookInner, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      renderId: renderId\n    }, props));\n  });\n}\n\nvar ContentHookInner = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ContentHookInner, _super);\n\n  function ContentHookInner() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.innerElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  ContentHookInner.prototype.render = function () {\n    return this.props.children(this.innerElRef, this.renderInnerContent());\n  };\n\n  ContentHookInner.prototype.componentDidMount = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentDidUpdate = function () {\n    this.updateCustomContent();\n  };\n\n  ContentHookInner.prototype.componentWillUnmount = function () {\n    if (this.customContentInfo && this.customContentInfo.destroy) {\n      this.customContentInfo.destroy();\n    }\n  };\n\n  ContentHookInner.prototype.renderInnerContent = function () {\n    var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n\n    var innerContent = this.getInnerContent();\n    var meta = this.getContentMeta(innerContent); // initial run, or content-type changing? (from vue -> react for example)\n\n    if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n      // clearing old value\n      if (customContentInfo) {\n        if (customContentInfo.destroy) {\n          customContentInfo.destroy();\n        }\n\n        customContentInfo = this.customContentInfo = null;\n      } // assigning new value\n\n\n      if (meta.contentKey) {\n        customContentInfo = this.customContentInfo = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          contentKey: meta.contentKey,\n          contentVal: innerContent[meta.contentKey]\n        }, meta.buildLifecycleFuncs());\n      } // updating\n\n    } else if (customContentInfo) {\n      customContentInfo.contentVal = innerContent[meta.contentKey];\n    }\n\n    return customContentInfo ? [] // signal that something was specified\n    : innerContent; // assume a [p]react vdom node. use it\n  };\n\n  ContentHookInner.prototype.getInnerContent = function () {\n    var props = this.props;\n    var innerContent = normalizeContent(props.content, props.hookProps);\n\n    if (innerContent === undefined) {\n      // use the default\n      innerContent = normalizeContent(props.defaultContent, props.hookProps);\n    }\n\n    return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n  };\n\n  ContentHookInner.prototype.getContentMeta = function (innerContent) {\n    var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n    var contentKey = '';\n    var buildLifecycleFuncs = null;\n\n    if (innerContent) {\n      // allowed to be null, for convenience to caller\n      for (var searchKey in contentTypeHandlers) {\n        if (innerContent[searchKey] !== undefined) {\n          contentKey = searchKey;\n          buildLifecycleFuncs = contentTypeHandlers[searchKey];\n          break;\n        }\n      }\n    }\n\n    return {\n      contentKey: contentKey,\n      buildLifecycleFuncs: buildLifecycleFuncs\n    };\n  };\n\n  ContentHookInner.prototype.updateCustomContent = function () {\n    if (this.customContentInfo) {\n      // for non-[p]react\n      this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into\n      this.customContentInfo.contentVal);\n    }\n  };\n\n  return ContentHookInner;\n}(BaseComponent);\n\nvar MountHook = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MountHook, _super);\n\n  function MountHook() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, rootEl);\n      }\n    };\n\n    return _this;\n  }\n\n  MountHook.prototype.render = function () {\n    return this.props.children(this.handleRootEl);\n  };\n\n  MountHook.prototype.componentDidMount = function () {\n    var callback = this.props.didMount;\n\n    if (callback) {\n      callback((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  MountHook.prototype.componentWillUnmount = function () {\n    var callback = this.props.willUnmount;\n\n    if (callback) {\n      callback((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this.props.hookProps), {\n        el: this.rootEl\n      }));\n    }\n  };\n\n  return MountHook;\n}(BaseComponent);\n\nfunction buildClassNameNormalizer() {\n  var currentGenerator;\n  var currentHookProps;\n  var currentClassNames = [];\n  return function (generator, hookProps) {\n    if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n      currentGenerator = generator;\n      currentHookProps = hookProps;\n      currentClassNames = normalizeClassNames(generator, hookProps);\n    }\n\n    return currentClassNames;\n  };\n}\n\nfunction normalizeClassNames(classNames, hookProps) {\n  if (typeof classNames === 'function') {\n    classNames = classNames(hookProps);\n  }\n\n  return parseClassNames(classNames);\n}\n\nfunction normalizeContent(input, hookProps) {\n  if (typeof input === 'function') {\n    return input(hookProps, _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement); // give the function the vdom-creation func\n  }\n\n  return input;\n}\n\nvar ViewRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ViewRoot, _super);\n\n  function ViewRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  ViewRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = {\n      view: context.viewApi\n    };\n    var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: options.viewDidMount,\n      willUnmount: options.viewWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, [\"fc-\" + props.viewSpec.type + \"-view\", 'fc-view'].concat(customClassNames));\n    });\n  };\n\n  return ViewRoot;\n}(BaseComponent);\n\nfunction parseViewConfigs(inputs) {\n  return mapHash(inputs, parseViewConfig);\n}\n\nfunction parseViewConfig(input) {\n  var rawOptions = typeof input === 'function' ? {\n    component: input\n  } : input;\n  var component = rawOptions.component;\n\n  if (rawOptions.content) {\n    component = createViewHookComponent(rawOptions); // TODO: remove content/classNames/didMount/etc from options?\n  }\n\n  return {\n    superType: rawOptions.type,\n    component: component,\n    rawOptions: rawOptions\n  };\n}\n\nfunction createViewHookComponent(options) {\n  return function (viewProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewRoot, {\n        viewSpec: context.viewSpec\n      }, function (viewElRef, viewClassNames) {\n        var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, viewProps), {\n          nextDayThreshold: context.options.nextDayThreshold\n        });\n\n        return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n          hookProps: hookProps,\n          classNames: options.classNames,\n          content: options.content,\n          didMount: options.didMount,\n          willUnmount: options.willUnmount,\n          elRef: viewElRef\n        }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n          return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: viewClassNames.concat(customClassNames).join(' '),\n            ref: rootElRef\n          }, innerContent);\n        });\n      });\n    });\n  };\n}\n\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var defaultConfigs = parseViewConfigs(defaultInputs);\n  var overrideConfigs = parseViewConfigs(optionOverrides.views);\n  var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n  return mapHash(viewDefs, function (viewDef) {\n    return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n  });\n}\n\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n  var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n  var duration = null;\n  var durationUnit = '';\n  var singleUnit = '';\n  var singleUnitOverrides = {};\n\n  if (durationInput) {\n    duration = createDurationCached(durationInput);\n\n    if (duration) {\n      // valid?\n      var denom = greatestDurationDenominator(duration);\n      durationUnit = denom.unit;\n\n      if (denom.value === 1) {\n        singleUnit = durationUnit;\n        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n      }\n    }\n  }\n\n  var queryButtonText = function queryButtonText(optionsSubset) {\n    var buttonTextMap = optionsSubset.buttonText || {};\n    var buttonTextKey = viewDef.defaults.buttonTextKey;\n\n    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n      return buttonTextMap[buttonTextKey];\n    }\n\n    if (buttonTextMap[viewDef.type] != null) {\n      return buttonTextMap[viewDef.type];\n    }\n\n    if (buttonTextMap[singleUnit] != null) {\n      return buttonTextMap[singleUnit];\n    }\n\n    return null;\n  };\n\n  return {\n    type: viewDef.type,\n    component: viewDef.component,\n    duration: duration,\n    durationUnit: durationUnit,\n    singleUnit: singleUnit,\n    optionDefaults: viewDef.defaults,\n    optionOverrides: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, singleUnitOverrides), viewDef.overrides),\n    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n    viewDef.overrides.buttonText,\n    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type // fall back to given view name\n\n  };\n} // hack to get memoization working\n\n\nvar durationInputMap = {};\n\nfunction createDurationCached(durationInput) {\n  var json = JSON.stringify(durationInput);\n  var res = durationInputMap[json];\n\n  if (res === undefined) {\n    res = createDuration(durationInput);\n    durationInputMap[json] = res;\n  }\n\n  return res;\n}\n\nvar DateProfileGenerator = function () {\n  function DateProfileGenerator(props) {\n    this.props = props;\n    this.nowDate = getNow(props.nowInput, props.dateEnv);\n    this.initHiddenDays();\n  }\n  /* Date Range Computation\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n\n\n  DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(prevDate, -1, forceToValid);\n  }; // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n\n\n  DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {\n    var dateEnv = this.props.dateEnv;\n    var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n    currentDateProfile.dateIncrement);\n    return this.build(nextDate, 1, forceToValid);\n  }; // Builds a structure holding dates/ranges for rendering around the given date.\n  // Optional direction param indicates whether the date is being incremented/decremented\n  // from its previous value. decremented = -1, incremented = 1 (default).\n\n\n  DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n    if (forceToValid === void 0) {\n      forceToValid = true;\n    }\n\n    var props = this.props;\n    var validRange;\n    var currentInfo;\n    var isRangeAllDay;\n    var renderRange;\n    var activeRange;\n    var isValid;\n    validRange = this.buildValidRange();\n    validRange = this.trimHiddenDays(validRange);\n\n    if (forceToValid) {\n      currentDate = constrainMarkerToRange(currentDate, validRange);\n    }\n\n    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n    renderRange = this.trimHiddenDays(renderRange);\n    activeRange = renderRange;\n\n    if (!props.showNonCurrentDates) {\n      activeRange = intersectRanges(activeRange, currentInfo.range);\n    }\n\n    activeRange = this.adjustActiveRange(activeRange);\n    activeRange = intersectRanges(activeRange, validRange); // might return null\n    // it's invalid if the originally requested date is not contained,\n    // or if the range is completely outside of the valid range.\n\n    isValid = rangesIntersect(currentInfo.range, validRange);\n    return {\n      // constraint for where prev/next operations can go and where events can be dragged/resized to.\n      // an object with optional start and end properties.\n      validRange: validRange,\n      // range the view is formally responsible for.\n      // for example, a month view might have 1st-31st, excluding padded dates\n      currentRange: currentInfo.range,\n      // name of largest unit being displayed, like \"month\" or \"week\"\n      currentRangeUnit: currentInfo.unit,\n      isRangeAllDay: isRangeAllDay,\n      // dates that display events and accept drag-n-drop\n      // will be `null` if no dates accept events\n      activeRange: activeRange,\n      // date range with a rendered skeleton\n      // includes not-active days that need some sort of DOM\n      renderRange: renderRange,\n      // Duration object that denotes the first visible time of any given day\n      slotMinTime: props.slotMinTime,\n      // Duration object that denotes the exclusive visible end time of any given day\n      slotMaxTime: props.slotMaxTime,\n      isValid: isValid,\n      // how far the current date will move for a prev/next operation\n      dateIncrement: this.buildDateIncrement(currentInfo.duration) // pass a fallback (might be null) ^\n\n    };\n  }; // Builds an object with optional start/end properties.\n  // Indicates the minimum/maximum dates to display.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildValidRange = function () {\n    var input = this.props.validRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(this.props.calendarApi, this.nowDate) : input;\n    return this.refineRange(simpleInput) || {\n      start: null,\n      end: null\n    }; // completely open-ended\n  }; // Builds a structure with info about the \"current\" range, the range that is\n  // highlighted as being the current month for example.\n  // See build() for a description of `direction`.\n  // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n\n\n  DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n    var props = this.props;\n    var duration = null;\n    var unit = null;\n    var range = null;\n    var dayCount;\n\n    if (props.duration) {\n      duration = props.duration;\n      unit = props.durationUnit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    } else if (dayCount = this.props.dayCount) {\n      unit = 'day';\n      range = this.buildRangeFromDayCount(date, direction, dayCount);\n    } else if (range = this.buildCustomVisibleRange(date)) {\n      unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n    } else {\n      duration = this.getFallbackDuration();\n      unit = greatestDurationDenominator(duration).unit;\n      range = this.buildRangeFromDuration(date, direction, duration, unit);\n    }\n\n    return {\n      duration: duration,\n      unit: unit,\n      range: range\n    };\n  };\n\n  DateProfileGenerator.prototype.getFallbackDuration = function () {\n    return createDuration({\n      day: 1\n    });\n  }; // Returns a new activeRange to have time values (un-ambiguate)\n  // slotMinTime or slotMaxTime causes the range to expand.\n\n\n  DateProfileGenerator.prototype.adjustActiveRange = function (range) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        usesMinMaxTime = _a.usesMinMaxTime,\n        slotMinTime = _a.slotMinTime,\n        slotMaxTime = _a.slotMaxTime;\n    var start = range.start,\n        end = range.end;\n\n    if (usesMinMaxTime) {\n      // expand active range if slotMinTime is negative (why not when positive?)\n      if (asRoughDays(slotMinTime) < 0) {\n        start = startOfDay(start); // necessary?\n\n        start = dateEnv.add(start, slotMinTime);\n      } // expand active range if slotMaxTime is beyond one day (why not when negative?)\n\n\n      if (asRoughDays(slotMaxTime) > 1) {\n        end = startOfDay(end); // necessary?\n\n        end = addDays(end, -1);\n        end = dateEnv.add(end, slotMaxTime);\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds the \"current\" range when it is specified as an explicit duration.\n  // `unit` is the already-computed greatestDurationDenominator unit of duration.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var start;\n    var end;\n    var res; // compute what the alignment should be\n\n    if (!dateAlignment) {\n      var dateIncrement = this.props.dateIncrement;\n\n      if (dateIncrement) {\n        // use the smaller of the two units\n        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n          dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n        } else {\n          dateAlignment = unit;\n        }\n      } else {\n        dateAlignment = unit;\n      }\n    } // if the view displays a single day or smaller\n\n\n    if (asRoughDays(duration) <= 1) {\n      if (this.isHiddenDay(start)) {\n        start = this.skipHiddenDays(start, direction);\n        start = startOfDay(start);\n      }\n    }\n\n    function computeRes() {\n      start = dateEnv.startOf(date, dateAlignment);\n      end = dateEnv.add(start, duration);\n      res = {\n        start: start,\n        end: end\n      };\n    }\n\n    computeRes(); // if range is completely enveloped by hidden days, go past the hidden days\n\n    if (!this.trimHiddenDays(res)) {\n      date = this.skipHiddenDays(date, direction);\n      computeRes();\n    }\n\n    return res;\n  }; // Builds the \"current\" range when a dayCount is specified.\n\n\n  DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        dateAlignment = _a.dateAlignment;\n    var runningCount = 0;\n    var start = date;\n    var end;\n\n    if (dateAlignment) {\n      start = dateEnv.startOf(start, dateAlignment);\n    }\n\n    start = startOfDay(start);\n    start = this.skipHiddenDays(start, direction);\n    end = start;\n\n    do {\n      end = addDays(end, 1);\n\n      if (!this.isHiddenDay(end)) {\n        runningCount += 1;\n      }\n    } while (runningCount < dayCount);\n\n    return {\n      start: start,\n      end: end\n    };\n  }; // Builds a normalized range object for the \"visible\" range,\n  // which is a way to define the currentRange and activeRange at the same time.\n\n\n  DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n    var props = this.props;\n    var input = props.visibleRangeInput;\n    var simpleInput = typeof input === 'function' ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n    var range = this.refineRange(simpleInput);\n\n    if (range && (range.start == null || range.end == null)) {\n      return null;\n    }\n\n    return range;\n  }; // Computes the range that will represent the element/cells for *rendering*,\n  // but which may have voided days/times.\n  // not responsible for trimming hidden days.\n\n\n  DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    return currentRange;\n  }; // Compute the duration value that should be added/substracted to the current date\n  // when a prev/next operation happens.\n\n\n  DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n    var dateIncrement = this.props.dateIncrement;\n    var customAlignment;\n\n    if (dateIncrement) {\n      return dateIncrement;\n    }\n\n    if (customAlignment = this.props.dateAlignment) {\n      return createDuration(1, customAlignment);\n    }\n\n    if (fallback) {\n      return fallback;\n    }\n\n    return createDuration({\n      days: 1\n    });\n  };\n\n  DateProfileGenerator.prototype.refineRange = function (rangeInput) {\n    if (rangeInput) {\n      var range = parseRange(rangeInput, this.props.dateEnv);\n\n      if (range) {\n        range = computeVisibleDayRange(range);\n      }\n\n      return range;\n    }\n\n    return null;\n  };\n  /* Hidden Days\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Initializes internal variables related to calculating hidden days-of-week\n\n\n  DateProfileGenerator.prototype.initHiddenDays = function () {\n    var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n\n    var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n\n    var dayCnt = 0;\n    var i;\n\n    if (this.props.weekends === false) {\n      hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n    }\n\n    for (i = 0; i < 7; i += 1) {\n      if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n        dayCnt += 1;\n      }\n    }\n\n    if (!dayCnt) {\n      throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n    }\n\n    this.isHiddenDayHash = isHiddenDayHash;\n  }; // Remove days from the beginning and end of the range that are computed as hidden.\n  // If the whole range is trimmed off, returns null\n\n\n  DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n    var start = range.start,\n        end = range.end;\n\n    if (start) {\n      start = this.skipHiddenDays(start);\n    }\n\n    if (end) {\n      end = this.skipHiddenDays(end, -1, true);\n    }\n\n    if (start == null || end == null || start < end) {\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    return null;\n  }; // Is the current day hidden?\n  // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n\n\n  DateProfileGenerator.prototype.isHiddenDay = function (day) {\n    if (day instanceof Date) {\n      day = day.getUTCDay();\n    }\n\n    return this.isHiddenDayHash[day];\n  }; // Incrementing the current day until it is no longer a hidden day, returning a copy.\n  // DOES NOT CONSIDER validRange!\n  // If the initial value of `date` is not a hidden day, don't do anything.\n  // Pass `isExclusive` as `true` if you are dealing with an end date.\n  // `inc` defaults to `1` (increment one day forward each time)\n\n\n  DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n    if (inc === void 0) {\n      inc = 1;\n    }\n\n    if (isExclusive === void 0) {\n      isExclusive = false;\n    }\n\n    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n      date = addDays(date, inc);\n    }\n\n    return date;\n  };\n\n  return DateProfileGenerator;\n}();\n\nfunction reduceViewType(viewType, action) {\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      viewType = action.viewType;\n  }\n\n  return viewType;\n}\n\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'SET_OPTION':\n      return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n\n    default:\n      return dynamicOptionOverrides;\n  }\n}\n\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n  var dp;\n\n  switch (action.type) {\n    case 'CHANGE_VIEW_TYPE':\n      return dateProfileGenerator.build(action.dateMarker || currentDate);\n\n    case 'CHANGE_DATE':\n      return dateProfileGenerator.build(action.dateMarker);\n\n    case 'PREV':\n      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n\n    case 'NEXT':\n      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n\n      if (dp.isValid) {\n        return dp;\n      }\n\n      break;\n  }\n\n  return currentDateProfile;\n}\n\nfunction initEventSources(calendarOptions, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null;\n  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\n\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  switch (action.type) {\n    case 'ADD_EVENT_SOURCES':\n      // already parsed\n      return addSources(eventSources, action.sources, activeRange, context);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return removeSource(eventSources, action.sourceId);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return fetchDirtySources(eventSources, activeRange, context);\n      }\n\n      return eventSources;\n\n    case 'FETCH_EVENT_SOURCES':\n      return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n      arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n\n    case 'RECEIVE_EVENTS':\n    case 'RECEIVE_EVENT_ERROR':\n      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return {};\n\n    default:\n      return eventSources;\n  }\n}\n\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n  var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n\n  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\n\nfunction computeEventSourcesLoading(eventSources) {\n  for (var sourceId in eventSources) {\n    if (eventSources[sourceId].isFetching) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n  var hash = {};\n\n  for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n    var source = sources_1[_i];\n    hash[source.sourceId] = source;\n  }\n\n  if (fetchRange) {\n    hash = fetchDirtySources(hash, fetchRange, context);\n  }\n\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSourceHash), hash);\n}\n\nfunction removeSource(eventSourceHash, sourceId) {\n  return filterHash(eventSourceHash, function (eventSource) {\n    return eventSource.sourceId !== sourceId;\n  });\n}\n\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) {\n    return isSourceDirty(eventSource, fetchRange, context);\n  }), fetchRange, false, context);\n}\n\nfunction isSourceDirty(eventSource, fetchRange, context) {\n  if (!doesSourceNeedRange(eventSource, context)) {\n    return !eventSource.latestFetchId;\n  }\n\n  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\n\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n  var nextSources = {};\n\n  for (var sourceId in prevSources) {\n    var source = prevSources[sourceId];\n\n    if (sourceIdHash[sourceId]) {\n      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n    } else {\n      nextSources[sourceId] = source;\n    }\n  }\n\n  return nextSources;\n}\n\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n  var options = context.options,\n      calendarApi = context.calendarApi;\n  var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n  var fetchId = guid();\n  sourceDef.fetch({\n    eventSource: eventSource,\n    range: fetchRange,\n    isRefetch: isRefetch,\n    context: context\n  }, function (res) {\n    var rawEvents = res.rawEvents;\n\n    if (options.eventSourceSuccess) {\n      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    if (eventSource.success) {\n      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENTS',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      rawEvents: rawEvents\n    });\n  }, function (error) {\n    console.warn(error.message, error);\n\n    if (options.eventSourceFailure) {\n      options.eventSourceFailure.call(calendarApi, error);\n    }\n\n    if (eventSource.failure) {\n      eventSource.failure(error);\n    }\n\n    context.dispatch({\n      type: 'RECEIVE_EVENT_ERROR',\n      sourceId: eventSource.sourceId,\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      error: error\n    });\n  });\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSource), {\n    isFetching: true,\n    latestFetchId: fetchId\n  });\n}\n\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n  var _a;\n\n  var eventSource = sourceHash[sourceId];\n\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, sourceHash), (_a = {}, _a[sourceId] = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventSource), {\n      isFetching: false,\n      fetchRange: fetchRange\n    }), _a));\n  }\n\n  return sourceHash;\n}\n\nfunction excludeStaticSources(eventSources, context) {\n  return filterHash(eventSources, function (eventSource) {\n    return doesSourceNeedRange(eventSource, context);\n  });\n}\n\nfunction parseInitialSources(rawOptions, context) {\n  var refiners = buildEventSourceRefiners(context);\n  var rawSources = [].concat(rawOptions.eventSources || []);\n  var sources = []; // parsed\n\n  if (rawOptions.initialEvents) {\n    rawSources.unshift(rawOptions.initialEvents);\n  }\n\n  if (rawOptions.events) {\n    rawSources.unshift(rawOptions.events);\n  }\n\n  for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n    var rawSource = rawSources_1[_i];\n    var source = parseEventSource(rawSource, context, refiners);\n\n    if (source) {\n      sources.push(source);\n    }\n  }\n\n  return sources;\n}\n\nfunction doesSourceNeedRange(eventSource, context) {\n  var defs = context.pluginHooks.eventSourceDefs;\n  return !defs[eventSource.sourceDefId].ignoreRange;\n}\n\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n  switch (action.type) {\n    case 'RECEIVE_EVENTS':\n      // raw\n      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n\n    case 'ADD_EVENTS':\n      // already parsed, but not expanded\n      return addEvent(eventStore, action.eventStore, // new ones\n      dateProfile ? dateProfile.activeRange : null, context);\n\n    case 'RESET_EVENTS':\n      return action.eventStore;\n\n    case 'MERGE_EVENTS':\n      // already parsed and expanded\n      return mergeEventStores(eventStore, action.eventStore);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'CHANGE_DATE':\n    case 'CHANGE_VIEW_TYPE':\n      if (dateProfile) {\n        return expandRecurring(eventStore, dateProfile.activeRange, context);\n      }\n\n      return eventStore;\n\n    case 'REMOVE_EVENTS':\n      return excludeSubEventStore(eventStore, action.eventStore);\n\n    case 'REMOVE_EVENT_SOURCE':\n      return excludeEventsBySourceId(eventStore, action.sourceId);\n\n    case 'REMOVE_ALL_EVENT_SOURCES':\n      return filterEventStoreDefs(eventStore, function (eventDef) {\n        return !eventDef.sourceId // only keep events with no source id\n        ;\n      });\n\n    case 'REMOVE_ALL_EVENTS':\n      return createEmptyEventStore();\n\n    default:\n      return eventStore;\n  }\n}\n\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n  if (eventSource && // not already removed\n  fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n  ) {\n    var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n\n    if (fetchRange) {\n      subset = expandRecurring(subset, fetchRange, context);\n    }\n\n    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n  }\n\n  return eventStore;\n}\n\nfunction transformRawEvents(rawEvents, eventSource, context) {\n  var calEachTransform = context.options.eventDataTransform;\n  var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n\n  if (sourceEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n  }\n\n  if (calEachTransform) {\n    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n  }\n\n  return rawEvents;\n}\n\nfunction transformEachRawEvent(rawEvents, func) {\n  var refinedEvents;\n\n  if (!func) {\n    refinedEvents = rawEvents;\n  } else {\n    refinedEvents = [];\n\n    for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n      var rawEvent = rawEvents_1[_i];\n      var refinedEvent = func(rawEvent);\n\n      if (refinedEvent) {\n        refinedEvents.push(refinedEvent);\n      } else if (refinedEvent == null) {\n        refinedEvents.push(rawEvent);\n      } // if a different falsy value, do nothing\n\n    }\n  }\n\n  return refinedEvents;\n}\n\nfunction addEvent(eventStore, subset, expandRange, context) {\n  if (expandRange) {\n    subset = expandRecurring(subset, expandRange, context);\n  }\n\n  return mergeEventStores(eventStore, subset);\n}\n\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n  var defs = eventStore.defs;\n  var instances = mapHash(eventStore.instances, function (instance) {\n    var def = defs[instance.defId];\n\n    if (def.allDay || def.recurringDef) {\n      return instance; // isn't dependent on timezone\n    }\n\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, instance), {\n      range: {\n        start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n        end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n      },\n      forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n      forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n    });\n  });\n  return {\n    defs: defs,\n    instances: instances\n  };\n}\n\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n  return filterEventStoreDefs(eventStore, function (eventDef) {\n    return eventDef.sourceId !== sourceId;\n  });\n} // QUESTION: why not just return instances? do a general object-property-exclusion util\n\n\nfunction excludeInstances(eventStore, removals) {\n  return {\n    defs: eventStore.defs,\n    instances: filterHash(eventStore.instances, function (instance) {\n      return !removals[instance.instanceId];\n    })\n  };\n}\n\nfunction reduceDateSelection(currentSelection, action) {\n  switch (action.type) {\n    case 'UNSELECT_DATES':\n      return null;\n\n    case 'SELECT_DATES':\n      return action.selection;\n\n    default:\n      return currentSelection;\n  }\n}\n\nfunction reduceSelectedEvent(currentInstanceId, action) {\n  switch (action.type) {\n    case 'UNSELECT_EVENT':\n      return '';\n\n    case 'SELECT_EVENT':\n      return action.eventInstanceId;\n\n    default:\n      return currentInstanceId;\n  }\n}\n\nfunction reduceEventDrag(currentDrag, action) {\n  var newDrag;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_DRAG':\n      return null;\n\n    case 'SET_EVENT_DRAG':\n      newDrag = action.state;\n      return {\n        affectedEvents: newDrag.affectedEvents,\n        mutatedEvents: newDrag.mutatedEvents,\n        isEvent: newDrag.isEvent\n      };\n\n    default:\n      return currentDrag;\n  }\n}\n\nfunction reduceEventResize(currentResize, action) {\n  var newResize;\n\n  switch (action.type) {\n    case 'UNSET_EVENT_RESIZE':\n      return null;\n\n    case 'SET_EVENT_RESIZE':\n      newResize = action.state;\n      return {\n        affectedEvents: newResize.affectedEvents,\n        mutatedEvents: newResize.mutatedEvents,\n        isEvent: newResize.isEvent\n      };\n\n    default:\n      return currentResize;\n  }\n}\n\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n  var viewsWithButtons = [];\n  var headerToolbar = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n  var footerToolbar = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n  return {\n    headerToolbar: headerToolbar,\n    footerToolbar: footerToolbar,\n    viewsWithButtons: viewsWithButtons\n  };\n}\n\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {\n  return mapHash(sectionStrHash, function (sectionStr) {\n    return parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons);\n  });\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/\n\n\nfunction parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {\n  var isRtl = calendarOptions.direction === 'rtl';\n  var calendarCustomButtons = calendarOptions.customButtons || {};\n  var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n  var calendarButtonText = calendarOptions.buttonText || {};\n  var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n  return sectionSubstrs.map(function (buttonGroupStr) {\n    return buttonGroupStr.split(',').map(function (buttonName) {\n      if (buttonName === 'title') {\n        return {\n          buttonName: buttonName\n        };\n      }\n\n      var customButtonProps;\n      var viewSpec;\n      var buttonClick;\n      var buttonIcon; // only one of these will be set\n\n      var buttonText; // \"\n\n      if (customButtonProps = calendarCustomButtons[buttonName]) {\n        buttonClick = function buttonClick(ev) {\n          if (customButtonProps.click) {\n            customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n          }\n        };\n\n        (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n      } else if (viewSpec = viewSpecs[buttonName]) {\n        viewsWithButtons.push(buttonName);\n\n        buttonClick = function buttonClick() {\n          calendarApi.changeView(buttonName);\n        };\n\n        (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n      } else if (calendarApi[buttonName]) {\n        // a calendarApi method\n        buttonClick = function buttonClick() {\n          calendarApi[buttonName]();\n        };\n\n        (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); //            ^ everything else is considered default\n      }\n\n      return {\n        buttonName: buttonName,\n        buttonClick: buttonClick,\n        buttonIcon: buttonIcon,\n        buttonText: buttonText\n      };\n    });\n  });\n}\n\nvar eventSourceDef$2 = {\n  ignoreRange: true,\n  parseMeta: function parseMeta(refined) {\n    if (Array.isArray(refined.events)) {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success) {\n    success({\n      rawEvents: arg.eventSource.meta\n    });\n  }\n};\nvar arrayEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$2]\n});\nvar eventSourceDef$1 = {\n  parseMeta: function parseMeta(refined) {\n    if (typeof refined.events === 'function') {\n      return refined.events;\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success, failure) {\n    var dateEnv = arg.context.dateEnv;\n    var func = arg.eventSource.meta;\n    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {\n      success({\n        rawEvents: rawEvents\n      }); // needs an object response\n    }, failure);\n  }\n};\nvar funcEventSourcePlugin = createPlugin({\n  eventSourceDefs: [eventSourceDef$1]\n});\n\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n  method = method.toUpperCase();\n  var body = null;\n\n  if (method === 'GET') {\n    url = injectQueryStringParams(url, params);\n  } else {\n    body = encodeParams(params);\n  }\n\n  var xhr = new XMLHttpRequest();\n  xhr.open(method, url, true);\n\n  if (method !== 'GET') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n\n  xhr.onload = function () {\n    if (xhr.status >= 200 && xhr.status < 400) {\n      var parsed = false;\n      var res = void 0;\n\n      try {\n        res = JSON.parse(xhr.responseText);\n        parsed = true;\n      } catch (err) {// will handle parsed=false\n      }\n\n      if (parsed) {\n        successCallback(res, xhr);\n      } else {\n        failureCallback('Failure parsing JSON', xhr);\n      }\n    } else {\n      failureCallback('Request failed', xhr);\n    }\n  };\n\n  xhr.onerror = function () {\n    failureCallback('Request failed', xhr);\n  };\n\n  xhr.send(body);\n}\n\nfunction injectQueryStringParams(url, params) {\n  return url + (url.indexOf('?') === -1 ? '?' : '&') + encodeParams(params);\n}\n\nfunction encodeParams(params) {\n  var parts = [];\n\n  for (var key in params) {\n    parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n  }\n\n  return parts.join('&');\n}\n\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n  method: String,\n  extraParams: identity,\n  startParam: String,\n  endParam: String,\n  timeZoneParam: String\n};\nvar eventSourceDef = {\n  parseMeta: function parseMeta(refined) {\n    if (refined.url && (refined.format === 'json' || !refined.format)) {\n      return {\n        url: refined.url,\n        format: 'json',\n        method: (refined.method || 'GET').toUpperCase(),\n        extraParams: refined.extraParams,\n        startParam: refined.startParam,\n        endParam: refined.endParam,\n        timeZoneParam: refined.timeZoneParam\n      };\n    }\n\n    return null;\n  },\n  fetch: function fetch(arg, success, failure) {\n    var meta = arg.eventSource.meta;\n    var requestParams = buildRequestParams(meta, arg.range, arg.context);\n    requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n      success({\n        rawEvents: rawEvents,\n        xhr: xhr\n      });\n    }, function (errorMessage, xhr) {\n      failure({\n        message: errorMessage,\n        xhr: xhr\n      });\n    });\n  }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n  eventSourceDefs: [eventSourceDef]\n});\n\nfunction buildRequestParams(meta, range, context) {\n  var dateEnv = context.dateEnv,\n      options = context.options;\n  var startParam;\n  var endParam;\n  var timeZoneParam;\n  var customRequestParams;\n  var params = {};\n  startParam = meta.startParam;\n\n  if (startParam == null) {\n    startParam = options.startParam;\n  }\n\n  endParam = meta.endParam;\n\n  if (endParam == null) {\n    endParam = options.endParam;\n  }\n\n  timeZoneParam = meta.timeZoneParam;\n\n  if (timeZoneParam == null) {\n    timeZoneParam = options.timeZoneParam;\n  } // retrieve any outbound GET/POST data from the options\n\n\n  if (typeof meta.extraParams === 'function') {\n    // supplied as a function that returns a key/value object\n    customRequestParams = meta.extraParams();\n  } else {\n    // probably supplied as a straight key/value object\n    customRequestParams = meta.extraParams || {};\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(params, customRequestParams);\n\n  params[startParam] = dateEnv.formatIso(range.start);\n  params[endParam] = dateEnv.formatIso(range.end);\n\n  if (dateEnv.timeZone !== 'local') {\n    params[timeZoneParam] = dateEnv.timeZone;\n  }\n\n  return params;\n}\n\nvar SIMPLE_RECURRING_REFINERS = {\n  daysOfWeek: identity,\n  startTime: createDuration,\n  endTime: createDuration,\n  duration: createDuration,\n  startRecur: identity,\n  endRecur: identity\n};\nvar recurring = {\n  parse: function parse(refined, dateEnv) {\n    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n      var recurringData = {\n        daysOfWeek: refined.daysOfWeek || null,\n        startTime: refined.startTime || null,\n        endTime: refined.endTime || null,\n        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n      };\n      var duration = void 0;\n\n      if (refined.duration) {\n        duration = refined.duration;\n      }\n\n      if (!duration && refined.startTime && refined.endTime) {\n        duration = subtractDurations(refined.endTime, refined.startTime);\n      }\n\n      return {\n        allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n        duration: duration,\n        typeData: recurringData // doesn't need endTime anymore but oh well\n\n      };\n    }\n\n    return null;\n  },\n  expand: function expand(typeData, framingRange, dateEnv) {\n    var clippedFramingRange = intersectRanges(framingRange, {\n      start: typeData.startRecur,\n      end: typeData.endRecur\n    });\n\n    if (clippedFramingRange) {\n      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n    }\n\n    return [];\n  }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n  recurringTypes: [recurring],\n  eventRefiners: SIMPLE_RECURRING_REFINERS\n});\n\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n  var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n  var dayMarker = startOfDay(framingRange.start);\n  var endMarker = framingRange.end;\n  var instanceStarts = [];\n\n  while (dayMarker < endMarker) {\n    var instanceStart // if everyday, or this particular day-of-week\n    = void 0; // if everyday, or this particular day-of-week\n\n    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n      if (startTime) {\n        instanceStart = dateEnv.add(dayMarker, startTime);\n      } else {\n        instanceStart = dayMarker;\n      }\n\n      instanceStarts.push(instanceStart);\n    }\n\n    dayMarker = addDays(dayMarker, 1);\n  }\n\n  return instanceStarts;\n}\n\nvar changeHandlerPlugin = createPlugin({\n  optionChangeHandlers: {\n    events: function events(_events, context) {\n      handleEventSources([_events], context);\n    },\n    eventSources: handleEventSources\n  }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/\n\nfunction handleEventSources(inputs, context) {\n  var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n  var newInputs = [];\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    var inputFound = false;\n\n    for (var i = 0; i < unfoundSources.length; i += 1) {\n      if (unfoundSources[i]._raw === input) {\n        unfoundSources.splice(i, 1); // delete\n\n        inputFound = true;\n        break;\n      }\n    }\n\n    if (!inputFound) {\n      newInputs.push(input);\n    }\n  }\n\n  for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n    var unfoundSource = unfoundSources_1[_a];\n    context.dispatch({\n      type: 'REMOVE_EVENT_SOURCE',\n      sourceId: unfoundSource.sourceId\n    });\n  }\n\n  for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n    var newInput = newInputs_1[_b];\n    context.calendarApi.addEventSource(newInput);\n  }\n}\n\nfunction handleDateProfile(dateProfile, context) {\n  context.emitter.trigger('datesSet', (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n    view: context.viewApi\n  }));\n}\n\nfunction handleEventStore(eventStore, context) {\n  var emitter = context.emitter;\n\n  if (emitter.hasHandlers('eventsSet')) {\n    emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n  }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/\n\n\nvar globalPlugins = [arrayEventSourcePlugin, funcEventSourcePlugin, jsonFeedEventSourcePlugin, simpleRecurringEventsPlugin, changeHandlerPlugin, createPlugin({\n  isLoadingFuncs: [function (state) {\n    return computeEventSourcesLoading(state.eventSources);\n  }],\n  contentTypeHandlers: {\n    html: function html() {\n      return {\n        render: injectHtml\n      };\n    },\n    domNodes: function domNodes() {\n      return {\n        render: injectDomNodes\n      };\n    }\n  },\n  propSetHandlers: {\n    dateProfile: handleDateProfile,\n    eventStore: handleEventStore\n  }\n})];\n\nfunction injectHtml(el, html) {\n  el.innerHTML = html;\n}\n\nfunction injectDomNodes(el, domNodes) {\n  var oldNodes = Array.prototype.slice.call(el.childNodes); // TODO: use array util\n\n  var newNodes = Array.prototype.slice.call(domNodes); // TODO: use array util\n\n  if (!isArraysEqual(oldNodes, newNodes)) {\n    for (var _i = 0, newNodes_1 = newNodes; _i < newNodes_1.length; _i++) {\n      var newNode = newNodes_1[_i];\n      el.appendChild(newNode);\n    }\n\n    oldNodes.forEach(removeElement);\n  }\n}\n\nvar DelayedRunner = function () {\n  function DelayedRunner(drainedOption) {\n    this.drainedOption = drainedOption;\n    this.isRunning = false;\n    this.isDirty = false;\n    this.pauseDepths = {};\n    this.timeoutId = 0;\n  }\n\n  DelayedRunner.prototype.request = function (delay) {\n    this.isDirty = true;\n\n    if (!this.isPaused()) {\n      this.clearTimeout();\n\n      if (delay == null) {\n        this.tryDrain();\n      } else {\n        this.timeoutId = setTimeout( // NOT OPTIMAL! TODO: look at debounce\n        this.tryDrain.bind(this), delay);\n      }\n    }\n  };\n\n  DelayedRunner.prototype.pause = function (scope) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n    this.clearTimeout();\n  };\n\n  DelayedRunner.prototype.resume = function (scope, force) {\n    if (scope === void 0) {\n      scope = '';\n    }\n\n    var pauseDepths = this.pauseDepths;\n\n    if (scope in pauseDepths) {\n      if (force) {\n        delete pauseDepths[scope];\n      } else {\n        pauseDepths[scope] -= 1;\n        var depth = pauseDepths[scope];\n\n        if (depth <= 0) {\n          delete pauseDepths[scope];\n        }\n      }\n\n      this.tryDrain();\n    }\n  };\n\n  DelayedRunner.prototype.isPaused = function () {\n    return Object.keys(this.pauseDepths).length;\n  };\n\n  DelayedRunner.prototype.tryDrain = function () {\n    if (!this.isRunning && !this.isPaused()) {\n      this.isRunning = true;\n\n      while (this.isDirty) {\n        this.isDirty = false;\n        this.drained(); // might set isDirty to true again\n      }\n\n      this.isRunning = false;\n    }\n  };\n\n  DelayedRunner.prototype.clear = function () {\n    this.clearTimeout();\n    this.isDirty = false;\n    this.pauseDepths = {};\n  };\n\n  DelayedRunner.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = 0;\n    }\n  };\n\n  DelayedRunner.prototype.drained = function () {\n    if (this.drainedOption) {\n      this.drainedOption();\n    }\n  };\n\n  return DelayedRunner;\n}();\n\nvar TaskRunner = function () {\n  function TaskRunner(runTaskOption, drainedOption) {\n    this.runTaskOption = runTaskOption;\n    this.drainedOption = drainedOption;\n    this.queue = [];\n    this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n  }\n\n  TaskRunner.prototype.request = function (task, delay) {\n    this.queue.push(task);\n    this.delayedRunner.request(delay);\n  };\n\n  TaskRunner.prototype.pause = function (scope) {\n    this.delayedRunner.pause(scope);\n  };\n\n  TaskRunner.prototype.resume = function (scope, force) {\n    this.delayedRunner.resume(scope, force);\n  };\n\n  TaskRunner.prototype.drain = function () {\n    var queue = this.queue;\n\n    while (queue.length) {\n      var completedTasks = [];\n      var task = void 0;\n\n      while (task = queue.shift()) {\n        this.runTask(task);\n        completedTasks.push(task);\n      }\n\n      this.drained(completedTasks);\n    } // keep going, in case new tasks were added in the drained handler\n\n  };\n\n  TaskRunner.prototype.runTask = function (task) {\n    if (this.runTaskOption) {\n      this.runTaskOption(task);\n    }\n  };\n\n  TaskRunner.prototype.drained = function (completedTasks) {\n    if (this.drainedOption) {\n      this.drainedOption(completedTasks);\n    }\n  };\n\n  return TaskRunner;\n}(); // Computes what the title at the top of the calendarApi should be for this view\n\n\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n  var range; // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n\n  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n    range = dateProfile.currentRange;\n  } else {\n    // for day units or smaller, use the actual day range\n    range = dateProfile.activeRange;\n  }\n\n  return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n    isEndExclusive: dateProfile.isRangeAllDay,\n    defaultSeparator: viewOptions.titleRangeSeparator\n  });\n} // Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n\n\nfunction buildTitleFormat(dateProfile) {\n  var currentRangeUnit = dateProfile.currentRangeUnit;\n\n  if (currentRangeUnit === 'year') {\n    return {\n      year: 'numeric'\n    };\n  }\n\n  if (currentRangeUnit === 'month') {\n    return {\n      year: 'numeric',\n      month: 'long'\n    }; // like \"September 2014\"\n  }\n\n  var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n\n  if (days !== null && days > 1) {\n    // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n    return {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    };\n  } // one day. longer, like \"September 9 2014\"\n\n\n  return {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric'\n  };\n} // in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\n\n\nvar CalendarDataManager = function () {\n  function CalendarDataManager(props) {\n    var _this = this;\n\n    this.computeOptionsData = memoize(this._computeOptionsData);\n    this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n    this.organizeRawLocales = memoize(organizeRawLocales);\n    this.buildLocale = memoize(buildLocale);\n    this.buildPluginHooks = buildBuildPluginHooks();\n    this.buildDateEnv = memoize(buildDateEnv);\n    this.buildTheme = memoize(buildTheme);\n    this.parseToolbars = memoize(parseToolbars);\n    this.buildViewSpecs = memoize(buildViewSpecs);\n    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n    this.buildViewApi = memoize(buildViewApi);\n    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n    this.buildEventUiBases = memoize(buildEventUiBases);\n    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n    this.buildTitle = memoize(buildTitle);\n    this.emitter = new Emitter();\n    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n    this.currentCalendarOptionsInput = {};\n    this.currentCalendarOptionsRefined = {};\n    this.currentViewOptionsInput = {};\n    this.currentViewOptionsRefined = {};\n    this.currentCalendarOptionsRefiners = {};\n\n    this.getCurrentData = function () {\n      return _this.data;\n    };\n\n    this.dispatch = function (action) {\n      _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n\n    };\n\n    this.props = props;\n    this.actionRunner.pause();\n    var dynamicOptionOverrides = {};\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    this.emitter.setThisContext(props.calendarApi);\n    this.emitter.setOptions(currentViewData.options);\n    var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n    var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n\n    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }; // needs to be after setThisContext\n\n    for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {\n      var callback = _a[_i];\n      callback(calendarContext);\n    } // NOT DRY\n\n\n    var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n    var initialState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      eventSources: eventSources,\n      eventUiBases: {},\n      eventStore: createEmptyEventStore(),\n      renderableEventStore: createEmptyEventStore(),\n      dateSelection: null,\n      eventSelection: '',\n      eventDrag: null,\n      eventResize: null,\n      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n    };\n\n    var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, calendarContext), initialState);\n\n    for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {\n      var reducer = _c[_b];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(initialState, reducer(null, null, contextAndState));\n    }\n\n    if (computeIsLoading(initialState, calendarContext)) {\n      this.emitter.trigger('loading', true); // NOT DRY\n    }\n\n    this.state = initialState;\n    this.updateData();\n    this.actionRunner.resume();\n  }\n\n  CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {\n    var props = this.props;\n    props.optionOverrides = append ? (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, props.optionOverrides), optionOverrides) : optionOverrides;\n    this.actionRunner.request({\n      type: 'NOTHING'\n    });\n  };\n\n  CalendarDataManager.prototype._handleAction = function (action) {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        emitter = _a.emitter;\n\n    var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n    var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n    var currentViewType = reduceViewType(state.currentViewType, action);\n    var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides); // wire things up\n    // TODO: not DRY\n\n    props.calendarApi.currentDataManager = this;\n    emitter.setThisContext(props.calendarApi);\n    emitter.setOptions(currentViewData.options);\n    var calendarContext = {\n      dateEnv: optionsData.dateEnv,\n      options: optionsData.calendarOptions,\n      pluginHooks: optionsData.pluginHooks,\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: emitter,\n      getCurrentData: this.getCurrentData\n    };\n    var currentDate = state.currentDate,\n        dateProfile = state.dateProfile;\n\n    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n      // hack\n      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n    }\n\n    currentDate = reduceCurrentDate(currentDate, action);\n    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n\n    if (action.type === 'PREV' || // TODO: move this logic into DateProfileGenerator\n    action.type === 'NEXT' || // \"\n    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n      currentDate = dateProfile.currentRange.start;\n    }\n\n    var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n    var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n    var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n\n    var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : // try from previous state\n    eventStore;\n\n    var _b = this.buildViewUiProps(calendarContext),\n        eventUiSingleBase = _b.eventUiSingleBase,\n        selectionConfig = _b.selectionConfig; // will memoize obj\n\n\n    var eventUiBySource = this.buildEventUiBySource(eventSources);\n    var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n    var newState = {\n      dynamicOptionOverrides: dynamicOptionOverrides,\n      currentViewType: currentViewType,\n      currentDate: currentDate,\n      dateProfile: dateProfile,\n      eventSources: eventSources,\n      eventStore: eventStore,\n      renderableEventStore: renderableEventStore,\n      selectionConfig: selectionConfig,\n      eventUiBases: eventUiBases,\n      businessHours: this.parseContextBusinessHours(calendarContext),\n      dateSelection: reduceDateSelection(state.dateSelection, action),\n      eventSelection: reduceSelectedEvent(state.eventSelection, action),\n      eventDrag: reduceEventDrag(state.eventDrag, action),\n      eventResize: reduceEventResize(state.eventResize, action)\n    };\n\n    var contextAndState = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, calendarContext), newState);\n\n    for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {\n      var reducer = _c[_i];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n\n    }\n\n    var wasLoading = computeIsLoading(state, calendarContext);\n    var isLoading = computeIsLoading(newState, calendarContext); // TODO: use propSetHandlers in plugin system\n\n    if (!wasLoading && isLoading) {\n      emitter.trigger('loading', true);\n    } else if (wasLoading && !isLoading) {\n      emitter.trigger('loading', false);\n    }\n\n    this.state = newState;\n\n    if (props.onAction) {\n      props.onAction(action);\n    }\n  };\n\n  CalendarDataManager.prototype.updateData = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var oldData = this.data;\n    var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n    var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n\n    var data = this.data = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n      calendarApi: props.calendarApi,\n      dispatch: this.dispatch,\n      emitter: this.emitter,\n      getCurrentData: this.getCurrentData\n    }, optionsData), currentViewData), state);\n\n    var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n    var oldCalendarOptions = oldData && oldData.calendarOptions;\n    var newCalendarOptions = optionsData.calendarOptions;\n\n    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n        // hack\n        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n      }\n\n      for (var optionName in changeHandlers) {\n        if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n          changeHandlers[optionName](newCalendarOptions[optionName], data);\n        }\n      }\n    }\n\n    if (props.onData) {\n      props.onData(data);\n    }\n  };\n\n  CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {\n    // TODO: blacklist options that are handled by optionChangeHandlers\n    var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        pluginHooks = _a.pluginHooks,\n        localeDefaults = _a.localeDefaults,\n        availableLocaleData = _a.availableLocaleData,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n    var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    var theme = this.buildTheme(refinedOptions, pluginHooks);\n    var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n    return {\n      calendarOptions: refinedOptions,\n      pluginHooks: pluginHooks,\n      dateEnv: dateEnv,\n      viewSpecs: viewSpecs,\n      theme: theme,\n      toolbarConfig: toolbarConfig,\n      localeDefaults: localeDefaults,\n      availableRawLocales: availableLocaleData.map\n    };\n  }; // always called from behind a memoizer\n\n\n  CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {\n    var _a = mergeRawOptions([BASE_OPTION_DEFAULTS, optionOverrides, dynamicOptionOverrides]),\n        locales = _a.locales,\n        locale = _a.locale;\n\n    var availableLocaleData = this.organizeRawLocales(locales);\n    var availableRawLocales = availableLocaleData.map;\n    var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n    var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n\n    var refiners = this.currentCalendarOptionsRefiners = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var extra = {};\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, localeDefaults, optionOverrides, dynamicOptionOverrides]);\n    var refined = {};\n    var currentRaw = this.currentCalendarOptionsInput;\n    var currentRefined = this.currentCalendarOptionsRefined;\n    var anyChanges = false;\n\n    for (var optionName in raw) {\n      if (optionName !== 'plugins') {\n        // because plugins is special-cased\n        if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n          refined[optionName] = currentRefined[optionName];\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n          anyChanges = true;\n        } else {\n          extra[optionName] = currentRaw[optionName];\n        }\n      }\n    }\n\n    if (anyChanges) {\n      this.currentCalendarOptionsInput = raw;\n      this.currentCalendarOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentCalendarOptionsInput,\n      refinedOptions: this.currentCalendarOptionsRefined,\n      pluginHooks: pluginHooks,\n      availableLocaleData: availableLocaleData,\n      localeDefaults: localeDefaults,\n      extra: extra\n    };\n  };\n\n  CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n    var viewSpec = optionsData.viewSpecs[viewType];\n\n    if (!viewSpec) {\n      throw new Error(\"viewType \\\"\" + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n    }\n\n    var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides),\n        refinedOptions = _a.refinedOptions,\n        extra = _a.extra;\n\n    warnUnknownOptions(extra);\n    var dateProfileGenerator = this.buildDateProfileGenerator({\n      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n      duration: viewSpec.duration,\n      durationUnit: viewSpec.durationUnit,\n      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n      dateEnv: optionsData.dateEnv,\n      calendarApi: this.props.calendarApi,\n      slotMinTime: refinedOptions.slotMinTime,\n      slotMaxTime: refinedOptions.slotMaxTime,\n      showNonCurrentDates: refinedOptions.showNonCurrentDates,\n      dayCount: refinedOptions.dayCount,\n      dateAlignment: refinedOptions.dateAlignment,\n      dateIncrement: refinedOptions.dateIncrement,\n      hiddenDays: refinedOptions.hiddenDays,\n      weekends: refinedOptions.weekends,\n      nowInput: refinedOptions.now,\n      validRangeInput: refinedOptions.validRange,\n      visibleRangeInput: refinedOptions.visibleRange,\n      monthMode: refinedOptions.monthMode,\n      fixedWeekCount: refinedOptions.fixedWeekCount\n    });\n    var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n    return {\n      viewSpec: viewSpec,\n      options: refinedOptions,\n      dateProfileGenerator: dateProfileGenerator,\n      viewApi: viewApi\n    };\n  };\n\n  CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n    var raw = mergeRawOptions([BASE_OPTION_DEFAULTS, viewSpec.optionDefaults, localeDefaults, optionOverrides, viewSpec.optionOverrides, dynamicOptionOverrides]);\n\n    var refiners = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n\n    var refined = {};\n    var currentRaw = this.currentViewOptionsInput;\n    var currentRefined = this.currentViewOptionsRefined;\n    var anyChanges = false;\n    var extra = {};\n\n    for (var optionName in raw) {\n      if (raw[optionName] === currentRaw[optionName]) {\n        refined[optionName] = currentRefined[optionName];\n      } else {\n        if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {\n          if (optionName in this.currentCalendarOptionsRefined) {\n            // might be an \"extra\" prop\n            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n          }\n        } else if (refiners[optionName]) {\n          refined[optionName] = refiners[optionName](raw[optionName]);\n        } else {\n          extra[optionName] = raw[optionName];\n        }\n\n        anyChanges = true;\n      }\n    }\n\n    if (anyChanges) {\n      this.currentViewOptionsInput = raw;\n      this.currentViewOptionsRefined = refined;\n    }\n\n    return {\n      rawOptions: this.currentViewOptionsInput,\n      refinedOptions: this.currentViewOptionsRefined,\n      extra: extra\n    };\n  };\n\n  return CalendarDataManager;\n}();\n\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n  var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n  return new DateEnv({\n    calendarSystem: 'gregory',\n    timeZone: timeZone,\n    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n    locale: locale,\n    weekNumberCalculation: weekNumberCalculation,\n    firstDay: firstDay,\n    weekText: weekText,\n    cmdFormatter: pluginHooks.cmdFormatter,\n    defaultSeparator: defaultSeparator\n  });\n}\n\nfunction buildTheme(options, pluginHooks) {\n  var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n  return new ThemeClass(options);\n}\n\nfunction buildDateProfileGenerator(props) {\n  var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n  return new DateProfileGeneratorClass(props);\n}\n\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n  return new ViewApi(type, getCurrentData, dateEnv);\n}\n\nfunction buildEventUiBySource(eventSources) {\n  return mapHash(eventSources, function (eventSource) {\n    return eventSource.ui;\n  });\n}\n\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n  var eventUiBases = {\n    '': eventUiSingleBase\n  };\n\n  for (var defId in eventDefs) {\n    var def = eventDefs[defId];\n\n    if (def.sourceId && eventUiBySource[def.sourceId]) {\n      eventUiBases[defId] = eventUiBySource[def.sourceId];\n    }\n  }\n\n  return eventUiBases;\n}\n\nfunction buildViewUiProps(calendarContext) {\n  var options = calendarContext.options;\n  return {\n    eventUiSingleBase: createEventUi({\n      display: options.eventDisplay,\n      editable: options.editable,\n      startEditable: options.eventStartEditable,\n      durationEditable: options.eventDurationEditable,\n      constraint: options.eventConstraint,\n      overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n      allow: options.eventAllow,\n      backgroundColor: options.eventBackgroundColor,\n      borderColor: options.eventBorderColor,\n      textColor: options.eventTextColor,\n      color: options.eventColor // classNames: options.eventClassNames // render hook will handle this\n\n    }, calendarContext),\n    selectionConfig: createEventUi({\n      constraint: options.selectConstraint,\n      overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n      allow: options.selectAllow\n    }, calendarContext)\n  };\n}\n\nfunction computeIsLoading(state, context) {\n  for (var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++) {\n    var isLoadingFunc = _a[_i];\n\n    if (isLoadingFunc(state)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction parseContextBusinessHours(calendarContext) {\n  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\n\nfunction warnUnknownOptions(options, viewName) {\n  for (var optionName in options) {\n    console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : ''));\n  }\n} // TODO: move this to react plugin?\n\n\nvar CalendarDataProvider = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarDataProvider, _super);\n\n  function CalendarDataProvider(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.handleData = function (data) {\n      if (!_this.dataManager) {\n        // still within initial run, before assignment in constructor\n        // eslint-disable-next-line react/no-direct-mutation-state\n        _this.state = data; // can't use setState yet\n      } else {\n        _this.setState(data);\n      }\n    };\n\n    _this.dataManager = new CalendarDataManager({\n      optionOverrides: props.optionOverrides,\n      calendarApi: props.calendarApi,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  CalendarDataProvider.prototype.render = function () {\n    return this.props.children(this.state);\n  };\n\n  CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {\n    var newOptionOverrides = this.props.optionOverrides;\n\n    if (newOptionOverrides !== prevProps.optionOverrides) {\n      // prevent recursive handleData\n      this.dataManager.resetOptions(newOptionOverrides);\n    }\n  };\n\n  return CalendarDataProvider;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component); // HELPERS\n\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/\n\n\nfunction sliceEvents(props, allDay) {\n  return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\n\nvar NamedTimeZoneImpl = function () {\n  function NamedTimeZoneImpl(timeZoneName) {\n    this.timeZoneName = timeZoneName;\n  }\n\n  return NamedTimeZoneImpl;\n}();\n\nvar SegHierarchy = function () {\n  function SegHierarchy() {\n    // settings\n    this.strictOrder = false;\n    this.allowReslicing = false;\n    this.maxCoord = -1; // -1 means no max\n\n    this.maxStackCnt = -1; // -1 means no max\n\n    this.levelCoords = []; // ordered\n\n    this.entriesByLevel = []; // parallel with levelCoords\n\n    this.stackCnts = {}; // TODO: use better technique!?\n  }\n\n  SegHierarchy.prototype.addSegs = function (inputs) {\n    var hiddenEntries = [];\n\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n      var input = inputs_1[_i];\n      this.insertEntry(input, hiddenEntries);\n    }\n\n    return hiddenEntries;\n  };\n\n  SegHierarchy.prototype.insertEntry = function (entry, hiddenEntries) {\n    var insertion = this.findInsertion(entry);\n\n    if (this.isInsertionValid(insertion, entry)) {\n      this.insertEntryAt(entry, insertion);\n      return 1;\n    }\n\n    return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n  };\n\n  SegHierarchy.prototype.isInsertionValid = function (insertion, entry) {\n    return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n  }; // returns number of new entries inserted\n\n\n  SegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    if (this.allowReslicing && insertion.touchingEntry) {\n      return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.splitEntry = function (entry, barrier, hiddenEntries) {\n    var partCnt = 0;\n    var splitHiddenEntries = [];\n    var entrySpan = entry.span;\n    var barrierSpan = barrier.span;\n\n    if (entrySpan.start < barrierSpan.start) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: entrySpan.start,\n          end: barrierSpan.start\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (entrySpan.end > barrierSpan.end) {\n      partCnt += this.insertEntry({\n        index: entry.index,\n        thickness: entry.thickness,\n        span: {\n          start: barrierSpan.end,\n          end: entrySpan.end\n        }\n      }, splitHiddenEntries);\n    }\n\n    if (partCnt) {\n      hiddenEntries.push.apply(hiddenEntries, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([{\n        index: entry.index,\n        thickness: entry.thickness,\n        span: intersectSpans(barrierSpan, entrySpan) // guaranteed to intersect\n\n      }], splitHiddenEntries));\n      return partCnt;\n    }\n\n    hiddenEntries.push(entry);\n    return 0;\n  };\n\n  SegHierarchy.prototype.insertEntryAt = function (entry, insertion) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    if (insertion.lateral === -1) {\n      // create a new level\n      insertAt(levelCoords, insertion.level, insertion.levelCoord);\n      insertAt(entriesByLevel, insertion.level, [entry]);\n    } else {\n      // insert into existing level\n      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n    }\n\n    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n  };\n\n  SegHierarchy.prototype.findInsertion = function (newEntry) {\n    var _a = this,\n        levelCoords = _a.levelCoords,\n        entriesByLevel = _a.entriesByLevel,\n        strictOrder = _a.strictOrder,\n        stackCnts = _a.stackCnts;\n\n    var levelCnt = levelCoords.length;\n    var candidateCoord = 0;\n    var touchingLevel = -1;\n    var touchingLateral = -1;\n    var touchingEntry = null;\n    var stackCnt = 0;\n\n    for (var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {\n      var trackingCoord = levelCoords[trackingLevel]; // if the current level is past the placed entry, we have found a good empty space and can stop.\n      // if strictOrder, keep finding more lateral intersections.\n\n      if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n        break;\n      }\n\n      var trackingEntries = entriesByLevel[trackingLevel];\n      var trackingEntry = void 0;\n      var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n\n      var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n\n      while ( // loop through entries that horizontally intersect\n      (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n      trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n      ) {\n        var trackingEntryBottom = trackingCoord + trackingEntry.thickness; // intersects into the top of the candidate?\n\n        if (trackingEntryBottom > candidateCoord) {\n          candidateCoord = trackingEntryBottom;\n          touchingEntry = trackingEntry;\n          touchingLevel = trackingLevel;\n          touchingLateral = lateralIndex;\n        } // butts up against top of candidate? (will happen if just intersected as well)\n\n\n        if (trackingEntryBottom === candidateCoord) {\n          // accumulate the highest possible stackCnt of the trackingEntries that butt up\n          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n        }\n\n        lateralIndex += 1;\n      }\n    } // the destination level will be after touchingEntry's level. find it\n\n\n    var destLevel = 0;\n\n    if (touchingEntry) {\n      destLevel = touchingLevel + 1;\n\n      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {\n        destLevel += 1;\n      }\n    } // if adding to an existing level, find where to insert\n\n\n    var destLateral = -1;\n\n    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n    }\n\n    return {\n      touchingLevel: touchingLevel,\n      touchingLateral: touchingLateral,\n      touchingEntry: touchingEntry,\n      stackCnt: stackCnt,\n      levelCoord: candidateCoord,\n      level: destLevel,\n      lateral: destLateral\n    };\n  }; // sorted by levelCoord (lowest to highest)\n\n\n  SegHierarchy.prototype.toRects = function () {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        levelCoords = _a.levelCoords;\n\n    var levelCnt = entriesByLevel.length;\n    var rects = [];\n\n    for (var level = 0; level < levelCnt; level += 1) {\n      var entries = entriesByLevel[level];\n      var levelCoord = levelCoords[level];\n\n      for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n        var entry = entries_1[_i];\n        rects.push((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, entry), {\n          levelCoord: levelCoord\n        }));\n      }\n    }\n\n    return rects;\n  };\n\n  return SegHierarchy;\n}();\n\nfunction getEntrySpanEnd(entry) {\n  return entry.span.end;\n}\n\nfunction buildEntryKey(entry) {\n  return entry.index + ':' + entry.span.start;\n} // returns groups with entries sorted by input order\n\n\nfunction groupIntersectingEntries(entries) {\n  var merges = [];\n\n  for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {\n    var entry = entries_2[_i];\n    var filteredMerges = [];\n    var hungryMerge = {\n      span: entry.span,\n      entries: [entry]\n    };\n\n    for (var _a = 0, merges_1 = merges; _a < merges_1.length; _a++) {\n      var merge = merges_1[_a];\n\n      if (intersectSpans(merge.span, hungryMerge.span)) {\n        hungryMerge = {\n          entries: merge.entries.concat(hungryMerge.entries),\n          span: joinSpans(merge.span, hungryMerge.span)\n        };\n      } else {\n        filteredMerges.push(merge);\n      }\n    }\n\n    filteredMerges.push(hungryMerge);\n    merges = filteredMerges;\n  }\n\n  return merges;\n}\n\nfunction joinSpans(span0, span1) {\n  return {\n    start: Math.min(span0.start, span1.start),\n    end: Math.max(span0.end, span1.end)\n  };\n}\n\nfunction intersectSpans(span0, span1) {\n  var start = Math.max(span0.start, span1.start);\n  var end = Math.min(span0.end, span1.end);\n\n  if (start < end) {\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  return null;\n} // general util\n// ---------------------------------------------------------------------------------------------------------------------\n\n\nfunction insertAt(arr, index, item) {\n  arr.splice(index, 0, item);\n}\n\nfunction binarySearch(a, searchVal, getItemVal) {\n  var startIndex = 0;\n  var endIndex = a.length; // exclusive\n\n  if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n    // no items OR before first item\n    return [0, 0];\n  }\n\n  if (searchVal > getItemVal(a[endIndex - 1])) {\n    // after last item\n    return [endIndex, 0];\n  }\n\n  while (startIndex < endIndex) {\n    var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n    var middleVal = getItemVal(a[middleIndex]);\n\n    if (searchVal < middleVal) {\n      endIndex = middleIndex;\n    } else if (searchVal > middleVal) {\n      startIndex = middleIndex + 1;\n    } else {\n      // equal!\n      return [middleIndex, 1];\n    }\n  }\n\n  return [startIndex, 0];\n}\n\nvar Interaction = function () {\n  function Interaction(settings) {\n    this.component = settings.component;\n    this.isHitComboAllowed = settings.isHitComboAllowed || null;\n  }\n\n  Interaction.prototype.destroy = function () {};\n\n  return Interaction;\n}();\n\nfunction parseInteractionSettings(component, input) {\n  return {\n    component: component,\n    el: input.el,\n    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n    isHitComboAllowed: input.isHitComboAllowed || null\n  };\n}\n\nfunction interactionSettingsToStore(settings) {\n  var _a;\n\n  return _a = {}, _a[settings.component.uid] = settings, _a;\n} // global state\n\n\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/\n\nvar ElementDragging = function () {\n  function ElementDragging(el, selector) {\n    this.emitter = new Emitter();\n  }\n\n  ElementDragging.prototype.destroy = function () {};\n\n  ElementDragging.prototype.setMirrorIsVisible = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {// optional if subclass doesn't want to support a mirror\n  };\n\n  ElementDragging.prototype.setAutoScrollEnabled = function (bool) {// optional\n  };\n\n  return ElementDragging;\n}(); // TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\n\n\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/\n\nvar DRAG_META_REFINERS = {\n  startTime: createDuration,\n  duration: createDuration,\n  create: Boolean,\n  sourceId: String\n};\n\nfunction parseDragMeta(raw) {\n  var _a = refineProps(raw, DRAG_META_REFINERS),\n      refined = _a.refined,\n      extra = _a.extra;\n\n  return {\n    startTime: refined.startTime || null,\n    duration: refined.duration || null,\n    create: refined.create != null ? refined.create : true,\n    sourceId: refined.sourceId,\n    leftoverProps: extra\n  };\n}\n\nvar ToolbarSection = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ToolbarSection, _super);\n\n  function ToolbarSection() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarSection.prototype.render = function () {\n    var _this = this;\n\n    var children = this.props.widgetGroups.map(function (widgetGroup) {\n      return _this.renderWidgetGroup(widgetGroup);\n    });\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['div', {\n      className: 'fc-toolbar-chunk'\n    }], children));\n  };\n\n  ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {\n    var props = this.props;\n    var theme = this.context.theme;\n    var children = [];\n    var isOnlyButtons = true;\n\n    for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {\n      var widget = widgetGroup_1[_i];\n      var buttonName = widget.buttonName,\n          buttonClick = widget.buttonClick,\n          buttonText = widget.buttonText,\n          buttonIcon = widget.buttonIcon;\n\n      if (buttonName === 'title') {\n        isOnlyButtons = false;\n        children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"h2\", {\n          className: \"fc-toolbar-title\"\n        }, props.title));\n      } else {\n        var ariaAttrs = buttonIcon ? {\n          'aria-label': buttonName\n        } : {};\n        var buttonClasses = [\"fc-\" + buttonName + \"-button\", theme.getClass('button')];\n\n        if (buttonName === props.activeButton) {\n          buttonClasses.push(theme.getClass('buttonActive'));\n        }\n\n        var isDisabled = !props.isTodayEnabled && buttonName === 'today' || !props.isPrevEnabled && buttonName === 'prev' || !props.isNextEnabled && buttonName === 'next';\n        children.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"button\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          disabled: isDisabled,\n          className: buttonClasses.join(' '),\n          onClick: buttonClick,\n          type: \"button\"\n        }, ariaAttrs), buttonText || (buttonIcon ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n          className: buttonIcon\n        }) : '')));\n      }\n    }\n\n    if (children.length > 1) {\n      var groupClassName = isOnlyButtons && theme.getClass('buttonGroup') || '';\n      return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['div', {\n        className: groupClassName\n      }], children));\n    }\n\n    return children[0];\n  };\n\n  return ToolbarSection;\n}(BaseComponent);\n\nvar Toolbar = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Toolbar, _super);\n\n  function Toolbar() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Toolbar.prototype.render = function () {\n    var _a = this.props,\n        model = _a.model,\n        extraClassName = _a.extraClassName;\n    var forceLtr = false;\n    var startContent;\n    var endContent;\n    var centerContent = model.center;\n\n    if (model.left) {\n      forceLtr = true;\n      startContent = model.left;\n    } else {\n      startContent = model.start;\n    }\n\n    if (model.right) {\n      forceLtr = true;\n      endContent = model.right;\n    } else {\n      endContent = model.end;\n    }\n\n    var classNames = [extraClassName || '', 'fc-toolbar', forceLtr ? 'fc-toolbar-ltr' : ''];\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: classNames.join(' ')\n    }, this.renderSection('start', startContent || []), this.renderSection('center', centerContent || []), this.renderSection('end', endContent || []));\n  };\n\n  Toolbar.prototype.renderSection = function (key, widgetGroups) {\n    var props = this.props;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ToolbarSection, {\n      key: key,\n      widgetGroups: widgetGroups,\n      title: props.title,\n      activeButton: props.activeButton,\n      isTodayEnabled: props.isTodayEnabled,\n      isPrevEnabled: props.isPrevEnabled,\n      isNextEnabled: props.isNextEnabled\n    });\n  };\n\n  return Toolbar;\n}(BaseComponent); // TODO: do function component?\n\n\nvar ViewContainer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ViewContainer, _super);\n\n  function ViewContainer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      availableWidth: null\n    };\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n\n      _this.updateAvailableWidth();\n    };\n\n    _this.handleResize = function () {\n      _this.updateAvailableWidth();\n    };\n\n    return _this;\n  }\n\n  ViewContainer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    var aspectRatio = props.aspectRatio;\n    var classNames = ['fc-view-harness', aspectRatio || props.liquid || props.height ? 'fc-view-harness-active' // harness controls the height\n    : 'fc-view-harness-passive' // let the view do the height\n    ];\n    var height = '';\n    var paddingBottom = '';\n\n    if (aspectRatio) {\n      if (state.availableWidth !== null) {\n        height = state.availableWidth / aspectRatio;\n      } else {\n        // while waiting to know availableWidth, we can't set height to *zero*\n        // because will cause lots of unnecessary scrollbars within scrollgrid.\n        // BETTER: don't start rendering ANYTHING yet until we know container width\n        // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n        paddingBottom = 1 / aspectRatio * 100 + \"%\";\n      }\n    } else {\n      height = props.height || '';\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      ref: this.handleEl,\n      onClick: props.onClick,\n      className: classNames.join(' '),\n      style: {\n        height: height,\n        paddingBottom: paddingBottom\n      }\n    }, props.children);\n  };\n\n  ViewContainer.prototype.componentDidMount = function () {\n    this.context.addResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleResize);\n  };\n\n  ViewContainer.prototype.updateAvailableWidth = function () {\n    if (this.el && // needed. but why?\n    this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n    ) {\n      this.setState({\n        availableWidth: this.el.offsetWidth\n      });\n    }\n  };\n\n  return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/\n\n\nvar EventClicking = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventClicking, _super);\n\n  function EventClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handleSegClick = function (ev, segEl) {\n      var component = _this.component;\n      var context = component.context;\n      var seg = getElSeg(segEl);\n\n      if (seg && // might be the <div> surrounding the more link\n      component.isValidSegDownEl(ev.target)) {\n        // our way to simulate a link click for elements that can't be <a> tags\n        // grab before trigger fired in case trigger trashes DOM thru rerendering\n        var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n        var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n        context.emitter.trigger('eventClick', {\n          el: segEl,\n          event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n\n        if (url && !ev.defaultPrevented) {\n          window.location.href = url;\n        }\n      }\n    };\n\n    _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events\n    _this.handleSegClick);\n    return _this;\n  }\n\n  return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/\n\n\nvar EventHovering = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventHovering, _super);\n\n  function EventHovering(settings) {\n    var _this = _super.call(this, settings) || this; // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n\n\n    _this.handleEventElRemove = function (el) {\n      if (el === _this.currentSegEl) {\n        _this.handleSegLeave(null, _this.currentSegEl);\n      }\n    };\n\n    _this.handleSegEnter = function (ev, segEl) {\n      if (getElSeg(segEl)) {\n        // TODO: better way to make sure not hovering over more+ link or its wrapper\n        _this.currentSegEl = segEl;\n\n        _this.triggerEvent('eventMouseEnter', ev, segEl);\n      }\n    };\n\n    _this.handleSegLeave = function (ev, segEl) {\n      if (_this.currentSegEl) {\n        _this.currentSegEl = null;\n\n        _this.triggerEvent('eventMouseLeave', ev, segEl);\n      }\n    };\n\n    _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events\n    _this.handleSegEnter, _this.handleSegLeave);\n    return _this;\n  }\n\n  EventHovering.prototype.destroy = function () {\n    this.removeHoverListeners();\n  };\n\n  EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n    var component = this.component;\n    var context = component.context;\n    var seg = getElSeg(segEl);\n\n    if (!ev || component.isValidSegDownEl(ev.target)) {\n      context.emitter.trigger(publicEvName, {\n        el: segEl,\n        event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n        jsEvent: ev,\n        view: context.viewApi\n      });\n    }\n  };\n\n  return EventHovering;\n}(Interaction);\n\nvar CalendarContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarContent, _super);\n\n  function CalendarContent() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildViewContext = memoize(buildViewContext);\n    _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n    _this.buildToolbarProps = memoize(buildToolbarProps);\n    _this.handleNavLinkClick = buildDelegationHandler('a[data-navlink]', _this._handleNavLinkClick.bind(_this));\n    _this.headerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.footerRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.interactionsStore = {}; // Component Registration\n    // -----------------------------------------------------------------------------------------------------------------\n\n    _this.registerInteractiveComponent = function (component, settingsInput) {\n      var settings = parseInteractionSettings(component, settingsInput);\n      var DEFAULT_INTERACTIONS = [EventClicking, EventHovering];\n      var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n      var interactions = interactionClasses.map(function (TheInteractionClass) {\n        return new TheInteractionClass(settings);\n      });\n      _this.interactionsStore[component.uid] = interactions;\n      interactionSettingsStore[component.uid] = settings;\n    };\n\n    _this.unregisterInteractiveComponent = function (component) {\n      for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n        var listener = _a[_i];\n        listener.destroy();\n      }\n\n      delete _this.interactionsStore[component.uid];\n      delete interactionSettingsStore[component.uid];\n    }; // Resizing\n    // -----------------------------------------------------------------------------------------------------------------\n\n\n    _this.resizeRunner = new DelayedRunner(function () {\n      _this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n\n\n      _this.props.emitter.trigger('windowResize', {\n        view: _this.props.viewApi\n      });\n    });\n\n    _this.handleWindowResize = function (ev) {\n      var options = _this.props.options;\n\n      if (options.handleWindowResize && ev.target === window // avoid jqui events\n      ) {\n        _this.resizeRunner.request(options.windowResizeDelay);\n      }\n    };\n\n    return _this;\n  }\n  /*\n  renders INSIDE of an outer div\n  */\n\n\n  CalendarContent.prototype.render = function () {\n    var props = this.props;\n    var toolbarConfig = props.toolbarConfig,\n        options = props.options;\n    var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????\n    props.viewTitle);\n    var viewVGrow = false;\n    var viewHeight = '';\n    var viewAspectRatio;\n\n    if (props.isHeightAuto || props.forPrint) {\n      viewHeight = '';\n    } else if (options.height != null) {\n      viewVGrow = true;\n    } else if (options.contentHeight != null) {\n      viewHeight = options.contentHeight;\n    } else {\n      viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n    }\n\n    var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Provider, {\n      value: viewContext\n    }, toolbarConfig.headerToolbar && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      ref: this.headerRef,\n      extraClassName: \"fc-header-toolbar\",\n      model: toolbarConfig.headerToolbar\n    }, toolbarProps)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContainer, {\n      liquid: viewVGrow,\n      height: viewHeight,\n      aspectRatio: viewAspectRatio,\n      onClick: this.handleNavLinkClick\n    }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footerToolbar && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Toolbar, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      ref: this.footerRef,\n      extraClassName: \"fc-footer-toolbar\",\n      model: toolbarConfig.footerToolbar\n    }, toolbarProps)));\n  };\n\n  CalendarContent.prototype.componentDidMount = function () {\n    var props = this.props;\n    this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function (CalendarInteractionClass) {\n      return new CalendarInteractionClass(props);\n    });\n    window.addEventListener('resize', this.handleWindowResize);\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      propSetHandlers[propName](props[propName], props);\n    }\n  };\n\n  CalendarContent.prototype.componentDidUpdate = function (prevProps) {\n    var props = this.props;\n    var propSetHandlers = props.pluginHooks.propSetHandlers;\n\n    for (var propName in propSetHandlers) {\n      if (props[propName] !== prevProps[propName]) {\n        propSetHandlers[propName](props[propName], props);\n      }\n    }\n  };\n\n  CalendarContent.prototype.componentWillUnmount = function () {\n    window.removeEventListener('resize', this.handleWindowResize);\n    this.resizeRunner.clear();\n\n    for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n      var interaction = _a[_i];\n      interaction.destroy();\n    }\n\n    this.props.emitter.trigger('_unmount');\n  };\n\n  CalendarContent.prototype._handleNavLinkClick = function (ev, anchorEl) {\n    var _a = this.props,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        calendarApi = _a.calendarApi;\n    var navLinkOptions = anchorEl.getAttribute('data-navlink');\n    navLinkOptions = navLinkOptions ? JSON.parse(navLinkOptions) : {};\n    var dateMarker = dateEnv.createMarker(navLinkOptions.date);\n    var viewType = navLinkOptions.type;\n    var customAction = viewType === 'day' ? options.navLinkDayClick : viewType === 'week' ? options.navLinkWeekClick : null;\n\n    if (typeof customAction === 'function') {\n      customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n    } else {\n      if (typeof customAction === 'string') {\n        viewType = customAction;\n      }\n\n      calendarApi.zoomTo(dateMarker, viewType);\n    }\n  };\n\n  CalendarContent.prototype.buildAppendContent = function () {\n    var props = this.props;\n    var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) {\n      return buildAppendContent(props);\n    });\n    return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}], children));\n  };\n\n  CalendarContent.prototype.renderView = function (props) {\n    var pluginHooks = props.pluginHooks;\n    var viewSpec = props.viewSpec;\n    var viewProps = {\n      dateProfile: props.dateProfile,\n      businessHours: props.businessHours,\n      eventStore: props.renderableEventStore,\n      eventUiBases: props.eventUiBases,\n      dateSelection: props.dateSelection,\n      eventSelection: props.eventSelection,\n      eventDrag: props.eventDrag,\n      eventResize: props.eventResize,\n      isHeightAuto: props.isHeightAuto,\n      forPrint: props.forPrint\n    };\n    var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n\n    for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n      var transformer = transformers_1[_i];\n\n      (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)(viewProps, transformer.transform(viewProps, props));\n    }\n\n    var ViewComponent = viewSpec.component;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewComponent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, viewProps));\n  };\n\n  return CalendarContent;\n}(PureComponent);\n\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n  // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n  var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n\n  var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n  var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n  return {\n    title: title,\n    activeButton: viewSpec.type,\n    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n    isPrevEnabled: prevInfo.isValid,\n    isNextEnabled: nextInfo.isValid\n  };\n} // Plugin\n// -----------------------------------------------------------------------------------------------------------------\n\n\nfunction buildViewPropTransformers(theClasses) {\n  return theClasses.map(function (TheClass) {\n    return new TheClass();\n  });\n}\n\nvar CalendarRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CalendarRoot, _super);\n\n  function CalendarRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      forPrint: false\n    };\n\n    _this.handleBeforePrint = function () {\n      _this.setState({\n        forPrint: true\n      });\n    };\n\n    _this.handleAfterPrint = function () {\n      _this.setState({\n        forPrint: false\n      });\n    };\n\n    return _this;\n  }\n\n  CalendarRoot.prototype.render = function () {\n    var props = this.props;\n    var options = props.options;\n    var forPrint = this.state.forPrint;\n    var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n    var height = !isHeightAuto && options.height != null ? options.height : '';\n    var classNames = ['fc', forPrint ? 'fc-media-print' : 'fc-media-screen', \"fc-direction-\" + options.direction, props.theme.getClass('root')];\n\n    if (!getCanVGrowWithinCell()) {\n      classNames.push('fc-liquid-hack');\n    }\n\n    return props.children(classNames, height, isHeightAuto, forPrint);\n  };\n\n  CalendarRoot.prototype.componentDidMount = function () {\n    var emitter = this.props.emitter;\n    emitter.on('_beforeprint', this.handleBeforePrint);\n    emitter.on('_afterprint', this.handleAfterPrint);\n  };\n\n  CalendarRoot.prototype.componentWillUnmount = function () {\n    var emitter = this.props.emitter;\n    emitter.off('_beforeprint', this.handleBeforePrint);\n    emitter.off('_afterprint', this.handleAfterPrint);\n  };\n\n  return CalendarRoot;\n}(BaseComponent); // Computes a default column header formatting string if `colFormat` is not explicitly defined\n\n\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n  // if more than one week row, or if there are a lot of columns with not much space,\n  // put just the day numbers will be in each cell\n  if (!datesRepDistinctDays || dayCnt > 10) {\n    return createFormatter({\n      weekday: 'short'\n    }); // \"Sat\"\n  }\n\n  if (dayCnt > 1) {\n    return createFormatter({\n      weekday: 'short',\n      month: 'numeric',\n      day: 'numeric',\n      omitCommas: true\n    }); // \"Sat 11/12\"\n  }\n\n  return createFormatter({\n    weekday: 'long'\n  }); // \"Saturday\"\n}\n\nvar CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n\nfunction renderInner$1(hookProps) {\n  return hookProps.text;\n}\n\nvar TableDateCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDateCell, _super);\n\n  function TableDateCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDateCell.prototype.render = function () {\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        options = _a.options,\n        theme = _a.theme,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n    var text = dateEnv.format(date, props.dayHeaderFormat); // if colCnt is 1, we are already in a day-view and don't need a navlink\n\n    var navLinkAttrs = options.navLinks && !dayMeta.isDisabled && props.colCnt > 1 ? {\n      'data-navlink': buildNavLinkData(date),\n      tabIndex: 0\n    } : {};\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      date: dateEnv.toDate(date),\n      view: viewApi\n    }, props.extraHookProps), {\n      text: text\n    }), dayMeta);\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, !dayMeta.isDisabled && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: innerElRef,\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' ')\n      }, navLinkAttrs), innerContent)));\n    });\n  };\n\n  return TableDateCell;\n}(BaseComponent);\n\nvar TableDowCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDowCell, _super);\n\n  function TableDowCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableDowCell.prototype.render = function () {\n    var props = this.props;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        theme = _a.theme,\n        viewApi = _a.viewApi,\n        options = _a.options;\n    var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n\n    var dateMeta = {\n      dow: props.dow,\n      isDisabled: false,\n      isFuture: false,\n      isPast: false,\n      isToday: false,\n      isOther: false\n    };\n    var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n    var text = dateEnv.format(date, props.dayHeaderFormat);\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      // TODO: make this public?\n      date: date\n    }, dateMeta), {\n      view: viewApi\n    }), props.extraHookProps), {\n      text: text\n    });\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInner$1,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        colSpan: props.colSpan\n      }, props.extraDataAttrs), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-scrollgrid-sync-inner\"\n      }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n        className: ['fc-col-header-cell-cushion', props.isSticky ? 'fc-sticky' : ''].join(' '),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return TableDowCell;\n}(BaseComponent);\n\nvar NowTimer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(NowTimer, _super);\n\n  function NowTimer(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n    _this.initialNowQueriedMs = new Date().valueOf();\n    _this.state = _this.computeTiming().currentState;\n    return _this;\n  }\n\n  NowTimer.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state;\n\n    return props.children(state.nowDate, state.todayRange);\n  };\n\n  NowTimer.prototype.componentDidMount = function () {\n    this.setTimeout();\n  };\n\n  NowTimer.prototype.componentDidUpdate = function (prevProps) {\n    if (prevProps.unit !== this.props.unit) {\n      this.clearTimeout();\n      this.setTimeout();\n    }\n  };\n\n  NowTimer.prototype.componentWillUnmount = function () {\n    this.clearTimeout();\n  };\n\n  NowTimer.prototype.computeTiming = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n    var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n    var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n    var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf(); // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n    // ensure no longer than a day\n\n    waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n    return {\n      currentState: {\n        nowDate: currentUnitStart,\n        todayRange: buildDayRange(currentUnitStart)\n      },\n      nextState: {\n        nowDate: nextUnitStart,\n        todayRange: buildDayRange(nextUnitStart)\n      },\n      waitMs: waitMs\n    };\n  };\n\n  NowTimer.prototype.setTimeout = function () {\n    var _this = this;\n\n    var _a = this.computeTiming(),\n        nextState = _a.nextState,\n        waitMs = _a.waitMs;\n\n    this.timeoutId = setTimeout(function () {\n      _this.setState(nextState, function () {\n        _this.setTimeout();\n      });\n    }, waitMs);\n  };\n\n  NowTimer.prototype.clearTimeout = function () {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n    }\n  };\n\n  NowTimer.contextType = ViewContextType;\n  return NowTimer;\n}(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Component);\n\nfunction buildDayRange(date) {\n  var start = startOfDay(date);\n  var end = addDays(start, 1);\n  return {\n    start: start,\n    end: end\n  };\n}\n\nvar DayHeader = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayHeader, _super);\n\n  function DayHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n    return _this;\n  }\n\n  DayHeader.prototype.render = function () {\n    var context = this.context;\n    var _a = this.props,\n        dates = _a.dates,\n        dateProfile = _a.dateProfile,\n        datesRepDistinctDays = _a.datesRepDistinctDays,\n        renderIntro = _a.renderIntro;\n    var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", null, renderIntro && renderIntro('day'), dates.map(function (date) {\n        return datesRepDistinctDays ? (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableDateCell, {\n          key: date.toISOString(),\n          date: date,\n          dateProfile: dateProfile,\n          todayRange: todayRange,\n          colCnt: dates.length,\n          dayHeaderFormat: dayHeaderFormat\n        }) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableDowCell, {\n          key: date.getUTCDay(),\n          dow: date.getUTCDay(),\n          dayHeaderFormat: dayHeaderFormat\n        });\n      }));\n    });\n  };\n\n  return DayHeader;\n}(BaseComponent);\n\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\n\nvar DaySeriesModel = function () {\n  function DaySeriesModel(range, dateProfileGenerator) {\n    var date = range.start;\n    var end = range.end;\n    var indices = [];\n    var dates = [];\n    var dayIndex = -1;\n\n    while (date < end) {\n      // loop each day from start to end\n      if (dateProfileGenerator.isHiddenDay(date)) {\n        indices.push(dayIndex + 0.5); // mark that it's between indices\n      } else {\n        dayIndex += 1;\n        indices.push(dayIndex);\n        dates.push(date);\n      }\n\n      date = addDays(date, 1);\n    }\n\n    this.dates = dates;\n    this.indices = indices;\n    this.cnt = dates.length;\n  }\n\n  DaySeriesModel.prototype.sliceRange = function (range) {\n    var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n\n    var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n\n    var clippedFirstIndex = Math.max(0, firstIndex);\n    var clippedLastIndex = Math.min(this.cnt - 1, lastIndex); // deal with in-between indices\n\n    clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n\n    clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n\n    if (clippedFirstIndex <= clippedLastIndex) {\n      return {\n        firstIndex: clippedFirstIndex,\n        lastIndex: clippedLastIndex,\n        isStart: firstIndex === clippedFirstIndex,\n        isEnd: lastIndex === clippedLastIndex\n      };\n    }\n\n    return null;\n  }; // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n  // If before the first offset, returns a negative number.\n  // If after the last offset, returns an offset past the last cell offset.\n  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n\n\n  DaySeriesModel.prototype.getDateDayIndex = function (date) {\n    var indices = this.indices;\n    var dayOffset = Math.floor(diffDays(this.dates[0], date));\n\n    if (dayOffset < 0) {\n      return indices[0] - 1;\n    }\n\n    if (dayOffset >= indices.length) {\n      return indices[indices.length - 1] + 1;\n    }\n\n    return indices[dayOffset];\n  };\n\n  return DaySeriesModel;\n}();\n\nvar DayTableModel = function () {\n  function DayTableModel(daySeries, breakOnWeeks) {\n    var dates = daySeries.dates;\n    var daysPerRow;\n    var firstDay;\n    var rowCnt;\n\n    if (breakOnWeeks) {\n      // count columns until the day-of-week repeats\n      firstDay = dates[0].getUTCDay();\n\n      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {\n        if (dates[daysPerRow].getUTCDay() === firstDay) {\n          break;\n        }\n      }\n\n      rowCnt = Math.ceil(dates.length / daysPerRow);\n    } else {\n      rowCnt = 1;\n      daysPerRow = dates.length;\n    }\n\n    this.rowCnt = rowCnt;\n    this.colCnt = daysPerRow;\n    this.daySeries = daySeries;\n    this.cells = this.buildCells();\n    this.headerDates = this.buildHeaderDates();\n  }\n\n  DayTableModel.prototype.buildCells = function () {\n    var rows = [];\n\n    for (var row = 0; row < this.rowCnt; row += 1) {\n      var cells = [];\n\n      for (var col = 0; col < this.colCnt; col += 1) {\n        cells.push(this.buildCell(row, col));\n      }\n\n      rows.push(cells);\n    }\n\n    return rows;\n  };\n\n  DayTableModel.prototype.buildCell = function (row, col) {\n    var date = this.daySeries.dates[row * this.colCnt + col];\n    return {\n      key: date.toISOString(),\n      date: date\n    };\n  };\n\n  DayTableModel.prototype.buildHeaderDates = function () {\n    var dates = [];\n\n    for (var col = 0; col < this.colCnt; col += 1) {\n      dates.push(this.cells[0][col].date);\n    }\n\n    return dates;\n  };\n\n  DayTableModel.prototype.sliceRange = function (range) {\n    var colCnt = this.colCnt;\n    var seriesSeg = this.daySeries.sliceRange(range);\n    var segs = [];\n\n    if (seriesSeg) {\n      var firstIndex = seriesSeg.firstIndex,\n          lastIndex = seriesSeg.lastIndex;\n      var index = firstIndex;\n\n      while (index <= lastIndex) {\n        var row = Math.floor(index / colCnt);\n        var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n        segs.push({\n          row: row,\n          firstCol: index % colCnt,\n          lastCol: (nextIndex - 1) % colCnt,\n          isStart: seriesSeg.isStart && index === firstIndex,\n          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n        });\n        index = nextIndex;\n      }\n    }\n\n    return segs;\n  };\n\n  return DayTableModel;\n}();\n\nvar Slicer = function () {\n  function Slicer() {\n    this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n    this.sliceDateSelection = memoize(this._sliceDateSpan);\n    this.sliceEventStore = memoize(this._sliceEventStore);\n    this.sliceEventDrag = memoize(this._sliceInteraction);\n    this.sliceEventResize = memoize(this._sliceInteraction);\n    this.forceDayIfListItem = false; // hack\n  }\n\n  Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    var eventUiBases = props.eventUiBases;\n    var eventSegs = this.sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));\n    return {\n      dateSelectionSegs: this.sliceDateSelection.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.dateSelection, eventUiBases, context], extraArgs)),\n      businessHourSegs: this.sliceBusinessHours.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),\n      fgEventSegs: eventSegs.fg,\n      bgEventSegs: eventSegs.bg,\n      eventDrag: this.sliceEventDrag.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventResize: this.sliceEventResize.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n      eventSelection: props.eventSelection\n    }; // TODO: give interactionSegs?\n  };\n\n  Slicer.prototype.sliceNowDate = function ( // does not memoize\n  date, context) {\n    var extraArgs = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      extraArgs[_i - 2] = arguments[_i];\n    }\n\n    return this._sliceDateSpan.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([{\n      range: {\n        start: date,\n        end: addMs(date, 1)\n      },\n      allDay: false\n    }, {}, context], extraArgs));\n  };\n\n  Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!businessHours) {\n      return [];\n    }\n\n    return this._sliceEventStore.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold], extraArgs)).bg;\n  };\n\n  Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (eventStore) {\n      var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n      return {\n        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n      };\n    }\n\n    return {\n      bg: [],\n      fg: []\n    };\n  };\n\n  Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {\n    var extraArgs = [];\n\n    for (var _i = 4; _i < arguments.length; _i++) {\n      extraArgs[_i - 4] = arguments[_i];\n    }\n\n    if (!interaction) {\n      return null;\n    }\n\n    var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n    return {\n      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n      affectedInstances: interaction.affectedEvents.instances,\n      isEvent: interaction.isEvent\n    };\n  };\n\n  Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {\n    var extraArgs = [];\n\n    for (var _i = 3; _i < arguments.length; _i++) {\n      extraArgs[_i - 3] = arguments[_i];\n    }\n\n    if (!dateSpan) {\n      return [];\n    }\n\n    var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n    var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([dateSpan.range], extraArgs));\n\n    for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n      var seg = segs_1[_a];\n      seg.eventRange = eventRange;\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n    }\n\n    return segs;\n  };\n  /*\n  \"complete\" seg means it has component and eventRange\n  */\n\n\n  Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {\n    var dateRange = eventRange.range; // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n\n    if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n      dateRange = {\n        start: dateRange.start,\n        end: addDays(dateRange.start, 1)\n      };\n    }\n\n    var segs = this.sliceRange.apply(this, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([dateRange], extraArgs));\n\n    for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n      var seg = segs_2[_i];\n      seg.eventRange = eventRange;\n      seg.isStart = eventRange.isStart && seg.isStart;\n      seg.isEnd = eventRange.isEnd && seg.isEnd;\n    }\n\n    return segs;\n  };\n\n  return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/\n\n\nfunction computeActiveRange(dateProfile, isComponentAllDay) {\n  var range = dateProfile.activeRange;\n\n  if (isComponentAllDay) {\n    return range;\n  }\n\n  return {\n    start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n    end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5) // 864e5 = ms in a day\n\n  };\n} // high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionValid(interaction, dateProfile, context) {\n  var instances = interaction.mutatedEvents.instances;\n\n  for (var instanceId in instances) {\n    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n      return false;\n    }\n  }\n\n  return isNewPropsValid({\n    eventDrag: interaction\n  }, context); // HACK: the eventDrag props is used for ALL interactions\n}\n\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n    return false;\n  }\n\n  return isNewPropsValid({\n    dateSelection: dateSelection\n  }, context);\n}\n\nfunction isNewPropsValid(newProps, context) {\n  var calendarState = context.getCurrentData();\n\n  var props = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    businessHours: calendarState.businessHours,\n    dateSelection: '',\n    eventStore: calendarState.eventStore,\n    eventUiBases: calendarState.eventUiBases,\n    eventSelection: '',\n    eventDrag: null,\n    eventResize: null\n  }, newProps);\n\n  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\n\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n  if (dateSpanMeta === void 0) {\n    dateSpanMeta = {};\n  }\n\n  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n    return false;\n  }\n\n  return true;\n} // Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var currentState = context.getCurrentData();\n  var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n\n  var subjectEventStore = interaction.mutatedEvents;\n  var subjectDefs = subjectEventStore.defs;\n  var subjectInstances = subjectEventStore.instances;\n  var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n    '': currentState.selectionConfig\n  });\n\n  if (filterConfig) {\n    subjectConfigs = mapHash(subjectConfigs, filterConfig);\n  } // exclude the subject events. TODO: exclude defs too?\n\n\n  var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n  var otherDefs = otherEventStore.defs;\n  var otherInstances = otherEventStore.instances;\n  var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n\n  for (var subjectInstanceId in subjectInstances) {\n    var subjectInstance = subjectInstances[subjectInstanceId];\n    var subjectRange = subjectInstance.range;\n    var subjectConfig = subjectConfigs[subjectInstance.defId];\n    var subjectDef = subjectDefs[subjectInstance.defId]; // constraint\n\n    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n      return false;\n    } // overlap\n\n\n    var eventOverlap = context.options.eventOverlap;\n    var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n\n    for (var otherInstanceId in otherInstances) {\n      var otherInstance = otherInstances[otherInstanceId]; // intersect! evaluate\n\n      if (rangesIntersect(subjectRange, otherInstance.range)) {\n        var otherOverlap = otherConfigs[otherInstance.defId].overlap; // consider the other event's overlap. only do this if the subject event is a \"real\" event\n\n        if (otherOverlap === false && interaction.isEvent) {\n          return false;\n        }\n\n        if (subjectConfig.overlap === false) {\n          return false;\n        }\n\n        if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event\n        new EventApi(context, subjectDef, subjectInstance))) {\n          return false;\n        }\n      }\n    } // allow (a function)\n\n\n    var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n\n    for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n      var subjectAllow = _a[_i];\n\n      var subjectDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dateSpanMeta), {\n        range: subjectInstance.range,\n        allDay: subjectDef.allDay\n      });\n\n      var origDef = calendarEventStore.defs[subjectDef.defId];\n      var origInstance = calendarEventStore.instances[subjectInstanceId];\n      var eventApi = void 0;\n\n      if (origDef) {\n        // was previously in the calendar\n        eventApi = new EventApi(context, origDef, origInstance);\n      } else {\n        // was an external event\n        eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n      }\n\n      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n  var relevantEventStore = state.eventStore;\n  var relevantDefs = relevantEventStore.defs;\n  var relevantInstances = relevantEventStore.instances;\n  var selection = state.dateSelection;\n  var selectionRange = selection.range;\n  var selectionConfig = context.getCurrentData().selectionConfig;\n\n  if (filterConfig) {\n    selectionConfig = filterConfig(selectionConfig);\n  } // constraint\n\n\n  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n    return false;\n  } // overlap\n\n\n  var selectOverlap = context.options.selectOverlap;\n  var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n\n  for (var relevantInstanceId in relevantInstances) {\n    var relevantInstance = relevantInstances[relevantInstanceId]; // intersect! evaluate\n\n    if (rangesIntersect(selectionRange, relevantInstance.range)) {\n      if (selectionConfig.overlap === false) {\n        return false;\n      }\n\n      if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n        return false;\n      }\n    }\n  } // allow (a function)\n\n\n  for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n    var selectionAllow = _a[_i];\n\n    var fullDateSpan = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, dateSpanMeta), selection);\n\n    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n      return false;\n    }\n  }\n\n  return true;\n} // Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\n\n\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n  for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n    var constraint = constraints_1[_i];\n\n    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\notherEventStore, // for if constraint is an even group ID\nbusinessHoursUnexpanded, // for if constraint is 'businessHours'\ncontext) {\n  if (constraint === 'businessHours') {\n    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n  }\n\n  if (typeof constraint === 'string') {\n    // an group ID\n    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) {\n      return eventDef.groupId === constraint;\n    }));\n  }\n\n  if (_typeof(constraint) === 'object' && constraint) {\n    // non-null object\n    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n  }\n\n  return []; // if it's false\n} // TODO: move to event-store file?\n\n\nfunction eventStoreToRanges(eventStore) {\n  var instances = eventStore.instances;\n  var ranges = [];\n\n  for (var instanceId in instances) {\n    ranges.push(instances[instanceId].range);\n  }\n\n  return ranges;\n} // TODO: move to geom file?\n\n\nfunction anyRangesContainRange(outerRanges, innerRange) {\n  for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n    var outerRange = outerRanges_1[_i];\n\n    if (rangeContainsRange(outerRange, innerRange)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n\nvar Scroller = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Scroller, _super);\n\n  function Scroller() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleEl = function (el) {\n      _this.el = el;\n      setRef(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  Scroller.prototype.render = function () {\n    var props = this.props;\n    var liquid = props.liquid,\n        liquidIsAbsolute = props.liquidIsAbsolute;\n    var isAbsolute = liquid && liquidIsAbsolute;\n    var className = ['fc-scroller'];\n\n    if (liquid) {\n      if (liquidIsAbsolute) {\n        className.push('fc-scroller-liquid-absolute');\n      } else {\n        className.push('fc-scroller-liquid');\n      }\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      ref: this.handleEl,\n      className: className.join(' '),\n      style: {\n        overflowX: props.overflowX,\n        overflowY: props.overflowY,\n        left: isAbsolute && -(props.overcomeLeft || 0) || '',\n        right: isAbsolute && -(props.overcomeRight || 0) || '',\n        bottom: isAbsolute && -(props.overcomeBottom || 0) || '',\n        marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || '',\n        marginRight: !isAbsolute && -(props.overcomeRight || 0) || '',\n        marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || '',\n        maxHeight: props.maxHeight || ''\n      }\n    }, props.children);\n  };\n\n  Scroller.prototype.needsXScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return false;\n    } // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().width > realClientWidth) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.needsYScrolling = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return false;\n    } // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n    // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n    // inner-child margins and absolute positioning\n\n\n    var el = this.el;\n    var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n    var children = el.children;\n\n    for (var i = 0; i < children.length; i += 1) {\n      var childEl = children[i];\n\n      if (childEl.getBoundingClientRect().height > realClientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Scroller.prototype.getXScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n      return 0;\n    }\n\n    return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  Scroller.prototype.getYScrollbarWidth = function () {\n    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n      return 0;\n    }\n\n    return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n  };\n\n  return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/\n\n\nvar RefMap = function () {\n  function RefMap(masterCallback) {\n    var _this = this;\n\n    this.masterCallback = masterCallback;\n    this.currentMap = {};\n    this.depths = {};\n    this.callbackMap = {};\n\n    this.handleValue = function (val, key) {\n      var _a = _this,\n          depths = _a.depths,\n          currentMap = _a.currentMap;\n      var removed = false;\n      var added = false;\n\n      if (val !== null) {\n        // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n        removed = key in currentMap;\n        currentMap[key] = val;\n        depths[key] = (depths[key] || 0) + 1;\n        added = true;\n      } else {\n        depths[key] -= 1;\n\n        if (!depths[key]) {\n          delete currentMap[key];\n          delete _this.callbackMap[key];\n          removed = true;\n        }\n      }\n\n      if (_this.masterCallback) {\n        if (removed) {\n          _this.masterCallback(null, String(key));\n        }\n\n        if (added) {\n          _this.masterCallback(val, String(key));\n        }\n      }\n    };\n  }\n\n  RefMap.prototype.createRef = function (key) {\n    var _this = this;\n\n    var refCallback = this.callbackMap[key];\n\n    if (!refCallback) {\n      refCallback = this.callbackMap[key] = function (val) {\n        _this.handleValue(val, String(key));\n      };\n    }\n\n    return refCallback;\n  }; // TODO: check callers that don't care about order. should use getAll instead\n  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n\n\n  RefMap.prototype.collect = function (startIndex, endIndex, step) {\n    return collectFromHash(this.currentMap, startIndex, endIndex, step);\n  };\n\n  RefMap.prototype.getAll = function () {\n    return hashValuesToArray(this.currentMap);\n  };\n\n  return RefMap;\n}();\n\nfunction computeShrinkWidth(chunkEls) {\n  var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n  var largestWidth = 0;\n\n  for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {\n    var shrinkCell = shrinkCells_1[_i];\n    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n  }\n\n  return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\n\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n  return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\n\nfunction getAllowYScrolling(props, sectionConfig) {\n  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n  getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n} // TODO: ONLY use `arg`. force out internal function to use same API\n\n\nfunction renderChunkContent(sectionConfig, chunkConfig, arg) {\n  var expandRows = arg.expandRows;\n  var content = typeof chunkConfig.content === 'function' ? chunkConfig.content(arg) : (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)('table', {\n    className: [chunkConfig.tableClassName, sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : ''].join(' '),\n    style: {\n      minWidth: arg.tableMinWidth,\n      width: arg.clientWidth,\n      height: expandRows ? arg.clientHeight : '' // css `height` on a <table> serves as a min-height\n\n    }\n  }, arg.tableColGroupNode, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)('tbody', {}, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n  return content;\n}\n\nfunction isColPropsEqual(cols0, cols1) {\n  return isArraysEqual(cols0, cols1, isPropsEqual);\n}\n\nfunction renderMicroColGroup(cols, shrinkWidth) {\n  var colNodes = [];\n  /*\n  for ColProps with spans, it would have been great to make a single <col span=\"\">\n  HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n  SOLUTION: making individual <col> elements makes Chrome behave.\n  */\n\n  for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n    var colProps = cols_1[_i];\n    var span = colProps.span || 1;\n\n    for (var i = 0; i < span; i += 1) {\n      colNodes.push((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"col\", {\n        style: {\n          width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || '',\n          minWidth: colProps.minWidth || ''\n        }\n      }));\n    }\n  }\n\n  return _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['colgroup', {}], colNodes));\n}\n\nfunction sanitizeShrinkWidth(shrinkWidth) {\n  /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n  4 accounts for 2 2-pixel borders. TODO: better solution? */\n  return shrinkWidth == null ? 4 : shrinkWidth;\n}\n\nfunction hasShrinkWidth(cols) {\n  for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {\n    var col = cols_2[_i];\n\n    if (col.width === 'shrink') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScrollGridClassNames(liquid, context) {\n  var classNames = ['fc-scrollgrid', context.theme.getClass('table')];\n\n  if (liquid) {\n    classNames.push('fc-scrollgrid-liquid');\n  }\n\n  return classNames;\n}\n\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n  var classNames = ['fc-scrollgrid-section', \"fc-scrollgrid-section-\" + sectionConfig.type, sectionConfig.className // used?\n  ];\n\n  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n    classNames.push('fc-scrollgrid-section-liquid');\n  }\n\n  if (sectionConfig.isSticky) {\n    classNames.push('fc-scrollgrid-section-sticky');\n  }\n\n  return classNames;\n}\n\nfunction renderScrollShim(arg) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-scrollgrid-sticky-shim\",\n    style: {\n      width: arg.clientWidth,\n      minWidth: arg.tableMinWidth\n    }\n  });\n}\n\nfunction getStickyHeaderDates(options) {\n  var stickyHeaderDates = options.stickyHeaderDates;\n\n  if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n    stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyHeaderDates;\n}\n\nfunction getStickyFooterScrollbar(options) {\n  var stickyFooterScrollbar = options.stickyFooterScrollbar;\n\n  if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n    stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n  }\n\n  return stickyFooterScrollbar;\n}\n\nvar SimpleScrollGrid = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(SimpleScrollGrid, _super);\n\n  function SimpleScrollGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.processCols = memoize(function (a) {\n      return a;\n    }, isColPropsEqual); // so we get same `cols` props every time\n    // yucky to memoize VNodes, but much more efficient for consumers\n\n    _this.renderMicroColGroup = memoize(renderMicroColGroup);\n    _this.scrollerRefs = new RefMap();\n    _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n    _this.state = {\n      shrinkWidth: null,\n      forceYScrollbars: false,\n      scrollerClientWidths: {},\n      scrollerClientHeights: {}\n    }; // TODO: can do a really simple print-view. dont need to join rows\n\n    _this.handleSizing = function () {\n      _this.setState((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        shrinkWidth: _this.computeShrinkWidth()\n      }, _this.computeScrollerDims()));\n    };\n\n    return _this;\n  }\n\n  SimpleScrollGrid.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var sectionConfigs = props.sections || [];\n    var cols = this.processCols(props.cols);\n    var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n    var classNames = getScrollGridClassNames(props.liquid, context);\n\n    if (props.collapsibleWidth) {\n      classNames.push('fc-scrollgrid-collapsible');\n    } // TODO: make DRY\n\n\n    var configCnt = sectionConfigs.length;\n    var configI = 0;\n    var currentConfig;\n    var headSectionNodes = [];\n    var bodySectionNodes = [];\n    var footSectionNodes = [];\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode));\n      configI += 1;\n    }\n\n    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode));\n      configI += 1;\n    } // firefox bug: when setting height on table and there is a thead or tfoot,\n    // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n    // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n    // if so, use a simpler dom structure, jam everything into a lone tbody.\n\n\n    var isBuggy = !getCanVGrowWithinCell();\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)('table', {\n      className: classNames.join(' '),\n      style: {\n        height: props.height\n      }\n    }, Boolean(!isBuggy && headSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['thead', {}], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['tbody', {}], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['tfoot', {}], footSectionNodes)), isBuggy && _vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)(['tbody', {}], headSectionNodes), bodySectionNodes), footSectionNodes)));\n  };\n\n  SimpleScrollGrid.prototype.renderSection = function (sectionConfig, microColGroupNode) {\n    if ('outerContent' in sectionConfig) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n        key: sectionConfig.key\n      }, sectionConfig.outerContent);\n    }\n\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n      key: sectionConfig.key,\n      className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ')\n    }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk));\n  };\n\n  SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, microColGroupNode, chunkConfig) {\n    if ('outerContent' in chunkConfig) {\n      return chunkConfig.outerContent;\n    }\n\n    var props = this.props;\n    var _a = this.state,\n        forceYScrollbars = _a.forceYScrollbars,\n        scrollerClientWidths = _a.scrollerClientWidths,\n        scrollerClientHeights = _a.scrollerClientHeights;\n    var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n\n    var isLiquid = getSectionHasLiquidHeight(props, sectionConfig); // for `!props.liquid` - is WHOLE scrollgrid natural height?\n    // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n\n    var overflowY = !props.liquid ? 'visible' : forceYScrollbars ? 'scroll' : !needsYScrolling ? 'hidden' : 'auto';\n    var sectionKey = sectionConfig.key;\n    var content = renderChunkContent(sectionConfig, chunkConfig, {\n      tableColGroupNode: microColGroupNode,\n      tableMinWidth: '',\n      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n      clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n      expandRows: sectionConfig.expandRows,\n      syncRowHeights: false,\n      rowSyncHeights: [],\n      reportRowHeightChange: function reportRowHeightChange() {}\n    });\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n      ref: chunkConfig.elRef\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: \"fc-scroller-harness\" + (isLiquid ? ' fc-scroller-harness-liquid' : '')\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Scroller, {\n      ref: this.scrollerRefs.createRef(sectionKey),\n      elRef: this.scrollerElRefs.createRef(sectionKey),\n      overflowY: overflowY,\n      overflowX: !props.liquid ? 'visible' : 'hidden'\n      /* natural height? */\n      ,\n      maxHeight: sectionConfig.maxHeight,\n      liquid: isLiquid,\n      liquidIsAbsolute // because its within a harness\n      : true\n    }, content)));\n  };\n\n  SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n    var section = getSectionByKey(this.props.sections, key);\n\n    if (section) {\n      setRef(section.chunk.scrollerElRef, scrollerEl);\n    }\n  };\n\n  SimpleScrollGrid.prototype.componentDidMount = function () {\n    this.handleSizing();\n    this.context.addResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.componentDidUpdate = function () {\n    // TODO: need better solution when state contains non-sizing things\n    this.handleSizing();\n  };\n\n  SimpleScrollGrid.prototype.componentWillUnmount = function () {\n    this.context.removeResizeHandler(this.handleSizing);\n  };\n\n  SimpleScrollGrid.prototype.computeShrinkWidth = function () {\n    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n  };\n\n  SimpleScrollGrid.prototype.computeScrollerDims = function () {\n    var scrollbarWidth = getScrollbarWidths();\n\n    var _a = this,\n        scrollerRefs = _a.scrollerRefs,\n        scrollerElRefs = _a.scrollerElRefs;\n\n    var forceYScrollbars = false;\n    var scrollerClientWidths = {};\n    var scrollerClientHeights = {};\n\n    for (var sectionKey in scrollerRefs.currentMap) {\n      var scroller = scrollerRefs.currentMap[sectionKey];\n\n      if (scroller && scroller.needsYScrolling()) {\n        forceYScrollbars = true;\n        break;\n      }\n    }\n\n    for (var _i = 0, _b = this.props.sections; _i < _b.length; _i++) {\n      var section = _b[_i];\n      var sectionKey = section.key;\n      var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n\n      if (scrollerEl) {\n        var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n\n        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n        : 0));\n        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n      }\n    }\n\n    return {\n      forceYScrollbars: forceYScrollbars,\n      scrollerClientWidths: scrollerClientWidths,\n      scrollerClientHeights: scrollerClientHeights\n    };\n  };\n\n  return SimpleScrollGrid;\n}(BaseComponent);\n\nSimpleScrollGrid.addStateEquality({\n  scrollerClientWidths: isPropsEqual,\n  scrollerClientHeights: isPropsEqual\n});\n\nfunction getSectionByKey(sections, key) {\n  for (var _i = 0, sections_1 = sections; _i < sections_1.length; _i++) {\n    var section = sections_1[_i];\n\n    if (section.key === key) {\n      return section;\n    }\n  }\n\n  return null;\n}\n\nvar EventRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(EventRoot, _super);\n\n  function EventRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.elRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  EventRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var seg = props.seg;\n    var eventRange = seg.eventRange;\n    var ui = eventRange.ui;\n    var hookProps = {\n      event: new EventApi(context, eventRange.def, eventRange.instance),\n      view: context.viewApi,\n      timeText: props.timeText,\n      textColor: ui.textColor,\n      backgroundColor: ui.backgroundColor,\n      borderColor: ui.borderColor,\n      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n      isStart: Boolean(seg.isStart),\n      isEnd: Boolean(seg.isEnd),\n      isPast: Boolean(props.isPast),\n      isFuture: Boolean(props.isFuture),\n      isToday: Boolean(props.isToday),\n      isSelected: Boolean(props.isSelected),\n      isDragging: Boolean(props.isDragging),\n      isResizing: Boolean(props.isResizing)\n    };\n    var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.eventClassNames,\n      content: options.eventContent,\n      defaultContent: props.defaultContent,\n      didMount: options.eventDidMount,\n      willUnmount: options.eventWillUnmount,\n      elRef: this.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n    });\n  };\n\n  EventRoot.prototype.componentDidMount = function () {\n    setElSeg(this.elRef.current, this.props.seg);\n  };\n  /*\n  need to re-assign seg to the element if seg changes, even if the element is the same\n  */\n\n\n  EventRoot.prototype.componentDidUpdate = function (prevProps) {\n    var seg = this.props.seg;\n\n    if (seg !== prevProps.seg) {\n      setElSeg(this.elRef.current, seg);\n    }\n  };\n\n  return EventRoot;\n}(BaseComponent); // should not be a purecomponent\n\n\nvar StandardEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(StandardEvent, _super);\n\n  function StandardEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  StandardEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n    var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(EventRoot, {\n      seg: seg,\n      timeText: timeText,\n      disableDragging: props.disableDragging,\n      disableResizing: props.disableResizing,\n      defaultContent: props.defaultContent || renderInnerContent$1,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        className: props.extraClassNames.concat(classNames).join(' '),\n        style: {\n          borderColor: hookProps.borderColor,\n          backgroundColor: hookProps.backgroundColor\n        },\n        ref: rootElRef\n      }, getSegAnchorAttrs(seg)), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-main\",\n        ref: innerElRef,\n        style: {\n          color: hookProps.textColor\n        }\n      }, innerContent), hookProps.isStartResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-start\"\n      }), hookProps.isEndResizable && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-event-resizer fc-event-resizer-end\"\n      }));\n    });\n  };\n\n  return StandardEvent;\n}(BaseComponent);\n\nfunction renderInnerContent$1(innerProps) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-main-frame\"\n  }, innerProps.timeText && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title-container\"\n  }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title fc-sticky\"\n  }, innerProps.event.title || (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xA0\"))));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar NowIndicatorRoot = function NowIndicatorRoot(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n    var options = context.options;\n    var hookProps = {\n      isAxis: props.isAxis,\n      date: context.dateEnv.toDate(props.date),\n      view: context.viewApi\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.nowIndicatorClassNames,\n      content: options.nowIndicatorContent,\n      didMount: options.nowIndicatorDidMount,\n      willUnmount: options.nowIndicatorWillUnmount\n    }, props.children);\n  });\n};\n\nvar DAY_NUM_FORMAT = createFormatter({\n  day: 'numeric'\n});\n\nvar DayCellContent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayCellContent, _super);\n\n  function DayCellContent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayCellContent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = refineDayCellHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ContentHook, {\n      hookProps: hookProps,\n      content: options.dayCellContent,\n      defaultContent: props.defaultContent\n    }, props.children);\n  };\n\n  return DayCellContent;\n}(BaseComponent);\n\nfunction refineDayCellHookProps(raw) {\n  var date = raw.date,\n      dateEnv = raw.dateEnv;\n  var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    date: dateEnv.toDate(date),\n    view: raw.viewApi\n  }, dayMeta), {\n    dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : ''\n  }), raw.extraProps);\n}\n\nvar DayCellRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayCellRoot, _super);\n\n  function DayCellRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    return _this;\n  }\n\n  DayCellRoot.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var options = context.options;\n    var hookProps = this.refineHookProps({\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraProps: props.extraHookProps,\n      viewApi: context.viewApi,\n      dateEnv: context.dateEnv\n    });\n    var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n    : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n    var dataAttrs = hookProps.isDisabled ? {} : {\n      'data-date': formatDayString(props.date)\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MountHook, {\n      hookProps: hookProps,\n      didMount: options.dayCellDidMount,\n      willUnmount: options.dayCellWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef) {\n      return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n    });\n  };\n\n  return DayCellRoot;\n}(BaseComponent);\n\nfunction renderFill(fillType) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-\" + fillType\n  });\n}\n\nvar BgEvent = function BgEvent(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(EventRoot, {\n    defaultContent: renderInnerContent,\n    seg: props.seg\n    /* uselesss i think */\n    ,\n    timeText: \"\",\n    disableDragging: true,\n    disableResizing: true,\n    isDragging: false,\n    isResizing: false,\n    isDateSelecting: false,\n    isSelected: false,\n    isPast: props.isPast,\n    isFuture: props.isFuture,\n    isToday: props.isToday\n  }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      ref: rootElRef,\n      className: ['fc-bg-event'].concat(classNames).join(' '),\n      style: {\n        backgroundColor: hookProps.backgroundColor\n      }\n    }, innerContent);\n  });\n};\n\nfunction renderInnerContent(props) {\n  var title = props.event.title;\n  return title && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title\"\n  }, props.event.title);\n}\n\nvar WeekNumberRoot = function WeekNumberRoot(props) {\n  return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var date = props.date;\n    var format = options.weekNumberFormat || props.defaultFormat;\n    var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n\n    var text = dateEnv.format(date, format);\n    var hookProps = {\n      num: num,\n      text: text,\n      date: date\n    };\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.weekNumberClassNames,\n      content: options.weekNumberContent,\n      defaultContent: renderInner,\n      didMount: options.weekNumberDidMount,\n      willUnmount: options.weekNumberWillUnmount\n    }, props.children);\n  });\n};\n\nfunction renderInner(innerProps) {\n  return innerProps.text;\n}\n\nvar PADDING_FROM_VIEWPORT = 10;\n\nvar Popover = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n\n    _this.handleDocumentMousedown = function (ev) {\n      // only hide the popover if the click happened outside the popover\n      var target = getEventTargetViaRoot(ev);\n\n      if (!_this.rootEl.contains(target)) {\n        _this.handleCloseClick();\n      }\n    };\n\n    _this.handleCloseClick = function () {\n      var onClose = _this.props.onClose;\n\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var theme = this.context.theme;\n    var props = this.props;\n    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createPortal)((0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      className: classNames.join(' ')\n    }, props.extraAttrs, {\n      ref: this.handleRootEl\n    }), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n    }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n      className: \"fc-popover-title\"\n    }, props.title), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n      className: 'fc-popover-close ' + theme.getIconClass('close'),\n      onClick: this.handleCloseClick\n    })), (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: 'fc-popover-body ' + theme.getClass('popoverContent')\n    }, props.children)), props.parentEl);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    document.addEventListener('mousedown', this.handleDocumentMousedown);\n    this.updateSize();\n  };\n\n  Popover.prototype.componentWillUnmount = function () {\n    document.removeEventListener('mousedown', this.handleDocumentMousedown);\n  };\n\n  Popover.prototype.updateSize = function () {\n    var isRtl = this.context.isRtl;\n    var _a = this.props,\n        alignmentEl = _a.alignmentEl,\n        alignGridTop = _a.alignGridTop;\n    var rootEl = this.rootEl;\n    var alignmentRect = computeClippedClientRect(alignmentEl);\n\n    if (alignmentRect) {\n      var popoverDims = rootEl.getBoundingClientRect(); // position relative to viewport\n\n      var popoverTop = alignGridTop ? elementClosest(alignmentEl, '.fc-scrollgrid').getBoundingClientRect().top : alignmentRect.top;\n      var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left; // constrain\n\n      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n      var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n      applyStyle(rootEl, {\n        top: popoverTop - origin_1.top,\n        left: popoverLeft - origin_1.left\n      });\n    }\n  };\n\n  return Popover;\n}(BaseComponent);\n\nvar MorePopover = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MorePopover, _super);\n\n  function MorePopover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          useEventCenter: false\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  MorePopover.prototype.render = function () {\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n    var props = this.props;\n    var startDate = props.startDate,\n        todayRange = props.todayRange,\n        dateProfile = props.dateProfile;\n    var title = dateEnv.format(startDate, options.dayPopoverFormat);\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayCellRoot, {\n      date: startDate,\n      dateProfile: dateProfile,\n      todayRange: todayRange,\n      elRef: this.handleRootEl\n    }, function (rootElRef, dayClassNames, dataAttrs) {\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(Popover, {\n        elRef: rootElRef,\n        title: title,\n        extraClassNames: ['fc-more-popover'].concat(dayClassNames),\n        extraAttrs: dataAttrs\n        /* TODO: make these time-based when not whole-day? */\n        ,\n        parentEl: props.parentEl,\n        alignmentEl: props.alignmentEl,\n        alignGridTop: props.alignGridTop,\n        onClose: props.onClose\n      }, (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayCellContent, {\n        date: startDate,\n        dateProfile: dateProfile,\n        todayRange: todayRange\n      }, function (innerElRef, innerContent) {\n        return innerContent && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n          className: \"fc-more-popover-misc\",\n          ref: innerElRef\n        }, innerContent);\n      }), props.children);\n    });\n  };\n\n  MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var _a = this,\n        rootEl = _a.rootEl,\n        props = _a.props;\n\n    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n      return {\n        dateProfile: props.dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          allDay: true,\n          range: {\n            start: props.startDate,\n            end: props.endDate\n          }\n        }, props.extraDateSpan),\n        dayEl: rootEl,\n        rect: {\n          left: 0,\n          top: 0,\n          right: elWidth,\n          bottom: elHeight\n        },\n        layer: 1 // important when comparing with hits from other components\n\n      };\n    }\n\n    return null;\n  };\n\n  return MorePopover;\n}(DateComponent);\n\nvar MoreLinkRoot = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MoreLinkRoot, _super);\n\n  function MoreLinkRoot() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.linkElRef = (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.state = {\n      isPopoverOpen: false\n    };\n\n    _this.handleClick = function (ev) {\n      var _a = _this,\n          props = _a.props,\n          context = _a.context;\n      var moreLinkClick = context.options.moreLinkClick;\n      var date = computeRange(props).start;\n\n      function buildPublicSeg(seg) {\n        var _a = seg.eventRange,\n            def = _a.def,\n            instance = _a.instance,\n            range = _a.range;\n        return {\n          event: new EventApi(context, def, instance),\n          start: context.dateEnv.toDate(range.start),\n          end: context.dateEnv.toDate(range.end),\n          isStart: seg.isStart,\n          isEnd: seg.isEnd\n        };\n      }\n\n      if (typeof moreLinkClick === 'function') {\n        moreLinkClick = moreLinkClick({\n          date: date,\n          allDay: Boolean(props.allDayDate),\n          allSegs: props.allSegs.map(buildPublicSeg),\n          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n          jsEvent: ev,\n          view: context.viewApi\n        });\n      }\n\n      if (!moreLinkClick || moreLinkClick === 'popover') {\n        _this.setState({\n          isPopoverOpen: true\n        });\n      } else if (typeof moreLinkClick === 'string') {\n        // a view name\n        context.calendarApi.zoomTo(date, moreLinkClick);\n      }\n    };\n\n    _this.handlePopoverClose = function () {\n      _this.setState({\n        isPopoverOpen: false\n      });\n    };\n\n    return _this;\n  }\n\n  MoreLinkRoot.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(ViewContextType.Consumer, null, function (context) {\n      var viewApi = context.viewApi,\n          options = context.options,\n          calendarApi = context.calendarApi;\n      var moreLinkText = options.moreLinkText;\n      var moreCnt = props.moreCnt;\n      var range = computeRange(props);\n      var hookProps = {\n        num: moreCnt,\n        shortText: \"+\" + moreCnt,\n        text: typeof moreLinkText === 'function' ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText,\n        view: viewApi\n      };\n      return (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(_vdom_js__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, Boolean(props.moreCnt) && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(RenderHook, {\n        elRef: _this.linkElRef,\n        hookProps: hookProps,\n        classNames: options.moreLinkClassNames,\n        content: options.moreLinkContent,\n        defaultContent: props.defaultContent || renderMoreLinkInner,\n        didMount: options.moreLinkDidMount,\n        willUnmount: options.moreLinkWillUnmount\n      }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n        return props.children(rootElRef, ['fc-more-link'].concat(customClassNames), innerElRef, innerContent, _this.handleClick);\n      }), _this.state.isPopoverOpen && (0,_vdom_js__WEBPACK_IMPORTED_MODULE_1__.createElement)(MorePopover, {\n        startDate: range.start,\n        endDate: range.end,\n        dateProfile: props.dateProfile,\n        todayRange: props.todayRange,\n        extraDateSpan: props.extraDateSpan,\n        parentEl: _this.parentEl,\n        alignmentEl: props.alignmentElRef.current,\n        alignGridTop: props.alignGridTop,\n        onClose: _this.handlePopoverClose\n      }, props.popoverContent()));\n    });\n  };\n\n  MoreLinkRoot.prototype.componentDidMount = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.componentDidUpdate = function () {\n    this.updateParentEl();\n  };\n\n  MoreLinkRoot.prototype.updateParentEl = function () {\n    if (this.linkElRef.current) {\n      this.parentEl = elementClosest(this.linkElRef.current, '.fc-view-harness');\n    }\n  };\n\n  return MoreLinkRoot;\n}(BaseComponent);\n\nfunction renderMoreLinkInner(props) {\n  return props.text;\n}\n\nfunction computeRange(props) {\n  if (props.allDayDate) {\n    return {\n      start: props.allDayDate,\n      end: addDays(props.allDayDate, 1)\n    };\n  }\n\n  var hiddenSegs = props.hiddenSegs;\n  return {\n    start: computeEarliestSegStart(hiddenSegs),\n    end: computeLatestSegEnd(hiddenSegs)\n  };\n}\n\nfunction computeEarliestSegStart(segs) {\n  return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\n\nfunction pickEarliestStart(seg0, seg1) {\n  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\n\nfunction computeLatestSegEnd(segs) {\n  return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\n\nfunction pickLatestEnd(seg0, seg1) {\n  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n} // exports\n// --------------------------------------------------------------------------------------------------\n\n\nvar version = '5.9.0'; // important to type it, so .d.ts has generic string\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUdBO0FBQUE7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBOztBQUlBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBOzs7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FDM0dBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU1BO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBR0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQWNBOzs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQzdLQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBO0FBTUE7O0FBRUE7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFRQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUdBOztBQUVBOztBQUdBO0FBRUE7QUFDQTs7O0FBSUE7QUFDQTtBQVNBOztBQUVBO0FBQ0E7QUFJQTtBQUlBOztBQUVBO0FBQ0E7QUFTQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7O0FDMU1BO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUMxQkE7QUFHQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBU0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDekxBO0FBTUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7OztBQUlBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOztBQUVBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7Ozs7QUFHQTtBQU9BO0FBQ0E7QUFHQTtBQUNBO0FBRkE7O0FBUUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDeEZBO0FBQ0E7O0FBSUE7OztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUhBO0FBSkE7QUFXQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBUEE7QUFXQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFJQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFHQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBSUE7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FDN05BO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFHQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDbERBO0FBS0E7QUFDQTtBQUVBO0FBQUE7O0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTs7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUtBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQVVBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFNQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBWkE7QUFjQTs7QUFDQTtBQUFBOztBQUVBO0FBS0E7O0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFPQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFLQTs7QUFDQTs7QUFFQTtBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUMxVkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBOztBQ3BCQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUM1QkE7Ozs7QUFJQTs7Ozs7O0FBSUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQ3BCQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FDWkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUN5QkE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwTEE7QUFrTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbERBO0FBMkRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBa0NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUF5QkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUE4QkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFpQ0E7QUFDQTtBQUNBOztBQzljQTtBQU1BO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFBQTtBQUFBOzs7QUFJQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FDTkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTs7QUFxQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBVkE7QUFZQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUdBO0FBREE7O0FBMkJBO0FBS0E7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQU9BO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTs7QUFpQkE7QUFBQTs7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBTEE7QUFPQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQ2xPQTs7QUFHQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBOztBQUdBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUNoSEE7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7OztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTs7QUFEQTtBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBSUE7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFMQTtBQVFBOztBQUVBO0FBQ0E7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFFQTtBQURBO0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQTtBQU1BOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQ2xKQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBSUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQ3REQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFJQTtBQUNBOzs7O0FBS0E7QUFLQTtBQUNBOztBQUVBO0FBR0E7QUFEQTs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFHQTtBQUlBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQzdJQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFGQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUZBOztBQUFBOztBQUlBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBVkE7O0FBa0NBO0FBR0E7QUFBQTtBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUNGQTs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUFBOztBQUFBO0FBQUE7OztBQUNBO0FBQ0E7Ozs7QUFLQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUVBO0FBSUE7OztBQUdBO0FBQ0E7QUFFQTtBQU1BOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUdBO0FBQUE7O0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFSQTtBQVVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOzs7OztBQ3JlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBREE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFEQTtBQWVBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFUQTtBQVdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFSQTtBQVVBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQVZBOztBQUFBO0FBWUE7QUFBQTtBQUNBO0FBR0E7QUFKQTs7QUFBQTtBQU1BO0FBQUE7QUFDQTtBQUdBO0FBSkE7O0FBQUE7QUFNQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUNBO0FBQ0E7QUFUQTs7QUFBQTtBQVdBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTtBQVRBOztBQUFBO0FBYUE7OztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBR0E7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FBRUE7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQU1BOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDeGJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7O0FBRUE7QUN4Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQVVBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOztBQUVBO0FBQ0E7OztBQ2NBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFFQTtBQUtBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBSUE7QUFFQTs7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUtBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQVFBOztBQUVBO0FBSUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFGQTtBQU9BO0FBQ0E7QUFGQTtBQVNBOzs7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBQ0E7QUFBQTs7QUNyY0E7QUN3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7O0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBREE7O0FBSUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFLQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FDakdBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7QUFHQTs7QUFFQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBREE7QUFHQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTkE7QUFTQTs7OztBQUdBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQ3BDQTtBQUNBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FDbEVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXNJQTs7QUFoSUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFNQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQURBOztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTs7QUFFQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzVFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQ05BOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQ3pCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUNmQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTs7QUFVQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FDbElBO0FBQ0E7QUFDQTs7O0FBQ0E7OztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFJQTtBQWdDQTs7QUE5QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4REE7Ozs7Ozs7O0FBZ0JBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUNyR0E7O0FBRUE7Ozs7Ozs7O0FBS0E7O0FBVUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOzs7QUFFQTs7QUFHQTtBQUFBOztBQUVBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUF2Q0E7OztBQXlDQTs7QUFBQTs7QUFnQ0E7O0FBL0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFoQ0E7OztBQy9FQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeEVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBd0JBO0FBQ0E7O0FBQ0E7QUFDQTs7QUF6QkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUNuQ0E7O0FBcUJBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBNUJBO0FBOEJBO0FDcEZBOzs7QUFRQTtBQUFBOztBQUFBOztBQW9CQTs7QUFUQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTs7QUFsQkE7QUFDQTtBQUNBO0FBaUJBO0FBQUE7O0FBRUE7QUFDQTs7O0FBRUE7O0FBQUE7O0FBSUE7O0FBSEE7QUFHQTtBQUFBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQy9CQTs7Ozs7Ozs7OztBQU9BOztBQUFBO0FBQUE7O0FBQ0E7O0FBMkJBOzs7O0FBdEJBOztBQUdBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQTVCQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTs7QUFvQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFtQ0E7O0FDeEpBO0FBQUE7O0FBQUE7O0FBQ0E7O0FBQUE7QUFEQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFNQTtBQUNBOztBQUVBO0FBQUE7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFQQTtBQVlBO0FDaEdBO0FBb0NBOzs7O0FBQ0E7O0FBQUE7QUFBQTs7QUFDQTs7QUFzQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBM0JBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFFQTtBQUdBOztBQVNBO0FBOUJBO0FBNENBOzs7QUFDQTs7QUFpQkE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBR0E7O0FBRUE7QUFBQTs7QUFBQTtBQUFBOztBQUNBOztBQWdHQTs7QUF2RkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQWpHQTs7O0FBMkdBOztBQUFBO0FBQUE7O0FBdUJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQTNCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBU0E7QUE5QkE7O0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQ3JRQTs7QUFBQTtBQUFBOztBQUNBOztBQXNCQTs7QUFwQkE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBR0E7QUFHQTs7QUFDQTtBQXZCQTs7QUNXQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQVFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7QUFEQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUdBO0FBRUE7QUFFQTtBQUNBOztBQzVEQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBT0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUVBOztBQWRBO0FBb0JBOzs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDakVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFHQTtBQUNBOzs7OztBQUtBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBRUE7OztBQUdBOzs7QUFJQTs7QUFHQTtBQUVBOzs7QUFJQTs7O0FBSUE7O0FBR0E7O0FBR0E7QUFFQTs7QUFHQTs7QUEvQkE7QUFrQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBOztBQzViQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7O0FDUEE7OztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUNMQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBbkJBOztBQXNCQTtBQUNBOztBQ3pCQTtBQUNBO0FBRUE7QUFNQTs7QUFFQTtBQU1BOztBQUVBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBbkNBO0FBcUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQU1BOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBRUE7O0FBRUE7QUFPQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFPQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFHQTtBQUVBO0FBQ0E7QUFGQTtBQUlBOztBQUVBOzs7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFJQTtBQUNBO0FBRkE7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUN0UEE7QUFPQTtBQUNBO0FBQUE7QUFDQTs7QUFTQTtBQUFBO0FBQ0E7QUFHQTs7QUFJQTtBQUNBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBakRBO0FBbURBOztBQUVBO0FBUUE7QUFFQTtBQUZBO0FBSUE7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRkE7QUFJQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBUkE7QUFVQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFSQTtBQVVBOztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFkQTtBQWdCQTs7QUNuQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQWRBO0FBZ0JBOztBQ2ZBO0FBT0E7QUFDQTtBQVNBO0FBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBU0E7QUFFQTtBQUFBO0FBRUE7QUFFQTs7Ozs7QUFHQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FDL0dBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQWRBO0FBaUJBO0FBQ0E7QUFEQTtBQ0ZBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQXBCQTtBQXdCQTtBQUNBO0FBREE7O0FDekNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQ2dCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBOUJBO0FBa0NBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUNtQkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQU1BOztBQUNBO0FBQ0E7QUE5Q0E7QUFrREE7QUFDQTtBQUNBO0FBRkE7O0FBS0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQURBO0FBU0E7Ozs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBRUE7QUFEQTtBQUdBOztBQ3FCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FDekJBOzs7Ozs7QUFJQTtBQU9BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBUkE7O0FBZUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUN4RkE7QUFLQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBOzs7QUM5Q0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFLQTtBQUNBO0FBRkE7QUFLQTtBQUdBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBOztBQUtBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FDS0E7Ozs7QUFnQ0E7QUFBQTs7QUE3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFtRkE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBcEZBO0FBQ0E7QUFFQTtBQUNBO0FBTUE7QUFDQTs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBOztBQVdBO0FBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBOztBQWdCQTs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQVFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFEQTtBQUdBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQU1BO0FBQ0E7OztBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVVBO0FBQUE7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUdBOztBQUVBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBOztBQWdCQTs7QUFFQTtBQUFBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUVBO0FBTUE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7O0FBV0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFFQTtBQVdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7OztBQUdBO0FBQ0E7QUFBQTtBQUFBOztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQU9BO0FBRUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7O0FBRUE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBT0E7O0FBUUE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7O0FBQ0E7QUFBQTs7QUFFQTtBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBWEE7QUFnQkE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQW5CQTtBQTJCQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTs7OztBQ25wQkE7O0FBR0E7QUFBQTs7QUFVQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFkQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQUtBOztBQVdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFqQ0E7O0FDV0E7Ozs7OztBQUlBO0FBSUE7QUFNQTs7O0FDbENBO0FBQ0E7QUFDQTs7QUFLQTtBQUFBOzs7QUNxQkE7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBO0FBK0tBOztBQTdLQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUhBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTs7QUFLQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFBQTs7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTs7O0FBQ0E7QUFHQTs7O0FBR0E7QUMvQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBTUE7QUFFQTs7QUFFQTtBQUVBOztBQUVBO0FBRUE7O0FBQ0E7QUFBQTtBQ3RDQTs7O0FBQ0E7QUNDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBbUJBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FDckJBO0FBQUE7O0FBQUE7O0FBdURBOztBQXREQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQUE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBdkRBOztBQ05BO0FBQUE7O0FBQUE7O0FBb0RBOztBQW5EQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFNQTtBQUNBO0FBQUE7QUFNQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7O0FBQ0E7QUFwREE7OztBQ1FBO0FBQUE7O0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBREE7O0FBbURBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBVUE7O0FBakVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFFQTtBQUZBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFKQTtBQVNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBWUE7QUFDQTtBQUVBO0FBRkE7QUFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBeEVBO0FDSkE7Ozs7O0FBR0E7QUFBQTs7QUFDQTtBQUFBOztBQVdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7OztBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBUkE7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQ0E7QUFJQTs7QUFFQTs7QUFnQ0E7QUExQ0E7QUNKQTs7Ozs7O0FBSUE7QUFBQTs7QUFLQTtBQUFBOzs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUEvQkE7QUFHQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBdUJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVJBO0FBVUE7QUFDQTs7QUFDQTtBQTNEQTs7O0FDaUJBOztBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQTBMQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTs7O0FBQ0E7Ozs7OztBQTlOQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBTUE7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBZ0JBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUhBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVdBO0FBQ0E7QUFDQTtBQUhBO0FBU0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQWFBOztBQUVBO0FBQUE7O0FBQ0E7QUFJQTs7QUFFQTtBQUVBO0FBR0E7O0FBK0NBO0FBM09BOztBQTZPQTs7QUFTQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUdBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUN2UkE7O0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBREE7O0FBc0NBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7O0FBekNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFTQTtBQTlDQTs7O0FDaEJBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7O0FDYkE7O0FBRUE7QUFDQTtBQUNBOzs7QUNvQkE7O0FBQUE7O0FBNkRBOztBQTVEQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBR0E7O0FBR0E7QUFDQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQURBOztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBSkE7QUFPQTtBQUFBO0FBR0E7QUFDQTtBQUZBO0FBYUE7QUFHQTs7QUFDQTtBQTdEQTs7O0FDTkE7O0FBQUE7O0FBMERBOztBQXpEQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUlBOztBQUNBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUFBO0FBRUE7QUFJQTtBQUxBO0FBV0E7QUFHQTs7QUFDQTtBQTFEQTs7O0FDSEE7O0FBT0E7QUFBQTs7QUFHQTtBQUNBO0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBS0E7O0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbkVBO0FBb0VBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FDMUVBOztBQUFBO0FBQUE7O0FBQ0E7O0FBd0NBOztBQXRDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUVBO0FBR0E7O0FBQ0E7QUF6Q0E7O0FBMkNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBR0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBOzs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUEyS0E7O0FBektBO0FBS0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOztBQUVBO0FBQ0E7QUFFQTs7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBOztBQUVBO0FBS0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBV0E7O0FBRUE7QUFLQTs7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBS0E7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUVBO0FBSUE7O0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7O0FBS0E7QUFJQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7QUFLQTtBQUlBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBRUE7Ozs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRkE7QUFJQTtBQ3ZOQTs7O0FBRUE7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBS0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBOztBQVdBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBOztBQUVBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBRkE7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7O0FBQ0E7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUdBOzs7QUFFQTtBQU9BO0FBQUE7O0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFBQTtBQUNBO0FBR0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUM3UkE7OztBQUVBOztBQUFBO0FBQUE7O0FBc0NBO0FBQ0E7QUFDQTtBQUNBOzs7QUErREE7O0FBckdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBSEE7QUFrQkE7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQXhHQTtBQ25CQTs7Ozs7OztBQVNBO0FBQUE7O0FBQUE7QUFKQTtBQUNBO0FBQ0E7O0FBaUJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1Q0E7O0FBRUE7QUFBQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBcUNBO0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUN0QkE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBRUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBTEE7QUFjQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FBT0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQURBO0FBT0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBUUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUMvS0E7O0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7OztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUF3SUE7QUFDQTtBQUNBO0FBREE7QUFJQTs7O0FBOERBOztBQXBNQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQVNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFJQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTs7O0FBSUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBV0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBUEE7QUFjQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQVVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFHQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTtBQU1BO0FBR0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFwTkE7O0FBc05BO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUM5TkE7O0FBQUE7QUFBQTs7QUFDQTs7QUErREE7O0FBN0RBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUVBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBaEVBOzs7O0FDckJBOztBQUFBOztBQWtEQTs7QUFqREE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTkE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBR0E7O0FBQ0E7QUFsREE7O0FBb0RBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQ3BFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFVQTtBQUNBOztBQzlCQTtBQUFBO0FBQUE7OztBQWdDQTs7QUFBQTs7QUF3QkE7O0FBdkJBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQVFBOztBQUNBO0FBeEJBOztBQTBCQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFEQTtBQUlBOzs7QUM3Q0E7O0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQW9DQTs7QUFsQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTtBQUNBO0FBS0E7QUFDQTtBQURBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFBQTtBQUdBOztBQUNBO0FBdENBOztBQy9CQTtBQUNBO0FBQ0E7QUFBQTtBQUVBOztBQVNBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFGQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQVNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBOztBQ2xDQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBV0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FDN0JBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTs7QUFzQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBNkJBOztBQXRGQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBMEJBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7O0FBR0E7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFDQTtBQXpGQTs7QUNJQTtBQUFBOztBQUFBO0FBQUE7O0FBa0NBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFnQ0E7O0FBekVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUpBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUlBO0FBR0E7O0FBY0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOztBQWpCQTtBQW1CQTs7QUFFQTtBQUNBOztBQUNBO0FBNUVBOzs7QUMyQkE7O0FBQUE7QUFBQTs7QUFDQTtBQUdBO0FBQ0E7QUFEQTs7QUE0RUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTs7QUE3R0E7QUFBQTs7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU5BO0FBU0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBZ0JBO0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXVDQTtBQXJIQTs7QUF1SEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUN4TUE7OztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2FwaS9FdmVudFNvdXJjZUFwaS50cz81MGE0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2RvbS1tYW5pcC50cz8zOTE1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2RvbS1ldmVudC50cz85MTY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL21pc2MudHM/M2I0YiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9tYXJrZXIudHM/OTFmMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9ldmVudC1pbnN0YW5jZS50cz8zMTdmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL29iamVjdC50cz82ZGFkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudC50cz84MGQyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2R1cmF0aW9uLnRzPzhmNGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvZm9ybWF0dGluZy11dGlscy50cz82MzkxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2FycmF5LnRzPzllYWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvbWVtb2l6ZS50cz83ZWYxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2Zvcm1hdHRpbmctbmF0aXZlLnRzPzNlN2MiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvem9uZWQtbWFya2VyLnRzPzQwYjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvRGF0ZUZvcm1hdHRlci50cz84YjA5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2Zvcm1hdHRpbmctY21kLnRzPzdjZGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvZm9ybWF0dGluZy1mdW5jLnRzPzhjNzIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvZm9ybWF0dGluZy50cz83OTFhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9vcHRpb25zLnRzPzkxODEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvZXZlbnQtc3RvcmUudHM/N2VkMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9jb25zdHJhaW50LnRzP2YxY2IiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvaHRtbC50cz8yM2E5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21wb25lbnQvZXZlbnQtdWkudHM/MzIzYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9ldmVudC1wYXJzZS50cz9hMGQwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2RhdGUudHM/NDcwYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZGF0ZWxpYi9kYXRlLXJhbmdlLnRzP2M5ZjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcudHM/ZDc1MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9kYXRlLXNwYW4udHM/MGMwMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY2FsZW5kYXItdXRpbHMudHM/M2MwYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc3RydWN0cy9ldmVudC1tdXRhdGlvbi50cz9hYTk5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9WaWV3QXBpLnRzPzhmMjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvZXZlbnQtc291cmNlLXBhcnNlLnRzPzFjYWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL2N1cnJlbnQtZGF0ZS50cz9jNDY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9DYWxlbmRhckFwaS50c3g/NzVmZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvYXBpL0V2ZW50QXBpLnRzP2I4NzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvY2FsZW5kYXItc3lzdGVtLnRzP2U0NDMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2RhdGVsaWIvcGFyc2luZy50cz9hMTFmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2Vudi50cz9kNDNiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9nbG9iYWwtbG9jYWxlcy50cz8xODI2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL2xvY2FsZS50cz8yMjY3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9mb3JtYXR0aW5nLWFwaS50cz81M2YzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL2J1c2luZXNzLWhvdXJzLnRzPzY4ZjAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvZ2VvbS50cz9jZmMxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL3RhYmxlLXN0eWxpbmcudHN4P2JiYWQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbXBvbmVudC9ldmVudC1zcGxpdHRpbmcudHM/MzUxYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tcG9uZW50L2RhdGUtcmVuZGVyaW5nLnRzeD9lYTUwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vbmF2LWxpbmsudHM/ZWM0ZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9zY3JvbGxiYXItc2lkZS50cz84OGMzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL3Njcm9sbGJhci13aWR0aC50cz80MGFkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL2RvbS1nZW9tLnRzP2Q4MDUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3V0aWwvcHJvbWlzZS50cz9kOTczIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vRW1pdHRlci50cz82ZDY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vUG9zaXRpb25DYWNoZS50cz8xYzljIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vc2Nyb2xsLWNvbnRyb2xsZXIudHM/NjJlMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdGhlbWUvVGhlbWUudHM/ZjNmMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvU2Nyb2xsUmVzcG9uZGVyLnRzPzJmNjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1ZpZXdDb250ZXh0LnRzPzEyNzciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3Zkb20tdXRpbC50c3g/NzgxNyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tcG9uZW50L0RhdGVDb21wb25lbnQudHM/NGUzNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcGx1Z2luLXN5c3RlbS50cz85YTJiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90aGVtZS9TdGFuZGFyZFRoZW1lLnRzP2NhNjUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvdmlldy1kZWYudHM/MzgzMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL3JlbmRlci1ob29rLnRzeD8zNzRjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vVmlld1Jvb3QudHN4PzBkYzUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvdmlldy1jb25maWcudHN4Pzc1ZDEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvdmlldy1zcGVjLnRzP2VkZjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL0RhdGVQcm9maWxlR2VuZXJhdG9yLnRzPzYyODQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL3ZpZXctdHlwZS50cz8yOTdhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9vcHRpb25zLnRzPzliYjciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL2RhdGUtcHJvZmlsZS50cz8wNjk3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9ldmVudFNvdXJjZXMudHM/MTFiYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvZXZlbnRTdG9yZS50cz8xM2ViIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9kYXRlLXNlbGVjdGlvbi50cz82ZWQ5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9zZWxlY3RlZC1ldmVudC50cz9hM2M3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9yZWR1Y2Vycy9ldmVudC1kcmFnLnRzP2NiY2QiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL2V2ZW50LXJlc2l6ZS50cz9mZWEyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy90b29sYmFyLXBhcnNlLnRzPzM4NmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2V2ZW50LXNvdXJjZXMvYXJyYXktZXZlbnQtc291cmNlLnRzP2U3NmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2V2ZW50LXNvdXJjZXMvZnVuYy1ldmVudC1zb3VyY2UudHM/NDdiMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9yZXF1ZXN0SnNvbi50cz8yYWI5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudC1zb3VyY2VzL2pzb24tZmVlZC1ldmVudC1zb3VyY2UtcmVmaW5lcnMudHM/OWQ1MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnQtc291cmNlcy9qc29uLWZlZWQtZXZlbnQtc291cmNlLnRzP2RhZjkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3N0cnVjdHMvcmVjdXJyaW5nLWV2ZW50LXNpbXBsZS1yZWZpbmVycy50cz9jZWFhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudC1zaW1wbGUudHM/MzRmNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvb3B0aW9uLWNoYW5nZS1oYW5kbGVycy50cz9jNzY5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlcy1zZXQudHM/MDE3MyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnQtY3J1ZC50cz82ZWU0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9nbG9iYWwtcGx1Z2lucy50cz9lNmM2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlsL0RlbGF5ZWRSdW5uZXIudHM/Zjc5YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9UYXNrUnVubmVyLnRzPzU5MzYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3JlZHVjZXJzL3RpdGxlLWZvcm1hdHRpbmcudHM/MDk2ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvcmVkdWNlcnMvQ2FsZW5kYXJEYXRhTWFuYWdlci50cz8zM2ZmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21wb25lbnQvQ2FsZW5kYXJEYXRhUHJvdmlkZXIudHM/OGIzOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVmlldy50cz9jMzE3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kYXRlbGliL3RpbWV6b25lLnRzP2E4MmIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3NlZy1oaWVyYXJjaHkudHM/ZmU4ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uLnRzPzhmMGQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9FbGVtZW50RHJhZ2dpbmcudHM/YTBiZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZ2xvYmFsLWNvbmZpZy50cz9mZmUxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zdHJ1Y3RzL2RyYWctbWV0YS50cz84OGM4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9Ub29sYmFyU2VjdGlvbi50c3g/OTBhYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVG9vbGJhci50c3g/NDFmNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVmlld0NvbnRhaW5lci50c3g/YjBjYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL0V2ZW50Q2xpY2tpbmcudHM/M2M5NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zL0V2ZW50SG92ZXJpbmcudHM/MTljNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvQ2FsZW5kYXJDb250ZW50LnRzeD8yNGQ1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9DYWxlbmRhclJvb3QudHN4PzY4YjIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi90YWJsZS11dGlscy50cz84ZjI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vdGFibGUtY2VsbC11dGlsLnRzeD82MGU4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vVGFibGVEYXRlQ2VsbC50c3g/YTlhYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL1RhYmxlRG93Q2VsbC50c3g/Yzc5NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvTm93VGltZXIudHM/ZmJmYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL0RheUhlYWRlci50c3g/NTJmNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL0RheVNlcmllc01vZGVsLnRzP2I1YWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9EYXlUYWJsZU1vZGVsLnRzPzYyNzEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9zbGljaW5nLXV0aWxzLnRzPzkyZDIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL3ZhbGlkYXRpb24udHM/ZWZiYyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc2Nyb2xsZ3JpZC9TY3JvbGxlci50c3g/NjcwNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvdXRpbC9SZWZNYXAudHM/MjE4MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvc2Nyb2xsZ3JpZC91dGlsLnRzeD83MGQ1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9zY3JvbGxncmlkL1NpbXBsZVNjcm9sbEdyaWQudHN4PzQyMDEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9FdmVudFJvb3QudHN4P2Q3OTIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9TdGFuZGFyZEV2ZW50LnRzeD8zZTA3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vTm93SW5kaWNhdG9yUm9vdC50c3g/OWUwMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvY29tbW9uL0RheUNlbGxDb250ZW50LnRzeD8zMWQ0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vRGF5Q2VsbFJvb3QudHN4PzE5N2QiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9iZy1maWxsLnRzeD9lNjE2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vV2Vla051bWJlclJvb3QudHN4P2E5OTMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9Qb3BvdmVyLnRzeD8xMDk4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9jb21tb24vTW9yZVBvcG92ZXIudHN4PzdiMTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2NvbW1vbi9Nb3JlTGlua1Jvb3QudHN4PzdkNDciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL21haW4udHM/Yjk5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgY2xhc3MgRXZlbnRTb3VyY2VBcGkge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgICBwdWJsaWMgaW50ZXJuYWxFdmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiwgLy8gcmVuYW1lP1xuICApIHtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgc291cmNlSWQ6IHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICB9KVxuICB9XG5cbiAgcmVmZXRjaCgpIHtcbiAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgc291cmNlSWRzOiBbdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSxcbiAgICAgIGlzUmVmZXRjaDogdHJ1ZSxcbiAgICB9KVxuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5wdWJsaWNJZFxuICB9XG5cbiAgZ2V0IHVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UubWV0YS51cmxcbiAgfVxuXG4gIGdldCBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0IC8vIFRPRE86IGJhZC4gbm90IGd1YXJhbnRlZWRcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsOiBIVE1MRWxlbWVudCkgeyAvLyByZW1vdmVzIG5vZGVzIGluIGFkZGl0aW9uIHRvIGVsZW1lbnRzLiBiYWQgbmFtZVxuICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpXG4gIH1cbn1cblxuLy8gUXVlcnlpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsOiBIVE1MRWxlbWVudCwgc2VsZWN0b3I6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgaWYgKGVsLmNsb3Nlc3QpIHtcbiAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3RvcilcblxuICAvLyByZWFsbHkgYmFkIGZhbGxiYWNrIGZvciBJRVxuICAvLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2Nsb3Nlc3RcbiAgfVxuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGRvIHtcbiAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGVsXG4gICAgfVxuICAgIGVsID0gKGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZSkgYXMgSFRNTEVsZW1lbnRcbiAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbDogSFRNTEVsZW1lbnQsIHNlbGVjdG9yOiBzdHJpbmcpOiBIVE1MRWxlbWVudCB7XG4gIGxldCBtZXRob2QgPSBlbC5tYXRjaGVzIHx8IChlbCBhcyBhbnkpLm1hdGNoZXNTZWxlY3RvciB8fCAoZWwgYXMgYW55KS5tc01hdGNoZXNTZWxlY3RvclxuXG4gIHJldHVybiBtZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpXG59XG5cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIHJldHVybnMgYSByZWFsIGFycmF5LiBnb29kIGZvciBtZXRob2RzIGxpa2UgZm9yRWFjaFxuLy8gVE9ETzogYWNjZXB0IHRoZSBkb2N1bWVudFxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbGVtZW50cyhjb250YWluZXI6IEhUTUxFbGVtZW50W10gfCBIVE1MRWxlbWVudCB8IE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+LCBzZWxlY3Rvcjogc3RyaW5nKTogSFRNTEVsZW1lbnRbXSB7XG4gIGxldCBjb250YWluZXJzID0gY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbY29udGFpbmVyXSA6IGNvbnRhaW5lclxuICBsZXQgYWxsTWF0Y2hlczogSFRNTEVsZW1lbnRbXSA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbGV0IG1hdGNoZXMgPSBjb250YWluZXJzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIGFsbE1hdGNoZXMucHVzaChtYXRjaGVzW2pdIGFzIEhUTUxFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbGxNYXRjaGVzXG59XG5cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHMgLy8gVE9ETzogcmVuYW1lIHRvIGZpbmREaXJlY3RDaGlsZHJlbiFcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRGlyZWN0Q2hpbGRyZW4ocGFyZW50OiBIVE1MRWxlbWVudFtdIHwgSFRNTEVsZW1lbnQsIHNlbGVjdG9yPzogc3RyaW5nKTogSFRNTEVsZW1lbnRbXSB7XG4gIGxldCBwYXJlbnRzID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbcGFyZW50XSA6IHBhcmVudFxuICBsZXQgYWxsTWF0Y2hlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbGV0IGNoaWxkTm9kZXMgPSBwYXJlbnRzW2ldLmNoaWxkcmVuIC8vIG9ubHkgZXZlciBlbGVtZW50c1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICBsZXQgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tqXVxuXG4gICAgICBpZiAoIXNlbGVjdG9yIHx8IGVsZW1lbnRNYXRjaGVzKGNoaWxkTm9kZSBhcyBIVE1MRWxlbWVudCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIGFsbE1hdGNoZXMucHVzaChjaGlsZE5vZGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFsbE1hdGNoZXNcbn1cblxuLy8gU3R5bGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2lcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wczogRGljdGlvbmFyeSkge1xuICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbDogSFRNTEVsZW1lbnQsIG5hbWU6IHN0cmluZywgdmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIGVsLnN0eWxlW25hbWVdID0gJydcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiBQSVhFTF9QUk9QX1JFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZVtuYW1lXSA9IGAke3ZhbH1weGBcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbFxuICB9XG59XG5cbi8vIEV2ZW50IEhhbmRsaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIGlmIGludGVyY2VwdGluZyBidWJibGVkIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQvd2luZG93L2JvZHkgbGV2ZWwsXG4vLyBhbmQgd2FudCB0byBzZWUgb3JpZ2luYXRpbmcgZWxlbWVudCAodGhlICd0YXJnZXQnKSwgdXNlIHRoaXMgdXRpbCBpbnN0ZWFkXG4vLyBvZiBgZXYudGFyZ2V0YCBiZWNhdXNlIGl0IGdvZXMgd2l0aGluIHdlYi1jb21wb25lbnQgYm91bmRhcmllcy5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXY6IEV2ZW50KSB7XG4gIHJldHVybiBldi5jb21wb3NlZFBhdGg/LigpWzBdID8/IGV2LnRhcmdldFxufVxuXG4vLyBTaGFkb3cgRE9NIGNvbnN1ZGVyYXRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbFJvb3QoZWw6IEhUTUxFbGVtZW50KTogU2hhZG93Um9vdCB8IERvY3VtZW50IHtcbiAgcmV0dXJuIGVsLmdldFJvb3ROb2RlID8gZWwuZ2V0Um9vdE5vZGUoKSBhcyBTaGFkb3dSb290IDogZG9jdW1lbnRcbn1cbiIsImltcG9ydCB7IGVsZW1lbnRDbG9zZXN0IH0gZnJvbSAnLi9kb20tbWFuaXAnXG5pbXBvcnQgeyBWVUlFdmVudCB9IGZyb20gJy4uL3Zkb20nXG5cbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG4gIGV2LnByZXZlbnREZWZhdWx0KClcbn1cblxuLy8gRXZlbnQgRGVsZWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcjxFdmVudFR5cGUgZXh0ZW5kcyAoRXZlbnQgfCBWVUlFdmVudCk+KFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBoYW5kbGVyOiAoZXY6IEV2ZW50VHlwZSwgbWF0Y2hlZFRhcmdldDogSFRNTEVsZW1lbnQpID0+IHZvaWQsXG4pIHtcbiAgcmV0dXJuIChldjogRXZlbnRUeXBlKSA9PiB7XG4gICAgbGV0IG1hdGNoZWRDaGlsZCA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgc2VsZWN0b3IpXG5cbiAgICBpZiAobWF0Y2hlZENoaWxkKSB7XG4gICAgICBoYW5kbGVyLmNhbGwobWF0Y2hlZENoaWxkLCBldiwgbWF0Y2hlZENoaWxkKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3RvcihcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgZXZlbnRUeXBlOiBzdHJpbmcsXG4gIHNlbGVjdG9yOiBzdHJpbmcsXG4gIGhhbmRsZXI6IChldjogRXZlbnQsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkLFxuKSB7XG4gIGxldCBhdHRhY2hlZEhhbmRsZXIgPSBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKVxuXG4gIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKVxuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKFxuICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICBzZWxlY3Rvcjogc3RyaW5nLFxuICBvbk1vdXNlRW50ZXI6IChldjogRXZlbnQsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkLFxuICBvbk1vdXNlTGVhdmU6IChldjogRXZlbnQsIG1hdGNoZWRUYXJnZXQ6IEhUTUxFbGVtZW50KSA9PiB2b2lkLFxuKSB7XG4gIGxldCBjdXJyZW50TWF0Y2hlZENoaWxkXG5cbiAgcmV0dXJuIGxpc3RlbkJ5U2VsZWN0b3IoY29udGFpbmVyLCAnbW91c2VvdmVyJywgc2VsZWN0b3IsIChtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKSA9PiB7XG4gICAgaWYgKG1hdGNoZWRDaGlsZCAhPT0gY3VycmVudE1hdGNoZWRDaGlsZCkge1xuICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZFxuICAgICAgb25Nb3VzZUVudGVyKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpXG5cbiAgICAgIGxldCByZWFsT25Nb3VzZUxlYXZlID0gKG1vdXNlTGVhdmVFdikgPT4ge1xuICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbFxuICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpXG4gICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSlcbiAgICAgIH1cblxuICAgICAgLy8gbGlzdGVuIHRvIHRoZSBuZXh0IG1vdXNlbGVhdmUsIGFuZCB0aGVuIHVuYXR0YWNoXG4gICAgICBtYXRjaGVkQ2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHJlYWxPbk1vdXNlTGVhdmUpXG4gICAgfVxuICB9KVxufVxuXG4vLyBBbmltYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgJ290cmFuc2l0aW9uZW5kJyxcbiAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgJ21zVHJhbnNpdGlvbkVuZCcsXG4gICd0cmFuc2l0aW9uZW5kJyxcbl1cblxuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5leHBvcnQgZnVuY3Rpb24gd2hlblRyYW5zaXRpb25Eb25lKGVsOiBIVE1MRWxlbWVudCwgY2FsbGJhY2s6IChldjogRXZlbnQpID0+IHZvaWQpIHtcbiAgbGV0IHJlYWxDYWxsYmFjayA9IChldikgPT4ge1xuICAgIGNhbGxiYWNrKGV2KVxuICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjaylcbiAgICB9KVxuICB9XG5cbiAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjaykgLy8gY3Jvc3MtYnJvd3NlciB3YXkgdG8gZGV0ZXJtaW5lIHdoZW4gdGhlIHRyYW5zaXRpb24gZmluaXNoZXNcbiAgfSlcbn1cbiIsImltcG9ydCB7IHByZXZlbnREZWZhdWx0IH0gZnJvbSAnLi9kb20tZXZlbnQnXG5cbmV4cG9ydCB0eXBlIEdlbmVyaWNIYXNoID0geyBba2V5OiBzdHJpbmddOiBhbnkgfSAvLyBhbHJlYWR5IGRpZCB0aGlzIHNvbWV3aGVyZVxuXG5sZXQgZ3VpZE51bWJlciA9IDBcblxuZXhwb3J0IGZ1bmN0aW9uIGd1aWQoKSB7XG4gIGd1aWROdW1iZXIgKz0gMVxuICByZXR1cm4gU3RyaW5nKGd1aWROdW1iZXIpXG59XG5cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdmYy1ub3QtYWxsb3dlZCcpXG59XG5cbi8vIFJldHVybnMgdGhlIG1vdXNlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgbG9va1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdmYy1ub3QtYWxsb3dlZCcpXG59XG5cbi8qIFNlbGVjdGlvblxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsOiBIVE1MRWxlbWVudCkge1xuICBlbC5jbGFzc0xpc3QuYWRkKCdmYy11bnNlbGVjdGFibGUnKVxuICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWw6IEhUTUxFbGVtZW50KSB7XG4gIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLXVuc2VsZWN0YWJsZScpXG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpXG59XG5cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWw6IEhUTUxFbGVtZW50KSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxvd0NvbnRleHRNZW51KGVsOiBIVE1MRWxlbWVudCkge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KVxufVxuXG4vKiBPYmplY3QgT3JkZXJpbmcgYnkgRmllbGRcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgaW50ZXJmYWNlIE9yZGVyU3BlYzxTdWJqZWN0PiB7XG4gIGZpZWxkPzogc3RyaW5nXG4gIG9yZGVyPzogbnVtYmVyXG4gIGZ1bmM/OiBGaWVsZFNwZWNJbnB1dEZ1bmM8U3ViamVjdD5cbn1cblxuZXhwb3J0IHR5cGUgRmllbGRTcGVjSW5wdXQ8U3ViamVjdD4gPSBzdHJpbmcgfCBzdHJpbmdbXSB8IEZpZWxkU3BlY0lucHV0RnVuYzxTdWJqZWN0PiB8IEZpZWxkU3BlY0lucHV0RnVuYzxTdWJqZWN0PltdXG5leHBvcnQgdHlwZSBGaWVsZFNwZWNJbnB1dEZ1bmM8U3ViamVjdD4gPSAoYTogU3ViamVjdCwgYjogU3ViamVjdCkgPT4gbnVtYmVyXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpZWxkU3BlY3M8U3ViamVjdD4oaW5wdXQ6IEZpZWxkU3BlY0lucHV0PFN1YmplY3Q+KTogT3JkZXJTcGVjPFN1YmplY3Q+W10ge1xuICBsZXQgc3BlY3M6IE9yZGVyU3BlYzxTdWJqZWN0PltdID0gW11cbiAgbGV0IHRva2VucyA9IFtdXG4gIGxldCBpXG4gIGxldCB0b2tlblxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdG9rZW5zID0gW2lucHV0XVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgdG9rZW5zID0gaW5wdXRcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNwZWNzLnB1c2goXG4gICAgICAgIHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSxcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3BlY3MucHVzaCh7IGZ1bmM6IHRva2VuIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNwZWNzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzPFN1YmplY3Q+KG9iajA6IFN1YmplY3QsIG9iajE6IFN1YmplY3QsIGZpZWxkU3BlY3M6IE9yZGVyU3BlYzxTdWJqZWN0PltdKTogbnVtYmVyIHtcbiAgbGV0IGlcbiAgbGV0IGNtcFxuXG4gIGZvciAoaSA9IDA7IGkgPCBmaWVsZFNwZWNzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY21wID0gY29tcGFyZUJ5RmllbGRTcGVjKG9iajAsIG9iajEsIGZpZWxkU3BlY3NbaV0pXG4gICAgaWYgKGNtcCkge1xuICAgICAgcmV0dXJuIGNtcFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWM8U3ViamVjdD4ob2JqMDogU3ViamVjdCwgb2JqMTogU3ViamVjdCwgZmllbGRTcGVjOiBPcmRlclNwZWM8U3ViamVjdD4pOiBudW1iZXIge1xuICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcbiAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMCwgb2JqMSlcbiAgfVxuXG4gIHJldHVybiBmbGV4aWJsZUNvbXBhcmUob2JqMFtmaWVsZFNwZWMuZmllbGRdLCBvYmoxW2ZpZWxkU3BlYy5maWVsZF0pXG4gICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xuICBpZiAoIWEgJiYgIWIpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmIChiID09IG51bGwpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoYSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpXG4gIH1cbiAgcmV0dXJuIGEgLSBiXG59XG5cbi8qIFN0cmluZyBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFkU3RhcnQodmFsLCBsZW4pIHsgLy8gZG9lc24ndCB3b3JrIHdpdGggdG90YWwgbGVuZ3RoIG1vcmUgdGhhbiAzXG4gIGxldCBzID0gU3RyaW5nKHZhbClcbiAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzXG59XG5cbi8qIE51bWJlciBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikgeyAvLyBmb3IgLnNvcnQoKVxuICByZXR1cm4gYSAtIGJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgcmV0dXJuIG4gJSAxID09PSAwXG59XG5cbi8qIFdlaXJkIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdERlZmluZWQoLi4uYXJncykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYXJnc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbi8qIEZDLXNwZWNpZmljIERPTSBkaW1lbnNpb24gc3R1ZmZcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKGNlbGxFbDogSFRNTEVsZW1lbnQpIHtcbiAgbGV0IGFsbFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJylcbiAgbGV0IGNvbnRlbnRXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJylcblxuICBpZiAoIWFsbFdpZHRoRWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lIGNsYXNzTmFtZScpIC8vIFRPRE86IHVzZSBjb25zdFxuICB9XG4gIGlmICghY29udGVudFdpZHRoRWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZWRzIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24gY2xhc3NOYW1lJylcbiAgfVxuXG4gIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBhbGxXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgLy8gdGhlIGNlbGwgcGFkZGluZytib3JkZXJcbiAgICBjb250ZW50V2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxufVxuIiwiaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2R1cmF0aW9uJ1xuXG5leHBvcnQgdHlwZSBEYXRlTWFya2VyID0gRGF0ZVxuXG5leHBvcnQgY29uc3QgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J11cblxuLy8gQWRkaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRXZWVrcyhtOiBEYXRlTWFya2VyLCBuOiBudW1iZXIpIHtcbiAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKVxuICBhWzJdICs9IG4gKiA3XG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkRGF5cyhtOiBEYXRlTWFya2VyLCBuOiBudW1iZXIpIHtcbiAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKVxuICBhWzJdICs9IG5cbiAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRNcyhtOiBEYXRlTWFya2VyLCBuOiBudW1iZXIpIHtcbiAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKVxuICBhWzZdICs9IG5cbiAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpXG59XG5cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuXG5leHBvcnQgZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICByZXR1cm4gZGlmZkRheXMobTAsIG0xKSAvIDdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gMTAwMFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyKTogRHVyYXRpb24ge1xuICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKVxuICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKVxuXG4gIHJldHVybiB7XG4gICAgeWVhcnM6IDAsXG4gICAgbW9udGhzOiAwLFxuICAgIGRheXM6IE1hdGgucm91bmQoZGlmZkRheXMobTBkYXksIG0xZGF5KSksXG4gICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICB9XG59XG5cbi8vIERpZmZpbmcgV2hvbGUgVW5pdHNcblxuZXhwb3J0IGZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wOiBEYXRlTWFya2VyLCBtMTogRGF0ZU1hcmtlcik6IG51bWJlciB7XG4gIGxldCBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpXG5cbiAgaWYgKGQgIT09IG51bGwgJiYgZCAlIDcgPT09IDApIHtcbiAgICByZXR1cm4gZCAvIDdcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wOiBEYXRlTWFya2VyLCBtMTogRGF0ZU1hcmtlcik6IG51bWJlciB7XG4gIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wLCBtMSkpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLy8gU3RhcnQtT2ZcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZEYXkobTogRGF0ZU1hcmtlcik6IERhdGVNYXJrZXIge1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgbS5nZXRVVENEYXRlKCksXG4gIF0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mSG91cihtOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBtLmdldFVUQ0hvdXJzKCksXG4gIF0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydE9mTWludXRlKG06IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgbS5nZXRVVENNb250aCgpLFxuICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgXSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobTogRGF0ZU1hcmtlcikge1xuICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgbS5nZXRVVENEYXRlKCksXG4gICAgbS5nZXRVVENIb3VycygpLFxuICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgIG0uZ2V0VVRDU2Vjb25kcygpLFxuICBdKVxufVxuXG4vLyBXZWVrIENvbXB1dGF0aW9uXG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgbGV0IHkgPSBtYXJrZXIuZ2V0VVRDRnVsbFllYXIoKVxuICBsZXQgdyA9IHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHksIGRvdywgZG95KVxuXG4gIGlmICh3IDwgMSkge1xuICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpXG4gIH1cblxuICBsZXQgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpXG4gIGlmIChuZXh0VyA+PSAxKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHcsIG5leHRXKVxuICB9XG5cbiAgcmV0dXJuIHdcbn1cblxuZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcbiAgbGV0IGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSlcbiAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpXG4gIGxldCBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKVxuXG4gIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDEgLy8gemVyby1pbmRleGVkXG59XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gIGxldCBmd2QgPSA3ICsgZG93IC0gZG95XG5cbiAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICBsZXQgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3XG5cbiAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDFcbn1cblxuLy8gQXJyYXkgQ29udmVyc2lvblxuXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gIHJldHVybiBbXG4gICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgIGRhdGUuZ2V0TW9udGgoKSxcbiAgICBkYXRlLmdldERhdGUoKSxcbiAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgZGF0ZS5nZXRNaW51dGVzKCksXG4gICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcbiAgXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XG4gIHJldHVybiBuZXcgRGF0ZShcbiAgICBhWzBdLFxuICAgIGFbMV0gfHwgMCxcbiAgICBhWzJdID09IG51bGwgPyAxIDogYVsyXSwgLy8gZGF5IG9mIG1vbnRoXG4gICAgYVszXSB8fCAwLFxuICAgIGFbNF0gfHwgMCxcbiAgICBhWzVdIHx8IDAsXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgcmV0dXJuIFtcbiAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgZGF0ZS5nZXRVVENNb250aCgpLFxuICAgIGRhdGUuZ2V0VVRDRGF0ZSgpLFxuICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBkYXRlLmdldFVUQ1NlY29uZHMoKSxcbiAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICBdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gIC8vIGFjY29yZGluZyB0byB3ZWIgc3RhbmRhcmRzIChhbmQgU2FmYXJpKSwgYSBtb250aCBpbmRleCBpcyByZXF1aXJlZC5cbiAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cbiAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgYSA9IGEuY29uY2F0KFswXSlcbiAgfVxuXG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyguLi4oYSBhcyBbYW55LCBhbnldKSkpXG59XG5cbi8vIE90aGVyIFV0aWxzXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRGF0ZShtOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lQXNNcyhtOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXG4gICAgbS5nZXRVVENNaW51dGVzKCkgKiAxMDAwICogNjAgK1xuICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKVxufVxuIiwiaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgZ3VpZCB9IGZyb20gJy4uL3V0aWwvbWlzYydcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudEluc3RhbmNlIHtcbiAgaW5zdGFuY2VJZDogc3RyaW5nXG4gIGRlZklkOiBzdHJpbmdcbiAgcmFuZ2U6IERhdGVSYW5nZVxuICBmb3JjZWRTdGFydFR6bzogbnVtYmVyIHwgbnVsbFxuICBmb3JjZWRFbmRUem86IG51bWJlciB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRJbnN0YW5jZUhhc2ggPSB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBFdmVudEluc3RhbmNlIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoXG4gIGRlZklkOiBzdHJpbmcsXG4gIHJhbmdlOiBEYXRlUmFuZ2UsXG4gIGZvcmNlZFN0YXJ0VHpvPzogbnVtYmVyLFxuICBmb3JjZWRFbmRUem8/OiBudW1iZXIsXG4pOiBFdmVudEluc3RhbmNlIHtcbiAgcmV0dXJuIHtcbiAgICBpbnN0YW5jZUlkOiBndWlkKCksXG4gICAgZGVmSWQsXG4gICAgcmFuZ2UsXG4gICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgZm9yY2VkRW5kVHpvOiBmb3JjZWRFbmRUem8gPT0gbnVsbCA/IG51bGwgOiBmb3JjZWRFbmRUem8sXG4gIH1cbn1cbiIsImNvbnN0IHsgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGVcblxuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXG4vLyBUaGUgc2Vjb25kIGFyZ3VtZW50IGFsbG93cyBmb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgd2hvJ3Mgb2JqZWN0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB0b2dldGhlci5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVByb3BzKHByb3BPYmpzLCBjb21wbGV4UHJvcHNNYXA/KTogYW55IHtcbiAgbGV0IGRlc3QgPSB7fVxuXG4gIGlmIChjb21wbGV4UHJvcHNNYXApIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIGNvbXBsZXhQcm9wc01hcCkge1xuICAgICAgbGV0IGNvbXBsZXhPYmpzID0gW11cblxuICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgZm9yIChsZXQgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGxldCB2YWwgPSBwcm9wT2Jqc1tpXVtuYW1lXVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZXN0W25hbWVdID0gdmFsIC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSB0cmFpbGluZyB2YWx1ZXMgd2VyZSBvYmplY3RzLCB1c2UgdGhlIG1lcmdlZCB2YWx1ZVxuICAgICAgaWYgKGNvbXBsZXhPYmpzLmxlbmd0aCkge1xuICAgICAgICBkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2JqcylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XG4gIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgIGxldCBwcm9wcyA9IHByb3BPYmpzW2ldXG5cbiAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKSB7XG4gICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7IC8vIGlmIGFscmVhZHkgYXNzaWduZWQgYnkgcHJldmlvdXMgcHJvcHMgb3IgY29tcGxleCBwcm9wcywgZG9uJ3QgcmVhc3NpZ25cbiAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckhhc2goaGFzaCwgZnVuYykge1xuICBsZXQgZmlsdGVyZWQgPSB7fVxuXG4gIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XG4gICAgaWYgKGZ1bmMoaGFzaFtrZXldLCBrZXkpKSB7XG4gICAgICBmaWx0ZXJlZFtrZXldID0gaGFzaFtrZXldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoPElucHV0SXRlbSwgT3V0cHV0SXRlbT4oXG4gIGhhc2g6IHsgW2tleTogc3RyaW5nXTogSW5wdXRJdGVtIH0sXG4gIGZ1bmM6IChpbnB1dDogSW5wdXRJdGVtLCBrZXk6IHN0cmluZykgPT4gT3V0cHV0SXRlbSxcbik6IHsgW2tleTogc3RyaW5nXTogT3V0cHV0SXRlbSB9IHtcbiAgbGV0IG5ld0hhc2ggPSB7fVxuXG4gIGZvciAobGV0IGtleSBpbiBoYXNoKSB7XG4gICAgbmV3SGFzaFtrZXldID0gZnVuYyhoYXNoW2tleV0sIGtleSlcbiAgfVxuXG4gIHJldHVybiBuZXdIYXNoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvSGFzaChhKTogeyBba2V5OiBzdHJpbmddOiB0cnVlIH0geyAvLyBUT0RPOiByZW5hbWUgdG8gc3RyaW5BcnJheVRvSGFzaCBvciBzb21ldGhpbmdcbiAgbGV0IGhhc2ggPSB7fVxuXG4gIGZvciAobGV0IGl0ZW0gb2YgYSkge1xuICAgIGhhc2hbaXRlbV0gPSB0cnVlXG4gIH1cblxuICByZXR1cm4gaGFzaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRIYXNoRnJvbUFycmF5PEl0ZW0sIEl0ZW1SZXM+KGE6IEl0ZW1bXSwgZnVuYzogKGl0ZW06IEl0ZW0sIGluZGV4OiBudW1iZXIpID0+IFsgc3RyaW5nLCBJdGVtUmVzIF0pIHtcbiAgbGV0IGhhc2g6IHsgW2tleTogc3RyaW5nXTogSXRlbVJlcyB9ID0ge31cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgdHVwbGUgPSBmdW5jKGFbaV0sIGkpXG5cbiAgICBoYXNoW3R1cGxlWzBdXSA9IHR1cGxlWzFdXG4gIH1cblxuICByZXR1cm4gaGFzaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzaFZhbHVlc1RvQXJyYXkob2JqKSB7IC8vIGNhbid0IHVzZSBPYmplY3QudmFsdWVzIHlldCBiZWNhdXNlIG9mIG5vIElFIHN1cHBvcnRcbiAgbGV0IGEgPSBbXVxuXG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBhLnB1c2gob2JqW2tleV0pXG4gIH1cblxuICByZXR1cm4gYVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9wc0VxdWFsKG9iajAsIG9iajEpIHsgLy8gVE9ETzogbWVyZ2Ugd2l0aCBjb21wYXJlT2Jqc1xuICBpZiAob2JqMCA9PT0gb2JqMSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqMCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqMSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgbGV0IGtleXM6IHN0cmluZ1tdID0gW11cblxuICBmb3IgKGxldCBrZXkgaW4gb2JqMCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGtleXNcbn1cblxuZXhwb3J0IHR5cGUgRXF1YWxpdHlGdW5jPFQ+ID0gKGE6IFQsIGI6IFQpID0+IGJvb2xlYW5cbmV4cG9ydCB0eXBlIEVxdWFsaXR5VGhpbmc8VD4gPSBFcXVhbGl0eUZ1bmM8VD4gfCB0cnVlXG5cbmV4cG9ydCB0eXBlIEVxdWFsaXR5RnVuY3M8T2JqVHlwZT4gPSB7IC8vIG5vdCByZWFsbHkganVzdCBhIFwiZnVuY1wiIGFueW1vcmVcbiAgW0sgaW4ga2V5b2YgT2JqVHlwZV0/OiBFcXVhbGl0eVRoaW5nPE9ialR5cGVbS10+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlT2JqcyhvbGRQcm9wcywgbmV3UHJvcHMsIGVxdWFsaXR5RnVuY3M6IEVxdWFsaXR5RnVuY3M8YW55PiA9IHt9KSB7XG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yIChsZXQga2V5IGluIG5ld1Byb3BzKSB7XG4gICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSB7XG4gICAgICAvLyBlcXVhbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBmb3IgcHJvcHMgdGhhdCB3ZXJlIG9taXR0ZWQgaW4gdGhlIG5ld1xuICBmb3IgKGxldCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoIShrZXkgaW4gbmV3UHJvcHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKlxuYXNzdW1lZCBcInRydWVcIiBlcXVhbGl0eSBmb3IgaGFuZGxlciBuYW1lcyBsaWtlIFwib25SZWNlaXZlU29tZXRoaW5nXCJcbiovXG5mdW5jdGlvbiBpc09ialZhbHNFcXVhbDxUPih2YWwwOiBULCB2YWwxOiBULCBjb21wYXJhdG9yOiBFcXVhbGl0eVRoaW5nPFQ+KSB7XG4gIGlmICh2YWwwID09PSB2YWwxIHx8IGNvbXBhcmF0b3IgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgcmV0dXJuIGNvbXBhcmF0b3IodmFsMCwgdmFsMSlcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RGcm9tSGFzaDxJdGVtPihcbiAgaGFzaDogeyBba2V5OiBzdHJpbmddOiBJdGVtIH0sXG4gIHN0YXJ0SW5kZXggPSAwLFxuICBlbmRJbmRleD86IG51bWJlcixcbiAgc3RlcCA9IDEsXG4pIHtcbiAgbGV0IHJlczogSXRlbVtdID0gW11cblxuICBpZiAoZW5kSW5kZXggPT0gbnVsbCkge1xuICAgIGVuZEluZGV4ID0gT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoXG4gIH1cblxuICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpICs9IHN0ZXApIHtcbiAgICBsZXQgdmFsID0gaGFzaFtpXVxuXG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgcmVzLnB1c2godmFsKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNcbn1cbiIsImltcG9ydCB7IEV2ZW50RGVmIH0gZnJvbSAnLi9ldmVudC1kZWYnXG5pbXBvcnQgeyBFdmVudEluc3RhbmNlLCBjcmVhdGVFdmVudEluc3RhbmNlIH0gZnJvbSAnLi9ldmVudC1pbnN0YW5jZSdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IERhdGVNYXJrZXIsIHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZmlsdGVySGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRXZlbnRSZWZpbmVkIH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcblxuLypcblRoZSBwbHVnaW4gc3lzdGVtIGZvciBkZWZpbmluZyBob3cgYSByZWN1cnJpbmcgZXZlbnQgaXMgZXhwYW5kZWQgaW50byBpbmRpdmlkdWFsIGluc3RhbmNlcy5cbiovXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkUmVjdXJyaW5nPFJlY3VycmluZ0RhdGE+IHtcbiAgdHlwZURhdGE6IFJlY3VycmluZ0RhdGFcbiAgYWxsRGF5R3Vlc3M6IGJvb2xlYW4gfCBudWxsXG4gIGR1cmF0aW9uOiBEdXJhdGlvbiB8IG51bGwgLy8gc2lnbmFscyBoYXNFbmRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWN1cnJpbmdUeXBlPFJlY3VycmluZ0RhdGE+IHtcbiAgcGFyc2U6IChyZWZpbmVkOiBFdmVudFJlZmluZWQsIGRhdGVFbnY6IERhdGVFbnYpID0+IFBhcnNlZFJlY3VycmluZzxSZWN1cnJpbmdEYXRhPiB8IG51bGwgLy8gVE9ETzogcmVuYW1lIHRvIHBvc3QtcHJvY2VzcyBvciBzb21ldGhpbmdcbiAgZXhwYW5kOiAodHlwZURhdGE6IGFueSwgZnJhbWluZ1JhbmdlOiBEYXRlUmFuZ2UsIGRhdGVFbnY6IERhdGVFbnYpID0+IERhdGVNYXJrZXJbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZWN1cnJpbmcoXG4gIHJlZmluZWQ6IEV2ZW50UmVmaW5lZCxcbiAgZGVmYXVsdEFsbERheTogYm9vbGVhbiB8IG51bGwsXG4gIGRhdGVFbnY6IERhdGVFbnYsXG4gIHJlY3VycmluZ1R5cGVzOiBSZWN1cnJpbmdUeXBlPGFueT5bXSxcbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY3VycmluZ1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbGV0IHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpXG5cbiAgICBpZiAocGFyc2VkKSB7XG4gICAgICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWRcbiAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5XG4gICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgIGFsbERheSA9IHBhcnNlZC5hbGxEYXlHdWVzc1xuICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWxsRGF5LFxuICAgICAgICBkdXJhdGlvbjogcGFyc2VkLmR1cmF0aW9uLFxuICAgICAgICB0eXBlRGF0YTogcGFyc2VkLnR5cGVEYXRhLFxuICAgICAgICB0eXBlSWQ6IGksXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnRTdG9yZSB7XG4gIGxldCB7IGRhdGVFbnYsIHBsdWdpbkhvb2tzLCBvcHRpb25zIH0gPSBjb250ZXh0XG4gIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZVxuXG4gIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gIC8vIFRPRE86IGJhZC4gYWx3YXlzIGV4cGFuZCBldmVudHMgYXMgYSBzZWNvbmQgc3RlcFxuICBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGluc3RhbmNlcywgKGluc3RhbmNlOiBFdmVudEluc3RhbmNlKSA9PiAhZGVmc1tpbnN0YW5jZS5kZWZJZF0ucmVjdXJyaW5nRGVmKVxuXG4gIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF1cblxuICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICBsZXQgeyBkdXJhdGlvbiB9ID0gZGVmLnJlY3VycmluZ0RlZlxuXG4gICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgb3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uXG4gICAgICB9XG5cbiAgICAgIGxldCBzdGFydHMgPSBleHBhbmRSZWN1cnJpbmdSYW5nZXMoZGVmLCBkdXJhdGlvbiwgZnJhbWluZ1JhbmdlLCBkYXRlRW52LCBwbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcylcblxuICAgICAgZm9yIChsZXQgc3RhcnQgb2Ygc3RhcnRzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbiksXG4gICAgICAgIH0pXG4gICAgICAgIGluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH1cbn1cblxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhcbiAgZXZlbnREZWY6IEV2ZW50RGVmLFxuICBkdXJhdGlvbjogRHVyYXRpb24sXG4gIGZyYW1pbmdSYW5nZTogRGF0ZVJhbmdlLFxuICBkYXRlRW52OiBEYXRlRW52LFxuICByZWN1cnJpbmdUeXBlczogUmVjdXJyaW5nVHlwZTxhbnk+W10sXG4pOiBEYXRlTWFya2VyW10ge1xuICBsZXQgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdXG4gIGxldCBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoXG4gICAgZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLFxuICAgIHtcbiAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLCAvLyBmb3Igd2hlbiBldmVudCBzdGFydHMgYmVmb3JlIGZyYW1pbmcgcmFuZ2UgYW5kIGdvZXMgaW50b1xuICAgICAgZW5kOiBmcmFtaW5nUmFuZ2UuZW5kLFxuICAgIH0sXG4gICAgZGF0ZUVudixcbiAgKVxuXG4gIC8vIHRoZSByZWN1cnJlbmNlIHBsdWdpbnMgZG9uJ3QgZ3VhcmFudGVlIHRoYXQgYWxsLWRheSBldmVudHMgYXJlIHN0YXJ0LW9mLWRheSwgc28gd2UgaGF2ZSB0b1xuICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgbWFya2VycyA9IG1hcmtlcnMubWFwKHN0YXJ0T2ZEYXkpXG4gIH1cblxuICByZXR1cm4gbWFya2Vyc1xufVxuIiwiaW1wb3J0IHsgaXNJbnQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5cbmV4cG9ydCB0eXBlIER1cmF0aW9uSW5wdXQgPSBEdXJhdGlvbk9iamVjdElucHV0IHwgc3RyaW5nIHwgbnVtYmVyXG5cbmV4cG9ydCBpbnRlcmZhY2UgRHVyYXRpb25PYmplY3RJbnB1dCB7XG4gIHllYXJzPzogbnVtYmVyXG4gIHllYXI/OiBudW1iZXJcbiAgbW9udGhzPzogbnVtYmVyXG4gIG1vbnRoPzogbnVtYmVyXG4gIHdlZWtzPzogbnVtYmVyXG4gIHdlZWs/OiBudW1iZXJcbiAgZGF5cz86IG51bWJlclxuICBkYXk/OiBudW1iZXJcbiAgaG91cnM/OiBudW1iZXJcbiAgaG91cj86IG51bWJlclxuICBtaW51dGVzPzogbnVtYmVyXG4gIG1pbnV0ZT86IG51bWJlclxuICBzZWNvbmRzPzogbnVtYmVyXG4gIHNlY29uZD86IG51bWJlclxuICBtaWxsaXNlY29uZHM/OiBudW1iZXJcbiAgbWlsbGlzZWNvbmQ/OiBudW1iZXJcbiAgbXM/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEdXJhdGlvbiB7XG4gIHllYXJzOiBudW1iZXJcbiAgbW9udGhzOiBudW1iZXJcbiAgZGF5czogbnVtYmVyXG4gIG1pbGxpc2Vjb25kczogbnVtYmVyXG4gIHNwZWNpZmllZFdlZWtzPzogYm9vbGVhblxufVxuXG5jb25zdCBJTlRFUk5BTF9VTklUUyA9IFsneWVhcnMnLCAnbW9udGhzJywgJ2RheXMnLCAnbWlsbGlzZWNvbmRzJ11cbmNvbnN0IFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vXG5cbi8vIFBhcnNpbmcgYW5kIENyZWF0aW9uXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dDogRHVyYXRpb25JbnB1dCwgdW5pdD86IHN0cmluZyk6IER1cmF0aW9uIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QoeyBbdW5pdCB8fCAnbWlsbGlzZWNvbmRzJ106IGlucHV0IH0pXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoczogc3RyaW5nKTogRHVyYXRpb24ge1xuICBsZXQgbSA9IFBBUlNFX1JFLmV4ZWMocylcbiAgaWYgKG0pIHtcbiAgICBsZXQgc2lnbiA9IG1bMV0gPyAtMSA6IDFcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcnM6IDAsXG4gICAgICBtb250aHM6IDAsXG4gICAgICBkYXlzOiBzaWduICogKG1bMl0gPyBwYXJzZUludChtWzJdLCAxMCkgOiAwKSxcbiAgICAgIG1pbGxpc2Vjb25kczogc2lnbiAqIChcbiAgICAgICAgKG1bM10gPyBwYXJzZUludChtWzNdLCAxMCkgOiAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgKG1bNV0gPyBwYXJzZUludChtWzVdLCAxMCkgOiAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgIChtWzZdID8gcGFyc2VJbnQobVs2XSwgMTApIDogMCkgLy8gbXNcbiAgICAgICksXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iajogRHVyYXRpb25PYmplY3RJbnB1dCk6IER1cmF0aW9uIHtcbiAgbGV0IGR1cmF0aW9uOiBEdXJhdGlvbiA9IHtcbiAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgbW9udGhzOiBvYmoubW9udGhzIHx8IG9iai5tb250aCB8fCAwLFxuICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICBtaWxsaXNlY29uZHM6XG4gICAgICAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICB9XG5cbiAgbGV0IHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrXG4gIGlmICh3ZWVrcykge1xuICAgIGR1cmF0aW9uLmRheXMgKz0gd2Vla3MgKiA3XG4gICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gZHVyYXRpb25cbn1cblxuLy8gRXF1YWxpdHlcblxuZXhwb3J0IGZ1bmN0aW9uIGR1cmF0aW9uc0VxdWFsKGQwOiBEdXJhdGlvbiwgZDE6IER1cmF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBkMC55ZWFycyA9PT0gZDEueWVhcnMgJiZcbiAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcbiAgICBkMC5taWxsaXNlY29uZHMgPT09IGQxLm1pbGxpc2Vjb25kc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyOiBEdXJhdGlvbikge1xuICBpZiAoIWR1ci55ZWFycyAmJiAhZHVyLm1vbnRocyAmJiAhZHVyLm1pbGxpc2Vjb25kcykge1xuICAgIHJldHVybiBkdXIuZGF5c1xuICB9XG4gIHJldHVybiAwXG59XG5cbi8vIFNpbXBsZSBNYXRoXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGREdXJhdGlvbnMoZDA6IER1cmF0aW9uLCBkMTogRHVyYXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyczogZDAueWVhcnMgKyBkMS55ZWFycyxcbiAgICBtb250aHM6IGQwLm1vbnRocyArIGQxLm1vbnRocyxcbiAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICBtaWxsaXNlY29uZHM6IGQwLm1pbGxpc2Vjb25kcyArIGQxLm1pbGxpc2Vjb25kcyxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDE6IER1cmF0aW9uLCBkMDogRHVyYXRpb24pOiBEdXJhdGlvbiB7XG4gIHJldHVybiB7XG4gICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXG4gICAgbW9udGhzOiBkMS5tb250aHMgLSBkMC5tb250aHMsXG4gICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHMsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZDogRHVyYXRpb24sIG46IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIHllYXJzOiBkLnllYXJzICogbixcbiAgICBtb250aHM6IGQubW9udGhzICogbixcbiAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgIG1pbGxpc2Vjb25kczogZC5taWxsaXNlY29uZHMgKiBuLFxuICB9XG59XG5cbi8vIENvbnZlcnNpb25zXG4vLyBcIlJvdWdoXCIgYmVjYXVzZSB0aGV5IGFyZSBiYXNlZCBvbiBhdmVyYWdlLWNhc2UgR3JlZ29yaWFuIG1vbnRocy95ZWFyc1xuXG5leHBvcnQgZnVuY3Rpb24gYXNSb3VnaFllYXJzKGR1cjogRHVyYXRpb24pIHtcbiAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzUm91Z2hNb250aHMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDMwXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDg2NGU1XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoSG91cnMoZHVyOiBEdXJhdGlvbikge1xuICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAoMTAwMCAqIDYwICogNjApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoTWludXRlcyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc1JvdWdoU2Vjb25kcyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDEwMDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzUm91Z2hNcyhkdXI6IER1cmF0aW9uKSB7XG4gIHJldHVybiBkdXIueWVhcnMgKiAoMzY1ICogODY0ZTUpICtcbiAgICBkdXIubW9udGhzICogKDMwICogODY0ZTUpICtcbiAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICBkdXIubWlsbGlzZWNvbmRzXG59XG5cbi8vIEFkdmFuY2VkIE1hdGhcblxuZXhwb3J0IGZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvcjogRHVyYXRpb24sIGRlbm9taW5hdG9yOiBEdXJhdGlvbik6IG51bWJlciB7XG4gIGxldCByZXMgPSBudWxsXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJTlRFUk5BTF9VTklUUy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV1cblxuICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgbGV0IGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF1cblxuICAgICAgaWYgKCFpc0ludChsb2NhbFJlcykgfHwgKHJlcyAhPT0gbnVsbCAmJiByZXMgIT09IGxvY2FsUmVzKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXMgPSBsb2NhbFJlc1xuICAgIH0gZWxzZSBpZiAobnVtZXJhdG9yW3VuaXRdKSB7XG4gICAgICAvLyBuZWVkcyB0byBkaXZpZGUgYnkgc29tZXRoaW5nIGJ1dCBjYW4ndCFcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cjogRHVyYXRpb24pIHtcbiAgbGV0IG1zID0gZHVyLm1pbGxpc2Vjb25kc1xuICBpZiAobXMpIHtcbiAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfVxuICAgIH1cbiAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfVxuICAgIH1cbiAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfVxuICAgIH1cbiAgICBpZiAobXMpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9XG4gICAgfVxuICB9XG4gIGlmIChkdXIuZGF5cykge1xuICAgIGlmIChkdXIuc3BlY2lmaWVkV2Vla3MgJiYgZHVyLmRheXMgJSA3ID09PSAwKSB7XG4gICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBkdXIuZGF5cyAvIDcgfVxuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IGR1ci5kYXlzIH1cbiAgfVxuICBpZiAoZHVyLm1vbnRocykge1xuICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBkdXIubW9udGhzIH1cbiAgfVxuICBpZiAoZHVyLnllYXJzKSB7XG4gICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogZHVyLnllYXJzIH1cbiAgfVxuICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9XG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBwYWRTdGFydCB9IGZyb20gJy4uL3V0aWwvbWlzYydcblxuLy8gdGltZVpvbmVPZmZzZXQgaXMgaW4gbWludXRlc1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSXNvU3RyaW5nKG1hcmtlcjogRGF0ZU1hcmtlciwgdGltZVpvbmVPZmZzZXQ/OiBudW1iZXIsIHN0cmlwWmVyb1RpbWU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICBsZXQgcyA9IG1hcmtlci50b0lTT1N0cmluZygpXG5cbiAgcyA9IHMucmVwbGFjZSgnLjAwMCcsICcnKVxuXG4gIGlmIChzdHJpcFplcm9UaW1lKSB7XG4gICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKVxuICB9XG5cbiAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgaWYgKHRpbWVab25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoJ1onLCAnJylcbiAgICB9IGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXG4gIH1cblxuICByZXR1cm4gc1xufVxuXG4vLyBmb3JtYXRzIHRoZSBkYXRlLCBidXQgd2l0aCBubyB0aW1lIHBhcnRcbi8vIFRPRE86IHNvbWVob3cgbWVyZ2Ugd2l0aCBidWlsZElzb1N0cmluZyBhbmQgc3RyaXBaZXJvVGltZVxuLy8gVE9ETzogcmVuYW1lLiBvbWl0IFwic3RyaW5nXCJcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyOiBEYXRlTWFya2VyKSB7XG4gIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9ULiokLywgJycpXG59XG5cbi8vIFRPRE86IHVzZSBEYXRlOjp0b0lTT1N0cmluZyBhbmQgdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIFQ/XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXI6IERhdGVNYXJrZXIpIHtcbiAgcmV0dXJuIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENIb3VycygpLCAyKSArICc6JyArXG4gICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xuICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENTZWNvbmRzKCksIDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRUaW1lWm9uZU9mZnNldChtaW51dGVzOiBudW1iZXIsIGRvSXNvID0gZmFsc2UpIHtcbiAgbGV0IHNpZ24gPSBtaW51dGVzIDwgMCA/ICctJyA6ICcrJ1xuICBsZXQgYWJzID0gTWF0aC5hYnMobWludXRlcylcbiAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MClcbiAgbGV0IG1pbnMgPSBNYXRoLnJvdW5kKGFicyAlIDYwKVxuXG4gIGlmIChkb0lzbykge1xuICAgIHJldHVybiBgJHtzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnMsIDIpfWBcbiAgfVxuICByZXR1cm4gYEdNVCR7c2lnbn0ke2hvdXJzfSR7bWlucyA/IGA6JHtwYWRTdGFydChtaW5zLCAyKX1gIDogJyd9YFxufVxuIiwiLy8gVE9ETzogbmV3IHV0aWwgYXJyYXlpZnk/XG4vLyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU1hdGNoaW5nKGFycmF5LCB0ZXN0RnVuYykge1xuICBsZXQgcmVtb3ZlQ250ID0gMFxuICBsZXQgaSA9IDBcblxuICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGlmICh0ZXN0RnVuYyhhcnJheVtpXSkpIHsgLy8gdHJ1dGh5IHZhbHVlIG1lYW5zICpyZW1vdmUqXG4gICAgICBhcnJheS5zcGxpY2UoaSwgMSlcbiAgICAgIHJlbW92ZUNudCArPSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIGkgKz0gMVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZW1vdmVDbnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xuICBsZXQgcmVtb3ZlQ250ID0gMFxuICBsZXQgaSA9IDBcblxuICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgIGFycmF5LnNwbGljZShpLCAxKVxuICAgICAgcmVtb3ZlQ250ICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgaSArPSAxXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZUNudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEsIGVxdWFsaXR5RnVuYz86ICh2MCwgdjEpID0+IGJvb2xlYW4pIHsgLy8gVE9ETzogYmV0dGVyIHR5cGluZ1xuICBpZiAoYTAgPT09IGExKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGxldCBsZW4gPSBhMC5sZW5ndGhcbiAgbGV0IGlcblxuICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBpZiAoIShlcXVhbGl0eUZ1bmMgPyBlcXVhbGl0eUZ1bmMoYTBbaV0sIGExW2ldKSA6IGEwW2ldID09PSBhMVtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG4iLCJpbXBvcnQgeyBpc0FycmF5c0VxdWFsIH0gZnJvbSAnLi9hcnJheSdcbmltcG9ydCB7IGlzUHJvcHNFcXVhbCB9IGZyb20gJy4vb2JqZWN0J1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplPEFyZ3MgZXh0ZW5kcyBhbnlbXSwgUmVzPihcbiAgd29ya2VyRnVuYzogKC4uLmFyZ3M6IEFyZ3MpID0+IFJlcyxcbiAgcmVzRXF1YWxpdHk/OiAocmVzMDogUmVzLCByZXMxOiBSZXMpID0+IGJvb2xlYW4sXG4gIHRlYXJkb3duRnVuYz86IChyZXM6IFJlcykgPT4gdm9pZCxcbik6ICguLi5hcmdzOiBBcmdzKSA9PiBSZXMge1xuICBsZXQgY3VycmVudEFyZ3M6IEFyZ3MgfCB1bmRlZmluZWRcbiAgbGV0IGN1cnJlbnRSZXM6IFJlcyB8IHVuZGVmaW5lZFxuXG4gIHJldHVybiBmdW5jdGlvbiAoLi4ubmV3QXJnczogQXJncykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZXNcbiAgICBpZiAoIWN1cnJlbnRBcmdzKSB7XG4gICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKVxuICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ3MsIG5ld0FyZ3MpKSB7XG4gICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKVxuXG4gICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgIGN1cnJlbnRSZXMgPSByZXNcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50QXJncyA9IG5ld0FyZ3NcblxuICAgIHJldHVybiBjdXJyZW50UmVzXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lbW9pemVPYmpBcmc8QXJnIGV4dGVuZHMgRGljdGlvbmFyeSwgUmVzPihcbiAgd29ya2VyRnVuYzogKGFyZzogQXJnKSA9PiBSZXMsXG4gIHJlc0VxdWFsaXR5PzogKHJlczA6IFJlcywgcmVzMTogUmVzKSA9PiBib29sZWFuLFxuICB0ZWFyZG93bkZ1bmM/OiAocmVzOiBSZXMpID0+IHZvaWQsXG4pOiAoYXJnOiBBcmcpID0+IFJlcyB7XG4gIGxldCBjdXJyZW50QXJnOiBBcmcgfCB1bmRlZmluZWRcbiAgbGV0IGN1cnJlbnRSZXM6IFJlcyB8IHVuZGVmaW5lZFxuXG4gIHJldHVybiAobmV3QXJnOiBBcmcpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRBcmcpIHtcbiAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmNhbGwodGhpcywgbmV3QXJnKVxuICAgIH0gZWxzZSBpZiAoIWlzUHJvcHNFcXVhbChjdXJyZW50QXJnLCBuZXdBcmcpKSB7XG4gICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZylcblxuICAgICAgaWYgKCFyZXNFcXVhbGl0eSB8fCAhcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzKSkge1xuICAgICAgICBjdXJyZW50UmVzID0gcmVzXG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudEFyZyA9IG5ld0FyZ1xuXG4gICAgcmV0dXJuIGN1cnJlbnRSZXNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZTxBcmdzIGV4dGVuZHMgYW55W10sIFJlcz4oIC8vIHVzZWQgYXQgYWxsP1xuICB3b3JrZXJGdW5jOiAoLi4uYXJnczogQXJncykgPT4gUmVzLFxuICByZXNFcXVhbGl0eT86IChyZXMwOiBSZXMsIHJlczE6IFJlcykgPT4gYm9vbGVhbixcbiAgdGVhcmRvd25GdW5jPzogKHJlczogUmVzKSA9PiB2b2lkLFxuKTogKGFyZ1NldHM6IEFyZ3NbXSkgPT4gUmVzW10ge1xuICBsZXQgY3VycmVudEFyZ1NldHM6IEFyZ3NbXSA9IFtdXG4gIGxldCBjdXJyZW50UmVzdWx0czogUmVzW10gPSBbXVxuXG4gIHJldHVybiAobmV3QXJnU2V0czogQXJnc1tdKSA9PiB7XG4gICAgbGV0IGN1cnJlbnRMZW4gPSBjdXJyZW50QXJnU2V0cy5sZW5ndGhcbiAgICBsZXQgbmV3TGVuID0gbmV3QXJnU2V0cy5sZW5ndGhcbiAgICBsZXQgaSA9IDBcblxuICAgIGZvciAoOyBpIDwgY3VycmVudExlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoIW5ld0FyZ1NldHNbaV0pIHsgLy8gb25lIG9mIHRoZSBvbGQgc2V0cyBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ1NldHNbaV0sIG5ld0FyZ1NldHNbaV0pKSB7XG4gICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKVxuXG4gICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgY3VycmVudFJlc3VsdHNbaV0gPSByZXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpIDwgbmV3TGVuOyBpICs9IDEpIHtcbiAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdTZXRzW2ldKVxuICAgIH1cblxuICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0c1xuICAgIGN1cnJlbnRSZXN1bHRzLnNwbGljZShuZXdMZW4pIC8vIHJlbW92ZSBleGNlc3NcblxuICAgIHJldHVybiBjdXJyZW50UmVzdWx0c1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplSGFzaGxpa2U8QXJncyBleHRlbmRzIGFueVtdLCBSZXM+KCAvLyB1c2VkP1xuICB3b3JrZXJGdW5jOiAoLi4uYXJnczogQXJncykgPT4gUmVzLFxuICByZXNFcXVhbGl0eT86IChyZXMwOiBSZXMsIHJlczE6IFJlcykgPT4gYm9vbGVhbixcbiAgdGVhcmRvd25GdW5jPzogKHJlczogUmVzKSA9PiB2b2lkLCAvLyBUT0RPOiBjaGFuZ2UgYXJnIG9yZGVyXG4pOiAoYXJnSGFzaDogeyBba2V5OiBzdHJpbmddOiBBcmdzIH0pID0+IHsgW2tleTogc3RyaW5nXTogUmVzIH0ge1xuICBsZXQgY3VycmVudEFyZ0hhc2g6IHsgW2tleTogc3RyaW5nXTogQXJncyB9ID0ge31cbiAgbGV0IGN1cnJlbnRSZXNIYXNoOiB7IFtrZXk6IHN0cmluZ106IFJlcyB9ID0ge31cblxuICByZXR1cm4gKG5ld0FyZ0hhc2g6IHsgW2tleTogc3RyaW5nXTogQXJncyB9KSA9PiB7XG4gICAgbGV0IG5ld1Jlc0hhc2g6IHsgW2tleTogc3RyaW5nXTogUmVzIH0gPSB7fVxuXG4gICAgZm9yIChsZXQga2V5IGluIG5ld0FyZ0hhc2gpIHtcbiAgICAgIGlmICghY3VycmVudFJlc0hhc2hba2V5XSkge1xuICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdIYXNoW2tleV0pXG5cbiAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gKHJlc0VxdWFsaXR5ICYmIHJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc0hhc2hba2V5XSkpXG4gICAgICAgICAgPyBjdXJyZW50UmVzSGFzaFtrZXldXG4gICAgICAgICAgOiByZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50QXJnSGFzaCA9IG5ld0FyZ0hhc2hcbiAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2hcblxuICAgIHJldHVybiBuZXdSZXNIYXNoXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIsIHRpbWVBc01zIH0gZnJvbSAnLi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhclN5c3RlbSB9IGZyb20gJy4vY2FsZW5kYXItc3lzdGVtJ1xuaW1wb3J0IHsgTG9jYWxlIH0gZnJvbSAnLi9sb2NhbGUnXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyLCBEYXRlRm9ybWF0dGluZ0NvbnRleHQgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBab25lZE1hcmtlciB9IGZyb20gJy4vem9uZWQtbWFya2VyJ1xuaW1wb3J0IHsgZm9ybWF0VGltZVpvbmVPZmZzZXQgfSBmcm9tICcuL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnLi4vdXRpbC9tZW1vaXplJ1xuXG5jb25zdCBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUyA9IHtcbiAgd2VlazogMyxcbiAgc2VwYXJhdG9yOiAwLCAvLyAwID0gbm90IGFwcGxpY2FibGVcbiAgb21pdFplcm9NaW51dGU6IDAsXG4gIG1lcmlkaWVtOiAwLCAvLyBsaWtlIGFtL3BtXG4gIG9taXRDb21tYXM6IDAsXG59XG5cbmNvbnN0IFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICB0aW1lWm9uZU5hbWU6IDcsXG4gIGVyYTogNixcbiAgeWVhcjogNSxcbiAgbW9udGg6IDQsXG4gIGRheTogMixcbiAgd2Vla2RheTogMixcbiAgaG91cjogMSxcbiAgbWludXRlOiAxLFxuICBzZWNvbmQ6IDEsXG59XG5cbmNvbnN0IE1FUklESUVNX1JFID0gL1xccyooW2FwXSlcXC4/bVxcLj8vaSAvLyBlYXRzIHVwIGxlYWRpbmcgc3BhY2VzIHRvb1xuY29uc3QgQ09NTUFfUkUgPSAvLC9nIC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcbmNvbnN0IE1VTFRJX1NQQUNFX1JFID0gL1xccysvZ1xuY29uc3QgTFRSX1JFID0gL1xcdTIwMGUvZyAvLyBjb250cm9sIGNoYXJhY3RlclxuY29uc3QgVVRDX1JFID0gL1VUQ3xHTVQvXG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF0aXZlRm9ybWF0dGVyT3B0aW9ucyBleHRlbmRzIEludGwuRGF0ZVRpbWVGb3JtYXRPcHRpb25zIHtcbiAgd2Vlaz86ICdzaG9ydCcgfCAnbmFycm93JyB8ICdudW1lcmljJ1xuICBtZXJpZGllbT86ICdsb3dlcmNhc2UnIHwgJ3Nob3J0JyB8ICduYXJyb3cnIHwgYm9vbGVhblxuICBvbWl0WmVyb01pbnV0ZT86IGJvb2xlYW5cbiAgb21pdENvbW1hcz86IGJvb2xlYW5cbiAgc2VwYXJhdG9yPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjbGFzcyBOYXRpdmVGb3JtYXR0ZXIgaW1wbGVtZW50cyBEYXRlRm9ybWF0dGVyIHtcbiAgc3RhbmRhcmREYXRlUHJvcHM6IGFueVxuICBleHRlbmRlZFNldHRpbmdzOiBhbnlcbiAgc2V2ZXJpdHk6IG51bWJlclxuICBwcml2YXRlIGJ1aWxkRm9ybWF0dGluZ0Z1bmM6IHR5cGVvZiBidWlsZEZvcm1hdHRpbmdGdW5jIC8vIGNhY2hpbmcgZm9yIGVmZmljaWVuY3kgd2l0aCBzYW1lIGRhdGUgZW52XG5cbiAgY29uc3RydWN0b3IoZm9ybWF0U2V0dGluZ3M6IE5hdGl2ZUZvcm1hdHRlck9wdGlvbnMpIHtcbiAgICBsZXQgc3RhbmRhcmREYXRlUHJvcHM6IGFueSA9IHt9XG4gICAgbGV0IGV4dGVuZGVkU2V0dGluZ3M6IGFueSA9IHt9XG4gICAgbGV0IHNldmVyaXR5ID0gMFxuXG4gICAgZm9yIChsZXQgbmFtZSBpbiBmb3JtYXRTZXR0aW5ncykge1xuICAgICAgaWYgKG5hbWUgaW4gRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVMpIHtcbiAgICAgICAgZXh0ZW5kZWRTZXR0aW5nc1tuYW1lXSA9IGZvcm1hdFNldHRpbmdzW25hbWVdXG4gICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoRVhURU5ERURfU0VUVElOR1NfQU5EX1NFVkVSSVRJRVNbbmFtZV0sIHNldmVyaXR5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhbmRhcmREYXRlUHJvcHNbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXVxuXG4gICAgICAgIGlmIChuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxuICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV0sIHNldmVyaXR5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdGFuZGFyZERhdGVQcm9wcyA9IHN0YW5kYXJkRGF0ZVByb3BzXG4gICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5nc1xuICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eVxuXG4gICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKVxuICB9XG5cbiAgZm9ybWF0KGRhdGU6IFpvbmVkTWFya2VyLCBjb250ZXh0OiBEYXRlRm9ybWF0dGluZ0NvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSlcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKHN0YXJ0OiBab25lZE1hcmtlciwgZW5kOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nKSB7XG4gICAgbGV0IHsgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgfSA9IHRoaXNcblxuICAgIGxldCBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSlcbiAgICBpZiAoIWRpZmZTZXZlcml0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHN0YXJ0LCBjb250ZXh0KVxuICAgIH1cblxuICAgIGxldCBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHlcbiAgICBpZiAoXG4gICAgICBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxuICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKVxuICAgICkge1xuICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMSAvLyBtYWtlIGl0IGxvb2sgbGlrZSB0aGUgZGF0ZXMgYXJlIG9ubHkgZGlmZmVyZW50IGluIHRlcm1zIG9mIHRpbWVcbiAgICB9XG5cbiAgICBsZXQgZnVsbDAgPSB0aGlzLmZvcm1hdChzdGFydCwgY29udGV4dClcbiAgICBsZXQgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpXG5cbiAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XG4gICAgICByZXR1cm4gZnVsbDBcbiAgICB9XG5cbiAgICBsZXQgcGFydGlhbERhdGVQcm9wcyA9IGNvbXB1dGVQYXJ0aWFsRm9ybWF0dGluZ09wdGlvbnMoc3RhbmRhcmREYXRlUHJvcHMsIGJpZ2dlc3RVbml0Rm9yUGFydGlhbClcbiAgICBsZXQgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KVxuICAgIGxldCBwYXJ0aWFsMCA9IHBhcnRpYWxGb3JtYXR0aW5nRnVuYyhzdGFydClcbiAgICBsZXQgcGFydGlhbDEgPSBwYXJ0aWFsRm9ybWF0dGluZ0Z1bmMoZW5kKVxuXG4gICAgbGV0IGluc2VydGlvbiA9IGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpXG4gICAgbGV0IHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnXG5cbiAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXJcbiAgICB9XG5cbiAgICByZXR1cm4gZnVsbDAgKyBzZXBhcmF0b3IgKyBmdWxsMVxuICB9XG5cbiAgZ2V0TGFyZ2VzdFVuaXQoKSB7XG4gICAgc3dpdGNoICh0aGlzLnNldmVyaXR5KSB7XG4gICAgICBjYXNlIDc6XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJldHVybiAneWVhcidcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuICdtb250aCdcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuICd3ZWVrJ1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gJ2RheSdcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAndGltZScgLy8gcmVhbGx5P1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKFxuICBzdGFuZGFyZERhdGVQcm9wcyxcbiAgZXh0ZW5kZWRTZXR0aW5ncyxcbiAgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LFxuKTogKGRhdGU6IFpvbmVkTWFya2VyKSA9PiBzdHJpbmcge1xuICBsZXQgc3RhbmRhcmREYXRlUHJvcENudCA9IE9iamVjdC5rZXlzKHN0YW5kYXJkRGF0ZVByb3BzKS5sZW5ndGhcblxuICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICByZXR1cm4gKGRhdGU6IFpvbmVkTWFya2VyKSA9PiAoXG4gICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xuICAgIHJldHVybiAoZGF0ZTogWm9uZWRNYXJrZXIpID0+IChcbiAgICAgIGZvcm1hdFdlZWtOdW1iZXIoXG4gICAgICAgIGNvbnRleHQuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZS5tYXJrZXIpLFxuICAgICAgICBjb250ZXh0LndlZWtUZXh0LFxuICAgICAgICBjb250ZXh0LmxvY2FsZSxcbiAgICAgICAgZXh0ZW5kZWRTZXR0aW5ncy53ZWVrLFxuICAgICAgKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKFxuICBzdGFuZGFyZERhdGVQcm9wcyxcbiAgZXh0ZW5kZWRTZXR0aW5ncyxcbiAgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LFxuKTogKGRhdGU6IFpvbmVkTWFya2VyKSA9PiBzdHJpbmcge1xuICBzdGFuZGFyZERhdGVQcm9wcyA9IHsgLi4uc3RhbmRhcmREYXRlUHJvcHMgfSAvLyBjb3B5XG4gIGV4dGVuZGVkU2V0dGluZ3MgPSB7IC4uLmV4dGVuZGVkU2V0dGluZ3MgfSAvLyBjb3B5XG5cbiAgc2FuaXRpemVTZXR0aW5ncyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncylcblxuICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnIC8vIHdlIGxldmVyYWdlIHRoZSBvbmx5IGd1YXJhbnRlZWQgdGltZVpvbmUgZm9yIG91ciBVVEMgbWFya2Vyc1xuXG4gIGxldCBub3JtYWxGb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2Rlcywgc3RhbmRhcmREYXRlUHJvcHMpXG4gIGxldCB6ZXJvRm9ybWF0IC8vIG5lZWRlZD9cblxuICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgIGxldCB6ZXJvUHJvcHMgPSB7IC4uLnN0YW5kYXJkRGF0ZVByb3BzIH1cbiAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZSAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXG4gICAgemVyb0Zvcm1hdCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGNvbnRleHQubG9jYWxlLmNvZGVzLCB6ZXJvUHJvcHMpXG4gIH1cblxuICByZXR1cm4gKGRhdGU6IFpvbmVkTWFya2VyKSA9PiB7XG4gICAgbGV0IHsgbWFya2VyIH0gPSBkYXRlXG4gICAgbGV0IGZvcm1hdFxuXG4gICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcbiAgICAgIGZvcm1hdCA9IHplcm9Gb3JtYXRcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0XG4gICAgfVxuXG4gICAgbGV0IHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcilcblxuICAgIHJldHVybiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dClcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gIC8vIGRlYWwgd2l0aCBhIGJyb3dzZXIgaW5jb25zaXN0ZW5jeSB3aGVyZSBmb3JtYXR0aW5nIHRoZSB0aW1lem9uZVxuICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxuICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XG4gICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnXG4gICAgfVxuICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XG4gICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCdcbiAgICB9XG4gIH1cblxuICAvLyBvbmx5IHN1cHBvcnQgc2hvcnQgdGltZXpvbmUgbmFtZXNcbiAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID0gJ3Nob3J0J1xuICB9XG5cbiAgLy8gaWYgcmVxdWVzdGluZyB0byBkaXNwbGF5IHNlY29uZHMsIE1VU1QgZGlzcGxheSBtaW51dGVzXG4gIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XG4gICAgZGVsZXRlIGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGVcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzOiBzdHJpbmcsIGRhdGU6IFpvbmVkTWFya2VyLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0KTogc3RyaW5nIHtcbiAgcyA9IHMucmVwbGFjZShMVFJfUkUsICcnKSAvLyByZW1vdmUgbGVmdC10by1yaWdodCBjb250cm9sIGNoYXJzLiBkbyBmaXJzdC4gZ29vZCBmb3Igb3RoZXIgcmVnZXhlc1xuXG4gIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICBzID0gaW5qZWN0VHpvU3RyKFxuICAgICAgcyxcbiAgICAgIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgJ1VUQycgOiAvLyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIGZvciBJRSwgd2hpY2ggZG9lcyBcIkdNVFwiXG4gICAgICAgIGZvcm1hdFRpbWVab25lT2Zmc2V0KGRhdGUudGltZVpvbmVPZmZzZXQpLFxuICAgIClcbiAgfVxuXG4gIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRDb21tYXMpIHtcbiAgICBzID0gcy5yZXBsYWNlKENPTU1BX1JFLCAnJykudHJpbSgpXG4gIH1cblxuICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSkge1xuICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKSAvLyB6ZXJvRm9ybWF0IGRvZXNuJ3QgYWx3YXlzIGFjaGlldmUgdGhpc1xuICB9XG5cbiAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gIC8vIGJlY2F1c2UgTUVSSURJRU1fUkUgbGlrZXMgdG8gZWF0IHVwIGxvYWRpbmcgc3BhY2VzXG5cbiAgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09IGZhbHNlKSB7XG4gICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKVxuICB9IGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICduYXJyb3cnKSB7IC8vIGEvcFxuICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkpXG4gIH0gZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ3Nob3J0JykgeyAvLyBhbS9wbVxuICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCwgbTEpID0+IGAke20xLnRvTG9jYWxlTG93ZXJDYXNlKCl9bWApXG4gIH0gZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ2xvd2VyY2FzZScpIHsgLy8gb3RoZXIgbWVyaWRpZW0gdHJhbnNmb3JtZXJzIGFscmVhZHkgY29udmVydGVkIHRvIGxvd2VyY2FzZVxuICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIChtMCkgPT4gbTAudG9Mb2NhbGVMb3dlckNhc2UoKSlcbiAgfVxuXG4gIHMgPSBzLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsICcgJylcbiAgcyA9IHMudHJpbSgpXG5cbiAgcmV0dXJuIHNcbn1cblxuZnVuY3Rpb24gaW5qZWN0VHpvU3RyKHM6IHN0cmluZywgdHpvU3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgcmVwbGFjZWQgPSBmYWxzZVxuXG4gIHMgPSBzLnJlcGxhY2UoVVRDX1JFLCAoKSA9PiB7XG4gICAgcmVwbGFjZWQgPSB0cnVlXG4gICAgcmV0dXJuIHR6b1N0clxuICB9KVxuXG4gIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxuICBpZiAoIXJlcGxhY2VkKSB7XG4gICAgcyArPSBgICR7dHpvU3RyfWBcbiAgfVxuXG4gIHJldHVybiBzXG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXIobnVtOiBudW1iZXIsIHdlZWtUZXh0OiBzdHJpbmcsIGxvY2FsZTogTG9jYWxlLCBkaXNwbGF5PzogJ251bWVyaWMnIHwgJ25hcnJvdycgfCAnc2hvcnQnKTogc3RyaW5nIHtcbiAgbGV0IHBhcnRzID0gW11cblxuICBpZiAoZGlzcGxheSA9PT0gJ25hcnJvdycpIHtcbiAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0KVxuICB9IGVsc2UgaWYgKGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcbiAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0LCAnICcpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCBjb25zaWRlcmVkICdudW1lcmljJ1xuXG4gIHBhcnRzLnB1c2gobG9jYWxlLnNpbXBsZU51bWJlckZvcm1hdC5mb3JtYXQobnVtKSlcblxuICBpZiAobG9jYWxlLm9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBUT0RPOiB1c2UgY29udHJvbCBjaGFyYWN0ZXJzIGluc3RlYWQ/XG4gICAgcGFydHMucmV2ZXJzZSgpXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuLy8gUmFuZ2UgRm9ybWF0dGluZyBVdGlsc1xuXG4vLyAwID0gZXhhY3RseSB0aGUgc2FtZVxuLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXG4vLyBhbmQgYmlnZ2VyXG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwOiBEYXRlTWFya2VyLCBkMTogRGF0ZU1hcmtlciwgY2E6IENhbGVuZGFyU3lzdGVtKSB7XG4gIGlmIChjYS5nZXRNYXJrZXJZZWFyKGQwKSAhPT0gY2EuZ2V0TWFya2VyWWVhcihkMSkpIHtcbiAgICByZXR1cm4gNVxuICB9XG4gIGlmIChjYS5nZXRNYXJrZXJNb250aChkMCkgIT09IGNhLmdldE1hcmtlck1vbnRoKGQxKSkge1xuICAgIHJldHVybiA0XG4gIH1cbiAgaWYgKGNhLmdldE1hcmtlckRheShkMCkgIT09IGNhLmdldE1hcmtlckRheShkMSkpIHtcbiAgICByZXR1cm4gMlxuICB9XG4gIGlmICh0aW1lQXNNcyhkMCkgIT09IHRpbWVBc01zKGQxKSkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xuICBsZXQgcGFydGlhbE9wdGlvbnMgPSB7fVxuXG4gIGZvciAobGV0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChcbiAgICAgICEobmFtZSBpbiBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUykgfHwgLy8gbm90IGEgZGF0ZSBwYXJ0IHByb3AgKGxpa2UgdGltZVpvbmUpXG4gICAgICBTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFU1tuYW1lXSA8PSBiaWdnZXN0VW5pdFxuICAgICkge1xuICAgICAgcGFydGlhbE9wdGlvbnNbbmFtZV0gPSBvcHRpb25zW25hbWVdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRpYWxPcHRpb25zXG59XG5cbmZ1bmN0aW9uIGZpbmRDb21tb25JbnNlcnRpb24oZnVsbDAsIHBhcnRpYWwwLCBmdWxsMSwgcGFydGlhbDEpIHtcbiAgbGV0IGkwID0gMFxuICB3aGlsZSAoaTAgPCBmdWxsMC5sZW5ndGgpIHtcbiAgICBsZXQgZm91bmQwID0gZnVsbDAuaW5kZXhPZihwYXJ0aWFsMCwgaTApXG4gICAgaWYgKGZvdW5kMCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgbGV0IGJlZm9yZTAgPSBmdWxsMC5zdWJzdHIoMCwgZm91bmQwKVxuICAgIGkwID0gZm91bmQwICsgcGFydGlhbDAubGVuZ3RoXG4gICAgbGV0IGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMClcblxuICAgIGxldCBpMSA9IDBcbiAgICB3aGlsZSAoaTEgPCBmdWxsMS5sZW5ndGgpIHtcbiAgICAgIGxldCBmb3VuZDEgPSBmdWxsMS5pbmRleE9mKHBhcnRpYWwxLCBpMSlcbiAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGxldCBiZWZvcmUxID0gZnVsbDEuc3Vic3RyKDAsIGZvdW5kMSlcbiAgICAgIGkxID0gZm91bmQxICsgcGFydGlhbDEubGVuZ3RoXG4gICAgICBsZXQgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKVxuXG4gICAgICBpZiAoYmVmb3JlMCA9PT0gYmVmb3JlMSAmJiBhZnRlcjAgPT09IGFmdGVyMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJlZm9yZTogYmVmb3JlMCxcbiAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuL21hcmtlcidcbmltcG9ydCB7IENhbGVuZGFyU3lzdGVtIH0gZnJvbSAnLi9jYWxlbmRhci1zeXN0ZW0nXG5cbmV4cG9ydCBpbnRlcmZhY2UgWm9uZWRNYXJrZXIge1xuICBtYXJrZXI6IERhdGVNYXJrZXIsXG4gIHRpbWVab25lT2Zmc2V0OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBhbmRlZFpvbmVkTWFya2VyIGV4dGVuZHMgWm9uZWRNYXJrZXIge1xuICBhcnJheTogbnVtYmVyW10sXG4gIHllYXI6IG51bWJlcixcbiAgbW9udGg6IG51bWJlcixcbiAgZGF5OiBudW1iZXIsXG4gIGhvdXI6IG51bWJlcixcbiAgbWludXRlOiBudW1iZXIsXG4gIHNlY29uZDogbnVtYmVyLFxuICBtaWxsaXNlY29uZDogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRab25lZE1hcmtlcihkYXRlSW5mbzogWm9uZWRNYXJrZXIsIGNhbGVuZGFyU3lzdGVtOiBDYWxlbmRhclN5c3RlbSk6IEV4cGFuZGVkWm9uZWRNYXJrZXIge1xuICBsZXQgYSA9IGNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkoZGF0ZUluZm8ubWFya2VyKVxuXG4gIHJldHVybiB7XG4gICAgbWFya2VyOiBkYXRlSW5mby5tYXJrZXIsXG4gICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVJbmZvLnRpbWVab25lT2Zmc2V0LFxuICAgIGFycmF5OiBhLFxuICAgIHllYXI6IGFbMF0sXG4gICAgbW9udGg6IGFbMV0sXG4gICAgZGF5OiBhWzJdLFxuICAgIGhvdXI6IGFbM10sXG4gICAgbWludXRlOiBhWzRdLFxuICAgIHNlY29uZDogYVs1XSxcbiAgICBtaWxsaXNlY29uZDogYVs2XSxcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vbWFya2VyJ1xuaW1wb3J0IHsgQ2FsZW5kYXJTeXN0ZW0gfSBmcm9tICcuL2NhbGVuZGFyLXN5c3RlbSdcbmltcG9ydCB7IExvY2FsZSB9IGZyb20gJy4vbG9jYWxlJ1xuaW1wb3J0IHsgWm9uZWRNYXJrZXIsIEV4cGFuZGVkWm9uZWRNYXJrZXIsIGV4cGFuZFpvbmVkTWFya2VyIH0gZnJvbSAnLi96b25lZC1tYXJrZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyYm9zZUZvcm1hdHRpbmdBcmcgeyAvLyBUT0RPOiBraWxsIHRoaXNcbiAgZGF0ZTogRXhwYW5kZWRab25lZE1hcmtlclxuICBzdGFydDogRXhwYW5kZWRab25lZE1hcmtlclxuICBlbmQ/OiBFeHBhbmRlZFpvbmVkTWFya2VyXG4gIHRpbWVab25lOiBzdHJpbmdcbiAgbG9jYWxlQ29kZXM6IHN0cmluZ1tdLFxuICBkZWZhdWx0U2VwYXJhdG9yOiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKFxuICBzdGFydDogWm9uZWRNYXJrZXIsXG4gIGVuZDogWm9uZWRNYXJrZXIsXG4gIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCxcbiAgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZyxcbik6IFZlcmJvc2VGb3JtYXR0aW5nQXJnIHtcbiAgbGV0IHN0YXJ0SW5mbyA9IGV4cGFuZFpvbmVkTWFya2VyKHN0YXJ0LCBjb250ZXh0LmNhbGVuZGFyU3lzdGVtKVxuICBsZXQgZW5kSW5mbyA9IGVuZCA/IGV4cGFuZFpvbmVkTWFya2VyKGVuZCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSkgOiBudWxsXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRlOiBzdGFydEluZm8sXG4gICAgc3RhcnQ6IHN0YXJ0SW5mbyxcbiAgICBlbmQ6IGVuZEluZm8sXG4gICAgdGltZVpvbmU6IGNvbnRleHQudGltZVpvbmUsXG4gICAgbG9jYWxlQ29kZXM6IGNvbnRleHQubG9jYWxlLmNvZGVzLFxuICAgIGRlZmF1bHRTZXBhcmF0b3I6IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yLFxuICB9XG59XG5cbmV4cG9ydCB0eXBlIENtZEZvcm1hdHRlckZ1bmMgPSAoY21kOiBzdHJpbmcsIGFyZzogVmVyYm9zZUZvcm1hdHRpbmdBcmcpID0+IHN0cmluZ1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVGb3JtYXR0aW5nQ29udGV4dCB7XG4gIHRpbWVab25lOiBzdHJpbmcsXG4gIGxvY2FsZTogTG9jYWxlLFxuICBjYWxlbmRhclN5c3RlbTogQ2FsZW5kYXJTeXN0ZW1cbiAgY29tcHV0ZVdlZWtOdW1iZXI6IChkOiBEYXRlTWFya2VyKSA9PiBudW1iZXJcbiAgd2Vla1RleHQ6IHN0cmluZ1xuICBjbWRGb3JtYXR0ZXI/OiBDbWRGb3JtYXR0ZXJGdW5jXG4gIGRlZmF1bHRTZXBhcmF0b3I6IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVGb3JtYXR0ZXIge1xuICBmb3JtYXQoZGF0ZTogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCk6IHN0cmluZ1xuICBmb3JtYXRSYW5nZShzdGFydDogWm9uZWRNYXJrZXIsIGVuZDogWm9uZWRNYXJrZXIsIGNvbnRleHQ6IERhdGVGb3JtYXR0aW5nQ29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcj86IHN0cmluZyk6IHN0cmluZ1xufVxuIiwiaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciwgRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyB9IGZyb20gJy4vRGF0ZUZvcm1hdHRlcidcbmltcG9ydCB7IFpvbmVkTWFya2VyIH0gZnJvbSAnLi96b25lZC1tYXJrZXInXG5cbi8qXG5UT0RPOiBmaXggdGhlIHRlcm1pbm9sb2d5IG9mIFwiZm9ybWF0dGVyXCIgdnMgXCJmb3JtYXR0aW5nIGZ1bmNcIlxuKi9cblxuLypcbkF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxuSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXG4qL1xuZXhwb3J0IGNsYXNzIENtZEZvcm1hdHRlciBpbXBsZW1lbnRzIERhdGVGb3JtYXR0ZXIge1xuICBjbWRTdHI6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGNtZFN0cjogc3RyaW5nKSB7XG4gICAgdGhpcy5jbWRTdHIgPSBjbWRTdHJcbiAgfVxuXG4gIGZvcm1hdChkYXRlOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY21kRm9ybWF0dGVyKHRoaXMuY21kU3RyLCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSlcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKHN0YXJ0OiBab25lZE1hcmtlciwgZW5kOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY21kRm9ybWF0dGVyKHRoaXMuY21kU3RyLCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciwgRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZywgVmVyYm9zZUZvcm1hdHRpbmdBcmcgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBab25lZE1hcmtlciB9IGZyb20gJy4vem9uZWQtbWFya2VyJ1xuXG5leHBvcnQgdHlwZSBGdW5jRm9ybWF0dGVyRnVuYyA9IChhcmc6IFZlcmJvc2VGb3JtYXR0aW5nQXJnKSA9PiBzdHJpbmdcblxuZXhwb3J0IGNsYXNzIEZ1bmNGb3JtYXR0ZXIgaW1wbGVtZW50cyBEYXRlRm9ybWF0dGVyIHtcbiAgZnVuYzogRnVuY0Zvcm1hdHRlckZ1bmNcblxuICBjb25zdHJ1Y3RvcihmdW5jOiBGdW5jRm9ybWF0dGVyRnVuYykge1xuICAgIHRoaXMuZnVuYyA9IGZ1bmNcbiAgfVxuXG4gIGZvcm1hdChkYXRlOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhkYXRlLCBudWxsLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSlcbiAgfVxuXG4gIGZvcm1hdFJhbmdlKHN0YXJ0OiBab25lZE1hcmtlciwgZW5kOiBab25lZE1hcmtlciwgY29udGV4dDogRGF0ZUZvcm1hdHRpbmdDb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgTmF0aXZlRm9ybWF0dGVyLCBOYXRpdmVGb3JtYXR0ZXJPcHRpb25zIH0gZnJvbSAnLi9mb3JtYXR0aW5nLW5hdGl2ZSdcbmltcG9ydCB7IENtZEZvcm1hdHRlciB9IGZyb20gJy4vZm9ybWF0dGluZy1jbWQnXG5pbXBvcnQgeyBGdW5jRm9ybWF0dGVyLCBGdW5jRm9ybWF0dGVyRnVuYyB9IGZyb20gJy4vZm9ybWF0dGluZy1mdW5jJ1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4vRGF0ZUZvcm1hdHRlcidcblxuZXhwb3J0IHR5cGUgRm9ybWF0dGVySW5wdXQgPSBOYXRpdmVGb3JtYXR0ZXJPcHRpb25zIHwgc3RyaW5nIHwgRnVuY0Zvcm1hdHRlckZ1bmNcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihpbnB1dDogRm9ybWF0dGVySW5wdXQpOiBEYXRlRm9ybWF0dGVyIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgcmV0dXJuIG5ldyBOYXRpdmVGb3JtYXR0ZXIoaW5wdXQpXG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBuZXcgRnVuY0Zvcm1hdHRlcihpbnB1dCBhcyBGdW5jRm9ybWF0dGVyRnVuYylcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiB9IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IG1lcmdlUHJvcHMsIGlzUHJvcHNFcXVhbCB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IHBhcnNlRmllbGRTcGVjcyB9IGZyb20gJy4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgQ3NzRGltVmFsdWUsXG4gIERhdGVJbnB1dCxcbiAgRGF0ZVJhbmdlSW5wdXQsXG4gIEJ1c2luZXNzSG91cnNJbnB1dCxcbiAgRXZlbnRTb3VyY2VJbnB1dCxcbiAgVmlld0FwaSxcbiAgTG9jYWxlU2luZ3VsYXJBcmcsIExvY2FsZUlucHV0LFxuICBFdmVudElucHV0LCBFdmVudElucHV0VHJhbnNmb3JtZXIsXG4gIE92ZXJsYXBGdW5jLCBDb25zdHJhaW50SW5wdXQsIEFsbG93RnVuYyxcbiAgUGx1Z2luRGVmLFxuICBWaWV3Q29tcG9uZW50VHlwZSxcbiAgU3BlY2lmaWNWaWV3Q29udGVudEFyZywgU3BlY2lmaWNWaWV3TW91bnRBcmcsXG4gIENsYXNzTmFtZXNHZW5lcmF0b3IsIEN1c3RvbUNvbnRlbnRHZW5lcmF0b3IsIERpZE1vdW50SGFuZGxlciwgV2lsbFVubW91bnRIYW5kbGVyLFxuICBOb3dJbmRpY2F0b3JDb250ZW50QXJnLCBOb3dJbmRpY2F0b3JNb3VudEFyZyxcbiAgV2Vla051bWJlckNvbnRlbnRBcmcsIFdlZWtOdW1iZXJNb3VudEFyZyxcbiAgU2xvdExhbmVDb250ZW50QXJnLCBTbG90TGFuZU1vdW50QXJnLFxuICBTbG90TGFiZWxDb250ZW50QXJnLCBTbG90TGFiZWxNb3VudEFyZyxcbiAgQWxsRGF5Q29udGVudEFyZywgQWxsRGF5TW91bnRBcmcsXG4gIERheUhlYWRlckNvbnRlbnRBcmcsIERheUhlYWRlck1vdW50QXJnLFxuICBEYXlDZWxsQ29udGVudEFyZywgRGF5Q2VsbE1vdW50QXJnLFxuICBWaWV3Q29udGVudEFyZywgVmlld01vdW50QXJnLFxuICBFdmVudENsaWNrQXJnLFxuICBFdmVudEhvdmVyaW5nQXJnLFxuICBEYXRlU2VsZWN0QXJnLCBEYXRlVW5zZWxlY3RBcmcsXG4gIENhbGVuZGFyQXBpLFxuICBWVUlFdmVudCxcbiAgV2Vla051bWJlckNhbGN1bGF0aW9uLFxuICBGb3JtYXR0ZXJJbnB1dCxcbiAgVG9vbGJhcklucHV0LCBDdXN0b21CdXR0b25JbnB1dCwgQnV0dG9uSWNvbnNJbnB1dCwgQnV0dG9uVGV4dENvbXBvdW5kSW5wdXQsXG4gIEV2ZW50Q29udGVudEFyZywgRXZlbnRNb3VudEFyZyxcbiAgRGF0ZXNTZXRBcmcsXG4gIEV2ZW50QXBpLCBFdmVudEFkZEFyZywgRXZlbnRDaGFuZ2VBcmcsIEV2ZW50UmVtb3ZlQXJnLFxuICBNb3JlTGlua0NvbnRlbnRBcmcsXG4gIE1vcmVMaW5rTW91bnRBcmcsXG4gIE1vcmVMaW5rQWN0aW9uLFxufSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cbi8vIGJhc2Ugb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgbmF2TGlua0RheUNsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTxzdHJpbmcgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCBkYXRlOiBEYXRlLCBqc0V2ZW50OiBWVUlFdmVudCkgPT4gdm9pZCk+LFxuICBuYXZMaW5rV2Vla0NsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTxzdHJpbmcgfCAoKHRoaXM6IENhbGVuZGFyQXBpLCB3ZWVrU3RhcnQ6IERhdGUsIGpzRXZlbnQ6IFZVSUV2ZW50KSA9PiB2b2lkKT4sXG4gIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgYm9vdHN0cmFwRm9udEF3ZXNvbWU6IGlkZW50aXR5IGFzIElkZW50aXR5PEJ1dHRvbkljb25zSW5wdXQgfCBmYWxzZT4sIC8vIFRPRE86IG1vdmUgdG8gYm9vdHN0cmFwIHBsdWdpblxuICBidXR0b25JY29uczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8QnV0dG9uSWNvbnNJbnB1dCB8IGZhbHNlPixcbiAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8eyBbbmFtZTogc3RyaW5nXTogQ3VzdG9tQnV0dG9uSW5wdXQgfT4sXG4gIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxuICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgc2Nyb2xsVGltZVJlc2V0OiBCb29sZWFuLFxuICBzbG90TWluVGltZTogY3JlYXRlRHVyYXRpb24sXG4gIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgZGF5UG9wb3ZlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICBzbG90RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICBoZWFkZXJUb29sYmFyOiBpZGVudGl0eSBhcyBJZGVudGl0eTxUb29sYmFySW5wdXQgfCBmYWxzZT4sXG4gIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5IGFzIElkZW50aXR5PFRvb2xiYXJJbnB1dCB8IGZhbHNlPixcbiAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgZm9yY2VFdmVudER1cmF0aW9uOiBCb29sZWFuLFxuXG4gIGRheUhlYWRlcnM6IEJvb2xlYW4sXG4gIGRheUhlYWRlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPERheUhlYWRlckNvbnRlbnRBcmc+PixcbiAgZGF5SGVhZGVyQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxEYXlIZWFkZXJDb250ZW50QXJnPj4sXG4gIGRheUhlYWRlckRpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8RGF5SGVhZGVyTW91bnRBcmc+PixcbiAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxEYXlIZWFkZXJNb3VudEFyZz4+LFxuXG4gIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPERheUNlbGxDb250ZW50QXJnPj4sXG4gIGRheUNlbGxDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPERheUNlbGxDb250ZW50QXJnPj4sXG4gIGRheUNlbGxEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPERheUNlbGxNb3VudEFyZz4+LFxuICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxEYXlDZWxsTW91bnRBcmc+PixcblxuICBpbml0aWFsVmlldzogU3RyaW5nLFxuICBhc3BlY3RSYXRpbzogTnVtYmVyLFxuICB3ZWVrZW5kczogQm9vbGVhbixcblxuICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5IGFzIElkZW50aXR5PFdlZWtOdW1iZXJDYWxjdWxhdGlvbj4sXG4gIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICB3ZWVrTnVtYmVyQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxXZWVrTnVtYmVyQ29udGVudEFyZz4+LFxuICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxXZWVrTnVtYmVyQ29udGVudEFyZz4+LFxuICB3ZWVrTnVtYmVyRGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxXZWVrTnVtYmVyTW91bnRBcmc+PixcbiAgd2Vla051bWJlcldpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8V2Vla051bWJlck1vdW50QXJnPj4sXG5cbiAgZWRpdGFibGU6IEJvb2xlYW4sXG5cbiAgdmlld0NsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8Vmlld0NvbnRlbnRBcmc+PixcbiAgdmlld0RpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8Vmlld01vdW50QXJnPj4sXG4gIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPFZpZXdNb3VudEFyZz4+LFxuXG4gIG5vd0luZGljYXRvcjogQm9vbGVhbixcbiAgbm93SW5kaWNhdG9yQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxOb3dJbmRpY2F0b3JDb250ZW50QXJnPj4sXG4gIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8Tm93SW5kaWNhdG9yQ29udGVudEFyZz4+LFxuICBub3dJbmRpY2F0b3JEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPE5vd0luZGljYXRvck1vdW50QXJnPj4sXG4gIG5vd0luZGljYXRvcldpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8Tm93SW5kaWNhdG9yTW91bnRBcmc+PixcblxuICBzaG93Tm9uQ3VycmVudERhdGVzOiBCb29sZWFuLFxuICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgZW5kUGFyYW06IFN0cmluZyxcbiAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICB0aW1lWm9uZTogU3RyaW5nLFxuICBsb2NhbGVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxMb2NhbGVJbnB1dFtdPixcbiAgbG9jYWxlOiBpZGVudGl0eSBhcyBJZGVudGl0eTxMb2NhbGVTaW5ndWxhckFyZz4sXG4gIHRoZW1lU3lzdGVtOiBTdHJpbmcgYXMgSWRlbnRpdHk8J3N0YW5kYXJkJyB8IHN0cmluZz4sXG4gIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICBkcmFnU2Nyb2xsOiBCb29sZWFuLFxuICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBCb29sZWFuLFxuICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gIGRyb3BBY2NlcHQ6IGlkZW50aXR5IGFzIElkZW50aXR5PHN0cmluZyB8ICgodGhpczogQ2FsZW5kYXJBcGksIGRyYWdnYWJsZTogYW55KSA9PiBib29sZWFuKT4sIC8vIFRPRE86IHR5cGUgZHJhZ2dhYmxlXG4gIGV2ZW50T3JkZXI6IHBhcnNlRmllbGRTcGVjcyxcbiAgZXZlbnRPcmRlclN0cmljdDogQm9vbGVhbixcblxuICBoYW5kbGVXaW5kb3dSZXNpemU6IEJvb2xlYW4sXG4gIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gIGxvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiBOdW1iZXIsXG4gIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gIGhlaWdodDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3NzRGltVmFsdWU+LFxuICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDc3NEaW1WYWx1ZT4sXG4gIGRpcmVjdGlvbjogU3RyaW5nIGFzIElkZW50aXR5PCdsdHInIHwgJ3J0bCc+LFxuICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBCb29sZWFuLFxuICBkaXNwbGF5RXZlbnRUaW1lOiBCb29sZWFuLFxuICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gIHdlZWtUZXh0OiBTdHJpbmcsXG4gIHByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmc6IEJvb2xlYW4sXG4gIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5IGFzIElkZW50aXR5PEJ1c2luZXNzSG91cnNJbnB1dD4sXG4gIGluaXRpYWxEYXRlOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBub3c6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dCB8ICgodGhpczogQ2FsZW5kYXJBcGkpID0+IERhdGVJbnB1dCk+LFxuICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50SW5wdXRUcmFuc2Zvcm1lcj4sXG4gIHN0aWNreUhlYWRlckRhdGVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuIHwgJ2F1dG8nPixcbiAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuIHwgJ2F1dG8nPixcbiAgdmlld0hlaWdodDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3NzRGltVmFsdWU+LFxuICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxuICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5IGFzIElkZW50aXR5PCh0aGlzOiBDYWxlbmRhckFwaSwgZXJyb3I6IGFueSkgPT4gdm9pZD4sXG4gIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KHRoaXM6IENhbGVuZGFyQXBpLCBldmVudHNJbnB1dDogRXZlbnRJbnB1dFtdLCB4aHI/OiBYTUxIdHRwUmVxdWVzdCkgPT4gRXZlbnRJbnB1dFtdIHwgdm9pZD4sXG5cbiAgZXZlbnREaXNwbGF5OiBTdHJpbmcsIC8vIFRPRE86IGdpdmUgbW9yZSBzcGVjaWZpY1xuICBldmVudFN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgZXZlbnRPdmVybGFwOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuIHwgT3ZlcmxhcEZ1bmM+LFxuICBldmVudENvbnN0cmFpbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PENvbnN0cmFpbnRJbnB1dD4sXG4gIGV2ZW50QWxsb3c6IGlkZW50aXR5IGFzIElkZW50aXR5PEFsbG93RnVuYz4sXG4gIGV2ZW50QmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gIGV2ZW50Qm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgZXZlbnRDb2xvcjogU3RyaW5nLFxuICBldmVudENsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8RXZlbnRDb250ZW50QXJnPj4sXG4gIGV2ZW50Q29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxFdmVudENvbnRlbnRBcmc+PixcbiAgZXZlbnREaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPEV2ZW50TW91bnRBcmc+PixcbiAgZXZlbnRXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPEV2ZW50TW91bnRBcmc+PixcblxuICBzZWxlY3RDb25zdHJhaW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDb25zdHJhaW50SW5wdXQ+LFxuICBzZWxlY3RPdmVybGFwOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuIHwgT3ZlcmxhcEZ1bmM+LFxuICBzZWxlY3RBbGxvdzogaWRlbnRpdHkgYXMgSWRlbnRpdHk8QWxsb3dGdW5jPixcblxuICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gIHVuc2VsZWN0Q2FuY2VsOiBTdHJpbmcsXG5cbiAgc2xvdExhYmVsRm9ybWF0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxGb3JtYXR0ZXJJbnB1dCB8IEZvcm1hdHRlcklucHV0W10+LFxuXG4gIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxTbG90TGFuZUNvbnRlbnRBcmc+PixcbiAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPFNsb3RMYW5lQ29udGVudEFyZz4+LFxuICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8U2xvdExhbmVNb3VudEFyZz4+LFxuICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8U2xvdExhbmVNb3VudEFyZz4+LFxuXG4gIHNsb3RMYWJlbENsYXNzTmFtZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PENsYXNzTmFtZXNHZW5lcmF0b3I8U2xvdExhYmVsQ29udGVudEFyZz4+LFxuICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPFNsb3RMYWJlbENvbnRlbnRBcmc+PixcbiAgc2xvdExhYmVsRGlkTW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERpZE1vdW50SGFuZGxlcjxTbG90TGFiZWxNb3VudEFyZz4+LFxuICBzbG90TGFiZWxXaWxsVW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8V2lsbFVubW91bnRIYW5kbGVyPFNsb3RMYWJlbE1vdW50QXJnPj4sXG5cbiAgZGF5TWF4RXZlbnRzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuIHwgbnVtYmVyPixcbiAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuIHwgbnVtYmVyPixcbiAgZGF5TWluV2lkdGg6IE51bWJlcixcbiAgc2xvdExhYmVsSW50ZXJ2YWw6IGNyZWF0ZUR1cmF0aW9uLFxuXG4gIGFsbERheVRleHQ6IFN0cmluZyxcbiAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxBbGxEYXlDb250ZW50QXJnPj4sXG4gIGFsbERheUNvbnRlbnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8QWxsRGF5Q29udGVudEFyZz4+LFxuICBhbGxEYXlEaWRNb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGlkTW91bnRIYW5kbGVyPEFsbERheU1vdW50QXJnPj4sXG4gIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8QWxsRGF5TW91bnRBcmc+PixcblxuICBzbG90TWluV2lkdGg6IE51bWJlciwgLy8gbW92ZSB0byB0aW1lbGluZT9cbiAgbmF2TGlua3M6IEJvb2xlYW4sXG4gIGV2ZW50VGltZUZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICByZXJlbmRlckRlbGF5OiBOdW1iZXIsIC8vIFRPRE86IG1vdmUgdG8gQGZ1bGxjYWxlbmRhci9jb3JlIHJpZ2h0PyBuYWgga2VlcCBoZXJlXG4gIG1vcmVMaW5rVGV4dDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8c3RyaW5nIHwgKCh0aGlzOiBDYWxlbmRhckFwaSwgbnVtOiBudW1iZXIpID0+IHN0cmluZyk+LCAvLyB0aGlzIG5vdCBlbmZvcmNlZCA6KCBjaGVjayBvdGhlcnMgdG9vXG4gIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gIHNlbGVjdGFibGU6IEJvb2xlYW4sXG4gIHNlbGVjdExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcblxuICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gIGV2ZW50TWF4U3RhY2s6IE51bWJlcixcbiAgZXZlbnRNaW5IZWlnaHQ6IE51bWJlcixcbiAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICBldmVudFNob3J0SGVpZ2h0OiBOdW1iZXIsXG4gIHNsb3RFdmVudE92ZXJsYXA6IEJvb2xlYW4sXG4gIHBsdWdpbnM6IGlkZW50aXR5IGFzIElkZW50aXR5PFBsdWdpbkRlZltdPixcbiAgZmlyc3REYXk6IE51bWJlcixcbiAgZGF5Q291bnQ6IE51bWJlcixcbiAgZGF0ZUFsaWdubWVudDogU3RyaW5nLFxuICBkYXRlSW5jcmVtZW50OiBjcmVhdGVEdXJhdGlvbixcbiAgaGlkZGVuRGF5czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8bnVtYmVyW10+LFxuICBtb250aE1vZGU6IEJvb2xlYW4sXG4gIGZpeGVkV2Vla0NvdW50OiBCb29sZWFuLFxuICB2YWxpZFJhbmdlOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlUmFuZ2VJbnB1dCB8ICgodGhpczogQ2FsZW5kYXJBcGksIG5vd0RhdGU6IERhdGUpID0+IERhdGVSYW5nZUlucHV0KT4sIC8vIGB0aGlzYCB3b3Jrcz9cbiAgdmlzaWJsZVJhbmdlOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlUmFuZ2VJbnB1dCB8ICgodGhpczogQ2FsZW5kYXJBcGksIGN1cnJlbnREYXRlOiBEYXRlKSA9PiBEYXRlUmFuZ2VJbnB1dCk+LCAvLyBgdGhpc2Agd29ya3M/XG4gIHRpdGxlRm9ybWF0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxGb3JtYXR0ZXJJbnB1dD4sIC8vIERPTlQgcGFyc2UganVzdCB5ZXQuIHdlIG5lZWQgdG8gaW5qZWN0IHRpdGxlU2VwYXJhdG9yXG5cbiAgLy8gb25seSB1c2VkIGJ5IGxpc3QtdmlldywgYnV0IGxhbmd1YWdlcyBkZWZpbmUgdGhlIHZhbHVlLCBzbyB3ZSBuZWVkIGl0IGluIGJhc2Ugb3B0aW9uc1xuICBub0V2ZW50c1RleHQ6IFN0cmluZyxcblxuICBtb3JlTGlua0NsaWNrOiBpZGVudGl0eSBhcyBJZGVudGl0eTxNb3JlTGlua0FjdGlvbj4sXG4gIG1vcmVMaW5rQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxNb3JlTGlua0NvbnRlbnRBcmc+PixcbiAgbW9yZUxpbmtDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPE1vcmVMaW5rQ29udGVudEFyZz4+LFxuICBtb3JlTGlua0RpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8TW9yZUxpbmtNb3VudEFyZz4+LFxuICBtb3JlTGlua1dpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8TW9yZUxpbmtNb3VudEFyZz4+LFxufVxuXG50eXBlIEJ1aWx0SW5CYXNlT3B0aW9uUmVmaW5lcnMgPSB0eXBlb2YgQkFTRV9PUFRJT05fUkVGSU5FUlNcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlT3B0aW9uUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluQmFzZU9wdGlvblJlZmluZXJzIHtcbiAgLy8gZm9yIGFtYmllbnQtZXh0ZW5kaW5nXG59XG5cbmV4cG9ydCB0eXBlIEJhc2VPcHRpb25zID0gUmF3T3B0aW9uc0Zyb21SZWZpbmVyczwgLy8gYXMgUmF3T3B0aW9uc1xuICBSZXF1aXJlZDxCYXNlT3B0aW9uUmVmaW5lcnM+IC8vIFJlcXVpcmVkIGlzIGEgaGFjayBmb3IgXCJJbmRleCBzaWduYXR1cmUgaXMgbWlzc2luZ1wiXG4+XG5cbi8vIGRvIE5PVCBnaXZlIGEgdHlwZSBoZXJlLiBuZWVkIGB0eXBlb2YgQkFTRV9PUFRJT05fREVGQVVMVFNgIHRvIGdpdmUgcmVhbCByZXN1bHRzLlxuLy8gcmF3IHZhbHVlcy5cbmV4cG9ydCBjb25zdCBCQVNFX09QVElPTl9ERUZBVUxUUyA9IHtcbiAgZXZlbnREaXNwbGF5OiAnYXV0bycsXG4gIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogJyAtICcsXG4gIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLCAvLyBlbiBkYXNoXG4gIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMTowMDowMCcsXG4gIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiB7IGRheTogMSB9LFxuICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuICBuZXh0RGF5VGhyZXNob2xkOiAnMDA6MDA6MDAnLFxuICBkYXlIZWFkZXJzOiB0cnVlLFxuICBpbml0aWFsVmlldzogJycsXG4gIGFzcGVjdFJhdGlvOiAxLjM1LFxuICBoZWFkZXJUb29sYmFyOiB7XG4gICAgc3RhcnQ6ICd0aXRsZScsXG4gICAgY2VudGVyOiAnJyxcbiAgICBlbmQ6ICd0b2RheSBwcmV2LG5leHQnLFxuICB9LFxuICB3ZWVrZW5kczogdHJ1ZSxcbiAgd2Vla051bWJlcnM6IGZhbHNlLFxuICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcgYXMgV2Vla051bWJlckNhbGN1bGF0aW9uLFxuICBlZGl0YWJsZTogZmFsc2UsXG4gIG5vd0luZGljYXRvcjogZmFsc2UsXG4gIHNjcm9sbFRpbWU6ICcwNjowMDowMCcsXG4gIHNjcm9sbFRpbWVSZXNldDogdHJ1ZSxcbiAgc2xvdE1pblRpbWU6ICcwMDowMDowMCcsXG4gIHNsb3RNYXhUaW1lOiAnMjQ6MDA6MDAnLFxuICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxuICBsYXp5RmV0Y2hpbmc6IHRydWUsXG4gIHN0YXJ0UGFyYW06ICdzdGFydCcsXG4gIGVuZFBhcmFtOiAnZW5kJyxcbiAgdGltZVpvbmVQYXJhbTogJ3RpbWVab25lJyxcbiAgdGltZVpvbmU6ICdsb2NhbCcsIC8vIFRPRE86IHRocm93IGVycm9yIGlmIGdpdmVuIGZhbHN5IHZhbHVlP1xuICBsb2NhbGVzOiBbXSxcbiAgbG9jYWxlOiAnJywgLy8gYmxhbmsgdmFsdWVzIG1lYW5zIGl0IHdpbGwgY29tcHV0ZSBiYXNlZCBvZmYgbG9jYWxlc1tdXG4gIHRoZW1lU3lzdGVtOiAnc3RhbmRhcmQnLFxuICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcbiAgZHJhZ1Njcm9sbDogdHJ1ZSxcbiAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogZmFsc2UsXG4gIHVuc2VsZWN0QXV0bzogdHJ1ZSxcbiAgZHJvcEFjY2VwdDogJyonLFxuICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXG4gIGRheVBvcG92ZXJGb3JtYXQ6IHsgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycsIHllYXI6ICdudW1lcmljJyB9LFxuICBoYW5kbGVXaW5kb3dSZXNpemU6IHRydWUsXG4gIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsIC8vIG1pbGxpc2Vjb25kcyBiZWZvcmUgYW4gdXBkYXRlU2l6ZSBoYXBwZW5zXG4gIGxvbmdQcmVzc0RlbGF5OiAxMDAwLFxuICBldmVudERyYWdNaW5EaXN0YW5jZTogNSwgLy8gb25seSBhcHBsaWVzIHRvIG1vdXNlXG4gIGV4cGFuZFJvd3M6IGZhbHNlLFxuICBuYXZMaW5rczogZmFsc2UsXG4gIHNlbGVjdGFibGU6IGZhbHNlLFxuICBldmVudE1pbkhlaWdodDogMTUsXG4gIGV2ZW50TWluV2lkdGg6IDMwLFxuICBldmVudFNob3J0SGVpZ2h0OiAzMCxcbn1cblxuZXhwb3J0IHR5cGUgQmFzZU9wdGlvbnNSZWZpbmVkID0gRGVmYXVsdGVkUmVmaW5lZE9wdGlvbnM8XG4gIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEJhc2VPcHRpb25SZWZpbmVycz4+LCAvLyBSZXF1aXJlZCBpcyBhIGhhY2sgZm9yIFwiSW5kZXggc2lnbmF0dXJlIGlzIG1pc3NpbmdcIlxuICBrZXlvZiB0eXBlb2YgQkFTRV9PUFRJT05fREVGQVVMVFNcbj5cblxuLy8gY2FsZW5kYXIgbGlzdGVuZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTID0ge1xuICBkYXRlc1NldDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRGF0ZXNTZXRBcmcpID0+IHZvaWQ+LFxuICBldmVudHNTZXQ6IGlkZW50aXR5IGFzIElkZW50aXR5PChldmVudHM6IEV2ZW50QXBpW10pID0+IHZvaWQ+LFxuICBldmVudEFkZDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRBZGRBcmcpID0+IHZvaWQ+LFxuICBldmVudENoYW5nZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRDaGFuZ2VBcmcpID0+IHZvaWQ+LFxuICBldmVudFJlbW92ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRSZW1vdmVBcmcpID0+IHZvaWQ+LFxuICB3aW5kb3dSZXNpemU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IHsgdmlldzogVmlld0FwaSB9KSA9PiB2b2lkPixcbiAgZXZlbnRDbGljazogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRDbGlja0FyZykgPT4gdm9pZD4sIC8vIFRPRE86IHJlc291cmNlIGZvciBzY2hlZHVsZXI/Pz8/XG4gIGV2ZW50TW91c2VFbnRlcjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRIb3ZlcmluZ0FyZykgPT4gdm9pZD4sXG4gIGV2ZW50TW91c2VMZWF2ZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRIb3ZlcmluZ0FyZykgPT4gdm9pZD4sXG4gIHNlbGVjdDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRGF0ZVNlbGVjdEFyZykgPT4gdm9pZD4sIC8vIHJlc291cmNlIGZvciBzY2hlZHVsZXI/Pz8/XG4gIHVuc2VsZWN0OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoYXJnOiBEYXRlVW5zZWxlY3RBcmcpID0+IHZvaWQ+LFxuICBsb2FkaW5nOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoaXNMb2FkaW5nOiBib29sZWFuKSA9PiB2b2lkPixcblxuICAvLyBpbnRlcm5hbFxuICBfdW5tb3VudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KCkgPT4gdm9pZD4sXG4gIF9iZWZvcmVwcmludDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KCkgPT4gdm9pZD4sXG4gIF9hZnRlcnByaW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTwoKSA9PiB2b2lkPixcbiAgX25vRXZlbnREcm9wOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoKSA9PiB2b2lkPixcbiAgX25vRXZlbnRSZXNpemU6IGlkZW50aXR5IGFzIElkZW50aXR5PCgpID0+IHZvaWQ+LFxuICBfcmVzaXplOiBpZGVudGl0eSBhcyBJZGVudGl0eTwoZm9yY2VkOiBib29sZWFuKSA9PiB2b2lkPixcbiAgX3Njcm9sbFJlcXVlc3Q6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IGFueSkgPT4gdm9pZD4sXG59XG5cbnR5cGUgQnVpbHRJbkNhbGVuZGFyTGlzdGVuZXJSZWZpbmVycyA9IHR5cGVvZiBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSU1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyTGlzdGVuZXJSZWZpbmVycyBleHRlbmRzIEJ1aWx0SW5DYWxlbmRhckxpc3RlbmVyUmVmaW5lcnMge1xuICAvLyBmb3IgYW1iaWVudCBleHRlbmRpbmdcbn1cblxudHlwZSBDYWxlbmRhckxpc3RlbmVyc0xvb3NlID0gUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8Q2FsZW5kYXJMaXN0ZW5lclJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuZXhwb3J0IHR5cGUgQ2FsZW5kYXJMaXN0ZW5lcnMgPSBSZXF1aXJlZDxDYWxlbmRhckxpc3RlbmVyc0xvb3NlPiAvLyBtdWNoIG1vcmUgY29udmVuaWVudCBmb3IgRW1pdHRlcnMgYW5kIHdoYXRub3RcblxuLy8gY2FsZW5kYXItc3BlY2lmaWMgb3B0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0geyAvLyBkb2VzIG5vdCBpbmNsdWRlIGJhc2Ugbm9yIGNhbGVuZGFyIGxpc3RlbmVyc1xuICBidXR0b25UZXh0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxCdXR0b25UZXh0Q29tcG91bmRJbnB1dD4sXG4gIHZpZXdzOiBpZGVudGl0eSBhcyBJZGVudGl0eTx7IFt2aWV3SWQ6IHN0cmluZ106IFZpZXdPcHRpb25zIH0+LFxuICBwbHVnaW5zOiBpZGVudGl0eSBhcyBJZGVudGl0eTxQbHVnaW5EZWZbXT4sXG4gIGluaXRpYWxFdmVudHM6IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50U291cmNlSW5wdXQ+LFxuICBldmVudHM6IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50U291cmNlSW5wdXQ+LFxuICBldmVudFNvdXJjZXM6IGlkZW50aXR5IGFzIElkZW50aXR5PEV2ZW50U291cmNlSW5wdXRbXT4sXG59XG5cbnR5cGUgQnVpbHRJbkNhbGVuZGFyT3B0aW9uUmVmaW5lcnMgPSB0eXBlb2YgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FsZW5kYXJPcHRpb25SZWZpbmVycyBleHRlbmRzIEJ1aWx0SW5DYWxlbmRhck9wdGlvblJlZmluZXJzIHtcbiAgLy8gZm9yIGFtYmllbnQtZXh0ZW5kaW5nXG59XG5cbmV4cG9ydCB0eXBlIENhbGVuZGFyT3B0aW9ucyA9XG4gIEJhc2VPcHRpb25zICZcbiAgQ2FsZW5kYXJMaXN0ZW5lcnNMb29zZSAmXG4gIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8Q2FsZW5kYXJPcHRpb25SZWZpbmVycz4+IC8vIFJlcXVpcmVkIGhhY2sgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNTMwMFxuXG5leHBvcnQgdHlwZSBDYWxlbmRhck9wdGlvbnNSZWZpbmVkID1cbiAgQmFzZU9wdGlvbnNSZWZpbmVkICZcbiAgQ2FsZW5kYXJMaXN0ZW5lcnNMb29zZSAmXG4gIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPENhbGVuZGFyT3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCBjb25zdCBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUzoge1xuICBbb3B0aW9uTmFtZSBpbiBrZXlvZiBDYWxlbmRhck9wdGlvbnNdOiAoYTogQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBiOiBDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pID0+IGJvb2xlYW5cbn0gPSB7XG4gIGhlYWRlclRvb2xiYXI6IGlzQm9vbENvbXBsZXhFcXVhbCxcbiAgZm9vdGVyVG9vbGJhcjogaXNCb29sQ29tcGxleEVxdWFsLFxuICBidXR0b25UZXh0OiBpc0Jvb2xDb21wbGV4RXF1YWwsXG4gIGJ1dHRvbkljb25zOiBpc0Jvb2xDb21wbGV4RXF1YWwsXG59XG5cbmZ1bmN0aW9uIGlzQm9vbENvbXBsZXhFcXVhbChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYikgeyAvLyBib3RoIG5vbi1udWxsIG9iamVjdHNcbiAgICByZXR1cm4gaXNQcm9wc0VxdWFsKGEsIGIpXG4gIH1cbiAgcmV0dXJuIGEgPT09IGJcbn1cblxuLy8gdmlldy1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IFZJRVdfT1BUSU9OX1JFRklORVJTOiB7XG4gIFtuYW1lOiBzdHJpbmddOiBhbnlcbn0gPSB7XG4gIHR5cGU6IFN0cmluZyxcbiAgY29tcG9uZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxWaWV3Q29tcG9uZW50VHlwZT4sXG4gIGJ1dHRvblRleHQ6IFN0cmluZyxcbiAgYnV0dG9uVGV4dEtleTogU3RyaW5nLCAvLyBpbnRlcm5hbCBvbmx5XG4gIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M+LFxuICB1c2VzTWluTWF4VGltZTogQm9vbGVhbiwgLy8gaW50ZXJuYWwgb25seVxuICBjbGFzc05hbWVzOiBpZGVudGl0eSBhcyBJZGVudGl0eTxDbGFzc05hbWVzR2VuZXJhdG9yPFNwZWNpZmljVmlld0NvbnRlbnRBcmc+PixcbiAgY29udGVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q3VzdG9tQ29udGVudEdlbmVyYXRvcjxTcGVjaWZpY1ZpZXdDb250ZW50QXJnPj4sXG4gIGRpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8U3BlY2lmaWNWaWV3TW91bnRBcmc+PixcbiAgd2lsbFVubW91bnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PFdpbGxVbm1vdW50SGFuZGxlcjxTcGVjaWZpY1ZpZXdNb3VudEFyZz4+LFxufVxuXG50eXBlIEJ1aWx0SW5WaWV3T3B0aW9uUmVmaW5lcnMgPSB0eXBlb2YgVklFV19PUFRJT05fUkVGSU5FUlNcblxuZXhwb3J0IGludGVyZmFjZSBWaWV3T3B0aW9uUmVmaW5lcnMgZXh0ZW5kcyBCdWlsdEluVmlld09wdGlvblJlZmluZXJzIHtcbiAgLy8gZm9yIGFtYmllbnQtZXh0ZW5kaW5nXG59XG5cbmV4cG9ydCB0eXBlIFZpZXdPcHRpb25zID1cbiAgQmFzZU9wdGlvbnMgJlxuICBDYWxlbmRhckxpc3RlbmVyc0xvb3NlICZcbiAgUmF3T3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxWaWV3T3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCB0eXBlIFZpZXdPcHRpb25zUmVmaW5lZCA9XG4gIEJhc2VPcHRpb25zUmVmaW5lZCAmXG4gIENhbGVuZGFyTGlzdGVuZXJzTG9vc2UgJlxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxWaWV3T3B0aW9uUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbi8vIHV0aWwgZnVuY3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUmF3T3B0aW9ucyhvcHRpb25TZXRzOiBEaWN0aW9uYXJ5W10pIHtcbiAgcmV0dXJuIG1lcmdlUHJvcHMob3B0aW9uU2V0cywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWZpbmVQcm9wczxSZWZpbmVycyBleHRlbmRzIEdlbmVyaWNSZWZpbmVycywgUmF3IGV4dGVuZHMgUmF3T3B0aW9uc0Zyb21SZWZpbmVyczxSZWZpbmVycz4+KFxuICBpbnB1dDogUmF3LFxuICByZWZpbmVyczogUmVmaW5lcnMsXG4pOiB7XG4gIHJlZmluZWQ6IFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlZmluZXJzPixcbiAgZXh0cmE6IERpY3Rpb25hcnksXG59IHtcbiAgbGV0IHJlZmluZWQgPSB7fSBhcyBhbnlcbiAgbGV0IGV4dHJhID0ge30gYXMgYW55XG5cbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcmVmaW5lcnMpIHtcbiAgICBpZiAocHJvcE5hbWUgaW4gaW5wdXQpIHtcbiAgICAgIHJlZmluZWRbcHJvcE5hbWVdID0gcmVmaW5lcnNbcHJvcE5hbWVdKGlucHV0W3Byb3BOYW1lXSlcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBwcm9wTmFtZSBpbiBpbnB1dCkge1xuICAgIGlmICghKHByb3BOYW1lIGluIHJlZmluZXJzKSkge1xuICAgICAgZXh0cmFbcHJvcE5hbWVdID0gaW5wdXRbcHJvcE5hbWVdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgcmVmaW5lZCwgZXh0cmEgfVxufVxuXG4vLyBkZWZpbml0aW9uIHV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCB0eXBlIEdlbmVyaWNSZWZpbmVycyA9IHtcbiAgW3Byb3BOYW1lOiBzdHJpbmddOiAoaW5wdXQ6IGFueSkgPT4gYW55XG59XG5cbmV4cG9ydCB0eXBlIEdlbmVyaWNMaXN0ZW5lclJlZmluZXJzID0ge1xuICBbbGlzdGVuZXJOYW1lOiBzdHJpbmddOiBJZGVudGl0eTwodGhpczogQ2FsZW5kYXJBcGksIC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPlxufVxuXG5leHBvcnQgdHlwZSBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlZmluZXJzIGV4dGVuZHMgR2VuZXJpY1JlZmluZXJzPiA9IHtcbiAgW1Byb3AgaW4ga2V5b2YgUmVmaW5lcnNdPzogLy8gYWxsIG9wdGlvbmFsXG4gICAgUmVmaW5lcnNbUHJvcF0gZXh0ZW5kcyAoKGlucHV0OiBpbmZlciBSYXdUeXBlKSA9PiBpbmZlciBSZWZpbmVkVHlwZSlcbiAgICAgID8gKGFueSBleHRlbmRzIFJhd1R5cGUgPyBSZWZpbmVkVHlwZSA6IFJhd1R5cGUpIC8vIGlmIGlucHV0IHR5cGUgYGFueWAsIHVzZSBvdXRwdXQgKGZvciBCb29sZWFuL051bWJlci9TdHJpbmcpXG4gICAgICA6IG5ldmVyXG59XG5cbmV4cG9ydCB0eXBlIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzPFJlZmluZXJzIGV4dGVuZHMgR2VuZXJpY1JlZmluZXJzPiA9IHtcbiAgW1Byb3AgaW4ga2V5b2YgUmVmaW5lcnNdPzogLy8gYWxsIG9wdGlvbmFsXG4gICAgUmVmaW5lcnNbUHJvcF0gZXh0ZW5kcyAoKGlucHV0OiBhbnkpID0+IGluZmVyIFJlZmluZWRUeXBlKSA/IFJlZmluZWRUeXBlIDogbmV2ZXJcbn1cblxuZXhwb3J0IHR5cGUgRGVmYXVsdGVkUmVmaW5lZE9wdGlvbnM8UmVmaW5lZE9wdGlvbnMgZXh0ZW5kcyBEaWN0aW9uYXJ5LCBEZWZhdWx0S2V5IGV4dGVuZHMga2V5b2YgUmVmaW5lZE9wdGlvbnM+ID1cbiAgUmVxdWlyZWQ8UGljazxSZWZpbmVkT3B0aW9ucywgRGVmYXVsdEtleT4+ICZcbiAgUGFydGlhbDxPbWl0PFJlZmluZWRPcHRpb25zLCBEZWZhdWx0S2V5Pj5cblxuZXhwb3J0IHR5cGUgRGljdGlvbmFyeSA9IFJlY29yZDxzdHJpbmcsIGFueT5cblxuZXhwb3J0IHR5cGUgSWRlbnRpdHk8VCA9IGFueT4gPSAocmF3OiBUKSA9PiBUXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eTxUPihyYXc6IFQpOiBUIHtcbiAgcmV0dXJuIHJhd1xufVxuIiwiaW1wb3J0IHsgRXZlbnREZWYsIEV2ZW50RGVmSGFzaCB9IGZyb20gJy4vZXZlbnQtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZSwgRXZlbnRJbnN0YW5jZUhhc2ggfSBmcm9tICcuL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgRXZlbnRJbnB1dCwgcGFyc2VFdmVudCwgRXZlbnRUdXBsZSwgYnVpbGRFdmVudFJlZmluZXJzIH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcbmltcG9ydCB7IGZpbHRlckhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IEV2ZW50U291cmNlIH0gZnJvbSAnLi9ldmVudC1zb3VyY2UnXG5cbi8qXG5BIGRhdGEgc3RydWN0dXJlIHRoYXQgZW5jYXBzdWxhdGVzIEV2ZW50RGVmcyBhbmQgRXZlbnRJbnN0YW5jZXMuXG5VdGlscyBmb3IgcGFyc2luZyB0aGlzIGRhdGEgZnJvbSByYXcgRXZlbnRJbnB1dHMuXG5VdGlscyBmb3IgbWFuaXB1bGF0aW5nIGFuIEV2ZW50U3RvcmUuXG4qL1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50U3RvcmUge1xuICBkZWZzOiBFdmVudERlZkhhc2hcbiAgaW5zdGFuY2VzOiBFdmVudEluc3RhbmNlSGFzaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdmVudHMoXG4gIHJhd0V2ZW50czogRXZlbnRJbnB1dFtdLFxuICBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiB8IG51bGwsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgYWxsb3dPcGVuUmFuZ2U/OiBib29sZWFuLFxuKTogRXZlbnRTdG9yZSB7XG4gIGxldCBldmVudFN0b3JlID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKClcbiAgbGV0IGV2ZW50UmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dClcblxuICBmb3IgKGxldCByYXdFdmVudCBvZiByYXdFdmVudHMpIHtcbiAgICBsZXQgdHVwbGUgPSBwYXJzZUV2ZW50KHJhd0V2ZW50LCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGV2ZW50UmVmaW5lcnMpXG5cbiAgICBpZiAodHVwbGUpIHtcbiAgICAgIGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlLCBldmVudFN0b3JlKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudFN0b3JlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZTogRXZlbnRUdXBsZSwgZXZlbnRTdG9yZTogRXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpKSB7XG4gIGV2ZW50U3RvcmUuZGVmc1t0dXBsZS5kZWYuZGVmSWRdID0gdHVwbGUuZGVmXG5cbiAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XG4gICAgZXZlbnRTdG9yZS5pbnN0YW5jZXNbdHVwbGUuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSB0dXBsZS5pbnN0YW5jZVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50U3RvcmVcbn1cblxuLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxuLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxuLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGluc3RhbmNlSWQ6IHN0cmluZyk6IEV2ZW50U3RvcmUge1xuICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXVxuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdXG5cbiAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICBsZXQgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAobG9va0RlZikgPT4gaXNFdmVudERlZnNHcm91cGVkKGRlZiwgbG9va0RlZikpXG5cbiAgICAvLyBhZGQgdGhlIG9yaWdpbmFsXG4gICAgLy8gVE9ETzogd2lzaCB3ZSBjb3VsZCB1c2UgZXZlbnRUdXBsZVRvU3RvcmUgb3Igc29tZXRoaW5nIGxpa2UgaXRcbiAgICBuZXdTdG9yZS5kZWZzW2RlZi5kZWZJZF0gPSBkZWZcbiAgICBuZXdTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZVxuXG4gICAgcmV0dXJuIG5ld1N0b3JlXG4gIH1cblxuICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKClcbn1cblxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjA6IEV2ZW50RGVmLCBkZWYxOiBFdmVudERlZik6IGJvb2xlYW4ge1xuICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTogRXZlbnRTdG9yZSB7XG4gIHJldHVybiB7IGRlZnM6IHt9LCBpbnN0YW5jZXM6IHt9IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRXZlbnRTdG9yZXMoc3RvcmUwOiBFdmVudFN0b3JlLCBzdG9yZTE6IEV2ZW50U3RvcmUpOiBFdmVudFN0b3JlIHtcbiAgcmV0dXJuIHtcbiAgICBkZWZzOiB7IC4uLnN0b3JlMC5kZWZzLCAuLi5zdG9yZTEuZGVmcyB9LFxuICAgIGluc3RhbmNlczogeyAuLi5zdG9yZTAuaW5zdGFuY2VzLCAuLi5zdG9yZTEuaW5zdGFuY2VzIH0sXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGZpbHRlckZ1bmM6IChldmVudERlZjogRXZlbnREZWYpID0+IGJvb2xlYW4pOiBFdmVudFN0b3JlIHtcbiAgbGV0IGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYylcbiAgbGV0IGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIChpbnN0YW5jZTogRXZlbnRJbnN0YW5jZSkgPT4gKFxuICAgIGRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIHN0aWxsIGV4aXN0cz9cbiAgKSlcbiAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKG1hc3RlcjogRXZlbnRTdG9yZSwgc3ViOiBFdmVudFN0b3JlKTogRXZlbnRTdG9yZSB7XG4gIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gbWFzdGVyXG4gIGxldCBmaWx0ZXJlZERlZnM6IHsgW2RlZklkOiBzdHJpbmddOiBFdmVudERlZiB9ID0ge31cbiAgbGV0IGZpbHRlcmVkSW5zdGFuY2VzOiB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBFdmVudEluc3RhbmNlIH0gPSB7fVxuXG4gIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICBpZiAoIXN1Yi5kZWZzW2RlZklkXSkgeyAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgZmlsdGVyZWREZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdXG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICBpZiAoXG4gICAgICAhc3ViLmluc3RhbmNlc1tpbnN0YW5jZUlkXSAmJiAvLyBub3QgZXhwbGljaXRseSBleGNsdWRlZFxuICAgICAgZmlsdGVyZWREZWZzW2luc3RhbmNlc1tpbnN0YW5jZUlkXS5kZWZJZF0gLy8gZGVmIHdhc24ndCBmaWx0ZXJlZCBhd2F5XG4gICAgKSB7XG4gICAgICBmaWx0ZXJlZEluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGVmczogZmlsdGVyZWREZWZzLFxuICAgIGluc3RhbmNlczogZmlsdGVyZWRJbnN0YW5jZXMsXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50U3RvcmUsIHBhcnNlRXZlbnRzIH0gZnJvbSAnLi9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEV2ZW50SW5wdXQgfSBmcm9tICcuL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgRGF0ZVNwYW5BcGkgfSBmcm9tICcuL2RhdGUtc3BhbidcbmltcG9ydCB7IEV2ZW50QXBpIH0gZnJvbSAnLi4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgU3BsaXR0YWJsZVByb3BzIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXNwbGl0dGluZydcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcblxuLy8gVE9ETzogcmVuYW1lIHRvIFwiY3JpdGVyaWFcIiA/XG5leHBvcnQgdHlwZSBDb25zdHJhaW50SW5wdXQgPSAnYnVzaW5lc3NIb3VycycgfCBzdHJpbmcgfCBFdmVudElucHV0IHwgRXZlbnRJbnB1dFtdXG5leHBvcnQgdHlwZSBDb25zdHJhaW50ID0gJ2J1c2luZXNzSG91cnMnIHwgc3RyaW5nIHwgRXZlbnRTdG9yZSB8IGZhbHNlIC8vIGZhbHNlIG1lYW5zIHdvbid0IHBhc3MgYXQgYWxsXG5leHBvcnQgdHlwZSBPdmVybGFwRnVuYyA9ICgoc3RpbGxFdmVudDogRXZlbnRBcGksIG1vdmluZ0V2ZW50OiBFdmVudEFwaSB8IG51bGwpID0+IGJvb2xlYW4pXG5leHBvcnQgdHlwZSBBbGxvd0Z1bmMgPSAoc3BhbjogRGF0ZVNwYW5BcGksIG1vdmluZ0V2ZW50OiBFdmVudEFwaSB8IG51bGwpID0+IGJvb2xlYW5cbmV4cG9ydCB0eXBlIGlzUHJvcHNWYWxpZFRlc3RlciA9IChwcm9wczogU3BsaXR0YWJsZVByb3BzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpID0+IGJvb2xlYW5cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbnN0cmFpbnQoaW5wdXQ6IENvbnN0cmFpbnRJbnB1dCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogQ29uc3RyYWludCB8IG51bGwge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoaW5wdXQsIG51bGwsIGNvbnRleHQsIHRydWUpIC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgfSBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICByZXR1cm4gcGFyc2VFdmVudHMoW2lucHV0XSwgbnVsbCwgY29udGV4dCwgdHJ1ZSkgLy8gYWxsb3dPcGVuUmFuZ2U9dHJ1ZVxuICB9IGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIFN0cmluZyhpbnB1dClcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIiwiZXhwb3J0IHR5cGUgQ2xhc3NOYW1lc0lucHV0ID0gc3RyaW5nIHwgc3RyaW5nW11cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ2xhc3NOYW1lcyhyYXc6IENsYXNzTmFtZXNJbnB1dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShyYXcpKSB7XG4gICAgcmV0dXJuIHJhd1xuICB9XG5cbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pXG4gIH1cblxuICByZXR1cm4gW11cbn1cbiIsImltcG9ydCB7IENvbnN0cmFpbnQsIEFsbG93RnVuYywgbm9ybWFsaXplQ29uc3RyYWludCB9IGZyb20gJy4uL3N0cnVjdHMvY29uc3RyYWludCdcbmltcG9ydCB7IHBhcnNlQ2xhc3NOYW1lcyB9IGZyb20gJy4uL3V0aWwvaHRtbCdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IFJhd09wdGlvbnNGcm9tUmVmaW5lcnMsIFJlZmluZWRPcHRpb25zRnJvbVJlZmluZXJzLCBpZGVudGl0eSwgSWRlbnRpdHkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG4vLyBUT0RPOiBiZXR0ZXIgY2FsbGVkIFwiRXZlbnRTZXR0aW5nc1wiIG9yIFwiRXZlbnRDb25maWdcIlxuLy8gVE9ETzogbW92ZSB0aGlzIGZpbGUgaW50byBzdHJ1Y3RzXG4vLyBUT0RPOiBzZXBhcmF0ZSBjb25zdHJhaW50L292ZXJsYXAvYWxsb3csIGJlY2F1c2Ugc2VsZWN0aW9uIHVzZXMgb25seSB0aGF0LCBub3Qgb3RoZXIgcHJvcHNcblxuZXhwb3J0IGNvbnN0IEVWRU5UX1VJX1JFRklORVJTID0ge1xuICBkaXNwbGF5OiBTdHJpbmcsXG4gIGVkaXRhYmxlOiBCb29sZWFuLFxuICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICBkdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxuICBjb25zdHJhaW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxhbnk+LCAvLyBJZGVudGl0eTxDb25zdHJhaW50SW5wdXQ+LCAvLyBjaXJjdWxhciByZWZlcmVuY2UuIHRzIGRpZXMuIGV2ZW50LT5jb25zdHJhaW50LT5ldmVudFxuICBvdmVybGFwOiBpZGVudGl0eSBhcyBJZGVudGl0eTxib29sZWFuPixcbiAgYWxsb3c6IGlkZW50aXR5IGFzIElkZW50aXR5PEFsbG93RnVuYz4sXG4gIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLCAvLyB3aWxsIGJvdGggZW5kIHVwIGFzIGFycmF5IG9mIHN0cmluZ3NcbiAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLCAvLyBcIlxuICBjb2xvcjogU3RyaW5nLFxuICBiYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgdGV4dENvbG9yOiBTdHJpbmcsXG59XG5cbmNvbnN0IEVNUFRZX0VWRU5UX1VJOiBFdmVudFVpID0ge1xuICBkaXNwbGF5OiBudWxsLFxuICBzdGFydEVkaXRhYmxlOiBudWxsLFxuICBkdXJhdGlvbkVkaXRhYmxlOiBudWxsLFxuICBjb25zdHJhaW50czogW10sXG4gIG92ZXJsYXA6IG51bGwsXG4gIGFsbG93czogW10sXG4gIGJhY2tncm91bmRDb2xvcjogJycsXG4gIGJvcmRlckNvbG9yOiAnJyxcbiAgdGV4dENvbG9yOiAnJyxcbiAgY2xhc3NOYW1lczogW10sXG59XG5cbnR5cGUgQnVpbHRJbkV2ZW50VWlSZWZpbmVycyA9IHR5cGVvZiBFVkVOVF9VSV9SRUZJTkVSU1xuXG5pbnRlcmZhY2UgRXZlbnRVaVJlZmluZXJzIGV4dGVuZHMgQnVpbHRJbkV2ZW50VWlSZWZpbmVycyB7XG4gIC8vIHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlIChhbmQgZ2l2ZSBpcyB0aGUgb3B0aW9uIGZvciBhbWJpZW50IG1vZGlmaWNhdGlvbiBmb3IgbGF0ZXIpXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50VWlJbnB1dCA9IFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8RXZlbnRVaVJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuZXhwb3J0IHR5cGUgRXZlbnRVaVJlZmluZWQgPSBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxFdmVudFVpUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRVaSB7XG4gIGRpc3BsYXk6IHN0cmluZyB8IG51bGxcbiAgc3RhcnRFZGl0YWJsZTogYm9vbGVhbiB8IG51bGxcbiAgZHVyYXRpb25FZGl0YWJsZTogYm9vbGVhbiB8IG51bGxcbiAgY29uc3RyYWludHM6IENvbnN0cmFpbnRbXVxuICBvdmVybGFwOiBib29sZWFuIHwgbnVsbFxuICBhbGxvd3M6IEFsbG93RnVuY1tdIC8vIGNyYXBweSBuYW1lIHRvIGluZGljYXRlIHBsdXJhbFxuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZ1xuICBib3JkZXJDb2xvcjogc3RyaW5nXG4gIHRleHRDb2xvcjogc3RyaW5nLFxuICBjbGFzc05hbWVzOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgdHlwZSBFdmVudFVpSGFzaCA9IHsgW2RlZklkOiBzdHJpbmddOiBFdmVudFVpIH1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50VWkocmVmaW5lZDogRXZlbnRVaVJlZmluZWQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50VWkge1xuICBsZXQgY29uc3RyYWludCA9IG5vcm1hbGl6ZUNvbnN0cmFpbnQocmVmaW5lZC5jb25zdHJhaW50LCBjb250ZXh0KVxuXG4gIHJldHVybiB7XG4gICAgZGlzcGxheTogcmVmaW5lZC5kaXNwbGF5IHx8IG51bGwsXG4gICAgc3RhcnRFZGl0YWJsZTogcmVmaW5lZC5zdGFydEVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0RWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICBjb25zdHJhaW50czogY29uc3RyYWludCAhPSBudWxsID8gW2NvbnN0cmFpbnRdIDogW10sXG4gICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxuICAgIGFsbG93czogcmVmaW5lZC5hbGxvdyAhPSBudWxsID8gW3JlZmluZWQuYWxsb3ddIDogW10sXG4gICAgYmFja2dyb3VuZENvbG9yOiByZWZpbmVkLmJhY2tncm91bmRDb2xvciB8fCByZWZpbmVkLmNvbG9yIHx8ICcnLFxuICAgIGJvcmRlckNvbG9yOiByZWZpbmVkLmJvcmRlckNvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgdGV4dENvbG9yOiByZWZpbmVkLnRleHRDb2xvciB8fCAnJyxcbiAgICBjbGFzc05hbWVzOiAocmVmaW5lZC5jbGFzc05hbWUgfHwgW10pLmNvbmNhdChyZWZpbmVkLmNsYXNzTmFtZXMgfHwgW10pLCAvLyBqb2luIHNpbmd1bGFyIGFuZCBwbHVyYWxcbiAgfVxufVxuXG4vLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVFdmVudFVpcyh1aXM6IEV2ZW50VWlbXSk6IEV2ZW50VWkge1xuICByZXR1cm4gdWlzLnJlZHVjZShjb21iaW5lVHdvRXZlbnRVaXMsIEVNUFRZX0VWRU5UX1VJKVxufVxuXG5mdW5jdGlvbiBjb21iaW5lVHdvRXZlbnRVaXMoaXRlbTA6IEV2ZW50VWksIGl0ZW0xOiBFdmVudFVpKTogRXZlbnRVaSB7IC8vIGhhc2gxIGhhcyBoaWdoZXIgcHJlY2VkZW5jZVxuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6IGl0ZW0xLmRpc3BsYXkgIT0gbnVsbCA/IGl0ZW0xLmRpc3BsYXkgOiBpdGVtMC5kaXNwbGF5LFxuICAgIHN0YXJ0RWRpdGFibGU6IGl0ZW0xLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLnN0YXJ0RWRpdGFibGUgOiBpdGVtMC5zdGFydEVkaXRhYmxlLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IGl0ZW0xLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLmR1cmF0aW9uRWRpdGFibGUgOiBpdGVtMC5kdXJhdGlvbkVkaXRhYmxlLFxuICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxuICAgIG92ZXJsYXA6IHR5cGVvZiBpdGVtMS5vdmVybGFwID09PSAnYm9vbGVhbicgPyBpdGVtMS5vdmVybGFwIDogaXRlbTAub3ZlcmxhcCxcbiAgICBhbGxvd3M6IGl0ZW0wLmFsbG93cy5jb25jYXQoaXRlbTEuYWxsb3dzKSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ29sb3I6IGl0ZW0xLmJvcmRlckNvbG9yIHx8IGl0ZW0wLmJvcmRlckNvbG9yLFxuICAgIHRleHRDb2xvcjogaXRlbTEudGV4dENvbG9yIHx8IGl0ZW0wLnRleHRDb2xvcixcbiAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKSxcbiAgfVxufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5pbXBvcnQgeyBEYXRlSW5wdXQgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IHBhcnNlUmVjdXJyaW5nIH0gZnJvbSAnLi9yZWN1cnJpbmctZXZlbnQnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBFdmVudERlZiB9IGZyb20gJy4vZXZlbnQtZGVmJ1xuaW1wb3J0IHsgY3JlYXRlRXZlbnRJbnN0YW5jZSwgRXZlbnRJbnN0YW5jZSB9IGZyb20gJy4vZXZlbnQtaW5zdGFuY2UnXG5pbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4vZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnMsIFJhd09wdGlvbnNGcm9tUmVmaW5lcnMsIGlkZW50aXR5LCBJZGVudGl0eSwgRGljdGlvbmFyeSwgcmVmaW5lUHJvcHMgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgRVZFTlRfVUlfUkVGSU5FUlMsIGNyZWF0ZUV2ZW50VWksIEV2ZW50VWlJbnB1dCwgRXZlbnRVaVJlZmluZWQgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtdWknXG5cbmV4cG9ydCBjb25zdCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyA9IHtcbiAgaWQ6IFN0cmluZyxcbiAgZ3JvdXBJZDogU3RyaW5nLFxuICB0aXRsZTogU3RyaW5nLFxuICB1cmw6IFN0cmluZyxcbn1cblxuZXhwb3J0IGNvbnN0IEVWRU5UX0RBVEVfUkVGSU5FUlMgPSB7XG4gIHN0YXJ0OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBlbmQ6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD4sXG4gIGRhdGU6IGlkZW50aXR5IGFzIElkZW50aXR5PERhdGVJbnB1dD4sXG4gIGFsbERheTogQm9vbGVhbixcbn1cblxuY29uc3QgRVZFTlRfUkVGSU5FUlMgPSB7IC8vIGRvZXMgTk9UIGluY2x1ZGUgRVZFTlRfVUlfUkVGSU5FUlNcbiAgLi4uRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMsXG4gIC4uLkVWRU5UX0RBVEVfUkVGSU5FUlMsXG4gIGV4dGVuZGVkUHJvcHM6IGlkZW50aXR5IGFzIElkZW50aXR5PERpY3Rpb25hcnk+LFxufVxuXG50eXBlIEJ1aWx0SW5FdmVudFJlZmluZXJzID0gdHlwZW9mIEVWRU5UX1JFRklORVJTXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZWZpbmVycyBleHRlbmRzIEJ1aWx0SW5FdmVudFJlZmluZXJzIHtcbiAgLy8gZm9yIGFtYmllbnRcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRJbnB1dCA9XG4gIEV2ZW50VWlJbnB1dCAmXG4gIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8RXZlbnRSZWZpbmVycz4+ICYgLy8gUmVxdWlyZWQgaGFja1xuICB7IFtleHRlbmRlZFByb3A6IHN0cmluZ106IGFueSB9XG5cbmV4cG9ydCB0eXBlIEV2ZW50UmVmaW5lZCA9XG4gIEV2ZW50VWlSZWZpbmVkICZcbiAgUmVmaW5lZE9wdGlvbnNGcm9tUmVmaW5lcnM8UmVxdWlyZWQ8RXZlbnRSZWZpbmVycz4+IC8vIFJlcXVpcmVkIGhhY2tcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFR1cGxlIHtcbiAgZGVmOiBFdmVudERlZlxuICBpbnN0YW5jZTogRXZlbnRJbnN0YW5jZSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgRXZlbnRJbnB1dFRyYW5zZm9ybWVyID0gKGlucHV0OiBFdmVudElucHV0KSA9PiBFdmVudElucHV0XG5leHBvcnQgdHlwZSBFdmVudERlZk1lbWJlckFkZGVyID0gKHJlZmluZWQ6IEV2ZW50UmVmaW5lZCkgPT4gUGFydGlhbDxFdmVudERlZj5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXZlbnQoXG4gIHJhdzogRXZlbnRJbnB1dCxcbiAgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4gfCBudWxsLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gIGFsbG93T3BlblJhbmdlOiBib29sZWFuLFxuICByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSxcbik6IEV2ZW50VHVwbGUgfCBudWxsIHtcbiAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKHJhdywgY29udGV4dCwgcmVmaW5lcnMpXG5cbiAgbGV0IGRlZmF1bHRBbGxEYXkgPSBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KVxuICBsZXQgcmVjdXJyaW5nUmVzID0gcGFyc2VSZWN1cnJpbmcoXG4gICAgcmVmaW5lZCxcbiAgICBkZWZhdWx0QWxsRGF5LFxuICAgIGNvbnRleHQuZGF0ZUVudixcbiAgICBjb250ZXh0LnBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzLFxuICApXG5cbiAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKFxuICAgICAgcmVmaW5lZCxcbiAgICAgIGV4dHJhLFxuICAgICAgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLFxuICAgICAgcmVjdXJyaW5nUmVzLmFsbERheSxcbiAgICAgIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSxcbiAgICAgIGNvbnRleHQsXG4gICAgKVxuXG4gICAgZGVmLnJlY3VycmluZ0RlZiA9IHsgLy8gZG9uJ3Qgd2FudCBhbGwgdGhlIHByb3BzIGZyb20gcmVjdXJyaW5nUmVzLiBUT0RPOiBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpc1xuICAgICAgdHlwZUlkOiByZWN1cnJpbmdSZXMudHlwZUlkLFxuICAgICAgdHlwZURhdGE6IHJlY3VycmluZ1Jlcy50eXBlRGF0YSxcbiAgICAgIGR1cmF0aW9uOiByZWN1cnJpbmdSZXMuZHVyYXRpb24sXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZTogbnVsbCB9XG4gIH1cbiAgbGV0IHNpbmdsZVJlcyA9IHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKVxuXG4gIGlmIChzaW5nbGVSZXMpIHtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCBzaW5nbGVSZXMuYWxsRGF5LCBzaW5nbGVSZXMuaGFzRW5kLCBjb250ZXh0KVxuICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6bylcblxuICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmluZUV2ZW50RGVmKHJhdzogRXZlbnRJbnB1dCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LCByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSkge1xuICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgcmV0dXJuIHsgLi4uRVZFTlRfVUlfUkVGSU5FUlMsIC4uLkVWRU5UX1JFRklORVJTLCAuLi5jb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50UmVmaW5lcnMgfVxufVxuXG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUV2ZW50RGVmKFxuICByZWZpbmVkOiBFdmVudFJlZmluZWQsXG4gIGV4dHJhOiBEaWN0aW9uYXJ5LFxuICBzb3VyY2VJZDogc3RyaW5nLFxuICBhbGxEYXk6IGJvb2xlYW4sXG4gIGhhc0VuZDogYm9vbGVhbixcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogRXZlbnREZWYge1xuICBsZXQgZGVmOiBFdmVudERlZiA9IHtcbiAgICB0aXRsZTogcmVmaW5lZC50aXRsZSB8fCAnJyxcbiAgICBncm91cElkOiByZWZpbmVkLmdyb3VwSWQgfHwgJycsXG4gICAgcHVibGljSWQ6IHJlZmluZWQuaWQgfHwgJycsXG4gICAgdXJsOiByZWZpbmVkLnVybCB8fCAnJyxcbiAgICByZWN1cnJpbmdEZWY6IG51bGwsXG4gICAgZGVmSWQ6IGd1aWQoKSxcbiAgICBzb3VyY2VJZCxcbiAgICBhbGxEYXksXG4gICAgaGFzRW5kLFxuICAgIHVpOiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpLFxuICAgIGV4dGVuZGVkUHJvcHM6IHtcbiAgICAgIC4uLihyZWZpbmVkLmV4dGVuZGVkUHJvcHMgfHwge30pLFxuICAgICAgLi4uZXh0cmEsXG4gICAgfSxcbiAgfVxuXG4gIGZvciAobGV0IG1lbWJlckFkZGVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNZW1iZXJBZGRlcnMpIHtcbiAgICBfX2Fzc2lnbihkZWYsIG1lbWJlckFkZGVyKHJlZmluZWQpKVxuICB9XG5cbiAgLy8gaGVscCBvdXQgRXZlbnRBcGkgZnJvbSBoYXZpbmcgdXNlciBtb2RpZnkgcHJvcHNcbiAgT2JqZWN0LmZyZWV6ZShkZWYudWkuY2xhc3NOYW1lcylcbiAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcylcblxuICByZXR1cm4gZGVmXG59XG5cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJlZmluZWQ6IEV2ZW50UmVmaW5lZCwgZGVmYXVsdEFsbERheTogYm9vbGVhbiB8IG51bGwsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgYWxsb3dPcGVuUmFuZ2U/OiBib29sZWFuKSB7XG4gIGxldCB7IGFsbERheSB9ID0gcmVmaW5lZFxuICBsZXQgc3RhcnRNZXRhXG4gIGxldCBzdGFydE1hcmtlciA9IG51bGxcbiAgbGV0IGhhc0VuZCA9IGZhbHNlXG4gIGxldCBlbmRNZXRhXG4gIGxldCBlbmRNYXJrZXIgPSBudWxsXG5cbiAgbGV0IHN0YXJ0SW5wdXQgPSByZWZpbmVkLnN0YXJ0ICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0IDogcmVmaW5lZC5kYXRlXG4gIHN0YXJ0TWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpXG5cbiAgaWYgKHN0YXJ0TWV0YSkge1xuICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlclxuICB9IGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgIGVuZE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShyZWZpbmVkLmVuZClcbiAgfVxuXG4gIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgIGlmIChkZWZhdWx0QWxsRGF5ICE9IG51bGwpIHtcbiAgICAgIGFsbERheSA9IGRlZmF1bHRBbGxEYXlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkYXRlIHByb3BzIExBU1RcbiAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGFsbERheSAmJiBzdGFydE1hcmtlcikge1xuICAgIHN0YXJ0TWFya2VyID0gc3RhcnRPZkRheShzdGFydE1hcmtlcilcbiAgfVxuXG4gIGlmIChlbmRNZXRhKSB7XG4gICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXJcblxuICAgIGlmIChhbGxEYXkpIHtcbiAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKVxuICAgIH1cblxuICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgIGVuZE1hcmtlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kTWFya2VyKSB7XG4gICAgaGFzRW5kID0gdHJ1ZVxuICB9IGVsc2UgaWYgKCFhbGxvd09wZW5SYW5nZSkge1xuICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2VcblxuICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoXG4gICAgICBzdGFydE1hcmtlcixcbiAgICAgIGFsbERheSA/XG4gICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWxsRGF5LFxuICAgIGhhc0VuZCxcbiAgICByYW5nZTogeyBzdGFydDogc3RhcnRNYXJrZXIsIGVuZDogZW5kTWFya2VyIH0sXG4gICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YSA/IGVuZE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+IHwgbnVsbCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogYm9vbGVhbiB8IG51bGwge1xuICBsZXQgcmVzID0gbnVsbFxuXG4gIGlmIChldmVudFNvdXJjZSkge1xuICAgIHJlcyA9IGV2ZW50U291cmNlLmRlZmF1bHRBbGxEYXlcbiAgfVxuXG4gIGlmIChyZXMgPT0gbnVsbCkge1xuICAgIHJlcyA9IGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5XG4gIH1cblxuICByZXR1cm4gcmVzXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyLCBzdGFydE9mRGF5LCBhZGREYXlzLCBkaWZmRGF5cywgZGlmZkRheUFuZFRpbWUgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IER1cmF0aW9uLCBhc1JvdWdoTXMsIGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IERhdGVSYW5nZSwgT3BlbkRhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcblxuLyogRGF0ZSBzdHVmZiB0aGF0IGRvZXNuJ3QgYmVsb25nIGluIGRhdGVsaWIgY29yZVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFsaWduZWREYXlSYW5nZSh0aW1lZFJhbmdlOiBEYXRlUmFuZ2UpOiBEYXRlUmFuZ2Uge1xuICBsZXQgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDFcbiAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KVxuICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KVxuICByZXR1cm4geyBzdGFydCwgZW5kIH1cbn1cblxuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSBiYXNlZCBvbiBob3cgZm9yIHRoZSBlbmQgZGF0ZSBibGVlZHMgaW50byB0aGUgbmV4dCBkYXlcbi8vIFRPRE86IGdpdmUgbmV4dERheVRocmVzaG9sZCBhIGRlZmF1bHQgYXJnXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlOiBPcGVuRGF0ZVJhbmdlLCBuZXh0RGF5VGhyZXNob2xkOiBEdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKDApKTogT3BlbkRhdGVSYW5nZSB7XG4gIGxldCBzdGFydERheTogRGF0ZU1hcmtlciA9IG51bGxcbiAgbGV0IGVuZERheTogRGF0ZU1hcmtlciA9IG51bGxcblxuICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICBlbmREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2UuZW5kKVxuXG4gICAgbGV0IGVuZFRpbWVNUzogbnVtYmVyID0gdGltZWRSYW5nZS5lbmQudmFsdWVPZigpIC0gZW5kRGF5LnZhbHVlT2YoKSAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG5cbiAgICAvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXG4gICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgIGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IGFzUm91Z2hNcyhuZXh0RGF5VGhyZXNob2xkKSkge1xuICAgICAgZW5kRGF5ID0gYWRkRGF5cyhlbmREYXksIDEpXG4gICAgfVxuICB9XG5cbiAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCkgLy8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5IHRoZSByYW5nZSBzdGFydHNcblxuICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXG4gICAgaWYgKGVuZERheSAmJiBlbmREYXkgPD0gc3RhcnREYXkpIHtcbiAgICAgIGVuZERheSA9IGFkZERheXMoc3RhcnREYXksIDEpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9XG59XG5cbi8vIHNwYW5zIGZyb20gb25lIGRheSBpbnRvIGFub3RoZXI/XG5leHBvcnQgZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlOiBEYXRlUmFuZ2UpIHtcbiAgbGV0IHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpXG5cbiAgcmV0dXJuIGRpZmZEYXlzKHZpc2libGVSYW5nZS5zdGFydCwgdmlzaWJsZVJhbmdlLmVuZCkgPiAxXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTA6IERhdGVNYXJrZXIsIGRhdGUxOiBEYXRlTWFya2VyLCBkYXRlRW52OiBEYXRlRW52LCBsYXJnZVVuaXQ/OiBzdHJpbmcpIHtcbiAgaWYgKGxhcmdlVW5pdCA9PT0gJ3llYXInKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKSFcbiAgfVxuXG4gIGlmIChsYXJnZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJykhXG4gIH1cblxuICByZXR1cm4gZGlmZkRheUFuZFRpbWUoZGF0ZTAsIGRhdGUxKSAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuL21hcmtlcidcbmltcG9ydCB7IERhdGVFbnYsIERhdGVJbnB1dCB9IGZyb20gJy4vZW52J1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVSYW5nZUlucHV0IHtcbiAgc3RhcnQ/OiBEYXRlSW5wdXRcbiAgZW5kPzogRGF0ZUlucHV0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3BlbkRhdGVSYW5nZSB7XG4gIHN0YXJ0OiBEYXRlTWFya2VyIHwgbnVsbFxuICBlbmQ6IERhdGVNYXJrZXIgfCBudWxsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVJhbmdlIHtcbiAgc3RhcnQ6IERhdGVNYXJrZXJcbiAgZW5kOiBEYXRlTWFya2VyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJhbmdlKGlucHV0OiBEYXRlUmFuZ2VJbnB1dCwgZGF0ZUVudjogRGF0ZUVudik6IE9wZW5EYXRlUmFuZ2Uge1xuICBsZXQgc3RhcnQgPSBudWxsXG4gIGxldCBlbmQgPSBudWxsXG5cbiAgaWYgKGlucHV0LnN0YXJ0KSB7XG4gICAgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5zdGFydClcbiAgfVxuXG4gIGlmIChpbnB1dC5lbmQpIHtcbiAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5lbmQpXG4gIH1cblxuICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQgPCBzdGFydCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4geyBzdGFydCwgZW5kIH1cbn1cblxuLy8gU0lERS1FRkZFQ1Q6IHdpbGwgbXV0YXRlIHJhbmdlcy5cbi8vIFdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHJlc3VsdC5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnRSYW5nZXMocmFuZ2VzOiBEYXRlUmFuZ2VbXSwgY29uc3RyYWludFJhbmdlOiBEYXRlUmFuZ2UpOiBEYXRlUmFuZ2VbXSB7XG4gIGxldCBpbnZlcnRlZFJhbmdlczogRGF0ZVJhbmdlW10gPSBbXVxuICBsZXQgeyBzdGFydCB9ID0gY29uc3RyYWludFJhbmdlIC8vIHRoZSBlbmQgb2YgdGhlIHByZXZpb3VzIHJhbmdlLiB0aGUgc3RhcnQgb2YgdGhlIG5ldyByYW5nZVxuICBsZXQgaVxuICBsZXQgZGF0ZVJhbmdlXG5cbiAgLy8gcmFuZ2VzIG5lZWQgdG8gYmUgaW4gb3JkZXIuIHJlcXVpcmVkIGZvciBvdXIgZGF0ZS13YWxraW5nIGFsZ29yaXRobVxuICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKVxuXG4gIGZvciAoaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV1cblxuICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBkYXRlUmFuZ2Uuc3RhcnQgfSlcbiAgICB9XG5cbiAgICBpZiAoZGF0ZVJhbmdlLmVuZCA+IHN0YXJ0KSB7XG4gICAgICBzdGFydCA9IGRhdGVSYW5nZS5lbmRcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgdGhlIHNwYW4gb2YgdGltZSBhZnRlciB0aGUgbGFzdCBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICBpZiAoc3RhcnQgPCBjb25zdHJhaW50UmFuZ2UuZW5kKSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgaW52ZXJ0ZWRSYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQ6IGNvbnN0cmFpbnRSYW5nZS5lbmQgfSlcbiAgfVxuXG4gIHJldHVybiBpbnZlcnRlZFJhbmdlc1xufVxuXG5mdW5jdGlvbiBjb21wYXJlUmFuZ2VzKHJhbmdlMDogRGF0ZVJhbmdlLCByYW5nZTE6IERhdGVSYW5nZSkge1xuICByZXR1cm4gcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSAtIHJhbmdlMS5zdGFydC52YWx1ZU9mKCkgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTA6IE9wZW5EYXRlUmFuZ2UsIHJhbmdlMTogT3BlbkRhdGVSYW5nZSk6IE9wZW5EYXRlUmFuZ2Uge1xuICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTBcbiAgbGV0IG5ld1JhbmdlID0gbnVsbFxuXG4gIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcbiAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgIHN0YXJ0ID0gcmFuZ2UxLnN0YXJ0XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSlcbiAgICB9XG4gIH1cblxuICBpZiAocmFuZ2UxLmVuZCAhPSBudWxsKSB7XG4gICAgaWYgKGVuZCA9PT0gbnVsbCkge1xuICAgICAgZW5kID0gcmFuZ2UxLmVuZFxuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBuZXcgRGF0ZShNYXRoLm1pbihlbmQudmFsdWVPZigpLCByYW5nZTEuZW5kLnZhbHVlT2YoKSkpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCB8fCBzdGFydCA8IGVuZCkge1xuICAgIG5ld1JhbmdlID0geyBzdGFydCwgZW5kIH1cbiAgfVxuXG4gIHJldHVybiBuZXdSYW5nZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VzRXF1YWwocmFuZ2UwOiBPcGVuRGF0ZVJhbmdlLCByYW5nZTE6IE9wZW5EYXRlUmFuZ2UpOiBib29sZWFuIHtcbiAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcbiAgICAocmFuZ2UwLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTAuZW5kLnZhbHVlT2YoKSkgPT09IChyYW5nZTEuZW5kID09PSBudWxsID8gbnVsbCA6IHJhbmdlMS5lbmQudmFsdWVPZigpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VzSW50ZXJzZWN0KHJhbmdlMDogT3BlbkRhdGVSYW5nZSwgcmFuZ2UxOiBPcGVuRGF0ZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiAocmFuZ2UwLmVuZCA9PT0gbnVsbCB8fCByYW5nZTEuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UwLmVuZCA+IHJhbmdlMS5zdGFydCkgJiZcbiAgICAocmFuZ2UwLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMS5lbmQgPT09IG51bGwgfHwgcmFuZ2UwLnN0YXJ0IDwgcmFuZ2UxLmVuZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlOiBPcGVuRGF0ZVJhbmdlLCBpbm5lclJhbmdlOiBPcGVuRGF0ZVJhbmdlKTogYm9vbGVhbiB7XG4gIHJldHVybiAob3V0ZXJSYW5nZS5zdGFydCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5zdGFydCAhPT0gbnVsbCAmJiBpbm5lclJhbmdlLnN0YXJ0ID49IG91dGVyUmFuZ2Uuc3RhcnQpKSAmJlxuICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2VDb250YWluc01hcmtlcihyYW5nZTogT3BlbkRhdGVSYW5nZSwgZGF0ZTogRGF0ZU1hcmtlciB8IG51bWJlcik6IGJvb2xlYW4geyAvLyBkYXRlIGNhbiBiZSBhIG1pbGxpc2Vjb25kIHRpbWVcbiAgcmV0dXJuIChyYW5nZS5zdGFydCA9PT0gbnVsbCB8fCBkYXRlID49IHJhbmdlLnN0YXJ0KSAmJlxuICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZClcbn1cblxuLy8gSWYgdGhlIGdpdmVuIGRhdGUgaXMgbm90IHdpdGhpbiB0aGUgZ2l2ZW4gcmFuZ2UsIG1vdmUgaXQgaW5zaWRlLlxuLy8gKElmIGl0J3MgcGFzdCB0aGUgZW5kLCBtYWtlIGl0IG9uZSBtaWxsaXNlY29uZCBiZWZvcmUgdGhlIGVuZCkuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RyYWluTWFya2VyVG9SYW5nZShkYXRlOiBEYXRlTWFya2VyLCByYW5nZTogRGF0ZVJhbmdlKTogRGF0ZU1hcmtlciB7XG4gIGlmIChyYW5nZS5zdGFydCAhPSBudWxsICYmIGRhdGUgPCByYW5nZS5zdGFydCkge1xuICAgIHJldHVybiByYW5nZS5zdGFydFxuICB9XG5cbiAgaWYgKHJhbmdlLmVuZCAhPSBudWxsICYmIGRhdGUgPj0gcmFuZ2UuZW5kKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKVxuICB9XG5cbiAgcmV0dXJuIGRhdGVcbn1cbiIsImltcG9ydCB7IEV2ZW50RGVmLCBFdmVudERlZkhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmltcG9ydCB7IEV2ZW50VHVwbGUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgRXZlbnRTdG9yZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBEYXRlUmFuZ2UsIGludmVydFJhbmdlcywgaW50ZXJzZWN0UmFuZ2VzLCByYW5nZUNvbnRhaW5zTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgY29tcGFyZUJ5RmllbGRTcGVjcywgT3JkZXJTcGVjIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgY29tcHV0ZVZpc2libGVEYXlSYW5nZSB9IGZyb20gJy4uL3V0aWwvZGF0ZSdcbmltcG9ydCB7IFNlZyB9IGZyb20gJy4vRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IEV2ZW50QXBpIH0gZnJvbSAnLi4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgRXZlbnRVaSwgRXZlbnRVaUhhc2gsIGNvbWJpbmVFdmVudFVpcyB9IGZyb20gJy4vZXZlbnQtdWknXG5pbXBvcnQgeyBtYXBIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBWaWV3Q29udGV4dCB9IGZyb20gJy4uL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcbmltcG9ydCB7IGFkZE1zLCBEYXRlTWFya2VyLCBzdGFydE9mRGF5IH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcbmltcG9ydCB7IE1vdW50QXJnIH0gZnJvbSAnLi4vY29tbW9uL3JlbmRlci1ob29rJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50UmVuZGVyUmFuZ2UgZXh0ZW5kcyBFdmVudFR1cGxlIHtcbiAgdWk6IEV2ZW50VWlcbiAgcmFuZ2U6IERhdGVSYW5nZVxuICBpc1N0YXJ0OiBib29sZWFuXG4gIGlzRW5kOiBib29sZWFuXG59XG5cbi8qXG5TcGVjaWZ5aW5nIG5leHREYXlUaHJlc2hvbGQgc2lnbmFscyB0aGF0IGFsbC1kYXkgcmFuZ2VzIHNob3VsZCBiZSBzbGljZWQuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlOiBFdmVudFN0b3JlLCBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoLCBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSwgbmV4dERheVRocmVzaG9sZD86IER1cmF0aW9uKSB7XG4gIGxldCBpbnZlcnNlQmdCeUdyb3VwSWQ6IHsgW2dyb3VwSWQ6IHN0cmluZ106IERhdGVSYW5nZVtdIH0gPSB7fVxuICBsZXQgaW52ZXJzZUJnQnlEZWZJZDogeyBbZGVmSWQ6IHN0cmluZ106IERhdGVSYW5nZVtdIH0gPSB7fVxuICBsZXQgZGVmQnlHcm91cElkOiB7IFtncm91cElkOiBzdHJpbmddOiBFdmVudERlZiB9ID0ge31cbiAgbGV0IGJnUmFuZ2VzOiBFdmVudFJlbmRlclJhbmdlW10gPSBbXVxuICBsZXQgZmdSYW5nZXM6IEV2ZW50UmVuZGVyUmFuZ2VbXSA9IFtdXG4gIGxldCBldmVudFVpcyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50VWlCYXNlcylcblxuICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXVxuICAgIGxldCB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF1cblxuICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBbXVxuXG4gICAgICAgIGlmICghZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSkge1xuICAgICAgICAgIGRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBkZWZcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF0gPSBbXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXVxuICAgIGxldCBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdXG4gICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXVxuICAgIGxldCBvcmlnUmFuZ2UgPSBpbnN0YW5jZS5yYW5nZVxuXG4gICAgbGV0IG5vcm1hbFJhbmdlID0gKCFkZWYuYWxsRGF5ICYmIG5leHREYXlUaHJlc2hvbGQpID9cbiAgICAgIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2Uob3JpZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSA6XG4gICAgICBvcmlnUmFuZ2VcblxuICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhub3JtYWxSYW5nZSwgZnJhbWluZ1JhbmdlKVxuXG4gICAgaWYgKHNsaWNlZFJhbmdlKSB7XG4gICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgaW52ZXJzZUJnQnlHcm91cElkW2RlZi5ncm91cElkXS5wdXNoKHNsaWNlZFJhbmdlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludmVyc2VCZ0J5RGVmSWRbaW5zdGFuY2UuZGVmSWRdLnB1c2goc2xpY2VkUmFuZ2UpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodWkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICh1aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgPyBiZ1JhbmdlcyA6IGZnUmFuZ2VzKS5wdXNoKHtcbiAgICAgICAgICBkZWYsXG4gICAgICAgICAgdWksXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgIGlzU3RhcnQ6IG5vcm1hbFJhbmdlLnN0YXJ0ICYmIG5vcm1hbFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpLFxuICAgICAgICAgIGlzRW5kOiBub3JtYWxSYW5nZS5lbmQgJiYgbm9ybWFsUmFuZ2UuZW5kLnZhbHVlT2YoKSA9PT0gc2xpY2VkUmFuZ2UuZW5kLnZhbHVlT2YoKSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBncm91cElkIGluIGludmVyc2VCZ0J5R3JvdXBJZCkgeyAvLyBCWSBHUk9VUFxuICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF1cbiAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpXG5cbiAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICBsZXQgZGVmID0gZGVmQnlHcm91cElkW2dyb3VwSWRdXG4gICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdXG5cbiAgICAgIGJnUmFuZ2VzLnB1c2goe1xuICAgICAgICBkZWYsXG4gICAgICAgIHVpLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxuICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGRlZklkIGluIGludmVyc2VCZ0J5RGVmSWQpIHtcbiAgICBsZXQgcmFuZ2VzID0gaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF1cbiAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpXG5cbiAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICB1aTogZXZlbnRVaXNbZGVmSWRdLFxuICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxuICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGJnOiBiZ1JhbmdlcywgZmc6IGZnUmFuZ2VzIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZjogRXZlbnREZWYpIHtcbiAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbFNlZyhlbDogSFRNTEVsZW1lbnQsIHNlZzogU2VnKSB7XG4gIChlbCBhcyBhbnkpLmZjU2VnID0gc2VnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbFNlZyhlbDogSFRNTEVsZW1lbnQpOiBTZWcgfCBudWxsIHtcbiAgcmV0dXJuIChlbCBhcyBhbnkpLmZjU2VnIHx8XG4gICAgKGVsLnBhcmVudE5vZGUgYXMgYW55KS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICBudWxsXG59XG5cbi8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzOiBFdmVudERlZkhhc2gsIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2gpIHtcbiAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCAoZXZlbnREZWY6IEV2ZW50RGVmKSA9PiBjb21waWxlRXZlbnRVaShldmVudERlZiwgZXZlbnRVaUJhc2VzKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmOiBFdmVudERlZiwgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCkge1xuICBsZXQgdWlzID0gW11cblxuICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1snJ10pXG4gIH1cblxuICBpZiAoZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSkge1xuICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pXG4gIH1cblxuICB1aXMucHVzaChldmVudERlZi51aSlcblxuICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRFdmVudFNlZ3Moc2VncywgZXZlbnRPcmRlclNwZWNzOiBPcmRlclNwZWM8RXZlbnRBcGk+W10pOiBTZWdbXSB7XG4gIGxldCBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKVxuXG4gIG9ianMuc29ydCgob2JqMCwgb2JqMSkgPT4gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBldmVudE9yZGVyU3BlY3MpKVxuXG4gIHJldHVybiBvYmpzLm1hcCgoYykgPT4gYy5fc2VnKVxufVxuXG4vLyByZXR1cm5zIGEgb2JqZWN0IHdpdGggYWxsIHByaW1pdGl2ZSBwcm9wcyB0aGF0IGNhbiBiZSBjb21wYXJlZFxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWc6IFNlZykge1xuICBsZXQgeyBldmVudFJhbmdlIH0gPSBzZWdcbiAgbGV0IGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWZcbiAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5pbnN0YW5jZSA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2UgOiBldmVudFJhbmdlLnJhbmdlXG4gIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0ID8gcmFuZ2Uuc3RhcnQudmFsdWVPZigpIDogMCAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igb3Blbi1yYW5nZSBldmVudHNcbiAgbGV0IGVuZCA9IHJhbmdlLmVuZCA/IHJhbmdlLmVuZC52YWx1ZU9mKCkgOiAwIC8vIFwiXG5cbiAgcmV0dXJuIHtcbiAgICAuLi5ldmVudERlZi5leHRlbmRlZFByb3BzLFxuICAgIC4uLmV2ZW50RGVmLFxuICAgIGlkOiBldmVudERlZi5wdWJsaWNJZCxcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgZHVyYXRpb246IGVuZCAtIHN0YXJ0LFxuICAgIGFsbERheTogTnVtYmVyKGV2ZW50RGVmLmFsbERheSksXG4gICAgX3NlZzogc2VnLCAvLyBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gIH1cbn1cblxuLy8gb3RoZXIgc3R1ZmZcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudENvbnRlbnRBcmcgeyAvLyBmb3IgKkNvbnRlbnQgaGFuZGxlcnNcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIHRpbWVUZXh0OiBzdHJpbmdcbiAgYmFja2dyb3VuZENvbG9yOiBzdHJpbmcgLy8gVE9ETzogYWRkIG90aGVyIEV2ZW50VWkgcHJvcHM/XG4gIGJvcmRlckNvbG9yOiBzdHJpbmcgLy9cbiAgdGV4dENvbG9yOiBzdHJpbmcgLy9cbiAgaXNEcmFnZ2FibGU6IGJvb2xlYW5cbiAgaXNTdGFydFJlc2l6YWJsZTogYm9vbGVhblxuICBpc0VuZFJlc2l6YWJsZTogYm9vbGVhblxuICBpc01pcnJvcjogYm9vbGVhblxuICBpc1N0YXJ0OiBib29sZWFuXG4gIGlzRW5kOiBib29sZWFuXG4gIGlzUGFzdDogYm9vbGVhblxuICBpc0Z1dHVyZTogYm9vbGVhblxuICBpc1RvZGF5OiBib29sZWFuXG4gIGlzU2VsZWN0ZWQ6IGJvb2xlYW5cbiAgaXNEcmFnZ2luZzogYm9vbGVhblxuICBpc1Jlc2l6aW5nOiBib29sZWFuXG4gIHZpZXc6IFZpZXdBcGkgLy8gc3BlY2lmaWNhbGx5IGZvciB0aGUgQVBJXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50TW91bnRBcmcgPSBNb3VudEFyZzxFdmVudENvbnRlbnRBcmc+XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZzogU2VnLCBjb250ZXh0OiBWaWV3Q29udGV4dCkge1xuICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gY29udGV4dFxuICBsZXQgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnNcbiAgbGV0IHsgZGVmLCB1aSB9ID0gc2VnLmV2ZW50UmFuZ2VcbiAgbGV0IHZhbCA9IHVpLnN0YXJ0RWRpdGFibGVcblxuICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnOiBTZWcsIGNvbnRleHQ6IFZpZXdDb250ZXh0KSB7XG4gIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWc6IFNlZywgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KFxuICBzZWc6IFNlZyxcbiAgdGltZUZvcm1hdDogRGF0ZUZvcm1hdHRlcixcbiAgY29udGV4dDogVmlld0NvbnRleHQsXG4gIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lPzogYm9vbGVhbiwgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPzogYm9vbGVhbiwgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICBzdGFydE92ZXJyaWRlPzogRGF0ZU1hcmtlcixcbiAgZW5kT3ZlcnJpZGU/OiBEYXRlTWFya2VyLFxuKSB7XG4gIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgbGV0IHsgZGlzcGxheUV2ZW50VGltZSwgZGlzcGxheUV2ZW50RW5kIH0gPSBvcHRpb25zXG4gIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZlxuICBsZXQgZXZlbnRJbnN0YW5jZSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG5cbiAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkgeyBkaXNwbGF5RXZlbnRUaW1lID0gZGVmYXVsdERpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlIH1cbiAgaWYgKGRpc3BsYXlFdmVudEVuZCA9PSBudWxsKSB7IGRpc3BsYXlFdmVudEVuZCA9IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgIT09IGZhbHNlIH1cblxuICBsZXQgd2hvbGVFdmVudFN0YXJ0ID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydFxuICBsZXQgd2hvbGVFdmVudEVuZCA9IGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kXG4gIGxldCBzZWdTdGFydCA9IHN0YXJ0T3ZlcnJpZGUgfHwgc2VnLnN0YXJ0IHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0XG4gIGxldCBzZWdFbmQgPSBlbmRPdmVycmlkZSB8fCBzZWcuZW5kIHx8IHNlZy5ldmVudFJhbmdlLnJhbmdlLmVuZFxuICBsZXQgaXNTdGFydERheSA9IHN0YXJ0T2ZEYXkod2hvbGVFdmVudFN0YXJ0KS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoc2VnU3RhcnQpLnZhbHVlT2YoKVxuICBsZXQgaXNFbmREYXkgPSBzdGFydE9mRGF5KGFkZE1zKHdob2xlRXZlbnRFbmQsIC0xKSkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KGFkZE1zKHNlZ0VuZCwgLTEpKS52YWx1ZU9mKClcblxuICBpZiAoZGlzcGxheUV2ZW50VGltZSAmJiAhZXZlbnREZWYuYWxsRGF5ICYmIChpc1N0YXJ0RGF5IHx8IGlzRW5kRGF5KSkge1xuICAgIHNlZ1N0YXJ0ID0gaXNTdGFydERheSA/IHdob2xlRXZlbnRTdGFydCA6IHNlZ1N0YXJ0XG4gICAgc2VnRW5kID0gaXNFbmREYXkgPyB3aG9sZUV2ZW50RW5kIDogc2VnRW5kXG5cbiAgICBpZiAoZGlzcGxheUV2ZW50RW5kICYmIGV2ZW50RGVmLmhhc0VuZCkge1xuICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc2VnU3RhcnQsIHNlZ0VuZCwgdGltZUZvcm1hdCwge1xuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb29vb29vb29vbywgZ2l2ZSB0em8gaWYgc2FtZSBkYXRlXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kT3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoc2VnU3RhcnQsIHRpbWVGb3JtYXQsIHtcbiAgICAgIGZvcmNlZFR6bzogc3RhcnRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLCAvLyBub29vb28sIHNhbWVcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuICcnXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWdNZXRhKHNlZzogU2VnLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UsIG5vd0RhdGU/OiBEYXRlTWFya2VyKSB7IC8vIFRPRE86IG1ha2UgYXJnIG9yZGVyIGNvbnNpc3RlbnQgd2l0aCBkYXRlIHV0aWxcbiAgbGV0IHNlZ1JhbmdlID0gc2VnLmV2ZW50UmFuZ2UucmFuZ2VcblxuICByZXR1cm4ge1xuICAgIGlzUGFzdDogc2VnUmFuZ2UuZW5kIDwgKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICBpc1RvZGF5OiB0b2RheVJhbmdlICYmIHJhbmdlQ29udGFpbnNNYXJrZXIodG9kYXlSYW5nZSwgc2VnUmFuZ2Uuc3RhcnQpLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudENsYXNzTmFtZXMocHJvcHM6IEV2ZW50Q29udGVudEFyZykgeyAvLyB3ZWlyZCB0aGF0IHdlIHVzZSB0aGlzIGludGVyZmFjZSwgYnV0IGNvbnZlbmllbnRcbiAgbGV0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gWydmYy1ldmVudCddXG5cbiAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1taXJyb3InKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRHJhZ2dhYmxlKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpXG4gIH1cblxuICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtZHJhZ2dpbmcnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzUmVzaXppbmcpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJylcbiAgfVxuXG4gIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpXG4gIH1cblxuICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc3RhcnQnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRW5kKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpXG4gIH1cblxuICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtdG9kYXknKVxuICB9XG5cbiAgaWYgKHByb3BzLmlzRnV0dXJlKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKVxuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlOiBFdmVudFJlbmRlclJhbmdlKSB7XG4gIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICA6IGAke2V2ZW50UmFuZ2UuZGVmLmRlZklkfToke2V2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQudG9JU09TdHJpbmcoKX1gXG4gIC8vIGludmVyc2UtYmFja2dyb3VuZCBldmVudHMgZG9uJ3QgaGF2ZSBzcGVjaWZpYyBpbnN0YW5jZXMuIFRPRE86IGJldHRlciBzb2x1dGlvblxufVxuIiwiaW1wb3J0IHsgRGF0ZVJhbmdlLCByYW5nZXNFcXVhbCwgT3BlbkRhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVJbnB1dCwgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlRXZlbnRJbnN0YW5jZSB9IGZyb20gJy4vZXZlbnQtaW5zdGFuY2UnXG5pbXBvcnQgeyBwYXJzZUV2ZW50RGVmLCByZWZpbmVFdmVudERlZiB9IGZyb20gJy4vZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBFdmVudFJlbmRlclJhbmdlLCBjb21waWxlRXZlbnRVaSB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBFdmVudFVpSGFzaCB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IHJlZmluZVByb3BzLCBpZGVudGl0eSwgSWRlbnRpdHkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG4vKlxuQSBkYXRhLXN0cnVjdHVyZSBmb3IgYSBkYXRlLXJhbmdlIHRoYXQgd2lsbCBiZSB2aXN1YWxseSBkaXNwbGF5ZWQuXG5Db250YWlucyBvdGhlciBtZXRhZGF0YSBsaWtlIGFsbERheSwgYW5kIGFueXRoaW5nIGVsc2UgQ29tcG9uZW50cyBtaWdodCBsaWtlIHRvIHN0b3JlLlxuXG5UT0RPOiBpbiBmdXR1cmUsIHB1dCBvdGhlclByb3BzIGluIG93biBvYmplY3QuXG4qL1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5EYXRlU3BhbklucHV0IHtcbiAgc3RhcnQ/OiBEYXRlSW5wdXRcbiAgZW5kPzogRGF0ZUlucHV0XG4gIGFsbERheT86IGJvb2xlYW5cbiAgW290aGVyUHJvcDogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNwYW5JbnB1dCBleHRlbmRzIE9wZW5EYXRlU3BhbklucHV0IHtcbiAgc3RhcnQ6IERhdGVJbnB1dFxuICBlbmQ6IERhdGVJbnB1dFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5EYXRlU3BhbiB7XG4gIHJhbmdlOiBPcGVuRGF0ZVJhbmdlXG4gIGFsbERheTogYm9vbGVhblxuICBbb3RoZXJQcm9wOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlU3BhbiBleHRlbmRzIE9wZW5EYXRlU3BhbiB7XG4gIHJhbmdlOiBEYXRlUmFuZ2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYW5nZUFwaSB7XG4gIHN0YXJ0OiBEYXRlXG4gIGVuZDogRGF0ZVxuICBzdGFydFN0cjogc3RyaW5nXG4gIGVuZFN0cjogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNwYW5BcGkgZXh0ZW5kcyBSYW5nZUFwaSB7XG4gIGFsbERheTogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhbmdlQXBpV2l0aFRpbWVab25lIGV4dGVuZHMgUmFuZ2VBcGkge1xuICB0aW1lWm9uZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVBvaW50QXBpIHtcbiAgZGF0ZTogRGF0ZVxuICBkYXRlU3RyOiBzdHJpbmdcbiAgYWxsRGF5OiBib29sZWFuXG59XG5cbmNvbnN0IFNUQU5EQVJEX1BST1BTID0ge1xuICBzdGFydDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0PixcbiAgZW5kOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBhbGxEYXk6IEJvb2xlYW4sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGVTcGFuKHJhdzogRGF0ZVNwYW5JbnB1dCwgZGF0ZUVudjogRGF0ZUVudiwgZGVmYXVsdER1cmF0aW9uPzogRHVyYXRpb24pOiBEYXRlU3BhbiB8IG51bGwge1xuICBsZXQgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudilcbiAgbGV0IHsgcmFuZ2UgfSA9IHNwYW5cblxuICBpZiAoIXJhbmdlLnN0YXJ0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGlmICghcmFuZ2UuZW5kKSB7XG4gICAgaWYgKGRlZmF1bHREdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByYW5nZS5lbmQgPSBkYXRlRW52LmFkZChyYW5nZS5zdGFydCwgZGVmYXVsdER1cmF0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHNwYW4gYXMgRGF0ZVNwYW5cbn1cblxuLypcblRPRE86IHNvbWVob3cgY29tYmluZSB3aXRoIHBhcnNlUmFuZ2U/XG5XaWxsIHJldHVybiBudWxsIGlmIHRoZSBzdGFydC9lbmQgcHJvcHMgd2VyZSBwcmVzZW50IGJ1dCBwYXJzZWQgaW52YWxpZGx5LlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXc6IE9wZW5EYXRlU3BhbklucHV0LCBkYXRlRW52OiBEYXRlRW52KTogT3BlbkRhdGVTcGFuIHwgbnVsbCB7XG4gIGxldCB7IHJlZmluZWQ6IHN0YW5kYXJkUHJvcHMsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIFNUQU5EQVJEX1BST1BTKVxuICBsZXQgc3RhcnRNZXRhID0gc3RhbmRhcmRQcm9wcy5zdGFydCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLnN0YXJ0KSA6IG51bGxcbiAgbGV0IGVuZE1ldGEgPSBzdGFuZGFyZFByb3BzLmVuZCA/IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFuZGFyZFByb3BzLmVuZCkgOiBudWxsXG4gIGxldCB7IGFsbERheSB9ID0gc3RhbmRhcmRQcm9wc1xuXG4gIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJhbmdlOiB7XG4gICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgfSxcbiAgICBhbGxEYXksXG4gICAgLi4uZXh0cmEsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZVNwYW5zRXF1YWwoc3BhbjA6IERhdGVTcGFuLCBzcGFuMTogRGF0ZVNwYW4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHJhbmdlc0VxdWFsKHNwYW4wLnJhbmdlLCBzcGFuMS5yYW5nZSkgJiZcbiAgICBzcGFuMC5hbGxEYXkgPT09IHNwYW4xLmFsbERheSAmJlxuICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKVxufVxuXG4vLyB0aGUgTk9OLURBVEUtUkVMQVRFRCBwcm9wc1xuZnVuY3Rpb24gaXNTcGFuUHJvcHNFcXVhbChzcGFuMDogRGF0ZVNwYW4sIHNwYW4xOiBEYXRlU3Bhbik6IGJvb2xlYW4ge1xuICBmb3IgKGxldCBwcm9wTmFtZSBpbiBzcGFuMSkge1xuICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JhbmdlJyAmJiBwcm9wTmFtZSAhPT0gJ2FsbERheScpIHtcbiAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhcmUgdGhlcmUgYW55IHByb3BzIHRoYXQgc3BhbjAgaGFzIHRoYXQgc3BhbjEgRE9FU04nVCBoYXZlP1xuICAvLyBib3RoIGhhdmUgcmFuZ2UvYWxsRGF5LCBzbyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZS5cbiAgZm9yIChsZXQgcHJvcE5hbWUgaW4gc3BhbjApIHtcbiAgICBpZiAoIShwcm9wTmFtZSBpbiBzcGFuMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpKHNwYW46IERhdGVTcGFuLCBkYXRlRW52OiBEYXRlRW52KTogRGF0ZVNwYW5BcGkge1xuICByZXR1cm4ge1xuICAgIC4uLmJ1aWxkUmFuZ2VBcGkoc3Bhbi5yYW5nZSwgZGF0ZUVudiwgc3Bhbi5hbGxEYXkpLFxuICAgIGFsbERheTogc3Bhbi5hbGxEYXksXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUocmFuZ2U6IERhdGVSYW5nZSwgZGF0ZUVudjogRGF0ZUVudiwgb21pdFRpbWU/OiBib29sZWFuKTogUmFuZ2VBcGlXaXRoVGltZVpvbmUge1xuICByZXR1cm4ge1xuICAgIC4uLmJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSxcbiAgICB0aW1lWm9uZTogZGF0ZUVudi50aW1lWm9uZSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZTogRGF0ZVJhbmdlLCBkYXRlRW52OiBEYXRlRW52LCBvbWl0VGltZT86IGJvb2xlYW4pOiBSYW5nZUFwaSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lIH0pLFxuICAgIGVuZFN0cjogZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kLCB7IG9taXRUaW1lIH0pLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuOiBEYXRlU3BhbiwgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRXZlbnRSZW5kZXJSYW5nZSB7XG4gIGxldCByZXMgPSByZWZpbmVFdmVudERlZih7IGVkaXRhYmxlOiBmYWxzZSB9LCBjb250ZXh0KVxuICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihcbiAgICByZXMucmVmaW5lZCxcbiAgICByZXMuZXh0cmEsXG4gICAgJycsIC8vIHNvdXJjZUlkXG4gICAgZGF0ZVNwYW4uYWxsRGF5LFxuICAgIHRydWUsIC8vIGhhc0VuZFxuICAgIGNvbnRleHQsXG4gIClcblxuICByZXR1cm4ge1xuICAgIGRlZixcbiAgICB1aTogY29tcGlsZUV2ZW50VWkoZGVmLCBldmVudFVpQmFzZXMpLFxuICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxuICAgIHJhbmdlOiBkYXRlU3Bhbi5yYW5nZSxcbiAgICBpc1N0YXJ0OiB0cnVlLFxuICAgIGlzRW5kOiB0cnVlLFxuICB9XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgUG9pbnRlckRyYWdFdmVudCB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL3BvaW50ZXInXG5pbXBvcnQgeyBidWlsZERhdGVTcGFuQXBpLCBEYXRlU3BhbkFwaSwgRGF0ZVBvaW50QXBpLCBEYXRlU3BhbiB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuL1ZpZXdBcGknXG5pbXBvcnQgeyBEYXRlTWFya2VyLCBzdGFydE9mRGF5IH0gZnJvbSAnLi9kYXRlbGliL21hcmtlcidcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlQ2xpY2tBcGkgZXh0ZW5kcyBEYXRlUG9pbnRBcGkge1xuICBkYXlFbDogSFRNTEVsZW1lbnRcbiAganNFdmVudDogVUlFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVNlbGVjdGlvbkFwaSBleHRlbmRzIERhdGVTcGFuQXBpIHtcbiAganNFdmVudDogVUlFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCB0eXBlIERhdGVQb2ludFRyYW5zZm9ybSA9IChkYXRlU3BhbjogRGF0ZVNwYW4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gYW55XG5leHBvcnQgdHlwZSBEYXRlU3BhblRyYW5zZm9ybSA9IChkYXRlU3BhbjogRGF0ZVNwYW4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gYW55XG5cbmV4cG9ydCB0eXBlIENhbGVuZGFySW50ZXJhY3Rpb24gPSB7IGRlc3Ryb3k6ICgpID0+IHZvaWQgfVxuZXhwb3J0IHR5cGUgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzID0geyBuZXcoY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogQ2FsZW5kYXJJbnRlcmFjdGlvbiB9XG5cbmV4cG9ydCB0eXBlIE9wdGlvbkNoYW5nZUhhbmRsZXIgPSAocHJvcFZhbHVlOiBhbnksIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkgPT4gdm9pZFxuZXhwb3J0IHR5cGUgT3B0aW9uQ2hhbmdlSGFuZGxlck1hcCA9IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBPcHRpb25DaGFuZ2VIYW5kbGVyIH1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlU2VsZWN0QXJnIGV4dGVuZHMgRGF0ZVNwYW5BcGkge1xuICBqc0V2ZW50OiBNb3VzZUV2ZW50IHwgbnVsbFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb246IERhdGVTcGFuLCBwZXY6IFBvaW50ZXJEcmFnRXZlbnQgfCBudWxsLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQgJiB7IHZpZXdBcGk/OiBWaWV3QXBpIH0pIHtcbiAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIHtcbiAgICAuLi5idWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc2VsZWN0aW9uLCBjb250ZXh0KSxcbiAgICBqc0V2ZW50OiBwZXYgPyBwZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQgOiBudWxsLCAvLyBJcyB0aGlzIGFsd2F5cyBhIG1vdXNlIGV2ZW50PyBTZWUgIzQ2NTVcbiAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3LFxuICB9IGFzIERhdGVTZWxlY3RBcmcpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVVuc2VsZWN0QXJnIHtcbiAganNFdmVudDogTW91c2VFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldjogUG9pbnRlckRyYWdFdmVudCB8IG51bGwsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCAmIHsgdmlld0FwaT86IFZpZXdBcGkgfSkge1xuICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsXG4gICAgdmlldzogY29udGV4dC52aWV3QXBpIHx8IGNvbnRleHQuY2FsZW5kYXJBcGkudmlldyxcbiAgfSBhcyBEYXRlVW5zZWxlY3RBcmcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZGF0ZVNwYW46IERhdGVTcGFuLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IHByb3BzID0ge30gYXMgRGF0ZVNwYW5BcGlcblxuICBmb3IgKGxldCB0cmFuc2Zvcm0gb2YgY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlU3BhblRyYW5zZm9ybXMpIHtcbiAgICBfX2Fzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSlcbiAgfVxuXG4gIF9fYXNzaWduKHByb3BzLCBidWlsZERhdGVTcGFuQXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKVxuXG4gIHJldHVybiBwcm9wc1xufVxuXG4vLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXG4vLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRFdmVudEVuZChhbGxEYXk6IGJvb2xlYW4sIG1hcmtlcjogRGF0ZU1hcmtlciwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KTogRGF0ZU1hcmtlciB7XG4gIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgbGV0IGVuZCA9IG1hcmtlclxuXG4gIGlmIChhbGxEYXkpIHtcbiAgICBlbmQgPSBzdGFydE9mRGF5KGVuZClcbiAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pXG4gIH0gZWxzZSB7XG4gICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pXG4gIH1cblxuICByZXR1cm4gZW5kXG59XG4iLCJpbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBFdmVudFN0b3JlLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgfSBmcm9tICcuL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRXZlbnREZWYgfSBmcm9tICcuL2V2ZW50LWRlZidcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2UgfSBmcm9tICcuL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgY29tcHV0ZUFsaWduZWREYXlSYW5nZSB9IGZyb20gJy4uL3V0aWwvZGF0ZSdcbmltcG9ydCB7IHN0YXJ0T2ZEYXkgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IEV2ZW50VWlIYXNoLCBFdmVudFVpIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgY29tcGlsZUV2ZW50VWlzIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGdldERlZmF1bHRFdmVudEVuZCB9IGZyb20gJy4uL2NhbGVuZGFyLXV0aWxzJ1xuXG4vKlxuQSBkYXRhIHN0cnVjdHVyZSBmb3IgaG93IHRvIG1vZGlmeSBhbiBFdmVudERlZi9FdmVudEluc3RhbmNlIHdpdGhpbiBhbiBFdmVudFN0b3JlXG4qL1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50TXV0YXRpb24ge1xuICBkYXRlc0RlbHRhPzogRHVyYXRpb24gLy8gYm9keSBzdGFydCtlbmQgbW92aW5nIHRvZ2V0aGVyLiBmb3IgZHJhZ2dpbmdcbiAgc3RhcnREZWx0YT86IER1cmF0aW9uIC8vIGZvciByZXNpemluZ1xuICBlbmREZWx0YT86IER1cmF0aW9uIC8vIGZvciByZXNpemluZ1xuICBzdGFuZGFyZFByb3BzPzogYW55IC8vIGZvciB0aGUgZGVmLiBzaG91bGQgbm90IGluY2x1ZGUgZXh0ZW5kZWRQcm9wc1xuICBleHRlbmRlZFByb3BzPzogYW55IC8vIGZvciB0aGUgZGVmXG59XG5cbi8vIGFwcGxpZXMgdGhlIG11dGF0aW9uIHRvIEFMTCBkZWZzL2luc3RhbmNlcyB3aXRoaW4gdGhlIGV2ZW50IHN0b3JlXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZSxcbiAgZXZlbnRDb25maWdCYXNlOiBFdmVudFVpSGFzaCxcbiAgbXV0YXRpb246IEV2ZW50TXV0YXRpb24sXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbik6IEV2ZW50U3RvcmUge1xuICBsZXQgZXZlbnRDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKGV2ZW50U3RvcmUuZGVmcywgZXZlbnRDb25maWdCYXNlKVxuICBsZXQgZGVzdCA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG5cbiAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF1cblxuICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KVxuICB9XG5cbiAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdXG4gICAgbGV0IGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF0gLy8gaW1wb3J0YW50IHRvIGdyYWIgdGhlIG5ld2x5IG1vZGlmaWVkIGRlZlxuXG4gICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KVxuICB9XG5cbiAgcmV0dXJuIGRlc3Rcbn1cblxuZXhwb3J0IHR5cGUgZXZlbnREZWZNdXRhdGlvbkFwcGxpZXIgPSAoZXZlbnREZWY6IEV2ZW50RGVmLCBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSA9PiB2b2lkXG5cbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50RGVmKGV2ZW50RGVmOiBFdmVudERlZiwgZXZlbnRDb25maWc6IEV2ZW50VWksIG11dGF0aW9uOiBFdmVudE11dGF0aW9uLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudERlZiB7XG4gIGxldCBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fVxuXG4gIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAvLyBhbmQgdGh1cywgd2UgbmVlZCB0byBtYXJrIHRoZSBldmVudCBhcyBoYXZpbmcgYSByZWFsIGVuZFxuICBpZiAoXG4gICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUgJiZcbiAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSlcbiAgKSB7XG4gICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlIC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgfVxuXG4gIGxldCBjb3B5OiBFdmVudERlZiA9IHtcbiAgICAuLi5ldmVudERlZixcbiAgICAuLi5zdGFuZGFyZFByb3BzLFxuICAgIHVpOiB7IC4uLmV2ZW50RGVmLnVpLCAuLi5zdGFuZGFyZFByb3BzLnVpIH0sIC8vIHRoZSBvbmx5IHByb3Agd2Ugd2FudCB0byByZWN1cnNpdmVseSBvdmVybGF5XG4gIH1cblxuICBpZiAobXV0YXRpb24uZXh0ZW5kZWRQcm9wcykge1xuICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IHsgLi4uY29weS5leHRlbmRlZFByb3BzLCAuLi5tdXRhdGlvbi5leHRlbmRlZFByb3BzIH1cbiAgfVxuXG4gIGZvciAobGV0IGFwcGxpZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpIHtcbiAgICBhcHBsaWVyKGNvcHksIG11dGF0aW9uLCBjb250ZXh0KVxuICB9XG5cbiAgaWYgKCFjb3B5Lmhhc0VuZCAmJiBjb250ZXh0Lm9wdGlvbnMuZm9yY2VFdmVudER1cmF0aW9uKSB7XG4gICAgY29weS5oYXNFbmQgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gY29weVxufVxuXG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKFxuICBldmVudEluc3RhbmNlOiBFdmVudEluc3RhbmNlLFxuICBldmVudERlZjogRXZlbnREZWYsIC8vIG11c3QgZmlyc3QgYmUgbW9kaWZpZWQgYnkgYXBwbHlNdXRhdGlvblRvRXZlbnREZWZcbiAgZXZlbnRDb25maWc6IEV2ZW50VWksXG4gIG11dGF0aW9uOiBFdmVudE11dGF0aW9uLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pOiBFdmVudEluc3RhbmNlIHtcbiAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dFxuICBsZXQgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlXG4gIGxldCBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlXG4gIGxldCBjb3B5ID0geyAuLi5ldmVudEluc3RhbmNlIH0gYXMgRXZlbnRJbnN0YW5jZVxuXG4gIGlmIChmb3JjZUFsbERheSkge1xuICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpXG4gIH1cblxuICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XG4gICAgY29weS5yYW5nZSA9IHtcbiAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgIH1cbiAgfVxuXG4gIGlmIChtdXRhdGlvbi5zdGFydERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLnN0YXJ0RGVsdGEpLFxuICAgICAgZW5kOiBjb3B5LnJhbmdlLmVuZCxcbiAgICB9XG4gIH1cblxuICBpZiAobXV0YXRpb24uZW5kRGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICBzdGFydDogY29weS5yYW5nZS5zdGFydCxcbiAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmVuZERlbHRhKSxcbiAgICB9XG4gIH1cblxuICBpZiAoY2xlYXJFbmQpIHtcbiAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICBlbmQ6IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpLFxuICAgIH1cbiAgfVxuXG4gIC8vIGluIGNhc2UgZXZlbnQgd2FzIGFsbC1kYXkgYnV0IHRoZSBzdXBwbGllZCBkZWx0YXMgd2VyZSBub3RcbiAgLy8gYmV0dGVyIHV0aWwgZm9yIHRoaXM/XG4gIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5zdGFydCksXG4gICAgICBlbmQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5lbmQpLFxuICAgIH1cbiAgfVxuXG4gIC8vIGhhbmRsZSBpbnZhbGlkIGR1cmF0aW9uc1xuICBpZiAoY29weS5yYW5nZS5lbmQgPCBjb3B5LnJhbmdlLnN0YXJ0KSB7XG4gICAgY29weS5yYW5nZS5lbmQgPSBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KVxuICB9XG5cbiAgcmV0dXJuIGNvcHlcbn1cbiIsImltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9yZWR1Y2Vycy9kYXRhLXR5cGVzJ1xuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgY2xhc3MgVmlld0FwaSB7IC8vIGFsd2F5cyByZXByZXNlbnRzIHRoZSBjdXJyZW50IHZpZXcuIG90aGVyd2lzZSwgaXQnZCBuZWVkIHRvIGNoYW5nZSB2YWx1ZSBldmVyeSB0aW1lIGRhdGUgY2hhbmdlc1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgdHlwZTogc3RyaW5nLFxuICAgIHByaXZhdGUgZ2V0Q3VycmVudERhdGE6ICgpID0+IENhbGVuZGFyRGF0YSxcbiAgICBwcml2YXRlIGRhdGVFbnY6IERhdGVFbnYsXG4gICkge1xuICB9XG5cbiAgZ2V0IGNhbGVuZGFyKCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkuY2FsZW5kYXJBcGlcbiAgfVxuXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZVxuICB9XG5cbiAgZ2V0IGFjdGl2ZVN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5zdGFydClcbiAgfVxuXG4gIGdldCBhY3RpdmVFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLmVuZClcbiAgfVxuXG4gIGdldCBjdXJyZW50U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydClcbiAgfVxuXG4gIGdldCBjdXJyZW50RW5kKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKVxuICB9XG5cbiAgZ2V0T3B0aW9uKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXSAvLyBhcmUgdGhlIHZpZXctc3BlY2lmaWMgb3B0aW9uc1xuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudElucHV0LCBFdmVudElucHV0VHJhbnNmb3JtZXIgfSBmcm9tICcuL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VGdW5jIH0gZnJvbSAnLi4vZXZlbnQtc291cmNlcy9mdW5jLWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IEV2ZW50U291cmNlLCBFdmVudFNvdXJjZVN1Y2Nlc3NSZXNwb25zZUhhbmRsZXIsIEV2ZW50U291cmNlRXJyb3JSZXNwb25zZUhhbmRsZXIgfSBmcm9tICcuL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgfSBmcm9tICcuLi9ldmVudC1zb3VyY2VzL2pzb24tZmVlZC1ldmVudC1zb3VyY2UtcmVmaW5lcnMnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBndWlkIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgRVZFTlRfVUlfUkVGSU5FUlMsIGNyZWF0ZUV2ZW50VWksIEV2ZW50VWlJbnB1dCwgRXZlbnRVaVJlZmluZWQgfSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtdWknXG5pbXBvcnQgeyBpZGVudGl0eSwgSWRlbnRpdHksIFJhd09wdGlvbnNGcm9tUmVmaW5lcnMsIHJlZmluZVByb3BzLCBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVycyB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmNvbnN0IEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHsgLy8gZG9lcyBOT1QgaW5jbHVkZSBFVkVOVF9VSV9SRUZJTkVSU1xuICBpZDogU3RyaW5nLFxuICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxuICB1cmw6IFN0cmluZyxcbiAgZm9ybWF0OiBTdHJpbmcsXG4gIGV2ZW50czogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRJbnB1dFtdIHwgRXZlbnRTb3VyY2VGdW5jPiwgLy8gYXJyYXkgb3IgZnVuY3Rpb25cbiAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSBhcyBJZGVudGl0eTxFdmVudElucHV0VHJhbnNmb3JtZXI+LFxuXG4gIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgc3VjY2VzczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VTdWNjZXNzUmVzcG9uc2VIYW5kbGVyPixcbiAgZmFpbHVyZTogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RXZlbnRTb3VyY2VFcnJvclJlc3BvbnNlSGFuZGxlcj4sXG59XG5cbnR5cGUgQnVpbHRJbkV2ZW50U291cmNlUmVmaW5lcnMgPSB0eXBlb2YgRVZFTlRfU09VUkNFX1JFRklORVJTICZcbiAgdHlwZW9mIEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlNcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFNvdXJjZVJlZmluZXJzIGV4dGVuZHMgQnVpbHRJbkV2ZW50U291cmNlUmVmaW5lcnMge1xuICAvLyBmb3IgZXh0ZW5kaW5nXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50U291cmNlSW5wdXRPYmplY3QgPVxuICBFdmVudFVpSW5wdXQgJlxuICBSYXdPcHRpb25zRnJvbVJlZmluZXJzPFJlcXVpcmVkPEV2ZW50U291cmNlUmVmaW5lcnM+PiAvLyBSZXF1aXJlZCBoYWNrXG5cbmV4cG9ydCB0eXBlIEV2ZW50U291cmNlSW5wdXQgPVxuICBFdmVudFNvdXJjZUlucHV0T2JqZWN0IHwgLy8gb2JqZWN0IGluIGV4dGVuZGVkIGZvcm1cbiAgRXZlbnRJbnB1dFtdIHxcbiAgRXZlbnRTb3VyY2VGdW5jIHwgLy8ganVzdCBhIGZ1bmN0aW9uXG4gIHN0cmluZyAvLyBhIFVSTCBmb3IgYSBKU09OIGZlZWRcblxuZXhwb3J0IHR5cGUgRXZlbnRTb3VyY2VSZWZpbmVkID1cbiAgRXZlbnRVaVJlZmluZWQgJlxuICBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVyczxSZXF1aXJlZDxFdmVudFNvdXJjZVJlZmluZXJzPj4gLy8gUmVxdWlyZWQgaGFja1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdmVudFNvdXJjZShcbiAgcmF3OiBFdmVudFNvdXJjZUlucHV0LFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gIHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpLFxuKTogRXZlbnRTb3VyY2U8YW55PiB8IG51bGwge1xuICBsZXQgcmF3T2JqOiBFdmVudFNvdXJjZUlucHV0T2JqZWN0XG5cbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgcmF3T2JqID0geyB1cmw6IHJhdyB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICByYXdPYmogPSB7IGV2ZW50czogcmF3IH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnb2JqZWN0JyAmJiByYXcpIHsgLy8gbm90IG51bGxcbiAgICByYXdPYmogPSByYXdcbiAgfVxuXG4gIGlmIChyYXdPYmopIHtcbiAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3T2JqLCByZWZpbmVycylcbiAgICBsZXQgbWV0YVJlcyA9IGJ1aWxkRXZlbnRTb3VyY2VNZXRhKHJlZmluZWQsIGNvbnRleHQpXG5cbiAgICBpZiAobWV0YVJlcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JhdzogcmF3LFxuICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgbGF0ZXN0RmV0Y2hJZDogJycsXG4gICAgICAgIGZldGNoUmFuZ2U6IG51bGwsXG4gICAgICAgIGRlZmF1bHRBbGxEYXk6IHJlZmluZWQuZGVmYXVsdEFsbERheSxcbiAgICAgICAgZXZlbnREYXRhVHJhbnNmb3JtOiByZWZpbmVkLmV2ZW50RGF0YVRyYW5zZm9ybSxcbiAgICAgICAgc3VjY2VzczogcmVmaW5lZC5zdWNjZXNzLFxuICAgICAgICBmYWlsdXJlOiByZWZpbmVkLmZhaWx1cmUsXG4gICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICBzb3VyY2VJZDogZ3VpZCgpLFxuICAgICAgICBzb3VyY2VEZWZJZDogbWV0YVJlcy5zb3VyY2VEZWZJZCxcbiAgICAgICAgbWV0YTogbWV0YVJlcy5tZXRhLFxuICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogZXh0cmEsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgcmV0dXJuIHsgLi4uRVZFTlRfVUlfUkVGSU5FUlMsIC4uLkVWRU5UX1NPVVJDRV9SRUZJTkVSUywgLi4uY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZVJlZmluZXJzIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZU1ldGEocmF3OiBFdmVudFNvdXJjZVJlZmluZWQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzXG5cbiAgZm9yIChsZXQgaSA9IGRlZnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHsgLy8gbGF0ZXItYWRkZWQgcGx1Z2lucyB0YWtlIHByZWNlZGVuY2VcbiAgICBsZXQgZGVmID0gZGVmc1tpXVxuICAgIGxldCBtZXRhID0gZGVmLnBhcnNlTWV0YShyYXcpXG5cbiAgICBpZiAobWV0YSkge1xuICAgICAgcmV0dXJuIHsgc291cmNlRGVmSWQ6IGksIG1ldGEgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJpbXBvcnQgeyBEYXRlRW52LCBEYXRlSW5wdXQgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuaW1wb3J0IHsgQmFzZU9wdGlvbnNSZWZpbmVkIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUN1cnJlbnREYXRlKGN1cnJlbnREYXRlOiBEYXRlTWFya2VyLCBhY3Rpb246IEFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgcmV0dXJuIGFjdGlvbi5kYXRlTWFya2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50RGF0ZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsRGF0ZShvcHRpb25zOiBCYXNlT3B0aW9uc1JlZmluZWQsIGRhdGVFbnY6IERhdGVFbnYpIHtcbiAgbGV0IGluaXRpYWxEYXRlSW5wdXQgPSBvcHRpb25zLmluaXRpYWxEYXRlXG5cbiAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXG4gIGlmIChpbml0aWFsRGF0ZUlucHV0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5pdGlhbERhdGVJbnB1dClcbiAgfVxuICByZXR1cm4gZ2V0Tm93KG9wdGlvbnMubm93LCBkYXRlRW52KSAvLyBnZXROb3cgYWxyZWFkeSByZXR1cm5zIHVuem9uZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vdyhub3dJbnB1dDogRGF0ZUlucHV0IHwgKCgpID0+IERhdGVJbnB1dCksIGRhdGVFbnY6IERhdGVFbnYpIHtcbiAgaWYgKHR5cGVvZiBub3dJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vd0lucHV0ID0gbm93SW5wdXQoKVxuICB9XG5cbiAgaWYgKG5vd0lucHV0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVOb3dNYXJrZXIoKVxuICB9XG5cbiAgcmV0dXJuIGRhdGVFbnYuY3JlYXRlTWFya2VyKG5vd0lucHV0KVxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgcGFyc2VEYXRlU3BhbiB9IGZyb20gJy4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyBwYXJzZUV2ZW50U291cmNlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1wYXJzZSdcbmltcG9ydCB7IHBhcnNlRXZlbnQgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5pbXBvcnQgeyBldmVudFR1cGxlVG9TdG9yZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmltcG9ydCB7IFBvaW50ZXJEcmFnRXZlbnQgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9wb2ludGVyJ1xuaW1wb3J0IHsgZ2V0Tm93IH0gZnJvbSAnLi9yZWR1Y2Vycy9jdXJyZW50LWRhdGUnXG5pbXBvcnQgeyB0cmlnZ2VyRGF0ZVNlbGVjdCwgdHJpZ2dlckRhdGVVbnNlbGVjdCB9IGZyb20gJy4vY2FsZW5kYXItdXRpbHMnXG5pbXBvcnQgeyBoYXNoVmFsdWVzVG9BcnJheSB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBDYWxlbmRhckRhdGFNYW5hZ2VyIH0gZnJvbSAnLi9yZWR1Y2Vycy9DYWxlbmRhckRhdGFNYW5hZ2VyJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9yZWR1Y2Vycy9BY3Rpb24nXG5pbXBvcnQgeyBFdmVudFNvdXJjZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBldmVudEFwaVRvU3RvcmUsIGJ1aWxkRXZlbnRBcGlzIH0gZnJvbSAnLi9hcGkvRXZlbnRBcGknXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgQ2FsZW5kYXJPcHRpb25zLFxuICBDYWxlbmRhckxpc3RlbmVycyxcbiAgRGF0ZUlucHV0LFxuICBEdXJhdGlvbklucHV0LFxuICBEYXRlU3BhbklucHV0LFxuICBEYXRlUmFuZ2VJbnB1dCxcbiAgRXZlbnRTb3VyY2VJbnB1dCxcbiAgRXZlbnRJbnB1dCxcbiAgRXZlbnRTb3VyY2VBcGksXG4gIEV2ZW50QXBpLFxuICBWaWV3QXBpLFxufSBmcm9tICcuL2FwaS10eXBlLWRlcHMnXG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckFwaSB7XG4gIGN1cnJlbnREYXRhTWFuYWdlcj86IENhbGVuZGFyRGF0YU1hbmFnZXIgLy8gd2lsbCBiZSBzZXQgYnkgQ2FsZW5kYXJEYXRhTWFuYWdlclxuXG4gIGdldEN1cnJlbnREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlciEuZ2V0Q3VycmVudERhdGEoKVxuICB9XG5cbiAgZGlzcGF0Y2goYWN0aW9uOiBBY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIhLmRpc3BhdGNoKGFjdGlvbilcbiAgfVxuXG4gIGdldCB2aWV3KCk6IFZpZXdBcGkgeyByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdBcGkgfSAvLyBmb3IgcHVibGljIEFQSVxuXG4gIGJhdGNoUmVuZGVyaW5nKGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7IC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIHVwZGF0ZVNpemUoKSB7IC8vIHB1YmxpY1xuICAgIHRoaXMudHJpZ2dlcignX3Jlc2l6ZScsIHRydWUpXG4gIH1cblxuICAvLyBPcHRpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgc2V0T3B0aW9uPE9wdGlvbk5hbWUgZXh0ZW5kcyBrZXlvZiBDYWxlbmRhck9wdGlvbnM+KG5hbWU6IE9wdGlvbk5hbWUsIHZhbDogQ2FsZW5kYXJPcHRpb25zW09wdGlvbk5hbWVdKSB7XG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICBvcHRpb25OYW1lOiBuYW1lLFxuICAgICAgcmF3T3B0aW9uVmFsdWU6IHZhbCxcbiAgICB9KVxuICB9XG5cbiAgZ2V0T3B0aW9uPE9wdGlvbk5hbWUgZXh0ZW5kcyBrZXlvZiBDYWxlbmRhck9wdGlvbnM+KG5hbWU6IE9wdGlvbk5hbWUpOiBDYWxlbmRhck9wdGlvbnNbT3B0aW9uTmFtZV0geyAvLyBnZXR0ZXIsIHVzZWQgZXh0ZXJuYWxseS4gV1RGIFRTXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyIS5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV1cbiAgfVxuXG4gIGdldEF2YWlsYWJsZUxvY2FsZUNvZGVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcylcbiAgfVxuXG4gIC8vIFRyaWdnZXJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBvbjxMaXN0ZW5lck5hbWUgZXh0ZW5kcyBrZXlvZiBDYWxlbmRhckxpc3RlbmVycz4oaGFuZGxlck5hbWU6IExpc3RlbmVyTmFtZSwgaGFuZGxlcjogQ2FsZW5kYXJMaXN0ZW5lcnNbTGlzdGVuZXJOYW1lXSkge1xuICAgIGxldCB7IGN1cnJlbnREYXRhTWFuYWdlciB9ID0gdGhpc1xuXG4gICAgaWYgKGN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnNbaGFuZGxlck5hbWVdKSB7XG4gICAgICBjdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci5vbihoYW5kbGVyTmFtZSwgaGFuZGxlcilcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGxpc3RlbmVyIG5hbWUgJyR7aGFuZGxlck5hbWV9J2ApXG4gICAgfVxuICB9XG5cbiAgb2ZmPExpc3RlbmVyTmFtZSBleHRlbmRzIGtleW9mIENhbGVuZGFyTGlzdGVuZXJzPihoYW5kbGVyTmFtZTogTGlzdGVuZXJOYW1lLCBoYW5kbGVyOiBDYWxlbmRhckxpc3RlbmVyc1tMaXN0ZW5lck5hbWVdKSB7XG4gICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIhLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKVxuICB9XG5cbiAgLy8gbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXG4gIHRyaWdnZXI8TGlzdGVuZXJOYW1lIGV4dGVuZHMga2V5b2YgQ2FsZW5kYXJMaXN0ZW5lcnM+KGhhbmRsZXJOYW1lOiBMaXN0ZW5lck5hbWUsIC4uLmFyZ3M6IFBhcmFtZXRlcnM8Q2FsZW5kYXJMaXN0ZW5lcnNbTGlzdGVuZXJOYW1lXT4pIHtcbiAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlciEuZW1pdHRlci50cmlnZ2VyKGhhbmRsZXJOYW1lLCAuLi5hcmdzKVxuICB9XG5cbiAgLy8gVmlld1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGNoYW5nZVZpZXcodmlld1R5cGU6IHN0cmluZywgZGF0ZU9yUmFuZ2U/OiBEYXRlUmFuZ2VJbnB1dCB8IERhdGVJbnB1dCkge1xuICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgdGhpcy51bnNlbGVjdCgpXG5cbiAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xuICAgICAgICBpZiAoKGRhdGVPclJhbmdlIGFzIERhdGVSYW5nZUlucHV0KS5zdGFydCAmJiAoZGF0ZU9yUmFuZ2UgYXMgRGF0ZVJhbmdlSW5wdXQpLmVuZCkgeyAvLyBhIHJhbmdlXG4gICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICB2aWV3VHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2goeyAvLyBub3QgdmVyeSBlZmZpY2llbnQgdG8gZG8gdHdvIGRpc3BhdGNoZXNcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgIG9wdGlvbk5hbWU6ICd2aXNpYmxlUmFuZ2UnLFxuICAgICAgICAgICAgcmF3T3B0aW9uVmFsdWU6IGRhdGVPclJhbmdlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UgYXMgRGF0ZUlucHV0KSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gIC8vIGB2aWV3VHlwZWAgY2FuIGJlIGEgc3BlY2lmaWMgdmlldyBuYW1lIG9yIGEgZ2VuZXJpYyBvbmUgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLlxuICAvLyBuZWVkcyB0byBjaGFuZ2VcbiAgem9vbVRvKGRhdGVNYXJrZXI6IERhdGVNYXJrZXIsIHZpZXdUeXBlPzogc3RyaW5nKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgbGV0IHNwZWNcblxuICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgJ2RheScgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxuICAgIHNwZWMgPSBzdGF0ZS52aWV3U3BlY3Nbdmlld1R5cGVdIHx8IHRoaXMuZ2V0VW5pdFZpZXdTcGVjKHZpZXdUeXBlKVxuXG4gICAgdGhpcy51bnNlbGVjdCgpXG5cbiAgICBpZiAoc3BlYykge1xuICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgdmlld1R5cGU6IHNwZWMudHlwZSxcbiAgICAgICAgZGF0ZU1hcmtlcixcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICBkYXRlTWFya2VyLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBHaXZlbiBhIGR1cmF0aW9uIHNpbmd1bGFyIHVuaXQsIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIiwgZmluZHMgYSBtYXRjaGluZyB2aWV3IHNwZWMuXG4gIC8vIFByZWZlcmVuY2UgaXMgZ2l2ZW4gdG8gdmlld3MgdGhhdCBoYXZlIGNvcnJlc3BvbmRpbmcgYnV0dG9ucy5cbiAgcHJpdmF0ZSBnZXRVbml0Vmlld1NwZWModW5pdDogc3RyaW5nKTogVmlld1NwZWMgfCBudWxsIHtcbiAgICBsZXQgeyB2aWV3U3BlY3MsIHRvb2xiYXJDb25maWcgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCB2aWV3VHlwZXMgPSBbXS5jb25jYXQodG9vbGJhckNvbmZpZy52aWV3c1dpdGhCdXR0b25zKVxuICAgIGxldCBpXG4gICAgbGV0IHNwZWNcblxuICAgIGZvciAobGV0IHZpZXdUeXBlIGluIHZpZXdTcGVjcykge1xuICAgICAgdmlld1R5cGVzLnB1c2godmlld1R5cGUpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHZpZXdUeXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc3BlYyA9IHZpZXdTcGVjc1t2aWV3VHlwZXNbaV1dXG4gICAgICBpZiAoc3BlYykge1xuICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XG4gICAgICAgICAgcmV0dXJuIHNwZWNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDdXJyZW50IERhdGVcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBwcmV2KCkge1xuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSlcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgdGhpcy51bnNlbGVjdCgpXG4gICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdORVhUJyB9KVxuICB9XG5cbiAgcHJldlllYXIoKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgdGhpcy51bnNlbGVjdCgpXG4gICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgLTEpLFxuICAgIH0pXG4gIH1cblxuICBuZXh0WWVhcigpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgIH0pXG4gIH1cblxuICB0b2RheSgpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcbiAgICB9KVxuICB9XG5cbiAgZ290b0RhdGUoem9uZWREYXRlSW5wdXQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHRoaXMudW5zZWxlY3QoKVxuICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuY3JlYXRlTWFya2VyKHpvbmVkRGF0ZUlucHV0KSxcbiAgICB9KVxuICB9XG5cbiAgaW5jcmVtZW50RGF0ZShkZWx0YUlucHV0KSB7IC8vIGlzIHB1YmxpYyBmYWNpbmdcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KVxuXG4gICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgIHRoaXMudW5zZWxlY3QoKVxuICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBleHRlcm5hbCBBUElcbiAgZ2V0RGF0ZSgpOiBEYXRlIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcbiAgICByZXR1cm4gc3RhdGUuZGF0ZUVudi50b0RhdGUoc3RhdGUuY3VycmVudERhdGUpXG4gIH1cblxuICAvLyBEYXRlIEZvcm1hdHRpbmcgVXRpbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBmb3JtYXREYXRlKGQ6IERhdGVJbnB1dCwgZm9ybWF0dGVyKTogc3RyaW5nIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChcbiAgICAgIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQpLFxuICAgICAgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlciksXG4gICAgKVxuICB9XG5cbiAgLy8gYHNldHRpbmdzYCBpcyBmb3IgZm9ybWF0dGVyIEFORCBpc0VuZEV4Y2x1c2l2ZVxuICBmb3JtYXRSYW5nZShkMDogRGF0ZUlucHV0LCBkMTogRGF0ZUlucHV0LCBzZXR0aW5ncykge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuXG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoXG4gICAgICBkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksXG4gICAgICBkYXRlRW52LmNyZWF0ZU1hcmtlcihkMSksXG4gICAgICBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLFxuICAgICAgc2V0dGluZ3MsXG4gICAgKVxuICB9XG5cbiAgZm9ybWF0SXNvKGQ6IERhdGVJbnB1dCwgb21pdFRpbWU/OiBib29sZWFuKSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWUgfSlcbiAgfVxuXG4gIC8vIERhdGUgU2VsZWN0aW9uIC8gRXZlbnQgU2VsZWN0aW9uIC8gRGF5Q2xpY2tcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXG4gIC8vIE5PVEU6IGFyZ3Mgd2VyZSBjaGFuZ2VkIGZyb20gdjNcbiAgc2VsZWN0KGRhdGVPck9iajogRGF0ZUlucHV0IHwgYW55LCBlbmREYXRlPzogRGF0ZUlucHV0KSB7XG4gICAgbGV0IHNlbGVjdGlvbklucHV0OiBEYXRlU3BhbklucHV0XG5cbiAgICBpZiAoZW5kRGF0ZSA9PSBudWxsKSB7XG4gICAgICBpZiAoZGF0ZU9yT2JqLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSBkYXRlT3JPYmogYXMgRGF0ZVNwYW5JbnB1dFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgIGVuZDogZW5kRGF0ZSxcbiAgICAgIH0gYXMgRGF0ZVNwYW5JbnB1dFxuICAgIH1cblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCBzZWxlY3Rpb24gPSBwYXJzZURhdGVTcGFuKFxuICAgICAgc2VsZWN0aW9uSW5wdXQsXG4gICAgICBzdGF0ZS5kYXRlRW52LFxuICAgICAgY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pLCAvLyBUT0RPOiBjYWNoZSB0aGlzP1xuICAgIClcblxuICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb24gfSlcbiAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgbnVsbCwgc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgLy8gcHVibGljIG1ldGhvZFxuICB1bnNlbGVjdChwZXY/OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSlcbiAgICAgIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvLyBQdWJsaWMgRXZlbnRzIEFQSVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGFkZEV2ZW50KGV2ZW50SW5wdXQ6IEV2ZW50SW5wdXQsIHNvdXJjZUlucHV0PzogRXZlbnRTb3VyY2VBcGkgfCBzdHJpbmcgfCBib29sZWFuKTogRXZlbnRBcGkgfCBudWxsIHtcbiAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50QXBpKSB7XG4gICAgICBsZXQgZGVmID0gZXZlbnRJbnB1dC5fZGVmXG4gICAgICBsZXQgaW5zdGFuY2UgPSBldmVudElucHV0Ll9pbnN0YW5jZVxuICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICAgIC8vIG5vdCBhbHJlYWR5IHByZXNlbnQ/IGRvbid0IHdhbnQgdG8gYWRkIGFuIG9sZCBzbmFwc2hvdFxuICAgICAgaWYgKCFjdXJyZW50RGF0YS5ldmVudFN0b3JlLmRlZnNbZGVmLmRlZklkXSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UUycsXG4gICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWYsIGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKGV2ZW50SW5wdXQpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBldmVudElucHV0XG4gICAgfVxuXG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgbGV0IGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+XG5cbiAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc291cmNlSW5wdXQgPT09ICdib29sZWFuJykge1xuICAgICAgaWYgKHNvdXJjZUlucHV0KSB7IC8vIHRydWUuIHBhcnQgb2YgdGhlIGZpcnN0IGV2ZW50IHNvdXJjZVxuICAgICAgICBbZXZlbnRTb3VyY2VdID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc291cmNlSW5wdXQgIT0gbnVsbCkgeyAvLyBhbiBJRC4gYWNjZXB0cyBhIG51bWJlciB0b29cbiAgICAgIGxldCBzb3VyY2VBcGkgPSB0aGlzLmdldEV2ZW50U291cmNlQnlJZChzb3VyY2VJbnB1dCkgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG5cbiAgICAgIGlmICghc291cmNlQXBpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXCIke3NvdXJjZUlucHV0fVwiYCkgLy8gVE9ETzogdGVzdFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VBcGkuaW50ZXJuYWxFdmVudFNvdXJjZVxuICAgIH1cblxuICAgIGxldCB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSlcblxuICAgIGlmICh0dXBsZSkge1xuICAgICAgbGV0IG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50QXBpKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgdHVwbGUuZGVmLFxuICAgICAgICB0dXBsZS5kZWYucmVjdXJyaW5nRGVmID8gbnVsbCA6IHR1cGxlLmluc3RhbmNlLFxuICAgICAgKVxuICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUpLFxuICAgICAgfSlcbiAgICAgIHRoaXMudHJpZ2dlckV2ZW50QWRkKG5ld0V2ZW50QXBpKVxuXG4gICAgICByZXR1cm4gbmV3RXZlbnRBcGlcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcHJpdmF0ZSB0cmlnZ2VyRXZlbnRBZGQoZXZlbnRBcGk6IEV2ZW50QXBpKSB7XG4gICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xuICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICByZXZlcnQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50QXBpVG9TdG9yZShldmVudEFwaSksXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICAvLyBUT0RPOiBvcHRpbWl6ZVxuICBnZXRFdmVudEJ5SWQoaWQ6IHN0cmluZyk6IEV2ZW50QXBpIHwgbnVsbCB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpXG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBzdGF0ZS5ldmVudFN0b3JlXG4gICAgaWQgPSBTdHJpbmcoaWQpXG5cbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICBsZXQgZGVmID0gZGVmc1tkZWZJZF1cblxuICAgICAgaWYgKGRlZi5wdWJsaWNJZCA9PT0gaWQpIHtcbiAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50QXBpKHN0YXRlLCBkZWYsIG51bGwpXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGluc3RhbmNlcykge1xuICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXVxuXG4gICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkoc3RhdGUsIGRlZiwgaW5zdGFuY2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGdldEV2ZW50cygpOiBFdmVudEFwaVtdIHtcbiAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSlcbiAgfVxuXG4gIHJlbW92ZUFsbEV2ZW50cygpIHtcbiAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRTJyB9KVxuICB9XG5cbiAgLy8gUHVibGljIEV2ZW50IFNvdXJjZXMgQVBJXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgZ2V0RXZlbnRTb3VyY2VzKCk6IEV2ZW50U291cmNlQXBpW10ge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzXG4gICAgbGV0IHNvdXJjZUFwaXM6IEV2ZW50U291cmNlQXBpW10gPSBbXVxuXG4gICAgZm9yIChsZXQgaW50ZXJuYWxJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICBzb3VyY2VBcGlzLnB1c2gobmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSlcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlQXBpc1xuICB9XG5cbiAgZ2V0RXZlbnRTb3VyY2VCeUlkKGlkOiBzdHJpbmcpOiBFdmVudFNvdXJjZUFwaSB8IG51bGwge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKVxuICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzXG4gICAgaWQgPSBTdHJpbmcoaWQpXG5cbiAgICBmb3IgKGxldCBzb3VyY2VJZCBpbiBzb3VyY2VIYXNoKSB7XG4gICAgICBpZiAoc291cmNlSGFzaFtzb3VyY2VJZF0ucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoc3RhdGUsIHNvdXJjZUhhc2hbc291cmNlSWRdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBhZGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dDogRXZlbnRTb3VyY2VJbnB1dCk6IEV2ZW50U291cmNlQXBpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKClcblxuICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlQXBpKSB7XG4gICAgICAvLyBub3QgYWxyZWFkeSBwcmVzZW50PyBkb24ndCB3YW50IHRvIGFkZCBhbiBvbGQgc25hcHNob3RcbiAgICAgIGlmICghc3RhdGUuZXZlbnRTb3VyY2VzW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgc291cmNlczogW3NvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2VdLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291cmNlSW5wdXRcbiAgICB9XG5cbiAgICBsZXQgZXZlbnRTb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHNvdXJjZUlucHV0LCBzdGF0ZSlcblxuICAgIGlmIChldmVudFNvdXJjZSkgeyAvLyBUT0RPOiBlcnJvciBvdGhlcndpc2U/XG4gICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0FERF9FVkVOVF9TT1VSQ0VTJywgc291cmNlczogW2V2ZW50U291cmNlXSB9KVxuXG4gICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBldmVudFNvdXJjZSlcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmVtb3ZlQWxsRXZlbnRTb3VyY2VzKCkge1xuICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KVxuICB9XG5cbiAgcmVmZXRjaEV2ZW50cygpIHtcbiAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLCBpc1JlZmV0Y2g6IHRydWUgfSlcbiAgfVxuXG4gIC8vIFNjcm9sbFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHNjcm9sbFRvVGltZSh0aW1lSW5wdXQ6IER1cmF0aW9uSW5wdXQpIHtcbiAgICBsZXQgdGltZSA9IGNyZWF0ZUR1cmF0aW9uKHRpbWVJbnB1dClcblxuICAgIGlmICh0aW1lKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19zY3JvbGxSZXF1ZXN0JywgeyB0aW1lIH0pXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgRXZlbnREZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmltcG9ydCB7IEVWRU5UX05PTl9EQVRFX1JFRklORVJTLCBFVkVOVF9EQVRFX1JFRklORVJTIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcbmltcG9ydCB7IEV2ZW50SW5zdGFuY2UgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgRVZFTlRfVUlfUkVGSU5FUlMsIEV2ZW50VWlIYXNoIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgRXZlbnRNdXRhdGlvbiwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtbXV0YXRpb24nXG5pbXBvcnQgeyBkaWZmRGF0ZXMsIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UgfSBmcm9tICcuLi91dGlsL2RhdGUnXG5pbXBvcnQgeyBjcmVhdGVEdXJhdGlvbiwgZHVyYXRpb25zRXF1YWwgfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgZ2V0UmVsZXZhbnRFdmVudHMsIEV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgRGF0ZUlucHV0LFxuICBEdXJhdGlvbklucHV0LFxuICBGb3JtYXR0ZXJJbnB1dCxcbiAgRXZlbnRTb3VyY2VBcGksXG59IGZyb20gJy4uL2FwaS10eXBlLWRlcHMnXG5cbmV4cG9ydCBjbGFzcyBFdmVudEFwaSB7XG4gIF9jb250ZXh0OiBDYWxlbmRhckNvbnRleHRcbiAgX2RlZjogRXZlbnREZWZcbiAgX2luc3RhbmNlOiBFdmVudEluc3RhbmNlIHwgbnVsbFxuICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG5cbiAgY29uc3RydWN0b3IoY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LCBkZWY6IEV2ZW50RGVmLCBpbnN0YW5jZT86IEV2ZW50SW5zdGFuY2UpIHtcbiAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dFxuICAgIHRoaXMuX2RlZiA9IGRlZlxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbFxuICB9XG5cbiAgLypcbiAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAqL1xuICBzZXRQcm9wKG5hbWU6IHN0cmluZywgdmFsOiBhbnkpIHtcbiAgICBpZiAobmFtZSBpbiBFVkVOVF9EQVRFX1JFRklORVJTKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBzZXQgZGF0ZS1yZWxhdGVkIHByb3AgXFwnbmFtZVxcJy4gVXNlIG9uZSBvZiB0aGUgZGF0ZS1yZWxhdGVkIG1ldGhvZHMgaW5zdGVhZC4nKVxuICAgIC8vIFRPRE86IG1ha2UgcHJvcGVyIGFsaWFzaW5nIHN5c3RlbT9cbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbClcblxuICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHB1YmxpY0lkOiB2YWwgfSwgLy8gaGFyZGNvZGVkIGludGVybmFsIG5hbWVcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChuYW1lIGluIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSB7XG4gICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpXG5cbiAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgc3RhbmRhcmRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKG5hbWUgaW4gRVZFTlRfVUlfUkVGSU5FUlMpIHtcbiAgICAgIGxldCB1aSA9IEVWRU5UX1VJX1JFRklORVJTW25hbWVdKHZhbClcblxuICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH1cbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2VkaXRhYmxlJykge1xuICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdWkgPSB7IFtuYW1lXTogdmFsIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICBzdGFuZGFyZFByb3BzOiB7IHVpIH0sXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBzZXQgcHJvcCAnJHtuYW1lfScuIFVzZSBzZXRFeHRlbmRlZFByb3AgaW5zdGVhZC5gKVxuICAgIH1cbiAgfVxuXG4gIHNldEV4dGVuZGVkUHJvcChuYW1lOiBzdHJpbmcsIHZhbDogYW55KSB7XG4gICAgdGhpcy5tdXRhdGUoe1xuICAgICAgZXh0ZW5kZWRQcm9wczogeyBbbmFtZV06IHZhbCB9LFxuICAgIH0pXG4gIH1cblxuICBzZXRTdGFydChzdGFydElucHV0OiBEYXRlSW5wdXQsIG9wdGlvbnM6IHsgZ3JhbnVsYXJpdHk/OiBzdHJpbmcsIG1haW50YWluRHVyYXRpb24/OiBib29sZWFuIH0gPSB7fSkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHRcbiAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KVxuXG4gICAgaWYgKHN0YXJ0ICYmIHRoaXMuX2luc3RhbmNlKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZVxuICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpIC8vIHdoYXQgaWYgcGFyc2VkIGJhZCE/XG5cbiAgICAgIGlmIChvcHRpb25zLm1haW50YWluRHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGEgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRFbmQoZW5kSW5wdXQ6IERhdGVJbnB1dCB8IG51bGwsIG9wdGlvbnM6IHsgZ3JhbnVsYXJpdHk/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dFxuICAgIGxldCBlbmRcblxuICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dClcblxuICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgcmV0dXJuIC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBsZXQgZW5kRGVsdGEgPSBkaWZmRGF0ZXModGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpXG4gICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGEgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXREYXRlcyhzdGFydElucHV0OiBEYXRlSW5wdXQsIGVuZElucHV0OiBEYXRlSW5wdXQgfCBudWxsLCBvcHRpb25zOiB7IGFsbERheT86IGJvb2xlYW4sIGdyYW51bGFyaXR5Pzogc3RyaW5nIH0gPSB7fSkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHRcbiAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBvcHRpb25zLmFsbERheSB9IGFzIGFueVxuICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpXG4gICAgbGV0IGVuZFxuXG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgcmV0dXJuIC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgIH1cblxuICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dClcblxuICAgICAgaWYgKCFlbmQpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgbGV0IGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZVxuXG4gICAgICAvLyB3aGVuIGNvbXB1dGluZyB0aGUgZGlmZiBmb3IgYW4gZXZlbnQgYmVpbmcgY29udmVydGVkIHRvIGFsbC1kYXksXG4gICAgICAvLyBjb21wdXRlIGRpZmYgb2ZmIG9mIHRoZSBhbGwtZGF5IHZhbHVlcyB0aGUgd2F5IGV2ZW50LW11dGF0aW9uIGRvZXMuXG4gICAgICBpZiAob3B0aW9ucy5hbGxEYXkgPT09IHRydWUpIHtcbiAgICAgICAgaW5zdGFuY2VSYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoaW5zdGFuY2VSYW5nZSlcbiAgICAgIH1cblxuICAgICAgbGV0IHN0YXJ0RGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5zdGFydCwgc3RhcnQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpXG5cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpXG5cbiAgICAgICAgaWYgKGR1cmF0aW9uc0VxdWFsKHN0YXJ0RGVsdGEsIGVuZERlbHRhKSkge1xuICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhcnREZWx0YSwgZW5kRGVsdGEsIHN0YW5kYXJkUHJvcHMgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbWVhbnMgXCJjbGVhciB0aGUgZW5kXCJcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBmYWxzZVxuICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHMgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtb3ZlU3RhcnQoZGVsdGFJbnB1dDogRHVyYXRpb25JbnB1dCkge1xuICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpXG5cbiAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IGRlbHRhIH0pXG4gICAgfVxuICB9XG5cbiAgbW92ZUVuZChkZWx0YUlucHV0OiBEdXJhdGlvbklucHV0KSB7XG4gICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dClcblxuICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pXG4gICAgfVxuICB9XG5cbiAgbW92ZURhdGVzKGRlbHRhSW5wdXQ6IER1cmF0aW9uSW5wdXQpIHtcbiAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KVxuXG4gICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBkZWx0YSB9KVxuICAgIH1cbiAgfVxuXG4gIHNldEFsbERheShhbGxEYXk6IGJvb2xlYW4sIG9wdGlvbnM6IHsgbWFpbnRhaW5EdXJhdGlvbj86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgbGV0IHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheSB9IGFzIGFueVxuICAgIGxldCB7IG1haW50YWluRHVyYXRpb24gfSA9IG9wdGlvbnNcblxuICAgIGlmIChtYWludGFpbkR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgIG1haW50YWluRHVyYXRpb24gPSB0aGlzLl9jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWYuYWxsRGF5ICE9PSBhbGxEYXkpIHtcbiAgICAgIHN0YW5kYXJkUHJvcHMuaGFzRW5kID0gbWFpbnRhaW5EdXJhdGlvblxuICAgIH1cblxuICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wcyB9KVxuICB9XG5cbiAgZm9ybWF0UmFuZ2UoZm9ybWF0SW5wdXQ6IEZvcm1hdHRlcklucHV0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dFxuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlXG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihmb3JtYXRJbnB1dClcblxuICAgIGlmICh0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UucmFuZ2UuZW5kLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChpbnN0YW5jZS5yYW5nZS5zdGFydCwgZm9ybWF0dGVyLCB7XG4gICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgIH0pXG4gIH1cblxuICBtdXRhdGUobXV0YXRpb246IEV2ZW50TXV0YXRpb24pIHsgLy8gbWVhbnQgdG8gYmUgcHJpdmF0ZS4gYnV0IHBsdWdpbnMgbmVlZCBhY2Nlc3NcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZVxuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBsZXQgZGVmID0gdGhpcy5fZGVmXG4gICAgICBsZXQgY29udGV4dCA9IHRoaXMuX2NvbnRleHRcbiAgICAgIGxldCB7IGV2ZW50U3RvcmUgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKVxuICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2UuaW5zdGFuY2VJZClcbiAgICAgIGxldCBldmVudENvbmZpZ0Jhc2UgPSB7XG4gICAgICAgICcnOiB7IC8vIEhBQ0suIGFsd2F5cyBhbGxvdyBBUEkgdG8gbXV0YXRlIGV2ZW50c1xuICAgICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25zdHJhaW50czogW10sXG4gICAgICAgICAgb3ZlcmxhcDogbnVsbCxcbiAgICAgICAgICBhbGxvd3M6IFtdLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJycsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgIHRleHRDb2xvcjogJycsXG4gICAgICAgICAgY2xhc3NOYW1lczogW10sXG4gICAgICAgIH0sXG4gICAgICB9IGFzIEV2ZW50VWlIYXNoXG5cbiAgICAgIHJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dClcblxuICAgICAgbGV0IG9sZEV2ZW50ID0gbmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpIC8vIHNuYXBzaG90XG4gICAgICB0aGlzLl9kZWYgPSByZWxldmFudEV2ZW50cy5kZWZzW2RlZi5kZWZJZF1cbiAgICAgIHRoaXMuX2luc3RhbmNlID0gcmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdXG5cbiAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICB9KVxuXG4gICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCB7XG4gICAgICAgIG9sZEV2ZW50LFxuICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGluc3RhbmNlKSxcbiAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlLCAvLyB0aGUgT1JJR0lOQUwgc3RvcmVcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0XG4gICAgbGV0IGFzU3RvcmUgPSBldmVudEFwaVRvU3RvcmUodGhpcylcblxuICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICB9KVxuXG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgIHJldmVydCgpIHtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIGdldCBzb3VyY2UoKTogRXZlbnRTb3VyY2VBcGkgfCBudWxsIHtcbiAgICBsZXQgeyBzb3VyY2VJZCB9ID0gdGhpcy5fZGVmXG5cbiAgICBpZiAoc291cmNlSWQpIHtcbiAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkoXG4gICAgICAgIHRoaXMuX2NvbnRleHQsXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXNbc291cmNlSWRdLFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgZ2V0IHN0YXJ0KCk6IERhdGUgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgP1xuICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgbnVsbFxuICB9XG5cbiAgZ2V0IGVuZCgpOiBEYXRlIHwgbnVsbCB7XG4gICAgcmV0dXJuICh0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSA/XG4gICAgICB0aGlzLl9jb250ZXh0LmRhdGVFbnYudG9EYXRlKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCkgOlxuICAgICAgbnVsbFxuICB9XG5cbiAgZ2V0IHN0YXJ0U3RyKCk6IHN0cmluZyB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2VcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCB7XG4gICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvLFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBnZXQgZW5kU3RyKCk6IHN0cmluZyB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2VcbiAgICBpZiAoaW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICBmb3JjZWRUem86IGluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gY29tcHV0YWJsZSBwcm9wcyB0aGF0IGFsbCBhY2Nlc3MgdGhlIGRlZlxuICAvLyBUT0RPOiBmaW5kIGEgVHlwZVNjcmlwdC1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIGF0IHNjYWxlXG4gIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuX2RlZi5wdWJsaWNJZCB9XG4gIGdldCBncm91cElkKCkgeyByZXR1cm4gdGhpcy5fZGVmLmdyb3VwSWQgfVxuICBnZXQgYWxsRGF5KCkgeyByZXR1cm4gdGhpcy5fZGVmLmFsbERheSB9XG4gIGdldCB0aXRsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi50aXRsZSB9XG4gIGdldCB1cmwoKSB7IHJldHVybiB0aGlzLl9kZWYudXJsIH1cbiAgZ2V0IGRpc3BsYXkoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZGlzcGxheSB8fCAnYXV0bycgfSAvLyBiYWQuIGp1c3Qgbm9ybWFsaXplIHRoZSB0eXBlIGVhcmxpZXJcbiAgZ2V0IHN0YXJ0RWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZSB9XG4gIGdldCBkdXJhdGlvbkVkaXRhYmxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGUgfVxuICBnZXQgY29uc3RyYWludCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsIH1cbiAgZ2V0IG92ZXJsYXAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcCB9XG4gIGdldCBhbGxvdygpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbCB9XG4gIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yIH1cbiAgZ2V0IGJvcmRlckNvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yIH1cbiAgZ2V0IHRleHRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3IgfVxuXG4gIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXG4gIGdldCBjbGFzc05hbWVzKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNsYXNzTmFtZXMgfVxuICBnZXQgZXh0ZW5kZWRQcm9wcygpIHsgcmV0dXJuIHRoaXMuX2RlZi5leHRlbmRlZFByb3BzIH1cblxuICB0b1BsYWluT2JqZWN0KHNldHRpbmdzOiB7IGNvbGxhcHNlRXh0ZW5kZWRQcm9wcz86IGJvb2xlYW4sIGNvbGxhcHNlQ29sb3I/OiBib29sZWFuIH0gPSB7fSk6IERpY3Rpb25hcnkge1xuICAgIGxldCBkZWYgPSB0aGlzLl9kZWZcbiAgICBsZXQgeyB1aSB9ID0gZGVmXG4gICAgbGV0IHsgc3RhcnRTdHIsIGVuZFN0ciB9ID0gdGhpc1xuICAgIGxldCByZXM6IERpY3Rpb25hcnkgPSB7fVxuXG4gICAgaWYgKGRlZi50aXRsZSkge1xuICAgICAgcmVzLnRpdGxlID0gZGVmLnRpdGxlXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0U3RyKSB7XG4gICAgICByZXMuc3RhcnQgPSBzdGFydFN0clxuICAgIH1cblxuICAgIGlmIChlbmRTdHIpIHtcbiAgICAgIHJlcy5lbmQgPSBlbmRTdHJcbiAgICB9XG5cbiAgICBpZiAoZGVmLnB1YmxpY0lkKSB7XG4gICAgICByZXMuaWQgPSBkZWYucHVibGljSWRcbiAgICB9XG5cbiAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgIHJlcy5ncm91cElkID0gZGVmLmdyb3VwSWRcbiAgICB9XG5cbiAgICBpZiAoZGVmLnVybCkge1xuICAgICAgcmVzLnVybCA9IGRlZi51cmxcbiAgICB9XG5cbiAgICBpZiAodWkuZGlzcGxheSAmJiB1aS5kaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJlcy5kaXNwbGF5ID0gdWkuZGlzcGxheVxuICAgIH1cblxuICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgcmVjdXJyaW5nLWV2ZW50IHByb3BlcnRpZXM/Pz9cbiAgICAvLyBUT0RPOiBpbmNsdWRlIHN0YXJ0RWRpdGFibGUvZHVyYXRpb25FZGl0YWJsZS9jb25zdHJhaW50L292ZXJsYXAvYWxsb3dcblxuICAgIGlmIChzZXR0aW5ncy5jb2xsYXBzZUNvbG9yICYmIHVpLmJhY2tncm91bmRDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgPT09IHVpLmJvcmRlckNvbG9yKSB7XG4gICAgICByZXMuY29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3JcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVpLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICByZXMuYmFja2dyb3VuZENvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yXG4gICAgICB9XG4gICAgICBpZiAodWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgcmVzLmJvcmRlckNvbG9yID0gdWkuYm9yZGVyQ29sb3JcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodWkudGV4dENvbG9yKSB7XG4gICAgICByZXMudGV4dENvbG9yID0gdWkudGV4dENvbG9yXG4gICAgfVxuXG4gICAgaWYgKHVpLmNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgICByZXMuY2xhc3NOYW1lcyA9IHVpLmNsYXNzTmFtZXNcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmtleXMoZGVmLmV4dGVuZGVkUHJvcHMpLmxlbmd0aCkge1xuICAgICAgaWYgKHNldHRpbmdzLmNvbGxhcHNlRXh0ZW5kZWRQcm9wcykge1xuICAgICAgICBfX2Fzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLmV4dGVuZGVkUHJvcHMgPSBkZWYuZXh0ZW5kZWRQcm9wc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b1BsYWluT2JqZWN0KClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpOiBFdmVudEFwaSk6IEV2ZW50U3RvcmUge1xuICBsZXQgZGVmID0gZXZlbnRBcGkuX2RlZlxuICBsZXQgaW5zdGFuY2UgPSBldmVudEFwaS5faW5zdGFuY2VcblxuICByZXR1cm4ge1xuICAgIGRlZnM6IHsgW2RlZi5kZWZJZF06IGRlZiB9LFxuICAgIGluc3RhbmNlczogaW5zdGFuY2VcbiAgICAgID8geyBbaW5zdGFuY2UuaW5zdGFuY2VJZF06IGluc3RhbmNlIH1cbiAgICAgIDoge30sXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgZXhjbHVkZUluc3RhbmNlPzogRXZlbnRJbnN0YW5jZSk6IEV2ZW50QXBpW10ge1xuICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmVcbiAgbGV0IGV2ZW50QXBpczogRXZlbnRBcGlbXSA9IFtdXG4gIGxldCBleGNsdWRlSW5zdGFuY2VJZCA9IGV4Y2x1ZGVJbnN0YW5jZSA/IGV4Y2x1ZGVJbnN0YW5jZS5pbnN0YW5jZUlkIDogJydcblxuICBmb3IgKGxldCBpZCBpbiBpbnN0YW5jZXMpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaWRdXG4gICAgbGV0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdXG5cbiAgICBpZiAoaW5zdGFuY2UuaW5zdGFuY2VJZCAhPT0gZXhjbHVkZUluc3RhbmNlSWQpIHtcbiAgICAgIGV2ZW50QXBpcy5wdXNoKG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnRBcGlzXG59XG4iLCJpbXBvcnQgeyBEYXRlTWFya2VyLCBhcnJheVRvVXRjRGF0ZSwgZGF0ZVRvVXRjQXJyYXkgfSBmcm9tICcuL21hcmtlcidcblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhclN5c3RlbSB7XG4gIGdldE1hcmtlclllYXIoZDogRGF0ZU1hcmtlcik6IG51bWJlclxuICBnZXRNYXJrZXJNb250aChkOiBEYXRlTWFya2VyKTogbnVtYmVyXG4gIGdldE1hcmtlckRheShkOiBEYXRlTWFya2VyKTogbnVtYmVyXG4gIGFycmF5VG9NYXJrZXIoYXJyOiBudW1iZXJbXSk6IERhdGVNYXJrZXJcbiAgbWFya2VyVG9BcnJheShkOiBEYXRlTWFya2VyKTogbnVtYmVyW11cbn1cblxubGV0IGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAgPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDYWxlbmRhclN5c3RlbShuYW1lLCB0aGVDbGFzcykge1xuICBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdID0gdGhlQ2xhc3Ncbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyU3lzdGVtKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdKClcbn1cblxuY2xhc3MgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0gaW1wbGVtZW50cyBDYWxlbmRhclN5c3RlbSB7XG4gIGdldE1hcmtlclllYXIoZDogRGF0ZU1hcmtlcikge1xuICAgIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKClcbiAgfVxuXG4gIGdldE1hcmtlck1vbnRoKGQ6IERhdGVNYXJrZXIpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNb250aCgpXG4gIH1cblxuICBnZXRNYXJrZXJEYXkoZDogRGF0ZU1hcmtlcikge1xuICAgIHJldHVybiBkLmdldFVUQ0RhdGUoKVxuICB9XG5cbiAgYXJyYXlUb01hcmtlcihhcnIpIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYXJyKVxuICB9XG5cbiAgbWFya2VyVG9BcnJheShtYXJrZXIpIHtcbiAgICByZXR1cm4gZGF0ZVRvVXRjQXJyYXkobWFya2VyKVxuICB9XG59XG5cbnJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSlcbiIsImltcG9ydCB7IGlzVmFsaWREYXRlIH0gZnJvbSAnLi9tYXJrZXInXG5cbmNvbnN0IElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kL1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIGxldCBtID0gSVNPX1JFLmV4ZWMoc3RyKVxuXG4gIGlmIChtKSB7XG4gICAgbGV0IG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKFxuICAgICAgTnVtYmVyKG1bMV0pLFxuICAgICAgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLFxuICAgICAgTnVtYmVyKG1bNV0gfHwgMSksXG4gICAgICBOdW1iZXIobVs3XSB8fCAwKSxcbiAgICAgIE51bWJlcihtWzhdIHx8IDApLFxuICAgICAgTnVtYmVyKG1bMTBdIHx8IDApLFxuICAgICAgbVsxMl0gPyBOdW1iZXIoYDAuJHttWzEyXX1gKSAqIDEwMDAgOiAwLFxuICAgICkpXG5cbiAgICBpZiAoaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbFxuXG4gICAgICBpZiAobVsxM10pIHtcbiAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoXG4gICAgICAgICAgTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgIE51bWJlcihtWzE4XSB8fCAwKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgaXNUaW1lVW5zcGVjaWZpZWQ6ICFtWzZdLFxuICAgICAgICB0aW1lWm9uZU9mZnNldCxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwiaW1wb3J0IHtcbiAgRGF0ZU1hcmtlciwgYWRkTXMsXG4gIGRpZmZIb3VycywgZGlmZk1pbnV0ZXMsIGRpZmZTZWNvbmRzLCBkaWZmV2hvbGVXZWVrcywgZGlmZldob2xlRGF5cyxcbiAgc3RhcnRPZkRheSwgc3RhcnRPZkhvdXIsIHN0YXJ0T2ZNaW51dGUsIHN0YXJ0T2ZTZWNvbmQsXG4gIHdlZWtPZlllYXIsIGFycmF5VG9VdGNEYXRlLCBkYXRlVG9VdGNBcnJheSwgZGF0ZVRvTG9jYWxBcnJheSwgYXJyYXlUb0xvY2FsRGF0ZSwgdGltZUFzTXMsIGlzVmFsaWREYXRlLFxufSBmcm9tICcuL21hcmtlcidcbmltcG9ydCB7IENhbGVuZGFyU3lzdGVtLCBjcmVhdGVDYWxlbmRhclN5c3RlbSB9IGZyb20gJy4vY2FsZW5kYXItc3lzdGVtJ1xuaW1wb3J0IHsgTG9jYWxlIH0gZnJvbSAnLi9sb2NhbGUnXG5pbXBvcnQgeyBOYW1lZFRpbWVab25lSW1wbCwgTmFtZWRUaW1lWm9uZUltcGxDbGFzcyB9IGZyb20gJy4vdGltZXpvbmUnXG5pbXBvcnQgeyBEdXJhdGlvbiwgYXNSb3VnaFllYXJzLCBhc1JvdWdoTW9udGhzLCBhc1JvdWdoRGF5cywgYXNSb3VnaE1zIH0gZnJvbSAnLi9kdXJhdGlvbidcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIsIENtZEZvcm1hdHRlckZ1bmMgfSBmcm9tICcuL0RhdGVGb3JtYXR0ZXInXG5pbXBvcnQgeyBidWlsZElzb1N0cmluZyB9IGZyb20gJy4vZm9ybWF0dGluZy11dGlscydcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSAnLi9wYXJzaW5nJ1xuaW1wb3J0IHsgaXNJbnQgfSBmcm9tICcuLi91dGlsL21pc2MnXG5cbmV4cG9ydCB0eXBlIFdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9ICdsb2NhbCcgfCAnSVNPJyB8ICgobTogRGF0ZSkgPT4gbnVtYmVyKVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVFbnZTZXR0aW5ncyB7XG4gIHRpbWVab25lOiBzdHJpbmdcbiAgbmFtZWRUaW1lWm9uZUltcGw/OiBOYW1lZFRpbWVab25lSW1wbENsYXNzXG4gIGNhbGVuZGFyU3lzdGVtOiBzdHJpbmdcbiAgbG9jYWxlOiBMb2NhbGVcbiAgd2Vla051bWJlckNhbGN1bGF0aW9uPzogV2Vla051bWJlckNhbGN1bGF0aW9uXG4gIGZpcnN0RGF5PzogbnVtYmVyLCAvLyB3aWxsIG92ZXJyaWRlIHdoYXQgdGhlIGxvY2FsZSB3YW50c1xuICB3ZWVrVGV4dD86IHN0cmluZyxcbiAgY21kRm9ybWF0dGVyPzogQ21kRm9ybWF0dGVyRnVuY1xuICBkZWZhdWx0U2VwYXJhdG9yPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIERhdGVJbnB1dCA9IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCBudW1iZXJbXVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVNYXJrZXJNZXRhIHtcbiAgbWFya2VyOiBEYXRlTWFya2VyXG4gIGlzVGltZVVuc3BlY2lmaWVkOiBib29sZWFuXG4gIGZvcmNlZFR6bzogbnVtYmVyIHwgbnVsbFxufVxuXG5leHBvcnQgY2xhc3MgRGF0ZUVudiB7XG4gIHRpbWVab25lOiBzdHJpbmdcbiAgbmFtZWRUaW1lWm9uZUltcGw6IE5hbWVkVGltZVpvbmVJbXBsXG4gIGNhbkNvbXB1dGVPZmZzZXQ6IGJvb2xlYW5cblxuICBjYWxlbmRhclN5c3RlbTogQ2FsZW5kYXJTeXN0ZW1cbiAgbG9jYWxlOiBMb2NhbGVcbiAgd2Vla0RvdzogbnVtYmVyIC8vIHdoaWNoIGRheSBiZWdpbnMgdGhlIHdlZWtcbiAgd2Vla0RveTogbnVtYmVyIC8vIHdoaWNoIGRheSBtdXN0IGJlIHdpdGhpbiB0aGUgeWVhciwgZm9yIGNvbXB1dGluZyB0aGUgZmlyc3Qgd2VlayBudW1iZXJcbiAgd2Vla051bWJlckZ1bmM6IGFueVxuICB3ZWVrVGV4dDogc3RyaW5nIC8vIERPTidUIExJS0UgaG93IG9wdGlvbnMgYXJlIGNvbmZ1c2VkIHdpdGggbG9jYWxcbiAgY21kRm9ybWF0dGVyPzogQ21kRm9ybWF0dGVyRnVuY1xuICBkZWZhdWx0U2VwYXJhdG9yOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogRGF0ZUVudlNldHRpbmdzKSB7XG4gICAgbGV0IHRpbWVab25lID0gdGhpcy50aW1lWm9uZSA9IHNldHRpbmdzLnRpbWVab25lXG4gICAgbGV0IGlzTmFtZWRUaW1lWm9uZSA9IHRpbWVab25lICE9PSAnbG9jYWwnICYmIHRpbWVab25lICE9PSAnVVRDJ1xuXG4gICAgaWYgKHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsICYmIGlzTmFtZWRUaW1lWm9uZSkge1xuICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbCA9IG5ldyBzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCh0aW1lWm9uZSlcbiAgICB9XG5cbiAgICB0aGlzLmNhbkNvbXB1dGVPZmZzZXQgPSBCb29sZWFuKCFpc05hbWVkVGltZVpvbmUgfHwgdGhpcy5uYW1lZFRpbWVab25lSW1wbClcblxuICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0gPSBjcmVhdGVDYWxlbmRhclN5c3RlbShzZXR0aW5ncy5jYWxlbmRhclN5c3RlbSlcbiAgICB0aGlzLmxvY2FsZSA9IHNldHRpbmdzLmxvY2FsZVxuICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvd1xuICAgIHRoaXMud2Vla0RveSA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRveVxuXG4gICAgaWYgKHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycpIHtcbiAgICAgIHRoaXMud2Vla0RvdyA9IDFcbiAgICAgIHRoaXMud2Vla0RveSA9IDRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmZpcnN0RGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy53ZWVrRG93ID0gc2V0dGluZ3MuZmlyc3REYXlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy53ZWVrTnVtYmVyRnVuYyA9IHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvblxuICAgIH1cblxuICAgIHRoaXMud2Vla1RleHQgPSBzZXR0aW5ncy53ZWVrVGV4dCAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHQgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dFxuXG4gICAgdGhpcy5jbWRGb3JtYXR0ZXIgPSBzZXR0aW5ncy5jbWRGb3JtYXR0ZXJcbiAgICB0aGlzLmRlZmF1bHRTZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yXG4gIH1cblxuICAvLyBDcmVhdGluZyAvIFBhcnNpbmdcblxuICBjcmVhdGVNYXJrZXIoaW5wdXQ6IERhdGVJbnB1dCk6IERhdGVNYXJrZXIge1xuICAgIGxldCBtZXRhID0gdGhpcy5jcmVhdGVNYXJrZXJNZXRhKGlucHV0KVxuICAgIGlmIChtZXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gbWV0YS5tYXJrZXJcbiAgfVxuXG4gIGNyZWF0ZU5vd01hcmtlcigpOiBEYXRlTWFya2VyIHtcbiAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSlcbiAgICB9XG4gICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSB0aGUgY3VycmVudCBkYXRlIHZhbCBmb3IgYSB0aW1lem9uZSxcbiAgICAvLyBiZXR0ZXIgdG8gZ2l2ZSB0aGUgY3VycmVudCBsb2NhbCBkYXRlIHZhbHMgdGhhbiBVVENcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZSgpKSlcbiAgfVxuXG4gIGNyZWF0ZU1hcmtlck1ldGEoaW5wdXQ6IERhdGVJbnB1dCk6IERhdGVNYXJrZXJNZXRhIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpXG4gICAgfVxuXG4gICAgbGV0IG1hcmtlciA9IG51bGxcblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KVxuICAgIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKVxuXG4gICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKGlucHV0KVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KVxuICAgIH1cblxuICAgIGlmIChtYXJrZXIgPT09IG51bGwgfHwgIWlzVmFsaWREYXRlKG1hcmtlcikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogZmFsc2UsIGZvcmNlZFR6bzogbnVsbCB9XG4gIH1cblxuICBwYXJzZShzOiBzdHJpbmcpIHtcbiAgICBsZXQgcGFydHMgPSBwYXJzZShzKVxuICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBsZXQgeyBtYXJrZXIgfSA9IHBhcnRzXG4gICAgbGV0IGZvcmNlZFR6byA9IG51bGxcblxuICAgIGlmIChwYXJ0cy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlZFR6byA9IHBhcnRzLnRpbWVab25lT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWFya2VyLCBpc1RpbWVVbnNwZWNpZmllZDogcGFydHMuaXNUaW1lVW5zcGVjaWZpZWQsIGZvcmNlZFR6byB9XG4gIH1cblxuICAvLyBBY2Nlc3NvcnNcblxuICBnZXRZZWFyKG1hcmtlcjogRGF0ZU1hcmtlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpXG4gIH1cblxuICBnZXRNb250aChtYXJrZXI6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcilcbiAgfVxuXG4gIC8vIEFkZGluZyAvIFN1YnRyYWN0aW5nXG5cbiAgYWRkKG1hcmtlcjogRGF0ZU1hcmtlciwgZHVyOiBEdXJhdGlvbik6IERhdGVNYXJrZXIge1xuICAgIGxldCBhID0gdGhpcy5jYWxlbmRhclN5c3RlbS5tYXJrZXJUb0FycmF5KG1hcmtlcilcbiAgICBhWzBdICs9IGR1ci55ZWFyc1xuICAgIGFbMV0gKz0gZHVyLm1vbnRoc1xuICAgIGFbMl0gKz0gZHVyLmRheXNcbiAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHNcbiAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpXG4gIH1cblxuICBzdWJ0cmFjdChtYXJrZXI6IERhdGVNYXJrZXIsIGR1cjogRHVyYXRpb24pOiBEYXRlTWFya2VyIHtcbiAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpXG4gICAgYVswXSAtPSBkdXIueWVhcnNcbiAgICBhWzFdIC09IGR1ci5tb250aHNcbiAgICBhWzJdIC09IGR1ci5kYXlzXG4gICAgYVs2XSAtPSBkdXIubWlsbGlzZWNvbmRzXG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKVxuICB9XG5cbiAgYWRkWWVhcnMobWFya2VyOiBEYXRlTWFya2VyLCBuOiBudW1iZXIpIHtcbiAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpXG4gICAgYVswXSArPSBuXG4gICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihhKVxuICB9XG5cbiAgYWRkTW9udGhzKG1hcmtlcjogRGF0ZU1hcmtlciwgbjogbnVtYmVyKSB7XG4gICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKVxuICAgIGFbMV0gKz0gblxuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSlcbiAgfVxuXG4gIC8vIERpZmZpbmcgV2hvbGUgVW5pdHNcblxuICBkaWZmV2hvbGVZZWFycyhtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICAgIGxldCB7IGNhbGVuZGFyU3lzdGVtIH0gPSB0aGlzXG5cbiAgICBpZiAoXG4gICAgICB0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSAmJlxuICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSlcbiAgICApIHtcbiAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBkaWZmV2hvbGVNb250aHMobTA6IERhdGVNYXJrZXIsIG0xOiBEYXRlTWFya2VyKTogbnVtYmVyIHtcbiAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpc1xuXG4gICAgaWYgKFxuICAgICAgdGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSlcbiAgICApIHtcbiAgICAgIHJldHVybiAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApKSArXG4gICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTJcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIFJhbmdlIC8gRHVyYXRpb25cblxuICBncmVhdGVzdFdob2xlVW5pdChtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIpIHtcbiAgICBsZXQgbiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKVxuXG4gICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpXG5cbiAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpXG5cbiAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgbiA9IGRpZmZXaG9sZURheXMobTAsIG0xKVxuXG4gICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdkYXknLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpXG5cbiAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfVxuICAgIH1cblxuICAgIG4gPSBkaWZmTWludXRlcyhtMCwgbTEpXG5cbiAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbiB9XG4gICAgfVxuXG4gICAgbiA9IGRpZmZTZWNvbmRzKG0wLCBtMSlcblxuICAgIGlmIChpc0ludChuKSkge1xuICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBuIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH1cbiAgfVxuXG4gIGNvdW50RHVyYXRpb25zQmV0d2VlbihtMDogRGF0ZU1hcmtlciwgbTE6IERhdGVNYXJrZXIsIGQ6IER1cmF0aW9uKSB7XG4gICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgIGxldCBkaWZmXG5cbiAgICBpZiAoZC55ZWFycykge1xuICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlWWVhcnMobTAsIG0xKVxuICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoWWVhcnMoZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpXG4gICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZC5kYXlzKSB7XG4gICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpXG4gICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gYXNSb3VnaE1zKGQpXG4gIH1cblxuICAvLyBTdGFydC1PZlxuICAvLyB0aGVzZSBET04nVCByZXR1cm4gem9uZWQtZGF0ZXMuIG9ubHkgVVRDIHN0YXJ0LW9mIGRhdGVzXG5cbiAgc3RhcnRPZihtOiBEYXRlTWFya2VyLCB1bml0OiBzdHJpbmcpIHtcbiAgICBpZiAodW5pdCA9PT0gJ3llYXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydE9mWWVhcihtKVxuICAgIH1cbiAgICBpZiAodW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZk1vbnRoKG0pXG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnd2VlaycpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZXZWVrKG0pXG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZEYXkobSlcbiAgICB9XG4gICAgaWYgKHVuaXQgPT09ICdob3VyJykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZIb3VyKG0pXG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnbWludXRlJykge1xuICAgICAgcmV0dXJuIHN0YXJ0T2ZNaW51dGUobSlcbiAgICB9XG4gICAgaWYgKHVuaXQgPT09ICdzZWNvbmQnKSB7XG4gICAgICByZXR1cm4gc3RhcnRPZlNlY29uZChtKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgc3RhcnRPZlllYXIobTogRGF0ZU1hcmtlcik6IERhdGVNYXJrZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgIF0pXG4gIH1cblxuICBzdGFydE9mTW9udGgobTogRGF0ZU1hcmtlcik6IERhdGVNYXJrZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICBdKVxuICB9XG5cbiAgc3RhcnRPZldlZWsobTogRGF0ZU1hcmtlcik6IERhdGVNYXJrZXIge1xuICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgIG0uZ2V0VVRDRGF0ZSgpIC0gKChtLmdldFVUQ0RheSgpIC0gdGhpcy53ZWVrRG93ICsgNykgJSA3KSxcbiAgICBdKVxuICB9XG5cbiAgLy8gV2VlayBOdW1iZXJcblxuICBjb21wdXRlV2Vla051bWJlcihtYXJrZXI6IERhdGVNYXJrZXIpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLndlZWtOdW1iZXJGdW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy53ZWVrTnVtYmVyRnVuYyh0aGlzLnRvRGF0ZShtYXJrZXIpKVxuICAgIH1cbiAgICByZXR1cm4gd2Vla09mWWVhcihtYXJrZXIsIHRoaXMud2Vla0RvdywgdGhpcy53ZWVrRG95KVxuICB9XG5cbiAgLy8gVE9ETzogY2hva2Ugb24gdGltZVpvbmVOYW1lOiBsb25nXG4gIGZvcm1hdChtYXJrZXI6IERhdGVNYXJrZXIsIGZvcm1hdHRlcjogRGF0ZUZvcm1hdHRlciwgZGF0ZU9wdGlvbnM6IHsgZm9yY2VkVHpvPzogbnVtYmVyIH0gPSB7fSkge1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KFxuICAgICAge1xuICAgICAgICBtYXJrZXIsXG4gICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkVHpvIDpcbiAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpLFxuICAgICAgfSxcbiAgICAgIHRoaXMsXG4gICAgKVxuICB9XG5cbiAgZm9ybWF0UmFuZ2UoXG4gICAgc3RhcnQ6IERhdGVNYXJrZXIsXG4gICAgZW5kOiBEYXRlTWFya2VyLFxuICAgIGZvcm1hdHRlcjogRGF0ZUZvcm1hdHRlcixcbiAgICBkYXRlT3B0aW9uczogeyBmb3JjZWRTdGFydFR6bz86IG51bWJlciwgZm9yY2VkRW5kVHpvPzogbnVtYmVyLCBpc0VuZEV4Y2x1c2l2ZT86IGJvb2xlYW4sIGRlZmF1bHRTZXBhcmF0b3I/OiBzdHJpbmcgfSA9IHt9LFxuICApIHtcbiAgICBpZiAoZGF0ZU9wdGlvbnMuaXNFbmRFeGNsdXNpdmUpIHtcbiAgICAgIGVuZCA9IGFkZE1zKGVuZCwgLTEpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRSYW5nZShcbiAgICAgIHtcbiAgICAgICAgbWFya2VyOiBzdGFydCxcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvICE9IG51bGwgP1xuICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFN0YXJ0VHpvIDpcbiAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihzdGFydCksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgdGltZVpvbmVPZmZzZXQ6IGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byAhPSBudWxsID9cbiAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gOlxuICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKGVuZCksXG4gICAgICB9LFxuICAgICAgdGhpcyxcbiAgICAgIGRhdGVPcHRpb25zLmRlZmF1bHRTZXBhcmF0b3IsXG4gICAgKVxuICB9XG5cbiAgLypcbiAgRFVNQjogdGhlIG9taXRUaW1lIGFyZyBpcyBkdW1iLiBpZiB3ZSBvbWl0IHRoZSB0aW1lLCB3ZSB3YW50IHRvIG9taXQgdGhlIHRpbWV6b25lIG9mZnNldC4gYW5kIGlmIHdlIGRvIHRoYXQsXG4gIG1pZ2h0IGFzIHdlbGwgdXNlIGJ1aWxkSXNvU3RyaW5nIG9yIHNvbWUgb3RoZXIgdXRpbCBkaXJlY3RseVxuICAqL1xuICBmb3JtYXRJc28obWFya2VyOiBEYXRlTWFya2VyLCBleHRyYU9wdGlvbnM6IGFueSA9IHt9KSB7XG4gICAgbGV0IHRpbWVab25lT2Zmc2V0ID0gbnVsbFxuXG4gICAgaWYgKCFleHRyYU9wdGlvbnMub21pdFRpbWVab25lT2Zmc2V0KSB7XG4gICAgICBpZiAoZXh0cmFPcHRpb25zLmZvcmNlZFR6byAhPSBudWxsKSB7XG4gICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6b1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZVpvbmVPZmZzZXQgPSB0aGlzLm9mZnNldEZvck1hcmtlcihtYXJrZXIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSlcbiAgfVxuXG4gIC8vIFRpbWVab25lXG5cbiAgdGltZXN0YW1wVG9NYXJrZXIobXM6IG51bWJlcikge1xuICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZShtcykpKVxuICAgIH0gaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnIHx8ICF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUobXMpXG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZSh0aGlzLm5hbWVkVGltZVpvbmVJbXBsLnRpbWVzdGFtcFRvQXJyYXkobXMpKVxuICB9XG5cbiAgb2Zmc2V0Rm9yTWFya2VyKG06IERhdGVNYXJrZXIpIHtcbiAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgcmV0dXJuIC1hcnJheVRvTG9jYWxEYXRlKGRhdGVUb1V0Y0FycmF5KG0pKS5nZXRUaW1lem9uZU9mZnNldCgpIC8vIGNvbnZlcnQgXCJpbnZlcnNlXCIgb2Zmc2V0IHRvIFwibm9ybWFsXCIgb2Zmc2V0XG4gICAgfSBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBpZiAodGhpcy5uYW1lZFRpbWVab25lSW1wbCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZWRUaW1lWm9uZUltcGwub2Zmc2V0Rm9yQXJyYXkoZGF0ZVRvVXRjQXJyYXkobSkpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDb252ZXJzaW9uXG5cbiAgdG9EYXRlKG06IERhdGVNYXJrZXIsIGZvcmNlZFR6bz86IG51bWJlcik6IERhdGUge1xuICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSkgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShcbiAgICAgIG0udmFsdWVPZigpIC1cbiAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjAsIC8vIGNvbnZlcnQgbWludXRlcyAtPiBtc1xuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgTG9jYWxlSW5wdXQgfSBmcm9tICcuL2RhdGVsaWIvbG9jYWxlJ1xuXG5leHBvcnQgY29uc3QgZ2xvYmFsTG9jYWxlczogTG9jYWxlSW5wdXRbXSA9IFtdXG4iLCJpbXBvcnQgeyBtZXJnZVByb3BzIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBnbG9iYWxMb2NhbGVzIH0gZnJvbSAnLi4vZ2xvYmFsLWxvY2FsZXMnIC8vIHdlaXJkIHRvIGJlIGltcG9ydGluZyB0aGlzXG5pbXBvcnQgeyBDYWxlbmRhck9wdGlvbnMsIENhbGVuZGFyT3B0aW9uc1JlZmluZWQgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgdHlwZSBMb2NhbGVDb2RlQXJnID0gc3RyaW5nIHwgc3RyaW5nW11cbmV4cG9ydCB0eXBlIExvY2FsZVNpbmd1bGFyQXJnID0gTG9jYWxlQ29kZUFyZyB8IExvY2FsZUlucHV0XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxlIHtcbiAgY29kZUFyZzogTG9jYWxlQ29kZUFyZ1xuICBjb2Rlczogc3RyaW5nW11cbiAgd2VlazogeyBkb3c6IG51bWJlciwgZG95OiBudW1iZXIgfVxuICBzaW1wbGVOdW1iZXJGb3JtYXQ6IEludGwuTnVtYmVyRm9ybWF0XG4gIG9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2NhbGVJbnB1dCBleHRlbmRzIENhbGVuZGFyT3B0aW9ucyB7XG4gIGNvZGU6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBMb2NhbGVJbnB1dE1hcCA9IHsgW2NvZGU6IHN0cmluZ106IExvY2FsZUlucHV0IH1cblxuZXhwb3J0IGludGVyZmFjZSBSYXdMb2NhbGVJbmZvIHtcbiAgbWFwOiBMb2NhbGVJbnB1dE1hcFxuICBkZWZhdWx0Q29kZTogc3RyaW5nXG59XG5cbmNvbnN0IFJBV19FTl9MT0NBTEUgPSB7XG4gIGNvZGU6ICdlbicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrXG4gICAgZG95OiA0LCAvLyA0IGRheXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHllYXIgdG8gYmUgY29uc2lkZXJlZCB0aGUgZmlyc3Qgd2Vla1xuICB9LFxuICBkaXJlY3Rpb246ICdsdHInIGFzICgnbHRyJyB8ICdydGwnKSwgLy8gVE9ETzogbWFrZSBhIHJlYWwgdHlwZSBmb3IgdGhpc1xuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ3ByZXYnLFxuICAgIG5leHQ6ICduZXh0JyxcbiAgICBwcmV2WWVhcjogJ3ByZXYgeWVhcicsXG4gICAgbmV4dFllYXI6ICduZXh0IHllYXInLFxuICAgIHllYXI6ICd5ZWFyJyxcbiAgICB0b2RheTogJ3RvZGF5JyxcbiAgICBtb250aDogJ21vbnRoJyxcbiAgICB3ZWVrOiAnd2VlaycsXG4gICAgZGF5OiAnZGF5JyxcbiAgICBsaXN0OiAnbGlzdCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVycsXG4gIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcbiAgbW9yZUxpbmtUZXh0OiAnbW9yZScsXG4gIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cyB0byBkaXNwbGF5Jyxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXM6IExvY2FsZUlucHV0W10pOiBSYXdMb2NhbGVJbmZvIHtcbiAgbGV0IGRlZmF1bHRDb2RlID0gZXhwbGljaXRSYXdMb2NhbGVzLmxlbmd0aCA+IDAgPyBleHBsaWNpdFJhd0xvY2FsZXNbMF0uY29kZSA6ICdlbidcbiAgbGV0IGFsbFJhd0xvY2FsZXMgPSBnbG9iYWxMb2NhbGVzLmNvbmNhdChleHBsaWNpdFJhd0xvY2FsZXMpXG4gIGxldCByYXdMb2NhbGVNYXA6IExvY2FsZUlucHV0TWFwID0ge1xuICAgIGVuOiBSQVdfRU5fTE9DQUxFLCAvLyBuZWNlc3Nhcnk/XG4gIH1cblxuICBmb3IgKGxldCByYXdMb2NhbGUgb2YgYWxsUmF3TG9jYWxlcykge1xuICAgIHJhd0xvY2FsZU1hcFtyYXdMb2NhbGUuY29kZV0gPSByYXdMb2NhbGVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWFwOiByYXdMb2NhbGVNYXAsXG4gICAgZGVmYXVsdENvZGUsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTG9jYWxlKGlucHV0U2luZ3VsYXI6IExvY2FsZVNpbmd1bGFyQXJnLCBhdmFpbGFibGU6IExvY2FsZUlucHV0TWFwKSB7XG4gIGlmICh0eXBlb2YgaW5wdXRTaW5ndWxhciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5wdXRTaW5ndWxhcikpIHtcbiAgICByZXR1cm4gcGFyc2VMb2NhbGUoXG4gICAgICBpbnB1dFNpbmd1bGFyLmNvZGUsXG4gICAgICBbaW5wdXRTaW5ndWxhci5jb2RlXSxcbiAgICAgIGlucHV0U2luZ3VsYXIsXG4gICAgKVxuICB9XG4gIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5TG9jYWxlKGNvZGVBcmc6IExvY2FsZUNvZGVBcmcsIGF2YWlsYWJsZTogTG9jYWxlSW5wdXRNYXApOiBMb2NhbGUge1xuICBsZXQgY29kZXMgPSBbXS5jb25jYXQoY29kZUFyZyB8fCBbXSkgLy8gd2lsbCBjb252ZXJ0IHRvIGFycmF5XG4gIGxldCByYXcgPSBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB8fCBSQVdfRU5fTE9DQUxFXG5cbiAgcmV0dXJuIHBhcnNlTG9jYWxlKGNvZGVBcmcsIGNvZGVzLCByYXcpXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5UmF3TG9jYWxlKGNvZGVzOiBzdHJpbmdbXSwgYXZhaWxhYmxlOiBMb2NhbGVJbnB1dE1hcCk6IExvY2FsZUlucHV0IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBwYXJ0cyA9IGNvZGVzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCkuc3BsaXQoJy0nKVxuXG4gICAgZm9yIChsZXQgaiA9IHBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xuICAgICAgbGV0IHNpbXBsZUlkID0gcGFydHMuc2xpY2UoMCwgaikuam9pbignLScpXG5cbiAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVbc2ltcGxlSWRdXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYWxlKGNvZGVBcmc6IExvY2FsZUNvZGVBcmcsIGNvZGVzOiBzdHJpbmdbXSwgcmF3OiBMb2NhbGVJbnB1dCk6IExvY2FsZSB7XG4gIGxldCBtZXJnZWQgPSBtZXJnZVByb3BzKFtSQVdfRU5fTE9DQUxFLCByYXddLCBbJ2J1dHRvblRleHQnXSlcblxuICBkZWxldGUgbWVyZ2VkLmNvZGUgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgbGV0IHsgd2VlayB9ID0gbWVyZ2VkXG4gIGRlbGV0ZSBtZXJnZWQud2Vla1xuXG4gIHJldHVybiB7XG4gICAgY29kZUFyZyxcbiAgICBjb2RlcyxcbiAgICB3ZWVrLFxuICAgIHNpbXBsZU51bWJlckZvcm1hdDogbmV3IEludGwuTnVtYmVyRm9ybWF0KGNvZGVBcmcpLFxuICAgIG9wdGlvbnM6IG1lcmdlZCxcbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IE5hdGl2ZUZvcm1hdHRlck9wdGlvbnMgfSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZy1uYXRpdmUnXG5pbXBvcnQgeyBvcmdhbml6ZVJhd0xvY2FsZXMsIGJ1aWxkTG9jYWxlIH0gZnJvbSAnLi9kYXRlbGliL2xvY2FsZSdcbmltcG9ydCB7IEJBU0VfT1BUSU9OX0RFRkFVTFRTIH0gZnJvbSAnLi9vcHRpb25zJ1xuXG4vLyBwdWJsaWNcbmltcG9ydCB7IERhdGVJbnB1dCB9IGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXREYXRlT3B0aW9ucyBleHRlbmRzIE5hdGl2ZUZvcm1hdHRlck9wdGlvbnMge1xuICBsb2NhbGU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRSYW5nZU9wdGlvbnMgZXh0ZW5kcyBGb3JtYXREYXRlT3B0aW9ucyB7XG4gIHNlcGFyYXRvcj86IHN0cmluZ1xuICBpc0VuZEV4Y2x1c2l2ZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZUlucHV0OiBEYXRlSW5wdXQsIG9wdGlvbnM6IEZvcm1hdERhdGVPcHRpb25zID0ge30pIHtcbiAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYob3B0aW9ucylcbiAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKVxuICBsZXQgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KVxuXG4gIGlmICghZGF0ZU1ldGEpIHsgLy8gVE9ETzogd2FybmluZz9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmFuZ2UoXG4gIHN0YXJ0SW5wdXQ6IERhdGVJbnB1dCxcbiAgZW5kSW5wdXQ6IERhdGVJbnB1dCxcbiAgb3B0aW9uczogRm9ybWF0UmFuZ2VPcHRpb25zLCAvLyBtaXh0dXJlIG9mIGVudiBhbmQgZm9ybWF0dGVyIHNldHRpbmdzXG4pIHtcbiAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgPyBvcHRpb25zIDoge30pIC8vIHBhc3MgaW4gaWYgbm9uLW51bGwgb2JqZWN0XG4gIGxldCBmb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucylcbiAgbGV0IHN0YXJ0TWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KVxuICBsZXQgZW5kTWV0YSA9IGRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShlbmRJbnB1dClcblxuICBpZiAoIXN0YXJ0TWV0YSB8fCAhZW5kTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc3RhcnRNZXRhLm1hcmtlciwgZW5kTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEuZm9yY2VkVHpvLFxuICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YS5mb3JjZWRUem8sXG4gICAgaXNFbmRFeGNsdXNpdmU6IG9wdGlvbnMuaXNFbmRFeGNsdXNpdmUsXG4gICAgZGVmYXVsdFNlcGFyYXRvcjogQkFTRV9PUFRJT05fREVGQVVMVFMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yLFxuICB9KVxufVxuXG4vLyBUT0RPOiBtb3JlIERSWSBhbmQgb3B0aW1pemVkXG5mdW5jdGlvbiBidWlsZERhdGVFbnYoc2V0dGluZ3M6IEZvcm1hdFJhbmdlT3B0aW9ucykge1xuICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKSAvLyBUT0RPOiBkb24ndCBoYXJkY29kZSAnZW4nIGV2ZXJ5d2hlcmVcblxuICByZXR1cm4gbmV3IERhdGVFbnYoe1xuICAgIHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSxcbiAgICBjYWxlbmRhclN5c3RlbTogJ2dyZWdvcnknLFxuICAgIC4uLnNldHRpbmdzLFxuICAgIGxvY2FsZSxcbiAgfSlcbn1cbiIsImltcG9ydCB7IEV2ZW50SW5wdXQgfSBmcm9tICcuL2V2ZW50LXBhcnNlJ1xuaW1wb3J0IHsgRXZlbnRTdG9yZSwgcGFyc2VFdmVudHMgfSBmcm9tICcuL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuXG4vKlxuVXRpbHMgZm9yIGNvbnZlcnRpbmcgcmF3IGJ1c2luZXNzIGhvdXIgaW5wdXQgaW50byBhbiBFdmVudFN0b3JlLFxuZm9yIGJvdGggcmVuZGVyaW5nIGFuZCB0aGUgY29uc3RyYWludCBzeXN0ZW0uXG4qL1xuXG5leHBvcnQgdHlwZSBCdXNpbmVzc0hvdXJzSW5wdXQgPSBib29sZWFuIHwgRXZlbnRJbnB1dCB8IEV2ZW50SW5wdXRbXVxuXG5jb25zdCBERUZfREVGQVVMVFMgPSB7XG4gIHN0YXJ0VGltZTogJzA5OjAwJyxcbiAgZW5kVGltZTogJzE3OjAwJyxcbiAgZGF5c09mV2VlazogWzEsIDIsIDMsIDQsIDVdLCAvLyBtb25kYXkgLSBmcmlkYXlcbiAgZGlzcGxheTogJ2ludmVyc2UtYmFja2dyb3VuZCcsXG4gIGNsYXNzTmFtZXM6ICdmYy1ub24tYnVzaW5lc3MnLFxuICBncm91cElkOiAnX2J1c2luZXNzSG91cnMnLCAvLyBzbyBtdWx0aXBsZSBkZWZzIGdldCBncm91cGVkXG59XG5cbi8qXG5UT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcbiovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VCdXNpbmVzc0hvdXJzKGlucHV0OiBCdXNpbmVzc0hvdXJzSW5wdXQsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50U3RvcmUge1xuICByZXR1cm4gcGFyc2VFdmVudHMoXG4gICAgcmVmaW5lSW5wdXRzKGlucHV0KSxcbiAgICBudWxsLFxuICAgIGNvbnRleHQsXG4gIClcbn1cblxuZnVuY3Rpb24gcmVmaW5lSW5wdXRzKGlucHV0OiBCdXNpbmVzc0hvdXJzSW5wdXQpIHtcbiAgbGV0IHJhd0RlZnNcblxuICBpZiAoaW5wdXQgPT09IHRydWUpIHtcbiAgICByYXdEZWZzID0gW3t9XSAvLyB3aWxsIGdldCBERUZfREVGQVVMVFMgdmVyYmF0aW1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIC8vIGlmIHNwZWNpZnlpbmcgYW4gYXJyYXksIGV2ZXJ5IHN1Yi1kZWZpbml0aW9uIE5FRURTIGEgZGF5LW9mLXdlZWtcbiAgICByYXdEZWZzID0gaW5wdXQuZmlsdGVyKChyYXdEZWYpID0+IHJhd0RlZi5kYXlzT2ZXZWVrKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgcmF3RGVmcyA9IFtpbnB1dF1cbiAgfSBlbHNlIHsgLy8gaXMgcHJvYmFibHkgZmFsc2VcbiAgICByYXdEZWZzID0gW11cbiAgfVxuXG4gIHJhd0RlZnMgPSByYXdEZWZzLm1hcCgocmF3RGVmKSA9PiAoeyAuLi5ERUZfREVGQVVMVFMsIC4uLnJhd0RlZiB9KSlcblxuICByZXR1cm4gcmF3RGVmc1xufVxuIiwiZXhwb3J0IGludGVyZmFjZSBQb2ludCB7XG4gIGxlZnQ6IG51bWJlclxuICB0b3A6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY3Qge1xuICBsZWZ0OiBudW1iZXJcbiAgcmlnaHQ6IG51bWJlclxuICB0b3A6IG51bWJlclxuICBib3R0b206IG51bWJlclxufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50OiBQb2ludCwgcmVjdDogUmVjdCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcG9pbnQubGVmdCA+PSByZWN0LmxlZnQgJiZcbiAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgIHBvaW50LnRvcCA8IHJlY3QuYm90dG9tXG59XG5cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDE6IFJlY3QsIHJlY3QyOiBSZWN0KTogUmVjdCB8IGZhbHNlIHtcbiAgbGV0IHJlcyA9IHtcbiAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICByaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcbiAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgfVxuXG4gIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0OiBSZWN0LCBkZWx0YVg6IG51bWJlciwgZGVsdGFZOiBudW1iZXIpOiBSZWN0IHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiByZWN0LmxlZnQgKyBkZWx0YVgsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICBib3R0b206IHJlY3QuYm90dG9tICsgZGVsdGFZLFxuICB9XG59XG5cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJhaW5Qb2ludChwb2ludDogUG9pbnQsIHJlY3Q6IFJlY3QpOiBQb2ludCB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pLFxuICB9XG59XG5cbi8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIHJlY3RhbmdsZVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdDogUmVjdCk6IFBvaW50IHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMixcbiAgfVxufVxuXG4vLyBTdWJ0cmFjdHMgcG9pbnQyJ3MgY29vcmRpbmF0ZXMgZnJvbSBwb2ludDEncyBjb29yZGluYXRlcywgcmV0dXJuaW5nIGEgZGVsdGFcbmV4cG9ydCBmdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MTogUG9pbnQsIHBvaW50MjogUG9pbnQpOiBQb2ludCB7XG4gIHJldHVybiB7XG4gICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wLFxuICB9XG59XG4iLCJsZXQgY2FuVkdyb3dXaXRoaW5DZWxsOiBib29sZWFuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKSB7XG4gIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgIGNhblZHcm93V2l0aGluQ2VsbCA9IGNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwoKVxuICB9XG4gIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGxcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgLy8gZm9yIFNTUiwgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGwgaW1tZWRpYXRlbHkgYXQgdG9wLWxldmVsXG4gIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gIGVsLnN0eWxlLnRvcCA9ICcwcHgnXG4gIGVsLnN0eWxlLmxlZnQgPSAnMHB4J1xuICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nXG4gIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4J1xuICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKVxuXG4gIGxldCBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKVxuICBsZXQgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMFxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKVxuICByZXR1cm4gcG9zc2libGVcbn1cbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBFdmVudFN0b3JlLCBjcmVhdGVFbXB0eUV2ZW50U3RvcmUgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXN0b3JlJ1xuaW1wb3J0IHsgRXZlbnREZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWRlZidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcbmltcG9ydCB7IG1hcEhhc2ggfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBFdmVudFVpSGFzaCwgRXZlbnRVaSwgY29tYmluZUV2ZW50VWlzIH0gZnJvbSAnLi9ldmVudC11aSdcbmltcG9ydCB7IERhdGVTcGFuIH0gZnJvbSAnLi4vc3RydWN0cy9kYXRlLXNwYW4nXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BsaXR0YWJsZVByb3BzIHtcbiAgYnVzaW5lc3NIb3VyczogRXZlbnRTdG9yZSB8IG51bGwgLy8gaXMgdGhpcyByZWFsbHkgYWxsb3dlZCB0byBiZSBudWxsP1xuICBkYXRlU2VsZWN0aW9uOiBEYXRlU3BhbiB8IG51bGxcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZVxuICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG59XG5cbmNvbnN0IEVNUFRZX0VWRU5UX1NUT1JFID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkgLy8gZm9yIHB1cmVjb21wb25lbnRzLiBUT0RPOiBrZWVwIGVsc2V3aGVyZVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3BsaXR0ZXI8UHJvcHNUeXBlIGV4dGVuZHMgU3BsaXR0YWJsZVByb3BzID0gU3BsaXR0YWJsZVByb3BzPiB7XG4gIHByaXZhdGUgZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IG1lbW9pemUodGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcylcbiAgcHJpdmF0ZSBzcGxpdERhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NwbGl0RGF0ZVNwYW4pXG4gIHByaXZhdGUgc3BsaXRFdmVudFN0b3JlID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEV2ZW50U3RvcmUpXG4gIHByaXZhdGUgc3BsaXRJbmRpdmlkdWFsVWkgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW5kaXZpZHVhbFVpKVxuICBwcml2YXRlIHNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZSh0aGlzLl9zcGxpdEludGVyYWN0aW9uKVxuICBwcml2YXRlIHNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW50ZXJhY3Rpb24pXG4gIHByaXZhdGUgZXZlbnRVaUJ1aWxkZXJzID0ge30gLy8gVE9ETzogdHlwZXNjcmlwdCBwcm90ZWN0aW9uXG5cbiAgYWJzdHJhY3QgZ2V0S2V5SW5mbyhwcm9wczogUHJvcHNUeXBlKTogeyBba2V5OiBzdHJpbmddOiB7IHVpPzogRXZlbnRVaSwgYnVzaW5lc3NIb3Vycz86IEV2ZW50U3RvcmUgfSB9XG4gIGFic3RyYWN0IGdldEtleXNGb3JEYXRlU3BhbihkYXRlU3BhbjogRGF0ZVNwYW4pOiBzdHJpbmdbXVxuICBhYnN0cmFjdCBnZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWY6IEV2ZW50RGVmKTogc3RyaW5nW11cblxuICBzcGxpdFByb3BzKHByb3BzOiBQcm9wc1R5cGUpOiB7IFtrZXk6IHN0cmluZ106IFNwbGl0dGFibGVQcm9wcyB9IHtcbiAgICBsZXQga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpXG4gICAgbGV0IGRlZktleXMgPSB0aGlzLmdldEtleXNGb3JFdmVudERlZnMocHJvcHMuZXZlbnRTdG9yZSlcbiAgICBsZXQgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKVxuICAgIGxldCBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cykgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgIGxldCBldmVudFN0b3JlcyA9IHRoaXMuc3BsaXRFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIGRlZktleXMpXG4gICAgbGV0IGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZylcbiAgICBsZXQgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKVxuICAgIGxldCBzcGxpdFByb3BzOiB7IFtrZXk6IHN0cmluZ106IFNwbGl0dGFibGVQcm9wcyB9ID0ge31cblxuICAgIHRoaXMuZXZlbnRVaUJ1aWxkZXJzID0gbWFwSGFzaChrZXlJbmZvcywgKGluZm8sIGtleSkgPT4gdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XSB8fCBtZW1vaXplKGJ1aWxkRXZlbnRVaUZvcktleSkpXG5cbiAgICBmb3IgKGxldCBrZXkgaW4ga2V5SW5mb3MpIHtcbiAgICAgIGxldCBrZXlJbmZvID0ga2V5SW5mb3Nba2V5XVxuICAgICAgbGV0IGV2ZW50U3RvcmUgPSBldmVudFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFXG4gICAgICBsZXQgYnVpbGRFdmVudFVpID0gdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XVxuXG4gICAgICBzcGxpdFByb3BzW2tleV0gPSB7XG4gICAgICAgIGJ1c2luZXNzSG91cnM6IGtleUluZm8uYnVzaW5lc3NIb3VycyB8fCBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uc1trZXldIHx8IG51bGwsXG4gICAgICAgIGV2ZW50U3RvcmUsXG4gICAgICAgIGV2ZW50VWlCYXNlczogYnVpbGRFdmVudFVpKHByb3BzLmV2ZW50VWlCYXNlc1snJ10sIGtleUluZm8udWksIGluZGl2aWR1YWxVaVtrZXldKSxcbiAgICAgICAgZXZlbnRTZWxlY3Rpb246IGV2ZW50U3RvcmUuaW5zdGFuY2VzW3Byb3BzLmV2ZW50U2VsZWN0aW9uXSA/IHByb3BzLmV2ZW50U2VsZWN0aW9uIDogJycsXG4gICAgICAgIGV2ZW50RHJhZzogZXZlbnREcmFnc1trZXldIHx8IG51bGwsXG4gICAgICAgIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZXNba2V5XSB8fCBudWxsLFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGxpdFByb3BzXG4gIH1cblxuICBwcml2YXRlIF9zcGxpdERhdGVTcGFuKGRhdGVTcGFuOiBEYXRlU3BhbiB8IG51bGwpIHtcbiAgICBsZXQgZGF0ZVNwYW5zID0ge31cblxuICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgbGV0IGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3BhbilcblxuICAgICAgZm9yIChsZXQga2V5IG9mIGtleXMpIHtcbiAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhblxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRlU3BhbnNcbiAgfVxuXG4gIHByaXZhdGUgX2dldEtleXNGb3JFdmVudERlZnMoZXZlbnRTdG9yZTogRXZlbnRTdG9yZSkge1xuICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U3RvcmUuZGVmcywgKGV2ZW50RGVmOiBFdmVudERlZikgPT4gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpKVxuICB9XG5cbiAgcHJpdmF0ZSBfc3BsaXRFdmVudFN0b3JlKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIGRlZktleXMpOiB7IFtrZXk6IHN0cmluZ106IEV2ZW50U3RvcmUgfSB7XG4gICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlXG4gICAgbGV0IHNwbGl0U3RvcmVzID0ge31cblxuICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICBpZiAoIXNwbGl0U3RvcmVzW2tleV0pIHtcbiAgICAgICAgICBzcGxpdFN0b3Jlc1trZXldID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKClcbiAgICAgICAgfVxuXG4gICAgICAgIHNwbGl0U3RvcmVzW2tleV0uZGVmc1tkZWZJZF0gPSBkZWZzW2RlZklkXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF1cblxuICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbaW5zdGFuY2UuZGVmSWRdKSB7XG4gICAgICAgIGlmIChzcGxpdFN0b3Jlc1trZXldKSB7IC8vIG11c3QgaGF2ZSBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0uaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gaW5zdGFuY2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGxpdFN0b3Jlc1xuICB9XG5cbiAgcHJpdmF0ZSBfc3BsaXRJbmRpdmlkdWFsVWkoZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCwgZGVmS2V5cyk6IHsgW2tleTogc3RyaW5nXTogRXZlbnRVaUhhc2ggfSB7XG4gICAgbGV0IHNwbGl0SGFzaGVzOiB7IFtrZXk6IHN0cmluZ106IEV2ZW50VWlIYXNoIH0gPSB7fVxuXG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnRVaUJhc2VzKSB7XG4gICAgICBpZiAoZGVmSWQpIHsgLy8gbm90IHRoZSAnJyBrZXlcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbZGVmSWRdKSB7XG4gICAgICAgICAgaWYgKCFzcGxpdEhhc2hlc1trZXldKSB7XG4gICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldID0ge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGxpdEhhc2hlc1trZXldW2RlZklkXSA9IGV2ZW50VWlCYXNlc1tkZWZJZF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGxpdEhhc2hlc1xuICB9XG5cbiAgcHJpdmF0ZSBfc3BsaXRJbnRlcmFjdGlvbihpbnRlcmFjdGlvbjogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbCk6IHsgW2tleTogc3RyaW5nXTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0ge1xuICAgIGxldCBzcGxpdFN0YXRlczogeyBba2V5OiBzdHJpbmddOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfSA9IHt9XG5cbiAgICBpZiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgIGxldCBhZmZlY3RlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShcbiAgICAgICAgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgIHRoaXMuX2dldEtleXNGb3JFdmVudERlZnMoaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMpLCAvLyBjYW4ndCB1c2UgY2FjaGVkLiBtaWdodCBiZSBldmVudHMgZnJvbSBvdGhlciBjYWxlbmRhclxuICAgICAgKVxuXG4gICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgIGxldCBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpXG4gICAgICBsZXQgbXV0YXRlZFN0b3JlcyA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBtdXRhdGVkS2V5c0J5RGVmSWQpXG5cbiAgICAgIGxldCBwb3B1bGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgaWYgKCFzcGxpdFN0YXRlc1trZXldKSB7XG4gICAgICAgICAgc3BsaXRTdGF0ZXNba2V5XSA9IHtcbiAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBhZmZlY3RlZFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbXV0YXRlZFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQga2V5IGluIGFmZmVjdGVkU3RvcmVzKSB7XG4gICAgICAgIHBvcHVsYXRlKGtleSlcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQga2V5IGluIG11dGF0ZWRTdG9yZXMpIHtcbiAgICAgICAgcG9wdWxhdGUoa2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGxpdFN0YXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUZvcktleShhbGxVaTogRXZlbnRVaSB8IG51bGwsIGV2ZW50VWlGb3JLZXk6IEV2ZW50VWkgfCBudWxsLCBpbmRpdmlkdWFsVWk6IEV2ZW50VWlIYXNoIHwgbnVsbCkge1xuICBsZXQgYmFzZVBhcnRzID0gW11cblxuICBpZiAoYWxsVWkpIHtcbiAgICBiYXNlUGFydHMucHVzaChhbGxVaSlcbiAgfVxuXG4gIGlmIChldmVudFVpRm9yS2V5KSB7XG4gICAgYmFzZVBhcnRzLnB1c2goZXZlbnRVaUZvcktleSlcbiAgfVxuXG4gIGxldCBzdHVmZiA9IHtcbiAgICAnJzogY29tYmluZUV2ZW50VWlzKGJhc2VQYXJ0cyksXG4gIH1cblxuICBpZiAoaW5kaXZpZHVhbFVpKSB7XG4gICAgX19hc3NpZ24oc3R1ZmYsIGluZGl2aWR1YWxVaSlcbiAgfVxuXG4gIHJldHVybiBzdHVmZlxufVxuIiwiaW1wb3J0IHsgRGF0ZU1hcmtlciwgREFZX0lEUyB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgcmFuZ2VDb250YWluc01hcmtlciwgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IFRoZW1lIH0gZnJvbSAnLi4vdGhlbWUvVGhlbWUnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZU1ldGEge1xuICBkb3c6IG51bWJlclxuICBpc0Rpc2FibGVkOiBib29sZWFuXG4gIGlzT3RoZXI6IGJvb2xlYW4gLy8gbGlrZSwgaXMgaXQgaW4gdGhlIG5vbi1jdXJyZW50IFwib3RoZXJcIiBtb250aFxuICBpc1RvZGF5OiBib29sZWFuXG4gIGlzUGFzdDogYm9vbGVhblxuICBpc0Z1dHVyZTogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0ZU1ldGEoZGF0ZTogRGF0ZU1hcmtlciwgdG9kYXlSYW5nZT86IERhdGVSYW5nZSwgbm93RGF0ZT86IERhdGVNYXJrZXIsIGRhdGVQcm9maWxlPzogRGF0ZVByb2ZpbGUpOiBEYXRlTWV0YSB7XG4gIHJldHVybiB7XG4gICAgZG93OiBkYXRlLmdldFVUQ0RheSgpLFxuICAgIGlzRGlzYWJsZWQ6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGRhdGUpKSxcbiAgICBpc090aGVyOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgZGF0ZSkpLFxuICAgIGlzVG9kYXk6IEJvb2xlYW4odG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIGRhdGUpKSxcbiAgICBpc1Bhc3Q6IEJvb2xlYW4obm93RGF0ZSA/IChkYXRlIDwgbm93RGF0ZSkgOiB0b2RheVJhbmdlID8gKGRhdGUgPCB0b2RheVJhbmdlLnN0YXJ0KSA6IGZhbHNlKSxcbiAgICBpc0Z1dHVyZTogQm9vbGVhbihub3dEYXRlID8gKGRhdGUgPiBub3dEYXRlKSA6IHRvZGF5UmFuZ2UgPyAoZGF0ZSA+PSB0b2RheVJhbmdlLmVuZCkgOiBmYWxzZSksXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERheUNsYXNzTmFtZXMobWV0YTogRGF0ZU1ldGEsIHRoZW1lOiBUaGVtZSkge1xuICBsZXQgY2xhc3NOYW1lczogc3RyaW5nW10gPSBbXG4gICAgJ2ZjLWRheScsXG4gICAgYGZjLWRheS0ke0RBWV9JRFNbbWV0YS5kb3ddfWAsXG4gIF1cblxuICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZGlzYWJsZWQnKVxuICB9IGVsc2Uge1xuICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXRvZGF5JylcbiAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSlcbiAgICB9XG5cbiAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXBhc3QnKVxuICAgIH1cblxuICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1mdXR1cmUnKVxuICAgIH1cblxuICAgIGlmIChtZXRhLmlzT3RoZXIpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LW90aGVyJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xhc3NOYW1lc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2xvdENsYXNzTmFtZXMobWV0YTogRGF0ZU1ldGEsIHRoZW1lOiBUaGVtZSkge1xuICBsZXQgY2xhc3NOYW1lczogc3RyaW5nW10gPSBbXG4gICAgJ2ZjLXNsb3QnLFxuICAgIGBmYy1zbG90LSR7REFZX0lEU1ttZXRhLmRvd119YCxcbiAgXVxuXG4gIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZGlzYWJsZWQnKVxuICB9IGVsc2Uge1xuICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpXG4gICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpXG4gICAgfVxuXG4gICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpXG4gICAgfVxuXG4gICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG4iLCJpbXBvcnQgeyBmb3JtYXREYXlTdHJpbmcgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZE5hdkxpbmtEYXRhKGRhdGU6IERhdGVNYXJrZXIsIHR5cGUgPSAnZGF5Jykge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIGRhdGU6IGZvcm1hdERheVN0cmluZyhkYXRlKSxcbiAgICB0eXBlLFxuICB9KVxufVxuIiwiaW1wb3J0IHsgcmVtb3ZlRWxlbWVudCwgYXBwbHlTdHlsZSB9IGZyb20gJy4vZG9tLW1hbmlwJ1xuXG5sZXQgX2lzUnRsU2Nyb2xsYmFyT25MZWZ0OiBib29sZWFuIHwgbnVsbCA9IG51bGxcblxuZXhwb3J0IGZ1bmN0aW9uIGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0KCkgeyAvLyByZXNwb25zaWJsZSBmb3IgY2FjaGluZyB0aGUgY29tcHV0YXRpb25cbiAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpXG4gIH1cbiAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdFxufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7IC8vIGNyZWF0ZXMgYW4gb2Zmc2NyZWVuIHRlc3QgZWxlbWVudCwgdGhlbiByZW1vdmVzIGl0XG4gIGxldCBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAtMTAwMCxcbiAgICBsZWZ0OiAwLFxuICAgIGJvcmRlcjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICBkaXJlY3Rpb246ICdydGwnLFxuICB9KVxuICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2PidcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyRWwpXG4gIGxldCBpbm5lckVsID0gb3V0ZXJFbC5maXJzdENoaWxkIGFzIEhUTUxFbGVtZW50XG4gIGxldCByZXMgPSBpbm5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgPiBvdXRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcblxuICByZW1vdmVFbGVtZW50KG91dGVyRWwpXG4gIHJldHVybiByZXNcbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgU2Nyb2xsYmFyV2lkdGhzIHtcbiAgeDogbnVtYmVyXG4gIHk6IG51bWJlciAvLyBUT0RPOiByZW5hbWUgdG8gdmVydGljYWwuIGxlc3MgY29uZnVzaW5nIHdoZW4gZGVhbGluZyB3aXRoIHdpZHRoL2hlaWdodCB2ZXJiYWdlXG59XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGhzOiBTY3JvbGxiYXJXaWR0aHMgfCB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocygpIHsgLy8gVE9ETzogd2F5IHRvIGZvcmNlIHJlY29tcHV0ZT9cbiAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgX3Njcm9sbGJhcldpZHRocyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKVxuICB9XG5cbiAgcmV0dXJuIF9zY3JvbGxiYXJXaWR0aHNcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpOiBTY3JvbGxiYXJXaWR0aHMge1xuICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnXG4gIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICBlbC5zdHlsZS50b3AgPSAnLTk5OTlweCdcbiAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4J1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKVxuICBsZXQgcmVzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKVxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKVxuICByZXR1cm4gcmVzXG59XG5cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWw6IEhUTUxFbGVtZW50KTogU2Nyb2xsYmFyV2lkdGhzIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQsXG4gICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgfVxufVxuIiwiaW1wb3J0IHsgaW50ZXJzZWN0UmVjdHMsIFJlY3QgfSBmcm9tICcuL2dlb20nXG5pbXBvcnQgeyBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCB9IGZyb20gJy4vc2Nyb2xsYmFyLXNpZGUnXG5pbXBvcnQgeyBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwgfSBmcm9tICcuL3Njcm9sbGJhci13aWR0aCdcblxuZXhwb3J0IGludGVyZmFjZSBFZGdlSW5mbyB7XG4gIGJvcmRlckxlZnQ6IG51bWJlclxuICBib3JkZXJSaWdodDogbnVtYmVyXG4gIGJvcmRlclRvcDogbnVtYmVyXG4gIGJvcmRlckJvdHRvbTogbnVtYmVyXG4gIHNjcm9sbGJhckxlZnQ6IG51bWJlclxuICBzY3JvbGxiYXJSaWdodDogbnVtYmVyXG4gIHNjcm9sbGJhckJvdHRvbTogbnVtYmVyXG4gIHBhZGRpbmdMZWZ0PzogbnVtYmVyXG4gIHBhZGRpbmdSaWdodD86IG51bWJlclxuICBwYWRkaW5nVG9wPzogbnVtYmVyXG4gIHBhZGRpbmdCb3R0b20/OiBudW1iZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbDogSFRNTEVsZW1lbnQsIGdldFBhZGRpbmcgPSBmYWxzZSk6IEVkZ2VJbmZvIHsgLy8gY2FjaGUgc29tZWhvdz9cbiAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClcbiAgbGV0IGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDBcbiAgbGV0IGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMFxuICBsZXQgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDBcbiAgbGV0IGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwXG4gIGxldCBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpIC8vIGluY2x1ZGVzIGJvcmRlciFcbiAgbGV0IHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0XG4gIGxldCBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbVxuXG4gIGxldCByZXM6IEVkZ2VJbmZvID0ge1xuICAgIGJvcmRlckxlZnQsXG4gICAgYm9yZGVyUmlnaHQsXG4gICAgYm9yZGVyVG9wLFxuICAgIGJvcmRlckJvdHRvbSxcbiAgICBzY3JvbGxiYXJCb3R0b20sXG4gICAgc2Nyb2xsYmFyTGVmdDogMCxcbiAgICBzY3JvbGxiYXJSaWdodDogMCxcbiAgfVxuXG4gIGlmIChnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpICYmIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XG4gICAgcmVzLnNjcm9sbGJhckxlZnQgPSBzY3JvbGxiYXJMZWZ0UmlnaHRcbiAgfSBlbHNlIHtcbiAgICByZXMuc2Nyb2xsYmFyUmlnaHQgPSBzY3JvbGxiYXJMZWZ0UmlnaHRcbiAgfVxuXG4gIGlmIChnZXRQYWRkaW5nKSB7XG4gICAgcmVzLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCwgMTApIHx8IDBcbiAgICByZXMucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQsIDEwKSB8fCAwXG4gICAgcmVzLnBhZGRpbmdUb3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwXG4gICAgcmVzLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKSB8fCAwXG4gIH1cblxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW5uZXJSZWN0KGVsLCBnb1dpdGhpblBhZGRpbmcgPSBmYWxzZSwgZG9Gcm9tV2luZG93Vmlld3BvcnQ/OiBib29sZWFuKSB7XG4gIGxldCBvdXRlclJlY3QgPSBkb0Zyb21XaW5kb3dWaWV3cG9ydCA/IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogY29tcHV0ZVJlY3QoZWwpXG4gIGxldCBlZGdlcyA9IGNvbXB1dGVFZGdlcyhlbCwgZ29XaXRoaW5QYWRkaW5nKVxuICBsZXQgcmVzID0ge1xuICAgIGxlZnQ6IG91dGVyUmVjdC5sZWZ0ICsgZWRnZXMuYm9yZGVyTGVmdCArIGVkZ2VzLnNjcm9sbGJhckxlZnQsXG4gICAgcmlnaHQ6IG91dGVyUmVjdC5yaWdodCAtIGVkZ2VzLmJvcmRlclJpZ2h0IC0gZWRnZXMuc2Nyb2xsYmFyUmlnaHQsXG4gICAgdG9wOiBvdXRlclJlY3QudG9wICsgZWRnZXMuYm9yZGVyVG9wLFxuICAgIGJvdHRvbTogb3V0ZXJSZWN0LmJvdHRvbSAtIGVkZ2VzLmJvcmRlckJvdHRvbSAtIGVkZ2VzLnNjcm9sbGJhckJvdHRvbSxcbiAgfVxuXG4gIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICByZXMubGVmdCArPSBlZGdlcy5wYWRkaW5nTGVmdFxuICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHRcbiAgICByZXMudG9wICs9IGVkZ2VzLnBhZGRpbmdUb3BcbiAgICByZXMuYm90dG9tIC09IGVkZ2VzLnBhZGRpbmdCb3R0b21cbiAgfVxuXG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVSZWN0KGVsKTogUmVjdCB7XG4gIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbDogSFRNTEVsZW1lbnQpOiBSZWN0IHwgbnVsbCB7XG4gIGxldCBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpXG4gIGxldCByZWN0OiBSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICBmb3IgKGxldCBjbGlwcGluZ1BhcmVudCBvZiBjbGlwcGluZ1BhcmVudHMpIHtcbiAgICBsZXQgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmVjdHMocmVjdCwgY2xpcHBpbmdQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXG4gICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgcmVjdCA9IGludGVyc2VjdGlvblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWN0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyhlbDogSFRNTEVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArIGNvbXB1dGVWTWFyZ2lucyhlbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVWTWFyZ2lucyhlbDogSFRNTEVsZW1lbnQpIHtcbiAgbGV0IGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpXG5cbiAgcmV0dXJuIHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpblRvcCwgMTApICtcbiAgICBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Cb3R0b20sIDEwKVxufVxuXG4vLyBkb2VzIG5vdCByZXR1cm4gd2luZG93XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50W10ge1xuICBsZXQgcGFyZW50czogSFRNTEVsZW1lbnRbXSA9IFtdXG5cbiAgd2hpbGUgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHsgLy8gd2lsbCBzdG9wIHdoZW4gZ2V0cyB0byBkb2N1bWVudCBvciBudWxsXG4gICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbClcblxuICAgIGlmIChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGlmICgoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WSArIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgcGFyZW50cy5wdXNoKGVsKVxuICAgIH1cblxuICAgIGVsID0gZWwucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgcmV0dXJuIHBhcmVudHNcbn1cbiIsIi8vIGdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyBhIHJlc3VsdCBhc3luY2hyb25vdXNseS5cbi8vIHRoZSBmdW5jdGlvbiBjYW4gZWl0aGVyIGNhbGwgcGFzc2VkLWluIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgY2FsbGJhY2tzLFxuLy8gb3IgaXQgY2FuIHJldHVybiBhIHByb21pc2UuXG4vLyBpZiB5b3UgbmVlZCB0byBwYXNzIGFkZGl0aW9uYWwgcGFyYW1zIHRvIGZ1bmMsIGJpbmQgdGhlbSBmaXJzdC5cbmV4cG9ydCBmdW5jdGlvbiB1bnByb21pc2lmeShmdW5jLCBzdWNjZXNzLCBmYWlsdXJlPykge1xuICAvLyBndWFyZCBhZ2FpbnN0IHN1Y2Nlc3MvZmFpbHVyZSBjYWxsYmFja3MgYmVpbmcgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXG4gIC8vIGFuZCBndWFyZCBhZ2FpbnN0IGEgcHJvbWlzZSBBTkQgY2FsbGJhY2sgYmVpbmcgdXNlZCB0b2dldGhlci5cbiAgbGV0IGlzUmVzb2x2ZWQgPSBmYWxzZVxuICBsZXQgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lc1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWVcbiAgICAgIHN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIH1cbiAgfVxuICBsZXQgd3JhcHBlZEZhaWx1cmUgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZnVuYy1uYW1lc1xuICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgaXNSZXNvbHZlZCA9IHRydWVcbiAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgIGZhaWx1cmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCByZXMgPSBmdW5jKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSlcbiAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXMudGhlbih3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpXG4gIH1cbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlckZ1bmNUeXBlSGFzaCB7XG4gIFtldmVudE5hbWU6IHN0cmluZ106ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55IC8vIHdpdGggYWxsIHByb3BlcnRpZXMgcmVxdWlyZWRcbn1cblxuZXhwb3J0IGNsYXNzIEVtaXR0ZXI8SGFuZGxlckZ1bmNzIGV4dGVuZHMgSGFuZGxlckZ1bmNUeXBlSGFzaD4ge1xuICBwcml2YXRlIGhhbmRsZXJzOiB7IFtQcm9wIGluIGtleW9mIEhhbmRsZXJGdW5jc10/OiBIYW5kbGVyRnVuY3NbUHJvcF1bXSB9ID0ge31cblxuICBwcml2YXRlIG9wdGlvbnM6IFBhcnRpYWw8SGFuZGxlckZ1bmNzPlxuXG4gIHByaXZhdGUgdGhpc0NvbnRleHQ6IGFueSA9IG51bGxcblxuICBzZXRUaGlzQ29udGV4dCh0aGlzQ29udGV4dCkge1xuICAgIHRoaXMudGhpc0NvbnRleHQgPSB0aGlzQ29udGV4dFxuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQYXJ0aWFsPEhhbmRsZXJGdW5jcz4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIH1cblxuICBvbjxQcm9wIGV4dGVuZHMga2V5b2YgSGFuZGxlckZ1bmNzPih0eXBlOiBQcm9wLCBoYW5kbGVyOiBIYW5kbGVyRnVuY3NbUHJvcF0pIHtcbiAgICBhZGRUb0hhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcilcbiAgfVxuXG4gIG9mZjxQcm9wIGV4dGVuZHMga2V5b2YgSGFuZGxlckZ1bmNzPih0eXBlOiBQcm9wLCBoYW5kbGVyPzogSGFuZGxlckZ1bmNzW1Byb3BdKSB7XG4gICAgcmVtb3ZlRnJvbUhhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcilcbiAgfVxuXG4gIHRyaWdnZXI8UHJvcCBleHRlbmRzIGtleW9mIEhhbmRsZXJGdW5jcz4odHlwZTogUHJvcCwgLi4uYXJnczogUGFyYW1ldGVyczxIYW5kbGVyRnVuY3NbUHJvcF0+KSB7XG4gICAgbGV0IGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdXG4gICAgbGV0IG9wdGlvbkhhbmRsZXIgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zW3R5cGVdXG4gICAgbGV0IGhhbmRsZXJzID0gW10uY29uY2F0KG9wdGlvbkhhbmRsZXIgfHwgW10sIGF0dGFjaGVkSGFuZGxlcnMpXG5cbiAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICBoYW5kbGVyLmFwcGx5KHRoaXMudGhpc0NvbnRleHQsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgaGFzSGFuZGxlcnModHlwZToga2V5b2YgSGFuZGxlckZ1bmNzKSB7XG4gICAgcmV0dXJuICh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVG9IYXNoKGhhc2gsIHR5cGUsIGhhbmRsZXIpIHtcbiAgKGhhc2hbdHlwZV0gfHwgKGhhc2hbdHlwZV0gPSBbXSkpXG4gICAgLnB1c2goaGFuZGxlcilcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbUhhc2goaGFzaCwgdHlwZSwgaGFuZGxlcj8pIHtcbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBpZiAoaGFzaFt0eXBlXSkge1xuICAgICAgaGFzaFt0eXBlXSA9IGhhc2hbdHlwZV0uZmlsdGVyKChmdW5jKSA9PiBmdW5jICE9PSBoYW5kbGVyKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgaGFzaFt0eXBlXSAvLyByZW1vdmUgYWxsIGhhbmRsZXIgZnVuY3MgZm9yIHRoaXMgdHlwZVxuICB9XG59XG4iLCIvKlxuUmVjb3JkcyBvZmZzZXQgaW5mb3JtYXRpb24gZm9yIGEgc2V0IG9mIGVsZW1lbnRzLCByZWxhdGl2ZSB0byBhbiBvcmlnaW4gZWxlbWVudC5cbkNhbiByZWNvcmQgdGhlIGxlZnQvcmlnaHQgT1IgdGhlIHRvcC9ib3R0b20gT1IgYm90aC5cblByb3ZpZGVzIG1ldGhvZHMgZm9yIHF1ZXJ5aW5nIHRoZSBjYWNoZSBieSBwb3NpdGlvbi5cbiovXG5leHBvcnQgY2xhc3MgUG9zaXRpb25DYWNoZSB7XG4gIGVsczogSFRNTEVsZW1lbnRbXSAvLyBhc3N1bWVkIHRvIGJlIHNpYmxpbmdzXG4gIG9yaWdpbkNsaWVudFJlY3Q6IENsaWVudFJlY3RcblxuICAvLyBhcnJheXMgb2YgY29vcmRpbmF0ZXMgKGZyb20gdG9wbGVmdCBvZiBvcmlnaW5FbClcbiAgLy8gY2FsbGVyIGNhbiBhY2Nlc3MgdGhlc2UgZGlyZWN0bHlcbiAgbGVmdHM6IGFueVxuICByaWdodHM6IGFueVxuICB0b3BzOiBhbnlcbiAgYm90dG9tczogYW55XG5cbiAgY29uc3RydWN0b3Iob3JpZ2luRWw6IEhUTUxFbGVtZW50LCBlbHM6IEhUTUxFbGVtZW50W10sIGlzSG9yaXpvbnRhbDogYm9vbGVhbiwgaXNWZXJ0aWNhbDogYm9vbGVhbikge1xuICAgIHRoaXMuZWxzID0gZWxzXG5cbiAgICBsZXQgb3JpZ2luQ2xpZW50UmVjdCA9IHRoaXMub3JpZ2luQ2xpZW50UmVjdCA9IG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIC8vIHJlbGF0aXZlIHRvIHZpZXdwb3J0IHRvcC1sZWZ0XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRSZWN0LmxlZnQpXG4gICAgfVxuXG4gICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscyhvcmlnaW5DbGllbnRSZWN0LnRvcClcbiAgICB9XG4gIH1cblxuICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgYnVpbGRFbEhvcml6b250YWxzKG9yaWdpbkNsaWVudExlZnQ6IG51bWJlcikge1xuICAgIGxldCBsZWZ0cyA9IFtdXG4gICAgbGV0IHJpZ2h0cyA9IFtdXG5cbiAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgbGVmdHMucHVzaChyZWN0LmxlZnQgLSBvcmlnaW5DbGllbnRMZWZ0KVxuICAgICAgcmlnaHRzLnB1c2gocmVjdC5yaWdodCAtIG9yaWdpbkNsaWVudExlZnQpXG4gICAgfVxuXG4gICAgdGhpcy5sZWZ0cyA9IGxlZnRzXG4gICAgdGhpcy5yaWdodHMgPSByaWdodHNcbiAgfVxuXG4gIC8vIFBvcHVsYXRlcyB0aGUgdG9wL2JvdHRvbSBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICBidWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFRvcDogbnVtYmVyKSB7XG4gICAgbGV0IHRvcHMgPSBbXVxuICAgIGxldCBib3R0b21zID0gW11cblxuICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XG4gICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB0b3BzLnB1c2gocmVjdC50b3AgLSBvcmlnaW5DbGllbnRUb3ApXG4gICAgICBib3R0b21zLnB1c2gocmVjdC5ib3R0b20gLSBvcmlnaW5DbGllbnRUb3ApXG4gICAgfVxuXG4gICAgdGhpcy50b3BzID0gdG9wc1xuICAgIHRoaXMuYm90dG9tcyA9IGJvdHRvbXNcbiAgfVxuXG4gIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxuICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gIGxlZnRUb0luZGV4KGxlZnRQb3NpdGlvbjogbnVtYmVyKSB7XG4gICAgbGV0IHsgbGVmdHMsIHJpZ2h0cyB9ID0gdGhpc1xuICAgIGxldCBsZW4gPSBsZWZ0cy5sZW5ndGhcbiAgICBsZXQgaVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAobGVmdFBvc2l0aW9uID49IGxlZnRzW2ldICYmIGxlZnRQb3NpdGlvbiA8IHJpZ2h0c1tpXSkge1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQgLy8gVE9ETzogYmV0dGVyXG4gIH1cblxuICAvLyBHaXZlbiBhIHRvcCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgdG9wKSwgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsIHRoYXQgaXQgdmVydGljYWxseSBpbnRlcnNlY3RzLlxuICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gIHRvcFRvSW5kZXgodG9wUG9zaXRpb246IG51bWJlcikge1xuICAgIGxldCB7IHRvcHMsIGJvdHRvbXMgfSA9IHRoaXNcbiAgICBsZXQgbGVuID0gdG9wcy5sZW5ndGhcbiAgICBsZXQgaVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodG9wUG9zaXRpb24gPj0gdG9wc1tpXSAmJiB0b3BQb3NpdGlvbiA8IGJvdHRvbXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkIC8vIFRPRE86IGJldHRlclxuICB9XG5cbiAgLy8gR2V0cyB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gIGdldFdpZHRoKGxlZnRJbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF1cbiAgfVxuXG4gIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgZ2V0SGVpZ2h0KHRvcEluZGV4OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMudG9wc1t0b3BJbmRleF1cbiAgfVxufVxuIiwiLyogZXNsaW50IG1heC1jbGFzc2VzLXBlci1maWxlOiBcIm9mZlwiICovXG5cbi8qXG5BbiBvYmplY3QgZm9yIGdldHRpbmcvc2V0dGluZyBzY3JvbGwtcmVsYXRlZCBpbmZvcm1hdGlvbiBmb3IgYW4gZWxlbWVudC5cbkludGVybmFsbHksIHRoaXMgaXMgZG9uZSB2ZXJ5IGRpZmZlcmVudGx5IGZvciB3aW5kb3cgdmVyc3VzIERPTSBlbGVtZW50LFxuc28gdGhpcyBvYmplY3Qgc2VydmVzIGFzIGEgY29tbW9uIGludGVyZmFjZS5cbiovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU2Nyb2xsQ29udHJvbGxlciB7XG4gIGFic3RyYWN0IGdldFNjcm9sbFRvcCgpOiBudW1iZXJcbiAgYWJzdHJhY3QgZ2V0U2Nyb2xsTGVmdCgpOiBudW1iZXJcbiAgYWJzdHJhY3Qgc2V0U2Nyb2xsVG9wKHRvcDogbnVtYmVyKTogdm9pZFxuICBhYnN0cmFjdCBzZXRTY3JvbGxMZWZ0KGxlZnQ6IG51bWJlcik6IHZvaWRcbiAgYWJzdHJhY3QgZ2V0Q2xpZW50V2lkdGgoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldENsaWVudEhlaWdodCgpOiBudW1iZXJcbiAgYWJzdHJhY3QgZ2V0U2Nyb2xsV2lkdGgoKTogbnVtYmVyXG4gIGFic3RyYWN0IGdldFNjcm9sbEhlaWdodCgpOiBudW1iZXJcblxuICBnZXRNYXhTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCkgLSB0aGlzLmdldENsaWVudEhlaWdodCgpXG4gIH1cblxuICBnZXRNYXhTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFdpZHRoKCkgLSB0aGlzLmdldENsaWVudFdpZHRoKClcbiAgfVxuXG4gIGNhblNjcm9sbFZlcnRpY2FsbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwXG4gIH1cblxuICBjYW5TY3JvbGxIb3Jpem9udGFsbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpID4gMFxuICB9XG5cbiAgY2FuU2Nyb2xsVXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPiAwXG4gIH1cblxuICBjYW5TY3JvbGxEb3duKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKVxuICB9XG5cbiAgY2FuU2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPiAwXG4gIH1cblxuICBjYW5TY3JvbGxSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPCB0aGlzLmdldE1heFNjcm9sbExlZnQoKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICBlbDogSFRNTEVsZW1lbnRcblxuICBjb25zdHJ1Y3RvcihlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5lbCA9IGVsXG4gIH1cblxuICBnZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsVG9wXG4gIH1cblxuICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbExlZnRcbiAgfVxuXG4gIHNldFNjcm9sbFRvcCh0b3A6IG51bWJlcikge1xuICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wXG4gIH1cblxuICBzZXRTY3JvbGxMZWZ0KGxlZnQ6IG51bWJlcikge1xuICAgIHRoaXMuZWwuc2Nyb2xsTGVmdCA9IGxlZnRcbiAgfVxuXG4gIGdldFNjcm9sbFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFdpZHRoXG4gIH1cblxuICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsSGVpZ2h0XG4gIH1cblxuICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWwuY2xpZW50SGVpZ2h0XG4gIH1cblxuICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRXaWR0aFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXaW5kb3dTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gIGdldFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0XG4gIH1cblxuICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXRcbiAgfVxuXG4gIHNldFNjcm9sbFRvcChuOiBudW1iZXIpIHtcbiAgICB3aW5kb3cuc2Nyb2xsKHdpbmRvdy5wYWdlWE9mZnNldCwgbilcbiAgfVxuXG4gIHNldFNjcm9sbExlZnQobjogbnVtYmVyKSB7XG4gICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cucGFnZVlPZmZzZXQpXG4gIH1cblxuICBnZXRTY3JvbGxXaWR0aCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoXG4gIH1cblxuICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgfVxuXG4gIGdldENsaWVudEhlaWdodCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICB9XG5cbiAgZ2V0Q2xpZW50V2lkdGgoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICB9XG59XG4iLCJpbXBvcnQgeyBDYWxlbmRhck9wdGlvbnNSZWZpbmVkIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGNsYXNzIFRoZW1lIHtcbiAgLy8gc2V0dGluZ3MuIGRlZmF1bHQgdmFsdWVzIGFyZSBzZXQgYWZ0ZXIgdGhlIGNsYXNzXG4gIGNsYXNzZXM6IGFueVxuICBpY29uQ2xhc3NlczogYW55XG4gIHJ0bEljb25DbGFzc2VzOiBhbnlcbiAgYmFzZUljb25DbGFzczogc3RyaW5nIC8vIGNsYXNzTmFtZSB0aGF0IEFMTCBpY29uIGVsZW1lbnRzIGZvciB0aGlzIHRoZW1lIHNob3VsZCBoYXZlXG4gIGljb25PdmVycmlkZU9wdGlvbjogYW55IC8vIHRoZSBuYW1lIG9mIHRoZSBzZXR0aW5nIHRvIHVzZSBmb3IgaWNvbnMuIHRoZSBzdWJjbGFzcyBtdXN0IHNldCB0aGlzLlxuICBpY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb246IGFueSAvLyB0aGUgbmFtZSBvZiB0aGUgc2V0dGluZywgKndpdGhpbiogZWFjaCBjdXN0b21CdXR0b25zIG9iamVjdCwgdG8gdXNlIGZvciBpY29uc1xuICBpY29uT3ZlcnJpZGVQcmVmaXg6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGNhbGVuZGFyT3B0aW9uczogQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCkge1xuICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUoXG4gICAgICAgIGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0sXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgc2V0SWNvbk92ZXJyaWRlKGljb25PdmVycmlkZUhhc2gpIHtcbiAgICBsZXQgaWNvbkNsYXNzZXNDb3B5XG4gICAgbGV0IGJ1dHRvbk5hbWVcblxuICAgIGlmICh0eXBlb2YgaWNvbk92ZXJyaWRlSGFzaCA9PT0gJ29iamVjdCcgJiYgaWNvbk92ZXJyaWRlSGFzaCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgIGljb25DbGFzc2VzQ29weSA9IHsgLi4udGhpcy5pY29uQ2xhc3NlcyB9XG5cbiAgICAgIGZvciAoYnV0dG9uTmFtZSBpbiBpY29uT3ZlcnJpZGVIYXNoKSB7XG4gICAgICAgIGljb25DbGFzc2VzQ29weVtidXR0b25OYW1lXSA9IHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoXG4gICAgICAgICAgaWNvbk92ZXJyaWRlSGFzaFtidXR0b25OYW1lXSxcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5XG4gICAgfSBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9XG4gICAgfVxuICB9XG5cbiAgYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKSB7XG4gICAgbGV0IHByZWZpeCA9IHRoaXMuaWNvbk92ZXJyaWRlUHJlZml4XG5cbiAgICBpZiAocHJlZml4ICYmIGNsYXNzTmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHsgLy8gaWYgbm90IGFscmVhZHkgcHJlc2VudFxuICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lXG4gICAgfVxuXG4gICAgcmV0dXJuIGNsYXNzTmFtZVxuICB9XG5cbiAgZ2V0Q2xhc3Moa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3Nlc1trZXldIHx8ICcnXG4gIH1cblxuICBnZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGw/OiBib29sZWFuKSB7XG4gICAgbGV0IGNsYXNzTmFtZVxuXG4gICAgaWYgKGlzUnRsICYmIHRoaXMucnRsSWNvbkNsYXNzZXMpIHtcbiAgICAgIGNsYXNzTmFtZSA9IHRoaXMucnRsSWNvbkNsYXNzZXNbYnV0dG9uTmFtZV0gfHwgdGhpcy5pY29uQ2xhc3Nlc1tidXR0b25OYW1lXVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdXG4gICAgfVxuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZUljb25DbGFzc30gJHtjbGFzc05hbWV9YFxuICAgIH1cblxuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZVxuXG4gICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XG4gICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl1cblxuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5iYXNlSWNvbkNsYXNzfSAke3RoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKX1gXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fVxuVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge31cblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJydcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJ1xuXG5leHBvcnQgdHlwZSBUaGVtZUNsYXNzID0geyBuZXcoY2FsZW5kYXJPcHRpb25zOiBhbnkpOiBUaGVtZSB9XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi9jb21tb24vRW1pdHRlcidcbmltcG9ydCB7IENhbGVuZGFyTGlzdGVuZXJzIH0gZnJvbSAnLi9vcHRpb25zJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbFJlcXVlc3Qge1xuICB0aW1lPzogRHVyYXRpb25cbiAgW290aGVyUHJvcDogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIFNjcm9sbFJlcXVlc3RIYW5kbGVyID0gKHJlcXVlc3Q6IFNjcm9sbFJlcXVlc3QpID0+IGJvb2xlYW5cblxuZXhwb3J0IGNsYXNzIFNjcm9sbFJlc3BvbmRlciB7XG4gIHF1ZXVlZFJlcXVlc3Q6IFNjcm9sbFJlcXVlc3RcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGV4ZWNGdW5jOiBTY3JvbGxSZXF1ZXN0SGFuZGxlcixcbiAgICBwcml2YXRlIGVtaXR0ZXI6IEVtaXR0ZXI8Q2FsZW5kYXJMaXN0ZW5lcnM+LFxuICAgIHByaXZhdGUgc2Nyb2xsVGltZTogRHVyYXRpb24sXG4gICAgcHJpdmF0ZSBzY3JvbGxUaW1lUmVzZXQ6IGJvb2xlYW4sXG4gICkge1xuICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KVxuICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKVxuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KVxuICB9XG5cbiAgdXBkYXRlKGlzRGF0ZXNOZXc6IGJvb2xlYW4pIHtcbiAgICBpZiAoaXNEYXRlc05ldyAmJiB0aGlzLnNjcm9sbFRpbWVSZXNldCkge1xuICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpIC8vIHdpbGwgZHJhaW5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmFpbigpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaXJlSW5pdGlhbFNjcm9sbCgpIHtcbiAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3Qoe1xuICAgICAgdGltZTogdGhpcy5zY3JvbGxUaW1lLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVNjcm9sbFJlcXVlc3QgPSAocmVxdWVzdDogU2Nyb2xsUmVxdWVzdCkgPT4ge1xuICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IF9fYXNzaWduKHt9LCB0aGlzLnF1ZXVlZFJlcXVlc3QgfHwge30sIHJlcXVlc3QpXG4gICAgdGhpcy5kcmFpbigpXG4gIH1cblxuICBwcml2YXRlIGRyYWluKCkge1xuICAgIGlmICh0aGlzLnF1ZXVlZFJlcXVlc3QgJiYgdGhpcy5leGVjRnVuYyh0aGlzLnF1ZXVlZFJlcXVlc3QpKSB7XG4gICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBudWxsXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4vQ2FsZW5kYXJBcGknXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuaW1wb3J0IHsgVGhlbWUgfSBmcm9tICcuL3RoZW1lL1RoZW1lJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBQbHVnaW5Ib29rcyB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBDb250ZXh0IH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgU2Nyb2xsUmVzcG9uZGVyLCBTY3JvbGxSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vU2Nyb2xsUmVzcG9uZGVyJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSBmcm9tICcuL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgVmlld1NwZWMgfSBmcm9tICcuL3N0cnVjdHMvdmlldy1zcGVjJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9yZWR1Y2Vycy9kYXRhLXR5cGVzJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9yZWR1Y2Vycy9BY3Rpb24nXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi9jb21tb24vRW1pdHRlcidcbmltcG9ydCB7IEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2ludGVyYWN0aW9uJ1xuaW1wb3J0IHsgRGF0ZUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgVmlld09wdGlvbnNSZWZpbmVkLCBDYWxlbmRhckxpc3RlbmVycyB9IGZyb20gJy4vb3B0aW9ucydcblxuZXhwb3J0IGNvbnN0IFZpZXdDb250ZXh0VHlwZTogQ29udGV4dDxhbnk+ID0gY3JlYXRlQ29udGV4dDxWaWV3Q29udGV4dD4oe30gYXMgYW55KSAvLyBmb3IgQ29tcG9uZW50c1xuZXhwb3J0IHR5cGUgUmVzaXplSGFuZGxlciA9IChmb3JjZTogYm9vbGVhbikgPT4gdm9pZFxuXG4vKlxuaXQncyBpbXBvcnRhbnQgdGhhdCBWaWV3Q29udGV4dCBleHRlbmRzIENhbGVuZGFyQ29udGV4dCBzbyB0aGF0IGNvbXBvbmVudHMgdGhhdCBzdWJzY3JpYmUgdG8gVmlld0NvbnRleHRcbmNhbiBwYXNzIGluIHRoZWlyIFZpZXdDb250ZXh0IHRvIHV0aWwgZnVuY3Rpb25zIHRoYXQgYWNjZXB0IENhbGVuZGFyQ29udGV4dC5cbiovXG5leHBvcnQgaW50ZXJmYWNlIFZpZXdDb250ZXh0IGV4dGVuZHMgQ2FsZW5kYXJDb250ZXh0IHtcbiAgb3B0aW9uczogVmlld09wdGlvbnNSZWZpbmVkIC8vIG1vcmUgc3BlY2lmaWMgdGhhbiBCYXNlT3B0aW9uc1JlZmluZWRcbiAgdGhlbWU6IFRoZW1lXG4gIGlzUnRsOiBib29sZWFuXG4gIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBEYXRlUHJvZmlsZUdlbmVyYXRvclxuICB2aWV3U3BlYzogVmlld1NwZWNcbiAgdmlld0FwaTogVmlld0FwaVxuICBhZGRSZXNpemVIYW5kbGVyOiAoaGFuZGxlcjogUmVzaXplSGFuZGxlcikgPT4gdm9pZFxuICByZW1vdmVSZXNpemVIYW5kbGVyOiAoaGFuZGxlcjogUmVzaXplSGFuZGxlcikgPT4gdm9pZFxuICBjcmVhdGVTY3JvbGxSZXNwb25kZXI6IChleGVjRnVuYzogU2Nyb2xsUmVxdWVzdEhhbmRsZXIpID0+IFNjcm9sbFJlc3BvbmRlclxuICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4sIHNldHRpbmdzSW5wdXQ6IEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCkgPT4gdm9pZFxuICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQ6IChjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55PikgPT4gdm9pZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWaWV3Q29udGV4dChcbiAgdmlld1NwZWM6IFZpZXdTcGVjLFxuICB2aWV3QXBpOiBWaWV3QXBpLFxuICB2aWV3T3B0aW9uczogVmlld09wdGlvbnNSZWZpbmVkLFxuICBkYXRlUHJvZmlsZUdlbmVyYXRvcjogRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gIGRhdGVFbnY6IERhdGVFbnYsXG4gIHRoZW1lOiBUaGVtZSxcbiAgcGx1Z2luSG9va3M6IFBsdWdpbkhvb2tzLFxuICBkaXNwYXRjaDogKGFjdGlvbjogQWN0aW9uKSA9PiB2b2lkLFxuICBnZXRDdXJyZW50RGF0YTogKCkgPT4gQ2FsZW5kYXJEYXRhLFxuICBlbWl0dGVyOiBFbWl0dGVyPENhbGVuZGFyTGlzdGVuZXJzPixcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpLFxuICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4sIHNldHRpbmdzSW5wdXQ6IEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCkgPT4gdm9pZCxcbiAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4pID0+IHZvaWQsXG4pOiBWaWV3Q29udGV4dCB7XG4gIHJldHVybiB7XG4gICAgZGF0ZUVudixcbiAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICBwbHVnaW5Ib29rcyxcbiAgICBlbWl0dGVyLFxuICAgIGRpc3BhdGNoLFxuICAgIGdldEN1cnJlbnREYXRhLFxuICAgIGNhbGVuZGFyQXBpLFxuICAgIHZpZXdTcGVjLFxuICAgIHZpZXdBcGksXG4gICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgdGhlbWUsXG4gICAgaXNSdGw6IHZpZXdPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcsXG4gICAgYWRkUmVzaXplSGFuZGxlcihoYW5kbGVyOiBSZXNpemVIYW5kbGVyKSB7XG4gICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcilcbiAgICB9LFxuICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoaGFuZGxlcjogUmVzaXplSGFuZGxlcikge1xuICAgICAgZW1pdHRlci5vZmYoJ19yZXNpemUnLCBoYW5kbGVyKVxuICAgIH0sXG4gICAgY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jOiBTY3JvbGxSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXNwb25kZXIoXG4gICAgICAgIGV4ZWNGdW5jLFxuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBjcmVhdGVEdXJhdGlvbih2aWV3T3B0aW9ucy5zY3JvbGxUaW1lKSxcbiAgICAgICAgdmlld09wdGlvbnMuc2Nyb2xsVGltZVJlc2V0LFxuICAgICAgKVxuICAgIH0sXG4gICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gIH1cbn1cbiIsIi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG5cbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBDb21wb25lbnQsIFJlZiB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IFZpZXdDb250ZXh0VHlwZSwgVmlld0NvbnRleHQgfSBmcm9tICcuL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgY29tcGFyZU9ianMsIEVxdWFsaXR5RnVuY3MsIGdldFVuZXF1YWxQcm9wcyB9IGZyb20gJy4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi9vcHRpb25zJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUHVyZUNvbXBvbmVudDxQcm9wcz1EaWN0aW9uYXJ5LCBTdGF0ZT1EaWN0aW9uYXJ5PiBleHRlbmRzIENvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIGFkZFByb3BzRXF1YWxpdHkgPSBhZGRQcm9wc0VxdWFsaXR5XG4gIHN0YXRpYyBhZGRTdGF0ZUVxdWFsaXR5ID0gYWRkU3RhdGVFcXVhbGl0eVxuICBzdGF0aWMgY29udGV4dFR5cGU6IGFueSA9IFZpZXdDb250ZXh0VHlwZVxuXG4gIGNvbnRleHQ6IFZpZXdDb250ZXh0XG4gIHByb3BFcXVhbGl0eTogRXF1YWxpdHlGdW5jczxQcm9wcz5cbiAgc3RhdGVFcXVhbGl0eTogRXF1YWxpdHlGdW5jczxTdGF0ZT5cblxuICBkZWJ1ZzogYm9vbGVhblxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHM6IFByb3BzLCBuZXh0U3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhnZXRVbmVxdWFsUHJvcHMobmV4dFByb3BzLCB0aGlzLnByb3BzKSwgZ2V0VW5lcXVhbFByb3BzKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkpXG4gICAgfVxuXG4gICAgcmV0dXJuICFjb21wYXJlT2Jqcyh0aGlzLnByb3BzLCBuZXh0UHJvcHMsIHRoaXMucHJvcEVxdWFsaXR5KSB8fFxuICAgICAgIWNvbXBhcmVPYmpzKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSwgdGhpcy5zdGF0ZUVxdWFsaXR5KVxuICB9XG59XG5cblB1cmVDb21wb25lbnQucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IHt9XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0ge31cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDb21wb25lbnQ8UHJvcHM9RGljdGlvbmFyeSwgU3RhdGU9RGljdGlvbmFyeT4gZXh0ZW5kcyBQdXJlQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgY29udGV4dFR5cGU6IGFueSA9IFZpZXdDb250ZXh0VHlwZVxuXG4gIGNvbnRleHQ6IFZpZXdDb250ZXh0XG59XG5cbmZ1bmN0aW9uIGFkZFByb3BzRXF1YWxpdHkodGhpczogeyBwcm90b3R5cGU6IHsgcHJvcEVxdWFsaXR5OiBhbnkgfSB9LCBwcm9wRXF1YWxpdHkpIHtcbiAgbGV0IGhhc2ggPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSlcbiAgX19hc3NpZ24oaGFzaCwgcHJvcEVxdWFsaXR5KVxuICB0aGlzLnByb3RvdHlwZS5wcm9wRXF1YWxpdHkgPSBoYXNoXG59XG5cbmZ1bmN0aW9uIGFkZFN0YXRlRXF1YWxpdHkodGhpczogeyBwcm90b3R5cGU6IHsgc3RhdGVFcXVhbGl0eTogYW55IH0gfSwgc3RhdGVFcXVhbGl0eSkge1xuICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSlcbiAgX19hc3NpZ24oaGFzaCwgc3RhdGVFcXVhbGl0eSlcbiAgdGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IGhhc2hcbn1cblxuLy8gdXNlIG90aGVyIG9uZVxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlZjxSZWZUeXBlPihyZWY6IFJlZjxSZWZUeXBlPiB8IHZvaWQsIGN1cnJlbnQ6IFJlZlR5cGUpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYoY3VycmVudClcbiAgfSBlbHNlIGlmIChyZWYpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzAyOVxuICAgIChyZWYgYXMgYW55KS5jdXJyZW50ID0gY3VycmVudFxuICB9XG59XG4iLCJpbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgRXZlbnRSZW5kZXJSYW5nZSB9IGZyb20gJy4vZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgSGl0IH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2hpdCdcbmltcG9ydCB7IGVsZW1lbnRDbG9zZXN0IH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBndWlkIH0gZnJvbSAnLi4vdXRpbC9taXNjJ1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCB0eXBlIERhdGVDb21wb25lbnRIYXNoID0geyBbdWlkOiBzdHJpbmddOiBEYXRlQ29tcG9uZW50PGFueSwgYW55PiB9XG5cbi8vIE5PVEU6IGZvciBmZy1ldmVudHMsIGV2ZW50UmFuZ2UucmFuZ2UgaXMgTk9UIHNsaWNlZCxcbi8vIHRodXMsIHdlIG5lZWQgaXNTdGFydC9pc0VuZFxuZXhwb3J0IGludGVyZmFjZSBTZWcge1xuICBjb21wb25lbnQ/OiBEYXRlQ29tcG9uZW50PGFueSwgYW55PlxuICBpc1N0YXJ0OiBib29sZWFuXG4gIGlzRW5kOiBib29sZWFuXG4gIGV2ZW50UmFuZ2U/OiBFdmVudFJlbmRlclJhbmdlXG4gIFtvdGhlclByb3A6IHN0cmluZ106IGFueSAvLyBUT0RPOiByZW1vdmUgdGhpcy4gZXh0ZW5kaW5nIFNlZyB3aWxsIGhhbmRsZSB0aGlzXG4gIGVsPzogbmV2ZXJcbiAgLy8gTk9URTogY2FuIHNvbWV0aW1lcyBoYXZlIHN0YXJ0L2VuZCwgd2hpY2ggYXJlIGltcG9ydGFudCB2YWx1ZXMgOihcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB7XG4gIGFmZmVjdGVkSW5zdGFuY2VzOiBFdmVudEluc3RhbmNlSGFzaFxuICBzZWdzOiBTZWdbXVxuICBpc0V2ZW50OiBib29sZWFuXG59XG5cbi8qXG5hbiBJTlRFUkFDVEFCTEUgZGF0ZSBjb21wb25lbnRcblxuUFVSUE9TRVM6XG4tIGhvb2sgdXAgdG8gZmcsIGZpbGwsIGFuZCBtaXJyb3IgcmVuZGVyZXJzXG4tIGludGVyZmFjZSBmb3IgZHJhZ2dpbmcgYW5kIGhpdHNcbiovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0ZUNvbXBvbmVudDxQcm9wcz1EaWN0aW9uYXJ5LCBTdGF0ZT1EaWN0aW9uYXJ5PiBleHRlbmRzIEJhc2VDb21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHVpZCA9IGd1aWQoKVxuXG4gIC8vIEhpdCBTeXN0ZW1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBwcmVwYXJlSGl0cygpIHtcbiAgfVxuXG4gIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdDogbnVtYmVyLCBwb3NpdGlvblRvcDogbnVtYmVyLCBlbFdpZHRoOiBudW1iZXIsIGVsSGVpZ2h0OiBudW1iZXIpOiBIaXQgfCBudWxsIHtcbiAgICByZXR1cm4gbnVsbCAvLyB0aGlzIHNob3VsZCBiZSBhYnN0cmFjdFxuICB9XG5cbiAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGlzVmFsaWRTZWdEb3duRWwoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuICEodGhpcy5wcm9wcyBhcyBhbnkpLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAhKHRoaXMucHJvcHMgYXMgYW55KS5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJylcbiAgfVxuXG4gIGlzVmFsaWREYXRlRG93bkVsKGVsOiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQ6bm90KC5mYy1iZy1ldmVudCknKSAmJlxuICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLW1vcmUtbGluaycpICYmIC8vIGEgXCJtb3JlLi5cIiBsaW5rXG4gICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICdhW2RhdGEtbmF2bGlua10nKSAmJiAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xuICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLXBvcG92ZXInKSAvLyBoYWNrXG4gIH1cbn1cbiIsImltcG9ydCB7IGd1aWQgfSBmcm9tICcuL3V0aWwvbWlzYydcbmltcG9ydCB7IFBsdWdpbkRlZklucHV0LCBQbHVnaW5EZWYsIFBsdWdpbkhvb2tzIH0gZnJvbSAnLi9wbHVnaW4tc3lzdGVtLXN0cnVjdCdcbmltcG9ydCB7IGlzQXJyYXlzRXF1YWwgfSBmcm9tICcuL3V0aWwvYXJyYXknXG5cbi8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0OiBQbHVnaW5EZWZJbnB1dCk6IFBsdWdpbkRlZiB7XG4gIHJldHVybiB7XG4gICAgaWQ6IGd1aWQoKSxcbiAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxuICAgIHJlZHVjZXJzOiBpbnB1dC5yZWR1Y2VycyB8fCBbXSxcbiAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXG4gICAgZXZlbnRSZWZpbmVyczogaW5wdXQuZXZlbnRSZWZpbmVycyB8fCB7fSxcbiAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcbiAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaW5wdXQuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IGlucHV0LmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICB2aWV3czogaW5wdXQudmlld3MgfHwge30sXG4gICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGlucHV0LmV4dGVybmFsRGVmVHJhbnNmb3JtcyB8fCBbXSxcbiAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBpbnB1dC5jb21wb25lbnRJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgIGV2ZW50U291cmNlRGVmczogaW5wdXQuZXZlbnRTb3VyY2VEZWZzIHx8IFtdLFxuICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICBuYW1lZFRpbWVab25lZEltcGw6IGlucHV0Lm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogaW5wdXQub3B0aW9uQ2hhbmdlSGFuZGxlcnMgfHwge30sXG4gICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgY29udGVudFR5cGVIYW5kbGVyczogaW5wdXQuY29udGVudFR5cGVIYW5kbGVycyB8fCB7fSxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiBpbnB1dC5saXN0ZW5lclJlZmluZXJzIHx8IHt9LFxuICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFBsdWdpbkhvb2tzKHBsdWdpbkRlZnM6IFBsdWdpbkRlZltdLCBnbG9iYWxEZWZzOiBQbHVnaW5EZWZbXSk6IFBsdWdpbkhvb2tzIHtcbiAgbGV0IGlzQWRkZWQ6IHsgW3BsdWdpbklkOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuICBsZXQgaG9va3M6IFBsdWdpbkhvb2tzID0ge1xuICAgIHJlZHVjZXJzOiBbXSxcbiAgICBpc0xvYWRpbmdGdW5jczogW10sXG4gICAgY29udGV4dEluaXQ6IFtdLFxuICAgIGV2ZW50UmVmaW5lcnM6IHt9LFxuICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBbXSxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcbiAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogW10sXG4gICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IFtdLFxuICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogW10sXG4gICAgZGF0ZVBvaW50VHJhbnNmb3JtczogW10sXG4gICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICB2aWV3czoge30sXG4gICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBbXSxcbiAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBbXSxcbiAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogW10sXG4gICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcbiAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IFtdLFxuICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBbXSxcbiAgICB0aGVtZUNsYXNzZXM6IHt9LFxuICAgIGV2ZW50U291cmNlRGVmczogW10sXG4gICAgY21kRm9ybWF0dGVyOiBudWxsLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcbiAgICBuYW1lZFRpbWVab25lZEltcGw6IG51bGwsXG4gICAgaW5pdGlhbFZpZXc6ICcnLFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXG4gICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IHt9LFxuICAgIHNjcm9sbEdyaWRJbXBsOiBudWxsLFxuICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHt9LFxuICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgIG9wdGlvblJlZmluZXJzOiB7fSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzOiBQbHVnaW5EZWZbXSkge1xuICAgIGZvciAobGV0IGRlZiBvZiBkZWZzKSB7XG4gICAgICBpZiAoIWlzQWRkZWRbZGVmLmlkXSkge1xuICAgICAgICBpc0FkZGVkW2RlZi5pZF0gPSB0cnVlXG4gICAgICAgIGFkZERlZnMoZGVmLmRlcHMpXG4gICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBsdWdpbkRlZnMpIHtcbiAgICBhZGREZWZzKHBsdWdpbkRlZnMpXG4gIH1cblxuICBhZGREZWZzKGdsb2JhbERlZnMpXG5cbiAgcmV0dXJuIGhvb2tzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKSB7IC8vIG1lbW9pemVzXG4gIGxldCBjdXJyZW50T3ZlcnJpZGVEZWZzOiBQbHVnaW5EZWZbXSA9IFtdXG4gIGxldCBjdXJyZW50R2xvYmFsRGVmczogUGx1Z2luRGVmW10gPSBbXVxuICBsZXQgY3VycmVudEhvb2tzOiBQbHVnaW5Ib29rc1xuXG4gIHJldHVybiAob3ZlcnJpZGVEZWZzOiBQbHVnaW5EZWZbXSwgZ2xvYmFsRGVmczogUGx1Z2luRGVmW10pID0+IHtcbiAgICBpZiAoIWN1cnJlbnRIb29rcyB8fCAhaXNBcnJheXNFcXVhbChvdmVycmlkZURlZnMsIGN1cnJlbnRPdmVycmlkZURlZnMpIHx8ICFpc0FycmF5c0VxdWFsKGdsb2JhbERlZnMsIGN1cnJlbnRHbG9iYWxEZWZzKSkge1xuICAgICAgY3VycmVudEhvb2tzID0gYnVpbGRQbHVnaW5Ib29rcyhvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpXG4gICAgfVxuICAgIGN1cnJlbnRPdmVycmlkZURlZnMgPSBvdmVycmlkZURlZnNcbiAgICBjdXJyZW50R2xvYmFsRGVmcyA9IGdsb2JhbERlZnNcbiAgICByZXR1cm4gY3VycmVudEhvb2tzXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tYmluZUhvb2tzKGhvb2tzMDogUGx1Z2luSG9va3MsIGhvb2tzMTogUGx1Z2luSG9va3MpOiBQbHVnaW5Ib29rcyB7XG4gIHJldHVybiB7XG4gICAgcmVkdWNlcnM6IGhvb2tzMC5yZWR1Y2Vycy5jb25jYXQoaG9va3MxLnJlZHVjZXJzKSxcbiAgICBpc0xvYWRpbmdGdW5jczogaG9va3MwLmlzTG9hZGluZ0Z1bmNzLmNvbmNhdChob29rczEuaXNMb2FkaW5nRnVuY3MpLFxuICAgIGNvbnRleHRJbml0OiBob29rczAuY29udGV4dEluaXQuY29uY2F0KGhvb2tzMS5jb250ZXh0SW5pdCksXG4gICAgZXZlbnRSZWZpbmVyczogeyAuLi5ob29rczAuZXZlbnRSZWZpbmVycywgLi4uaG9va3MxLmV2ZW50UmVmaW5lcnMgfSxcbiAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IHsgLi4uaG9va3MwLmV2ZW50U291cmNlUmVmaW5lcnMsIC4uLmhvb2tzMS5ldmVudFNvdXJjZVJlZmluZXJzIH0sXG4gICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGhvb2tzMC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzKSxcbiAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxuICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaG9va3MwLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyksXG4gICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaG9va3MwLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSxcbiAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxuICAgIGRhdGVTcGFuVHJhbnNmb3JtczogaG9va3MwLmRhdGVTcGFuVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVTcGFuVHJhbnNmb3JtcyksXG4gICAgdmlld3M6IHsgLi4uaG9va3MwLnZpZXdzLCAuLi5ob29rczEudmlld3MgfSxcbiAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxuICAgIGlzUHJvcHNWYWxpZDogaG9va3MxLmlzUHJvcHNWYWxpZCB8fCBob29rczAuaXNQcm9wc1ZhbGlkLFxuICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaG9va3MwLmV4dGVybmFsRGVmVHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmV4dGVybmFsRGVmVHJhbnNmb3JtcyksXG4gICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGhvb2tzMC52aWV3Q29udGFpbmVyQXBwZW5kcy5jb25jYXQoaG9va3MxLnZpZXdDb250YWluZXJBcHBlbmRzKSxcbiAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGhvb2tzMC5ldmVudERyb3BUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5ldmVudERyb3BUcmFuc2Zvcm1lcnMpLFxuICAgIGNhbGVuZGFySW50ZXJhY3Rpb25zOiBob29rczAuY2FsZW5kYXJJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jYWxlbmRhckludGVyYWN0aW9ucyksXG4gICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcbiAgICB0aGVtZUNsYXNzZXM6IHsgLi4uaG9va3MwLnRoZW1lQ2xhc3NlcywgLi4uaG9va3MxLnRoZW1lQ2xhc3NlcyB9LFxuICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXG4gICAgcmVjdXJyaW5nVHlwZXM6IGhvb2tzMC5yZWN1cnJpbmdUeXBlcy5jb25jYXQoaG9va3MxLnJlY3VycmluZ1R5cGVzKSxcbiAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldywgLy8gcHV0IGVhcmxpZXIgcGx1Z2lucyBGSVJTVFxuICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLCAvLyBcIlxuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7IC4uLmhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycywgLi4uaG9va3MxLm9wdGlvbkNoYW5nZUhhbmRsZXJzIH0sXG4gICAgc2Nyb2xsR3JpZEltcGw6IGhvb2tzMS5zY3JvbGxHcmlkSW1wbCB8fCBob29rczAuc2Nyb2xsR3JpZEltcGwsXG4gICAgY29udGVudFR5cGVIYW5kbGVyczogeyAuLi5ob29rczAuY29udGVudFR5cGVIYW5kbGVycywgLi4uaG9va3MxLmNvbnRlbnRUeXBlSGFuZGxlcnMgfSxcbiAgICBsaXN0ZW5lclJlZmluZXJzOiB7IC4uLmhvb2tzMC5saXN0ZW5lclJlZmluZXJzLCAuLi5ob29rczEubGlzdGVuZXJSZWZpbmVycyB9LFxuICAgIG9wdGlvblJlZmluZXJzOiB7IC4uLmhvb2tzMC5vcHRpb25SZWZpbmVycywgLi4uaG9va3MxLm9wdGlvblJlZmluZXJzIH0sXG4gICAgcHJvcFNldEhhbmRsZXJzOiB7IC4uLmhvb2tzMC5wcm9wU2V0SGFuZGxlcnMsIC4uLmhvb2tzMS5wcm9wU2V0SGFuZGxlcnMgfSxcbiAgfVxufVxuIiwiaW1wb3J0IHsgVGhlbWUgfSBmcm9tICcuL1RoZW1lJ1xuXG5leHBvcnQgY2xhc3MgU3RhbmRhcmRUaGVtZSBleHRlbmRzIFRoZW1lIHtcbn1cblxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcbiAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJywgLy8gVE9ETzogY29tcHV0ZSB0aGlzIG9mZiBvZiByZWdpc3RlcmVkIHRoZW1lIG5hbWVcbiAgdGFibGVDZWxsU2hhZGVkOiAnZmMtY2VsbC1zaGFkZWQnLFxuICBidXR0b25Hcm91cDogJ2ZjLWJ1dHRvbi1ncm91cCcsXG4gIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXG4gIGJ1dHRvbkFjdGl2ZTogJ2ZjLWJ1dHRvbi1hY3RpdmUnLFxufVxuXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJ2ZjLWljb24nXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcbiAgY2xvc2U6ICdmYy1pY29uLXgnLFxuICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxuICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxufVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUucnRsSWNvbkNsYXNzZXMgPSB7XG4gIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxuICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG59XG5cblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucycgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZmMtaWNvbi0nXG4iLCJpbXBvcnQgeyBWaWV3Q29uZmlnSGFzaCwgVmlld0NvbXBvbmVudFR5cGUgfSBmcm9tICcuL3ZpZXctY29uZmlnJ1xuaW1wb3J0IHsgVmlld09wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG4vKlxuUmVwcmVzZW50cyBpbmZvcm1hdGlvbiBmb3IgYW4gaW5zdGFudGlhdGFibGUgVmlldyBjbGFzcyBhbG9uZyB3aXRoIHNldHRpbmdzXG50aGF0IGFyZSBzcGVjaWZpYyB0byB0aGF0IHZpZXcuIE5vIG90aGVyIHNldHRpbmdzLCBsaWtlIGNhbGVuZGFyLXdpZGUgc2V0dGluZ3MsIGFyZSBzdG9yZWQuXG4qL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3RGVmIHtcbiAgdHlwZTogc3RyaW5nXG4gIGNvbXBvbmVudDogVmlld0NvbXBvbmVudFR5cGVcbiAgb3ZlcnJpZGVzOiBWaWV3T3B0aW9uc1xuICBkZWZhdWx0czogVmlld09wdGlvbnNcbn1cblxuZXhwb3J0IHR5cGUgVmlld0RlZkhhc2ggPSB7IFt2aWV3VHlwZTogc3RyaW5nXTogVmlld0RlZiB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3M6IFZpZXdDb25maWdIYXNoLCBvdmVycmlkZUNvbmZpZ3M6IFZpZXdDb25maWdIYXNoKTogVmlld0RlZkhhc2gge1xuICBsZXQgaGFzaDogVmlld0RlZkhhc2ggPSB7fVxuICBsZXQgdmlld1R5cGU6IHN0cmluZ1xuXG4gIGZvciAodmlld1R5cGUgaW4gZGVmYXVsdENvbmZpZ3MpIHtcbiAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKVxuICB9XG5cbiAgZm9yICh2aWV3VHlwZSBpbiBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKVxuICB9XG5cbiAgcmV0dXJuIGhhc2hcbn1cblxuZnVuY3Rpb24gZW5zdXJlVmlld0RlZihcbiAgdmlld1R5cGU6IHN0cmluZyxcbiAgaGFzaDogVmlld0RlZkhhc2gsXG4gIGRlZmF1bHRDb25maWdzOiBWaWV3Q29uZmlnSGFzaCxcbiAgb3ZlcnJpZGVDb25maWdzOiBWaWV3Q29uZmlnSGFzaCxcbik6IFZpZXdEZWYgfCBudWxsIHtcbiAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgcmV0dXJuIGhhc2hbdmlld1R5cGVdXG4gIH1cblxuICBsZXQgdmlld0RlZiA9IGJ1aWxkVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcblxuICBpZiAodmlld0RlZikge1xuICAgIGhhc2hbdmlld1R5cGVdID0gdmlld0RlZlxuICB9XG5cbiAgcmV0dXJuIHZpZXdEZWZcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3RGVmKFxuICB2aWV3VHlwZTogc3RyaW5nLFxuICBoYXNoOiBWaWV3RGVmSGFzaCxcbiAgZGVmYXVsdENvbmZpZ3M6IFZpZXdDb25maWdIYXNoLFxuICBvdmVycmlkZUNvbmZpZ3M6IFZpZXdDb25maWdIYXNoLFxuKTogVmlld0RlZiB8IG51bGwge1xuICBsZXQgZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWdzW3ZpZXdUeXBlXVxuICBsZXQgb3ZlcnJpZGVDb25maWcgPSBvdmVycmlkZUNvbmZpZ3Nbdmlld1R5cGVdXG5cbiAgbGV0IHF1ZXJ5UHJvcCA9IChuYW1lKSA9PiAoXG4gICAgKGRlZmF1bHRDb25maWcgJiYgZGVmYXVsdENvbmZpZ1tuYW1lXSAhPT0gbnVsbCkgPyBkZWZhdWx0Q29uZmlnW25hbWVdIDpcbiAgICAgICgob3ZlcnJpZGVDb25maWcgJiYgb3ZlcnJpZGVDb25maWdbbmFtZV0gIT09IG51bGwpID8gb3ZlcnJpZGVDb25maWdbbmFtZV0gOiBudWxsKVxuICApXG5cbiAgbGV0IHRoZUNvbXBvbmVudCA9IHF1ZXJ5UHJvcCgnY29tcG9uZW50JykgYXMgVmlld0NvbXBvbmVudFR5cGVcbiAgbGV0IHN1cGVyVHlwZSA9IHF1ZXJ5UHJvcCgnc3VwZXJUeXBlJykgYXMgc3RyaW5nXG4gIGxldCBzdXBlckRlZjogVmlld0RlZiB8IG51bGwgPSBudWxsXG5cbiAgaWYgKHN1cGVyVHlwZSkge1xuICAgIGlmIChzdXBlclR5cGUgPT09IHZpZXdUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgaGF2ZSBhIGN1c3RvbSB2aWV3IHR5cGUgdGhhdCByZWZlcmVuY2VzIGl0c2VsZicpXG4gICAgfVxuXG4gICAgc3VwZXJEZWYgPSBlbnN1cmVWaWV3RGVmKHN1cGVyVHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncylcbiAgfVxuXG4gIGlmICghdGhlQ29tcG9uZW50ICYmIHN1cGVyRGVmKSB7XG4gICAgdGhlQ29tcG9uZW50ID0gc3VwZXJEZWYuY29tcG9uZW50XG4gIH1cblxuICBpZiAoIXRoZUNvbXBvbmVudCkge1xuICAgIHJldHVybiBudWxsIC8vIGRvbid0IHRocm93IGEgd2FybmluZywgbWlnaHQgYmUgc2V0dGluZ3MgZm9yIGEgc2luZ2xlLXVuaXQgdmlld1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB2aWV3VHlwZSxcbiAgICBjb21wb25lbnQ6IHRoZUNvbXBvbmVudCxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLi4uKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSksXG4gICAgICAuLi4oZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcucmF3T3B0aW9ucyA6IHt9KSxcbiAgICB9LFxuICAgIG92ZXJyaWRlczoge1xuICAgICAgLi4uKHN1cGVyRGVmID8gc3VwZXJEZWYub3ZlcnJpZGVzIDoge30pLFxuICAgICAgLi4uKG92ZXJyaWRlQ29uZmlnID8gb3ZlcnJpZGVDb25maWcucmF3T3B0aW9ucyA6IHt9KSxcbiAgICB9LFxuICB9XG59XG4iLCIvKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuXG5pbXBvcnQgeyBSZWYsIGNyZWF0ZVJlZiwgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQsIFJlZk9iamVjdCwgY3JlYXRlQ29udGV4dCwgQ29udGV4dCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBzZXRSZWYsIEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBpc1Byb3BzRXF1YWwgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IHBhcnNlQ2xhc3NOYW1lcywgQ2xhc3NOYW1lc0lucHV0IH0gZnJvbSAnLi4vdXRpbC9odG1sJ1xuXG5leHBvcnQgdHlwZSBNb3VudEFyZzxDb250ZW50QXJnPiA9IENvbnRlbnRBcmcgJiB7IGVsOiBIVE1MRWxlbWVudCB9XG5leHBvcnQgdHlwZSBEaWRNb3VudEhhbmRsZXI8VGhlTW91bnRBcmcgZXh0ZW5kcyB7IGVsOiBIVE1MRWxlbWVudCB9PiA9IChtb3VudEFyZzogVGhlTW91bnRBcmcpID0+IHZvaWRcbmV4cG9ydCB0eXBlIFdpbGxVbm1vdW50SGFuZGxlcjxUaGVNb3VudEFyZyBleHRlbmRzIHsgZWw6IEhUTUxFbGVtZW50IH0+ID0gKG1vdW50QXJnOiBUaGVNb3VudEFyZykgPT4gdm9pZFxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckhvb2tQcm9wczxDb250ZW50QXJnPiB7XG4gIGhvb2tQcm9wczogQ29udGVudEFyZ1xuICBjbGFzc05hbWVzOiBDbGFzc05hbWVzR2VuZXJhdG9yPENvbnRlbnRBcmc+XG4gIGNvbnRlbnQ6IEN1c3RvbUNvbnRlbnRHZW5lcmF0b3I8Q29udGVudEFyZz5cbiAgZGVmYXVsdENvbnRlbnQ/OiBEZWZhdWx0Q29udGVudEdlbmVyYXRvcjxDb250ZW50QXJnPlxuICBkaWRNb3VudDogRGlkTW91bnRIYW5kbGVyPE1vdW50QXJnPENvbnRlbnRBcmc+PlxuICB3aWxsVW5tb3VudDogV2lsbFVubW91bnRIYW5kbGVyPE1vdW50QXJnPENvbnRlbnRBcmc+PlxuICBjaGlsZHJlbjogUmVuZGVySG9va1Byb3BzQ2hpbGRyZW5cbiAgZWxSZWY/OiBSZWY8YW55PlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJIb29rUHJvcHNDaGlsZHJlbiA9IChcbiAgcm9vdEVsUmVmOiBSZWY8YW55PixcbiAgY2xhc3NOYW1lczogc3RyaW5nW10sXG4gIGlubmVyRWxSZWY6IFJlZjxhbnk+LFxuICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuIC8vIGlmIGZhbHN5LCBtZWFucyBpdCB3YXNuJ3Qgc3BlY2lmaWVkXG4pID0+IENvbXBvbmVudENoaWxkcmVuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudFR5cGVIYW5kbGVycyB7XG4gIFtjb250ZW50S2V5OiBzdHJpbmddOiAoKSA9PiAoe1xuICAgIHJlbmRlcjogKGVsOiBIVE1MRWxlbWVudCwgY29udGVudFZhbDogYW55KSA9PiB2b2lkXG4gICAgZGVzdHJveT86ICgpID0+IHZvaWRcbiAgfSlcbn1cblxuLy8gTk9URTogaW4gSlNYLCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgdGhpcyBjbGFzcyB3aXRoIDxIb29rUHJvcHM+IGFyZy4gb3RoZXJ3aXNlLCB3aWxsIGRlZmF1bHQgdG8gYW55Pz8/XG5leHBvcnQgY2xhc3MgUmVuZGVySG9vazxIb29rUHJvcHM+IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxSZW5kZXJIb29rUHJvcHM8SG9va1Byb3BzPj4ge1xuICBwcml2YXRlIHJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgaG9va1Byb3BzIH0gPSBwcm9wc1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxNb3VudEhvb2sgaG9va1Byb3BzPXtob29rUHJvcHN9IGRpZE1vdW50PXtwcm9wcy5kaWRNb3VudH0gd2lsbFVubW91bnQ9e3Byb3BzLndpbGxVbm1vdW50fSBlbFJlZj17dGhpcy5oYW5kbGVSb290RWx9PlxuICAgICAgICB7KHJvb3RFbFJlZikgPT4gKFxuICAgICAgICAgIDxDb250ZW50SG9vayBob29rUHJvcHM9e2hvb2tQcm9wc30gY29udGVudD17cHJvcHMuY29udGVudH0gZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50fSBiYWNrdXBFbFJlZj17dGhpcy5yb290RWxSZWZ9PlxuICAgICAgICAgICAgeyhpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IHByb3BzLmNoaWxkcmVuKFxuICAgICAgICAgICAgICByb290RWxSZWYsXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lcywgaG9va1Byb3BzKSxcbiAgICAgICAgICAgICAgaW5uZXJFbFJlZixcbiAgICAgICAgICAgICAgaW5uZXJDb250ZW50LFxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L0NvbnRlbnRIb29rPlxuICAgICAgICApfVxuICAgICAgPC9Nb3VudEhvb2s+XG4gICAgKVxuICB9XG5cbiAgaGFuZGxlUm9vdEVsID0gKGVsOiBIVE1MRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICBzZXRSZWYodGhpcy5yb290RWxSZWYsIGVsKVxuXG4gICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBPYmpDdXN0b21Db250ZW50IHtcbiAgaHRtbDogc3RyaW5nXG4gIGRvbU5vZGVzOiBhbnlbXVxuICBbY3VzdG9tOiBzdHJpbmddOiBhbnkgLy8gVE9ETzogZXhwb3NlIGhvb2sgZm9yIHBsdWdpbnMgdG8gYWRkIVxufVxuXG5leHBvcnQgdHlwZSBDdXN0b21Db250ZW50ID0gQ29tcG9uZW50Q2hpbGRyZW4gfCBPYmpDdXN0b21Db250ZW50XG5leHBvcnQgdHlwZSBDdXN0b21Db250ZW50R2VuZXJhdG9yPEhvb2tQcm9wcz4gPSBDdXN0b21Db250ZW50IHwgKChob29rUHJvcHM6IEhvb2tQcm9wcykgPT4gQ3VzdG9tQ29udGVudClcblxuZXhwb3J0IHR5cGUgRGVmYXVsdENvbnRlbnRHZW5lcmF0b3I8SG9va1Byb3BzPiA9IChob29rUHJvcHM6IEhvb2tQcm9wcykgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbi8vIFRPRE86IHJlbmFtZSB0byBiZSBhYm91dCBmdW5jdGlvbiwgbm90IGRlZmF1bHQuIHVzZSBpbiBhYm92ZSB0eXBlXG5cbi8vIGZvciBmb3JjaW5nIHJlcmVuZGVyIG9mIGNvbXBvbmVudHMgdGhhdCB1c2UgdGhlIENvbnRlbnRIb29rXG5leHBvcnQgY29uc3QgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQ6IENvbnRleHQ8bnVtYmVyPiA9IGNyZWF0ZUNvbnRleHQ8bnVtYmVyPigwKVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRlbnRIb29rUHJvcHM8SG9va1Byb3BzPiB7XG4gIGhvb2tQcm9wczogSG9va1Byb3BzIC8vIHByb2R1Y2VkIGJ5IEZ1bGxDYWxlbmRhciBpbnRlcm5hbGx5LCBmb3IgcmVuZGVyaW5nIGFuIGVudGl0eS93aGF0ZXZlclxuICBjb250ZW50OiBDdXN0b21Db250ZW50R2VuZXJhdG9yPEhvb2tQcm9wcz4gLy8gdGhlIHZhbHVlIG9mIGEgdXNlci1ob29rLCBsaWtlIGBldmVudENvbnRlbnRgXG4gIGRlZmF1bHRDb250ZW50PzogRGVmYXVsdENvbnRlbnRHZW5lcmF0b3I8SG9va1Byb3BzPiAvLyBpZiBjb250ZW50IG5vdCBzcGVjaWZpZWQgKFRPRE86IGp1c3QgdXNlIGNvbnRlbnQ/KVxuICBjaGlsZHJlbjogKCAvLyBmb3IgcHJvZHVjaW5nIGEgd3JhcHBlciBhcm91bmQgdGhlIGNvbnRlbnRcbiAgICBpbm5lckVsUmVmOiBSZWY8YW55PixcbiAgICBpbm5lckNvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuIC8vIGlmIGZhbHN5LCBtZWFucyBpdCB3YXNuJ3Qgc3BlY2lmaWVkXG4gICkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbiAgYmFja3VwRWxSZWY/OiBSZWZPYmplY3Q8YW55PlxufVxuXG5pbnRlcmZhY2UgQ29udGVudEhvb2tJbm5lclByb3BzPEhvb2tQcm9wcz4gZXh0ZW5kcyBDb250ZW50SG9va1Byb3BzPEhvb2tQcm9wcz4ge1xuICByZW5kZXJJZDogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb250ZW50SG9vazxIb29rUHJvcHM+KHByb3BzOiBDb250ZW50SG9va1Byb3BzPEhvb2tQcm9wcz4pIHsgLy8gVE9ETzogcmVuYW1lIHRvIEN1c3RvbUNvbnRlbnRIb29rP1xuICByZXR1cm4gKFxuICAgIDxDdXN0b21Db250ZW50UmVuZGVyQ29udGV4dC5Db25zdW1lcj5cbiAgICAgIHsocmVuZGVySWQpID0+IChcbiAgICAgICAgPENvbnRlbnRIb29rSW5uZXIgcmVuZGVySWQ9e3JlbmRlcklkfSB7Li4ucHJvcHN9IC8+XG4gICAgICApfVxuICAgIDwvQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQuQ29uc3VtZXI+XG4gIClcbn1cblxuY2xhc3MgQ29udGVudEhvb2tJbm5lcjxIb29rUHJvcHM+IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxDb250ZW50SG9va0lubmVyUHJvcHM8SG9va1Byb3BzPj4ge1xuICBwcml2YXRlIGlubmVyRWxSZWYgPSBjcmVhdGVSZWYoKVxuXG4gIHByaXZhdGUgY3VzdG9tQ29udGVudEluZm86IHtcbiAgICBjb250ZW50S2V5OiBzdHJpbmdcbiAgICBjb250ZW50VmFsOiBhbnlcbiAgICByZW5kZXI6IChlbDogSFRNTEVsZW1lbnQsIGNvbnRlbnRWYWw6IGFueSkgPT4gdm9pZFxuICAgIGRlc3Ryb3k/OiAoKSA9PiB2b2lkXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5pbm5lckVsUmVmLCB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVDdXN0b21Db250ZW50KClcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbnRlbnQoKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8gJiYgdGhpcy5jdXN0b21Db250ZW50SW5mby5kZXN0cm95KSB7XG4gICAgICB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3koKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVuZGVySW5uZXJDb250ZW50KCkge1xuICAgIGxldCB7IGN1c3RvbUNvbnRlbnRJbmZvIH0gPSB0aGlzIC8vIG9ubHkgcG9wdWxhdGVkIGlmIHVzaW5nIG5vbi1bcF1yZWFjdCBub2RlKHMpXG4gICAgbGV0IGlubmVyQ29udGVudCA9IHRoaXMuZ2V0SW5uZXJDb250ZW50KClcbiAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0Q29udGVudE1ldGEoaW5uZXJDb250ZW50KVxuXG4gICAgLy8gaW5pdGlhbCBydW4sIG9yIGNvbnRlbnQtdHlwZSBjaGFuZ2luZz8gKGZyb20gdnVlIC0+IHJlYWN0IGZvciBleGFtcGxlKVxuICAgIGlmICghY3VzdG9tQ29udGVudEluZm8gfHwgY3VzdG9tQ29udGVudEluZm8uY29udGVudEtleSAhPT0gbWV0YS5jb250ZW50S2V5KSB7XG4gICAgICAvLyBjbGVhcmluZyBvbGQgdmFsdWVcbiAgICAgIGlmIChjdXN0b21Db250ZW50SW5mbykge1xuICAgICAgICBpZiAoY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSkge1xuICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3koKVxuICAgICAgICB9XG4gICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IG51bGxcbiAgICAgIH1cbiAgICAgIC8vIGFzc2lnbmluZyBuZXcgdmFsdWVcbiAgICAgIGlmIChtZXRhLmNvbnRlbnRLZXkpIHtcbiAgICAgICAgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvID0geyAvLyBmb3Igbm9uLVtwXXJlYWN0XG4gICAgICAgICAgY29udGVudEtleTogbWV0YS5jb250ZW50S2V5LFxuICAgICAgICAgIGNvbnRlbnRWYWw6IGlubmVyQ29udGVudFttZXRhLmNvbnRlbnRLZXldLFxuICAgICAgICAgIC4uLm1ldGEuYnVpbGRMaWZlY3ljbGVGdW5jcygpLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgLy8gdXBkYXRpbmdcbiAgICB9IGVsc2UgaWYgKGN1c3RvbUNvbnRlbnRJbmZvKSB7XG4gICAgICBjdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsID0gaW5uZXJDb250ZW50W21ldGEuY29udGVudEtleV1cbiAgICB9XG5cbiAgICByZXR1cm4gY3VzdG9tQ29udGVudEluZm9cbiAgICAgID8gW10gLy8gc2lnbmFsIHRoYXQgc29tZXRoaW5nIHdhcyBzcGVjaWZpZWRcbiAgICAgIDogaW5uZXJDb250ZW50IC8vIGFzc3VtZSBhIFtwXXJlYWN0IHZkb20gbm9kZS4gdXNlIGl0XG4gIH1cblxuICBwcml2YXRlIGdldElubmVyQ29udGVudCgpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCBpbm5lckNvbnRlbnQgPSBub3JtYWxpemVDb250ZW50KHByb3BzLmNvbnRlbnQsIHByb3BzLmhvb2tQcm9wcylcblxuICAgIGlmIChpbm5lckNvbnRlbnQgPT09IHVuZGVmaW5lZCkgeyAvLyB1c2UgdGhlIGRlZmF1bHRcbiAgICAgIGlubmVyQ29udGVudCA9IG5vcm1hbGl6ZUNvbnRlbnQocHJvcHMuZGVmYXVsdENvbnRlbnQsIHByb3BzLmhvb2tQcm9wcylcbiAgICB9XG5cbiAgICByZXR1cm4gaW5uZXJDb250ZW50ID09IG51bGwgPyBudWxsIDogaW5uZXJDb250ZW50IC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgKGJldHRlciBmb3IgUmVhY3QpXG4gIH1cblxuICBwcml2YXRlIGdldENvbnRlbnRNZXRhKGlubmVyQ29udGVudDogYW55KSB7XG4gICAgbGV0IHsgY29udGVudFR5cGVIYW5kbGVycyB9ID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzXG4gICAgbGV0IGNvbnRlbnRLZXkgPSAnJ1xuICAgIGxldCBidWlsZExpZmVjeWNsZUZ1bmNzID0gbnVsbFxuXG4gICAgaWYgKGlubmVyQ29udGVudCkgeyAvLyBhbGxvd2VkIHRvIGJlIG51bGwsIGZvciBjb252ZW5pZW5jZSB0byBjYWxsZXJcbiAgICAgIGZvciAobGV0IHNlYXJjaEtleSBpbiBjb250ZW50VHlwZUhhbmRsZXJzKSB7XG4gICAgICAgIGlmIChpbm5lckNvbnRlbnRbc2VhcmNoS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udGVudEtleSA9IHNlYXJjaEtleVxuICAgICAgICAgIGJ1aWxkTGlmZWN5Y2xlRnVuY3MgPSBjb250ZW50VHlwZUhhbmRsZXJzW3NlYXJjaEtleV1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgY29udGVudEtleSwgYnVpbGRMaWZlY3ljbGVGdW5jcyB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUN1c3RvbUNvbnRlbnQoKSB7XG4gICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8pIHsgLy8gZm9yIG5vbi1bcF1yZWFjdFxuICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5yZW5kZXIoXG4gICAgICAgIHRoaXMuaW5uZXJFbFJlZi5jdXJyZW50IHx8IHRoaXMucHJvcHMuYmFja3VwRWxSZWYuY3VycmVudCwgLy8gdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGludG9cbiAgICAgICAgdGhpcy5jdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsLFxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vdW50SG9va1Byb3BzPENvbnRlbnRBcmc+IHtcbiAgaG9va1Byb3BzOiBDb250ZW50QXJnXG4gIGRpZE1vdW50OiBEaWRNb3VudEhhbmRsZXI8TW91bnRBcmc8Q29udGVudEFyZz4+XG4gIHdpbGxVbm1vdW50OiBXaWxsVW5tb3VudEhhbmRsZXI8TW91bnRBcmc8Q29udGVudEFyZz4+XG4gIGNoaWxkcmVuOiAocm9vdEVsUmVmOiBSZWY8YW55PikgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbiAgZWxSZWY/OiBSZWY8YW55PiAvLyBtYXliZSBnZXQgcmlkIG9mIG9uY2Ugd2UgaGF2ZSBiZXR0ZXIgQVBJIGZvciBjYWxsZXIgdG8gY29tYmluZSByZWZzXG59XG5cbmV4cG9ydCBjbGFzcyBNb3VudEhvb2s8Q29udGVudEFyZz4gZXh0ZW5kcyBCYXNlQ29tcG9uZW50PE1vdW50SG9va1Byb3BzPENvbnRlbnRBcmc+PiB7XG4gIHJvb3RFbDogSFRNTEVsZW1lbnRcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5oYW5kbGVSb290RWwpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLnByb3BzLmRpZE1vdW50XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKHsgLi4udGhpcy5wcm9wcy5ob29rUHJvcHMsIGVsOiB0aGlzLnJvb3RFbCB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGxldCBjYWxsYmFjayA9IHRoaXMucHJvcHMud2lsbFVubW91bnRcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soeyAuLi50aGlzLnByb3BzLmhvb2tQcm9wcywgZWw6IHRoaXMucm9vdEVsIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSb290RWwgPSAocm9vdEVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIHRoaXMucm9vdEVsID0gcm9vdEVsXG5cbiAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIHJvb3RFbClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjxIb29rUHJvcHM+KCkgeyAvLyBUT0RPOiBnZW5lcmFsIGRlZXAtbWVtb2l6ZXI/XG4gIGxldCBjdXJyZW50R2VuZXJhdG9yOiBDbGFzc05hbWVzR2VuZXJhdG9yPEhvb2tQcm9wcz5cbiAgbGV0IGN1cnJlbnRIb29rUHJvcHM6IEhvb2tQcm9wc1xuICBsZXQgY3VycmVudENsYXNzTmFtZXM6IHN0cmluZ1tdID0gW11cblxuICByZXR1cm4gKGdlbmVyYXRvcjogQ2xhc3NOYW1lc0dlbmVyYXRvcjxIb29rUHJvcHM+LCBob29rUHJvcHM6IEhvb2tQcm9wcykgPT4ge1xuICAgIGlmICghY3VycmVudEhvb2tQcm9wcyB8fCAhaXNQcm9wc0VxdWFsKGN1cnJlbnRIb29rUHJvcHMsIGhvb2tQcm9wcykgfHwgZ2VuZXJhdG9yICE9PSBjdXJyZW50R2VuZXJhdG9yKSB7XG4gICAgICBjdXJyZW50R2VuZXJhdG9yID0gZ2VuZXJhdG9yXG4gICAgICBjdXJyZW50SG9va1Byb3BzID0gaG9va1Byb3BzXG4gICAgICBjdXJyZW50Q2xhc3NOYW1lcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoZ2VuZXJhdG9yLCBob29rUHJvcHMpXG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRDbGFzc05hbWVzXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ2xhc3NOYW1lc0dlbmVyYXRvcjxIb29rUHJvcHM+ID0gQ2xhc3NOYW1lc0lucHV0IHwgKChob29rUHJvcHM6IEhvb2tQcm9wcykgPT4gQ2xhc3NOYW1lc0lucHV0KVxuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzPEhvb2tQcm9wcz4oY2xhc3NOYW1lczogQ2xhc3NOYW1lc0dlbmVyYXRvcjxIb29rUHJvcHM+LCBob29rUHJvcHM6IEhvb2tQcm9wcyk6IHN0cmluZ1tdIHtcbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMoaG9va1Byb3BzKVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlQ2xhc3NOYW1lcyhjbGFzc05hbWVzKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb250ZW50KGlucHV0LCBob29rUHJvcHMpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpbnB1dChob29rUHJvcHMsIGNyZWF0ZUVsZW1lbnQpIC8vIGdpdmUgdGhlIGZ1bmN0aW9uIHRoZSB2ZG9tLWNyZWF0aW9uIGZ1bmNcbiAgfVxuICByZXR1cm4gaW5wdXRcbn1cbiIsImltcG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi4vc3RydWN0cy92aWV3LXNwZWMnXG5pbXBvcnQgeyBNb3VudEhvb2ssIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciwgTW91bnRBcmcgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQsIFJlZiB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld1Jvb3RQcm9wcyB7XG4gIHZpZXdTcGVjOiBWaWV3U3BlY1xuICBjaGlsZHJlbjogKHJvb3RFbFJlZjogUmVmPGFueT4sIGNsYXNzTmFtZXM6IHN0cmluZ1tdKSA9PiBDb21wb25lbnRDaGlsZHJlblxuICBlbFJlZj86IFJlZjxhbnk+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld0NvbnRlbnRBcmcge1xuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCB0eXBlIFZpZXdNb3VudEFyZyA9IE1vdW50QXJnPFZpZXdDb250ZW50QXJnPlxuXG5leHBvcnQgY2xhc3MgVmlld1Jvb3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFZpZXdSb290UHJvcHM+IHtcbiAgbm9ybWFsaXplQ2xhc3NOYW1lcyA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjxWaWV3Q29udGVudEFyZz4oKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICBsZXQgaG9va1Byb3BzOiBWaWV3Q29udGVudEFyZyA9IHsgdmlldzogY29udGV4dC52aWV3QXBpIH1cbiAgICBsZXQgY3VzdG9tQ2xhc3NOYW1lcyA9IHRoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyhvcHRpb25zLnZpZXdDbGFzc05hbWVzLCBob29rUHJvcHMpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPE1vdW50SG9va1xuICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMudmlld0RpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy52aWV3V2lsbFVubW91bnR9XG4gICAgICAgIGVsUmVmPXtwcm9wcy5lbFJlZn1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYpID0+IHByb3BzLmNoaWxkcmVuKFxuICAgICAgICAgIHJvb3RFbFJlZixcbiAgICAgICAgICBbYGZjLSR7cHJvcHMudmlld1NwZWMudHlwZX0tdmlld2AsICdmYy12aWV3J10uY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLFxuICAgICAgICApfVxuICAgICAgPC9Nb3VudEhvb2s+XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBWaWV3UHJvcHMgfSBmcm9tICcuLi9WaWV3J1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSwgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IFZpZXdSb290IH0gZnJvbSAnLi4vY29tbW9uL1ZpZXdSb290J1xuaW1wb3J0IHsgUmVuZGVySG9vaywgTW91bnRBcmcgfSBmcm9tICcuLi9jb21tb24vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBWaWV3Q29udGV4dCwgVmlld0NvbnRleHRUeXBlIH0gZnJvbSAnLi4vVmlld0NvbnRleHQnXG5pbXBvcnQgeyBWaWV3T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5cbi8qXG5BIHZpZXctY29uZmlnIHJlcHJlc2VudHMgaW5mb3JtYXRpb24gZm9yIGVpdGhlcjpcbkEpIGNyZWF0aW5nIGEgbmV3IGluc3RhbnRpYXRhYmxlIHZpZXcgY2xhc3MuIGluIHdoaWNoIGNhc2UsIHN1cHBsaWVkIGEgY2xhc3MvdHlwZSBpbiBhZGRpdGlvbiB0byBvcHRpb25zLCBPUlxuQikgb3B0aW9ucyB0byBjdXN0b21pemUgYW4gZXhpc3RpbmcgdmlldywgaW4gd2hpY2ggY2FzZSBvbmx5IHByb3ZpZGVzIG9wdGlvbnMuXG4qL1xuXG5leHBvcnQgdHlwZSBWaWV3Q29tcG9uZW50ID0gQ29tcG9uZW50PFZpZXdQcm9wcz4gLy8gYW4gaW5zdGFuY2VcbmV4cG9ydCB0eXBlIFZpZXdDb21wb25lbnRUeXBlID0gQ29tcG9uZW50VHlwZTxWaWV3UHJvcHM+XG5cbmV4cG9ydCB0eXBlIFZpZXdDb25maWdJbnB1dCA9IFZpZXdDb21wb25lbnRUeXBlIHwgVmlld09wdGlvbnNcbmV4cG9ydCB0eXBlIFZpZXdDb25maWdJbnB1dEhhc2ggPSB7IFt2aWV3VHlwZTogc3RyaW5nXTogVmlld0NvbmZpZ0lucHV0IH1cblxuZXhwb3J0IGludGVyZmFjZSBWaWV3Q29uZmlnIHtcbiAgc3VwZXJUeXBlOiBzdHJpbmdcbiAgY29tcG9uZW50OiBWaWV3Q29tcG9uZW50VHlwZSB8IG51bGxcbiAgcmF3T3B0aW9uczogVmlld09wdGlvbnNcbn1cblxuZXhwb3J0IHR5cGUgVmlld0NvbmZpZ0hhc2ggPSB7IFt2aWV3VHlwZTogc3RyaW5nXTogVmlld0NvbmZpZyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0czogVmlld0NvbmZpZ0lucHV0SGFzaCk6IFZpZXdDb25maWdIYXNoIHtcbiAgcmV0dXJuIG1hcEhhc2goaW5wdXRzLCBwYXJzZVZpZXdDb25maWcpXG59XG5cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dDogVmlld0NvbmZpZ0lucHV0KTogVmlld0NvbmZpZyB7XG4gIGxldCByYXdPcHRpb25zOiBWaWV3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgIGlucHV0XG4gIGxldCB7IGNvbXBvbmVudCB9ID0gcmF3T3B0aW9uc1xuXG4gIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICBjb21wb25lbnQgPSBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChyYXdPcHRpb25zKVxuICAgIC8vIFRPRE86IHJlbW92ZSBjb250ZW50L2NsYXNzTmFtZXMvZGlkTW91bnQvZXRjIGZyb20gb3B0aW9ucz9cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUgYXMgYW55LFxuICAgIGNvbXBvbmVudDogY29tcG9uZW50IGFzIGFueSxcbiAgICByYXdPcHRpb25zLCAvLyBpbmNsdWRlcyB0eXBlIGFuZCBjb21wb25lbnQgdG9vIDooXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTcGVjaWZpY1ZpZXdDb250ZW50QXJnIGV4dGVuZHMgVmlld1Byb3BzIHtcbiAgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb25cbn1cblxuZXhwb3J0IHR5cGUgU3BlY2lmaWNWaWV3TW91bnRBcmcgPSBNb3VudEFyZzxTcGVjaWZpY1ZpZXdDb250ZW50QXJnPlxuXG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zOiBWaWV3T3B0aW9ucykge1xuICByZXR1cm4gKHZpZXdQcm9wczogVmlld1Byb3BzKSA9PiAoXG4gICAgPFZpZXdDb250ZXh0VHlwZS5Db25zdW1lcj5cbiAgICAgIHsoY29udGV4dDogVmlld0NvbnRleHQpID0+IChcbiAgICAgICAgPFZpZXdSb290IHZpZXdTcGVjPXtjb250ZXh0LnZpZXdTcGVjfT5cbiAgICAgICAgICB7KHZpZXdFbFJlZiwgdmlld0NsYXNzTmFtZXMpID0+IHtcbiAgICAgICAgICAgIGxldCBob29rUHJvcHM6IFNwZWNpZmljVmlld0NvbnRlbnRBcmcgPSB7XG4gICAgICAgICAgICAgIC4uLnZpZXdQcm9wcyxcbiAgICAgICAgICAgICAgbmV4dERheVRocmVzaG9sZDogY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8UmVuZGVySG9va1xuICAgICAgICAgICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMuY2xhc3NOYW1lcyBhcyBhbnl9XG4gICAgICAgICAgICAgICAgY29udGVudD17b3B0aW9ucy5jb250ZW50IGFzIGFueX1cbiAgICAgICAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5kaWRNb3VudCBhcyBhbnl9XG4gICAgICAgICAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMud2lsbFVubW91bnQgYXMgYW55fVxuICAgICAgICAgICAgICAgIGVsUmVmPXt2aWV3RWxSZWZ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7KHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17dmlld0NsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKX0gcmVmPXtyb290RWxSZWZ9PlxuICAgICAgICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9SZW5kZXJIb29rPlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH19XG4gICAgICAgIDwvVmlld1Jvb3Q+XG4gICAgICApfVxuICAgIDwvVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICApXG59XG4iLCJpbXBvcnQgeyBWaWV3RGVmLCBjb21waWxlVmlld0RlZnMgfSBmcm9tICcuL3ZpZXctZGVmJ1xuaW1wb3J0IHsgRHVyYXRpb24sIGNyZWF0ZUR1cmF0aW9uLCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IsIER1cmF0aW9uSW5wdXQgfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgbWFwSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgVmlld09wdGlvbnMsIENhbGVuZGFyT3B0aW9ucywgQkFTRV9PUFRJT05fREVGQVVMVFMgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgVmlld0NvbmZpZ0lucHV0SGFzaCwgcGFyc2VWaWV3Q29uZmlncywgVmlld0NvbmZpZ0hhc2gsIFZpZXdDb21wb25lbnRUeXBlIH0gZnJvbSAnLi92aWV3LWNvbmZpZydcblxuLypcblJlcHJlc2VudHMgZXZlcnl0aGluZyBuZWVkZWQgdG8gaW5zdGFudGlhdGUgYSBuZXcgdmlldyBpbnN0YW5jZSxcbmluY2x1ZGluZyBvcHRpb25zIHRoYXQgaGF2ZSBiZWVuIGNvbXBpbGVkIGZyb20gdmlldy1zcGVjaWZpYyBhbmQgY2FsZW5kYXItd2lkZSBvcHRpb25zLFxuYXMgd2VsbCBhcyBkdXJhdGlvbiBpbmZvcm1hdGlvbi5cblxuT3ZlcmFsbCBmbG93OlxuVmlld0NvbmZpZyAtPiBWaWV3RGVmIC0+IFZpZXdTcGVjXG4qL1xuZXhwb3J0IGludGVyZmFjZSBWaWV3U3BlYyB7XG4gIHR5cGU6IHN0cmluZ1xuICBjb21wb25lbnQ6IFZpZXdDb21wb25lbnRUeXBlXG4gIGR1cmF0aW9uOiBEdXJhdGlvblxuICBkdXJhdGlvblVuaXQ6IHN0cmluZ1xuICBzaW5nbGVVbml0OiBzdHJpbmdcbiAgb3B0aW9uRGVmYXVsdHM6IFZpZXdPcHRpb25zXG4gIG9wdGlvbk92ZXJyaWRlczogVmlld09wdGlvbnNcbiAgYnV0dG9uVGV4dE92ZXJyaWRlOiBzdHJpbmdcbiAgYnV0dG9uVGV4dERlZmF1bHQ6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBWaWV3U3BlY0hhc2ggPSB7IFt2aWV3VHlwZTogc3RyaW5nXTogVmlld1NwZWMgfVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoXG4gIGRlZmF1bHRJbnB1dHM6IFZpZXdDb25maWdJbnB1dEhhc2gsXG4gIG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gIGxvY2FsZURlZmF1bHRzLFxuKTogVmlld1NwZWNIYXNoIHtcbiAgbGV0IGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKVxuICBsZXQgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25PdmVycmlkZXMudmlld3MpXG4gIGxldCB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKVxuXG4gIHJldHVybiBtYXBIYXNoKHZpZXdEZWZzLCAodmlld0RlZikgPT4gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpKVxufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKFxuICB2aWV3RGVmOiBWaWV3RGVmLFxuICBvdmVycmlkZUNvbmZpZ3M6IFZpZXdDb25maWdIYXNoLFxuICBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgZHluYW1pY09wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICBsb2NhbGVEZWZhdWx0cyxcbik6IFZpZXdTcGVjIHtcbiAgbGV0IGR1cmF0aW9uSW5wdXQgPVxuICAgIHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb25cblxuICBsZXQgZHVyYXRpb24gPSBudWxsXG4gIGxldCBkdXJhdGlvblVuaXQgPSAnJ1xuICBsZXQgc2luZ2xlVW5pdCA9ICcnXG4gIGxldCBzaW5nbGVVbml0T3ZlcnJpZGVzOiBWaWV3T3B0aW9ucyA9IHt9XG5cbiAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcbiAgICBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpXG5cbiAgICBpZiAoZHVyYXRpb24pIHsgLy8gdmFsaWQ/XG4gICAgICBsZXQgZGVub20gPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pXG4gICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0XG5cbiAgICAgIGlmIChkZW5vbS52YWx1ZSA9PT0gMSkge1xuICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0XG4gICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLnJhd09wdGlvbnMgOiB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBxdWVyeUJ1dHRvblRleHQgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xuICAgIGxldCBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9XG4gICAgbGV0IGJ1dHRvblRleHRLZXkgPSB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHRLZXkgYXMgc3RyaW5nXG5cbiAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV1cbiAgICB9XG5cbiAgICBpZiAoYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV1cbiAgICB9XG5cbiAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICBjb21wb25lbnQ6IHZpZXdEZWYuY29tcG9uZW50LFxuICAgIGR1cmF0aW9uLFxuICAgIGR1cmF0aW9uVW5pdCxcbiAgICBzaW5nbGVVbml0LFxuICAgIG9wdGlvbkRlZmF1bHRzOiB2aWV3RGVmLmRlZmF1bHRzLFxuICAgIG9wdGlvbk92ZXJyaWRlczogeyAuLi5zaW5nbGVVbml0T3ZlcnJpZGVzLCAuLi52aWV3RGVmLm92ZXJyaWRlcyB9LFxuXG4gICAgYnV0dG9uVGV4dE92ZXJyaWRlOlxuICAgICAgcXVlcnlCdXR0b25UZXh0KGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uT3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LCAvLyBgYnV0dG9uVGV4dGAgZm9yIHZpZXctc3BlY2lmaWMgb3B0aW9ucyBpcyBhIHN0cmluZ1xuXG4gICAgYnV0dG9uVGV4dERlZmF1bHQ6XG4gICAgICBxdWVyeUJ1dHRvblRleHQobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvblRleHQgfHxcbiAgICAgIHF1ZXJ5QnV0dG9uVGV4dChCQVNFX09QVElPTl9ERUZBVUxUUykgfHxcbiAgICAgIHZpZXdEZWYudHlwZSwgLy8gZmFsbCBiYWNrIHRvIGdpdmVuIHZpZXcgbmFtZVxuICB9XG59XG5cbi8vIGhhY2sgdG8gZ2V0IG1lbW9pemF0aW9uIHdvcmtpbmdcblxubGV0IGR1cmF0aW9uSW5wdXRNYXA6IHsgW2pzb246IHN0cmluZ106IER1cmF0aW9uIH0gPSB7fVxuXG5mdW5jdGlvbiBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0OiBEdXJhdGlvbklucHV0KSB7XG4gIGxldCBqc29uID0gSlNPTi5zdHJpbmdpZnkoZHVyYXRpb25JbnB1dClcbiAgbGV0IHJlcyA9IGR1cmF0aW9uSW5wdXRNYXBbanNvbl1cblxuICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXMgPSBjcmVhdGVEdXJhdGlvbihkdXJhdGlvbklucHV0KVxuICAgIGR1cmF0aW9uSW5wdXRNYXBbanNvbl0gPSByZXNcbiAgfVxuXG4gIHJldHVybiByZXNcbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIsIHN0YXJ0T2ZEYXksIGFkZERheXMgfSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgRHVyYXRpb24sIGNyZWF0ZUR1cmF0aW9uLCBhc1JvdWdoRGF5cywgYXNSb3VnaE1zLCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQge1xuICBEYXRlUmFuZ2UsXG4gIE9wZW5EYXRlUmFuZ2UsXG4gIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UsXG4gIGludGVyc2VjdFJhbmdlcyxcbiAgcmFuZ2VzSW50ZXJzZWN0LFxuICBwYXJzZVJhbmdlLFxuICBEYXRlUmFuZ2VJbnB1dCxcbn0gZnJvbSAnLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBEYXRlRW52LCBEYXRlSW5wdXQgfSBmcm9tICcuL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgY29tcHV0ZVZpc2libGVEYXlSYW5nZSB9IGZyb20gJy4vdXRpbC9kYXRlJ1xuaW1wb3J0IHsgZ2V0Tm93IH0gZnJvbSAnLi9yZWR1Y2Vycy9jdXJyZW50LWRhdGUnXG5pbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4vQ2FsZW5kYXJBcGknXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVByb2ZpbGUge1xuICBjdXJyZW50UmFuZ2U6IERhdGVSYW5nZSAvLyBUT0RPOiBkb2VzIHRoaXMgaW5jbHVkZSBzbG90TWluVGltZS9zbG90TWF4VGltZT9cbiAgY3VycmVudFJhbmdlVW5pdDogc3RyaW5nXG4gIGlzUmFuZ2VBbGxEYXk6IGJvb2xlYW5cbiAgdmFsaWRSYW5nZTogT3BlbkRhdGVSYW5nZVxuICBhY3RpdmVSYW5nZTogRGF0ZVJhbmdlIHwgbnVsbFxuICByZW5kZXJSYW5nZTogRGF0ZVJhbmdlXG4gIHNsb3RNaW5UaW1lOiBEdXJhdGlvblxuICBzbG90TWF4VGltZTogRHVyYXRpb25cbiAgaXNWYWxpZDogYm9vbGVhblxuICBkYXRlSW5jcmVtZW50OiBEdXJhdGlvblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhdGVQcm9maWxlR2VuZXJhdG9yUHJvcHMgZXh0ZW5kcyBEYXRlUHJvZmlsZU9wdGlvbnMge1xuICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIC8vIG5vdCB1c2VkIGJ5IERhdGVQcm9maWxlR2VuZXJhdG9yIGl0c2VsZlxuICBkdXJhdGlvbjogRHVyYXRpb25cbiAgZHVyYXRpb25Vbml0OiBzdHJpbmdcbiAgdXNlc01pbk1heFRpbWU6IGJvb2xlYW5cbiAgZGF0ZUVudjogRGF0ZUVudlxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlUHJvZmlsZU9wdGlvbnMge1xuICBzbG90TWluVGltZTogRHVyYXRpb25cbiAgc2xvdE1heFRpbWU6IER1cmF0aW9uXG4gIHNob3dOb25DdXJyZW50RGF0ZXM/OiBib29sZWFuXG4gIGRheUNvdW50PzogbnVtYmVyXG4gIGRhdGVBbGlnbm1lbnQ/OiBzdHJpbmdcbiAgZGF0ZUluY3JlbWVudD86IER1cmF0aW9uXG4gIGhpZGRlbkRheXM/OiBudW1iZXJbXVxuICB3ZWVrZW5kcz86IGJvb2xlYW5cbiAgbm93SW5wdXQ/OiBEYXRlSW5wdXQgfCAoKCkgPT4gRGF0ZUlucHV0KVxuICB2YWxpZFJhbmdlSW5wdXQ/OiBEYXRlUmFuZ2VJbnB1dCB8ICgodGhpczogQ2FsZW5kYXJBcGksIG5vd0RhdGU6IERhdGUpID0+IERhdGVSYW5nZUlucHV0KVxuICB2aXNpYmxlUmFuZ2VJbnB1dD86IERhdGVSYW5nZUlucHV0IHwgKCh0aGlzOiBDYWxlbmRhckFwaSwgbm93RGF0ZTogRGF0ZSkgPT4gRGF0ZVJhbmdlSW5wdXQpXG4gIG1vbnRoTW9kZT86IGJvb2xlYW5cbiAgZml4ZWRXZWVrQ291bnQ/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSB7XG4gIG5ldyhwcm9wczogRGF0ZVByb2ZpbGVHZW5lcmF0b3JQcm9wcyk6IERhdGVQcm9maWxlR2VuZXJhdG9yXG59XG5cbmV4cG9ydCBjbGFzcyBEYXRlUHJvZmlsZUdlbmVyYXRvciB7IC8vIG9ubHkgcHVibGljbHkgdXNlZCBmb3IgaXNIaWRkZW5EYXkgOihcbiAgbm93RGF0ZTogRGF0ZU1hcmtlclxuXG4gIGlzSGlkZGVuRGF5SGFzaDogYm9vbGVhbltdXG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHByb3BzOiBEYXRlUHJvZmlsZUdlbmVyYXRvclByb3BzKSB7XG4gICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KVxuICAgIHRoaXMuaW5pdEhpZGRlbkRheXMoKVxuICB9XG5cbiAgLyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuICBidWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY3VycmVudERhdGU6IERhdGVNYXJrZXIsIGZvcmNlVG9WYWxpZD86IGJvb2xlYW4pOiBEYXRlUHJvZmlsZSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IHByZXZEYXRlID0gZGF0ZUVudi5zdWJ0cmFjdChcbiAgICAgIGRhdGVFbnYuc3RhcnRPZihjdXJyZW50RGF0ZSwgY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpLCAvLyBpbXBvcnRhbnQgZm9yIHN0YXJ0LW9mLW1vbnRoXG4gICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCxcbiAgICApXG5cbiAgICByZXR1cm4gdGhpcy5idWlsZChwcmV2RGF0ZSwgLTEsIGZvcmNlVG9WYWxpZClcbiAgfVxuXG4gIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICBidWlsZE5leHQoY3VycmVudERhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY3VycmVudERhdGU6IERhdGVNYXJrZXIsIGZvcmNlVG9WYWxpZD86IGJvb2xlYW4pOiBEYXRlUHJvZmlsZSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IG5leHREYXRlID0gZGF0ZUVudi5hZGQoXG4gICAgICBkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQsXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuYnVpbGQobmV4dERhdGUsIDEsIGZvcmNlVG9WYWxpZClcbiAgfVxuXG4gIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSBob2xkaW5nIGRhdGVzL3JhbmdlcyBmb3IgcmVuZGVyaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gZGF0ZS5cbiAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG4gIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICBidWlsZChjdXJyZW50RGF0ZTogRGF0ZU1hcmtlciwgZGlyZWN0aW9uPywgZm9yY2VUb1ZhbGlkID0gdHJ1ZSk6IERhdGVQcm9maWxlIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB2YWxpZFJhbmdlOiBEYXRlUmFuZ2VcbiAgICBsZXQgY3VycmVudEluZm9cbiAgICBsZXQgaXNSYW5nZUFsbERheVxuICAgIGxldCByZW5kZXJSYW5nZTogRGF0ZVJhbmdlXG4gICAgbGV0IGFjdGl2ZVJhbmdlOiBEYXRlUmFuZ2VcbiAgICBsZXQgaXNWYWxpZFxuXG4gICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKClcbiAgICB2YWxpZFJhbmdlID0gdGhpcy50cmltSGlkZGVuRGF5cyh2YWxpZFJhbmdlKVxuXG4gICAgaWYgKGZvcmNlVG9WYWxpZCkge1xuICAgICAgY3VycmVudERhdGUgPSBjb25zdHJhaW5NYXJrZXJUb1JhbmdlKGN1cnJlbnREYXRlLCB2YWxpZFJhbmdlKVxuICAgIH1cblxuICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oY3VycmVudERhdGUsIGRpcmVjdGlvbilcbiAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpXG4gICAgcmVuZGVyUmFuZ2UgPSB0aGlzLmJ1aWxkUmVuZGVyUmFuZ2UoXG4gICAgICB0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnJhbmdlKSxcbiAgICAgIGN1cnJlbnRJbmZvLnVuaXQsXG4gICAgICBpc1JhbmdlQWxsRGF5LFxuICAgIClcbiAgICByZW5kZXJSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyUmFuZ2UpXG4gICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZVxuXG4gICAgaWYgKCFwcm9wcy5zaG93Tm9uQ3VycmVudERhdGVzKSB7XG4gICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpXG4gICAgfVxuXG4gICAgYWN0aXZlUmFuZ2UgPSB0aGlzLmFkanVzdEFjdGl2ZVJhbmdlKGFjdGl2ZVJhbmdlKVxuICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKSAvLyBtaWdodCByZXR1cm4gbnVsbFxuXG4gICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgLy8gb3IgaWYgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgb3V0c2lkZSBvZiB0aGUgdmFsaWQgcmFuZ2UuXG4gICAgaXNWYWxpZCA9IHJhbmdlc0ludGVyc2VjdChjdXJyZW50SW5mby5yYW5nZSwgdmFsaWRSYW5nZSlcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxuICAgICAgLy8gYW4gb2JqZWN0IHdpdGggb3B0aW9uYWwgc3RhcnQgYW5kIGVuZCBwcm9wZXJ0aWVzLlxuICAgICAgdmFsaWRSYW5nZSxcblxuICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG4gICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuXG4gICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXG4gICAgICBjdXJyZW50UmFuZ2VVbml0OiBjdXJyZW50SW5mby51bml0LFxuXG4gICAgICBpc1JhbmdlQWxsRGF5LFxuXG4gICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcbiAgICAgIC8vIHdpbGwgYmUgYG51bGxgIGlmIG5vIGRhdGVzIGFjY2VwdCBldmVudHNcbiAgICAgIGFjdGl2ZVJhbmdlLFxuXG4gICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxuICAgICAgLy8gaW5jbHVkZXMgbm90LWFjdGl2ZSBkYXlzIHRoYXQgbmVlZCBzb21lIHNvcnQgb2YgRE9NXG4gICAgICByZW5kZXJSYW5nZSxcblxuICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZmlyc3QgdmlzaWJsZSB0aW1lIG9mIGFueSBnaXZlbiBkYXlcbiAgICAgIHNsb3RNaW5UaW1lOiBwcm9wcy5zbG90TWluVGltZSxcblxuICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgc2xvdE1heFRpbWU6IHByb3BzLnNsb3RNYXhUaW1lLFxuXG4gICAgICBpc1ZhbGlkLFxuXG4gICAgICAvLyBob3cgZmFyIHRoZSBjdXJyZW50IGRhdGUgd2lsbCBtb3ZlIGZvciBhIHByZXYvbmV4dCBvcGVyYXRpb25cbiAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKSxcbiAgICAgIC8vIHBhc3MgYSBmYWxsYmFjayAobWlnaHQgYmUgbnVsbCkgXlxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgLy8gSW5kaWNhdGVzIHRoZSBtaW5pbXVtL21heGltdW0gZGF0ZXMgdG8gZGlzcGxheS5cbiAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgYnVpbGRWYWxpZFJhbmdlKCk6IE9wZW5EYXRlUmFuZ2Uge1xuICAgIGxldCBpbnB1dCA9IHRoaXMucHJvcHMudmFsaWRSYW5nZUlucHV0XG4gICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgOiBpbnB1dFxuXG4gICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfSAvLyBjb21wbGV0ZWx5IG9wZW4tZW5kZWRcbiAgfVxuXG4gIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgdGhlIFwiY3VycmVudFwiIHJhbmdlLCB0aGUgcmFuZ2UgdGhhdCBpc1xuICAvLyBoaWdobGlnaHRlZCBhcyBiZWluZyB0aGUgY3VycmVudCBtb250aCBmb3IgZXhhbXBsZS5cbiAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXG4gIC8vIEd1YXJhbnRlZWQgdG8gaGF2ZSBgcmFuZ2VgIGFuZCBgdW5pdGAgcHJvcGVydGllcy4gYGR1cmF0aW9uYCBpcyBvcHRpb25hbC5cbiAgYnVpbGRDdXJyZW50UmFuZ2VJbmZvKGRhdGU6IERhdGVNYXJrZXIsIGRpcmVjdGlvbikge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IGR1cmF0aW9uID0gbnVsbFxuICAgIGxldCB1bml0ID0gbnVsbFxuICAgIGxldCByYW5nZSA9IG51bGxcbiAgICBsZXQgZGF5Q291bnRcblxuICAgIGlmIChwcm9wcy5kdXJhdGlvbikge1xuICAgICAgZHVyYXRpb24gPSBwcm9wcy5kdXJhdGlvblxuICAgICAgdW5pdCA9IHByb3BzLmR1cmF0aW9uVW5pdFxuICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdClcbiAgICB9IGVsc2UgaWYgKChkYXlDb3VudCA9IHRoaXMucHJvcHMuZGF5Q291bnQpKSB7XG4gICAgICB1bml0ID0gJ2RheSdcbiAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpXG4gICAgfSBlbHNlIGlmICgocmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xuICAgICAgdW5pdCA9IHByb3BzLmRhdGVFbnYuZ3JlYXRlc3RXaG9sZVVuaXQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCkudW5pdFxuICAgIH0gZWxzZSB7XG4gICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpXG4gICAgICB1bml0ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKS51bml0XG4gICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KVxuICAgIH1cblxuICAgIHJldHVybiB7IGR1cmF0aW9uLCB1bml0LCByYW5nZSB9XG4gIH1cblxuICBnZXRGYWxsYmFja0R1cmF0aW9uKCk6IER1cmF0aW9uIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXk6IDEgfSlcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAvLyBzbG90TWluVGltZSBvciBzbG90TWF4VGltZSBjYXVzZXMgdGhlIHJhbmdlIHRvIGV4cGFuZC5cbiAgYWRqdXN0QWN0aXZlUmFuZ2UocmFuZ2U6IERhdGVSYW5nZSkge1xuICAgIGxldCB7IGRhdGVFbnYsIHVzZXNNaW5NYXhUaW1lLCBzbG90TWluVGltZSwgc2xvdE1heFRpbWUgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZVxuXG4gICAgaWYgKHVzZXNNaW5NYXhUaW1lKSB7XG4gICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNaW5UaW1lIGlzIG5lZ2F0aXZlICh3aHkgbm90IHdoZW4gcG9zaXRpdmU/KVxuICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNaW5UaW1lKSA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KSAvLyBuZWNlc3Nhcnk/XG4gICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5hZGQoc3RhcnQsIHNsb3RNaW5UaW1lKVxuICAgICAgfVxuXG4gICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNYXhUaW1lIGlzIGJleW9uZCBvbmUgZGF5ICh3aHkgbm90IHdoZW4gbmVnYXRpdmU/KVxuICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNYXhUaW1lKSA+IDEpIHtcbiAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpIC8vIG5lY2Vzc2FyeT9cbiAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIC0xKVxuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIHNsb3RNYXhUaW1lKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxuICB9XG5cbiAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cbiAgLy8gYHVuaXRgIGlzIHRoZSBhbHJlYWR5LWNvbXB1dGVkIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciB1bml0IG9mIGR1cmF0aW9uLlxuICBidWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGU6IERhdGVNYXJrZXIsIGRpcmVjdGlvbiwgZHVyYXRpb246IER1cmF0aW9uLCB1bml0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBzdGFydDogRGF0ZU1hcmtlclxuICAgIGxldCBlbmQ6IERhdGVNYXJrZXJcbiAgICBsZXQgcmVzXG5cbiAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcbiAgICBpZiAoIWRhdGVBbGlnbm1lbnQpIHtcbiAgICAgIGxldCB7IGRhdGVJbmNyZW1lbnQgfSA9IHRoaXMucHJvcHNcblxuICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgaWYgKGFzUm91Z2hNcyhkYXRlSW5jcmVtZW50KSA8IGFzUm91Z2hNcyhkdXJhdGlvbikpIHtcbiAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgaWYgKGFzUm91Z2hEYXlzKGR1cmF0aW9uKSA8PSAxKSB7XG4gICAgICBpZiAodGhpcy5pc0hpZGRlbkRheShzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pXG4gICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlUmVzKCkge1xuICAgICAgc3RhcnQgPSBkYXRlRW52LnN0YXJ0T2YoZGF0ZSwgZGF0ZUFsaWdubWVudClcbiAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbilcbiAgICAgIHJlcyA9IHsgc3RhcnQsIGVuZCB9XG4gICAgfVxuXG4gICAgY29tcHV0ZVJlcygpXG5cbiAgICAvLyBpZiByYW5nZSBpcyBjb21wbGV0ZWx5IGVudmVsb3BlZCBieSBoaWRkZW4gZGF5cywgZ28gcGFzdCB0aGUgaGlkZGVuIGRheXNcbiAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKVxuICAgICAgY29tcHV0ZVJlcygpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxuICBidWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGU6IERhdGVNYXJrZXIsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBkYXRlQWxpZ25tZW50IH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHJ1bm5pbmdDb3VudCA9IDBcbiAgICBsZXQgc3RhcnQ6IERhdGVNYXJrZXIgPSBkYXRlXG4gICAgbGV0IGVuZDogRGF0ZU1hcmtlclxuXG4gICAgaWYgKGRhdGVBbGlnbm1lbnQpIHtcbiAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKHN0YXJ0LCBkYXRlQWxpZ25tZW50KVxuICAgIH1cblxuICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydClcbiAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbilcblxuICAgIGVuZCA9IHN0YXJ0XG4gICAgZG8ge1xuICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIDEpXG4gICAgICBpZiAoIXRoaXMuaXNIaWRkZW5EYXkoZW5kKSkge1xuICAgICAgICBydW5uaW5nQ291bnQgKz0gMVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KVxuXG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9XG4gIH1cblxuICAvLyBCdWlsZHMgYSBub3JtYWxpemVkIHJhbmdlIG9iamVjdCBmb3IgdGhlIFwidmlzaWJsZVwiIHJhbmdlLFxuICAvLyB3aGljaCBpcyBhIHdheSB0byBkZWZpbmUgdGhlIGN1cnJlbnRSYW5nZSBhbmQgYWN0aXZlUmFuZ2UgYXQgdGhlIHNhbWUgdGltZS5cbiAgYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZTogRGF0ZU1hcmtlcikge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IGlucHV0ID0gcHJvcHMudmlzaWJsZVJhbmdlSW5wdXRcbiAgICBsZXQgc2ltcGxlSW5wdXQgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbidcbiAgICAgID8gaW5wdXQuY2FsbChwcm9wcy5jYWxlbmRhckFwaSwgcHJvcHMuZGF0ZUVudi50b0RhdGUoZGF0ZSkpXG4gICAgICA6IGlucHV0XG5cbiAgICBsZXQgcmFuZ2UgPSB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KVxuXG4gICAgaWYgKHJhbmdlICYmIChyYW5nZS5zdGFydCA9PSBudWxsIHx8IHJhbmdlLmVuZCA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2VcbiAgfVxuXG4gIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxuICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZTogRGF0ZVJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRSYW5nZVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZHVyYXRpb24gdmFsdWUgdGhhdCBzaG91bGQgYmUgYWRkZWQvc3Vic3RyYWN0ZWQgdG8gdGhlIGN1cnJlbnQgZGF0ZVxuICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxuICBidWlsZERhdGVJbmNyZW1lbnQoZmFsbGJhY2spOiBEdXJhdGlvbiB7XG4gICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCBjdXN0b21BbGlnbm1lbnRcblxuICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0ZUluY3JlbWVudFxuICAgIH1cblxuICAgIGlmICgoY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5wcm9wcy5kYXRlQWxpZ25tZW50KSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudClcbiAgICB9XG5cbiAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgIHJldHVybiBmYWxsYmFja1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheXM6IDEgfSlcbiAgfVxuXG4gIHJlZmluZVJhbmdlKHJhbmdlSW5wdXQ6IERhdGVSYW5nZUlucHV0IHwgdW5kZWZpbmVkKTogRGF0ZVJhbmdlIHwgbnVsbCB7XG4gICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgIGxldCByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KVxuXG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuZ2VcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyogSGlkZGVuIERheXNcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBJbml0aWFsaXplcyBpbnRlcm5hbCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjYWxjdWxhdGluZyBoaWRkZW4gZGF5cy1vZi13ZWVrXG4gIGluaXRIaWRkZW5EYXlzKCkge1xuICAgIGxldCBoaWRkZW5EYXlzID0gdGhpcy5wcm9wcy5oaWRkZW5EYXlzIHx8IFtdIC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgbGV0IGlzSGlkZGVuRGF5SGFzaCA9IFtdIC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcbiAgICBsZXQgZGF5Q250ID0gMFxuICAgIGxldCBpXG5cbiAgICBpZiAodGhpcy5wcm9wcy53ZWVrZW5kcyA9PT0gZmFsc2UpIHtcbiAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KSAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpICs9IDEpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIShpc0hpZGRlbkRheUhhc2hbaV0gPSBoaWRkZW5EYXlzLmluZGV4T2YoaSkgIT09IC0xKVxuICAgICAgKSB7XG4gICAgICAgIGRheUNudCArPSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkYXlDbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJykgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cbiAgICB9XG5cbiAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaCA9IGlzSGlkZGVuRGF5SGFzaFxuICB9XG5cbiAgLy8gUmVtb3ZlIGRheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRoYXQgYXJlIGNvbXB1dGVkIGFzIGhpZGRlbi5cbiAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgdHJpbUhpZGRlbkRheXMocmFuZ2U6IERhdGVSYW5nZSk6IERhdGVSYW5nZSB8IG51bGwge1xuICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlXG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydClcbiAgICB9XG5cbiAgICBpZiAoZW5kKSB7XG4gICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpXG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xuICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIERhdGUgKHVzZWQgZm9yIFVUQylcbiAgaXNIaWRkZW5EYXkoZGF5KSB7XG4gICAgaWYgKGRheSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGRheSA9IGRheS5nZXRVVENEYXkoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XVxuICB9XG5cbiAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAvLyBJZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgZGF0ZWAgaXMgbm90IGEgaGlkZGVuIGRheSwgZG9uJ3QgZG8gYW55dGhpbmcuXG4gIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gIHNraXBIaWRkZW5EYXlzKGRhdGU6IERhdGVNYXJrZXIsIGluYyA9IDEsIGlzRXhjbHVzaXZlID0gZmFsc2UpIHtcbiAgICB3aGlsZSAoXG4gICAgICB0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XVxuICAgICkge1xuICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKVxuICAgIH1cbiAgICByZXR1cm4gZGF0ZVxuICB9XG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZVZpZXdUeXBlKHZpZXdUeXBlOiBzdHJpbmcsIGFjdGlvbjogQWN0aW9uKTogc3RyaW5nIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgdmlld1R5cGUgPSBhY3Rpb24udmlld1R5cGVcbiAgfVxuXG4gIHJldHVybiB2aWV3VHlwZVxufVxuIiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbjogQWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdTRVRfT1BUSU9OJzpcbiAgICAgIHJldHVybiB7IC4uLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIFthY3Rpb24ub3B0aW9uTmFtZV06IGFjdGlvbi5yYXdPcHRpb25WYWx1ZSB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVQcm9maWxlLCBEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VEYXRlUHJvZmlsZShcbiAgY3VycmVudERhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSB8IG51bGwsXG4gIGFjdGlvbjogQWN0aW9uLFxuICBjdXJyZW50RGF0ZTogRGF0ZU1hcmtlcixcbiAgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yLFxuKTogRGF0ZVByb2ZpbGUge1xuICBsZXQgZHA6IERhdGVQcm9maWxlXG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyIHx8IGN1cnJlbnREYXRlKVxuXG4gICAgY2FzZSAnQ0hBTkdFX0RBVEUnOlxuICAgICAgcmV0dXJuIGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGFjdGlvbi5kYXRlTWFya2VyKVxuXG4gICAgY2FzZSAnUFJFVic6XG4gICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKVxuICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGRwXG4gICAgICB9XG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnTkVYVCc6XG4gICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKVxuICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGRwXG4gICAgICB9XG4gICAgICBicmVha1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZVxufVxuIiwiaW1wb3J0IHsgRXZlbnRTb3VyY2UsIEV2ZW50U291cmNlSGFzaCB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc291cmNlJ1xuaW1wb3J0IHsgcGFyc2VFdmVudFNvdXJjZSwgYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UtcGFyc2UnXG5pbXBvcnQgeyBhcnJheVRvSGFzaCwgZmlsdGVySGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuaW1wb3J0IHsgZ3VpZCB9IGZyb20gJy4uL3V0aWwvbWlzYydcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4uL0NhbGVuZGFyQ29udGV4dCdcbmltcG9ydCB7IENhbGVuZGFyT3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMnXG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0RXZlbnRTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGxcblxuICByZXR1cm4gYWRkU291cmNlcyhcbiAgICB7fSxcbiAgICBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksXG4gICAgYWN0aXZlUmFuZ2UsXG4gICAgY29udGV4dCxcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKFxuICBldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCxcbiAgYWN0aW9uOiBBY3Rpb24sXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogRXZlbnRTb3VyY2VIYXNoIHtcbiAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGwgLy8gbmVlZCB0aGlzIGNoZWNrP1xuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dClcblxuICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZClcblxuICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICBjYXNlICdORVhUJzpcbiAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnRTb3VyY2VzXG5cbiAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhcbiAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICAoYWN0aW9uIGFzIGFueSkuc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XG4gICAgICAgICAgYXJyYXlUb0hhc2goKGFjdGlvbiBhcyBhbnkpLnNvdXJjZUlkcykgOlxuICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksXG4gICAgICAgIGFjdGl2ZVJhbmdlLFxuICAgICAgICBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuXG4gICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxuICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKVxuXG4gICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgIHJldHVybiB7fVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBldmVudFNvdXJjZXNcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzOiBFdmVudFNvdXJjZUhhc2gsIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsIC8vIG5lZWQgdGhpcyBjaGVjaz9cblxuICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoXG4gICAgZXZlbnRTb3VyY2VzLFxuICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksXG4gICAgYWN0aXZlUmFuZ2UsXG4gICAgdHJ1ZSxcbiAgICBjb250ZXh0LFxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCk6IGJvb2xlYW4ge1xuICBmb3IgKGxldCBzb3VyY2VJZCBpbiBldmVudFNvdXJjZXMpIHtcbiAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhZGRTb3VyY2VzKFxuICBldmVudFNvdXJjZUhhc2g6IEV2ZW50U291cmNlSGFzaCxcbiAgc291cmNlczogRXZlbnRTb3VyY2U8YW55PltdLFxuICBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pOiBFdmVudFNvdXJjZUhhc2gge1xuICBsZXQgaGFzaDogRXZlbnRTb3VyY2VIYXNoID0ge31cblxuICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGhhc2hbc291cmNlLnNvdXJjZUlkXSA9IHNvdXJjZVxuICB9XG5cbiAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICBoYXNoID0gZmV0Y2hEaXJ0eVNvdXJjZXMoaGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiB7IC4uLmV2ZW50U291cmNlSGFzaCwgLi4uaGFzaCB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZUhhc2g6IEV2ZW50U291cmNlSGFzaCwgc291cmNlSWQ6IHN0cmluZyk6IEV2ZW50U291cmNlSGFzaCB7XG4gIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgKGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+KSA9PiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQpXG59XG5cbmZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2g6IEV2ZW50U291cmNlSGFzaCwgZmV0Y2hSYW5nZTogRGF0ZVJhbmdlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFNvdXJjZUhhc2gge1xuICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoXG4gICAgc291cmNlSGFzaCxcbiAgICBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkpLFxuICAgIGZldGNoUmFuZ2UsXG4gICAgZmFsc2UsXG4gICAgY29udGV4dCxcbiAgKVxufVxuXG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+LCBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBpZiAoIWRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKSB7XG4gICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkXG4gIH1cbiAgcmV0dXJuICFjb250ZXh0Lm9wdGlvbnMubGF6eUZldGNoaW5nIHx8XG4gICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcbiAgICAgIGZldGNoUmFuZ2Uuc3RhcnQgPCBldmVudFNvdXJjZS5mZXRjaFJhbmdlLnN0YXJ0IHx8XG4gICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kXG59XG5cbmZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKFxuICBwcmV2U291cmNlczogRXZlbnRTb3VyY2VIYXNoLFxuICBzb3VyY2VJZEhhc2g6IHsgW3NvdXJjZUlkOiBzdHJpbmddOiBhbnkgfSxcbiAgZmV0Y2hSYW5nZTogRGF0ZVJhbmdlLFxuICBpc1JlZmV0Y2g6IGJvb2xlYW4sXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbik6IEV2ZW50U291cmNlSGFzaCB7XG4gIGxldCBuZXh0U291cmNlczogRXZlbnRTb3VyY2VIYXNoID0ge31cblxuICBmb3IgKGxldCBzb3VyY2VJZCBpbiBwcmV2U291cmNlcykge1xuICAgIGxldCBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF1cblxuICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XG4gICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dClcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dFNvdXJjZXNbc291cmNlSWRdID0gc291cmNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTb3VyY2VzXG59XG5cbmZ1bmN0aW9uIGZldGNoU291cmNlKGV2ZW50U291cmNlOiBFdmVudFNvdXJjZTxhbnk+LCBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UsIGlzUmVmZXRjaDogYm9vbGVhbiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCB7IG9wdGlvbnMsIGNhbGVuZGFyQXBpIH0gPSBjb250ZXh0XG4gIGxldCBzb3VyY2VEZWYgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF1cbiAgbGV0IGZldGNoSWQgPSBndWlkKClcblxuICBzb3VyY2VEZWYuZmV0Y2goXG4gICAge1xuICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICByYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgIGlzUmVmZXRjaCxcbiAgICAgIGNvbnRleHQsXG4gICAgfSxcbiAgICAocmVzKSA9PiB7IC8vIHN1Y2Nlc3MgY2FsbGJhY2tcbiAgICAgIGxldCB7IHJhd0V2ZW50cyB9ID0gcmVzXG5cbiAgICAgIGlmIChvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcykge1xuICAgICAgICByYXdFdmVudHMgPSBvcHRpb25zLmV2ZW50U291cmNlU3VjY2Vzcy5jYWxsKGNhbGVuZGFyQXBpLCByYXdFdmVudHMsIHJlcy54aHIpIHx8IHJhd0V2ZW50c1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRTb3VyY2Uuc3VjY2Vzcykge1xuICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnhocikgfHwgcmF3RXZlbnRzXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVFMnLFxuICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIGZldGNoSWQsXG4gICAgICAgIGZldGNoUmFuZ2UsXG4gICAgICAgIHJhd0V2ZW50cyxcbiAgICAgIH0pXG4gICAgfSxcbiAgICAoZXJyb3IpID0+IHsgLy8gZmFpbHVyZSBjYWxsYmFja1xuICAgICAgY29uc29sZS53YXJuKGVycm9yLm1lc3NhZ2UsIGVycm9yKVxuXG4gICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUpIHtcbiAgICAgICAgb3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUuY2FsbChjYWxlbmRhckFwaSwgZXJyb3IpXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgIGV2ZW50U291cmNlLmZhaWx1cmUoZXJyb3IpXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXG4gICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgZmV0Y2hJZCxcbiAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9KVxuICAgIH0sXG4gIClcblxuICByZXR1cm4ge1xuICAgIC4uLmV2ZW50U291cmNlLFxuICAgIGlzRmV0Y2hpbmc6IHRydWUsXG4gICAgbGF0ZXN0RmV0Y2hJZDogZmV0Y2hJZCxcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNlaXZlUmVzcG9uc2Uoc291cmNlSGFzaDogRXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZDogc3RyaW5nLCBmZXRjaElkOiBzdHJpbmcsIGZldGNoUmFuZ2U6IERhdGVSYW5nZSkge1xuICBsZXQgZXZlbnRTb3VyY2U6IEV2ZW50U291cmNlPGFueT4gPSBzb3VyY2VIYXNoW3NvdXJjZUlkXVxuXG4gIGlmIChcbiAgICBldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZFxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc291cmNlSGFzaCxcbiAgICAgIFtzb3VyY2VJZF06IHtcbiAgICAgICAgLi4uZXZlbnRTb3VyY2UsXG4gICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICBmZXRjaFJhbmdlLCAvLyBhbHNvIHNlcnZlcyBhcyBhIG1hcmtlciB0aGF0IGF0IGxlYXN0IG9uZSBmZXRjaCBoYXMgY29tcGxldGVkXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzb3VyY2VIYXNoXG59XG5cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlczogRXZlbnRTb3VyY2VIYXNoLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFNvdXJjZUhhc2gge1xuICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpXG59XG5cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9uczogQ2FsZW5kYXJPcHRpb25zLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IHJlZmluZXJzID0gYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzKGNvbnRleHQpXG4gIGxldCByYXdTb3VyY2VzID0gW10uY29uY2F0KHJhd09wdGlvbnMuZXZlbnRTb3VyY2VzIHx8IFtdKVxuICBsZXQgc291cmNlcyA9IFtdIC8vIHBhcnNlZFxuXG4gIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcbiAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKVxuICB9XG5cbiAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuZXZlbnRzKVxuICB9XG5cbiAgZm9yIChsZXQgcmF3U291cmNlIG9mIHJhd1NvdXJjZXMpIHtcbiAgICBsZXQgc291cmNlID0gcGFyc2VFdmVudFNvdXJjZShyYXdTb3VyY2UsIGNvbnRleHQsIHJlZmluZXJzKVxuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZXNcbn1cblxuZnVuY3Rpb24gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnNcblxuICByZXR1cm4gIWRlZnNbZXZlbnRTb3VyY2Uuc291cmNlRGVmSWRdLmlnbm9yZVJhbmdlXG59XG4iLCJpbXBvcnQgeyBmaWx0ZXJIYXNoLCBtYXBIYXNoIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBFdmVudERlZiB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtZGVmJ1xuaW1wb3J0IHsgRXZlbnRJbnN0YW5jZSwgRXZlbnRJbnN0YW5jZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LWluc3RhbmNlJ1xuaW1wb3J0IHsgRXZlbnRJbnB1dCB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtcGFyc2UnXG5pbXBvcnQge1xuICBFdmVudFN0b3JlLFxuICBtZXJnZUV2ZW50U3RvcmVzLFxuICBjcmVhdGVFbXB0eUV2ZW50U3RvcmUsXG4gIGZpbHRlckV2ZW50U3RvcmVEZWZzLFxuICBleGNsdWRlU3ViRXZlbnRTdG9yZSxcbiAgcGFyc2VFdmVudHMsXG59IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IEV2ZW50U291cmNlSGFzaCwgRXZlbnRTb3VyY2UgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBleHBhbmRSZWN1cnJpbmcgfSBmcm9tICcuLi9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudCdcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUV2ZW50U3RvcmUoXG4gIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsXG4gIGFjdGlvbjogQWN0aW9uLFxuICBldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCxcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pOiBFdmVudFN0b3JlIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhcbiAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgZXZlbnRTb3VyY2VzW2FjdGlvbi5zb3VyY2VJZF0sXG4gICAgICAgIGFjdGlvbi5mZXRjaElkLFxuICAgICAgICBhY3Rpb24uZmV0Y2hSYW5nZSxcbiAgICAgICAgYWN0aW9uLnJhd0V2ZW50cyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgIClcblxuICAgIGNhc2UgJ0FERF9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCwgYnV0IG5vdCBleHBhbmRlZFxuICAgICAgcmV0dXJuIGFkZEV2ZW50KFxuICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcbiAgICAgICAgZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGwsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApXG5cbiAgICBjYXNlICdSRVNFVF9FVkVOVFMnOlxuICAgICAgcmV0dXJuIGFjdGlvbi5ldmVudFN0b3JlXG5cbiAgICBjYXNlICdNRVJHRV9FVkVOVFMnOiAvLyBhbHJlYWR5IHBhcnNlZCBhbmQgZXhwYW5kZWRcbiAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKVxuXG4gICAgY2FzZSAnUFJFVic6IC8vIFRPRE86IGhvdyBkbyB3ZSB0cmFjayBhbGwgYWN0aW9ucyB0aGF0IGFmZmVjdCBkYXRlUHJvZmlsZSA6KFxuICAgIGNhc2UgJ05FWFQnOlxuICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgIGlmIChkYXRlUHJvZmlsZSkge1xuICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV2ZW50U3RvcmVcblxuICAgIGNhc2UgJ1JFTU9WRV9FVkVOVFMnOlxuICAgICAgcmV0dXJuIGV4Y2x1ZGVTdWJFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbi5ldmVudFN0b3JlKVxuXG4gICAgY2FzZSAnUkVNT1ZFX0VWRU5UX1NPVVJDRSc6XG4gICAgICByZXR1cm4gZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgYWN0aW9uLnNvdXJjZUlkKVxuXG4gICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAoZXZlbnREZWY6IEV2ZW50RGVmKSA9PiAoXG4gICAgICAgICFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICApKVxuXG4gICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV2ZW50U3RvcmVcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKFxuICBldmVudFN0b3JlOiBFdmVudFN0b3JlLFxuICBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PixcbiAgZmV0Y2hJZDogc3RyaW5nLFxuICBmZXRjaFJhbmdlOiBEYXRlUmFuZ2UgfCBudWxsLFxuICByYXdFdmVudHM6IEV2ZW50SW5wdXRbXSxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogRXZlbnRTdG9yZSB7XG4gIGlmIChcbiAgICBldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICkge1xuICAgIGxldCBzdWJzZXQgPSBwYXJzZUV2ZW50cyhcbiAgICAgIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSxcbiAgICAgIGV2ZW50U291cmNlLFxuICAgICAgY29udGV4dCxcbiAgICApXG5cbiAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dClcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhcbiAgICAgIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSxcbiAgICAgIHN1YnNldCxcbiAgICApXG4gIH1cblxuICByZXR1cm4gZXZlbnRTdG9yZVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZTogRXZlbnRTb3VyY2U8YW55PiwgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybVxuICBsZXQgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbFxuXG4gIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XG4gICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgc291cmNlRWFjaFRyYW5zZm9ybSlcbiAgfVxuXG4gIGlmIChjYWxFYWNoVHJhbnNmb3JtKSB7XG4gICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSlcbiAgfVxuXG4gIHJldHVybiByYXdFdmVudHNcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgZnVuYykge1xuICBsZXQgcmVmaW5lZEV2ZW50c1xuXG4gIGlmICghZnVuYykge1xuICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHNcbiAgfSBlbHNlIHtcbiAgICByZWZpbmVkRXZlbnRzID0gW11cblxuICAgIGZvciAobGV0IHJhd0V2ZW50IG9mIHJhd0V2ZW50cykge1xuICAgICAgbGV0IHJlZmluZWRFdmVudCA9IGZ1bmMocmF3RXZlbnQpXG5cbiAgICAgIGlmIChyZWZpbmVkRXZlbnQpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudClcbiAgICAgIH0gZWxzZSBpZiAocmVmaW5lZEV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJhd0V2ZW50KVxuICAgICAgfSAvLyBpZiBhIGRpZmZlcmVudCBmYWxzeSB2YWx1ZSwgZG8gbm90aGluZ1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpbmVkRXZlbnRzXG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50KGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIHN1YnNldDogRXZlbnRTdG9yZSwgZXhwYW5kUmFuZ2U6IERhdGVSYW5nZSB8IG51bGwsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCk6IEV2ZW50U3RvcmUge1xuICBpZiAoZXhwYW5kUmFuZ2UpIHtcbiAgICBzdWJzZXQgPSBleHBhbmRSZWN1cnJpbmcoc3Vic2V0LCBleHBhbmRSYW5nZSwgY29udGV4dClcbiAgfVxuXG4gIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV2ZW50U3RvcmUsIHN1YnNldClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBvbGREYXRlRW52OiBEYXRlRW52LCBuZXdEYXRlRW52OiBEYXRlRW52KTogRXZlbnRTdG9yZSB7XG4gIGxldCB7IGRlZnMgfSA9IGV2ZW50U3RvcmVcblxuICBsZXQgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlOiBFdmVudEluc3RhbmNlKTogRXZlbnRJbnN0YW5jZSA9PiB7XG4gICAgbGV0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdXG5cbiAgICBpZiAoZGVmLmFsbERheSB8fCBkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5pbnN0YW5jZSxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHN0YXJ0OiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8pKSxcbiAgICAgICAgZW5kOiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5lbmQsIGluc3RhbmNlLmZvcmNlZEVuZFR6bykpLFxuICAgICAgfSxcbiAgICAgIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICBmb3JjZWRFbmRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9XG59XG5cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsIHNvdXJjZUlkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZjogRXZlbnREZWYpID0+IGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZClcbn1cblxuLy8gUVVFU1RJT046IHdoeSBub3QganVzdCByZXR1cm4gaW5zdGFuY2VzPyBkbyBhIGdlbmVyYWwgb2JqZWN0LXByb3BlcnR5LWV4Y2x1c2lvbiB1dGlsXG5leHBvcnQgZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCByZW1vdmFsczogRXZlbnRJbnN0YW5jZUhhc2gpOiBFdmVudFN0b3JlIHtcbiAgcmV0dXJuIHtcbiAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2U6IEV2ZW50SW5zdGFuY2UpID0+ICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSksXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVTcGFuIH0gZnJvbSAnLi4vc3RydWN0cy9kYXRlLXNwYW4nXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbjogRGF0ZVNwYW4gfCBudWxsLCBhY3Rpb246IEFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnVU5TRUxFQ1RfREFURVMnOlxuICAgICAgcmV0dXJuIG51bGxcblxuICAgIGNhc2UgJ1NFTEVDVF9EQVRFUyc6XG4gICAgICByZXR1cm4gYWN0aW9uLnNlbGVjdGlvblxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uXG4gIH1cbn1cbiIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlU2VsZWN0ZWRFdmVudChjdXJyZW50SW5zdGFuY2VJZDogc3RyaW5nLCBhY3Rpb246IEFjdGlvbik6IHN0cmluZyB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdVTlNFTEVDVF9FVkVOVCc6XG4gICAgICByZXR1cm4gJydcblxuICAgIGNhc2UgJ1NFTEVDVF9FVkVOVCc6XG4gICAgICByZXR1cm4gYWN0aW9uLmV2ZW50SW5zdGFuY2VJZFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2VJZFxuICB9XG59XG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL0FjdGlvbidcbmltcG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4uL2ludGVyYWN0aW9ucy9ldmVudC1pbnRlcmFjdGlvbi1zdGF0ZSdcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUV2ZW50RHJhZyhjdXJyZW50RHJhZzogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbCwgYWN0aW9uOiBBY3Rpb24pOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsIHtcbiAgbGV0IG5ld0RyYWc6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZVxuXG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdVTlNFVF9FVkVOVF9EUkFHJzpcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICBuZXdEcmFnID0gYWN0aW9uLnN0YXRlXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdEcmFnLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdEcmFnLm11dGF0ZWRFdmVudHMsXG4gICAgICAgIGlzRXZlbnQ6IG5ld0RyYWcuaXNFdmVudCxcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY3VycmVudERyYWdcbiAgfVxufVxuIiwiaW1wb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nXG5cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VFdmVudFJlc2l6ZShjdXJyZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsLCBhY3Rpb246IEFjdGlvbik6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGwge1xuICBsZXQgbmV3UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGVcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSAnVU5TRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgIG5ld1Jlc2l6ZSA9IGFjdGlvbi5zdGF0ZVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZmZlY3RlZEV2ZW50czogbmV3UmVzaXplLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICBtdXRhdGVkRXZlbnRzOiBuZXdSZXNpemUubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemVcbiAgfVxufVxuIiwiaW1wb3J0IHsgVmlld1NwZWMsIFZpZXdTcGVjSGFzaCB9IGZyb20gJy4vc3RydWN0cy92aWV3LXNwZWMnXG5pbXBvcnQgeyBUaGVtZSB9IGZyb20gJy4vdGhlbWUvVGhlbWUnXG5pbXBvcnQgeyBtYXBIYXNoIH0gZnJvbSAnLi91dGlsL29iamVjdCdcbmltcG9ydCB7IENhbGVuZGFyQXBpIH0gZnJvbSAnLi9DYWxlbmRhckFwaSdcbmltcG9ydCB7IENhbGVuZGFyT3B0aW9uc1JlZmluZWQsIENhbGVuZGFyT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCB7IFRvb2xiYXJJbnB1dCwgVG9vbGJhck1vZGVsLCBUb29sYmFyV2lkZ2V0LCBDdXN0b21CdXR0b25JbnB1dCB9IGZyb20gJy4vdG9vbGJhci1zdHJ1Y3QnXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRvb2xiYXJzKFxuICBjYWxlbmRhck9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gIHRoZW1lOiBUaGVtZSxcbiAgdmlld1NwZWNzOiBWaWV3U3BlY0hhc2gsXG4gIGNhbGVuZGFyQXBpOiBDYWxlbmRhckFwaSxcbikge1xuICBsZXQgdmlld3NXaXRoQnV0dG9uczogc3RyaW5nW10gPSBbXVxuICBsZXQgaGVhZGVyVG9vbGJhciA9IGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKFxuICAgIGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyLFxuICAgIGNhbGVuZGFyT3B0aW9ucyxcbiAgICBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcyxcbiAgICB0aGVtZSxcbiAgICB2aWV3U3BlY3MsXG4gICAgY2FsZW5kYXJBcGksXG4gICAgdmlld3NXaXRoQnV0dG9ucyxcbiAgKSA6IG51bGxcbiAgbGV0IGZvb3RlclRvb2xiYXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihcbiAgICBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhcixcbiAgICBjYWxlbmRhck9wdGlvbnMsXG4gICAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsXG4gICAgdGhlbWUsXG4gICAgdmlld1NwZWNzLFxuICAgIGNhbGVuZGFyQXBpLFxuICAgIHZpZXdzV2l0aEJ1dHRvbnMsXG4gICkgOiBudWxsXG5cbiAgcmV0dXJuIHsgaGVhZGVyVG9vbGJhciwgZm9vdGVyVG9vbGJhciwgdmlld3NXaXRoQnV0dG9ucyB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihcbiAgc2VjdGlvblN0ckhhc2g6IFRvb2xiYXJJbnB1dCxcbiAgY2FsZW5kYXJPcHRpb25zOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICBjYWxlbmRhck9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICB0aGVtZTogVGhlbWUsXG4gIHZpZXdTcGVjczogVmlld1NwZWNIYXNoLFxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGksXG4gIHZpZXdzV2l0aEJ1dHRvbnM6IHN0cmluZ1tdLCAvLyBkdW1wIHNpZGUgZWZmZWN0c1xuKSA6IFRvb2xiYXJNb2RlbCB7XG4gIHJldHVybiBtYXBIYXNoKFxuICAgIHNlY3Rpb25TdHJIYXNoIGFzIHsgW3NlY3Rpb246IHN0cmluZ106IHN0cmluZyB9LFxuICAgIChzZWN0aW9uU3RyKSA9PiBwYXJzZVNlY3Rpb24oc2VjdGlvblN0ciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGksIHZpZXdzV2l0aEJ1dHRvbnMpLFxuICApXG59XG5cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKFxuICBzZWN0aW9uU3RyOiBzdHJpbmcsXG4gIGNhbGVuZGFyT3B0aW9uczogQ2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgY2FsZW5kYXJPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgdGhlbWU6IFRoZW1lLFxuICB2aWV3U3BlY3M6IFZpZXdTcGVjSGFzaCxcbiAgY2FsZW5kYXJBcGk6IENhbGVuZGFyQXBpLFxuICB2aWV3c1dpdGhCdXR0b25zOiBzdHJpbmdbXSwgLy8gZHVtcCBzaWRlIGVmZmVjdHNcbik6IFRvb2xiYXJXaWRnZXRbXVtdIHtcbiAgbGV0IGlzUnRsID0gY2FsZW5kYXJPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCdcbiAgbGV0IGNhbGVuZGFyQ3VzdG9tQnV0dG9ucyA9IGNhbGVuZGFyT3B0aW9ucy5jdXN0b21CdXR0b25zIHx8IHt9XG4gIGxldCBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9XG4gIGxldCBjYWxlbmRhckJ1dHRvblRleHQgPSBjYWxlbmRhck9wdGlvbnMuYnV0dG9uVGV4dCB8fCB7fVxuICBsZXQgc2VjdGlvblN1YnN0cnMgPSBzZWN0aW9uU3RyID8gc2VjdGlvblN0ci5zcGxpdCgnICcpIDogW11cblxuICByZXR1cm4gc2VjdGlvblN1YnN0cnMubWFwKFxuICAgIChidXR0b25Hcm91cFN0cik6IFRvb2xiYXJXaWRnZXRbXSA9PiAoXG4gICAgICBidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLm1hcCgoYnV0dG9uTmFtZSk6IFRvb2xiYXJXaWRnZXQgPT4ge1xuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1c3RvbUJ1dHRvblByb3BzOiBDdXN0b21CdXR0b25JbnB1dFxuICAgICAgICBsZXQgdmlld1NwZWM6IFZpZXdTcGVjXG4gICAgICAgIGxldCBidXR0b25DbGlja1xuICAgICAgICBsZXQgYnV0dG9uSWNvbiAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICBsZXQgYnV0dG9uVGV4dCAvLyBcIlxuXG4gICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgYnV0dG9uQ2xpY2sgPSAoZXY6IFVJRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xuICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGV2LnRhcmdldCwgZXYsIGV2LnRhcmdldCkgLy8gVE9ETzogdXNlIENhbGVuZGFyIHRoaXMgY29udGV4dD9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcbiAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gY3VzdG9tQnV0dG9uUHJvcHMudGV4dClcbiAgICAgICAgfSBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY3NbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoKGJ1dHRvbk5hbWUpXG5cbiAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxuICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lLCBpc1J0bCkpIHx8XG4gICAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dERlZmF1bHQpXG4gICAgICAgIH0gZWxzZSBpZiAoY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhckFwaSBtZXRob2RcbiAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKClcbiAgICAgICAgICB9O1xuICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0T3ZlcnJpZGVzW2J1dHRvbk5hbWVdKSB8fFxuICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIF4gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvbkljb24sIGJ1dHRvblRleHQgfVxuICAgICAgfSlcbiAgICApLFxuICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW4tc3lzdGVtJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VEZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1kZWYnXG5pbXBvcnQgeyBFdmVudElucHV0IH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcblxubGV0IGV2ZW50U291cmNlRGVmOiBFdmVudFNvdXJjZURlZjxFdmVudElucHV0W10+ID0ge1xuICBpZ25vcmVSYW5nZTogdHJ1ZSxcblxuICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xuICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH0sXG5cbiAgZmV0Y2goYXJnLCBzdWNjZXNzKSB7XG4gICAgc3VjY2Vzcyh7XG4gICAgICByYXdFdmVudHM6IGFyZy5ldmVudFNvdXJjZS5tZXRhLFxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBhcnJheUV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSlcbiIsImltcG9ydCB7IHVucHJvbWlzaWZ5IH0gZnJvbSAnLi4vdXRpbC9wcm9taXNlJ1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VEZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1kZWYnXG5pbXBvcnQgeyBFdmVudFNvdXJjZUVycm9yIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5pbXBvcnQgeyBFdmVudElucHV0IH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1wYXJzZSdcbmltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJy4uL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIH0gZnJvbSAnLi4vc3RydWN0cy9kYXRlLXNwYW4nXG5cbmV4cG9ydCB0eXBlIEV2ZW50U291cmNlRnVuYyA9IChcbiAgYXJnOiB7XG4gICAgc3RhcnQ6IERhdGVcbiAgICBlbmQ6IERhdGVcbiAgICBzdGFydFN0cjogc3RyaW5nXG4gICAgZW5kU3RyOiBzdHJpbmdcbiAgICB0aW1lWm9uZTogc3RyaW5nXG4gIH0sXG4gIHN1Y2Nlc3NDYWxsYmFjazogKGV2ZW50czogRXZlbnRJbnB1dFtdKSA9PiB2b2lkLFxuICBmYWlsdXJlQ2FsbGJhY2s6IChlcnJvcjogRXZlbnRTb3VyY2VFcnJvcikgPT4gdm9pZFxuKSA9PiAodm9pZCB8IFByb21pc2VMaWtlPEV2ZW50SW5wdXRbXT4pXG5cbmxldCBldmVudFNvdXJjZURlZjogRXZlbnRTb3VyY2VEZWY8RXZlbnRTb3VyY2VGdW5jPiA9IHtcblxuICBwYXJzZU1ldGEocmVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmVmaW5lZC5ldmVudHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiByZWZpbmVkLmV2ZW50c1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9LFxuXG4gIGZldGNoKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IGFyZy5jb250ZXh0XG4gICAgbGV0IGZ1bmMgPSBhcmcuZXZlbnRTb3VyY2UubWV0YVxuXG4gICAgdW5wcm9taXNpZnkoXG4gICAgICBmdW5jLmJpbmQobnVsbCwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShhcmcucmFuZ2UsIGRhdGVFbnYpKSxcbiAgICAgIChyYXdFdmVudHMpID0+IHsgLy8gc3VjY2Vzc1xuICAgICAgICBzdWNjZXNzKHsgcmF3RXZlbnRzIH0pIC8vIG5lZWRzIGFuIG9iamVjdCByZXNwb25zZVxuICAgICAgfSxcbiAgICAgIGZhaWx1cmUsIC8vIHNlbmQgZXJyb3JPYmogZGlyZWN0bHkgdG8gZmFpbHVyZSBjYWxsYmFja1xuICAgIClcbiAgfSxcblxufVxuXG5leHBvcnQgY29uc3QgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSlcbiIsImltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kOiBzdHJpbmcsIHVybDogc3RyaW5nLCBwYXJhbXM6IERpY3Rpb25hcnksIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG5cbiAgbGV0IGJvZHkgPSBudWxsXG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICB1cmwgPSBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcylcbiAgfSBlbHNlIHtcbiAgICBib2R5ID0gZW5jb2RlUGFyYW1zKHBhcmFtcylcbiAgfVxuXG4gIGxldCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSlcblxuICBpZiAobWV0aG9kICE9PSAnR0VUJykge1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcbiAgfVxuXG4gIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCA0MDApIHtcbiAgICAgIGxldCBwYXJzZWQgPSBmYWxzZVxuICAgICAgbGV0IHJlc1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXMgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpXG4gICAgICAgIHBhcnNlZCA9IHRydWVcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3aWxsIGhhbmRsZSBwYXJzZWQ9ZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBzdWNjZXNzQ2FsbGJhY2socmVzLCB4aHIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ0ZhaWx1cmUgcGFyc2luZyBKU09OJywgeGhyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmYWlsdXJlQ2FsbGJhY2soJ1JlcXVlc3QgZmFpbGVkJywgeGhyKVxuICAgIH1cbiAgfVxuXG4gIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpXG4gIH1cblxuICB4aHIuc2VuZChib2R5KVxufVxuXG5mdW5jdGlvbiBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmw6IHN0cmluZywgcGFyYW1zKSB7XG4gIHJldHVybiB1cmwgK1xuICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgIGVuY29kZVBhcmFtcyhwYXJhbXMpXG59XG5cbmZ1bmN0aW9uIGVuY29kZVBhcmFtcyhwYXJhbXMpIHtcbiAgbGV0IHBhcnRzID0gW11cblxuICBmb3IgKGxldCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgcGFydHMucHVzaChgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pfWApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJicpXG59XG4iLCJpbXBvcnQgeyBpZGVudGl0eSwgSWRlbnRpdHksIERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgY29uc3QgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgbWV0aG9kOiBTdHJpbmcsXG4gIGV4dHJhUGFyYW1zOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWN0aW9uYXJ5IHwgKCgpID0+IERpY3Rpb25hcnkpPixcbiAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICBlbmRQYXJhbTogU3RyaW5nLFxuICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG59XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJ1xuaW1wb3J0IHsgcmVxdWVzdEpzb24gfSBmcm9tICcuLi91dGlsL3JlcXVlc3RKc29uJ1xuaW1wb3J0IHsgQ2FsZW5kYXJDb250ZXh0IH0gZnJvbSAnLi4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgRXZlbnRTb3VyY2VEZWYgfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZS1kZWYnXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuLi9wbHVnaW4tc3lzdGVtJ1xuaW1wb3J0IHsgSlNPTl9GRUVEX0VWRU5UX1NPVVJDRV9SRUZJTkVSUyB9IGZyb20gJy4vanNvbi1mZWVkLWV2ZW50LXNvdXJjZS1yZWZpbmVycydcblxuaW50ZXJmYWNlIEpzb25GZWVkTWV0YSB7XG4gIHVybDogc3RyaW5nXG4gIGZvcm1hdDogJ2pzb24nIC8vIGZvciBFdmVudFNvdXJjZUFwaVxuICBtZXRob2Q6IHN0cmluZ1xuICBleHRyYVBhcmFtcz86IGFueVxuICBzdGFydFBhcmFtPzogc3RyaW5nXG4gIGVuZFBhcmFtPzogc3RyaW5nXG4gIHRpbWVab25lUGFyYW0/OiBzdHJpbmdcbn1cblxubGV0IGV2ZW50U291cmNlRGVmOiBFdmVudFNvdXJjZURlZjxKc29uRmVlZE1ldGE+ID0ge1xuXG4gIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgZXh0cmFQYXJhbXM6IHJlZmluZWQuZXh0cmFQYXJhbXMsXG4gICAgICAgIHN0YXJ0UGFyYW06IHJlZmluZWQuc3RhcnRQYXJhbSxcbiAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgIHRpbWVab25lUGFyYW06IHJlZmluZWQudGltZVpvbmVQYXJhbSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcblxuICBmZXRjaChhcmcsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICBsZXQgeyBtZXRhIH0gPSBhcmcuZXZlbnRTb3VyY2VcbiAgICBsZXQgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jb250ZXh0KVxuXG4gICAgcmVxdWVzdEpzb24oXG4gICAgICBtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMsXG4gICAgICAocmF3RXZlbnRzLCB4aHIpID0+IHtcbiAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50cywgeGhyIH0pXG4gICAgICB9LFxuICAgICAgKGVycm9yTWVzc2FnZSwgeGhyKSA9PiB7XG4gICAgICAgIGZhaWx1cmUoeyBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsIHhociB9KVxuICAgICAgfSxcbiAgICApXG4gIH0sXG5cbn1cblxuZXhwb3J0IGNvbnN0IGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICBldmVudFNvdXJjZVJlZmluZXJzOiBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTLFxuICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG59KVxuXG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YTogSnNvbkZlZWRNZXRhLCByYW5nZTogRGF0ZVJhbmdlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dFxuICBsZXQgc3RhcnRQYXJhbVxuICBsZXQgZW5kUGFyYW1cbiAgbGV0IHRpbWVab25lUGFyYW1cbiAgbGV0IGN1c3RvbVJlcXVlc3RQYXJhbXNcbiAgbGV0IHBhcmFtcyA9IHt9XG5cbiAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbVxuICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgc3RhcnRQYXJhbSA9IG9wdGlvbnMuc3RhcnRQYXJhbVxuICB9XG5cbiAgZW5kUGFyYW0gPSBtZXRhLmVuZFBhcmFtXG4gIGlmIChlbmRQYXJhbSA9PSBudWxsKSB7XG4gICAgZW5kUGFyYW0gPSBvcHRpb25zLmVuZFBhcmFtXG4gIH1cblxuICB0aW1lWm9uZVBhcmFtID0gbWV0YS50aW1lWm9uZVBhcmFtXG4gIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtXG4gIH1cblxuICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zKClcbiAgfSBlbHNlIHtcbiAgICAvLyBwcm9iYWJseSBzdXBwbGllZCBhcyBhIHN0cmFpZ2h0IGtleS92YWx1ZSBvYmplY3RcbiAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fVxuICB9XG5cbiAgX19hc3NpZ24ocGFyYW1zLCBjdXN0b21SZXF1ZXN0UGFyYW1zKVxuXG4gIHBhcmFtc1tzdGFydFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KVxuICBwYXJhbXNbZW5kUGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKVxuXG4gIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgcGFyYW1zW3RpbWVab25lUGFyYW1dID0gZGF0ZUVudi50aW1lWm9uZVxuICB9XG5cbiAgcmV0dXJuIHBhcmFtc1xufVxuIiwiaW1wb3J0IHsgY3JlYXRlRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgRGF0ZUlucHV0IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBpZGVudGl0eSwgSWRlbnRpdHkgfSBmcm9tICcuLi9vcHRpb25zJ1xuXG5leHBvcnQgY29uc3QgU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyA9IHtcbiAgZGF5c09mV2VlazogaWRlbnRpdHkgYXMgSWRlbnRpdHk8bnVtYmVyW10+LFxuICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICBlbmRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICBzdGFydFJlY3VyOiBpZGVudGl0eSBhcyBJZGVudGl0eTxEYXRlSW5wdXQ+LFxuICBlbmRSZWN1cjogaWRlbnRpdHkgYXMgSWRlbnRpdHk8RGF0ZUlucHV0Pixcbn1cbiIsImltcG9ydCB7IHN0YXJ0T2ZEYXksIGFkZERheXMsIERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IER1cmF0aW9uLCBzdWJ0cmFjdER1cmF0aW9ucyB9IGZyb20gJy4uL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBhcnJheVRvSGFzaCB9IGZyb20gJy4uL3V0aWwvb2JqZWN0J1xuaW1wb3J0IHsgUmVjdXJyaW5nVHlwZSB9IGZyb20gJy4vcmVjdXJyaW5nLWV2ZW50J1xuaW1wb3J0IHsgRXZlbnRSZWZpbmVkIH0gZnJvbSAnLi9ldmVudC1wYXJzZSdcbmltcG9ydCB7IERhdGVSYW5nZSwgaW50ZXJzZWN0UmFuZ2VzIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZUVudiB9IGZyb20gJy4uL2RhdGVsaWIvZW52J1xuaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgfSBmcm9tICcuL3JlY3VycmluZy1ldmVudC1zaW1wbGUtcmVmaW5lcnMnXG5pbXBvcnQgJy4vcmVjdXJyaW5nLWV2ZW50LXNpbXBsZS1kZWNsYXJlJ1xuXG4vKlxuQW4gaW1wbGVtZW50YXRpb24gb2YgcmVjdXJyaW5nIGV2ZW50cyB0aGF0IG9ubHkgc3VwcG9ydHMgZXZlcnktZGF5IG9yIHdlZWtseSByZWN1cnJlbmNlcy5cbiovXG5cbmludGVyZmFjZSBTaW1wbGVSZWN1cnJpbmdEYXRhIHtcbiAgZGF5c09mV2VlazogbnVtYmVyW10gfCBudWxsXG4gIHN0YXJ0VGltZTogRHVyYXRpb24gfCBudWxsXG4gIGVuZFRpbWU6IER1cmF0aW9uIHwgbnVsbFxuICBzdGFydFJlY3VyOiBEYXRlTWFya2VyIHwgbnVsbFxuICBlbmRSZWN1cjogRGF0ZU1hcmtlciB8IG51bGxcbn1cblxubGV0IHJlY3VycmluZzogUmVjdXJyaW5nVHlwZTxTaW1wbGVSZWN1cnJpbmdEYXRhPiA9IHtcblxuICBwYXJzZShyZWZpbmVkOiBFdmVudFJlZmluZWQsIGRhdGVFbnY6IERhdGVFbnYpIHtcbiAgICBpZiAocmVmaW5lZC5kYXlzT2ZXZWVrIHx8IHJlZmluZWQuc3RhcnRUaW1lIHx8IHJlZmluZWQuZW5kVGltZSB8fCByZWZpbmVkLnN0YXJ0UmVjdXIgfHwgcmVmaW5lZC5lbmRSZWN1cikge1xuICAgICAgbGV0IHJlY3VycmluZ0RhdGE6IFNpbXBsZVJlY3VycmluZ0RhdGEgPSB7XG4gICAgICAgIGRheXNPZldlZWs6IHJlZmluZWQuZGF5c09mV2VlayB8fCBudWxsLFxuICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgIGVuZFRpbWU6IHJlZmluZWQuZW5kVGltZSB8fCBudWxsLFxuICAgICAgICBzdGFydFJlY3VyOiByZWZpbmVkLnN0YXJ0UmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLnN0YXJ0UmVjdXIpIDogbnVsbCxcbiAgICAgICAgZW5kUmVjdXI6IHJlZmluZWQuZW5kUmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLmVuZFJlY3VyKSA6IG51bGwsXG4gICAgICB9XG5cbiAgICAgIGxldCBkdXJhdGlvbjogRHVyYXRpb25cblxuICAgICAgaWYgKHJlZmluZWQuZHVyYXRpb24pIHtcbiAgICAgICAgZHVyYXRpb24gPSByZWZpbmVkLmR1cmF0aW9uXG4gICAgICB9XG4gICAgICBpZiAoIWR1cmF0aW9uICYmIHJlZmluZWQuc3RhcnRUaW1lICYmIHJlZmluZWQuZW5kVGltZSkge1xuICAgICAgICBkdXJhdGlvbiA9IHN1YnRyYWN0RHVyYXRpb25zKHJlZmluZWQuZW5kVGltZSwgcmVmaW5lZC5zdGFydFRpbWUpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheUd1ZXNzOiBCb29sZWFuKCFyZWZpbmVkLnN0YXJ0VGltZSAmJiAhcmVmaW5lZC5lbmRUaW1lKSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIHR5cGVEYXRhOiByZWN1cnJpbmdEYXRhLCAvLyBkb2Vzbid0IG5lZWQgZW5kVGltZSBhbnltb3JlIGJ1dCBvaCB3ZWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfSxcblxuICBleHBhbmQodHlwZURhdGE6IFNpbXBsZVJlY3VycmluZ0RhdGEsIGZyYW1pbmdSYW5nZTogRGF0ZVJhbmdlLCBkYXRlRW52OiBEYXRlRW52KTogRGF0ZU1hcmtlcltdIHtcbiAgICBsZXQgY2xpcHBlZEZyYW1pbmdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhcbiAgICAgIGZyYW1pbmdSYW5nZSxcbiAgICAgIHsgc3RhcnQ6IHR5cGVEYXRhLnN0YXJ0UmVjdXIsIGVuZDogdHlwZURhdGEuZW5kUmVjdXIgfSxcbiAgICApXG5cbiAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyhcbiAgICAgICAgdHlwZURhdGEuZGF5c09mV2VlayxcbiAgICAgICAgdHlwZURhdGEuc3RhcnRUaW1lLFxuICAgICAgICBjbGlwcGVkRnJhbWluZ1JhbmdlLFxuICAgICAgICBkYXRlRW52LFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gW11cbiAgfSxcblxufVxuXG5leHBvcnQgY29uc3Qgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgcmVjdXJyaW5nVHlwZXM6IFtyZWN1cnJpbmddLFxuICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTLFxufSlcblxuZnVuY3Rpb24gZXhwYW5kUmFuZ2VzKFxuICBkYXlzT2ZXZWVrOiBudW1iZXJbXSB8IG51bGwsXG4gIHN0YXJ0VGltZTogRHVyYXRpb24gfCBudWxsLFxuICBmcmFtaW5nUmFuZ2U6IERhdGVSYW5nZSxcbiAgZGF0ZUVudjogRGF0ZUVudixcbik6IERhdGVNYXJrZXJbXSB7XG4gIGxldCBkb3dIYXNoOiB7IFtudW06IHN0cmluZ106IHRydWUgfSB8IG51bGwgPSBkYXlzT2ZXZWVrID8gYXJyYXlUb0hhc2goZGF5c09mV2VlaykgOiBudWxsXG4gIGxldCBkYXlNYXJrZXIgPSBzdGFydE9mRGF5KGZyYW1pbmdSYW5nZS5zdGFydClcbiAgbGV0IGVuZE1hcmtlciA9IGZyYW1pbmdSYW5nZS5lbmRcbiAgbGV0IGluc3RhbmNlU3RhcnRzOiBEYXRlTWFya2VyW10gPSBbXVxuXG4gIHdoaWxlIChkYXlNYXJrZXIgPCBlbmRNYXJrZXIpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGFydFxuXG4gICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcbiAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRhdGVFbnYuYWRkKGRheU1hcmtlciwgc3RhcnRUaW1lKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlclxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVN0YXJ0cy5wdXNoKGluc3RhbmNlU3RhcnQpXG4gICAgfVxuXG4gICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpXG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VTdGFydHNcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IGhhc2hWYWx1ZXNUb0FycmF5IH0gZnJvbSAnLi91dGlsL29iamVjdCdcbmltcG9ydCB7IEV2ZW50U291cmNlIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4vQ2FsZW5kYXJDb250ZXh0J1xuXG5leHBvcnQgY29uc3QgY2hhbmdlSGFuZGxlclBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XG4gICAgZXZlbnRzKGV2ZW50cywgY29udGV4dCkge1xuICAgICAgaGFuZGxlRXZlbnRTb3VyY2VzKFtldmVudHNdLCBjb250ZXh0KVxuICAgIH0sXG4gICAgZXZlbnRTb3VyY2VzOiBoYW5kbGVFdmVudFNvdXJjZXMsXG4gIH0sXG59KVxuXG4vKlxuQlVHOiBpZiBgZXZlbnRgIHdhcyBzdXBwbGllZCwgYWxsIHByZXZpb3VzbHktZ2l2ZW4gYGV2ZW50U291cmNlc2Agd2lsbCBiZSB3aXBlZCBvdXRcbiovXG5mdW5jdGlvbiBoYW5kbGVFdmVudFNvdXJjZXMoaW5wdXRzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgbGV0IHVuZm91bmRTb3VyY2VzOiBFdmVudFNvdXJjZTxhbnk+W10gPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKVxuICBsZXQgbmV3SW5wdXRzID0gW11cblxuICBmb3IgKGxldCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICBsZXQgaW5wdXRGb3VuZCA9IGZhbHNlXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcbiAgICAgICAgdW5mb3VuZFNvdXJjZXMuc3BsaWNlKGksIDEpIC8vIGRlbGV0ZVxuICAgICAgICBpbnB1dEZvdW5kID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5wdXRGb3VuZCkge1xuICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpXG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgdW5mb3VuZFNvdXJjZSBvZiB1bmZvdW5kU291cmNlcykge1xuICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2Uuc291cmNlSWQsXG4gICAgfSlcbiAgfVxuXG4gIGZvciAobGV0IG5ld0lucHV0IG9mIG5ld0lucHV0cykge1xuICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuYWRkRXZlbnRTb3VyY2UobmV3SW5wdXQpXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcbmltcG9ydCB7IFJhbmdlQXBpV2l0aFRpbWVab25lLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIH0gZnJvbSAnLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuL1ZpZXdBcGknXG5cbmV4cG9ydCB0eXBlIERhdGVzU2V0QXJnID0gUmFuZ2VBcGlXaXRoVGltZVpvbmUgJiB7IHZpZXc6IFZpZXdBcGkgfVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLCBjb250ZXh0OiBDYWxlbmRhckRhdGEpIHtcbiAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVzU2V0Jywge1xuICAgIC4uLmJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQuZGF0ZUVudiksXG4gICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICB9KVxufVxuIiwiaW1wb3J0IHsgRXZlbnRTdG9yZSB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IENhbGVuZGFyRGF0YSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcbmltcG9ydCB7IEV2ZW50QXBpLCBidWlsZEV2ZW50QXBpcyB9IGZyb20gJy4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuL2RhdGVsaWIvZHVyYXRpb24nXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50QWRkQXJnIHtcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIHJlbGF0ZWRFdmVudHM6IEV2ZW50QXBpW11cbiAgcmV2ZXJ0OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRDaGFuZ2VBcmcge1xuICBvbGRFdmVudDogRXZlbnRBcGlcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIHJlbGF0ZWRFdmVudHM6IEV2ZW50QXBpW11cbiAgcmV2ZXJ0OiAoKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnREcm9wQXJnIGV4dGVuZHMgRXZlbnRDaGFuZ2VBcmcgeyAvLyBub3QgYmVzdCBwbGFjZS4gZGVhbHMgdy8gVUlcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGRlbHRhOiBEdXJhdGlvblxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbiAgLy8gYW5kIG90aGVyIFwidHJhbnNmb3JtZWRcIiB0aGluZ3Ncbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFJlbW92ZUFyZyB7XG4gIGV2ZW50OiBFdmVudEFwaVxuICByZWxhdGVkRXZlbnRzOiBFdmVudEFwaVtdXG4gIHJldmVydDogKCkgPT4gdm9pZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlOiBFdmVudFN0b3JlLCBjb250ZXh0OiBDYWxlbmRhckRhdGEpIHtcbiAgbGV0IHsgZW1pdHRlciB9ID0gY29udGV4dFxuXG4gIGlmIChlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudHNTZXQnKSkge1xuICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpXG4gIH1cbn1cbiIsImltcG9ydCB7IFBsdWdpbkRlZiB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0nXG5pbXBvcnQgeyBhcnJheUV2ZW50U291cmNlUGx1Z2luIH0gZnJvbSAnLi9ldmVudC1zb3VyY2VzL2FycmF5LWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IGZ1bmNFdmVudFNvdXJjZVBsdWdpbiB9IGZyb20gJy4vZXZlbnQtc291cmNlcy9mdW5jLWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gfSBmcm9tICcuL2V2ZW50LXNvdXJjZXMvanNvbi1mZWVkLWV2ZW50LXNvdXJjZSdcbmltcG9ydCB7IHNpbXBsZVJlY3VycmluZ0V2ZW50c1BsdWdpbiB9IGZyb20gJy4vc3RydWN0cy9yZWN1cnJpbmctZXZlbnQtc2ltcGxlJ1xuaW1wb3J0IHsgY2hhbmdlSGFuZGxlclBsdWdpbiB9IGZyb20gJy4vb3B0aW9uLWNoYW5nZS1oYW5kbGVycydcbmltcG9ydCB7IGhhbmRsZURhdGVQcm9maWxlIH0gZnJvbSAnLi9kYXRlcy1zZXQnXG5pbXBvcnQgeyBoYW5kbGVFdmVudFN0b3JlIH0gZnJvbSAnLi9ldmVudC1jcnVkJ1xuaW1wb3J0IHsgaXNBcnJheXNFcXVhbCB9IGZyb20gJy4vdXRpbC9hcnJheSdcbmltcG9ydCB7IHJlbW92ZUVsZW1lbnQgfSBmcm9tICcuL3V0aWwvZG9tLW1hbmlwJ1xuaW1wb3J0IHsgY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcgfSBmcm9tICcuL3JlZHVjZXJzL2V2ZW50U291cmNlcydcbmltcG9ydCB7IENhbGVuZGFyRGF0YU1hbmFnZXJTdGF0ZSB9IGZyb20gJy4vcmVkdWNlcnMvZGF0YS10eXBlcydcblxuLypcbnRoaXMgYXJyYXkgaXMgZXhwb3NlZCBvbiB0aGUgcm9vdCBuYW1lc3BhY2Ugc28gdGhhdCBVTUQgcGx1Z2lucyBjYW4gYWRkIHRvIGl0Llxuc2VlIHRoZSByb2xsdXAtYnVuZGxlcyBzY3JpcHQuXG4qL1xuZXhwb3J0IGNvbnN0IGdsb2JhbFBsdWdpbnM6IFBsdWdpbkRlZltdID0gWyAvLyBUT0RPOiBtYWtlIGEgY29uc3Q/XG4gIGFycmF5RXZlbnRTb3VyY2VQbHVnaW4sXG4gIGZ1bmNFdmVudFNvdXJjZVBsdWdpbixcbiAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcbiAgc2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luLFxuICBjaGFuZ2VIYW5kbGVyUGx1Z2luLFxuICBjcmVhdGVQbHVnaW4oeyAvLyBtaXNjLi4uXG4gICAgaXNMb2FkaW5nRnVuY3M6IFtcbiAgICAgIChzdGF0ZTogQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlKSA9PiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhzdGF0ZS5ldmVudFNvdXJjZXMpLFxuICAgIF0sXG4gICAgY29udGVudFR5cGVIYW5kbGVyczoge1xuICAgICAgaHRtbDogKCkgPT4gKHsgcmVuZGVyOiBpbmplY3RIdG1sIH0pLFxuICAgICAgZG9tTm9kZXM6ICgpID0+ICh7IHJlbmRlcjogaW5qZWN0RG9tTm9kZXMgfSksXG4gICAgfSxcbiAgICBwcm9wU2V0SGFuZGxlcnM6IHtcbiAgICAgIGRhdGVQcm9maWxlOiBoYW5kbGVEYXRlUHJvZmlsZSxcbiAgICAgIGV2ZW50U3RvcmU6IGhhbmRsZUV2ZW50U3RvcmUsXG4gICAgfSxcbiAgfSksXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RIdG1sKGVsOiBIVE1MRWxlbWVudCwgaHRtbDogc3RyaW5nKSB7XG4gIGVsLmlubmVySFRNTCA9IGh0bWxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluamVjdERvbU5vZGVzKGVsOiBIVE1MRWxlbWVudCwgZG9tTm9kZXM6IE5vZGVbXSB8IE5vZGVMaXN0KSB7XG4gIGxldCBvbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsLmNoaWxkTm9kZXMpIC8vIFRPRE86IHVzZSBhcnJheSB1dGlsXG4gIGxldCBuZXdOb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvbU5vZGVzKSAvLyBUT0RPOiB1c2UgYXJyYXkgdXRpbFxuXG4gIGlmICghaXNBcnJheXNFcXVhbChvbGROb2RlcywgbmV3Tm9kZXMpKSB7XG4gICAgZm9yIChsZXQgbmV3Tm9kZSBvZiBuZXdOb2Rlcykge1xuICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3Tm9kZSlcbiAgICB9XG4gICAgb2xkTm9kZXMuZm9yRWFjaChyZW1vdmVFbGVtZW50KVxuICB9XG59XG4iLCJleHBvcnQgY2xhc3MgRGVsYXllZFJ1bm5lciB7XG4gIHByaXZhdGUgaXNSdW5uaW5nID0gZmFsc2VcbiAgcHJpdmF0ZSBpc0RpcnR5ID0gZmFsc2VcbiAgcHJpdmF0ZSBwYXVzZURlcHRoczogeyBbc2NvcGU6IHN0cmluZ106IG51bWJlciB9ID0ge31cbiAgcHJpdmF0ZSB0aW1lb3V0SWQ6IG51bWJlciA9IDBcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRyYWluZWRPcHRpb24/OiAoKSA9PiB2b2lkLFxuICApIHtcbiAgfVxuXG4gIHJlcXVlc3QoZGVsYXk/OiBudW1iZXIpIHtcbiAgICB0aGlzLmlzRGlydHkgPSB0cnVlXG5cbiAgICBpZiAoIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKVxuXG4gICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnRyeURyYWluKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCggLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgICkgYXMgdW5rbm93biBhcyBudW1iZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYXVzZShzY29wZSA9ICcnKSB7XG4gICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXNcblxuICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxXG5cbiAgICB0aGlzLmNsZWFyVGltZW91dCgpXG4gIH1cblxuICByZXN1bWUoc2NvcGUgPSAnJywgZm9yY2U/OiBib29sZWFuKSB7XG4gICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXNcblxuICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxXG4gICAgICAgIGxldCBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXVxuXG4gICAgICAgIGlmIChkZXB0aCA8PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJ5RHJhaW4oKVxuICAgIH1cbiAgfVxuXG4gIGlzUGF1c2VkKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhdXNlRGVwdGhzKS5sZW5ndGhcbiAgfVxuXG4gIHRyeURyYWluKCkge1xuICAgIGlmICghdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlXG5cbiAgICAgIHdoaWxlICh0aGlzLmlzRGlydHkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2VcbiAgICAgICAgdGhpcy5kcmFpbmVkKCkgLy8gbWlnaHQgc2V0IGlzRGlydHkgdG8gdHJ1ZSBhZ2FpblxuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5jbGVhclRpbWVvdXQoKVxuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlXG4gICAgdGhpcy5wYXVzZURlcHRocyA9IHt9XG4gIH1cblxuICBwcml2YXRlIGNsZWFyVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZClcbiAgICAgIHRoaXMudGltZW91dElkID0gMFxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBkcmFpbmVkKCkgeyAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcbiAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICB0aGlzLmRyYWluZWRPcHRpb24oKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgRGVsYXllZFJ1bm5lciB9IGZyb20gJy4vRGVsYXllZFJ1bm5lcidcblxuZXhwb3J0IGNsYXNzIFRhc2tSdW5uZXI8VGFzaz4geyAvLyB0aGlzIGNsYXNzIFVTRVMgdGhlIERlbGF5ZWRSdW5uZXJcbiAgcHJpdmF0ZSBxdWV1ZTogVGFza1tdID0gW11cblxuICBwcml2YXRlIGRlbGF5ZWRSdW5uZXI6IERlbGF5ZWRSdW5uZXIgLy8gd2lsbCBtb3N0IGxpa2VseSBiZSB1c2VkIFdJVEhPVVQgYW55IGRlbGF5XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBydW5UYXNrT3B0aW9uPzogKHRhc2s6IFRhc2spID0+IHZvaWQsXG4gICAgcHJpdmF0ZSBkcmFpbmVkT3B0aW9uPzogKGNvbXBsZXRlZFRhc2tzOiBUYXNrW10pID0+IHZvaWQsXG4gICkge1xuICAgIHRoaXMuZGVsYXllZFJ1bm5lciA9IG5ldyBEZWxheWVkUnVubmVyKHRoaXMuZHJhaW4uYmluZCh0aGlzKSlcbiAgfVxuXG4gIHJlcXVlc3QodGFzazogVGFzaywgZGVsYXk/OiBudW1iZXIpIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2godGFzaylcbiAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVxdWVzdChkZWxheSlcbiAgfVxuXG4gIHBhdXNlKHNjb3BlPzogc3RyaW5nKSB7XG4gICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKVxuICB9XG5cbiAgcmVzdW1lKHNjb3BlPzogc3RyaW5nLCBmb3JjZT86IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucmVzdW1lKHNjb3BlLCBmb3JjZSlcbiAgfVxuXG4gIGRyYWluKCkge1xuICAgIGxldCB7IHF1ZXVlIH0gPSB0aGlzXG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICBsZXQgY29tcGxldGVkVGFza3M6IFRhc2tbXSA9IFtdXG4gICAgICBsZXQgdGFzazogVGFza1xuXG4gICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICB0aGlzLnJ1blRhc2sodGFzaylcbiAgICAgICAgY29tcGxldGVkVGFza3MucHVzaCh0YXNrKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYWluZWQoY29tcGxldGVkVGFza3MpXG4gICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgfVxuXG4gIHByb3RlY3RlZCBydW5UYXNrKHRhc2s6IFRhc2spIHsgLy8gc3ViY2xhc3NlcyBjYW4gaW1wbGVtZW50XG4gICAgaWYgKHRoaXMucnVuVGFza09wdGlvbikge1xuICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uKHRhc2spXG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGRyYWluZWQoY29tcGxldGVkVGFza3M6IFRhc2tbXSkgeyAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcbiAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpXG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgZGlmZldob2xlRGF5cyB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgY3JlYXRlRm9ybWF0dGVyLCBGb3JtYXR0ZXJJbnB1dCB9IGZyb20gJy4uL2RhdGVsaWIvZm9ybWF0dGluZydcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVFbnYgfSBmcm9tICcuLi9kYXRlbGliL2VudidcbmltcG9ydCB7IEJhc2VPcHRpb25zIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuLy8gQ29tcHV0ZXMgd2hhdCB0aGUgdGl0bGUgYXQgdGhlIHRvcCBvZiB0aGUgY2FsZW5kYXJBcGkgc2hvdWxkIGJlIGZvciB0aGlzIHZpZXdcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFRpdGxlKGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgdmlld09wdGlvbnM6IEJhc2VPcHRpb25zLCBkYXRlRW52OiBEYXRlRW52KSB7XG4gIGxldCByYW5nZTogRGF0ZVJhbmdlXG5cbiAgLy8gZm9yIHZpZXdzIHRoYXQgc3BhbiBhIGxhcmdlIHVuaXQgb2YgdGltZSwgc2hvdyB0aGUgcHJvcGVyIGludGVydmFsLCBpZ25vcmluZyBzdHJheSBkYXlzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgaWYgKC9eKHllYXJ8bW9udGgpJC8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSkge1xuICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlXG4gIH0gZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXG4gICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZVxuICB9XG5cbiAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UoXG4gICAgcmFuZ2Uuc3RhcnQsXG4gICAgcmFuZ2UuZW5kLFxuICAgIGNyZWF0ZUZvcm1hdHRlcih2aWV3T3B0aW9ucy50aXRsZUZvcm1hdCB8fCBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSksXG4gICAge1xuICAgICAgaXNFbmRFeGNsdXNpdmU6IGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksXG4gICAgICBkZWZhdWx0U2VwYXJhdG9yOiB2aWV3T3B0aW9ucy50aXRsZVJhbmdlU2VwYXJhdG9yLFxuICAgIH0sXG4gIClcbn1cblxuLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxuLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cbmZ1bmN0aW9uIGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlKTogRm9ybWF0dGVySW5wdXQge1xuICBsZXQgeyBjdXJyZW50UmFuZ2VVbml0IH0gPSBkYXRlUHJvZmlsZVxuXG4gIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfSAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICB9XG5cbiAgbGV0IGRheXMgPSBkaWZmV2hvbGVEYXlzKFxuICAgIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCxcbiAgICBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kLFxuICApXG5cbiAgaWYgKGRheXMgIT09IG51bGwgJiYgZGF5cyA+IDEpIHtcbiAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH1cbiAgfVxuXG4gIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH1cbn1cbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBidWlsZExvY2FsZSwgUmF3TG9jYWxlSW5mbywgb3JnYW5pemVSYXdMb2NhbGVzLCBMb2NhbGVTaW5ndWxhckFyZyB9IGZyb20gJy4uL2RhdGVsaWIvbG9jYWxlJ1xuaW1wb3J0IHsgbWVtb2l6ZSwgbWVtb2l6ZU9iakFyZyB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJ1xuaW1wb3J0IHsgYnVpbGRCdWlsZFBsdWdpbkhvb2tzIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbSdcbmltcG9ydCB7IFBsdWdpbkhvb2tzIH0gZnJvbSAnLi4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5pbXBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4uL0NhbGVuZGFyQXBpJ1xuaW1wb3J0IHsgU3RhbmRhcmRUaGVtZSB9IGZyb20gJy4uL3RoZW1lL1N0YW5kYXJkVGhlbWUnXG5pbXBvcnQgeyBFdmVudFNvdXJjZUhhc2ggfSBmcm9tICcuLi9zdHJ1Y3RzL2V2ZW50LXNvdXJjZSdcbmltcG9ydCB7IGJ1aWxkVmlld1NwZWNzLCBWaWV3U3BlYyB9IGZyb20gJy4uL3N0cnVjdHMvdmlldy1zcGVjJ1xuaW1wb3J0IHsgbWFwSGFzaCwgaXNQcm9wc0VxdWFsIH0gZnJvbSAnLi4vdXRpbC9vYmplY3QnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZUdlbmVyYXRvciwgRGF0ZVByb2ZpbGVHZW5lcmF0b3JQcm9wcyB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgcmVkdWNlVmlld1R5cGUgfSBmcm9tICcuL3ZpZXctdHlwZSdcbmltcG9ydCB7IGdldEluaXRpYWxEYXRlLCByZWR1Y2VDdXJyZW50RGF0ZSB9IGZyb20gJy4vY3VycmVudC1kYXRlJ1xuaW1wb3J0IHsgcmVkdWNlRHluYW1pY09wdGlvbk92ZXJyaWRlcyB9IGZyb20gJy4vb3B0aW9ucydcbmltcG9ydCB7IHJlZHVjZURhdGVQcm9maWxlIH0gZnJvbSAnLi9kYXRlLXByb2ZpbGUnXG5pbXBvcnQgeyByZWR1Y2VFdmVudFNvdXJjZXMsIGluaXRFdmVudFNvdXJjZXMsIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lLCBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyB9IGZyb20gJy4vZXZlbnRTb3VyY2VzJ1xuaW1wb3J0IHsgcmVkdWNlRXZlbnRTdG9yZSwgcmV6b25lRXZlbnRTdG9yZURhdGVzIH0gZnJvbSAnLi9ldmVudFN0b3JlJ1xuaW1wb3J0IHsgcmVkdWNlRGF0ZVNlbGVjdGlvbiB9IGZyb20gJy4vZGF0ZS1zZWxlY3Rpb24nXG5pbXBvcnQgeyByZWR1Y2VTZWxlY3RlZEV2ZW50IH0gZnJvbSAnLi9zZWxlY3RlZC1ldmVudCdcbmltcG9ydCB7IHJlZHVjZUV2ZW50RHJhZyB9IGZyb20gJy4vZXZlbnQtZHJhZydcbmltcG9ydCB7IHJlZHVjZUV2ZW50UmVzaXplIH0gZnJvbSAnLi9ldmVudC1yZXNpemUnXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vY29tbW9uL0VtaXR0ZXInXG5pbXBvcnQgeyBFdmVudFVpSGFzaCwgRXZlbnRVaSwgY3JlYXRlRXZlbnRVaSB9IGZyb20gJy4uL2NvbXBvbmVudC9ldmVudC11aSdcbmltcG9ydCB7IEV2ZW50RGVmSGFzaCB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtZGVmJ1xuaW1wb3J0IHsgcGFyc2VUb29sYmFycyB9IGZyb20gJy4uL3Rvb2xiYXItcGFyc2UnXG5pbXBvcnQge1xuICBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLCBDYWxlbmRhck9wdGlvbnMsXG4gIENBTEVOREFSX09QVElPTl9SRUZJTkVSUywgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMsXG4gIFZpZXdPcHRpb25zLCBWaWV3T3B0aW9uc1JlZmluZWQsXG4gIEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBtZXJnZVJhd09wdGlvbnMsXG4gIEJBU0VfT1BUSU9OX1JFRklORVJTLCBWSUVXX09QVElPTl9SRUZJTkVSUyxcbiAgQ2FsZW5kYXJMaXN0ZW5lcnMsIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTLCBEaWN0aW9uYXJ5LFxufSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgcmFuZ2VDb250YWluc01hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuaW1wb3J0IHsgcGFyc2VCdXNpbmVzc0hvdXJzIH0gZnJvbSAnLi4vc3RydWN0cy9idXNpbmVzcy1ob3VycydcbmltcG9ydCB7IGdsb2JhbFBsdWdpbnMgfSBmcm9tICcuLi9nbG9iYWwtcGx1Z2lucydcbmltcG9ydCB7IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSB9IGZyb20gJy4uL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGUsIENhbGVuZGFyT3B0aW9uc0RhdGEsIENhbGVuZGFyQ3VycmVudFZpZXdEYXRhLCBDYWxlbmRhckRhdGEgfSBmcm9tICcuL2RhdGEtdHlwZXMnXG5pbXBvcnQgeyBUYXNrUnVubmVyIH0gZnJvbSAnLi4vdXRpbC9UYXNrUnVubmVyJ1xuaW1wb3J0IHsgYnVpbGRUaXRsZSB9IGZyb20gJy4vdGl0bGUtZm9ybWF0dGluZydcblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckRhdGFNYW5hZ2VyUHJvcHMge1xuICBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9uc1xuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGlcbiAgb25BY3Rpb24/OiAoYWN0aW9uOiBBY3Rpb24pID0+IHZvaWRcbiAgb25EYXRhPzogKGRhdGE6IENhbGVuZGFyRGF0YSkgPT4gdm9pZFxufVxuXG5leHBvcnQgdHlwZSBSZWR1Y2VyRnVuYyA9ICggLy8gVE9ETzogcmVuYW1lIHRvIENhbGVuZGFyRGF0YUluamVjdG9yLiBtb3ZlIHZpZXctcHJvcHMtbWFuaXAgaG9vayBoZXJlIGFzIHdlbGw/XG4gIGN1cnJlbnRTdGF0ZTogRGljdGlvbmFyeSB8IG51bGwsXG4gIGFjdGlvbjogQWN0aW9uIHwgbnVsbCxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0ICYgQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlIC8vIG1vcmUgdGhhbiBqdXN0IGNvbnRleHRcbikgPT4gRGljdGlvbmFyeVxuXG4vLyBpbiBmdXR1cmUgcmVmYWN0b3IsIGRvIHRoZSByZWR1eC1zdHlsZSBmdW5jdGlvbihzdGF0ZT1pbml0aWFsKSBmb3IgaW5pdGlhbC1zdGF0ZVxuLy8gYWxzbywgd2hhdGV2ZXIgaXMgaGFwcGVuaW5nIGluIGNvbnN0cnVjdG9yLCBoYXZlIGl0IGhhcHBlbiBpbiBhY3Rpb24gcXVldWUgdG9vXG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckRhdGFNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBjb21wdXRlT3B0aW9uc0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVPcHRpb25zRGF0YSlcbiAgcHJpdmF0ZSBjb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKVxuICBwcml2YXRlIG9yZ2FuaXplUmF3TG9jYWxlcyA9IG1lbW9pemUob3JnYW5pemVSYXdMb2NhbGVzKVxuICBwcml2YXRlIGJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSlcbiAgcHJpdmF0ZSBidWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKClcbiAgcHJpdmF0ZSBidWlsZERhdGVFbnYgPSBtZW1vaXplKGJ1aWxkRGF0ZUVudilcbiAgcHJpdmF0ZSBidWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKVxuICBwcml2YXRlIHBhcnNlVG9vbGJhcnMgPSBtZW1vaXplKHBhcnNlVG9vbGJhcnMpXG4gIHByaXZhdGUgYnVpbGRWaWV3U3BlY3MgPSBtZW1vaXplKGJ1aWxkVmlld1NwZWNzKVxuICBwcml2YXRlIGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpXG4gIHByaXZhdGUgYnVpbGRWaWV3QXBpID0gbWVtb2l6ZShidWlsZFZpZXdBcGkpXG4gIHByaXZhdGUgYnVpbGRWaWV3VWlQcm9wcyA9IG1lbW9pemVPYmpBcmcoYnVpbGRWaWV3VWlQcm9wcylcbiAgcHJpdmF0ZSBidWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbClcbiAgcHJpdmF0ZSBidWlsZEV2ZW50VWlCYXNlcyA9IG1lbW9pemUoYnVpbGRFdmVudFVpQmFzZXMpXG4gIHByaXZhdGUgcGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyA9IG1lbW9pemVPYmpBcmcocGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycylcbiAgcHJpdmF0ZSBidWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKVxuXG4gIHB1YmxpYyBlbWl0dGVyID0gbmV3IEVtaXR0ZXI8Q2FsZW5kYXJMaXN0ZW5lcnM+KClcbiAgcHJpdmF0ZSBhY3Rpb25SdW5uZXIgPSBuZXcgVGFza1J1bm5lcih0aGlzLl9oYW5kbGVBY3Rpb24uYmluZCh0aGlzKSwgdGhpcy51cGRhdGVEYXRhLmJpbmQodGhpcykpXG4gIHByaXZhdGUgcHJvcHM6IENhbGVuZGFyRGF0YU1hbmFnZXJQcm9wc1xuICBwcml2YXRlIHN0YXRlOiBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGVcbiAgcHJpdmF0ZSBkYXRhOiBDYWxlbmRhckRhdGFcblxuICBwdWJsaWMgY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0OiBDYWxlbmRhck9wdGlvbnMgPSB7fVxuICBwcml2YXRlIGN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0gKHt9IGFzIGFueSlcbiAgcHJpdmF0ZSBjdXJyZW50Vmlld09wdGlvbnNJbnB1dDogVmlld09wdGlvbnMgPSB7fVxuICBwcml2YXRlIGN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ6IFZpZXdPcHRpb25zUmVmaW5lZCA9ICh7fSBhcyBhbnkpXG4gIHB1YmxpYyBjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnM6IGFueSA9IHt9XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IENhbGVuZGFyRGF0YU1hbmFnZXJQcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wc1xuICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKClcblxuICAgIGxldCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMgPSB7fVxuICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHByb3BzLmNhbGVuZGFyQXBpLFxuICAgIClcblxuICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXdcbiAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKFxuICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgb3B0aW9uc0RhdGEsXG4gICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgIClcblxuICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgLy8gVE9ETzogbm90IERSWVxuICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXNcbiAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpXG4gICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpXG5cbiAgICBsZXQgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpXG4gICAgbGV0IGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKVxuXG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjdXJyZW50RGF0ZSkpIHtcbiAgICAgIGN1cnJlbnREYXRlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0XG4gICAgfVxuXG4gICAgbGV0IGNhbGVuZGFyQ29udGV4dDogQ2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgfVxuXG4gICAgLy8gbmVlZHMgdG8gYmUgYWZ0ZXIgc2V0VGhpc0NvbnRleHRcbiAgICBmb3IgKGxldCBjYWxsYmFjayBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5jb250ZXh0SW5pdCkge1xuICAgICAgY2FsbGJhY2soY2FsZW5kYXJDb250ZXh0KVxuICAgIH1cblxuICAgIC8vIE5PVCBEUllcbiAgICBsZXQgZXZlbnRTb3VyY2VzID0gaW5pdEV2ZW50U291cmNlcyhvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjYWxlbmRhckNvbnRleHQpXG5cbiAgICBsZXQgaW5pdGlhbFN0YXRlOiBDYWxlbmRhckRhdGFNYW5hZ2VyU3RhdGUgPSB7XG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgY3VycmVudERhdGUsXG4gICAgICBkYXRlUHJvZmlsZSxcbiAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLCAvLyB3ZWlyZCB0byBoYXZlIHRoaXMgaW4gc3RhdGVcbiAgICAgIGV2ZW50U291cmNlcyxcbiAgICAgIGV2ZW50VWlCYXNlczoge30sXG4gICAgICBldmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIGRhdGVTZWxlY3Rpb246IG51bGwsXG4gICAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgICBldmVudERyYWc6IG51bGwsXG4gICAgICBldmVudFJlc2l6ZTogbnVsbCxcbiAgICAgIHNlbGVjdGlvbkNvbmZpZzogdGhpcy5idWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkuc2VsZWN0aW9uQ29uZmlnLFxuICAgIH1cbiAgICBsZXQgY29udGV4dEFuZFN0YXRlID0geyAuLi5jYWxlbmRhckNvbnRleHQsIC4uLmluaXRpYWxTdGF0ZSB9XG5cbiAgICBmb3IgKGxldCByZWR1Y2VyIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLnJlZHVjZXJzKSB7XG4gICAgICBfX2Fzc2lnbihpbml0aWFsU3RhdGUsIHJlZHVjZXIobnVsbCwgbnVsbCwgY29udGV4dEFuZFN0YXRlKSlcbiAgICB9XG5cbiAgICBpZiAoY29tcHV0ZUlzTG9hZGluZyhpbml0aWFsU3RhdGUsIGNhbGVuZGFyQ29udGV4dCkpIHtcbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSkgLy8gTk9UIERSWVxuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGVcbiAgICB0aGlzLnVwZGF0ZURhdGEoKVxuICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlc3VtZSgpXG4gIH1cblxuICBnZXRDdXJyZW50RGF0YSA9ICgpID0+IHRoaXMuZGF0YVxuXG4gIGRpc3BhdGNoID0gKGFjdGlvbjogQWN0aW9uKSA9PiB7XG4gICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pIC8vIHByb3RlY3RzIGFnYWluc3QgcmVjdXJzaXZlIGNhbGxzIHRvIF9oYW5kbGVBY3Rpb25cbiAgfVxuXG4gIHJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucywgYXBwZW5kPzogYm9vbGVhbikge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBhcHBlbmRcbiAgICAgID8geyAuLi5wcm9wcy5vcHRpb25PdmVycmlkZXMsIC4uLm9wdGlvbk92ZXJyaWRlcyB9XG4gICAgICA6IG9wdGlvbk92ZXJyaWRlc1xuXG4gICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdCh7IC8vIGhhY2suIHdpbGwgY2F1c2UgdXBkYXRlRGF0YVxuICAgICAgdHlwZTogJ05PVEhJTkcnLFxuICAgIH0pXG4gIH1cblxuICBfaGFuZGxlQWN0aW9uKGFjdGlvbjogQWN0aW9uKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBlbWl0dGVyIH0gPSB0aGlzXG5cbiAgICBsZXQgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKVxuICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHByb3BzLmNhbGVuZGFyQXBpLFxuICAgIClcblxuICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIGFjdGlvbilcbiAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKFxuICAgICAgY3VycmVudFZpZXdUeXBlLFxuICAgICAgb3B0aW9uc0RhdGEsXG4gICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgIClcblxuICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgLy8gVE9ETzogbm90IERSWVxuICAgIHByb3BzLmNhbGVuZGFyQXBpLmN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXNcbiAgICBlbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKVxuICAgIGVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucylcblxuICAgIGxldCBjYWxlbmRhckNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgIGVtaXR0ZXIsXG4gICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICB9XG5cbiAgICBsZXQgeyBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHN0YXRlXG5cbiAgICBpZiAodGhpcy5kYXRhICYmIHRoaXMuZGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvciAhPT0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yKSB7IC8vIGhhY2tcbiAgICAgIGRhdGVQcm9maWxlID0gY3VycmVudFZpZXdEYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGN1cnJlbnREYXRlKVxuICAgIH1cblxuICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbilcbiAgICBkYXRlUHJvZmlsZSA9IHJlZHVjZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBhY3Rpb24sIGN1cnJlbnREYXRlLCBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpXG5cbiAgICBpZiAoXG4gICAgICBhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXG4gICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXG4gICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKVxuICAgICkge1xuICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnRcbiAgICB9XG5cbiAgICBsZXQgZXZlbnRTb3VyY2VzID0gcmVkdWNlRXZlbnRTb3VyY2VzKHN0YXRlLmV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KVxuICAgIGxldCBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dClcbiAgICBsZXQgaXNFdmVudHNMb2FkaW5nID0gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXG5cbiAgICBsZXQgcmVuZGVyYWJsZUV2ZW50U3RvcmUgPVxuICAgICAgKGlzRXZlbnRzTG9hZGluZyAmJiAhY3VycmVudFZpZXdEYXRhLm9wdGlvbnMucHJvZ3Jlc3NpdmVFdmVudFJlbmRlcmluZykgP1xuICAgICAgICAoc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgfHwgZXZlbnRTdG9yZSkgOiAvLyB0cnkgZnJvbSBwcmV2aW91cyBzdGF0ZVxuICAgICAgICBldmVudFN0b3JlXG5cbiAgICBsZXQgeyBldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnIH0gPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgbGV0IGV2ZW50VWlCeVNvdXJjZSA9IHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKVxuICAgIGxldCBldmVudFVpQmFzZXMgPSB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzKHJlbmRlcmFibGVFdmVudFN0b3JlLmRlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpXG5cbiAgICBsZXQgbmV3U3RhdGU6IENhbGVuZGFyRGF0YU1hbmFnZXJTdGF0ZSA9IHtcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICBjdXJyZW50RGF0ZSxcbiAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgZXZlbnRTdG9yZSxcbiAgICAgIHJlbmRlcmFibGVFdmVudFN0b3JlLFxuICAgICAgc2VsZWN0aW9uQ29uZmlnLFxuICAgICAgZXZlbnRVaUJhc2VzLFxuICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksIC8vIHdpbGwgbWVtb2l6ZSBvYmpcbiAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxuICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxuICAgIH1cbiAgICBsZXQgY29udGV4dEFuZFN0YXRlID0geyAuLi5jYWxlbmRhckNvbnRleHQsIC4uLm5ld1N0YXRlIH1cblxuICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgIF9fYXNzaWduKG5ld1N0YXRlLCByZWR1Y2VyKHN0YXRlLCBhY3Rpb24sIGNvbnRleHRBbmRTdGF0ZSkpIC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxuICAgIH1cblxuICAgIGxldCB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KVxuICAgIGxldCBpc0xvYWRpbmcgPSBjb21wdXRlSXNMb2FkaW5nKG5ld1N0YXRlLCBjYWxlbmRhckNvbnRleHQpXG5cbiAgICAvLyBUT0RPOiB1c2UgcHJvcFNldEhhbmRsZXJzIGluIHBsdWdpbiBzeXN0ZW1cbiAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XG4gICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKVxuICAgIH0gZWxzZSBpZiAod2FzTG9hZGluZyAmJiAhaXNMb2FkaW5nKSB7XG4gICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCBmYWxzZSlcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGVcblxuICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xuICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZURhdGEoKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgbGV0IG9sZERhdGEgPSB0aGlzLmRhdGFcblxuICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKFxuICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHByb3BzLmNhbGVuZGFyQXBpLFxuICAgIClcblxuICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoXG4gICAgICBzdGF0ZS5jdXJyZW50Vmlld1R5cGUsXG4gICAgICBvcHRpb25zRGF0YSxcbiAgICAgIHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgKVxuXG4gICAgbGV0IGRhdGE6IENhbGVuZGFyRGF0YSA9IHRoaXMuZGF0YSA9IHtcbiAgICAgIHZpZXdUaXRsZTogdGhpcy5idWlsZFRpdGxlKHN0YXRlLmRhdGVQcm9maWxlLCBjdXJyZW50Vmlld0RhdGEub3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudiksXG4gICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgLi4ub3B0aW9uc0RhdGEsXG4gICAgICAuLi5jdXJyZW50Vmlld0RhdGEsXG4gICAgICAuLi5zdGF0ZSxcbiAgICB9XG5cbiAgICBsZXQgY2hhbmdlSGFuZGxlcnMgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5vcHRpb25DaGFuZ2VIYW5kbGVyc1xuICAgIGxldCBvbGRDYWxlbmRhck9wdGlvbnMgPSBvbGREYXRhICYmIG9sZERhdGEuY2FsZW5kYXJPcHRpb25zXG4gICAgbGV0IG5ld0NhbGVuZGFyT3B0aW9ucyA9IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9uc1xuXG4gICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucyAmJiBvbGRDYWxlbmRhck9wdGlvbnMgIT09IG5ld0NhbGVuZGFyT3B0aW9ucykge1xuICAgICAgaWYgKG9sZENhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zLnRpbWVab25lKSB7XG4gICAgICAgIC8vIGhhY2tcbiAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2VzID0gZGF0YS5ldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShkYXRhLmV2ZW50U291cmNlcywgc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGEpXG4gICAgICAgIHN0YXRlLmV2ZW50U3RvcmUgPSBkYXRhLmV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5ldmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudilcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiBjaGFuZ2VIYW5kbGVycykge1xuICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICBjaGFuZ2VIYW5kbGVyc1tvcHRpb25OYW1lXShuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0sIGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvcHMub25EYXRhKSB7XG4gICAgICBwcm9wcy5vbkRhdGEoZGF0YSlcbiAgICB9XG4gIH1cblxuICBfY29tcHV0ZU9wdGlvbnNEYXRhKFxuICAgIG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGksXG4gICk6IENhbGVuZGFyT3B0aW9uc0RhdGEge1xuICAgIC8vIFRPRE86IGJsYWNrbGlzdCBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgYnkgb3B0aW9uQ2hhbmdlSGFuZGxlcnNcblxuICAgIGxldCB7XG4gICAgICByZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBleHRyYSxcbiAgICB9ID0gdGhpcy5wcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcylcblxuICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSlcblxuICAgIGxldCBkYXRlRW52ID0gdGhpcy5idWlsZERhdGVFbnYoXG4gICAgICByZWZpbmVkT3B0aW9ucy50aW1lWm9uZSxcbiAgICAgIHJlZmluZWRPcHRpb25zLmxvY2FsZSxcbiAgICAgIHJlZmluZWRPcHRpb25zLndlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgICAgIHJlZmluZWRPcHRpb25zLmZpcnN0RGF5LFxuICAgICAgcmVmaW5lZE9wdGlvbnMud2Vla1RleHQsXG4gICAgICBwbHVnaW5Ib29rcyxcbiAgICAgIGF2YWlsYWJsZUxvY2FsZURhdGEsXG4gICAgICByZWZpbmVkT3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IsXG4gICAgKVxuXG4gICAgbGV0IHZpZXdTcGVjcyA9IHRoaXMuYnVpbGRWaWV3U3BlY3MocGx1Z2luSG9va3Mudmlld3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpXG4gICAgbGV0IHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcylcbiAgICBsZXQgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgb3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSlcblxuICAgIHJldHVybiB7XG4gICAgICBjYWxlbmRhck9wdGlvbnM6IHJlZmluZWRPcHRpb25zLFxuICAgICAgcGx1Z2luSG9va3MsXG4gICAgICBkYXRlRW52LFxuICAgICAgdmlld1NwZWNzLFxuICAgICAgdGhlbWUsXG4gICAgICB0b29sYmFyQ29uZmlnLFxuICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICBhdmFpbGFibGVSYXdMb2NhbGVzOiBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCxcbiAgICB9XG4gIH1cblxuICAvLyBhbHdheXMgY2FsbGVkIGZyb20gYmVoaW5kIGEgbWVtb2l6ZXJcbiAgcHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucywgZHluYW1pY09wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zKSB7XG4gICAgbGV0IHsgbG9jYWxlcywgbG9jYWxlIH0gPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgIF0pXG4gICAgbGV0IGF2YWlsYWJsZUxvY2FsZURhdGEgPSB0aGlzLm9yZ2FuaXplUmF3TG9jYWxlcyhsb2NhbGVzKVxuICAgIGxldCBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXBcbiAgICBsZXQgbG9jYWxlRGVmYXVsdHMgPSB0aGlzLmJ1aWxkTG9jYWxlKGxvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVSYXdMb2NhbGVzKS5vcHRpb25zXG4gICAgbGV0IHBsdWdpbkhvb2tzID0gdGhpcy5idWlsZFBsdWdpbkhvb2tzKG9wdGlvbk92ZXJyaWRlcy5wbHVnaW5zIHx8IFtdLCBnbG9iYWxQbHVnaW5zKVxuICAgIGxldCByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0ge1xuICAgICAgLi4uQkFTRV9PUFRJT05fUkVGSU5FUlMsXG4gICAgICAuLi5DQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyxcbiAgICAgIC4uLkNBTEVOREFSX09QVElPTl9SRUZJTkVSUyxcbiAgICAgIC4uLnBsdWdpbkhvb2tzLmxpc3RlbmVyUmVmaW5lcnMsXG4gICAgICAuLi5wbHVnaW5Ib29rcy5vcHRpb25SZWZpbmVycyxcbiAgICB9XG4gICAgbGV0IGV4dHJhID0ge31cblxuICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgXSlcbiAgICBsZXQgcmVmaW5lZDogUGFydGlhbDxDYWxlbmRhck9wdGlvbnNSZWZpbmVkPiA9IHt9XG4gICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFxuICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWRcbiAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlXG5cbiAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgaWYgKG9wdGlvbk5hbWUgIT09ICdwbHVnaW5zJykgeyAvLyBiZWNhdXNlIHBsdWdpbnMgaXMgc3BlY2lhbC1jYXNlZFxuICAgICAgICBpZiAoXG4gICAgICAgICAgcmF3W29wdGlvbk5hbWVdID09PSBjdXJyZW50UmF3W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgKFxuICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV1cbiAgICAgICAgfSBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pXG4gICAgICAgICAgYW55Q2hhbmdlcyA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHJhd1xuICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQgYXMgQ2FsZW5kYXJPcHRpb25zUmVmaW5lZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByYXdPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCxcbiAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkLFxuICAgICAgcGx1Z2luSG9va3MsXG4gICAgICBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgbG9jYWxlRGVmYXVsdHMsXG4gICAgICBleHRyYSxcbiAgICB9XG4gIH1cblxuICBfY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShcbiAgICB2aWV3VHlwZTogc3RyaW5nLFxuICAgIG9wdGlvbnNEYXRhOiBDYWxlbmRhck9wdGlvbnNEYXRhLFxuICAgIG9wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyxcbiAgKTogQ2FsZW5kYXJDdXJyZW50Vmlld0RhdGEge1xuICAgIGxldCB2aWV3U3BlYyA9IG9wdGlvbnNEYXRhLnZpZXdTcGVjc1t2aWV3VHlwZV1cblxuICAgIGlmICghdmlld1NwZWMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdmlld1R5cGUgXCIke3ZpZXdUeXBlfVwiIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgeW91J3ZlIGxvYWRlZCBhbGwgbmVjY2Vzc2FyeSBwbHVnaW5zYClcbiAgICB9XG5cbiAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgZXh0cmEgfSA9IHRoaXMucHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKFxuICAgICAgdmlld1NwZWMsXG4gICAgICBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLFxuICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICApXG5cbiAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpXG5cbiAgICBsZXQgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xuICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyBhcyBhbnksXG4gICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSBhcyBhbnksXG4gICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgY2FsZW5kYXJBcGk6IHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIC8vIHNob3VsZCBjb21lIGZyb20gZWxzZXdoZXJlP1xuICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxuICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxuICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcbiAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcbiAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXG4gICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxuICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcbiAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcbiAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXG4gICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXG4gICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxuICAgICAgbW9udGhNb2RlOiByZWZpbmVkT3B0aW9ucy5tb250aE1vZGUsXG4gICAgICBmaXhlZFdlZWtDb3VudDogcmVmaW5lZE9wdGlvbnMuZml4ZWRXZWVrQ291bnQsXG4gICAgfSlcblxuICAgIGxldCB2aWV3QXBpID0gdGhpcy5idWlsZFZpZXdBcGkodmlld1R5cGUsIHRoaXMuZ2V0Q3VycmVudERhdGEsIG9wdGlvbnNEYXRhLmRhdGVFbnYpXG5cbiAgICByZXR1cm4geyB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yLCB2aWV3QXBpIH1cbiAgfVxuXG4gIHByb2Nlc3NSYXdWaWV3T3B0aW9ucyhcbiAgICB2aWV3U3BlYzogVmlld1NwZWMsXG4gICAgcGx1Z2luSG9va3M6IFBsdWdpbkhvb2tzLFxuICAgIGxvY2FsZURlZmF1bHRzOiBDYWxlbmRhck9wdGlvbnMsXG4gICAgb3B0aW9uT3ZlcnJpZGVzOiBDYWxlbmRhck9wdGlvbnMsXG4gICAgZHluYW1pY09wdGlvbk92ZXJyaWRlczogQ2FsZW5kYXJPcHRpb25zLFxuICApIHtcbiAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXG4gICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgXSlcbiAgICBsZXQgcmVmaW5lcnMgPSB7XG4gICAgICAuLi5CQVNFX09QVElPTl9SRUZJTkVSUyxcbiAgICAgIC4uLkNBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTLFxuICAgICAgLi4uQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTLFxuICAgICAgLi4uVklFV19PUFRJT05fUkVGSU5FUlMsXG4gICAgICAuLi5wbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzLFxuICAgICAgLi4ucGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMsXG4gICAgfVxuICAgIGxldCByZWZpbmVkOiBQYXJ0aWFsPFZpZXdPcHRpb25zUmVmaW5lZD4gPSB7fVxuICAgIGxldCBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dFxuICAgIGxldCBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZFxuICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2VcbiAgICBsZXQgZXh0cmEgPSB7fVxuXG4gICAgZm9yIChsZXQgb3B0aW9uTmFtZSBpbiByYXcpIHtcbiAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IGN1cnJlbnRSZWZpbmVkW29wdGlvbk5hbWVdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmF3W29wdGlvbk5hbWVdID09PSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkge1xuICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcbiAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgcmVmaW5lZFtvcHRpb25OYW1lXSA9IHJlZmluZXJzW29wdGlvbk5hbWVdKHJhd1tvcHRpb25OYW1lXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHRyYVtvcHRpb25OYW1lXSA9IHJhd1tvcHRpb25OYW1lXVxuICAgICAgICB9XG5cbiAgICAgICAgYW55Q2hhbmdlcyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW55Q2hhbmdlcykge1xuICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCA9IHJhd1xuICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZCBhcyBWaWV3T3B0aW9uc1JlZmluZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcbiAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXG4gICAgICBleHRyYSxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGREYXRlRW52KFxuICB0aW1lWm9uZTogc3RyaW5nLFxuICBleHBsaWNpdExvY2FsZTogTG9jYWxlU2luZ3VsYXJBcmcsXG4gIHdlZWtOdW1iZXJDYWxjdWxhdGlvbixcbiAgZmlyc3REYXk6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgd2Vla1RleHQsXG4gIHBsdWdpbkhvb2tzOiBQbHVnaW5Ib29rcyxcbiAgYXZhaWxhYmxlTG9jYWxlRGF0YTogUmF3TG9jYWxlSW5mbyxcbiAgZGVmYXVsdFNlcGFyYXRvcjogc3RyaW5nLFxuKSB7XG4gIGxldCBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcClcblxuICByZXR1cm4gbmV3IERhdGVFbnYoe1xuICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsIC8vIFRPRE86IG1ha2UgdGhpcyBhIHNldHRpbmdcbiAgICB0aW1lWm9uZSxcbiAgICBuYW1lZFRpbWVab25lSW1wbDogcGx1Z2luSG9va3MubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgIGxvY2FsZSxcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sXG4gICAgZmlyc3REYXksXG4gICAgd2Vla1RleHQsXG4gICAgY21kRm9ybWF0dGVyOiBwbHVnaW5Ib29rcy5jbWRGb3JtYXR0ZXIsXG4gICAgZGVmYXVsdFNlcGFyYXRvcixcbiAgfSlcbn1cblxuZnVuY3Rpb24gYnVpbGRUaGVtZShvcHRpb25zOiBDYWxlbmRhck9wdGlvbnNSZWZpbmVkLCBwbHVnaW5Ib29rczogUGx1Z2luSG9va3MpIHtcbiAgbGV0IFRoZW1lQ2xhc3MgPSBwbHVnaW5Ib29rcy50aGVtZUNsYXNzZXNbb3B0aW9ucy50aGVtZVN5c3RlbV0gfHwgU3RhbmRhcmRUaGVtZVxuXG4gIHJldHVybiBuZXcgVGhlbWVDbGFzcyhvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzOiBEYXRlUHJvZmlsZUdlbmVyYXRvclByb3BzKTogRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICBsZXQgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgfHwgRGF0ZVByb2ZpbGVHZW5lcmF0b3JcblxuICByZXR1cm4gbmV3IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MocHJvcHMpXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVmlld0FwaSh0eXBlOiBzdHJpbmcsIGdldEN1cnJlbnREYXRhOiAoKSA9PiBDYWxlbmRhckRhdGEsIGRhdGVFbnY6IERhdGVFbnYpIHtcbiAgcmV0dXJuIG5ldyBWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KVxufVxuXG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSGFzaCk6IEV2ZW50VWlIYXNoIHtcbiAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGV2ZW50U291cmNlLnVpKVxufVxuXG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCYXNlcyhldmVudERlZnM6IEV2ZW50RGVmSGFzaCwgZXZlbnRVaVNpbmdsZUJhc2U6IEV2ZW50VWksIGV2ZW50VWlCeVNvdXJjZTogRXZlbnRVaUhhc2gpIHtcbiAgbGV0IGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2ggPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9XG5cbiAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgbGV0IGRlZiA9IGV2ZW50RGVmc1tkZWZJZF1cblxuICAgIGlmIChkZWYuc291cmNlSWQgJiYgZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF0pIHtcbiAgICAgIGV2ZW50VWlCYXNlc1tkZWZJZF0gPSBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudFVpQmFzZXNcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgeyBvcHRpb25zIH0gPSBjYWxlbmRhckNvbnRleHRcblxuICByZXR1cm4ge1xuICAgIGV2ZW50VWlTaW5nbGVCYXNlOiBjcmVhdGVFdmVudFVpKFxuICAgICAge1xuICAgICAgICBkaXNwbGF5OiBvcHRpb25zLmV2ZW50RGlzcGxheSxcbiAgICAgICAgZWRpdGFibGU6IG9wdGlvbnMuZWRpdGFibGUsIC8vIHdpdGhvdXQgXCJldmVudFwiIGF0IHN0YXJ0XG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IG9wdGlvbnMuZXZlbnRTdGFydEVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiBvcHRpb25zLmV2ZW50RHVyYXRpb25FZGl0YWJsZSxcbiAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5ldmVudENvbnN0cmFpbnQsXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLmV2ZW50T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ldmVudE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93OiBvcHRpb25zLmV2ZW50QWxsb3csXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5ldmVudEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuZXZlbnRCb3JkZXJDb2xvcixcbiAgICAgICAgdGV4dENvbG9yOiBvcHRpb25zLmV2ZW50VGV4dENvbG9yLFxuICAgICAgICBjb2xvcjogb3B0aW9ucy5ldmVudENvbG9yLFxuICAgICAgICAvLyBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcyAvLyByZW5kZXIgaG9vayB3aWxsIGhhbmRsZSB0aGlzXG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJDb250ZXh0LFxuICAgICksXG4gICAgc2VsZWN0aW9uQ29uZmlnOiBjcmVhdGVFdmVudFVpKFxuICAgICAge1xuICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsXG4gICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLnNlbGVjdE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3c6IG9wdGlvbnMuc2VsZWN0QWxsb3csXG4gICAgICB9LFxuICAgICAgY2FsZW5kYXJDb250ZXh0LFxuICAgICksXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZTogQ2FsZW5kYXJEYXRhTWFuYWdlclN0YXRlLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgZm9yIChsZXQgaXNMb2FkaW5nRnVuYyBvZiBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzKSB7XG4gICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KVxufVxuXG5mdW5jdGlvbiB3YXJuVW5rbm93bk9wdGlvbnMob3B0aW9uczogYW55LCB2aWV3TmFtZT86IHN0cmluZykge1xuICBmb3IgKGxldCBvcHRpb25OYW1lIGluIG9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgVW5rbm93biBvcHRpb24gJyR7b3B0aW9uTmFtZX0nYCArXG4gICAgICAodmlld05hbWUgPyBgIGZvciB2aWV3ICcke3ZpZXdOYW1lfSdgIDogJycpLFxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb21wb25lbnRDaGlsZHJlbiB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBDYWxlbmRhckRhdGFNYW5hZ2VyIH0gZnJvbSAnLi4vcmVkdWNlcnMvQ2FsZW5kYXJEYXRhTWFuYWdlcidcbmltcG9ydCB7IENhbGVuZGFyQXBpIH0gZnJvbSAnLi4vQ2FsZW5kYXJBcGknXG5pbXBvcnQgeyBDYWxlbmRhckRhdGEgfSBmcm9tICcuLi9yZWR1Y2Vycy9kYXRhLXR5cGVzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyRGF0YVByb3ZpZGVyUHJvcHMge1xuICBvcHRpb25PdmVycmlkZXM6IGFueVxuICBjYWxlbmRhckFwaTogQ2FsZW5kYXJBcGlcbiAgY2hpbGRyZW4/OiAoZGF0YTogQ2FsZW5kYXJEYXRhKSA9PiBDb21wb25lbnRDaGlsZHJlblxufVxuXG4vLyBUT0RPOiBtb3ZlIHRoaXMgdG8gcmVhY3QgcGx1Z2luP1xuZXhwb3J0IGNsYXNzIENhbGVuZGFyRGF0YVByb3ZpZGVyIGV4dGVuZHMgQ29tcG9uZW50PENhbGVuZGFyRGF0YVByb3ZpZGVyUHJvcHMsIENhbGVuZGFyRGF0YT4ge1xuICBkYXRhTWFuYWdlcjogQ2FsZW5kYXJEYXRhTWFuYWdlclxuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBDYWxlbmRhckRhdGFQcm92aWRlclByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG5cbiAgICB0aGlzLmRhdGFNYW5hZ2VyID0gbmV3IENhbGVuZGFyRGF0YU1hbmFnZXIoe1xuICAgICAgb3B0aW9uT3ZlcnJpZGVzOiBwcm9wcy5vcHRpb25PdmVycmlkZXMsXG4gICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICBvbkRhdGE6IHRoaXMuaGFuZGxlRGF0YSxcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRGF0YSA9IChkYXRhOiBDYWxlbmRhckRhdGEpID0+IHtcbiAgICBpZiAoIXRoaXMuZGF0YU1hbmFnZXIpIHsgLy8gc3RpbGwgd2l0aGluIGluaXRpYWwgcnVuLCBiZWZvcmUgYXNzaWdubWVudCBpbiBjb25zdHJ1Y3RvclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWRpcmVjdC1tdXRhdGlvbi1zdGF0ZVxuICAgICAgdGhpcy5zdGF0ZSA9IGRhdGEgLy8gY2FuJ3QgdXNlIHNldFN0YXRlIHlldFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0YXRlKGRhdGEpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuc3RhdGUpXG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBDYWxlbmRhckRhdGFQcm92aWRlclByb3BzKSB7XG4gICAgbGV0IG5ld09wdGlvbk92ZXJyaWRlcyA9IHRoaXMucHJvcHMub3B0aW9uT3ZlcnJpZGVzXG5cbiAgICBpZiAobmV3T3B0aW9uT3ZlcnJpZGVzICE9PSBwcmV2UHJvcHMub3B0aW9uT3ZlcnJpZGVzKSB7IC8vIHByZXZlbnQgcmVjdXJzaXZlIGhhbmRsZURhdGFcbiAgICAgIHRoaXMuZGF0YU1hbmFnZXIucmVzZXRPcHRpb25zKG5ld09wdGlvbk92ZXJyaWRlcylcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc3RvcmUnXG5pbXBvcnQgeyBFdmVudFVpSGFzaCB9IGZyb20gJy4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgc2xpY2VFdmVudFN0b3JlLCBFdmVudFJlbmRlclJhbmdlIH0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgRGF0ZVNwYW4gfSBmcm9tICcuL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvZXZlbnQtaW50ZXJhY3Rpb24tc3RhdGUnXG5pbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4vZGF0ZWxpYi9kdXJhdGlvbidcblxuZXhwb3J0IGludGVyZmFjZSBWaWV3UHJvcHMge1xuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgYnVzaW5lc3NIb3VyczogRXZlbnRTdG9yZVxuICBldmVudFN0b3JlOiBFdmVudFN0b3JlXG4gIGV2ZW50VWlCYXNlczogRXZlbnRVaUhhc2hcbiAgZGF0ZVNlbGVjdGlvbjogRGF0ZVNwYW4gfCBudWxsXG4gIGV2ZW50U2VsZWN0aW9uOiBzdHJpbmdcbiAgZXZlbnREcmFnOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudEludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGlzSGVpZ2h0QXV0bzogYm9vbGVhblxuICBmb3JQcmludDogYm9vbGVhblxufVxuXG4vLyBIRUxQRVJTXG5cbi8qXG5pZiBuZXh0RGF5VGhyZXNob2xkIGlzIHNwZWNpZmllZCwgc2xpY2luZyBpcyBkb25lIGluIGFuIGFsbC1kYXkgZmFzaGlvbi5cbnlvdSBjYW4gZ2V0IG5leHREYXlUaHJlc2hvbGQgZnJvbSBjb250ZXh0Lm5leHREYXlUaHJlc2hvbGRcbiovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VFdmVudHMoXG4gIHByb3BzOiBWaWV3UHJvcHMgJiB7IGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb24gfSxcbiAgYWxsRGF5PzogYm9vbGVhbixcbik6IEV2ZW50UmVuZGVyUmFuZ2VbXSB7XG4gIHJldHVybiBzbGljZUV2ZW50U3RvcmUoXG4gICAgcHJvcHMuZXZlbnRTdG9yZSxcbiAgICBwcm9wcy5ldmVudFVpQmFzZXMsXG4gICAgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsXG4gICAgYWxsRGF5ID8gcHJvcHMubmV4dERheVRocmVzaG9sZCA6IG51bGwsXG4gICkuZmdcbn1cbiIsImV4cG9ydCBhYnN0cmFjdCBjbGFzcyBOYW1lZFRpbWVab25lSW1wbCB7XG4gIHRpbWVab25lTmFtZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IodGltZVpvbmVOYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZVxuICB9XG5cbiAgYWJzdHJhY3Qgb2Zmc2V0Rm9yQXJyYXkoYTogbnVtYmVyW10pOiBudW1iZXJcblxuICBhYnN0cmFjdCB0aW1lc3RhbXBUb0FycmF5KG1zOiBudW1iZXIpOiBudW1iZXJbXVxufVxuXG5leHBvcnQgdHlwZSBOYW1lZFRpbWVab25lSW1wbENsYXNzID0geyBuZXcodGltZVpvbmVOYW1lOiBzdHJpbmcpOiBOYW1lZFRpbWVab25lSW1wbCB9XG4iLCJleHBvcnQgaW50ZXJmYWNlIFNlZ1NwYW4ge1xuICBzdGFydDogbnVtYmVyXG4gIGVuZDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VnRW50cnkge1xuICBpbmRleDogbnVtYmVyXG4gIHRoaWNrbmVzczogbnVtYmVyIC8vIHNob3VsZCBiZSBhbiBpbnRlZ2VyXG4gIHNwYW46IFNlZ1NwYW5cbn1cblxuLy8gdXNlZCBpbnRlcm5hbGx5LiBleHBvc2VkIGZvciBzdWJjbGFzc2VzIG9mIFNlZ0hpZXJhcmNoeVxuZXhwb3J0IGludGVyZmFjZSBTZWdJbnNlcnRpb24ge1xuICBsZXZlbDogbnVtYmVyIC8vIHdpbGwgaGF2ZSBhbiBlcXVhbCBjb29yZCwgb3Igc2xpZ2h0bHkgYmVmb3JlLCBlbnRyaWVzIGluIGV4aXN0aW5nIGxldmVsXG4gIGxldmVsQ29vcmQ6IG51bWJlclxuICBsYXRlcmFsOiBudW1iZXIgLy8gd2hlcmUgdG8gaW5zZXJ0IGluIHRoZSBleGlzdGluZyBsZXZlbC4gLTEgaWYgY3JlYXRpbmcgYSBuZXcgbGV2ZWxcbiAgdG91Y2hpbmdMZXZlbDogbnVtYmVyIC8vIC0xIGlmIG5vIHRvdWNoaW5nXG4gIHRvdWNoaW5nTGF0ZXJhbDogbnVtYmVyIC8vIC0xIGlmIG5vIHRvdWNoaW5nXG4gIHRvdWNoaW5nRW50cnk6IFNlZ0VudHJ5IC8vIHRoZSBsYXN0IHRvdWNoaW5nIGVudHJ5IGluIHRoZSBsZXZlbFxuICBzdGFja0NudDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VnUmVjdCBleHRlbmRzIFNlZ0VudHJ5IHtcbiAgbGV2ZWxDb29yZDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VnRW50cnlHcm91cCB7XG4gIGVudHJpZXM6IFNlZ0VudHJ5W11cbiAgc3BhbjogU2VnU3BhblxufVxuXG5leHBvcnQgY2xhc3MgU2VnSGllcmFyY2h5IHtcbiAgLy8gc2V0dGluZ3NcbiAgc3RyaWN0T3JkZXI6IGJvb2xlYW4gPSBmYWxzZVxuICBhbGxvd1Jlc2xpY2luZzogYm9vbGVhbiA9IGZhbHNlXG4gIG1heENvb3JkOiBudW1iZXIgPSAtMSAvLyAtMSBtZWFucyBubyBtYXhcbiAgbWF4U3RhY2tDbnQ6IG51bWJlciA9IC0xIC8vIC0xIG1lYW5zIG5vIG1heFxuXG4gIGxldmVsQ29vcmRzOiBudW1iZXJbXSA9IFtdIC8vIG9yZGVyZWRcbiAgZW50cmllc0J5TGV2ZWw6IFNlZ0VudHJ5W11bXSA9IFtdIC8vIHBhcmFsbGVsIHdpdGggbGV2ZWxDb29yZHNcbiAgc3RhY2tDbnRzOiB7IFtlbnRyeUlkOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9IC8vIFRPRE86IHVzZSBiZXR0ZXIgdGVjaG5pcXVlIT9cblxuICBhZGRTZWdzKGlucHV0czogU2VnRW50cnlbXSk6IFNlZ0VudHJ5W10ge1xuICAgIGxldCBoaWRkZW5FbnRyaWVzOiBTZWdFbnRyeVtdID0gW11cblxuICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgdGhpcy5pbnNlcnRFbnRyeShpbnB1dCwgaGlkZGVuRW50cmllcylcbiAgICB9XG5cbiAgICByZXR1cm4gaGlkZGVuRW50cmllc1xuICB9XG5cbiAgaW5zZXJ0RW50cnkoZW50cnk6IFNlZ0VudHJ5LCBoaWRkZW5FbnRyaWVzOiBTZWdFbnRyeVtdKTogbnVtYmVyIHtcbiAgICBsZXQgaW5zZXJ0aW9uID0gdGhpcy5maW5kSW5zZXJ0aW9uKGVudHJ5KVxuXG4gICAgaWYgKHRoaXMuaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSkge1xuICAgICAgdGhpcy5pbnNlcnRFbnRyeUF0KGVudHJ5LCBpbnNlcnRpb24pXG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcylcbiAgfVxuXG4gIGlzSW5zZXJ0aW9uVmFsaWQoaW5zZXJ0aW9uOiBTZWdJbnNlcnRpb24sIGVudHJ5OiBTZWdFbnRyeSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAodGhpcy5tYXhDb29yZCA9PT0gLTEgfHwgaW5zZXJ0aW9uLmxldmVsQ29vcmQgKyBlbnRyeS50aGlja25lc3MgPD0gdGhpcy5tYXhDb29yZCkgJiZcbiAgICAgICh0aGlzLm1heFN0YWNrQ250ID09PSAtMSB8fCBpbnNlcnRpb24uc3RhY2tDbnQgPCB0aGlzLm1heFN0YWNrQ250KVxuICB9XG5cbiAgLy8gcmV0dXJucyBudW1iZXIgb2YgbmV3IGVudHJpZXMgaW5zZXJ0ZWRcbiAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb246IFNlZ0luc2VydGlvbiwgZW50cnk6IFNlZ0VudHJ5LCBoaWRkZW5FbnRyaWVzOiBTZWdFbnRyeVtdKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZyAmJiBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpXG4gICAgfVxuXG4gICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KVxuICAgIHJldHVybiAwXG4gIH1cblxuICBzcGxpdEVudHJ5KGVudHJ5OiBTZWdFbnRyeSwgYmFycmllcjogU2VnRW50cnksIGhpZGRlbkVudHJpZXM6IFNlZ0VudHJ5W10pOiBudW1iZXIge1xuICAgIGxldCBwYXJ0Q250ID0gMFxuICAgIGxldCBzcGxpdEhpZGRlbkVudHJpZXM6IFNlZ0VudHJ5W10gPSBbXVxuICAgIGxldCBlbnRyeVNwYW4gPSBlbnRyeS5zcGFuXG4gICAgbGV0IGJhcnJpZXJTcGFuID0gYmFycmllci5zcGFuXG5cbiAgICBpZiAoZW50cnlTcGFuLnN0YXJ0IDwgYmFycmllclNwYW4uc3RhcnQpIHtcbiAgICAgIHBhcnRDbnQgKz0gdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgIHNwYW46IHsgc3RhcnQ6IGVudHJ5U3Bhbi5zdGFydCwgZW5kOiBiYXJyaWVyU3Bhbi5zdGFydCB9LFxuICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKVxuICAgIH1cblxuICAgIGlmIChlbnRyeVNwYW4uZW5kID4gYmFycmllclNwYW4uZW5kKSB7XG4gICAgICBwYXJ0Q250ICs9IHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICBzcGFuOiB7IHN0YXJ0OiBiYXJyaWVyU3Bhbi5lbmQsIGVuZDogZW50cnlTcGFuLmVuZCB9LFxuICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKVxuICAgIH1cblxuICAgIGlmIChwYXJ0Q250KSB7XG4gICAgICBoaWRkZW5FbnRyaWVzLnB1c2goe1xuICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICBzcGFuOiBpbnRlcnNlY3RTcGFucyhiYXJyaWVyU3BhbiwgZW50cnlTcGFuKSwgLy8gZ3VhcmFudGVlZCB0byBpbnRlcnNlY3RcbiAgICAgIH0sIC4uLnNwbGl0SGlkZGVuRW50cmllcylcbiAgICAgIHJldHVybiBwYXJ0Q250XG4gICAgfVxuXG4gICAgaGlkZGVuRW50cmllcy5wdXNoKGVudHJ5KVxuICAgIHJldHVybiAwXG4gIH1cblxuICBpbnNlcnRFbnRyeUF0KGVudHJ5OiBTZWdFbnRyeSwgaW5zZXJ0aW9uOiBTZWdJbnNlcnRpb24pOiB2b2lkIHtcbiAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXNcblxuICAgIGlmIChpbnNlcnRpb24ubGF0ZXJhbCA9PT0gLTEpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBsZXZlbFxuICAgICAgaW5zZXJ0QXQobGV2ZWxDb29yZHMsIGluc2VydGlvbi5sZXZlbCwgaW5zZXJ0aW9uLmxldmVsQ29vcmQpXG4gICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbCwgaW5zZXJ0aW9uLmxldmVsLCBbZW50cnldKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbnNlcnQgaW50byBleGlzdGluZyBsZXZlbFxuICAgICAgaW5zZXJ0QXQoZW50cmllc0J5TGV2ZWxbaW5zZXJ0aW9uLmxldmVsXSwgaW5zZXJ0aW9uLmxhdGVyYWwsIGVudHJ5KVxuICAgIH1cblxuICAgIHRoaXMuc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkoZW50cnkpXSA9IGluc2VydGlvbi5zdGFja0NudFxuICB9XG5cbiAgZmluZEluc2VydGlvbihuZXdFbnRyeTogU2VnRW50cnkpOiBTZWdJbnNlcnRpb24ge1xuICAgIGxldCB7IGxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCwgc3RyaWN0T3JkZXIsIHN0YWNrQ250cyB9ID0gdGhpc1xuICAgIGxldCBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aFxuICAgIGxldCBjYW5kaWRhdGVDb29yZCA9IDBcbiAgICBsZXQgdG91Y2hpbmdMZXZlbDogbnVtYmVyID0gLTFcbiAgICBsZXQgdG91Y2hpbmdMYXRlcmFsOiBudW1iZXIgPSAtMVxuICAgIGxldCB0b3VjaGluZ0VudHJ5OiBTZWdFbnRyeSA9IG51bGxcbiAgICBsZXQgc3RhY2tDbnQgPSAwXG5cbiAgICBmb3IgKGxldCB0cmFja2luZ0xldmVsID0gMDsgdHJhY2tpbmdMZXZlbCA8IGxldmVsQ250OyB0cmFja2luZ0xldmVsICs9IDEpIHtcbiAgICAgIGxldCB0cmFja2luZ0Nvb3JkID0gbGV2ZWxDb29yZHNbdHJhY2tpbmdMZXZlbF1cblxuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgcGFzdCB0aGUgcGxhY2VkIGVudHJ5LCB3ZSBoYXZlIGZvdW5kIGEgZ29vZCBlbXB0eSBzcGFjZSBhbmQgY2FuIHN0b3AuXG4gICAgICAvLyBpZiBzdHJpY3RPcmRlciwga2VlcCBmaW5kaW5nIG1vcmUgbGF0ZXJhbCBpbnRlcnNlY3Rpb25zLlxuICAgICAgaWYgKCFzdHJpY3RPcmRlciAmJiB0cmFja2luZ0Nvb3JkID49IGNhbmRpZGF0ZUNvb3JkICsgbmV3RW50cnkudGhpY2tuZXNzKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGxldCB0cmFja2luZ0VudHJpZXMgPSBlbnRyaWVzQnlMZXZlbFt0cmFja2luZ0xldmVsXVxuICAgICAgbGV0IHRyYWNraW5nRW50cnk6IFNlZ0VudHJ5XG4gICAgICBsZXQgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKSAvLyBmaW5kIGZpcnN0IGVudHJ5IGFmdGVyIG5ld0VudHJ5J3MgZW5kXG4gICAgICBsZXQgbGF0ZXJhbEluZGV4ID0gc2VhcmNoUmVzWzBdICsgc2VhcmNoUmVzWzFdIC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxuXG4gICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAodHJhY2tpbmdFbnRyeSA9IHRyYWNraW5nRW50cmllc1tsYXRlcmFsSW5kZXhdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIGVudHJ5IGxpc3RcbiAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICApIHtcbiAgICAgICAgbGV0IHRyYWNraW5nRW50cnlCb3R0b20gPSB0cmFja2luZ0Nvb3JkICsgdHJhY2tpbmdFbnRyeS50aGlja25lc3NcbiAgICAgICAgLy8gaW50ZXJzZWN0cyBpbnRvIHRoZSB0b3Agb2YgdGhlIGNhbmRpZGF0ZT9cbiAgICAgICAgaWYgKHRyYWNraW5nRW50cnlCb3R0b20gPiBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgIGNhbmRpZGF0ZUNvb3JkID0gdHJhY2tpbmdFbnRyeUJvdHRvbVxuICAgICAgICAgIHRvdWNoaW5nRW50cnkgPSB0cmFja2luZ0VudHJ5XG4gICAgICAgICAgdG91Y2hpbmdMZXZlbCA9IHRyYWNraW5nTGV2ZWxcbiAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwgPSBsYXRlcmFsSW5kZXhcbiAgICAgICAgfVxuICAgICAgICAvLyBidXR0cyB1cCBhZ2FpbnN0IHRvcCBvZiBjYW5kaWRhdGU/ICh3aWxsIGhhcHBlbiBpZiBqdXN0IGludGVyc2VjdGVkIGFzIHdlbGwpXG4gICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgIC8vIGFjY3VtdWxhdGUgdGhlIGhpZ2hlc3QgcG9zc2libGUgc3RhY2tDbnQgb2YgdGhlIHRyYWNraW5nRW50cmllcyB0aGF0IGJ1dHQgdXBcbiAgICAgICAgICBzdGFja0NudCA9IE1hdGgubWF4KHN0YWNrQ250LCBzdGFja0NudHNbYnVpbGRFbnRyeUtleSh0cmFja2luZ0VudHJ5KV0gKyAxKVxuICAgICAgICB9XG4gICAgICAgIGxhdGVyYWxJbmRleCArPSAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdGhlIGRlc3RpbmF0aW9uIGxldmVsIHdpbGwgYmUgYWZ0ZXIgdG91Y2hpbmdFbnRyeSdzIGxldmVsLiBmaW5kIGl0XG4gICAgbGV0IGRlc3RMZXZlbCA9IDBcbiAgICBpZiAodG91Y2hpbmdFbnRyeSkge1xuICAgICAgZGVzdExldmVsID0gdG91Y2hpbmdMZXZlbCArIDFcbiAgICAgIHdoaWxlIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdIDwgY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgZGVzdExldmVsICs9IDFcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBhZGRpbmcgdG8gYW4gZXhpc3RpbmcgbGV2ZWwsIGZpbmQgd2hlcmUgdG8gaW5zZXJ0XG4gICAgbGV0IGRlc3RMYXRlcmFsID0gLTFcbiAgICBpZiAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgIGRlc3RMYXRlcmFsID0gYmluYXJ5U2VhcmNoKGVudHJpZXNCeUxldmVsW2Rlc3RMZXZlbF0sIG5ld0VudHJ5LnNwYW4uZW5kLCBnZXRFbnRyeVNwYW5FbmQpWzBdXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdWNoaW5nTGV2ZWwsXG4gICAgICB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICB0b3VjaGluZ0VudHJ5LFxuICAgICAgc3RhY2tDbnQsXG4gICAgICBsZXZlbENvb3JkOiBjYW5kaWRhdGVDb29yZCxcbiAgICAgIGxldmVsOiBkZXN0TGV2ZWwsXG4gICAgICBsYXRlcmFsOiBkZXN0TGF0ZXJhbCxcbiAgICB9XG4gIH1cblxuICAvLyBzb3J0ZWQgYnkgbGV2ZWxDb29yZCAobG93ZXN0IHRvIGhpZ2hlc3QpXG4gIHRvUmVjdHMoKTogU2VnUmVjdFtdIHtcbiAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXNcbiAgICBsZXQgbGV2ZWxDbnQgPSBlbnRyaWVzQnlMZXZlbC5sZW5ndGhcbiAgICBsZXQgcmVjdHM6IFNlZ1JlY3RbXSA9IFtdXG5cbiAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdXG4gICAgICBsZXQgbGV2ZWxDb29yZCA9IGxldmVsQ29vcmRzW2xldmVsXVxuXG4gICAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIHJlY3RzLnB1c2goeyAuLi5lbnRyeSwgbGV2ZWxDb29yZCB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWN0c1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnRyeVNwYW5FbmQoZW50cnk6IFNlZ0VudHJ5KSB7XG4gIHJldHVybiBlbnRyeS5zcGFuLmVuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRFbnRyeUtleShlbnRyeTogU2VnRW50cnkpIHsgLy8gVE9ETzogdXNlIE1hcCBpbnN0ZWFkP1xuICByZXR1cm4gZW50cnkuaW5kZXggKyAnOicgKyBlbnRyeS5zcGFuLnN0YXJ0XG59XG5cbi8vIHJldHVybnMgZ3JvdXBzIHdpdGggZW50cmllcyBzb3J0ZWQgYnkgaW5wdXQgb3JkZXJcbmV4cG9ydCBmdW5jdGlvbiBncm91cEludGVyc2VjdGluZ0VudHJpZXMoZW50cmllczogU2VnRW50cnlbXSk6IFNlZ0VudHJ5R3JvdXBbXSB7XG4gIGxldCBtZXJnZXM6IFNlZ0VudHJ5R3JvdXBbXSA9IFtdXG5cbiAgZm9yIChsZXQgZW50cnkgb2YgZW50cmllcykge1xuICAgIGxldCBmaWx0ZXJlZE1lcmdlczogU2VnRW50cnlHcm91cFtdID0gW11cbiAgICBsZXQgaHVuZ3J5TWVyZ2U6IFNlZ0VudHJ5R3JvdXAgPSB7IC8vIHRoZSBtZXJnZSB0aGF0IHdpbGwgZWF0IHdoYXQgaXQgY29sbGlkZXMgd2l0aFxuICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgfVxuXG4gICAgZm9yIChsZXQgbWVyZ2Ugb2YgbWVyZ2VzKSB7XG4gICAgICBpZiAoaW50ZXJzZWN0U3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbikpIHtcbiAgICAgICAgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgZW50cmllczogbWVyZ2UuZW50cmllcy5jb25jYXQoaHVuZ3J5TWVyZ2UuZW50cmllcyksIC8vIGtlZXAgcHJlZXhpc3RpbmcgbWVyZ2UncyBpdGVtcyBmaXJzdC4gbWFpbnRhaW5zIG9yZGVyXG4gICAgICAgICAgc3Bhbjogam9pblNwYW5zKG1lcmdlLnNwYW4sIGh1bmdyeU1lcmdlLnNwYW4pLFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWx0ZXJlZE1lcmdlcy5wdXNoKG1lcmdlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlcmVkTWVyZ2VzLnB1c2goaHVuZ3J5TWVyZ2UpXG4gICAgbWVyZ2VzID0gZmlsdGVyZWRNZXJnZXNcbiAgfVxuXG4gIHJldHVybiBtZXJnZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5TcGFucyhzcGFuMDogU2VnU3Bhbiwgc3BhbjE6IFNlZ1NwYW4pOiBTZWdTcGFuIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogTWF0aC5taW4oc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KSxcbiAgICBlbmQ6IE1hdGgubWF4KHNwYW4wLmVuZCwgc3BhbjEuZW5kKSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0U3BhbnMoc3BhbjA6IFNlZ1NwYW4sIHNwYW4xOiBTZWdTcGFuKTogU2VnU3BhbiB8IG51bGwge1xuICBsZXQgc3RhcnQgPSBNYXRoLm1heChzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpXG4gIGxldCBlbmQgPSBNYXRoLm1pbihzcGFuMC5lbmQsIHNwYW4xLmVuZClcblxuICBpZiAoc3RhcnQgPCBlbmQpIHtcbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbi8vIGdlbmVyYWwgdXRpbFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGluc2VydEF0PEl0ZW0+KGFycjogSXRlbVtdLCBpbmRleDogbnVtYmVyLCBpdGVtOiBJdGVtKSB7XG4gIGFyci5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8SXRlbT4oXG4gIGE6IEl0ZW1bXSxcbiAgc2VhcmNoVmFsOiBudW1iZXIsXG4gIGdldEl0ZW1WYWw6IChpdGVtOiBJdGVtKSA9PiBudW1iZXIsXG4pOiBbbnVtYmVyLCBudW1iZXJdIHsgLy8gcmV0dXJucyBbbGV2ZWwsIGlzRXhhY3RNYXRjaCA/IDEgOiAwXVxuICBsZXQgc3RhcnRJbmRleCA9IDBcbiAgbGV0IGVuZEluZGV4ID0gYS5sZW5ndGggLy8gZXhjbHVzaXZlXG5cbiAgaWYgKCFlbmRJbmRleCB8fCBzZWFyY2hWYWwgPCBnZXRJdGVtVmFsKGFbc3RhcnRJbmRleF0pKSB7IC8vIG5vIGl0ZW1zIE9SIGJlZm9yZSBmaXJzdCBpdGVtXG4gICAgcmV0dXJuIFswLCAwXVxuICB9XG4gIGlmIChzZWFyY2hWYWwgPiBnZXRJdGVtVmFsKGFbZW5kSW5kZXggLSAxXSkpIHsgLy8gYWZ0ZXIgbGFzdCBpdGVtXG4gICAgcmV0dXJuIFtlbmRJbmRleCwgMF1cbiAgfVxuXG4gIHdoaWxlIChzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICBsZXQgbWlkZGxlSW5kZXggPSBNYXRoLmZsb29yKHN0YXJ0SW5kZXggKyAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIDIpXG4gICAgbGV0IG1pZGRsZVZhbCA9IGdldEl0ZW1WYWwoYVttaWRkbGVJbmRleF0pXG5cbiAgICBpZiAoc2VhcmNoVmFsIDwgbWlkZGxlVmFsKSB7XG4gICAgICBlbmRJbmRleCA9IG1pZGRsZUluZGV4XG4gICAgfSBlbHNlIGlmIChzZWFyY2hWYWwgPiBtaWRkbGVWYWwpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSBtaWRkbGVJbmRleCArIDFcbiAgICB9IGVsc2UgeyAvLyBlcXVhbCFcbiAgICAgIHJldHVybiBbbWlkZGxlSW5kZXgsIDFdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtzdGFydEluZGV4LCAwXVxufVxuIiwiaW1wb3J0IHsgRGF0ZUNvbXBvbmVudCB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgSGl0IH0gZnJvbSAnLi9oaXQnXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbnRlcmFjdGlvbiB7XG4gIGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+XG4gIGlzSGl0Q29tYm9BbGxvd2VkOiAoKGhpdDA6IEhpdCwgaGl0MTogSGl0KSA9PiBib29sZWFuKSB8IG51bGxcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHRoaXMuY29tcG9uZW50ID0gc2V0dGluZ3MuY29tcG9uZW50XG4gICAgdGhpcy5pc0hpdENvbWJvQWxsb3dlZCA9IHNldHRpbmdzLmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGxcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgSW50ZXJhY3Rpb25DbGFzcyA9IHsgbmV3KHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKTogSW50ZXJhY3Rpb24gfVxuXG5leHBvcnQgaW50ZXJmYWNlIEludGVyYWN0aW9uU2V0dGluZ3NJbnB1dCB7XG4gIGVsOiBIVE1MRWxlbWVudFxuICB1c2VFdmVudENlbnRlcj86IGJvb2xlYW5cbiAgaXNIaXRDb21ib0FsbG93ZWQ/OiAoaGl0MDogSGl0LCBoaXQxOiBIaXQpID0+IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnRlcmFjdGlvblNldHRpbmdzIHtcbiAgY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT5cbiAgZWw6IEhUTUxFbGVtZW50XG4gIHVzZUV2ZW50Q2VudGVyOiBib29sZWFuXG4gIGlzSGl0Q29tYm9BbGxvd2VkOiAoKGhpdDA6IEhpdCwgaGl0MTogSGl0KSA9PiBib29sZWFuKSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgSW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0geyBbY29tcG9uZW5VaWQ6IHN0cmluZ106IEludGVyYWN0aW9uU2V0dGluZ3MgfVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBpbnB1dDogSW50ZXJhY3Rpb25TZXR0aW5nc0lucHV0KTogSW50ZXJhY3Rpb25TZXR0aW5ncyB7XG4gIHJldHVybiB7XG4gICAgY29tcG9uZW50LFxuICAgIGVsOiBpbnB1dC5lbCxcbiAgICB1c2VFdmVudENlbnRlcjogaW5wdXQudXNlRXZlbnRDZW50ZXIgIT0gbnVsbCA/IGlucHV0LnVzZUV2ZW50Q2VudGVyIDogdHJ1ZSxcbiAgICBpc0hpdENvbWJvQWxsb3dlZDogaW5wdXQuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbCxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3M6IEludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICBbc2V0dGluZ3MuY29tcG9uZW50LnVpZF06IHNldHRpbmdzLFxuICB9XG59XG5cbi8vIGdsb2JhbCBzdGF0ZVxuZXhwb3J0IGNvbnN0IGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZTogSW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlID0ge31cbiIsImltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi9jb21tb24vRW1pdHRlcidcblxuLypcbkFuIGFic3RyYWN0aW9uIGZvciBhIGRyYWdnaW5nIGludGVyYWN0aW9uIG9yaWdpbmF0aW5nIG9uIGFuIGV2ZW50LlxuRG9lcyBoaWdoZXItbGV2ZWwgdGhpbmdzIHRoYW4gUG9pbnRlckRyYWdnZXIsIHN1Y2ggYXMgcG9zc2libHk6XG4tIGEgXCJtaXJyb3JcIiB0aGF0IG1vdmVzIHdpdGggdGhlIHBvaW50ZXJcbi0gYSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgb3Igb3RoZXIgY3JpdGVyaWEgZm9yIGEgdHJ1ZSBkcmFnIHRvIGJlZ2luXG5cbnN1YmNsYXNzZXMgbXVzdCBlbWl0OlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gZHJhZ21vdmVcbi0gcG9pbnRlcnVwXG4tIGRyYWdlbmRcbiovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRWxlbWVudERyYWdnaW5nIHsgLy8gVE9ETzogcmVuYW1lIHRvICpJbnRlcmZhY2U/XG4gIGVtaXR0ZXI6IEVtaXR0ZXI8YW55PlxuXG4gIGNvbnN0cnVjdG9yKGVsOiBIVE1MRWxlbWVudCwgc2VsZWN0b3I/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICB9XG5cbiAgLy8gaWYgZ2l2ZW4gdHJ1ZSwgc2hvdWxkIHByZXZlbnQgZHJhZ3N0YXJ0K2RyYWdtb3ZlK2RyYWdlbmQgZnJvbSBmaXJpbmdcbiAgYWJzdHJhY3Qgc2V0SWdub3JlTW92ZShib29sOiBib29sZWFuKTogdm9pZFxuXG4gIHNldE1pcnJvcklzVmlzaWJsZShib29sOiBib29sZWFuKSB7XG4gICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgfVxuXG4gIHNldE1pcnJvck5lZWRzUmV2ZXJ0KGJvb2w6IGJvb2xlYW4pIHtcbiAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICB9XG5cbiAgc2V0QXV0b1Njcm9sbEVuYWJsZWQoYm9vbDogYm9vbGVhbikge1xuICAgIC8vIG9wdGlvbmFsXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgRWxlbWVudERyYWdnaW5nQ2xhc3MgPSB7IG5ldyhlbDogSFRNTEVsZW1lbnQsIHNlbGVjdG9yPzogc3RyaW5nKTogRWxlbWVudERyYWdnaW5nIH1cbiIsIi8vIFRPRE86IGdldCByaWQgb2YgdGhpcyBpbiBmYXZvciBvZiBvcHRpb25zIHN5c3RlbSxcbi8vIHRobyBpdCdzIHJlYWxseSBlYXN5IHRvIGFjY2VzcyB0aGlzIGdsb2JhbGx5IHJhdGhlciB0aGFuIHBhc3MgdGhydSBvcHRpb25zLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHt9IGFzIGFueVxuIiwiaW1wb3J0IHsgY3JlYXRlRHVyYXRpb24sIER1cmF0aW9uIH0gZnJvbSAnLi4vZGF0ZWxpYi9kdXJhdGlvbidcbmltcG9ydCB7IHJlZmluZVByb3BzLCBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cblxuY29uc3QgRFJBR19NRVRBX1JFRklORVJTID0ge1xuICBzdGFydFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gIGNyZWF0ZTogQm9vbGVhbixcbiAgc291cmNlSWQ6IFN0cmluZyxcbn1cblxuZXhwb3J0IHR5cGUgRHJhZ01ldGFJbnB1dCA9XG4gIFJhd09wdGlvbnNGcm9tUmVmaW5lcnM8dHlwZW9mIERSQUdfTUVUQV9SRUZJTkVSUz4gJlxuICB7IFtvdGhlclByb3A6IHN0cmluZ106IGFueSB9IC8vIGZvciBsZWZ0b3ZlclByb3BzXG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ01ldGEge1xuICBzdGFydFRpbWU6IER1cmF0aW9uIHwgbnVsbFxuICBkdXJhdGlvbjogRHVyYXRpb24gfCBudWxsXG4gIGNyZWF0ZTogYm9vbGVhbiAvLyBjcmVhdGUgYW4gZXZlbnQgd2hlbiBkcm9wcGVkP1xuICBzb3VyY2VJZDogc3RyaW5nIC8vIHNpbWlsYXIgdG8gYWRkRXZlbnQncyBwYXJhbWV0ZXJcbiAgbGVmdG92ZXJQcm9wczogRGljdGlvbmFyeVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEcmFnTWV0YShyYXc6IERyYWdNZXRhSW5wdXQpOiBEcmFnTWV0YSB7XG4gIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUylcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICBkdXJhdGlvbjogcmVmaW5lZC5kdXJhdGlvbiB8fCBudWxsLFxuICAgIGNyZWF0ZTogcmVmaW5lZC5jcmVhdGUgIT0gbnVsbCA/IHJlZmluZWQuY3JlYXRlIDogdHJ1ZSxcbiAgICBzb3VyY2VJZDogcmVmaW5lZC5zb3VyY2VJZCxcbiAgICBsZWZ0b3ZlclByb3BzOiBleHRyYSxcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgVk5vZGUgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBUb29sYmFyV2lkZ2V0IH0gZnJvbSAnLi90b29sYmFyLXN0cnVjdCdcblxuZXhwb3J0IGludGVyZmFjZSBUb29sYmFyQ29udGVudCB7XG4gIHRpdGxlOiBzdHJpbmdcbiAgYWN0aXZlQnV0dG9uOiBzdHJpbmdcbiAgaXNUb2RheUVuYWJsZWQ6IGJvb2xlYW5cbiAgaXNQcmV2RW5hYmxlZDogYm9vbGVhblxuICBpc05leHRFbmFibGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbGJhclNlY3Rpb25Qcm9wcyBleHRlbmRzIFRvb2xiYXJDb250ZW50IHtcbiAgd2lkZ2V0R3JvdXBzOiBUb29sYmFyV2lkZ2V0W11bXVxufVxuXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlY3Rpb24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRvb2xiYXJTZWN0aW9uUHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXMucHJvcHMud2lkZ2V0R3JvdXBzLm1hcCgod2lkZ2V0R3JvdXApID0+IHRoaXMucmVuZGVyV2lkZ2V0R3JvdXAod2lkZ2V0R3JvdXApKVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiAnZmMtdG9vbGJhci1jaHVuaycgfSwgLi4uY2hpbGRyZW4pXG4gIH1cblxuICByZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cDogVG9vbGJhcldpZGdldFtdKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyB0aGVtZSB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IGNoaWxkcmVuOiBWTm9kZVtdID0gW11cbiAgICBsZXQgaXNPbmx5QnV0dG9ucyA9IHRydWVcblxuICAgIGZvciAobGV0IHdpZGdldCBvZiB3aWRnZXRHcm91cCkge1xuICAgICAgbGV0IHsgYnV0dG9uTmFtZSwgYnV0dG9uQ2xpY2ssIGJ1dHRvblRleHQsIGJ1dHRvbkljb24gfSA9IHdpZGdldFxuXG4gICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2VcbiAgICAgICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwiZmMtdG9vbGJhci10aXRsZVwiPntwcm9wcy50aXRsZX08L2gyPixcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGFyaWFBdHRycyA9IGJ1dHRvbkljb24gPyB7ICdhcmlhLWxhYmVsJzogYnV0dG9uTmFtZSB9IDoge31cblxuICAgICAgICBsZXQgYnV0dG9uQ2xhc3NlcyA9IFtgZmMtJHtidXR0b25OYW1lfS1idXR0b25gLCB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyldXG4gICAgICAgIGlmIChidXR0b25OYW1lID09PSBwcm9wcy5hY3RpdmVCdXR0b24pIHtcbiAgICAgICAgICBidXR0b25DbGFzc2VzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkFjdGl2ZScpKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzRGlzYWJsZWQgPVxuICAgICAgICAgICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAoIXByb3BzLmlzUHJldkVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3ByZXYnKSB8fFxuICAgICAgICAgICghcHJvcHMuaXNOZXh0RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAnbmV4dCcpXG5cbiAgICAgICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17YnV0dG9uQ2xhc3Nlcy5qb2luKCcgJyl9XG4gICAgICAgICAgICBvbkNsaWNrPXtidXR0b25DbGlja31cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgey4uLmFyaWFBdHRyc31cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7YnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IDxzcGFuIGNsYXNzTmFtZT17YnV0dG9uSWNvbn0gLz4gOiAnJyl9XG4gICAgICAgICAgPC9idXR0b24+LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJ1xuXG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6IGdyb3VwQ2xhc3NOYW1lIH0sIC4uLmNoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW5bMF1cbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuL3Zkb20tdXRpbCdcbmltcG9ydCB7IFRvb2xiYXJNb2RlbCwgVG9vbGJhcldpZGdldCB9IGZyb20gJy4vdG9vbGJhci1zdHJ1Y3QnXG5pbXBvcnQgeyBUb29sYmFyU2VjdGlvbiwgVG9vbGJhckNvbnRlbnQgfSBmcm9tICcuL1Rvb2xiYXJTZWN0aW9uJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJQcm9wcyBleHRlbmRzIFRvb2xiYXJDb250ZW50IHtcbiAgZXh0cmFDbGFzc05hbWU6IHN0cmluZyAvLyB3aXNoIHRoaXMgY291bGQgYmUgYXJyYXksIGJ1dCBlYXNpZXIgZm9yIHB1cmVuZXNzXG4gIG1vZGVsOiBUb29sYmFyTW9kZWxcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2xiYXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRvb2xiYXJQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgbW9kZWwsIGV4dHJhQ2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IGZvcmNlTHRyID0gZmFsc2VcbiAgICBsZXQgc3RhcnRDb250ZW50XG4gICAgbGV0IGVuZENvbnRlbnRcbiAgICBsZXQgY2VudGVyQ29udGVudCA9IG1vZGVsLmNlbnRlclxuXG4gICAgaWYgKG1vZGVsLmxlZnQpIHtcbiAgICAgIGZvcmNlTHRyID0gdHJ1ZVxuICAgICAgc3RhcnRDb250ZW50ID0gbW9kZWwubGVmdFxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydENvbnRlbnQgPSBtb2RlbC5zdGFydFxuICAgIH1cblxuICAgIGlmIChtb2RlbC5yaWdodCkge1xuICAgICAgZm9yY2VMdHIgPSB0cnVlXG4gICAgICBlbmRDb250ZW50ID0gbW9kZWwucmlnaHRcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kQ29udGVudCA9IG1vZGVsLmVuZFxuICAgIH1cblxuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgZXh0cmFDbGFzc05hbWUgfHwgJycsXG4gICAgICAnZmMtdG9vbGJhcicsXG4gICAgICBmb3JjZUx0ciA/ICdmYy10b29sYmFyLWx0cicgOiAnJyxcbiAgICBdXG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMuam9pbignICcpfT5cbiAgICAgICAge3RoaXMucmVuZGVyU2VjdGlvbignc3RhcnQnLCBzdGFydENvbnRlbnQgfHwgW10pfVxuICAgICAgICB7dGhpcy5yZW5kZXJTZWN0aW9uKCdjZW50ZXInLCBjZW50ZXJDb250ZW50IHx8IFtdKX1cbiAgICAgICAge3RoaXMucmVuZGVyU2VjdGlvbignZW5kJywgZW5kQ29udGVudCB8fCBbXSl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICByZW5kZXJTZWN0aW9uKGtleTogc3RyaW5nLCB3aWRnZXRHcm91cHM6IFRvb2xiYXJXaWRnZXRbXVtdKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIHJldHVybiAoXG4gICAgICA8VG9vbGJhclNlY3Rpb25cbiAgICAgICAga2V5PXtrZXl9XG4gICAgICAgIHdpZGdldEdyb3Vwcz17d2lkZ2V0R3JvdXBzfVxuICAgICAgICB0aXRsZT17cHJvcHMudGl0bGV9XG4gICAgICAgIGFjdGl2ZUJ1dHRvbj17cHJvcHMuYWN0aXZlQnV0dG9ufVxuICAgICAgICBpc1RvZGF5RW5hYmxlZD17cHJvcHMuaXNUb2RheUVuYWJsZWR9XG4gICAgICAgIGlzUHJldkVuYWJsZWQ9e3Byb3BzLmlzUHJldkVuYWJsZWR9XG4gICAgICAgIGlzTmV4dEVuYWJsZWQ9e3Byb3BzLmlzTmV4dEVuYWJsZWR9XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgQmFzZUNvbXBvbmVudCwgc2V0UmVmIH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgUmVmLCBjcmVhdGVFbGVtZW50LCBWVUlFdmVudCB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IENzc0RpbVZhbHVlIH0gZnJvbSAnLi9zY3JvbGxncmlkL3V0aWwnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlld0NvbnRhaW5lclByb3BzIHtcbiAgbGlxdWlkPzogYm9vbGVhblxuICBoZWlnaHQ/OiBDc3NEaW1WYWx1ZVxuICBhc3BlY3RSYXRpbz86IG51bWJlclxuICBvbkNsaWNrPzogKGV2OiBWVUlFdmVudCkgPT4gdm9pZFxuICBlbFJlZj86IFJlZjxIVE1MRGl2RWxlbWVudD5cbiAgY2hpbGRyZW4/OiBDb21wb25lbnRDaGlsZHJlblxufVxuXG5pbnRlcmZhY2UgVmlld0NvbnRhaW5lclN0YXRlIHtcbiAgYXZhaWxhYmxlV2lkdGg6IG51bWJlciB8IG51bGxcbn1cblxuLy8gVE9ETzogZG8gZnVuY3Rpb24gY29tcG9uZW50P1xuZXhwb3J0IGNsYXNzIFZpZXdDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFZpZXdDb250YWluZXJQcm9wcywgVmlld0NvbnRhaW5lclN0YXRlPiB7XG4gIGVsOiBIVE1MRWxlbWVudFxuXG4gIHN0YXRlOiBWaWV3Q29udGFpbmVyU3RhdGUgPSB7XG4gICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgbGV0IHsgYXNwZWN0UmF0aW8gfSA9IHByb3BzXG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxuICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXG4gICAgICAgID8gJ2ZjLXZpZXctaGFybmVzcy1hY3RpdmUnIC8vIGhhcm5lc3MgY29udHJvbHMgdGhlIGhlaWdodFxuICAgICAgICA6ICdmYy12aWV3LWhhcm5lc3MtcGFzc2l2ZScsIC8vIGxldCB0aGUgdmlldyBkbyB0aGUgaGVpZ2h0XG4gICAgXVxuICAgIGxldCBoZWlnaHQ6IENzc0RpbVZhbHVlID0gJydcbiAgICBsZXQgcGFkZGluZ0JvdHRvbTogQ3NzRGltVmFsdWUgPSAnJ1xuXG4gICAgaWYgKGFzcGVjdFJhdGlvKSB7XG4gICAgICBpZiAoc3RhdGUuYXZhaWxhYmxlV2lkdGggIT09IG51bGwpIHtcbiAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpb1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hpbGUgd2FpdGluZyB0byBrbm93IGF2YWlsYWJsZVdpZHRoLCB3ZSBjYW4ndCBzZXQgaGVpZ2h0IHRvICp6ZXJvKlxuICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxuICAgICAgICAvLyBCRVRURVI6IGRvbid0IHN0YXJ0IHJlbmRlcmluZyBBTllUSElORyB5ZXQgdW50aWwgd2Uga25vdyBjb250YWluZXIgd2lkdGhcbiAgICAgICAgLy8gTk9URTogd2h5IG5vdCBhbHdheXMgdXNlIHBhZGRpbmdCb3R0b20/IENhdXNlcyBoZWlnaHQgb3NjaWxsYXRpb24gKGlzc3VlIDU2MDYpXG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBgJHsoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMH0lYFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSBwcm9wcy5oZWlnaHQgfHwgJydcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICByZWY9e3RoaXMuaGFuZGxlRWx9XG4gICAgICAgIG9uQ2xpY2s9e3Byb3BzLm9uQ2xpY2t9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5qb2luKCcgJyl9XG4gICAgICAgIHN0eWxlPXt7IGhlaWdodCwgcGFkZGluZ0JvdHRvbSB9fVxuICAgICAgPlxuICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSlcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY29udGV4dC5yZW1vdmVSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlUmVzaXplKVxuICB9XG5cbiAgaGFuZGxlRWwgPSAoZWw6IEhUTUxFbGVtZW50IHwgbnVsbCkgPT4ge1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKClcbiAgfVxuXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKClcbiAgfVxuXG4gIHVwZGF0ZUF2YWlsYWJsZVdpZHRoKCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xuICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXG4gICAgKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgYXZhaWxhYmxlV2lkdGg6IHRoaXMuZWwub2Zmc2V0V2lkdGggfSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGxpc3RlbkJ5U2VsZWN0b3IgfSBmcm9tICcuLi91dGlsL2RvbS1ldmVudCdcbmltcG9ydCB7IEV2ZW50QXBpIH0gZnJvbSAnLi4vYXBpL0V2ZW50QXBpJ1xuaW1wb3J0IHsgZWxlbWVudENsb3Nlc3QgfSBmcm9tICcuLi91dGlsL2RvbS1tYW5pcCdcbmltcG9ydCB7IGdldEVsU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IEludGVyYWN0aW9uLCBJbnRlcmFjdGlvblNldHRpbmdzIH0gZnJvbSAnLi9pbnRlcmFjdGlvbidcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50Q2xpY2tBcmcge1xuICBlbDogSFRNTEVsZW1lbnRcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG4vKlxuRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XG4qL1xuZXhwb3J0IGNsYXNzIEV2ZW50Q2xpY2tpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzOiBJbnRlcmFjdGlvblNldHRpbmdzKSB7XG4gICAgc3VwZXIoc2V0dGluZ3MpXG5cbiAgICB0aGlzLmRlc3Ryb3kgPSBsaXN0ZW5CeVNlbGVjdG9yKFxuICAgICAgc2V0dGluZ3MuZWwsXG4gICAgICAnY2xpY2snLFxuICAgICAgJy5mYy1ldmVudCcsIC8vIG9uIGJvdGggZmcgYW5kIGJnIGV2ZW50c1xuICAgICAgdGhpcy5oYW5kbGVTZWdDbGljayxcbiAgICApXG4gIH1cblxuICBoYW5kbGVTZWdDbGljayA9IChldjogRXZlbnQsIHNlZ0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpc1xuICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudFxuICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbClcblxuICAgIGlmIChcbiAgICAgIHNlZyAmJiAvLyBtaWdodCBiZSB0aGUgPGRpdj4gc3Vycm91bmRpbmcgdGhlIG1vcmUgbGlua1xuICAgICAgY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwoZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuICAgICkge1xuICAgICAgLy8gb3VyIHdheSB0byBzaW11bGF0ZSBhIGxpbmsgY2xpY2sgZm9yIGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgPGE+IHRhZ3NcbiAgICAgIC8vIGdyYWIgYmVmb3JlIHRyaWdnZXIgZmlyZWQgaW4gY2FzZSB0cmlnZ2VyIHRyYXNoZXMgRE9NIHRocnUgcmVyZW5kZXJpbmdcbiAgICAgIGxldCBoYXNVcmxDb250YWluZXIgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQsICcuZmMtZXZlbnQtZm9yY2VkLXVybCcpXG4gICAgICBsZXQgdXJsID0gaGFzVXJsQ29udGFpbmVyID8gKGhhc1VybENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdhW2hyZWZdJykgYXMgYW55KS5ocmVmIDogJydcblxuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShcbiAgICAgICAgICBjb21wb25lbnQuY29udGV4dCxcbiAgICAgICAgICBzZWcuZXZlbnRSYW5nZS5kZWYsXG4gICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICAgICksXG4gICAgICAgIGpzRXZlbnQ6IGV2IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICB9IGFzIEV2ZW50Q2xpY2tBcmcpXG5cbiAgICAgIGlmICh1cmwgJiYgIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIH0gZnJvbSAnLi4vdXRpbC9kb20tZXZlbnQnXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IGdldEVsU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IEludGVyYWN0aW9uLCBJbnRlcmFjdGlvblNldHRpbmdzIH0gZnJvbSAnLi9pbnRlcmFjdGlvbidcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50SG92ZXJpbmdBcmcge1xuICBlbDogSFRNTEVsZW1lbnRcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG4vKlxuVHJpZ2dlcnMgZXZlbnRzIGFuZCBhZGRzL3JlbW92ZXMgY29yZSBjbGFzc05hbWVzIHdoZW4gdGhlIHVzZXIncyBwb2ludGVyXG5lbnRlcnMvbGVhdmVzIGV2ZW50LWVsZW1lbnRzIG9mIGEgY29tcG9uZW50LlxuKi9cbmV4cG9ydCBjbGFzcyBFdmVudEhvdmVyaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICByZW1vdmVIb3Zlckxpc3RlbmVyczogKCkgPT4gdm9pZFxuXG4gIGN1cnJlbnRTZWdFbDogSFRNTEVsZW1lbnRcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKVxuXG4gICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycyA9IGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKFxuICAgICAgc2V0dGluZ3MuZWwsXG4gICAgICAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyLFxuICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZSxcbiAgICApXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlSG92ZXJMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gZm9yIHNpbXVsYXRpbmcgYW4gZXZlbnRNb3VzZUxlYXZlIHdoZW4gdGhlIGV2ZW50IGVsIGlzIGRlc3Ryb3llZCB3aGlsZSBtb3VzZSBpcyBvdmVyIGl0XG4gIGhhbmRsZUV2ZW50RWxSZW1vdmUgPSAoZWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsID09PSB0aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZShudWxsLCB0aGlzLmN1cnJlbnRTZWdFbClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTZWdFbnRlciA9IChldjogRXZlbnQsIHNlZ0VsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgdGhpcy5jdXJyZW50U2VnRWwgPSBzZWdFbFxuICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VFbnRlcicsIGV2LCBzZWdFbClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTZWdMZWF2ZSA9IChldjogRXZlbnQgfCBudWxsLCBzZWdFbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgICBpZiAodGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gbnVsbFxuICAgICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbClcbiAgICB9XG4gIH1cblxuICB0cmlnZ2VyRXZlbnQocHVibGljRXZOYW1lOiAnZXZlbnRNb3VzZUVudGVyJyB8ICdldmVudE1vdXNlTGVhdmUnLCBldjogRXZlbnQgfCBudWxsLCBzZWdFbDogSFRNTEVsZW1lbnQpIHtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXNcbiAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnRcbiAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpIVxuXG4gICAgaWYgKCFldiB8fCBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcihwdWJsaWNFdk5hbWUsIHtcbiAgICAgICAgZWw6IHNlZ0VsLFxuICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgIHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLFxuICAgICAgICApLFxuICAgICAgICBqc0V2ZW50OiBldiBhcyBNb3VzZUV2ZW50LCAvLyBJcyB0aGlzIGFsd2F5cyBhIG1vdXNlIGV2ZW50PyBTZWUgIzQ2NTVcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgfSBhcyBFdmVudEhvdmVyaW5nQXJnKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IFZpZXdDb250ZXh0VHlwZSwgYnVpbGRWaWV3Q29udGV4dCB9IGZyb20gJy4vVmlld0NvbnRleHQnXG5pbXBvcnQgeyBWaWV3U3BlYyB9IGZyb20gJy4vc3RydWN0cy92aWV3LXNwZWMnXG5pbXBvcnQgeyBWaWV3UHJvcHMgfSBmcm9tICcuL1ZpZXcnXG5pbXBvcnQgeyBUb29sYmFyIH0gZnJvbSAnLi9Ub29sYmFyJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIERhdGVQcm9maWxlIH0gZnJvbSAnLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IHJhbmdlQ29udGFpbnNNYXJrZXIgfSBmcm9tICcuL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9yZWR1Y2Vycy9kYXRhLXR5cGVzJ1xuaW1wb3J0IHsgVmlld1Byb3BzVHJhbnNmb3JtZXJDbGFzcyB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIFZVSUV2ZW50LCBGcmFnbWVudCwgVk5vZGUgfSBmcm9tICcuL3Zkb20nXG5pbXBvcnQgeyBidWlsZERlbGVnYXRpb25IYW5kbGVyIH0gZnJvbSAnLi91dGlsL2RvbS1ldmVudCdcbmltcG9ydCB7IFZpZXdDb250YWluZXIgfSBmcm9tICcuL1ZpZXdDb250YWluZXInXG5pbXBvcnQge1xuICBJbnRlcmFjdGlvbixcbiAgSW50ZXJhY3Rpb25TZXR0aW5nc0lucHV0LFxuICBJbnRlcmFjdGlvbkNsYXNzLFxuICBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MsXG4gIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSxcbn0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24nXG5pbXBvcnQgeyBEYXRlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IEV2ZW50Q2xpY2tpbmcgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9FdmVudENsaWNraW5nJ1xuaW1wb3J0IHsgRXZlbnRIb3ZlcmluZyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL0V2ZW50SG92ZXJpbmcnXG5pbXBvcnQgeyBnZXROb3cgfSBmcm9tICcuL3JlZHVjZXJzL2N1cnJlbnQtZGF0ZSdcbmltcG9ydCB7IENhbGVuZGFySW50ZXJhY3Rpb24gfSBmcm9tICcuL2NhbGVuZGFyLXV0aWxzJ1xuaW1wb3J0IHsgRGVsYXllZFJ1bm5lciB9IGZyb20gJy4vdXRpbC9EZWxheWVkUnVubmVyJ1xuaW1wb3J0IHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJy4vdmRvbS11dGlsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIENhbGVuZGFyQ29udGVudFByb3BzIGV4dGVuZHMgQ2FsZW5kYXJEYXRhIHtcbiAgZm9yUHJpbnQ6IGJvb2xlYW5cbiAgaXNIZWlnaHRBdXRvOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhckNvbnRlbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50PENhbGVuZGFyQ29udGVudFByb3BzPiB7XG4gIHByaXZhdGUgYnVpbGRWaWV3Q29udGV4dCA9IG1lbW9pemUoYnVpbGRWaWV3Q29udGV4dClcbiAgcHJpdmF0ZSBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKVxuICBwcml2YXRlIGJ1aWxkVG9vbGJhclByb3BzID0gbWVtb2l6ZShidWlsZFRvb2xiYXJQcm9wcylcbiAgcHJpdmF0ZSBoYW5kbGVOYXZMaW5rQ2xpY2sgPSBidWlsZERlbGVnYXRpb25IYW5kbGVyKCdhW2RhdGEtbmF2bGlua10nLCB0aGlzLl9oYW5kbGVOYXZMaW5rQ2xpY2suYmluZCh0aGlzKSlcbiAgcHJpdmF0ZSBoZWFkZXJSZWYgPSBjcmVhdGVSZWY8VG9vbGJhcj4oKVxuICBwcml2YXRlIGZvb3RlclJlZiA9IGNyZWF0ZVJlZjxUb29sYmFyPigpXG4gIHByaXZhdGUgaW50ZXJhY3Rpb25zU3RvcmU6IHsgW2NvbXBvbmVudFVpZDogc3RyaW5nXTogSW50ZXJhY3Rpb25bXSB9ID0ge31cbiAgcHJpdmF0ZSBjYWxlbmRhckludGVyYWN0aW9uczogQ2FsZW5kYXJJbnRlcmFjdGlvbltdXG5cbiAgLypcbiAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XG4gICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IHRvb2xiYXJDb25maWcsIG9wdGlvbnMgfSA9IHByb3BzXG5cbiAgICBsZXQgdG9vbGJhclByb3BzID0gdGhpcy5idWlsZFRvb2xiYXJQcm9wcyhcbiAgICAgIHByb3BzLnZpZXdTcGVjLFxuICAgICAgcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgIHByb3BzLmN1cnJlbnREYXRlLFxuICAgICAgZ2V0Tm93KHByb3BzLm9wdGlvbnMubm93LCBwcm9wcy5kYXRlRW52KSwgLy8gVE9ETzogdXNlIE5vd1RpbWVyPz8/P1xuICAgICAgcHJvcHMudmlld1RpdGxlLFxuICAgIClcblxuICAgIGxldCB2aWV3Vkdyb3cgPSBmYWxzZVxuICAgIGxldCB2aWV3SGVpZ2h0OiBzdHJpbmcgfCBudW1iZXIgPSAnJ1xuICAgIGxldCB2aWV3QXNwZWN0UmF0aW86IG51bWJlciB8IHVuZGVmaW5lZFxuXG4gICAgaWYgKHByb3BzLmlzSGVpZ2h0QXV0byB8fCBwcm9wcy5mb3JQcmludCkge1xuICAgICAgdmlld0hlaWdodCA9ICcnXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICB2aWV3Vkdyb3cgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodFxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3QXNwZWN0UmF0aW8gPSBNYXRoLm1heChvcHRpb25zLmFzcGVjdFJhdGlvLCAwLjUpIC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXG4gICAgfVxuXG4gICAgbGV0IHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KFxuICAgICAgcHJvcHMudmlld1NwZWMsXG4gICAgICBwcm9wcy52aWV3QXBpLFxuICAgICAgcHJvcHMub3B0aW9ucyxcbiAgICAgIHByb3BzLmRhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgICAgcHJvcHMuZGF0ZUVudixcbiAgICAgIHByb3BzLnRoZW1lLFxuICAgICAgcHJvcHMucGx1Z2luSG9va3MsXG4gICAgICBwcm9wcy5kaXNwYXRjaCxcbiAgICAgIHByb3BzLmdldEN1cnJlbnREYXRhLFxuICAgICAgcHJvcHMuZW1pdHRlcixcbiAgICAgIHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgICAgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsXG4gICAgKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxWaWV3Q29udGV4dFR5cGUuUHJvdmlkZXIgdmFsdWU9e3ZpZXdDb250ZXh0fT5cbiAgICAgICAge3Rvb2xiYXJDb25maWcuaGVhZGVyVG9vbGJhciAmJiAoXG4gICAgICAgICAgPFRvb2xiYXJcbiAgICAgICAgICAgIHJlZj17dGhpcy5oZWFkZXJSZWZ9XG4gICAgICAgICAgICBleHRyYUNsYXNzTmFtZT1cImZjLWhlYWRlci10b29sYmFyXCJcbiAgICAgICAgICAgIG1vZGVsPXt0b29sYmFyQ29uZmlnLmhlYWRlclRvb2xiYXJ9XG4gICAgICAgICAgICB7Li4udG9vbGJhclByb3BzfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICAgIDxWaWV3Q29udGFpbmVyXG4gICAgICAgICAgbGlxdWlkPXt2aWV3Vkdyb3d9XG4gICAgICAgICAgaGVpZ2h0PXt2aWV3SGVpZ2h0fVxuICAgICAgICAgIGFzcGVjdFJhdGlvPXt2aWV3QXNwZWN0UmF0aW99XG4gICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVOYXZMaW5rQ2xpY2t9XG4gICAgICAgID5cbiAgICAgICAgICB7dGhpcy5yZW5kZXJWaWV3KHByb3BzKX1cbiAgICAgICAgICB7dGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKX1cbiAgICAgICAgPC9WaWV3Q29udGFpbmVyPlxuICAgICAgICB7dG9vbGJhckNvbmZpZy5mb290ZXJUb29sYmFyICYmIChcbiAgICAgICAgICA8VG9vbGJhclxuICAgICAgICAgICAgcmVmPXt0aGlzLmZvb3RlclJlZn1cbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lPVwiZmMtZm9vdGVyLXRvb2xiYXJcIlxuICAgICAgICAgICAgbW9kZWw9e3Rvb2xiYXJDb25maWcuZm9vdGVyVG9vbGJhcn1cbiAgICAgICAgICAgIHsuLi50b29sYmFyUHJvcHN9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgIDwvVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyPlxuICAgIClcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgIC5tYXAoKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcykpXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpXG5cbiAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzXG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcHJvcFNldEhhbmRsZXJzKSB7XG4gICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpXG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogQ2FsZW5kYXJDb250ZW50UHJvcHMpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgbGV0IHsgcHJvcFNldEhhbmRsZXJzIH0gPSBwcm9wcy5wbHVnaW5Ib29rc1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAhPT0gcHJldlByb3BzW3Byb3BOYW1lXSkge1xuICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuaGFuZGxlV2luZG93UmVzaXplKVxuICAgIHRoaXMucmVzaXplUnVubmVyLmNsZWFyKClcblxuICAgIGZvciAobGV0IGludGVyYWN0aW9uIG9mIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMpIHtcbiAgICAgIGludGVyYWN0aW9uLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfdW5tb3VudCcpXG4gIH1cblxuICBfaGFuZGxlTmF2TGlua0NsaWNrKGV2OiBWVUlFdmVudCwgYW5jaG9yRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IHRoaXMucHJvcHNcblxuICAgIGxldCBuYXZMaW5rT3B0aW9uczogYW55ID0gYW5jaG9yRWwuZ2V0QXR0cmlidXRlKCdkYXRhLW5hdmxpbmsnKVxuICAgIG5hdkxpbmtPcHRpb25zID0gbmF2TGlua09wdGlvbnMgPyBKU09OLnBhcnNlKG5hdkxpbmtPcHRpb25zKSA6IHt9XG5cbiAgICBsZXQgZGF0ZU1hcmtlciA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKG5hdkxpbmtPcHRpb25zLmRhdGUpXG4gICAgbGV0IHZpZXdUeXBlID0gbmF2TGlua09wdGlvbnMudHlwZVxuXG4gICAgbGV0IGN1c3RvbUFjdGlvbiA9XG4gICAgICB2aWV3VHlwZSA9PT0gJ2RheScgPyBvcHRpb25zLm5hdkxpbmtEYXlDbGljayA6XG4gICAgICAgIHZpZXdUeXBlID09PSAnd2VlaycgPyBvcHRpb25zLm5hdkxpbmtXZWVrQ2xpY2sgOiBudWxsXG5cbiAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VzdG9tQWN0aW9uLmNhbGwoY2FsZW5kYXJBcGksIGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpLCBldilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGNhbGVuZGFyQXBpLnpvb21UbyhkYXRlTWFya2VyLCB2aWV3VHlwZSlcbiAgICB9XG4gIH1cblxuICBidWlsZEFwcGVuZENvbnRlbnQoKTogVk5vZGUge1xuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG5cbiAgICBsZXQgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoXG4gICAgICAoYnVpbGRBcHBlbmRDb250ZW50KSA9PiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpLFxuICAgIClcblxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgLi4uY2hpbGRyZW4pXG4gIH1cblxuICByZW5kZXJWaWV3KHByb3BzOiBDYWxlbmRhckNvbnRlbnRQcm9wcykge1xuICAgIGxldCB7IHBsdWdpbkhvb2tzIH0gPSBwcm9wc1xuICAgIGxldCB7IHZpZXdTcGVjIH0gPSBwcm9wc1xuXG4gICAgbGV0IHZpZXdQcm9wczogVmlld1Byb3BzID0ge1xuICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgIGV2ZW50U3RvcmU6IHByb3BzLnJlbmRlcmFibGVFdmVudFN0b3JlLCAvLyAhXG4gICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXG4gICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcbiAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxuICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxuICAgIH1cblxuICAgIGxldCB0cmFuc2Zvcm1lcnMgPSB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMocGx1Z2luSG9va3Mudmlld1Byb3BzVHJhbnNmb3JtZXJzKVxuXG4gICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgICBfX2Fzc2lnbihcbiAgICAgICAgdmlld1Byb3BzLFxuICAgICAgICB0cmFuc2Zvcm1lci50cmFuc2Zvcm0odmlld1Byb3BzLCBwcm9wcyksXG4gICAgICApXG4gICAgfVxuXG4gICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnRcblxuICAgIHJldHVybiAoXG4gICAgICA8Vmlld0NvbXBvbmVudCB7Li4udmlld1Byb3BzfSAvPlxuICAgIClcbiAgfVxuXG4gIC8vIENvbXBvbmVudCBSZWdpc3RyYXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gKGNvbXBvbmVudDogRGF0ZUNvbXBvbmVudDxhbnk+LCBzZXR0aW5nc0lucHV0OiBJbnRlcmFjdGlvblNldHRpbmdzSW5wdXQpID0+IHtcbiAgICBsZXQgc2V0dGluZ3MgPSBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KVxuICAgIGxldCBERUZBVUxUX0lOVEVSQUNUSU9OUzogSW50ZXJhY3Rpb25DbGFzc1tdID0gW1xuICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgIEV2ZW50SG92ZXJpbmcsXG4gICAgXVxuICAgIGxldCBpbnRlcmFjdGlvbkNsYXNzZXM6IEludGVyYWN0aW9uQ2xhc3NbXSA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdChcbiAgICAgIHRoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zLFxuICAgIClcbiAgICBsZXQgaW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25DbGFzc2VzLm1hcCgoVGhlSW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IFRoZUludGVyYWN0aW9uQ2xhc3Moc2V0dGluZ3MpKVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXSA9IGludGVyYWN0aW9uc1xuICAgIGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZVtjb21wb25lbnQudWlkXSA9IHNldHRpbmdzXG4gIH1cblxuICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSAoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4pID0+IHtcbiAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdKSB7XG4gICAgICBsaXN0ZW5lci5kZXN0cm95KClcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXVxuICAgIGRlbGV0ZSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF1cbiAgfVxuXG4gIC8vIFJlc2l6aW5nXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcmVzaXplUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIoKCkgPT4ge1xuICAgIHRoaXMucHJvcHMuZW1pdHRlci50cmlnZ2VyKCdfcmVzaXplJywgdHJ1ZSkgLy8gc2hvdWxkIHdpbmRvdyByZXNpemVzIGJlIGNvbnNpZGVyZWQgXCJmb3JjZWRcIiA/XG4gICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogdGhpcy5wcm9wcy52aWV3QXBpIH0pXG4gIH0pXG5cbiAgaGFuZGxlV2luZG93UmVzaXplID0gKGV2OiBVSUV2ZW50KSA9PiB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcy5wcm9wc1xuXG4gICAgaWYgKFxuICAgICAgb3B0aW9ucy5oYW5kbGVXaW5kb3dSZXNpemUgJiZcbiAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93IC8vIGF2b2lkIGpxdWkgZXZlbnRzXG4gICAgKSB7XG4gICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5yZXF1ZXN0KG9wdGlvbnMud2luZG93UmVzaXplRGVsYXkpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkVG9vbGJhclByb3BzKFxuICB2aWV3U3BlYzogVmlld1NwZWMsXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBjdXJyZW50RGF0ZTogRGF0ZU1hcmtlcixcbiAgbm93OiBEYXRlTWFya2VyLFxuICB0aXRsZTogc3RyaW5nLFxuKSB7XG4gIC8vIGRvbid0IGZvcmNlIGFueSBkYXRlLXByb2ZpbGVzIHRvIHZhbGlkIGRhdGUgcHJvZmlsZXMgKHRoZSBgZmFsc2VgKSBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIGl0J3MgaW52YWxpZFxuICBsZXQgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKSAvLyBUT0RPOiBuZWVkIGB1bmRlZmluZWRgIG9yIGVsc2UgSU5GSU5JVEUgTE9PUCBmb3Igc29tZSByZWFzb25cbiAgbGV0IHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpXG4gIGxldCBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKVxuXG4gIHJldHVybiB7XG4gICAgdGl0bGUsXG4gICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgIGlzVG9kYXlFbmFibGVkOiB0b2RheUluZm8uaXNWYWxpZCAmJiAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIG5vdyksXG4gICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICB9XG59XG5cbi8vIFBsdWdpblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzOiBWaWV3UHJvcHNUcmFuc2Zvcm1lckNsYXNzW10pIHtcbiAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKChUaGVDbGFzcykgPT4gbmV3IFRoZUNsYXNzKCkpXG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiB9IGZyb20gJy4vdmRvbSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuL3Zkb20tdXRpbCdcbmltcG9ydCB7IENzc0RpbVZhbHVlIH0gZnJvbSAnLi9zY3JvbGxncmlkL3V0aWwnXG5pbXBvcnQgeyBDYWxlbmRhck9wdGlvbnMsIENhbGVuZGFyTGlzdGVuZXJzIH0gZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0IHsgVGhlbWUgfSBmcm9tICcuL3RoZW1lL1RoZW1lJ1xuaW1wb3J0IHsgZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsIH0gZnJvbSAnLi91dGlsL3RhYmxlLXN0eWxpbmcnXG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi9jb21tb24vRW1pdHRlcidcblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhclJvb3RQcm9wcyB7XG4gIG9wdGlvbnM6IENhbGVuZGFyT3B0aW9uc1xuICB0aGVtZTogVGhlbWVcbiAgZW1pdHRlcjogRW1pdHRlcjxDYWxlbmRhckxpc3RlbmVycz5cbiAgY2hpbGRyZW46IChjbGFzc05hbWVzOiBzdHJpbmdbXSwgaGVpZ2h0OiBDc3NEaW1WYWx1ZSwgaXNIZWlnaHRBdXRvOiBib29sZWFuLCBmb3JQcmludDogYm9vbGVhbikgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuaW50ZXJmYWNlIENhbGVuZGFyUm9vdFN0YXRlIHtcbiAgZm9yUHJpbnQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyUm9vdCBleHRlbmRzIEJhc2VDb21wb25lbnQ8Q2FsZW5kYXJSb290UHJvcHMsIENhbGVuZGFyUm9vdFN0YXRlPiB7XG4gIHN0YXRlID0ge1xuICAgIGZvclByaW50OiBmYWxzZSxcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IHByb3BzXG4gICAgbGV0IHsgZm9yUHJpbnQgfSA9IHRoaXMuc3RhdGVcblxuICAgIGxldCBpc0hlaWdodEF1dG8gPSBmb3JQcmludCB8fCBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nXG4gICAgbGV0IGhlaWdodCA9ICghaXNIZWlnaHRBdXRvICYmIG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpID8gb3B0aW9ucy5oZWlnaHQgOiAnJ1xuXG4gICAgbGV0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gW1xuICAgICAgJ2ZjJyxcbiAgICAgIGZvclByaW50ID8gJ2ZjLW1lZGlhLXByaW50JyA6ICdmYy1tZWRpYS1zY3JlZW4nLFxuICAgICAgYGZjLWRpcmVjdGlvbi0ke29wdGlvbnMuZGlyZWN0aW9ufWAsXG4gICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgIF1cblxuICAgIGlmICghZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkpIHtcbiAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtbGlxdWlkLWhhY2snKVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbihjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzXG4gICAgZW1pdHRlci5vbignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludClcbiAgICBlbWl0dGVyLm9uKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMucHJvcHNcbiAgICBlbWl0dGVyLm9mZignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludClcbiAgICBlbWl0dGVyLm9mZignX2FmdGVycHJpbnQnLCB0aGlzLmhhbmRsZUFmdGVyUHJpbnQpXG4gIH1cblxuICBoYW5kbGVCZWZvcmVQcmludCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IHRydWUgfSlcbiAgfVxuXG4gIGhhbmRsZUFmdGVyUHJpbnQgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvclByaW50OiBmYWxzZSB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5cbi8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXM6IGJvb2xlYW4sIGRheUNudDogbnVtYmVyKSB7XG4gIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXG4gIC8vIHB1dCBqdXN0IHRoZSBkYXkgbnVtYmVycyB3aWxsIGJlIGluIGVhY2ggY2VsbFxuICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdzaG9ydCcgfSkgLy8gXCJTYXRcIlxuICB9XG5cbiAgaWYgKGRheUNudCA+IDEpIHtcbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ3Nob3J0JywgbW9udGg6ICdudW1lcmljJywgZGF5OiAnbnVtZXJpYycsIG9taXRDb21tYXM6IHRydWUgfSkgLy8gXCJTYXQgMTEvMTJcIlxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZvcm1hdHRlcih7IHdlZWtkYXk6ICdsb25nJyB9KSAvLyBcIlNhdHVyZGF5XCJcbn1cbiIsImltcG9ydCB7IERheUhlYWRlckNvbnRlbnRBcmcgfSBmcm9tICcuLi9yZW5kZXItaG9vay1taXNjJ1xuXG5leHBvcnQgY29uc3QgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnIC8vIGRvIHRoZSBjdXNoaW9uIHRvbz8gbm9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcklubmVyKGhvb2tQcm9wczogRGF5SGVhZGVyQ29udGVudEFyZykge1xuICByZXR1cm4gaG9va1Byb3BzLnRleHRcbn1cbiIsImltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IGdldERheUNsYXNzTmFtZXMsIGdldERhdGVNZXRhIH0gZnJvbSAnLi4vY29tcG9uZW50L2RhdGUtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9EYXRlRm9ybWF0dGVyJ1xuaW1wb3J0IHsgZm9ybWF0RGF5U3RyaW5nIH0gZnJvbSAnLi4vZGF0ZWxpYi9mb3JtYXR0aW5nLXV0aWxzJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IFJlbmRlckhvb2sgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgYnVpbGROYXZMaW5rRGF0YSB9IGZyb20gJy4vbmF2LWxpbmsnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgRGF5SGVhZGVyQ29udGVudEFyZyB9IGZyb20gJy4uL3JlbmRlci1ob29rLW1pc2MnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IENMQVNTX05BTUUsIHJlbmRlcklubmVyIH0gZnJvbSAnLi90YWJsZS1jZWxsLXV0aWwnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVEYXRlQ2VsbFByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIGNvbENudDogbnVtYmVyXG4gIGRheUhlYWRlckZvcm1hdDogRGF0ZUZvcm1hdHRlclxuICBjb2xTcGFuPzogbnVtYmVyXG4gIGlzU3RpY2t5PzogYm9vbGVhbiAvLyBUT0RPOiBnZXQgdGhpcyBvdXR0YSBoZXJlIHNvbWVob3dcbiAgZXh0cmFEYXRhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhSG9va1Byb3BzPzogRGljdGlvbmFyeVxufVxuXG5leHBvcnQgY2xhc3MgVGFibGVEYXRlQ2VsbCBleHRlbmRzIEJhc2VDb21wb25lbnQ8VGFibGVEYXRlQ2VsbFByb3BzPiB7IC8vIEJBRCBuYW1lIGZvciB0aGlzIGNsYXNzIG5vdy4gdXNlZCBpbiB0aGUgSGVhZGVyXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB0aGVtZSwgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlLCBkYXRlUHJvZmlsZSB9ID0gcHJvcHNcbiAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKVxuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KFxuICAgICAgZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSksXG4gICAgKVxuICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KVxuXG4gICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgbGV0IG5hdkxpbmtBdHRycyA9IChvcHRpb25zLm5hdkxpbmtzICYmICFkYXlNZXRhLmlzRGlzYWJsZWQgJiYgcHJvcHMuY29sQ250ID4gMSlcbiAgICAgID8geyAnZGF0YS1uYXZsaW5rJzogYnVpbGROYXZMaW5rRGF0YShkYXRlKSwgdGFiSW5kZXg6IDAgfVxuICAgICAgOiB7fVxuXG4gICAgbGV0IGhvb2tQcm9wczogRGF5SGVhZGVyQ29udGVudEFyZyA9IHtcbiAgICAgIGRhdGU6IGRhdGVFbnYudG9EYXRlKGRhdGUpLFxuICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgIC4uLnByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgdGV4dCxcbiAgICAgIC4uLmRheU1ldGEsXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZW5kZXJIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXN9XG4gICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuZGF5SGVhZGVyQ29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyfVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudH1cbiAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnR9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICA8dGhcbiAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyl9XG4gICAgICAgICAgICBkYXRhLWRhdGU9eyFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWR9XG4gICAgICAgICAgICBjb2xTcGFuPXtwcm9wcy5jb2xTcGFufVxuICAgICAgICAgICAgey4uLnByb3BzLmV4dHJhRGF0YUF0dHJzfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCI+XG4gICAgICAgICAgICAgIHshZGF5TWV0YS5pc0Rpc2FibGVkICYmIChcbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgcmVmPXtpbm5lckVsUmVmfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ID8gJ2ZjLXN0aWNreScgOiAnJyxcbiAgICAgICAgICAgICAgICAgIF0uam9pbignICcpfVxuICAgICAgICAgICAgICAgICAgey4uLm5hdkxpbmtBdHRyc31cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvdGg+XG4gICAgICAgICl9XG4gICAgICA8L1JlbmRlckhvb2s+XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBnZXREYXlDbGFzc05hbWVzLCBEYXRlTWV0YSB9IGZyb20gJy4uL2NvbXBvbmVudC9kYXRlLXJlbmRlcmluZydcbmltcG9ydCB7IGFkZERheXMgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBSZW5kZXJIb29rIH0gZnJvbSAnLi9yZW5kZXItaG9vaydcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgQ0xBU1NfTkFNRSwgcmVuZGVySW5uZXIgfSBmcm9tICcuL3RhYmxlLWNlbGwtdXRpbCdcbmltcG9ydCB7IERheUhlYWRlckNvbnRlbnRBcmcgfSBmcm9tICcuLi9yZW5kZXItaG9vay1taXNjJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlRG93Q2VsbFByb3BzIHtcbiAgZG93OiBudW1iZXJcbiAgZGF5SGVhZGVyRm9ybWF0OiBEYXRlRm9ybWF0dGVyXG4gIGNvbFNwYW4/OiBudW1iZXJcbiAgaXNTdGlja3k/OiBib29sZWFuIC8vIFRPRE86IGdldCB0aGlzIG91dHRhIGhlcmUgc29tZWhvd1xuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgZXh0cmFEYXRhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhQ2xhc3NOYW1lcz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZURvd0NlbGwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFRhYmxlRG93Q2VsbFByb3BzPiB7XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IGRhdGVFbnYsIHRoZW1lLCB2aWV3QXBpLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgZGF0ZSA9IGFkZERheXMobmV3IERhdGUoMjU5MjAwMDAwKSwgcHJvcHMuZG93KSAvLyBzdGFydCB3aXRoIFN1biwgMDQgSmFuIDE5NzAgMDA6MDA6MDAgR01UXG4gICAgbGV0IGRhdGVNZXRhOiBEYXRlTWV0YSA9IHtcbiAgICAgIGRvdzogcHJvcHMuZG93LFxuICAgICAgaXNEaXNhYmxlZDogZmFsc2UsXG4gICAgICBpc0Z1dHVyZTogZmFsc2UsXG4gICAgICBpc1Bhc3Q6IGZhbHNlLFxuICAgICAgaXNUb2RheTogZmFsc2UsXG4gICAgICBpc090aGVyOiBmYWxzZSxcbiAgICB9XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KFxuICAgICAgZ2V0RGF5Q2xhc3NOYW1lcyhkYXRlTWV0YSwgdGhlbWUpLFxuICAgICAgcHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdLFxuICAgIClcbiAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdClcbiAgICBsZXQgaG9va1Byb3BzOiBEYXlIZWFkZXJDb250ZW50QXJnID0geyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgZGF0ZSxcbiAgICAgIC4uLmRhdGVNZXRhLFxuICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgIC4uLnByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgdGV4dCxcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFJlbmRlckhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lc31cbiAgICAgICAgY29udGVudD17b3B0aW9ucy5kYXlIZWFkZXJDb250ZW50fVxuICAgICAgICBkZWZhdWx0Q29udGVudD17cmVuZGVySW5uZXJ9XG4gICAgICAgIGRpZE1vdW50PXtvcHRpb25zLmRheUhlYWRlckRpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudH1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgIDx0aFxuICAgICAgICAgICAgcmVmPXtyb290RWxSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIGNvbFNwYW49e3Byb3BzLmNvbFNwYW59XG4gICAgICAgICAgICB7Li4ucHJvcHMuZXh0cmFEYXRhQXR0cnN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIj5cbiAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSA/ICdmYy1zdGlja3knIDogJycsXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJyl9XG4gICAgICAgICAgICAgICAgcmVmPXtpbm5lckVsUmVmfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC90aD5cbiAgICAgICAgKX1cbiAgICAgIDwvUmVuZGVySG9vaz5cbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVNYXJrZXIsIGFkZE1zLCBzdGFydE9mRGF5LCBhZGREYXlzIH0gZnJvbSAnLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNyZWF0ZUR1cmF0aW9uIH0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgVmlld0NvbnRleHQsIFZpZXdDb250ZXh0VHlwZSB9IGZyb20gJy4vVmlld0NvbnRleHQnXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgQ29tcG9uZW50IH0gZnJvbSAnLi92ZG9tJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBnZXROb3cgfSBmcm9tICcuL3JlZHVjZXJzL2N1cnJlbnQtZGF0ZSdcblxuZXhwb3J0IGludGVyZmFjZSBOb3dUaW1lclByb3BzIHtcbiAgdW5pdDogc3RyaW5nIC8vIFRPRE86IGFkZCB0eXBlIG9mIHVuaXRcbiAgY2hpbGRyZW46IChub3c6IERhdGVNYXJrZXIsIHRvZGF5UmFuZ2U6IERhdGVSYW5nZSkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuaW50ZXJmYWNlIE5vd1RpbWVyU3RhdGUge1xuICBub3dEYXRlOiBEYXRlTWFya2VyXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxufVxuXG5leHBvcnQgY2xhc3MgTm93VGltZXIgZXh0ZW5kcyBDb21wb25lbnQ8Tm93VGltZXJQcm9wcywgTm93VGltZXJTdGF0ZT4ge1xuICBzdGF0aWMgY29udGV4dFR5cGU6IGFueSA9IFZpZXdDb250ZXh0VHlwZVxuICBjb250ZXh0OiBWaWV3Q29udGV4dCAvLyBkbyB0aGlzIGZvciBhbGwgY29tcG9uZW50cyB0aGF0IHVzZSB0aGUgY29udGV4dCEhIVxuICBpbml0aWFsTm93RGF0ZTogRGF0ZU1hcmtlclxuICBpbml0aWFsTm93UXVlcmllZE1zOiBudW1iZXJcbiAgdGltZW91dElkOiBhbnlcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogTm93VGltZXJQcm9wcywgY29udGV4dDogVmlld0NvbnRleHQpIHtcbiAgICBzdXBlcihwcm9wcywgY29udGV4dClcblxuICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KVxuICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpXG5cbiAgICB0aGlzLnN0YXRlID0gdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzXG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHN0YXRlLm5vd0RhdGUsIHN0YXRlLnRvZGF5UmFuZ2UpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNldFRpbWVvdXQoKVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogTm93VGltZXJQcm9wcykge1xuICAgIGlmIChwcmV2UHJvcHMudW5pdCAhPT0gdGhpcy5wcm9wcy51bml0KSB7XG4gICAgICB0aGlzLmNsZWFyVGltZW91dCgpXG4gICAgICB0aGlzLnNldFRpbWVvdXQoKVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KClcbiAgfVxuXG4gIHByaXZhdGUgY29tcHV0ZVRpbWluZygpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcylcbiAgICBsZXQgY3VycmVudFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5zdGFydE9mKHVucm91bmRlZE5vdywgcHJvcHMudW5pdClcbiAgICBsZXQgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpXG4gICAgbGV0IHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKVxuXG4gICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XG4gICAgd2FpdE1zID0gTWF0aC5taW4oMTAwMCAqIDYwICogNjAgKiAyNCwgd2FpdE1zKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnRTdGF0ZTogeyBub3dEYXRlOiBjdXJyZW50VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKGN1cnJlbnRVbml0U3RhcnQpIH0gYXMgTm93VGltZXJTdGF0ZSxcbiAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0gYXMgTm93VGltZXJTdGF0ZSxcbiAgICAgIHdhaXRNcyxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldFRpbWVvdXQoKSB7XG4gICAgbGV0IHsgbmV4dFN0YXRlLCB3YWl0TXMgfSA9IHRoaXMuY29tcHV0ZVRpbWluZygpXG5cbiAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KClcbiAgICAgIH0pXG4gICAgfSwgd2FpdE1zKVxuICB9XG5cbiAgcHJpdmF0ZSBjbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZTogRGF0ZU1hcmtlcik6IERhdGVSYW5nZSB7IC8vIFRPRE86IG1ha2UgdGhpcyBhIGdlbmVyYWwgdXRpbFxuICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KGRhdGUpXG4gIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKVxuXG4gIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxufVxuIiwiaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCB9IGZyb20gJy4vdGFibGUtdXRpbHMnXG5pbXBvcnQgeyBWTm9kZSwgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBUYWJsZURhdGVDZWxsIH0gZnJvbSAnLi9UYWJsZURhdGVDZWxsJ1xuaW1wb3J0IHsgVGFibGVEb3dDZWxsIH0gZnJvbSAnLi9UYWJsZURvd0NlbGwnXG5pbXBvcnQgeyBOb3dUaW1lciB9IGZyb20gJy4uL05vd1RpbWVyJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBEYXRlRm9ybWF0dGVyIH0gZnJvbSAnLi4vZGF0ZWxpYi9EYXRlRm9ybWF0dGVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERheUhlYWRlclByb3BzIHtcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIGRhdGVzOiBEYXRlTWFya2VyW11cbiAgZGF0ZXNSZXBEaXN0aW5jdERheXM6IGJvb2xlYW5cbiAgcmVuZGVySW50cm8/OiAocm93S2V5OiBzdHJpbmcpID0+IFZOb2RlXG59XG5cbmV4cG9ydCBjbGFzcyBEYXlIZWFkZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PERheUhlYWRlclByb3BzPiB7IC8vIFRPRE86IHJlbmFtZSB0byBEYXlIZWFkZXJUcj9cbiAgY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyID0gbWVtb2l6ZShjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIpXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlcywgZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzLCByZW5kZXJJbnRybyB9ID0gdGhpcy5wcm9wc1xuXG4gICAgbGV0IGRheUhlYWRlckZvcm1hdCA9IHRoaXMuY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKFxuICAgICAgY29udGV4dC5vcHRpb25zLmRheUhlYWRlckZvcm1hdCxcbiAgICAgIGRhdGVzUmVwRGlzdGluY3REYXlzLFxuICAgICAgZGF0ZXMubGVuZ3RoLFxuICAgIClcblxuICAgIHJldHVybiAoXG4gICAgICA8Tm93VGltZXIgdW5pdD1cImRheVwiPlxuICAgICAgICB7KG5vd0RhdGU6IERhdGVNYXJrZXIsIHRvZGF5UmFuZ2U6IERhdGVSYW5nZSkgPT4gKFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIHtyZW5kZXJJbnRybyAmJiByZW5kZXJJbnRybygnZGF5Jyl9XG4gICAgICAgICAgICB7ZGF0ZXMubWFwKChkYXRlKSA9PiAoXG4gICAgICAgICAgICAgIGRhdGVzUmVwRGlzdGluY3REYXlzID8gKFxuICAgICAgICAgICAgICAgIDxUYWJsZURhdGVDZWxsXG4gICAgICAgICAgICAgICAgICBrZXk9e2RhdGUudG9JU09TdHJpbmcoKX1cbiAgICAgICAgICAgICAgICAgIGRhdGU9e2RhdGV9XG4gICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9XG4gICAgICAgICAgICAgICAgICB0b2RheVJhbmdlPXt0b2RheVJhbmdlfVxuICAgICAgICAgICAgICAgICAgY29sQ250PXtkYXRlcy5sZW5ndGh9XG4gICAgICAgICAgICAgICAgICBkYXlIZWFkZXJGb3JtYXQ9e2RheUhlYWRlckZvcm1hdH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxUYWJsZURvd0NlbGxcbiAgICAgICAgICAgICAgICAgIGtleT17ZGF0ZS5nZXRVVENEYXkoKX1cbiAgICAgICAgICAgICAgICAgIGRvdz17ZGF0ZS5nZXRVVENEYXkoKX1cbiAgICAgICAgICAgICAgICAgIGRheUhlYWRlckZvcm1hdD17ZGF5SGVhZGVyRm9ybWF0fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvdHI+XG4gICAgICAgICl9XG4gICAgICA8L05vd1RpbWVyPlxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIoZXhwbGljaXRGb3JtYXQ6IERhdGVGb3JtYXR0ZXIsIGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KSB7XG4gIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpXG59XG4iLCJpbXBvcnQgeyBEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciwgYWRkRGF5cywgZGlmZkRheXMgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcblxuZXhwb3J0IGludGVyZmFjZSBEYXlTZXJpZXNTZWcge1xuICBmaXJzdEluZGV4OiBudW1iZXJcbiAgbGFzdEluZGV4OiBudW1iZXJcbiAgaXNTdGFydDogYm9vbGVhblxuICBpc0VuZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgRGF5U2VyaWVzTW9kZWwge1xuICBjbnQ6IG51bWJlclxuICBkYXRlczogRGF0ZU1hcmtlcltdIC8vIHdob2xlLWRheSBkYXRlcyBmb3IgZWFjaCBjb2x1bW4uIGxlZnQgdG8gcmlnaHRcbiAgaW5kaWNlczogbnVtYmVyW10gLy8gZm9yIGVhY2ggZGF5IGZyb20gc3RhcnQsIHRoZSBvZmZzZXRcblxuICBjb25zdHJ1Y3RvcihyYW5nZTogRGF0ZVJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcjogRGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF0ZTogRGF0ZU1hcmtlciA9IHJhbmdlLnN0YXJ0XG4gICAgbGV0IHsgZW5kIH0gPSByYW5nZVxuICAgIGxldCBpbmRpY2VzOiBudW1iZXJbXSA9IFtdXG4gICAgbGV0IGRhdGVzOiBEYXRlTWFya2VyW10gPSBbXVxuICAgIGxldCBkYXlJbmRleCA9IC0xXG5cbiAgICB3aGlsZSAoZGF0ZSA8IGVuZCkgeyAvLyBsb29wIGVhY2ggZGF5IGZyb20gc3RhcnQgdG8gZW5kXG4gICAgICBpZiAoZGF0ZVByb2ZpbGVHZW5lcmF0b3IuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcbiAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KSAvLyBtYXJrIHRoYXQgaXQncyBiZXR3ZWVuIGluZGljZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRheUluZGV4ICs9IDFcbiAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4KVxuICAgICAgICBkYXRlcy5wdXNoKGRhdGUpXG4gICAgICB9XG4gICAgICBkYXRlID0gYWRkRGF5cyhkYXRlLCAxKVxuICAgIH1cblxuICAgIHRoaXMuZGF0ZXMgPSBkYXRlc1xuICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXNcbiAgICB0aGlzLmNudCA9IGRhdGVzLmxlbmd0aFxuICB9XG5cbiAgc2xpY2VSYW5nZShyYW5nZTogRGF0ZVJhbmdlKTogRGF5U2VyaWVzU2VnIHwgbnVsbCB7XG4gICAgbGV0IGZpcnN0SW5kZXggPSB0aGlzLmdldERhdGVEYXlJbmRleChyYW5nZS5zdGFydCkgLy8gaW5jbHVzaXZlIGZpcnN0IGluZGV4XG4gICAgbGV0IGxhc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KGFkZERheXMocmFuZ2UuZW5kLCAtMSkpIC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XG5cbiAgICBsZXQgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLm1heCgwLCBmaXJzdEluZGV4KVxuICAgIGxldCBjbGlwcGVkTGFzdEluZGV4ID0gTWF0aC5taW4odGhpcy5jbnQgLSAxLCBsYXN0SW5kZXgpXG5cbiAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXG4gICAgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLmNlaWwoY2xpcHBlZEZpcnN0SW5kZXgpIC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxuICAgIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLmZsb29yKGNsaXBwZWRMYXN0SW5kZXgpIC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcblxuICAgIGlmIChjbGlwcGVkRmlyc3RJbmRleCA8PSBjbGlwcGVkTGFzdEluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaXJzdEluZGV4OiBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgbGFzdEluZGV4OiBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICBpc1N0YXJ0OiBmaXJzdEluZGV4ID09PSBjbGlwcGVkRmlyc3RJbmRleCxcbiAgICAgICAgaXNFbmQ6IGxhc3RJbmRleCA9PT0gY2xpcHBlZExhc3RJbmRleCxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIEdpdmVuIGEgZGF0ZSwgcmV0dXJucyBpdHMgY2hyb25vbG9jaWFsIGNlbGwtaW5kZXggZnJvbSB0aGUgZmlyc3QgY2VsbCBvZiB0aGUgZ3JpZC5cbiAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxuICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgLy8gSWYgYWZ0ZXIgdGhlIGxhc3Qgb2Zmc2V0LCByZXR1cm5zIGFuIG9mZnNldCBwYXN0IHRoZSBsYXN0IGNlbGwgb2Zmc2V0LlxuICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cbiAgcHJpdmF0ZSBnZXREYXRlRGF5SW5kZXgoZGF0ZTogRGF0ZU1hcmtlcikge1xuICAgIGxldCB7IGluZGljZXMgfSA9IHRoaXNcbiAgICBsZXQgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSlcblxuICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDFcbiAgICB9XG5cbiAgICBpZiAoZGF5T2Zmc2V0ID49IGluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdICsgMVxuICAgIH1cblxuICAgIHJldHVybiBpbmRpY2VzW2RheU9mZnNldF1cbiAgfVxufVxuIiwiaW1wb3J0IHsgRGF5U2VyaWVzTW9kZWwgfSBmcm9tICcuL0RheVNlcmllc01vZGVsJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IGludGVyZmFjZSBEYXlUYWJsZVNlZyBleHRlbmRzIFNlZyB7XG4gIHJvdzogbnVtYmVyXG4gIGZpcnN0Q29sOiBudW1iZXJcbiAgbGFzdENvbDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5VGFibGVDZWxsIHtcbiAga2V5OiBzdHJpbmcgLy8gcHJvYmFibHkganVzdCB0aGUgc2VyaWFsaXplZCBkYXRlLCBidXQgY291bGQgYmUgb3RoZXIgbWV0YWRhdGEgaWYgdGhpcyBjb2wgaXMgc3BlY2lmaWMgdG8gYW5vdGhlciBlbnRpdHlcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBleHRyYUhvb2tQcm9wcz86IERpY3Rpb25hcnlcbiAgZXh0cmFEYXRhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIGV4dHJhQ2xhc3NOYW1lcz86IHN0cmluZ1tdXG4gIGV4dHJhRGF0ZVNwYW4/OiBEaWN0aW9uYXJ5XG59XG5cbmV4cG9ydCBjbGFzcyBEYXlUYWJsZU1vZGVsIHtcbiAgcm93Q250OiBudW1iZXJcbiAgY29sQ250OiBudW1iZXJcbiAgY2VsbHM6IERheVRhYmxlQ2VsbFtdW11cbiAgaGVhZGVyRGF0ZXM6IERhdGVNYXJrZXJbXVxuXG4gIHByaXZhdGUgZGF5U2VyaWVzOiBEYXlTZXJpZXNNb2RlbFxuXG4gIGNvbnN0cnVjdG9yKGRheVNlcmllczogRGF5U2VyaWVzTW9kZWwsIGJyZWFrT25XZWVrczogYm9vbGVhbikge1xuICAgIGxldCB7IGRhdGVzIH0gPSBkYXlTZXJpZXNcbiAgICBsZXQgZGF5c1BlclJvd1xuICAgIGxldCBmaXJzdERheVxuICAgIGxldCByb3dDbnRcblxuICAgIGlmIChicmVha09uV2Vla3MpIHtcbiAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcbiAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KClcbiAgICAgIGZvciAoZGF5c1BlclJvdyA9IDE7IGRheXNQZXJSb3cgPCBkYXRlcy5sZW5ndGg7IGRheXNQZXJSb3cgKz0gMSkge1xuICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm93Q250ID0gTWF0aC5jZWlsKGRhdGVzLmxlbmd0aCAvIGRheXNQZXJSb3cpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJvd0NudCA9IDFcbiAgICAgIGRheXNQZXJSb3cgPSBkYXRlcy5sZW5ndGhcbiAgICB9XG5cbiAgICB0aGlzLnJvd0NudCA9IHJvd0NudFxuICAgIHRoaXMuY29sQ250ID0gZGF5c1BlclJvd1xuICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzXG4gICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpXG4gICAgdGhpcy5oZWFkZXJEYXRlcyA9IHRoaXMuYnVpbGRIZWFkZXJEYXRlcygpXG4gIH1cblxuICBwcml2YXRlIGJ1aWxkQ2VsbHMoKSB7XG4gICAgbGV0IHJvd3MgPSBbXVxuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XG4gICAgICBsZXQgY2VsbHMgPSBbXVxuXG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgY2VsbHMucHVzaChcbiAgICAgICAgICB0aGlzLmJ1aWxkQ2VsbChyb3csIGNvbCksXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgcm93cy5wdXNoKGNlbGxzKVxuICAgIH1cblxuICAgIHJldHVybiByb3dzXG4gIH1cblxuICBwcml2YXRlIGJ1aWxkQ2VsbChyb3csIGNvbCk6IERheVRhYmxlQ2VsbCB7XG4gICAgbGV0IGRhdGUgPSB0aGlzLmRheVNlcmllcy5kYXRlc1tyb3cgKiB0aGlzLmNvbENudCArIGNvbF1cbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICBkYXRlLFxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRIZWFkZXJEYXRlcygpIHtcbiAgICBsZXQgZGF0ZXMgPSBbXVxuXG4gICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCArPSAxKSB7XG4gICAgICBkYXRlcy5wdXNoKHRoaXMuY2VsbHNbMF1bY29sXS5kYXRlKVxuICAgIH1cblxuICAgIHJldHVybiBkYXRlc1xuICB9XG5cbiAgc2xpY2VSYW5nZShyYW5nZTogRGF0ZVJhbmdlKTogRGF5VGFibGVTZWdbXSB7XG4gICAgbGV0IHsgY29sQ250IH0gPSB0aGlzXG4gICAgbGV0IHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpXG4gICAgbGV0IHNlZ3M6IERheVRhYmxlU2VnW10gPSBbXVxuXG4gICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgbGV0IHsgZmlyc3RJbmRleCwgbGFzdEluZGV4IH0gPSBzZXJpZXNTZWdcbiAgICAgIGxldCBpbmRleCA9IGZpcnN0SW5kZXhcblxuICAgICAgd2hpbGUgKGluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICBsZXQgcm93ID0gTWF0aC5mbG9vcihpbmRleCAvIGNvbENudClcbiAgICAgICAgbGV0IG5leHRJbmRleCA9IE1hdGgubWluKChyb3cgKyAxKSAqIGNvbENudCwgbGFzdEluZGV4ICsgMSlcblxuICAgICAgICBzZWdzLnB1c2goe1xuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBmaXJzdENvbDogaW5kZXggJSBjb2xDbnQsXG4gICAgICAgICAgbGFzdENvbDogKG5leHRJbmRleCAtIDEpICUgY29sQ250LFxuICAgICAgICAgIGlzU3RhcnQ6IHNlcmllc1NlZy5pc1N0YXJ0ICYmIGluZGV4ID09PSBmaXJzdEluZGV4LFxuICAgICAgICAgIGlzRW5kOiBzZXJpZXNTZWcuaXNFbmQgJiYgKG5leHRJbmRleCAtIDEpID09PSBsYXN0SW5kZXgsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaW5kZXggPSBuZXh0SW5kZXhcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2Vnc1xuICB9XG59XG4iLCJpbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBFdmVudFN0b3JlIH0gZnJvbSAnLi4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IEV2ZW50VWlIYXNoIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXVpJ1xuaW1wb3J0IHsgc2xpY2VFdmVudFN0b3JlLCBFdmVudFJlbmRlclJhbmdlIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBTZWcsIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnIC8vIFRPRE86IHJlbmFtZSBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSwgbW92ZSBoZXJlXG5pbXBvcnQgeyBEYXRlU3BhbiwgZmFicmljYXRlRXZlbnRSYW5nZSB9IGZyb20gJy4uL3N0cnVjdHMvZGF0ZS1zcGFuJ1xuaW1wb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuaW1wb3J0IHsgRHVyYXRpb24gfSBmcm9tICcuLi9kYXRlbGliL2R1cmF0aW9uJ1xuaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJy4uL3V0aWwvbWVtb2l6ZSdcbmltcG9ydCB7IERhdGVNYXJrZXIsIGFkZE1zLCBhZGREYXlzIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBDYWxlbmRhckNvbnRleHQgfSBmcm9tICcuLi9DYWxlbmRhckNvbnRleHQnXG5pbXBvcnQgeyBleHBhbmRSZWN1cnJpbmcgfSBmcm9tICcuLi9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudCdcblxuZXhwb3J0IGludGVyZmFjZSBTbGljZWFibGVQcm9wcyB7XG4gIGRhdGVTZWxlY3Rpb246IERhdGVTcGFuXG4gIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmVcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZVxuICBldmVudERyYWc6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2VkUHJvcHM8U2VnVHlwZSBleHRlbmRzIFNlZz4ge1xuICBkYXRlU2VsZWN0aW9uU2VnczogU2VnVHlwZVtdXG4gIGJ1c2luZXNzSG91clNlZ3M6IFNlZ1R5cGVbXVxuICBmZ0V2ZW50U2VnczogU2VnVHlwZVtdXG4gIGJnRXZlbnRTZWdzOiBTZWdUeXBlW11cbiAgZXZlbnREcmFnOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbiAgZXZlbnRSZXNpemU6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTbGljZXI8U2VnVHlwZSBleHRlbmRzIFNlZywgRXh0cmFBcmdzIGV4dGVuZHMgYW55W10gPSBbXT4ge1xuICBwcml2YXRlIHNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKVxuICBwcml2YXRlIHNsaWNlRGF0ZVNlbGVjdGlvbiA9IG1lbW9pemUodGhpcy5fc2xpY2VEYXRlU3BhbilcbiAgcHJpdmF0ZSBzbGljZUV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NsaWNlRXZlbnRTdG9yZSlcbiAgcHJpdmF0ZSBzbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbilcbiAgcHJpdmF0ZSBzbGljZUV2ZW50UmVzaXplID0gbWVtb2l6ZSh0aGlzLl9zbGljZUludGVyYWN0aW9uKVxuXG4gIGFic3RyYWN0IHNsaWNlUmFuZ2UoZGF0ZVJhbmdlOiBEYXRlUmFuZ2UsIC4uLmV4dHJhQXJnczogRXh0cmFBcmdzKTogU2VnVHlwZVtdXG4gIHByb3RlY3RlZCBmb3JjZURheUlmTGlzdEl0ZW0gPSBmYWxzZSAvLyBoYWNrXG5cbiAgc2xpY2VQcm9wcyhcbiAgICBwcm9wczogU2xpY2VhYmxlUHJvcHMsXG4gICAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIHwgbnVsbCxcbiAgICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gICAgLi4uZXh0cmFBcmdzOiBFeHRyYUFyZ3NcbiAgKTogU2xpY2VkUHJvcHM8U2VnVHlwZT4ge1xuICAgIGxldCB7IGV2ZW50VWlCYXNlcyB9ID0gcHJvcHNcbiAgICBsZXQgZXZlbnRTZWdzID0gdGhpcy5zbGljZUV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFVpQmFzZXMsIGNvbnRleHQsIC4uLmV4dHJhQXJncyksXG4gICAgICBidXNpbmVzc0hvdXJTZWdzOiB0aGlzLnNsaWNlQnVzaW5lc3NIb3Vycyhwcm9wcy5idXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgIGZnRXZlbnRTZWdzOiBldmVudFNlZ3MuZmcsXG4gICAgICBiZ0V2ZW50U2VnczogZXZlbnRTZWdzLmJnLFxuICAgICAgZXZlbnREcmFnOiB0aGlzLnNsaWNlRXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyksXG4gICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgfSAvLyBUT0RPOiBnaXZlIGludGVyYWN0aW9uU2Vncz9cbiAgfVxuXG4gIHNsaWNlTm93RGF0ZSggLy8gZG9lcyBub3QgbWVtb2l6ZVxuICAgIGRhdGU6IERhdGVNYXJrZXIsXG4gICAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuICAgIC4uLmV4dHJhQXJnczogRXh0cmFBcmdzXG4gICk6IFNlZ1R5cGVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4oXG4gICAgICB7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSwgLy8gYWRkIDEgbXMsIHByb3RlY3QgYWdhaW5zdCBudWxsIHJhbmdlXG4gICAgICB7fSxcbiAgICAgIGNvbnRleHQsXG4gICAgICAuLi5leHRyYUFyZ3MsXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBfc2xpY2VCdXNpbmVzc0hvdXJzKFxuICAgIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmUsXG4gICAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uIHwgbnVsbCxcbiAgICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4gICAgLi4uZXh0cmFBcmdzOiBFeHRyYUFyZ3NcbiAgKTogU2VnVHlwZVtdIHtcbiAgICBpZiAoIWJ1c2luZXNzSG91cnMpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zbGljZUV2ZW50U3RvcmUoXG4gICAgICBleHBhbmRSZWN1cnJpbmcoXG4gICAgICAgIGJ1c2luZXNzSG91cnMsXG4gICAgICAgIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksXG4gICAgICAgIGNvbnRleHQsXG4gICAgICApLFxuICAgICAge30sXG4gICAgICBkYXRlUHJvZmlsZSxcbiAgICAgIG5leHREYXlUaHJlc2hvbGQsXG4gICAgICAuLi5leHRyYUFyZ3MsXG4gICAgKS5iZ1xuICB9XG5cbiAgcHJpdmF0ZSBfc2xpY2VFdmVudFN0b3JlKFxuICAgIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmUsXG4gICAgZXZlbnRVaUJhc2VzOiBFdmVudFVpSGFzaCxcbiAgICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gICAgbmV4dERheVRocmVzaG9sZDogRHVyYXRpb24gfCBudWxsLFxuICAgIC4uLmV4dHJhQXJnczogRXh0cmFBcmdzXG4gICk6IHsgYmc6IFNlZ1R5cGVbXSwgZmc6IFNlZ1R5cGVbXSB9IHtcbiAgICBpZiAoZXZlbnRTdG9yZSkge1xuICAgICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKFxuICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICBldmVudFVpQmFzZXMsXG4gICAgICAgIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksXG4gICAgICAgIG5leHREYXlUaHJlc2hvbGQsXG4gICAgICApXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuYmcsIGV4dHJhQXJncyksXG4gICAgICAgIGZnOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGJnOiBbXSwgZmc6IFtdIH1cbiAgfVxuXG4gIHByaXZhdGUgX3NsaWNlSW50ZXJhY3Rpb24oXG4gICAgaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSxcbiAgICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoLFxuICAgIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSxcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBEdXJhdGlvbiB8IG51bGwsXG4gICAgLi4uZXh0cmFBcmdzOiBFeHRyYUFyZ3NcbiAgKTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUge1xuICAgIGlmICghaW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgbGV0IHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKFxuICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyxcbiAgICAgIGV2ZW50VWlCYXNlcyxcbiAgICAgIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksXG4gICAgICBuZXh0RGF5VGhyZXNob2xkLFxuICAgIClcblxuICAgIHJldHVybiB7XG4gICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxuICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zbGljZURhdGVTcGFuKFxuICAgIGRhdGVTcGFuOiBEYXRlU3BhbixcbiAgICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoLFxuICAgIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbiAgICAuLi5leHRyYUFyZ3M6IEV4dHJhQXJnc1xuICApOiBTZWdUeXBlW10ge1xuICAgIGlmICghZGF0ZVNwYW4pIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGxldCBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KVxuICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVTcGFuLnJhbmdlLCAuLi5leHRyYUFyZ3MpXG5cbiAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxuXG4gIC8qXG4gIFwiY29tcGxldGVcIiBzZWcgbWVhbnMgaXQgaGFzIGNvbXBvbmVudCBhbmQgZXZlbnRSYW5nZVxuICAqL1xuICBwcml2YXRlIHNsaWNlRXZlbnRSYW5nZXMoXG4gICAgZXZlbnRSYW5nZXM6IEV2ZW50UmVuZGVyUmFuZ2VbXSxcbiAgICBleHRyYUFyZ3M6IEV4dHJhQXJncyxcbiAgKTogU2VnVHlwZVtdIHtcbiAgICBsZXQgc2VnczogU2VnVHlwZVtdID0gW11cblxuICAgIGZvciAobGV0IGV2ZW50UmFuZ2Ugb2YgZXZlbnRSYW5nZXMpIHtcbiAgICAgIHNlZ3MucHVzaCguLi50aGlzLnNsaWNlRXZlbnRSYW5nZShldmVudFJhbmdlLCBleHRyYUFyZ3MpKVxuICAgIH1cblxuICAgIHJldHVybiBzZWdzXG4gIH1cblxuICAvKlxuICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgKi9cbiAgcHJpdmF0ZSBzbGljZUV2ZW50UmFuZ2UoXG4gICAgZXZlbnRSYW5nZTogRXZlbnRSZW5kZXJSYW5nZSxcbiAgICBleHRyYUFyZ3M6IEV4dHJhQXJncyxcbiAgKTogU2VnVHlwZVtdIHtcbiAgICBsZXQgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZVxuXG4gICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICBpZiAodGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gJiYgZXZlbnRSYW5nZS51aS5kaXNwbGF5ID09PSAnbGlzdC1pdGVtJykge1xuICAgICAgZGF0ZVJhbmdlID0ge1xuICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICBlbmQ6IGFkZERheXMoZGF0ZVJhbmdlLnN0YXJ0LCAxKSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2VncyA9IHRoaXMuc2xpY2VSYW5nZShkYXRlUmFuZ2UsIC4uLmV4dHJhQXJncylcblxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICBzZWcuZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2VcbiAgICAgIHNlZy5pc1N0YXJ0ID0gZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZy5pc1N0YXJ0XG4gICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZFxuICAgIH1cblxuICAgIHJldHVybiBzZWdzXG4gIH1cbn1cblxuLypcbmZvciBpbmNvcnBvcmF0aW5nIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIGlmIGFwcHJvcHJpYXRlXG5UT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcblRpbWVsaW5lRGF0ZVByb2ZpbGUgYWxyZWFkeSBkb2VzIHRoaXMgYnR3XG4qL1xuZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgaXNDb21wb25lbnRBbGxEYXk6IGJvb2xlYW4pOiBEYXRlUmFuZ2Uge1xuICBsZXQgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZVxuXG4gIGlmIChpc0NvbXBvbmVudEFsbERheSkge1xuICAgIHJldHVybiByYW5nZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogYWRkTXMocmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLm1pbGxpc2Vjb25kcyksXG4gICAgZW5kOiBhZGRNcyhyYW5nZS5lbmQsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLm1pbGxpc2Vjb25kcyAtIDg2NGU1KSwgLy8gODY0ZTUgPSBtcyBpbiBhIGRheVxuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudFN0b3JlLCBmaWx0ZXJFdmVudFN0b3JlRGVmcyB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmltcG9ydCB7IERhdGVTcGFuIH0gZnJvbSAnLi9zdHJ1Y3RzL2RhdGUtc3BhbidcbmltcG9ydCB7IHJhbmdlQ29udGFpbnNSYW5nZSwgcmFuZ2VzSW50ZXJzZWN0LCBEYXRlUmFuZ2UsIE9wZW5EYXRlUmFuZ2UgfSBmcm9tICcuL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IEV2ZW50QXBpIH0gZnJvbSAnLi9hcGkvRXZlbnRBcGknXG5pbXBvcnQgeyBjb21waWxlRXZlbnRVaXMgfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC1yZW5kZXJpbmcnXG5pbXBvcnQgeyBleGNsdWRlSW5zdGFuY2VzIH0gZnJvbSAnLi9yZWR1Y2Vycy9ldmVudFN0b3JlJ1xuaW1wb3J0IHsgRXZlbnRJbnRlcmFjdGlvblN0YXRlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvZXZlbnQtaW50ZXJhY3Rpb24tc3RhdGUnXG5pbXBvcnQgeyBTcGxpdHRhYmxlUHJvcHMgfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC1zcGxpdHRpbmcnXG5pbXBvcnQgeyBtYXBIYXNoIH0gZnJvbSAnLi91dGlsL29iamVjdCdcbmltcG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4vQ2FsZW5kYXJDb250ZXh0J1xuaW1wb3J0IHsgYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0IH0gZnJvbSAnLi9jYWxlbmRhci11dGlscydcbmltcG9ydCB7IENvbnN0cmFpbnQgfSBmcm9tICcuL3N0cnVjdHMvY29uc3RyYWludCdcbmltcG9ydCB7IGV4cGFuZFJlY3VycmluZyB9IGZyb20gJy4vc3RydWN0cy9yZWN1cnJpbmctZXZlbnQnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5cbi8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25WYWxpZChcbiAgaW50ZXJhY3Rpb246IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSxcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsXG4pIHtcbiAgbGV0IHsgaW5zdGFuY2VzIH0gPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBldmVudERyYWc6IGludGVyYWN0aW9uIH0sIGNvbnRleHQpIC8vIEhBQ0s6IHRoZSBldmVudERyYWcgcHJvcHMgaXMgdXNlZCBmb3IgQUxMIGludGVyYWN0aW9uc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uVmFsaWQoXG4gIGRhdGVTZWxlY3Rpb246IERhdGVTcGFuLFxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGUsXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCxcbikge1xuICBpZiAoIXJhbmdlQ29udGFpbnNSYW5nZShkYXRlUHJvZmlsZS52YWxpZFJhbmdlLCBkYXRlU2VsZWN0aW9uLnJhbmdlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBkYXRlU2VsZWN0aW9uIH0sIGNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0KSB7XG4gIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpXG5cbiAgbGV0IHByb3BzID0ge1xuICAgIGJ1c2luZXNzSG91cnM6IGNhbGVuZGFyU3RhdGUuYnVzaW5lc3NIb3VycyxcbiAgICBkYXRlU2VsZWN0aW9uOiAnJyxcbiAgICBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsXG4gICAgZXZlbnRVaUJhc2VzOiBjYWxlbmRhclN0YXRlLmV2ZW50VWlCYXNlcyxcbiAgICBldmVudFNlbGVjdGlvbjogJycsXG4gICAgZXZlbnREcmFnOiBudWxsLFxuICAgIGV2ZW50UmVzaXplOiBudWxsLFxuICAgIC4uLm5ld1Byb3BzLFxuICB9XG5cbiAgcmV0dXJuIChjb250ZXh0LnBsdWdpbkhvb2tzLmlzUHJvcHNWYWxpZCB8fCBpc1Byb3BzVmFsaWQpKHByb3BzLCBjb250ZXh0KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQcm9wc1ZhbGlkKHN0YXRlOiBTcGxpdHRhYmxlUHJvcHMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgZGF0ZVNwYW5NZXRhID0ge30sIGZpbHRlckNvbmZpZz8pOiBib29sZWFuIHtcbiAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgIWlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gTW92aW5nIEV2ZW50IFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZTogU3BsaXR0YWJsZVByb3BzLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQsIGRhdGVTcGFuTWV0YTogYW55LCBmaWx0ZXJDb25maWcpOiBib29sZWFuIHtcbiAgbGV0IGN1cnJlbnRTdGF0ZSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKVxuICBsZXQgaW50ZXJhY3Rpb24gPSBzdGF0ZS5ldmVudERyYWcgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG5cbiAgbGV0IHN1YmplY3RFdmVudFN0b3JlID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50c1xuICBsZXQgc3ViamVjdERlZnMgPSBzdWJqZWN0RXZlbnRTdG9yZS5kZWZzXG4gIGxldCBzdWJqZWN0SW5zdGFuY2VzID0gc3ViamVjdEV2ZW50U3RvcmUuaW5zdGFuY2VzXG4gIGxldCBzdWJqZWN0Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhcbiAgICBzdWJqZWN0RGVmcyxcbiAgICBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cbiAgICAgIHN0YXRlLmV2ZW50VWlCYXNlcyA6XG4gICAgICB7ICcnOiBjdXJyZW50U3RhdGUuc2VsZWN0aW9uQ29uZmlnIH0sIC8vIGlmIG5vdCBhIHJlYWwgZXZlbnQsIHZhbGlkYXRlIGFzIGEgc2VsZWN0aW9uXG4gIClcblxuICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgc3ViamVjdENvbmZpZ3MgPSBtYXBIYXNoKHN1YmplY3RDb25maWdzLCBmaWx0ZXJDb25maWcpXG4gIH1cblxuICAvLyBleGNsdWRlIHRoZSBzdWJqZWN0IGV2ZW50cy4gVE9ETzogZXhjbHVkZSBkZWZzIHRvbz9cbiAgbGV0IG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKVxuXG4gIGxldCBvdGhlckRlZnMgPSBvdGhlckV2ZW50U3RvcmUuZGVmc1xuICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBvdGhlckV2ZW50U3RvcmUuaW5zdGFuY2VzXG4gIGxldCBvdGhlckNvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMob3RoZXJEZWZzLCBzdGF0ZS5ldmVudFVpQmFzZXMpXG5cbiAgZm9yIChsZXQgc3ViamVjdEluc3RhbmNlSWQgaW4gc3ViamVjdEluc3RhbmNlcykge1xuICAgIGxldCBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXVxuICAgIGxldCBzdWJqZWN0UmFuZ2UgPSBzdWJqZWN0SW5zdGFuY2UucmFuZ2VcbiAgICBsZXQgc3ViamVjdENvbmZpZyA9IHN1YmplY3RDb25maWdzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF1cbiAgICBsZXQgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF1cblxuICAgIC8vIGNvbnN0cmFpbnRcbiAgICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzdWJqZWN0Q29uZmlnLmNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIG92ZXJsYXBcblxuICAgIGxldCB7IGV2ZW50T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zXG4gICAgbGV0IGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbFxuXG4gICAgZm9yIChsZXQgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XG4gICAgICBsZXQgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF1cblxuICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzdWJqZWN0UmFuZ2UsIG90aGVySW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgIGxldCBvdGhlck92ZXJsYXAgPSBvdGhlckNvbmZpZ3Nbb3RoZXJJbnN0YW5jZS5kZWZJZF0ub3ZlcmxhcFxuXG4gICAgICAgIC8vIGNvbnNpZGVyIHRoZSBvdGhlciBldmVudCdzIG92ZXJsYXAuIG9ubHkgZG8gdGhpcyBpZiB0aGUgc3ViamVjdCBldmVudCBpcyBhIFwicmVhbFwiIGV2ZW50XG4gICAgICAgIGlmIChvdGhlck92ZXJsYXAgPT09IGZhbHNlICYmIGludGVyYWN0aW9uLmlzRXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJqZWN0Q29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhcbiAgICAgICAgICBuZXcgRXZlbnRBcGkoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICBuZXcgRXZlbnRBcGkoY29udGV4dCwgc3ViamVjdERlZiwgc3ViamVjdEluc3RhbmNlKSwgLy8gbW92aW5nIGV2ZW50XG4gICAgICAgICkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuXG4gICAgbGV0IGNhbGVuZGFyRXZlbnRTdG9yZSA9IGN1cnJlbnRTdGF0ZS5ldmVudFN0b3JlIC8vIG5lZWQgZ2xvYmFsLXRvLWNhbGVuZGFyLCBub3QgbG9jYWwgdG8gY29tcG9uZW50IChzcGxpdHRhYmxlKXN0YXRlXG5cbiAgICBmb3IgKGxldCBzdWJqZWN0QWxsb3cgb2Ygc3ViamVjdENvbmZpZy5hbGxvd3MpIHtcbiAgICAgIGxldCBzdWJqZWN0RGF0ZVNwYW46IERhdGVTcGFuID0ge1xuICAgICAgICAuLi5kYXRlU3Bhbk1ldGEsXG4gICAgICAgIHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsXG4gICAgICAgIGFsbERheTogc3ViamVjdERlZi5hbGxEYXksXG4gICAgICB9XG5cbiAgICAgIGxldCBvcmlnRGVmID0gY2FsZW5kYXJFdmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF1cbiAgICAgIGxldCBvcmlnSW5zdGFuY2UgPSBjYWxlbmRhckV2ZW50U3RvcmUuaW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXVxuICAgICAgbGV0IGV2ZW50QXBpXG5cbiAgICAgIGlmIChvcmlnRGVmKSB7IC8vIHdhcyBwcmV2aW91c2x5IGluIHRoZSBjYWxlbmRhclxuICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBvcmlnRGVmLCBvcmlnSW5zdGFuY2UpXG4gICAgICB9IGVsc2UgeyAvLyB3YXMgYW4gZXh0ZXJuYWwgZXZlbnRcbiAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgc3ViamVjdERlZikgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXG4gICAgICB9XG5cbiAgICAgIGlmICghc3ViamVjdEFsbG93KFxuICAgICAgICBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSxcbiAgICAgICAgZXZlbnRBcGksXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbi8vIERhdGUgU2VsZWN0aW9uIFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlOiBTcGxpdHRhYmxlUHJvcHMsIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgZGF0ZVNwYW5NZXRhOiBhbnksIGZpbHRlckNvbmZpZyk6IGJvb2xlYW4ge1xuICBsZXQgcmVsZXZhbnRFdmVudFN0b3JlID0gc3RhdGUuZXZlbnRTdG9yZVxuICBsZXQgcmVsZXZhbnREZWZzID0gcmVsZXZhbnRFdmVudFN0b3JlLmRlZnNcbiAgbGV0IHJlbGV2YW50SW5zdGFuY2VzID0gcmVsZXZhbnRFdmVudFN0b3JlLmluc3RhbmNlc1xuXG4gIGxldCBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uXG4gIGxldCBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZVxuICBsZXQgeyBzZWxlY3Rpb25Db25maWcgfSA9IGNvbnRleHQuZ2V0Q3VycmVudERhdGEoKVxuXG4gIGlmIChmaWx0ZXJDb25maWcpIHtcbiAgICBzZWxlY3Rpb25Db25maWcgPSBmaWx0ZXJDb25maWcoc2VsZWN0aW9uQ29uZmlnKVxuICB9XG5cbiAgLy8gY29uc3RyYWludFxuICBpZiAoIWFsbENvbnN0cmFpbnRzUGFzcyhzZWxlY3Rpb25Db25maWcuY29uc3RyYWludHMsIHNlbGVjdGlvblJhbmdlLCByZWxldmFudEV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBvdmVybGFwXG5cbiAgbGV0IHsgc2VsZWN0T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zXG4gIGxldCBzZWxlY3RPdmVybGFwRnVuYyA9IHR5cGVvZiBzZWxlY3RPdmVybGFwID09PSAnZnVuY3Rpb24nID8gc2VsZWN0T3ZlcmxhcCA6IG51bGxcblxuICBmb3IgKGxldCByZWxldmFudEluc3RhbmNlSWQgaW4gcmVsZXZhbnRJbnN0YW5jZXMpIHtcbiAgICBsZXQgcmVsZXZhbnRJbnN0YW5jZSA9IHJlbGV2YW50SW5zdGFuY2VzW3JlbGV2YW50SW5zdGFuY2VJZF1cblxuICAgIC8vIGludGVyc2VjdCEgZXZhbHVhdGVcbiAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHNlbGVjdGlvblJhbmdlLCByZWxldmFudEluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdE92ZXJsYXBGdW5jICYmICFzZWxlY3RPdmVybGFwRnVuYyhcbiAgICAgICAgbmV3IEV2ZW50QXBpKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksXG4gICAgICAgIG51bGwsXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICBmb3IgKGxldCBzZWxlY3Rpb25BbGxvdyBvZiBzZWxlY3Rpb25Db25maWcuYWxsb3dzKSB7XG4gICAgbGV0IGZ1bGxEYXRlU3BhbiA9IHsgLi4uZGF0ZVNwYW5NZXRhLCAuLi5zZWxlY3Rpb24gfVxuXG4gICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhcbiAgICAgIGJ1aWxkRGF0ZVNwYW5BcGlXaXRoQ29udGV4dChmdWxsRGF0ZVNwYW4sIGNvbnRleHQpLFxuICAgICAgbnVsbCxcbiAgICApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBDb25zdHJhaW50IFV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKFxuICBjb25zdHJhaW50czogQ29uc3RyYWludFtdLFxuICBzdWJqZWN0UmFuZ2U6IERhdGVSYW5nZSxcbiAgb3RoZXJFdmVudFN0b3JlOiBFdmVudFN0b3JlLFxuICBidXNpbmVzc0hvdXJzVW5leHBhbmRlZDogRXZlbnRTdG9yZSxcbiAgY29udGV4dDogQ2FsZW5kYXJDb250ZXh0LFxuKTogYm9vbGVhbiB7XG4gIGZvciAobGV0IGNvbnN0cmFpbnQgb2YgY29uc3RyYWludHMpIHtcbiAgICBpZiAoIWFueVJhbmdlc0NvbnRhaW5SYW5nZShcbiAgICAgIGNvbnN0cmFpbnRUb1Jhbmdlcyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpLFxuICAgICAgc3ViamVjdFJhbmdlLFxuICAgICkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGNvbnN0cmFpbnRUb1JhbmdlcyhcbiAgY29uc3RyYWludDogQ29uc3RyYWludCxcbiAgc3ViamVjdFJhbmdlOiBEYXRlUmFuZ2UsIC8vIGZvciBleHBhbmRpbmcgYSByZWN1cnJpbmcgY29uc3RyYWludCwgb3IgZXhwYW5kaW5nIGJ1c2luZXNzIGhvdXJzXG4gIG90aGVyRXZlbnRTdG9yZTogRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuICBidXNpbmVzc0hvdXJzVW5leHBhbmRlZDogRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgJ2J1c2luZXNzSG91cnMnXG4gIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCwgLy8gZm9yIGV4cGFuZGluZyBidXNpbmVzc2hvdXJzXG4pOiBPcGVuRGF0ZVJhbmdlW10ge1xuICBpZiAoY29uc3RyYWludCA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XG4gICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhcbiAgICAgIGV4cGFuZFJlY3VycmluZyhidXNpbmVzc0hvdXJzVW5leHBhbmRlZCwgc3ViamVjdFJhbmdlLCBjb250ZXh0KSxcbiAgICApXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7IC8vIGFuIGdyb3VwIElEXG4gICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhcbiAgICAgIGZpbHRlckV2ZW50U3RvcmVEZWZzKG90aGVyRXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiBldmVudERlZi5ncm91cElkID09PSBjb25zdHJhaW50KSxcbiAgICApXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdvYmplY3QnICYmIGNvbnN0cmFpbnQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhcbiAgICAgIGV4cGFuZFJlY3VycmluZyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBbXSAvLyBpZiBpdCdzIGZhbHNlXG59XG5cbi8vIFRPRE86IG1vdmUgdG8gZXZlbnQtc3RvcmUgZmlsZT9cbmZ1bmN0aW9uIGV2ZW50U3RvcmVUb1JhbmdlcyhldmVudFN0b3JlOiBFdmVudFN0b3JlKTogRGF0ZVJhbmdlW10ge1xuICBsZXQgeyBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmVcbiAgbGV0IHJhbmdlczogRGF0ZVJhbmdlW10gPSBbXVxuXG4gIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgcmFuZ2VzLnB1c2goaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKVxuICB9XG5cbiAgcmV0dXJuIHJhbmdlc1xufVxuXG4vLyBUT0RPOiBtb3ZlIHRvIGdlb20gZmlsZT9cbmZ1bmN0aW9uIGFueVJhbmdlc0NvbnRhaW5SYW5nZShvdXRlclJhbmdlczogRGF0ZVJhbmdlW10sIGlubmVyUmFuZ2U6IERhdGVSYW5nZSk6IGJvb2xlYW4ge1xuICBmb3IgKGxldCBvdXRlclJhbmdlIG9mIG91dGVyUmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIENvbXBvbmVudENoaWxkcmVuLCBSZWYgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCwgc2V0UmVmIH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgQ3NzRGltVmFsdWUsIFNjcm9sbGVyTGlrZSB9IGZyb20gJy4vdXRpbCdcblxuZXhwb3J0IHR5cGUgT3ZlcmZsb3dWYWx1ZSA9ICdhdXRvJyB8ICdoaWRkZW4nIHwgJ3Njcm9sbCcgfCAndmlzaWJsZSdcblxuZXhwb3J0IGludGVyZmFjZSBTY3JvbGxlclByb3BzIHtcbiAgb3ZlcmZsb3dYOiBPdmVyZmxvd1ZhbHVlXG4gIG92ZXJmbG93WTogT3ZlcmZsb3dWYWx1ZVxuICBvdmVyY29tZUxlZnQ/OiBudW1iZXJcbiAgb3ZlcmNvbWVSaWdodD86IG51bWJlclxuICBvdmVyY29tZUJvdHRvbT86IG51bWJlclxuICBtYXhIZWlnaHQ/OiBDc3NEaW1WYWx1ZVxuICBsaXF1aWQ/OiBib29sZWFuXG4gIGxpcXVpZElzQWJzb2x1dGU/OiBib29sZWFuXG4gIGNoaWxkcmVuPzogQ29tcG9uZW50Q2hpbGRyZW5cbiAgZWxSZWY/OiBSZWY8SFRNTEVsZW1lbnQ+XG59XG5cbmNvbnN0IFZJU0lCTEVfSElEREVOX1JFID0gL14odmlzaWJsZXxoaWRkZW4pJC9cblxuZXhwb3J0IGNsYXNzIFNjcm9sbGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxTY3JvbGxlclByb3BzPiBpbXBsZW1lbnRzIFNjcm9sbGVyTGlrZSB7XG4gIHByaXZhdGUgZWw6IEhUTUxFbGVtZW50IC8vIFRPRE86IGp1c3QgdXNlIHRoaXMuYmFzZT9cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBsaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgfSA9IHByb3BzXG4gICAgbGV0IGlzQWJzb2x1dGUgPSBsaXF1aWQgJiYgbGlxdWlkSXNBYnNvbHV0ZVxuICAgIGxldCBjbGFzc05hbWUgPSBbJ2ZjLXNjcm9sbGVyJ11cblxuICAgIGlmIChsaXF1aWQpIHtcbiAgICAgIGlmIChsaXF1aWRJc0Fic29sdXRlKSB7XG4gICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NOYW1lLnB1c2goJ2ZjLXNjcm9sbGVyLWxpcXVpZCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPXt0aGlzLmhhbmRsZUVsfVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZS5qb2luKCcgJyl9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgb3ZlcmZsb3dYOiBwcm9wcy5vdmVyZmxvd1gsXG4gICAgICAgICAgb3ZlcmZsb3dZOiBwcm9wcy5vdmVyZmxvd1ksXG4gICAgICAgICAgbGVmdDogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgIHJpZ2h0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lUmlnaHQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgIGJvdHRvbTogKGlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgbWFyZ2luTGVmdDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVMZWZ0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICBtYXJnaW5SaWdodDogKCFpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUJvdHRvbSB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgbWF4SGVpZ2h0OiBwcm9wcy5tYXhIZWlnaHQgfHwgJycsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxuXG4gIGhhbmRsZUVsID0gKGVsOiBIVE1MRWxlbWVudCkgPT4ge1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbClcbiAgfVxuXG4gIG5lZWRzWFNjcm9sbGluZygpIHtcbiAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgLy8gaW5uZXItY2hpbGQgbWFyZ2lucyBhbmQgYWJzb2x1dGUgcG9zaXRpb25pbmdcblxuICAgIGxldCB7IGVsIH0gPSB0aGlzXG4gICAgbGV0IHJlYWxDbGllbnRXaWR0aCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSB0aGlzLmdldFlTY3JvbGxiYXJXaWR0aCgpXG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldXG5cbiAgICAgIGlmIChjaGlsZEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoID4gcmVhbENsaWVudFdpZHRoKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBuZWVkc1lTY3JvbGxpbmcoKSB7XG4gICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgLy8gbXVjaCBtb3JlIHJlbGlhYmxlIHRvIHNlZSBpZiBjaGlsZHJlbiBhcmUgdGFsbGVyIHRoYW4gdGhlIHNjcm9sbGVyLCBldmVuIHRobyBkb2Vzbid0IGFjY291bnQgZm9yXG4gICAgLy8gaW5uZXItY2hpbGQgbWFyZ2lucyBhbmQgYWJzb2x1dGUgcG9zaXRpb25pbmdcblxuICAgIGxldCB7IGVsIH0gPSB0aGlzXG4gICAgbGV0IHJlYWxDbGllbnRIZWlnaHQgPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCAtIHRoaXMuZ2V0WFNjcm9sbGJhcldpZHRoKClcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWxcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV1cblxuICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ID4gcmVhbENsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0WFNjcm9sbGJhcldpZHRoKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbC5jbGllbnRIZWlnaHQgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICB9XG5cbiAgZ2V0WVNjcm9sbGJhcldpZHRoKCkge1xuICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dZKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0V2lkdGggLSB0aGlzLmVsLmNsaWVudFdpZHRoIC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgfVxufVxuIiwiaW1wb3J0IHsgaGFzaFZhbHVlc1RvQXJyYXksIGNvbGxlY3RGcm9tSGFzaCB9IGZyb20gJy4vb2JqZWN0J1xuXG4vKlxuVE9ETzogc29tZWhvdyBpbmZlciBPdGhlckFyZ3MgZnJvbSBtYXN0ZXJDYWxsYmFjaz9cblRPRE86IGluZmVyIFJlZlR5cGUgZnJvbSBtYXN0ZXJDYWxsYmFjayBpZiBwcm92aWRlZFxuKi9cbmV4cG9ydCBjbGFzcyBSZWZNYXA8UmVmVHlwZT4ge1xuICBwdWJsaWMgY3VycmVudE1hcDogeyBba2V5OiBzdHJpbmddOiBSZWZUeXBlIH0gPSB7fVxuICBwcml2YXRlIGRlcHRoczogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG4gIHByaXZhdGUgY2FsbGJhY2tNYXA6IHsgW2tleTogc3RyaW5nXTogKHZhbDogUmVmVHlwZSB8IG51bGwpID0+IHZvaWQgfSA9IHt9XG5cbiAgY29uc3RydWN0b3IocHVibGljIG1hc3RlckNhbGxiYWNrPzogKHZhbDogUmVmVHlwZSB8IG51bGwsIGtleTogc3RyaW5nKSA9PiB2b2lkKSB7XG4gIH1cblxuICBjcmVhdGVSZWYoa2V5OiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICBsZXQgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV1cblxuICAgIGlmICghcmVmQ2FsbGJhY2spIHtcbiAgICAgIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldID0gKHZhbDogUmVmVHlwZSB8IG51bGwpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSh2YWwsIFN0cmluZyhrZXkpKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWZDYWxsYmFja1xuICB9XG5cbiAgaGFuZGxlVmFsdWUgPSAodmFsOiBSZWZUeXBlIHwgbnVsbCwga2V5OiBzdHJpbmcpID0+IHsgLy8gYmluZCBpbiBjYXNlIHVzZXJzIHdhbnQgdG8gcGFzcyBpdCBhcm91bmRcbiAgICBsZXQgeyBkZXB0aHMsIGN1cnJlbnRNYXAgfSA9IHRoaXNcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlXG4gICAgbGV0IGFkZGVkID0gZmFsc2VcblxuICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgIC8vIGZvciBidWcuLi4gQUNUVUFMTFk6IGNhbiBwcm9iYWJseSBkbyBhd2F5IHdpdGggdGhpcyBub3cgdGhhdCBjYWxsZXJzIGRvbid0IHNoYXJlIG51bWVyaWMgaW5kaWNlcyBhbnltb3JlXG4gICAgICByZW1vdmVkID0gKGtleSBpbiBjdXJyZW50TWFwKVxuXG4gICAgICBjdXJyZW50TWFwW2tleV0gPSB2YWxcbiAgICAgIGRlcHRoc1trZXldID0gKGRlcHRoc1trZXldIHx8IDApICsgMVxuICAgICAgYWRkZWQgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlcHRoc1trZXldIC09IDFcblxuICAgICAgaWYgKCFkZXB0aHNba2V5XSkge1xuICAgICAgICBkZWxldGUgY3VycmVudE1hcFtrZXldXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrTWFwW2tleV1cbiAgICAgICAgcmVtb3ZlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5tYXN0ZXJDYWxsYmFjaykge1xuICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5tYXN0ZXJDYWxsYmFjayhudWxsLCBTdHJpbmcoa2V5KSlcbiAgICAgIH1cbiAgICAgIGlmIChhZGRlZCkge1xuICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKHZhbCwgU3RyaW5nKGtleSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgLy8gTk9URTogdGhpcyBtZXRob2QgaGFzIGJlY29tZSBsZXNzIHZhbHVhYmxlIG5vdyB0aGF0IHdlIGFyZSBlbmNvdXJhZ2VkIHRvIG1hcCBvcmRlciBieSBzb21lIG90aGVyIGluZGV4XG4gIC8vIFRPRE86IHByb3ZpZGUgT05FIGFycmF5LWV4cG9ydCBmdW5jdGlvbiwgYnVpbGRBcnJheSwgd2hpY2ggZmFpbHMgb24gbm9uLW51bWVyaWMgaW5kZXhlcy4gY2FsbGVyIGNhbiBtYW5pcHVsYXRlIGFuZCBcImNvbGxlY3RcIlxuICBjb2xsZWN0KFxuICAgIHN0YXJ0SW5kZXg/OiBudW1iZXIsXG4gICAgZW5kSW5kZXg/OiBudW1iZXIsXG4gICAgc3RlcD86IG51bWJlcixcbiAgKSB7XG4gICAgcmV0dXJuIGNvbGxlY3RGcm9tSGFzaCh0aGlzLmN1cnJlbnRNYXAsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKVxuICB9XG5cbiAgZ2V0QWxsKCk6IFJlZlR5cGVbXSB7IC8vIHJldHVybnMgaW4gbm8gcGFydGljYWwgb3JkZXIhXG4gICAgcmV0dXJuIGhhc2hWYWx1ZXNUb0FycmF5KHRoaXMuY3VycmVudE1hcClcbiAgfVxufVxuIiwiaW1wb3J0IHsgVk5vZGUsIGNyZWF0ZUVsZW1lbnQsIFJlZiB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBmaW5kRWxlbWVudHMgfSBmcm9tICcuLi91dGlsL2RvbS1tYW5pcCdcbmltcG9ydCB7IFZpZXdDb250ZXh0IH0gZnJvbSAnLi4vVmlld0NvbnRleHQnXG5pbXBvcnQgeyBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGggfSBmcm9tICcuLi91dGlsL21pc2MnXG5pbXBvcnQgeyBpc1Byb3BzRXF1YWwgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGlzQXJyYXlzRXF1YWwgfSBmcm9tICcuLi91dGlsL2FycmF5J1xuaW1wb3J0IHsgQmFzZU9wdGlvbnNSZWZpbmVkIH0gZnJvbSAnLi4vb3B0aW9ucydcblxuZXhwb3J0IHR5cGUgQ3NzRGltVmFsdWUgPSBzdHJpbmcgfCBudW1iZXIgLy8gVE9ETzogbW92ZSB0byBtb3JlIGdlbmVyYWwgZmlsZVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbFByb3BzIHtcbiAgd2lkdGg/OiBDc3NEaW1WYWx1ZVxuICBtaW5XaWR0aD86IENzc0RpbVZhbHVlXG4gIHNwYW4/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWN0aW9uQ29uZmlnIHtcbiAgb3V0ZXJDb250ZW50PzogVk5vZGVcbiAgdHlwZTogJ2JvZHknIHwgJ2hlYWRlcicgfCAnZm9vdGVyJ1xuICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgbWF4SGVpZ2h0PzogbnVtYmVyXG4gIGxpcXVpZD86IGJvb2xlYW5cbiAgZXhwYW5kUm93cz86IGJvb2xlYW4gLy8gVE9ETzogaG93IHRvIGdldCBhIGJvdHRvbSBydWxlP1xuICBzeW5jUm93SGVpZ2h0cz86IGJvb2xlYW4gLy8geXVja1xuICBpc1N0aWNreT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgQ2h1bmtDb25maWdDb250ZW50ID0gKGNvbnRlbnRQcm9wczogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSA9PiBWTm9kZVxuZXhwb3J0IHR5cGUgQ2h1bmtDb25maWdSb3dDb250ZW50ID0gVk5vZGUgfCBDaHVua0NvbmZpZ0NvbnRlbnRcblxuZXhwb3J0IGludGVyZmFjZSBDaHVua0NvbmZpZyB7XG4gIG91dGVyQ29udGVudD86IFZOb2RlXG4gIGNvbnRlbnQ/OiBDaHVua0NvbmZpZ0NvbnRlbnRcbiAgcm93Q29udGVudD86IENodW5rQ29uZmlnUm93Q29udGVudFxuICBzY3JvbGxlckVsUmVmPzogUmVmPEhUTUxEaXZFbGVtZW50PlxuICBlbFJlZj86IFJlZjxIVE1MVGFibGVDZWxsRWxlbWVudD5cbiAgdGFibGVDbGFzc05hbWU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MgeyAvLyBUT0RPOiB1dGlsIGZvciB3cmFwcGluZyB0YWJsZXMhP1xuICB0YWJsZUNvbEdyb3VwTm9kZTogVk5vZGVcbiAgdGFibGVNaW5XaWR0aDogQ3NzRGltVmFsdWVcbiAgY2xpZW50V2lkdGg6IG51bWJlciB8IG51bGwgLy8gaW1wb3J0YW50IHRvIGtub3cgd2hldGhlciAwIG9yIG5vdC15ZXQtZGV0ZXJtaW5lZC4gZm9yIGhlYWRsZXNzIHRlc3RpbmdcbiAgY2xpZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsIC8vXG4gIGV4cGFuZFJvd3M6IGJvb2xlYW5cbiAgc3luY1Jvd0hlaWdodHM6IGJvb2xlYW5cbiAgcm93U3luY0hlaWdodHM6IG51bWJlcltdXG4gIHJlcG9ydFJvd0hlaWdodENoYW5nZTogKHJvd0VsOiBIVE1MRWxlbWVudCwgaXNTdGFibGU6IGJvb2xlYW4pID0+IHZvaWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0VsczogSFRNTEVsZW1lbnRbXSkgeyAvLyBhbGwgaW4gc2FtZSBDT0whXG4gIGxldCBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpXG4gIGxldCBsYXJnZXN0V2lkdGggPSAwXG5cbiAgZm9yIChsZXQgc2hyaW5rQ2VsbCBvZiBzaHJpbmtDZWxscykge1xuICAgIGxhcmdlc3RXaWR0aCA9IE1hdGgubWF4KFxuICAgICAgbGFyZ2VzdFdpZHRoLFxuICAgICAgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoKHNocmlua0NlbGwpLFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBNYXRoLmNlaWwobGFyZ2VzdFdpZHRoKSAvLyA8dGFibGU+IGVsZW1lbnRzIHdvcmsgYmVzdCB3aXRoIGludGVnZXJzLiByb3VuZCB1cCB0byBlbnN1cmUgY29udGVudHMgZml0c1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjcm9sbGVyTGlrZSB7IC8vIGhhdmUgc2Nyb2xsZXJzIGltcGxlbWVudD9cbiAgbmVlZHNZU2Nyb2xsaW5nKCk6IGJvb2xlYW5cbiAgbmVlZHNYU2Nyb2xsaW5nKCk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHM6IHsgbGlxdWlkOiBib29sZWFuIH0sIHNlY3Rpb25Db25maWc6IFNlY3Rpb25Db25maWcpIHtcbiAgcmV0dXJuIHByb3BzLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAvLyBkb2VzIHRoZSBzZWN0aW9uIGRvIGxpcXVpZC1oZWlnaHQ/IChuZWVkIHRvIGhhdmUgd2hvbGUgc2Nyb2xsZ3JpZCBsaXF1aWQtaGVpZ2h0IGFzIHdlbGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHM6IHsgbGlxdWlkOiBib29sZWFuIH0sIHNlY3Rpb25Db25maWc6IFNlY3Rpb25Db25maWcpIHtcbiAgcmV0dXJuIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ICE9IG51bGwgfHwgLy8gaWYgaXRzIHBvc3NpYmxlIGZvciB0aGUgaGVpZ2h0IHRvIG1heCBvdXQsIHdlIG1pZ2h0IG5lZWQgc2Nyb2xsYmFyc1xuICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpIC8vIGlmIHRoZSBzZWN0aW9uIGlzIGxpcXVpZCBoZWlnaHQsIGl0IG1pZ2h0IGNvbmRlbnNlIGVub3VnaCB0byByZXF1aXJlIHNjcm9sbGJhcnNcbn1cblxuLy8gVE9ETzogT05MWSB1c2UgYGFyZ2AuIGZvcmNlIG91dCBpbnRlcm5hbCBmdW5jdGlvbiB0byB1c2Ugc2FtZSBBUElcbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJDaHVua0NvbnRlbnQoc2VjdGlvbkNvbmZpZzogU2VjdGlvbkNvbmZpZywgY2h1bmtDb25maWc6IENodW5rQ29uZmlnLCBhcmc6IENodW5rQ29udGVudENhbGxiYWNrQXJncykge1xuICBsZXQgeyBleHBhbmRSb3dzIH0gPSBhcmdcblxuICBsZXQgY29udGVudDogVk5vZGUgPSB0eXBlb2YgY2h1bmtDb25maWcuY29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcbiAgICBjcmVhdGVFbGVtZW50KCd0YWJsZScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxuICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxuICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsIC8vIGJlY2F1c2UgY29sTWluV2lkdGhzIGFyZW50IGVub3VnaFxuICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gYXJnLmNsaWVudEhlaWdodCA6ICcnLCAvLyBjc3MgYGhlaWdodGAgb24gYSA8dGFibGU+IHNlcnZlcyBhcyBhIG1pbi1oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBhcmcudGFibGVDb2xHcm91cE5vZGUsXG4gICAgICBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHt9LCB0eXBlb2YgY2h1bmtDb25maWcucm93Q29udGVudCA9PT0gJ2Z1bmN0aW9uJyA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKSA6IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQpKVxuXG4gIHJldHVybiBjb250ZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczA6IENvbFByb3BzW10sIGNvbHMxOiBDb2xQcm9wc1tdKSB7XG4gIHJldHVybiBpc0FycmF5c0VxdWFsKGNvbHMwLCBjb2xzMSwgaXNQcm9wc0VxdWFsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzOiBDb2xQcm9wc1tdLCBzaHJpbmtXaWR0aD86IG51bWJlcik6IFZOb2RlIHtcbiAgbGV0IGNvbE5vZGVzOiBWTm9kZVtdID0gW11cblxuICAvKlxuICBmb3IgQ29sUHJvcHMgd2l0aCBzcGFucywgaXQgd291bGQgaGF2ZSBiZWVuIGdyZWF0IHRvIG1ha2UgYSBzaW5nbGUgPGNvbCBzcGFuPVwiXCI+XG4gIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXG4gIFNPTFVUSU9OOiBtYWtpbmcgaW5kaXZpZHVhbCA8Y29sPiBlbGVtZW50cyBtYWtlcyBDaHJvbWUgYmVoYXZlLlxuICAqL1xuICBmb3IgKGxldCBjb2xQcm9wcyBvZiBjb2xzKSB7XG4gICAgbGV0IHNwYW4gPSBjb2xQcm9wcy5zcGFuIHx8IDFcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhbjsgaSArPSAxKSB7XG4gICAgICBjb2xOb2Rlcy5wdXNoKFxuICAgICAgICA8Y29sXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICBtaW5XaWR0aDogY29sUHJvcHMubWluV2lkdGggfHwgJycsXG4gICAgICAgICAgfX1cbiAgICAgICAgLz4sXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJywge30sIC4uLmNvbE5vZGVzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVTaHJpbmtXaWR0aChzaHJpbmtXaWR0aD86IG51bWJlcikge1xuICAvKiB3aHkgND8gaWYgd2UgZG8gMCwgaXQgd2lsbCBraWxsIGFueSBib3JkZXIsIHdoaWNoIGFyZSBuZWVkZWQgZm9yIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aFxuICA0IGFjY291bnRzIGZvciAyIDItcGl4ZWwgYm9yZGVycy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uPyAqL1xuICByZXR1cm4gc2hyaW5rV2lkdGggPT0gbnVsbCA/IDQgOiBzaHJpbmtXaWR0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzU2hyaW5rV2lkdGgoY29sczogQ29sUHJvcHNbXSkge1xuICBmb3IgKGxldCBjb2wgb2YgY29scykge1xuICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMobGlxdWlkOiBib29sZWFuLCBjb250ZXh0OiBWaWV3Q29udGV4dCkge1xuICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAnZmMtc2Nyb2xsZ3JpZCcsXG4gICAgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGUnKSxcbiAgXVxuXG4gIGlmIChsaXF1aWQpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJylcbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnOiBTZWN0aW9uQ29uZmlnLCB3aG9sZVRhYmxlVkdyb3c6IGJvb2xlYW4pIHtcbiAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbicsXG4gICAgYGZjLXNjcm9sbGdyaWQtc2VjdGlvbi0ke3NlY3Rpb25Db25maWcudHlwZX1gLFxuICAgIHNlY3Rpb25Db25maWcuY2xhc3NOYW1lLCAvLyB1c2VkP1xuICBdXG5cbiAgaWYgKHdob2xlVGFibGVWR3JvdyAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkJylcbiAgfVxuXG4gIGlmIChzZWN0aW9uQ29uZmlnLmlzU3RpY2t5KSB7XG4gICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5JylcbiAgfVxuXG4gIHJldHVybiBjbGFzc05hbWVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTY3JvbGxTaGltKGFyZzogQ2h1bmtDb250ZW50Q2FsbGJhY2tBcmdzKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPVwiZmMtc2Nyb2xsZ3JpZC1zdGlja3ktc2hpbVwiXG4gICAgICBzdHlsZT17e1xuICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICB9fVxuICAgIC8+XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0aWNreUhlYWRlckRhdGVzKG9wdGlvbnM6IEJhc2VPcHRpb25zUmVmaW5lZCkge1xuICBsZXQgeyBzdGlja3lIZWFkZXJEYXRlcyB9ID0gb3B0aW9uc1xuXG4gIGlmIChzdGlja3lIZWFkZXJEYXRlcyA9PSBudWxsIHx8IHN0aWNreUhlYWRlckRhdGVzID09PSAnYXV0bycpIHtcbiAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0bydcbiAgfVxuXG4gIHJldHVybiBzdGlja3lIZWFkZXJEYXRlc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnM6IEJhc2VPcHRpb25zUmVmaW5lZCkge1xuICBsZXQgeyBzdGlja3lGb290ZXJTY3JvbGxiYXIgfSA9IG9wdGlvbnNcblxuICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID09IG51bGwgfHwgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID09PSAnYXV0bycpIHtcbiAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nXG4gIH1cblxuICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyXG59XG4iLCJpbXBvcnQgeyBWTm9kZSwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCwgc2V0UmVmIH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgU2Nyb2xsZXIsIE92ZXJmbG93VmFsdWUgfSBmcm9tICcuL1Njcm9sbGVyJ1xuaW1wb3J0IHsgUmVmTWFwIH0gZnJvbSAnLi4vdXRpbC9SZWZNYXAnXG5pbXBvcnQge1xuICBDb2xQcm9wcywgU2VjdGlvbkNvbmZpZywgcmVuZGVyTWljcm9Db2xHcm91cCwgY29tcHV0ZVNocmlua1dpZHRoLCBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcywgZ2V0U2VjdGlvbkNsYXNzTmFtZXMsIGdldEFsbG93WVNjcm9sbGluZyxcbiAgcmVuZGVyQ2h1bmtDb250ZW50LCBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0LCBDaHVua0NvbmZpZywgaGFzU2hyaW5rV2lkdGgsIENzc0RpbVZhbHVlLFxuICBpc0NvbFByb3BzRXF1YWwsXG59IGZyb20gJy4vdXRpbCdcbmltcG9ydCB7IGdldENhblZHcm93V2l0aGluQ2VsbCB9IGZyb20gJy4uL3V0aWwvdGFibGUtc3R5bGluZydcbmltcG9ydCB7IG1lbW9pemUgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBpc1Byb3BzRXF1YWwgfSBmcm9tICcuLi91dGlsL29iamVjdCdcbmltcG9ydCB7IGdldFNjcm9sbGJhcldpZHRocyB9IGZyb20gJy4uL3V0aWwvc2Nyb2xsYmFyLXdpZHRoJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVNjcm9sbEdyaWRQcm9wcyB7XG4gIGNvbHM6IENvbFByb3BzW11cbiAgc2VjdGlvbnM6IFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uW11cbiAgbGlxdWlkOiBib29sZWFuIC8vIGxpcXVpZCAqaGVpZ2h0KlxuICBjb2xsYXBzaWJsZVdpZHRoOiBib29sZWFuIC8vIGNhbiBBTEwgc2VjdGlvbnMgYmUgZnVsbHkgY29sbGFwc2VkIGluIHdpZHRoP1xuICBoZWlnaHQ/OiBDc3NEaW1WYWx1ZSAvLyBUT0RPOiBnaXZlIHRvIHJlYWwgU2Nyb2xsR3JpZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uIGV4dGVuZHMgU2VjdGlvbkNvbmZpZyB7XG4gIGtleTogc3RyaW5nXG4gIGNodW5rPzogQ2h1bmtDb25maWdcbn1cblxuaW50ZXJmYWNlIFNpbXBsZVNjcm9sbEdyaWRTdGF0ZSB7XG4gIHNocmlua1dpZHRoOiBudW1iZXIgfCBudWxsXG4gIGZvcmNlWVNjcm9sbGJhcnM6IGJvb2xlYW5cbiAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH1cbiAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVTY3JvbGxHcmlkIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxTaW1wbGVTY3JvbGxHcmlkUHJvcHMsIFNpbXBsZVNjcm9sbEdyaWRTdGF0ZT4ge1xuICBwcm9jZXNzQ29scyA9IG1lbW9pemUoKGEpID0+IGEsIGlzQ29sUHJvcHNFcXVhbCkgLy8gc28gd2UgZ2V0IHNhbWUgYGNvbHNgIHByb3BzIGV2ZXJ5IHRpbWVcblxuICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICByZW5kZXJNaWNyb0NvbEdyb3VwOiB0eXBlb2YgcmVuZGVyTWljcm9Db2xHcm91cCA9IG1lbW9pemUocmVuZGVyTWljcm9Db2xHcm91cClcblxuICBzY3JvbGxlclJlZnMgPSBuZXcgUmVmTWFwPFNjcm9sbGVyPigpXG4gIHNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcDxIVE1MRWxlbWVudD4odGhpcy5faGFuZGxlU2Nyb2xsZXJFbC5iaW5kKHRoaXMpKVxuXG4gIHN0YXRlOiBTaW1wbGVTY3JvbGxHcmlkU3RhdGUgPSB7XG4gICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHt9LFxuICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge30sXG4gIH1cblxuICByZW5kZXIoKTogVk5vZGUge1xuICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdXG4gICAgbGV0IGNvbHMgPSB0aGlzLnByb2Nlc3NDb2xzKHByb3BzLmNvbHMpXG5cbiAgICBsZXQgbWljcm9Db2xHcm91cE5vZGUgPSB0aGlzLnJlbmRlck1pY3JvQ29sR3JvdXAoY29scywgc3RhdGUuc2hyaW5rV2lkdGgpXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhwcm9wcy5saXF1aWQsIGNvbnRleHQpXG5cbiAgICBpZiAocHJvcHMuY29sbGFwc2libGVXaWR0aCkge1xuICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWNvbGxhcHNpYmxlJylcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBtYWtlIERSWVxuICAgIGxldCBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGhcbiAgICBsZXQgY29uZmlnSSA9IDBcbiAgICBsZXQgY3VycmVudENvbmZpZzogU2ltcGxlU2Nyb2xsR3JpZFNlY3Rpb25cbiAgICBsZXQgaGVhZFNlY3Rpb25Ob2RlczogVk5vZGVbXSA9IFtdXG4gICAgbGV0IGJvZHlTZWN0aW9uTm9kZXM6IFZOb2RlW10gPSBbXVxuICAgIGxldCBmb290U2VjdGlvbk5vZGVzOiBWTm9kZVtdID0gW11cblxuICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlKSlcbiAgICAgIGNvbmZpZ0kgKz0gMVxuICAgIH1cblxuICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdib2R5Jykge1xuICAgICAgYm9keVNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSkpXG4gICAgICBjb25maWdJICs9IDFcbiAgICB9XG5cbiAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnZm9vdGVyJykge1xuICAgICAgZm9vdFNlY3Rpb25Ob2Rlcy5wdXNoKHRoaXMucmVuZGVyU2VjdGlvbihjdXJyZW50Q29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSkpXG4gICAgICBjb25maWdJICs9IDFcbiAgICB9XG5cbiAgICAvLyBmaXJlZm94IGJ1Zzogd2hlbiBzZXR0aW5nIGhlaWdodCBvbiB0YWJsZSBhbmQgdGhlcmUgaXMgYSB0aGVhZCBvciB0Zm9vdCxcbiAgICAvLyB0aGUgbmVjZXNzYXJ5IGhlaWdodDoxMDAlIG9uIHRoZSBsaXF1aWQtaGVpZ2h0IGJvZHkgc2VjdGlvbiBmb3JjZXMgdGhlICp3aG9sZSogdGFibGUgdG8gYmUgdGFsbGVyLiAoYnVnICM1NTI0KVxuICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgIC8vIGlmIHNvLCB1c2UgYSBzaW1wbGVyIGRvbSBzdHJ1Y3R1cmUsIGphbSBldmVyeXRoaW5nIGludG8gYSBsb25lIHRib2R5LlxuICAgIGxldCBpc0J1Z2d5ID0gIWdldENhblZHcm93V2l0aGluQ2VsbCgpXG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgICd0YWJsZScsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksXG4gICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXG4gICAgICB9LFxuICAgICAgQm9vbGVhbighaXNCdWdneSAmJiBoZWFkU2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGhlYWQnLCB7fSwgLi4uaGVhZFNlY3Rpb25Ob2RlcyksXG4gICAgICBCb29sZWFuKCFpc0J1Z2d5ICYmIGJvZHlTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHt9LCAuLi5ib2R5U2VjdGlvbk5vZGVzKSxcbiAgICAgIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rmb290Jywge30sIC4uLmZvb3RTZWN0aW9uTm9kZXMpLFxuICAgICAgaXNCdWdneSAmJiBjcmVhdGVFbGVtZW50KCd0Ym9keScsIHt9LCAuLi5oZWFkU2VjdGlvbk5vZGVzLCAuLi5ib2R5U2VjdGlvbk5vZGVzLCAuLi5mb290U2VjdGlvbk5vZGVzKSxcbiAgICApXG4gIH1cblxuICByZW5kZXJTZWN0aW9uKHNlY3Rpb25Db25maWc6IFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uLCBtaWNyb0NvbEdyb3VwTm9kZTogVk5vZGUpIHtcbiAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEZyYWdtZW50IGtleT17c2VjdGlvbkNvbmZpZy5rZXl9PlxuICAgICAgICAgIHtzZWN0aW9uQ29uZmlnLm91dGVyQ29udGVudH1cbiAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRyIGtleT17c2VjdGlvbkNvbmZpZy5rZXl9IGNsYXNzTmFtZT17Z2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKX0+XG4gICAgICAgIHt0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmspfVxuICAgICAgPC90cj5cbiAgICApXG4gIH1cblxuICByZW5kZXJDaHVua1RkKHNlY3Rpb25Db25maWc6IFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uLCBtaWNyb0NvbEdyb3VwTm9kZTogVk5vZGUsIGNodW5rQ29uZmlnOiBDaHVua0NvbmZpZykge1xuICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBjaHVua0NvbmZpZykge1xuICAgICAgcmV0dXJuIGNodW5rQ29uZmlnLm91dGVyQ29udGVudFxuICAgIH1cblxuICAgIGxldCB7IHByb3BzIH0gPSB0aGlzXG4gICAgbGV0IHsgZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0cyB9ID0gdGhpcy5zdGF0ZVxuXG4gICAgbGV0IG5lZWRzWVNjcm9sbGluZyA9IGdldEFsbG93WVNjcm9sbGluZyhwcm9wcywgc2VjdGlvbkNvbmZpZykgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICBsZXQgaXNMaXF1aWQgPSBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKVxuXG4gICAgLy8gZm9yIGAhcHJvcHMubGlxdWlkYCAtIGlzIFdIT0xFIHNjcm9sbGdyaWQgbmF0dXJhbCBoZWlnaHQ/XG4gICAgLy8gVE9ETzogZG8gc2FtZSB0aGluZyBpbiBhZHZhbmNlZCBzY3JvbGxncmlkPyBwcm9sbHkgbm90IGIvYyBhbHdheXMgaGFzIGhvcml6b250YWwgc2Nyb2xsYmFyc1xuICAgIGxldCBvdmVyZmxvd1k6IE92ZXJmbG93VmFsdWUgPVxuICAgICAgIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6XG4gICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICdhdXRvJ1xuXG4gICAgbGV0IHNlY3Rpb25LZXkgPSBzZWN0aW9uQ29uZmlnLmtleVxuICAgIGxldCBjb250ZW50ID0gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCB7XG4gICAgICB0YWJsZUNvbEdyb3VwTm9kZTogbWljcm9Db2xHcm91cE5vZGUsXG4gICAgICB0YWJsZU1pbldpZHRoOiAnJyxcbiAgICAgIGNsaWVudFdpZHRoOiAoIXByb3BzLmNvbGxhcHNpYmxlV2lkdGggJiYgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCkgPyBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICBjbGllbnRIZWlnaHQ6IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkID8gc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgIGV4cGFuZFJvd3M6IHNlY3Rpb25Db25maWcuZXhwYW5kUm93cyxcbiAgICAgIHN5bmNSb3dIZWlnaHRzOiBmYWxzZSxcbiAgICAgIHJvd1N5bmNIZWlnaHRzOiBbXSxcbiAgICAgIHJlcG9ydFJvd0hlaWdodENoYW5nZTogKCkgPT4ge30sXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8dGQgcmVmPXtjaHVua0NvbmZpZy5lbFJlZn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgZmMtc2Nyb2xsZXItaGFybmVzcyR7aXNMaXF1aWQgPyAnIGZjLXNjcm9sbGVyLWhhcm5lc3MtbGlxdWlkJyA6ICcnfWB9PlxuICAgICAgICAgIDxTY3JvbGxlclxuICAgICAgICAgICAgcmVmPXt0aGlzLnNjcm9sbGVyUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSl9XG4gICAgICAgICAgICBlbFJlZj17dGhpcy5zY3JvbGxlckVsUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSl9XG4gICAgICAgICAgICBvdmVyZmxvd1k9e292ZXJmbG93WX1cbiAgICAgICAgICAgIG92ZXJmbG93WD17IXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nIC8qIG5hdHVyYWwgaGVpZ2h0PyAqL31cbiAgICAgICAgICAgIG1heEhlaWdodD17c2VjdGlvbkNvbmZpZy5tYXhIZWlnaHR9XG4gICAgICAgICAgICBsaXF1aWQ9e2lzTGlxdWlkfVxuICAgICAgICAgICAgbGlxdWlkSXNBYnNvbHV0ZSAvLyBiZWNhdXNlIGl0cyB3aXRoaW4gYSBoYXJuZXNzXG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NvbnRlbnR9XG4gICAgICAgICAgPC9TY3JvbGxlcj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3RkPlxuICAgIClcbiAgfVxuXG4gIF9oYW5kbGVTY3JvbGxlckVsKHNjcm9sbGVyRWw6IEhUTUxFbGVtZW50IHwgbnVsbCwga2V5OiBzdHJpbmcpIHtcbiAgICBsZXQgc2VjdGlvbiA9IGdldFNlY3Rpb25CeUtleSh0aGlzLnByb3BzLnNlY3Rpb25zLCBrZXkpXG5cbiAgICBpZiAoc2VjdGlvbikge1xuICAgICAgc2V0UmVmKHNlY3Rpb24uY2h1bmsuc2Nyb2xsZXJFbFJlZiwgc2Nyb2xsZXJFbClcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgaGFuZGxlU2l6aW5nID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc2hyaW5rV2lkdGg6IHRoaXMuY29tcHV0ZVNocmlua1dpZHRoKCksIC8vIHdpbGwgY3JlYXRlIGVhY2ggY2h1bmsncyA8Y29sZ3JvdXA+LiBUT0RPOiBwcmVjb21wdXRlIGhhc1Nocmlua1dpZHRoXG4gICAgICAuLi50aGlzLmNvbXB1dGVTY3JvbGxlckRpbXMoKSxcbiAgICB9KVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5oYW5kbGVTaXppbmcoKVxuICAgIHRoaXMuY29udGV4dC5hZGRSZXNpemVIYW5kbGVyKHRoaXMuaGFuZGxlU2l6aW5nKVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIC8vIFRPRE86IG5lZWQgYmV0dGVyIHNvbHV0aW9uIHdoZW4gc3RhdGUgY29udGFpbnMgbm9uLXNpemluZyB0aGluZ3NcbiAgICB0aGlzLmhhbmRsZVNpemluZygpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLmNvbnRleHQucmVtb3ZlUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZylcbiAgfVxuXG4gIGNvbXB1dGVTaHJpbmtXaWR0aCgpIHtcbiAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgIDogMFxuICB9XG5cbiAgY29tcHV0ZVNjcm9sbGVyRGltcygpIHtcbiAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aHMoKVxuICAgIGxldCB7IHNjcm9sbGVyUmVmcywgc2Nyb2xsZXJFbFJlZnMgfSA9IHRoaXNcblxuICAgIGxldCBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2VcbiAgICBsZXQgc2Nyb2xsZXJDbGllbnRXaWR0aHM6IHsgW2luZGV4OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG4gICAgbGV0IHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogeyBbaW5kZXg6IHN0cmluZ106IG51bWJlciB9ID0ge31cblxuICAgIGZvciAobGV0IHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgIGxldCBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldXG5cbiAgICAgIGlmIChzY3JvbGxlciAmJiBzY3JvbGxlci5uZWVkc1lTY3JvbGxpbmcoKSkge1xuICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHNlY3Rpb24gb2YgdGhpcy5wcm9wcy5zZWN0aW9ucykge1xuICAgICAgbGV0IHNlY3Rpb25LZXkgPSBzZWN0aW9uLmtleVxuICAgICAgbGV0IHNjcm9sbGVyRWwgPSBzY3JvbGxlckVsUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldXG5cbiAgICAgIGlmIChzY3JvbGxlckVsKSB7XG4gICAgICAgIGxldCBoYXJuZXNzRWwgPSBzY3JvbGxlckVsLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgLy8gVE9ETzogd2VpcmQgd2F5IHRvIGdldCB0aGlzLiBuZWVkIGhhcm5lc3MgYi9jIGRvZXNuJ3QgaW5jbHVkZSB0YWJsZSBib3JkZXJzXG5cbiAgICAgICAgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgIGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIChcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnNcbiAgICAgICAgICAgICAgPyBzY3JvbGxiYXJXaWR0aC55IC8vIHVzZSBnbG9iYWwgYmVjYXVzZSBzY3JvbGxlciBtaWdodCBub3QgaGF2ZSBzY3JvbGxiYXJzIHlldCBidXQgd2lsbCBuZWVkIHRoZW0gaW4gZnV0dXJlXG4gICAgICAgICAgICAgIDogMFxuICAgICAgICAgICksXG4gICAgICAgIClcblxuICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgIGhhcm5lc3NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsIC8vIG5ldmVyIGhhcyBob3Jpem9udGFsIHNjcm9sbGJhcnNcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgfVxuICB9XG59XG5cblNpbXBsZVNjcm9sbEdyaWQuYWRkU3RhdGVFcXVhbGl0eSh7XG4gIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiBpc1Byb3BzRXF1YWwsXG4gIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSlcblxuZnVuY3Rpb24gZ2V0U2VjdGlvbkJ5S2V5KHNlY3Rpb25zOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbltdLCBrZXk6IHN0cmluZyk6IFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uIHwgbnVsbCB7XG4gIGZvciAobGV0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICBpZiAoc2VjdGlvbi5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHNlY3Rpb25cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuIiwiaW1wb3J0IHsgU2VnIH0gZnJvbSAnLi4vY29tcG9uZW50L0RhdGVDb21wb25lbnQnXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCwgUmVmLCBjcmVhdGVSZWYsIFJlZk9iamVjdCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7XG4gIGNvbXB1dGVTZWdEcmFnZ2FibGUsXG4gIGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSxcbiAgY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSxcbiAgc2V0RWxTZWcsXG4gIEV2ZW50Q29udGVudEFyZyxcbiAgZ2V0RXZlbnRDbGFzc05hbWVzLFxufSBmcm9tICcuLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgUmVuZGVySG9vayB9IGZyb20gJy4vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE1pbmltYWxFdmVudFByb3BzIHtcbiAgc2VnOiBTZWdcbiAgaXNEcmFnZ2luZzogYm9vbGVhbiAvLyByZW5hbWUgdG8gaXNNaXJyb3JEcmFnZ2luZz8gbWFrZSBvcHRpb25hbD9cbiAgaXNSZXNpemluZzogYm9vbGVhbiAvLyByZW5hbWUgdG8gaXNNaXJyb3JSZXNpemluZz8gbWFrZSBvcHRpb25hbD9cbiAgaXNEYXRlU2VsZWN0aW5nOiBib29sZWFuIC8vIHJlbmFtZSB0byBpc01pcnJvckRhdGVTZWxlY3Rpbmc/IG1ha2Ugb3B0aW9uYWw/XG4gIGlzU2VsZWN0ZWQ6IGJvb2xlYW5cbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFdmVudFJvb3RQcm9wcyBleHRlbmRzIE1pbmltYWxFdmVudFByb3BzIHtcbiAgdGltZVRleHQ6IHN0cmluZ1xuICBkaXNhYmxlRHJhZ2dpbmc/OiBib29sZWFuXG4gIGRpc2FibGVSZXNpemluZz86IGJvb2xlYW5cbiAgZGVmYXVsdENvbnRlbnQ6IChob29rUHJvcHM6IEV2ZW50Q29udGVudEFyZykgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbiAgY2hpbGRyZW46IChcbiAgICByb290RWxSZWY6IFJlZjxhbnk+LFxuICAgIGNsYXNzTmFtZXM6IHN0cmluZ1tdLFxuICAgIGlubmVyRWxSZWY6IFJlZjxhbnk+LFxuICAgIGlubmVyQ29udGVudDogQ29tcG9uZW50Q2hpbGRyZW4sXG4gICAgaG9va1Byb3BzOiBFdmVudENvbnRlbnRBcmdcbiAgKSA9PiBDb21wb25lbnRDaGlsZHJlblxufVxuXG5leHBvcnQgY2xhc3MgRXZlbnRSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxFdmVudFJvb3RQcm9wcz4ge1xuICBlbFJlZjogUmVmT2JqZWN0PEhUTUxFbGVtZW50PiA9IGNyZWF0ZVJlZjxIVE1MRWxlbWVudD4oKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICBsZXQgeyBzZWcgfSA9IHByb3BzXG4gICAgbGV0IHsgZXZlbnRSYW5nZSB9ID0gc2VnXG4gICAgbGV0IHsgdWkgfSA9IGV2ZW50UmFuZ2VcblxuICAgIGxldCBob29rUHJvcHM6IEV2ZW50Q29udGVudEFyZyA9IHtcbiAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLCAvLyBUT0RPOiBkb24ndCBjYXN0LiBnZXREYXRlTWV0YSBkb2VzIGl0XG4gICAgICBpc0Z1dHVyZTogQm9vbGVhbihwcm9wcy5pc0Z1dHVyZSksIC8vIFRPRE86IGRvbid0IGNhc3QuIGdldERhdGVNZXRhIGRvZXMgaXRcbiAgICAgIGlzVG9kYXk6IEJvb2xlYW4ocHJvcHMuaXNUb2RheSksIC8vIFRPRE86IGRvbid0IGNhc3QuIGdldERhdGVNZXRhIGRvZXMgaXRcbiAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICB9XG5cbiAgICBsZXQgc3RhbmRhcmRDbGFzc05hbWVzID0gZ2V0RXZlbnRDbGFzc05hbWVzKGhvb2tQcm9wcykuY29uY2F0KHVpLmNsYXNzTmFtZXMpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFJlbmRlckhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMuZXZlbnRDbGFzc05hbWVzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLmV2ZW50Q29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50fVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5ldmVudERpZE1vdW50fVxuICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5ldmVudFdpbGxVbm1vdW50fVxuICAgICAgICBlbFJlZj17dGhpcy5lbFJlZn1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gcHJvcHMuY2hpbGRyZW4oXG4gICAgICAgICAgcm9vdEVsUmVmLCBzdGFuZGFyZENsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcyxcbiAgICAgICAgKX1cbiAgICAgIDwvUmVuZGVySG9vaz5cbiAgICApXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuc2VnKVxuICB9XG5cbiAgLypcbiAgbmVlZCB0byByZS1hc3NpZ24gc2VnIHRvIHRoZSBlbGVtZW50IGlmIHNlZyBjaGFuZ2VzLCBldmVuIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lXG4gICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IEV2ZW50Um9vdFByb3BzKSB7XG4gICAgbGV0IHsgc2VnIH0gPSB0aGlzLnByb3BzXG5cbiAgICBpZiAoc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XG4gICAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHNlZylcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRDb250ZW50QXJnIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcbmltcG9ydCB7IEV2ZW50Um9vdCwgTWluaW1hbEV2ZW50UHJvcHMgfSBmcm9tICcuL0V2ZW50Um9vdCdcbmltcG9ydCB7IFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgRGF0ZUZvcm1hdHRlciB9IGZyb20gJy4uL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcblxuZXhwb3J0IGludGVyZmFjZSBTdGFuZGFyZEV2ZW50UHJvcHMgZXh0ZW5kcyBNaW5pbWFsRXZlbnRQcm9wcyB7XG4gIGV4dHJhQ2xhc3NOYW1lczogc3RyaW5nW11cbiAgZGVmYXVsdFRpbWVGb3JtYXQ6IERhdGVGb3JtYXR0ZXJcbiAgZGVmYXVsdERpc3BsYXlFdmVudFRpbWU/OiBib29sZWFuIC8vIGRlZmF1bHQgdHJ1ZVxuICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPzogYm9vbGVhbiAvLyBkZWZhdWx0IHRydWVcbiAgZGlzYWJsZURyYWdnaW5nPzogYm9vbGVhbiAvLyBkZWZhdWx0IGZhbHNlXG4gIGRpc2FibGVSZXNpemluZz86IGJvb2xlYW4gLy8gZGVmYXVsdCBmYWxzZVxuICBkZWZhdWx0Q29udGVudD86IChob29rUHJvcHM6IEV2ZW50Q29udGVudEFyZykgPT4gQ29tcG9uZW50Q2hpbGRyZW4gLy8gbm90IHVzZWQgYnkgYW55b25lIHlldFxufVxuXG4vLyBzaG91bGQgbm90IGJlIGEgcHVyZWNvbXBvbmVudFxuZXhwb3J0IGNsYXNzIFN0YW5kYXJkRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PFN0YW5kYXJkRXZlbnRQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBzZWcgfSA9IHByb3BzXG4gICAgbGV0IHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRUaW1lRm9ybWF0XG4gICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChcbiAgICAgIHNlZyxcbiAgICAgIHRpbWVGb3JtYXQsXG4gICAgICBjb250ZXh0LFxuICAgICAgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsXG4gICAgICBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLFxuICAgIClcblxuICAgIHJldHVybiAoXG4gICAgICA8RXZlbnRSb290XG4gICAgICAgIHNlZz17c2VnfVxuICAgICAgICB0aW1lVGV4dD17dGltZVRleHR9XG4gICAgICAgIGRpc2FibGVEcmFnZ2luZz17cHJvcHMuZGlzYWJsZURyYWdnaW5nfVxuICAgICAgICBkaXNhYmxlUmVzaXppbmc9e3Byb3BzLmRpc2FibGVSZXNpemluZ31cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50IHx8IHJlbmRlcklubmVyQ29udGVudH1cbiAgICAgICAgaXNEcmFnZ2luZz17cHJvcHMuaXNEcmFnZ2luZ31cbiAgICAgICAgaXNSZXNpemluZz17cHJvcHMuaXNSZXNpemluZ31cbiAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtwcm9wcy5pc0RhdGVTZWxlY3Rpbmd9XG4gICAgICAgIGlzU2VsZWN0ZWQ9e3Byb3BzLmlzU2VsZWN0ZWR9XG4gICAgICAgIGlzUGFzdD17cHJvcHMuaXNQYXN0fVxuICAgICAgICBpc0Z1dHVyZT17cHJvcHMuaXNGdXR1cmV9XG4gICAgICAgIGlzVG9kYXk9e3Byb3BzLmlzVG9kYXl9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgPT4gKFxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9e3Byb3BzLmV4dHJhQ2xhc3NOYW1lcy5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhvb2tQcm9wcy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBob29rUHJvcHMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgey4uLmdldFNlZ0FuY2hvckF0dHJzKHNlZyl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1ldmVudC1tYWluXCIgcmVmPXtpbm5lckVsUmVmfSBzdHlsZT17eyBjb2xvcjogaG9va1Byb3BzLnRleHRDb2xvciB9fT5cbiAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAge2hvb2tQcm9wcy5pc1N0YXJ0UmVzaXphYmxlICYmXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLXN0YXJ0XCIgLz59XG4gICAgICAgICAgICB7aG9va1Byb3BzLmlzRW5kUmVzaXphYmxlICYmXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLWVuZFwiIC8+fVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgKX1cbiAgICAgIDwvRXZlbnRSb290PlxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQoaW5uZXJQcm9wczogRXZlbnRDb250ZW50QXJnKSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmYy1ldmVudC1tYWluLWZyYW1lXCI+XG4gICAgICB7aW5uZXJQcm9wcy50aW1lVGV4dCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtdGltZVwiPntpbm5lclByb3BzLnRpbWVUZXh0fTwvZGl2PlxuICAgICAgKX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtdGl0bGUtY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtdGl0bGUgZmMtc3RpY2t5XCI+XG4gICAgICAgICAge2lubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgPEZyYWdtZW50PiZuYnNwOzwvRnJhZ21lbnQ+fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZzogU2VnKSB7XG4gIGxldCB7IHVybCB9ID0gc2VnLmV2ZW50UmFuZ2UuZGVmXG4gIHJldHVybiB1cmwgPyB7IGhyZWY6IHVybCB9IDoge31cbn1cbiIsImltcG9ydCB7IFJlbmRlckhvb2ssIFJlbmRlckhvb2tQcm9wc0NoaWxkcmVuLCBNb3VudEFyZyB9IGZyb20gJy4vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBWaWV3Q29udGV4dCwgVmlld0NvbnRleHRUeXBlIH0gZnJvbSAnLi4vVmlld0NvbnRleHQnXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vd0luZGljYXRvclJvb3RQcm9wcyB7XG4gIGlzQXhpczogYm9vbGVhblxuICBkYXRlOiBEYXRlTWFya2VyXG4gIGNoaWxkcmVuOiBSZW5kZXJIb29rUHJvcHNDaGlsZHJlblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vd0luZGljYXRvckNvbnRlbnRBcmcge1xuICBpc0F4aXM6IGJvb2xlYW5cbiAgZGF0ZTogRGF0ZVxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCB0eXBlIE5vd0luZGljYXRvck1vdW50QXJnID0gTW91bnRBcmc8Tm93SW5kaWNhdG9yQ29udGVudEFyZz5cblxuZXhwb3J0IGNvbnN0IE5vd0luZGljYXRvclJvb3QgPSAocHJvcHM6IE5vd0luZGljYXRvclJvb3RQcm9wcykgPT4gKFxuICA8Vmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgIHsoY29udGV4dDogVmlld0NvbnRleHQpID0+IHtcbiAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICAgIGxldCBob29rUHJvcHM6IE5vd0luZGljYXRvckNvbnRlbnRBcmcgPSB7XG4gICAgICAgIGlzQXhpczogcHJvcHMuaXNBeGlzLFxuICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHByb3BzLmRhdGUpLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxSZW5kZXJIb29rXG4gICAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgICAgY2xhc3NOYW1lcz17b3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzfVxuICAgICAgICAgIGNvbnRlbnQ9e29wdGlvbnMubm93SW5kaWNhdG9yQ29udGVudH1cbiAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5ub3dJbmRpY2F0b3JEaWRNb3VudH1cbiAgICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy5ub3dJbmRpY2F0b3JXaWxsVW5tb3VudH1cbiAgICAgICAgPlxuICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgPC9SZW5kZXJIb29rPlxuICAgICAgKVxuICAgIH19XG4gIDwvVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuKVxuIiwiaW1wb3J0IHsgUmVmLCBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBEYXRlTWFya2VyIH0gZnJvbSAnLi4vZGF0ZWxpYi9tYXJrZXInXG5pbXBvcnQgeyBEYXRlUmFuZ2UgfSBmcm9tICcuLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5pbXBvcnQgeyBnZXREYXRlTWV0YSwgRGF0ZU1ldGEgfSBmcm9tICcuLi9jb21wb25lbnQvZGF0ZS1yZW5kZXJpbmcnXG5pbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmcnXG5pbXBvcnQgeyBDb250ZW50SG9vayB9IGZyb20gJy4vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi4vVmlld0FwaSdcbmltcG9ydCB7IEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi92ZG9tLXV0aWwnXG5pbXBvcnQgeyBEYXRlUHJvZmlsZSB9IGZyb20gJy4uL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyBEYXRlRW52IH0gZnJvbSAnLi4vZGF0ZWxpYi9lbnYnXG5cbmNvbnN0IERBWV9OVU1fRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgZGF5OiAnbnVtZXJpYycgfSlcblxuZXhwb3J0IGludGVyZmFjZSBEYXlDZWxsQ29udGVudFByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIHNob3dEYXlOdW1iZXI/OiBib29sZWFuIC8vIGRlZmF1bHRzIHRvIGZhbHNlXG4gIGV4dHJhSG9va1Byb3BzPzogRGljdGlvbmFyeVxuICBkZWZhdWx0Q29udGVudD86IChob29rUHJvcHM6IERheUNlbGxDb250ZW50QXJnKSA9PiBDb21wb25lbnRDaGlsZHJlblxuICBjaGlsZHJlbjogKFxuICAgIGlubmVyRWxSZWY6IFJlZjxhbnk+LFxuICAgIGlubmVyQ29udGVudDogQ29tcG9uZW50Q2hpbGRyZW5cbiAgKSA9PiBDb21wb25lbnRDaGlsZHJlblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheUNlbGxDb250ZW50QXJnIGV4dGVuZHMgRGF0ZU1ldGEge1xuICBkYXRlOiBEYXRlTWFya2VyIC8vIGxvY2FsaXplZFxuICB2aWV3OiBWaWV3QXBpXG4gIGRheU51bWJlclRleHQ6IHN0cmluZ1xuICBbZXh0cmFQcm9wOiBzdHJpbmddOiBhbnkgLy8gc28gY2FuIGluY2x1ZGUgYSByZXNvdXJjZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERheUNlbGxIb29rUHJvcHNJbnB1dCB7XG4gIGRhdGU6IERhdGVNYXJrZXIgLy8gZ2VuZXJpY1xuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIGRhdGVFbnY6IERhdGVFbnZcbiAgdmlld0FwaTogVmlld0FwaVxuICBzaG93RGF5TnVtYmVyPzogYm9vbGVhbiAvLyBkZWZhdWx0cyB0byBmYWxzZVxuICBleHRyYVByb3BzPzogRGljdGlvbmFyeSAvLyBzbyBjYW4gaW5jbHVkZSBhIHJlc291cmNlXG59XG5cbmV4cG9ydCBjbGFzcyBEYXlDZWxsQ29udGVudCBleHRlbmRzIEJhc2VDb21wb25lbnQ8RGF5Q2VsbENvbnRlbnRQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0XG4gICAgbGV0IGhvb2tQcm9wcyA9IHJlZmluZURheUNlbGxIb29rUHJvcHMoe1xuICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLFxuICAgICAgZXh0cmFQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsXG4gICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8Q29udGVudEhvb2tcbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuZGF5Q2VsbENvbnRlbnR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtwcm9wcy5kZWZhdWx0Q29udGVudH1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9Db250ZW50SG9vaz5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZmluZURheUNlbGxIb29rUHJvcHMocmF3OiBEYXlDZWxsSG9va1Byb3BzSW5wdXQpOiBEYXlDZWxsQ29udGVudEFyZyB7XG4gIGxldCB7IGRhdGUsIGRhdGVFbnYgfSA9IHJhd1xuICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHJhdy50b2RheVJhbmdlLCBudWxsLCByYXcuZGF0ZVByb2ZpbGUpXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSxcbiAgICB2aWV3OiByYXcudmlld0FwaSxcbiAgICAuLi5kYXlNZXRhLFxuICAgIGRheU51bWJlclRleHQ6IHJhdy5zaG93RGF5TnVtYmVyID8gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgREFZX05VTV9GT1JNQVQpIDogJycsXG4gICAgLi4ucmF3LmV4dHJhUHJvcHMsXG4gIH1cbn1cbiIsImltcG9ydCB7IFJlZiwgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgZ2V0RGF5Q2xhc3NOYW1lcywgRGF0ZU1ldGEgfSBmcm9tICcuLi9jb21wb25lbnQvZGF0ZS1yZW5kZXJpbmcnXG5pbXBvcnQgeyBmb3JtYXREYXlTdHJpbmcgfSBmcm9tICcuLi9kYXRlbGliL2Zvcm1hdHRpbmctdXRpbHMnXG5pbXBvcnQgeyBidWlsZENsYXNzTmFtZU5vcm1hbGl6ZXIsIE1vdW50SG9vaywgTW91bnRBcmcgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuaW1wb3J0IHsgVmlld0FwaSB9IGZyb20gJy4uL1ZpZXdBcGknXG5pbXBvcnQgeyBCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IG1lbW9pemVPYmpBcmcgfSBmcm9tICcuLi91dGlsL21lbW9pemUnXG5pbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IHJlZmluZURheUNlbGxIb29rUHJvcHMgfSBmcm9tICcuL0RheUNlbGxDb250ZW50J1xuXG5leHBvcnQgaW50ZXJmYWNlIERheUNlbGxDb250ZW50QXJnIGV4dGVuZHMgRGF0ZU1ldGEge1xuICBkYXRlOiBEYXRlTWFya2VyIC8vIGxvY2FsaXplZFxuICB2aWV3OiBWaWV3QXBpXG4gIGRheU51bWJlclRleHQ6IHN0cmluZ1xuICBbZXh0cmFQcm9wOiBzdHJpbmddOiBhbnkgLy8gc28gY2FuIGluY2x1ZGUgYSByZXNvdXJjZVxufVxuZXhwb3J0IHR5cGUgRGF5Q2VsbE1vdW50QXJnID0gTW91bnRBcmc8RGF5Q2VsbENvbnRlbnRBcmc+XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5Q2VsbFJvb3RQcm9wcyB7XG4gIGVsUmVmPzogUmVmPGFueT5cbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIHNob3dEYXlOdW1iZXI/OiBib29sZWFuIC8vIGRlZmF1bHRzIHRvIGZhbHNlXG4gIGV4dHJhSG9va1Byb3BzPzogRGljdGlvbmFyeVxuICBjaGlsZHJlbjogKFxuICAgIHJvb3RFbFJlZjogUmVmPGFueT4sXG4gICAgY2xhc3NOYW1lczogc3RyaW5nW10sXG4gICAgcm9vdERhdGFBdHRycyxcbiAgICBpc0Rpc2FibGVkOiBib29sZWFuXG4gICkgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbn1cblxuZXhwb3J0IGNsYXNzIERheUNlbGxSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxEYXlDZWxsUm9vdFByb3BzPiB7XG4gIHJlZmluZUhvb2tQcm9wcyA9IG1lbW9pemVPYmpBcmcocmVmaW5lRGF5Q2VsbEhvb2tQcm9wcylcbiAgbm9ybWFsaXplQ2xhc3NOYW1lcyA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjxEYXlDZWxsQ29udGVudEFyZz4oKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcbiAgICBsZXQgaG9va1Byb3BzID0gdGhpcy5yZWZpbmVIb29rUHJvcHMoe1xuICAgICAgZGF0ZTogcHJvcHMuZGF0ZSxcbiAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsXG4gICAgICBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLFxuICAgICAgZXh0cmFQcm9wczogcHJvcHMuZXh0cmFIb29rUHJvcHMsXG4gICAgICB2aWV3QXBpOiBjb250ZXh0LnZpZXdBcGksXG4gICAgICBkYXRlRW52OiBjb250ZXh0LmRhdGVFbnYsXG4gICAgfSlcblxuICAgIGxldCBjbGFzc05hbWVzID0gZ2V0RGF5Q2xhc3NOYW1lcyhob29rUHJvcHMsIGNvbnRleHQudGhlbWUpLmNvbmNhdChcbiAgICAgIGhvb2tQcm9wcy5pc0Rpc2FibGVkXG4gICAgICAgID8gW10gLy8gZG9uJ3QgdXNlIGN1c3RvbSBjbGFzc05hbWVzIGlmIGRpc2FibGVkXG4gICAgICAgIDogdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzKG9wdGlvbnMuZGF5Q2VsbENsYXNzTmFtZXMsIGhvb2tQcm9wcyksXG4gICAgKVxuXG4gICAgbGV0IGRhdGFBdHRycyA9IGhvb2tQcm9wcy5pc0Rpc2FibGVkID8ge30gOiB7XG4gICAgICAnZGF0YS1kYXRlJzogZm9ybWF0RGF5U3RyaW5nKHByb3BzLmRhdGUpLFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8TW91bnRIb29rXG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5kYXlDZWxsRGlkTW91bnR9XG4gICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLmRheUNlbGxXaWxsVW5tb3VudH1cbiAgICAgICAgZWxSZWY9e3Byb3BzLmVsUmVmfVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZikgPT4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBkYXRhQXR0cnMsIGhvb2tQcm9wcy5pc0Rpc2FibGVkKX1cbiAgICAgIDwvTW91bnRIb29rPlxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBFdmVudFJvb3QgfSBmcm9tICcuL0V2ZW50Um9vdCdcbmltcG9ydCB7IFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgRXZlbnRDb250ZW50QXJnIH0gZnJvbSAnLi4vY29tcG9uZW50L2V2ZW50LXJlbmRlcmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckZpbGwoZmlsbFR5cGU6IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtgZmMtJHtmaWxsVHlwZX1gfSAvPlxuICApXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmdFdmVudFByb3BzIHtcbiAgc2VnOiBTZWdcbiAgaXNQYXN0OiBib29sZWFuXG4gIGlzRnV0dXJlOiBib29sZWFuXG4gIGlzVG9kYXk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IEJnRXZlbnQgPSAocHJvcHM6IEJnRXZlbnRQcm9wcykgPT4gKFxuICA8RXZlbnRSb290XG4gICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyQ29udGVudH1cbiAgICBzZWc9e3Byb3BzLnNlZyAvKiB1c2VsZXNzcyBpIHRoaW5rICovfVxuICAgIHRpbWVUZXh0PVwiXCJcbiAgICBkaXNhYmxlRHJhZ2dpbmdcbiAgICBkaXNhYmxlUmVzaXppbmdcbiAgICBpc0RyYWdnaW5nPXtmYWxzZX1cbiAgICBpc1Jlc2l6aW5nPXtmYWxzZX1cbiAgICBpc0RhdGVTZWxlY3Rpbmc9e2ZhbHNlfVxuICAgIGlzU2VsZWN0ZWQ9e2ZhbHNlfVxuICAgIGlzUGFzdD17cHJvcHMuaXNQYXN0fVxuICAgIGlzRnV0dXJlPXtwcm9wcy5pc0Z1dHVyZX1cbiAgICBpc1RvZGF5PXtwcm9wcy5pc1RvZGF5fVxuICA+XG4gICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKSA9PiAoXG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICBjbGFzc05hbWU9e1snZmMtYmctZXZlbnQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaG9va1Byb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgIDwvZGl2PlxuICAgICl9XG4gIDwvRXZlbnRSb290PlxuKVxuXG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHM6IEV2ZW50Q29udGVudEFyZykge1xuICBsZXQgeyB0aXRsZSB9ID0gcHJvcHMuZXZlbnRcblxuICByZXR1cm4gdGl0bGUgJiYgKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmMtZXZlbnQtdGl0bGVcIj57cHJvcHMuZXZlbnQudGl0bGV9PC9kaXY+XG4gIClcbn1cbiIsImltcG9ydCB7IFZpZXdDb250ZXh0LCBWaWV3Q29udGV4dFR5cGUgfSBmcm9tICcuLi9WaWV3Q29udGV4dCdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IFJlbmRlckhvb2ssIFJlbmRlckhvb2tQcm9wc0NoaWxkcmVuLCBNb3VudEFyZyB9IGZyb20gJy4vcmVuZGVyLWhvb2snXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAnLi4vdmRvbSdcbmltcG9ydCB7IERhdGVGb3JtYXR0ZXIgfSBmcm9tICcuLi9kYXRlbGliL0RhdGVGb3JtYXR0ZXInXG5cbmV4cG9ydCBpbnRlcmZhY2UgV2Vla051bWJlclJvb3RQcm9wcyB7XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZGVmYXVsdEZvcm1hdDogRGF0ZUZvcm1hdHRlclxuICBjaGlsZHJlbjogUmVuZGVySG9va1Byb3BzQ2hpbGRyZW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXZWVrTnVtYmVyQ29udGVudEFyZyB7XG4gIG51bTogbnVtYmVyXG4gIHRleHQ6IHN0cmluZ1xuICBkYXRlOiBEYXRlXG59XG5leHBvcnQgdHlwZSBXZWVrTnVtYmVyTW91bnRBcmcgPSBNb3VudEFyZzxXZWVrTnVtYmVyQ29udGVudEFyZz5cblxuZXhwb3J0IGNvbnN0IFdlZWtOdW1iZXJSb290ID0gKHByb3BzOiBXZWVrTnVtYmVyUm9vdFByb3BzKSA9PiAoXG4gIDxWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4gICAgeyhjb250ZXh0OiBWaWV3Q29udGV4dCkgPT4ge1xuICAgICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dFxuICAgICAgbGV0IHsgZGF0ZSB9ID0gcHJvcHNcbiAgICAgIGxldCBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdFxuICAgICAgbGV0IG51bSA9IGRhdGVFbnYuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZSkgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgZm9ybWF0KVxuICAgICAgbGV0IGhvb2tQcm9wczogV2Vla051bWJlckNvbnRlbnRBcmcgPSB7IG51bSwgdGV4dCwgZGF0ZSB9XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxSZW5kZXJIb29rPFdlZWtOdW1iZXJDb250ZW50QXJnPiAvLyB3aHkgaXNuJ3QgV2Vla051bWJlckNvbnRlbnRBcmcgYmVpbmcgYXV0by1kZXRlY3RlZD9cbiAgICAgICAgICBob29rUHJvcHM9e2hvb2tQcm9wc31cbiAgICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLndlZWtOdW1iZXJDbGFzc05hbWVzfVxuICAgICAgICAgIGNvbnRlbnQ9e29wdGlvbnMud2Vla051bWJlckNvbnRlbnR9XG4gICAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyfVxuICAgICAgICAgIGRpZE1vdW50PXtvcHRpb25zLndlZWtOdW1iZXJEaWRNb3VudH1cbiAgICAgICAgICB3aWxsVW5tb3VudD17b3B0aW9ucy53ZWVrTnVtYmVyV2lsbFVubW91bnR9XG4gICAgICAgID5cbiAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgIDwvUmVuZGVySG9vaz5cbiAgICAgIClcbiAgICB9fVxuICA8L1ZpZXdDb250ZXh0VHlwZS5Db25zdW1lcj5cbilcblxuZnVuY3Rpb24gcmVuZGVySW5uZXIoaW5uZXJQcm9wcykge1xuICByZXR1cm4gaW5uZXJQcm9wcy50ZXh0XG59XG4iLCJpbXBvcnQgeyBEaWN0aW9uYXJ5IH0gZnJvbSAnLi4vb3B0aW9ucydcbmltcG9ydCB7IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdCB9IGZyb20gJy4uL3V0aWwvZG9tLWdlb20nXG5pbXBvcnQgeyBhcHBseVN0eWxlLCBlbGVtZW50Q2xvc2VzdCwgZ2V0RXZlbnRUYXJnZXRWaWFSb290IH0gZnJvbSAnLi4vdXRpbC9kb20tbWFuaXAnXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBDb21wb25lbnRDaGlsZHJlbiwgUmVmLCBjcmVhdGVQb3J0YWwgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCwgc2V0UmVmIH0gZnJvbSAnLi4vdmRvbS11dGlsJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFBvcG92ZXJQcm9wcyB7XG4gIGVsUmVmPzogUmVmPEhUTUxFbGVtZW50PlxuICB0aXRsZTogc3RyaW5nXG4gIGV4dHJhQ2xhc3NOYW1lcz86IHN0cmluZ1tdXG4gIGV4dHJhQXR0cnM/OiBEaWN0aW9uYXJ5XG4gIHBhcmVudEVsOiBIVE1MRWxlbWVudFxuICBhbGlnbm1lbnRFbDogSFRNTEVsZW1lbnRcbiAgYWxpZ25HcmlkVG9wPzogYm9vbGVhblxuICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuXG4gIG9uQ2xvc2U/OiAoKSA9PiB2b2lkXG59XG5cbmNvbnN0IFBBRERJTkdfRlJPTV9WSUVXUE9SVCA9IDEwXG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxQb3BvdmVyUHJvcHM+IHtcbiAgcHJpdmF0ZSByb290RWw6IEhUTUxFbGVtZW50XG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHRoZW1lIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgJ2ZjLXBvcG92ZXInLFxuICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcbiAgICBdLmNvbmNhdChcbiAgICAgIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSxcbiAgICApXG5cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMuam9pbignICcpfSB7Li4ucHJvcHMuZXh0cmFBdHRyc30gcmVmPXt0aGlzLmhhbmRsZVJvb3RFbH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXsnZmMtcG9wb3Zlci1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJyl9PlxuICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZjLXBvcG92ZXItdGl0bGVcIj5cbiAgICAgICAgICAgIHtwcm9wcy50aXRsZX1cbiAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXsnZmMtcG9wb3Zlci1jbG9zZSAnICsgdGhlbWUuZ2V0SWNvbkNsYXNzKCdjbG9zZScpfSBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsb3NlQ2xpY2t9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J2ZjLXBvcG92ZXItYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50Jyl9PlxuICAgICAgICAgIHtwcm9wcy5jaGlsZHJlbn1cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj4sXG4gICAgICBwcm9wcy5wYXJlbnRFbCxcbiAgICApXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duKVxuICAgIHRoaXMudXBkYXRlU2l6ZSgpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duKVxuICB9XG5cbiAgaGFuZGxlUm9vdEVsID0gKGVsOiBIVE1MRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICB0aGlzLnJvb3RFbCA9IGVsXG5cbiAgICBpZiAodGhpcy5wcm9wcy5lbFJlZikge1xuICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyAqYW55d2hlcmUqIGluIHRoZSBkb2N1bWVudCwgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlXG4gIGhhbmRsZURvY3VtZW50TW91c2Vkb3duID0gKGV2KSA9PiB7XG4gICAgLy8gb25seSBoaWRlIHRoZSBwb3BvdmVyIGlmIHRoZSBjbGljayBoYXBwZW5lZCBvdXRzaWRlIHRoZSBwb3BvdmVyXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KSBhcyBIVE1MRWxlbWVudFxuICAgIGlmICghdGhpcy5yb290RWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDbG9zZUNsaWNrID0gKCkgPT4ge1xuICAgIGxldCB7IG9uQ2xvc2UgfSA9IHRoaXMucHJvcHNcbiAgICBpZiAob25DbG9zZSkge1xuICAgICAgb25DbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVTaXplKCkge1xuICAgIGxldCB7IGlzUnRsIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyBhbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzXG5cbiAgICBsZXQgYWxpZ25tZW50UmVjdCA9IGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChhbGlnbm1lbnRFbClcbiAgICBpZiAoYWxpZ25tZW50UmVjdCkge1xuICAgICAgbGV0IHBvcG92ZXJEaW1zID0gcm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gICAgICBsZXQgcG9wb3ZlclRvcCA9IGFsaWduR3JpZFRvcFxuICAgICAgICA/IGVsZW1lbnRDbG9zZXN0KGFsaWdubWVudEVsLCAnLmZjLXNjcm9sbGdyaWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgOiBhbGlnbm1lbnRSZWN0LnRvcFxuICAgICAgbGV0IHBvcG92ZXJMZWZ0ID0gaXNSdGwgPyBhbGlnbm1lbnRSZWN0LnJpZ2h0IC0gcG9wb3ZlckRpbXMud2lkdGggOiBhbGlnbm1lbnRSZWN0LmxlZnRcblxuICAgICAgLy8gY29uc3RyYWluXG4gICAgICBwb3BvdmVyVG9wID0gTWF0aC5tYXgocG9wb3ZlclRvcCwgUEFERElOR19GUk9NX1ZJRVdQT1JUKVxuICAgICAgcG9wb3ZlckxlZnQgPSBNYXRoLm1pbihwb3BvdmVyTGVmdCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC0gUEFERElOR19GUk9NX1ZJRVdQT1JUIC0gcG9wb3ZlckRpbXMud2lkdGgpXG4gICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWF4KHBvcG92ZXJMZWZ0LCBQQURESU5HX0ZST01fVklFV1BPUlQpXG5cbiAgICAgIGxldCBvcmlnaW4gPSByb290RWwub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBhcHBseVN0eWxlKHJvb3RFbCwge1xuICAgICAgICB0b3A6IHBvcG92ZXJUb3AgLSBvcmlnaW4udG9wLFxuICAgICAgICBsZWZ0OiBwb3BvdmVyTGVmdCAtIG9yaWdpbi5sZWZ0LFxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IERhdGVDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnQvRGF0ZUNvbXBvbmVudCdcbmltcG9ydCB7IERhdGVSYW5nZSB9IGZyb20gJy4uL2RhdGVsaWIvZGF0ZS1yYW5nZSdcbmltcG9ydCB7IERhdGVNYXJrZXIgfSBmcm9tICcuLi9kYXRlbGliL21hcmtlcidcbmltcG9ydCB7IERhdGVQcm9maWxlIH0gZnJvbSAnLi4vRGF0ZVByb2ZpbGVHZW5lcmF0b3InXG5pbXBvcnQgeyBIaXQgfSBmcm9tICcuLi9pbnRlcmFjdGlvbnMvaGl0J1xuaW1wb3J0IHsgRGljdGlvbmFyeSB9IGZyb20gJy4uL29wdGlvbnMnXG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBDb21wb25lbnRDaGlsZHJlbiB9IGZyb20gJy4uL3Zkb20nXG5pbXBvcnQgeyBEYXlDZWxsQ29udGVudCB9IGZyb20gJy4vRGF5Q2VsbENvbnRlbnQnXG5pbXBvcnQgeyBEYXlDZWxsUm9vdCB9IGZyb20gJy4vRGF5Q2VsbFJvb3QnXG5pbXBvcnQgeyBQb3BvdmVyIH0gZnJvbSAnLi9Qb3BvdmVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE1vcmVQb3BvdmVyUHJvcHMge1xuICBzdGFydERhdGU6IERhdGVNYXJrZXJcbiAgZW5kRGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgcGFyZW50RWw6IEhUTUxFbGVtZW50XG4gIGFsaWdubWVudEVsOiBIVE1MRWxlbWVudFxuICBhbGlnbkdyaWRUb3A/OiBib29sZWFuXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBleHRyYURhdGVTcGFuOiBEaWN0aW9uYXJ5XG4gIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlblxuICBvbkNsb3NlPzogKCkgPT4gdm9pZFxufVxuXG5leHBvcnQgY2xhc3MgTW9yZVBvcG92ZXIgZXh0ZW5kcyBEYXRlQ29tcG9uZW50PE1vcmVQb3BvdmVyUHJvcHM+IHtcbiAgcm9vdEVsOiBIVE1MRWxlbWVudFxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCB7IHN0YXJ0RGF0ZSwgdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzXG4gICAgbGV0IHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpXG4gICAgcmV0dXJuIChcbiAgICAgIDxEYXlDZWxsUm9vdCBkYXRlPXtzdGFydERhdGV9IGRhdGVQcm9maWxlPXtkYXRlUHJvZmlsZX0gdG9kYXlSYW5nZT17dG9kYXlSYW5nZX0gZWxSZWY9e3RoaXMuaGFuZGxlUm9vdEVsfT5cbiAgICAgICAgeyhyb290RWxSZWYsIGRheUNsYXNzTmFtZXMsIGRhdGFBdHRycykgPT4gKFxuICAgICAgICAgIDxQb3BvdmVyXG4gICAgICAgICAgICBlbFJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgdGl0bGU9e3RpdGxlfVxuICAgICAgICAgICAgZXh0cmFDbGFzc05hbWVzPXtbJ2ZjLW1vcmUtcG9wb3ZlciddLmNvbmNhdChkYXlDbGFzc05hbWVzKX1cbiAgICAgICAgICAgIGV4dHJhQXR0cnM9e2RhdGFBdHRycyAvKiBUT0RPOiBtYWtlIHRoZXNlIHRpbWUtYmFzZWQgd2hlbiBub3Qgd2hvbGUtZGF5PyAqL31cbiAgICAgICAgICAgIHBhcmVudEVsPXtwcm9wcy5wYXJlbnRFbH1cbiAgICAgICAgICAgIGFsaWdubWVudEVsPXtwcm9wcy5hbGlnbm1lbnRFbH1cbiAgICAgICAgICAgIGFsaWduR3JpZFRvcD17cHJvcHMuYWxpZ25HcmlkVG9wfVxuICAgICAgICAgICAgb25DbG9zZT17cHJvcHMub25DbG9zZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8RGF5Q2VsbENvbnRlbnQgZGF0ZT17c3RhcnREYXRlfSBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9IHRvZGF5UmFuZ2U9e3RvZGF5UmFuZ2V9PlxuICAgICAgICAgICAgICB7KGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgICAgICAgIGlubmVyQ29udGVudCAmJlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1tb3JlLXBvcG92ZXItbWlzY1wiIHJlZj17aW5uZXJFbFJlZn0+e2lubmVyQ29udGVudH08L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRGF5Q2VsbENvbnRlbnQ+XG4gICAgICAgICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgICAgICAgPC9Qb3BvdmVyPlxuICAgICAgICApfVxuICAgICAgPC9EYXlDZWxsUm9vdD5cbiAgICApXG4gIH1cblxuICBoYW5kbGVSb290RWwgPSAocm9vdEVsOiBIVE1MRGl2RWxlbWVudCB8IG51bGwpID0+IHtcbiAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbFxuICAgIGlmIChyb290RWwpIHtcbiAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIHF1ZXJ5SGl0KHBvc2l0aW9uTGVmdDogbnVtYmVyLCBwb3NpdGlvblRvcDogbnVtYmVyLCBlbFdpZHRoOiBudW1iZXIsIGVsSGVpZ2h0OiBudW1iZXIpOiBIaXQge1xuICAgIGxldCB7IHJvb3RFbCwgcHJvcHMgfSA9IHRoaXNcblxuICAgIGlmIChcbiAgICAgIHBvc2l0aW9uTGVmdCA+PSAwICYmIHBvc2l0aW9uTGVmdCA8IGVsV2lkdGggJiZcbiAgICAgIHBvc2l0aW9uVG9wID49IDAgJiYgcG9zaXRpb25Ub3AgPCBlbEhlaWdodFxuICAgICkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICBkYXRlU3Bhbjoge1xuICAgICAgICAgIGFsbERheTogdHJ1ZSxcbiAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLnN0YXJ0RGF0ZSxcbiAgICAgICAgICAgIGVuZDogcHJvcHMuZW5kRGF0ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLnByb3BzLmV4dHJhRGF0ZVNwYW4sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUVsOiByb290RWwsXG4gICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICByaWdodDogZWxXaWR0aCxcbiAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxuICAgICAgICB9LFxuICAgICAgICBsYXllcjogMSwgLy8gaW1wb3J0YW50IHdoZW4gY29tcGFyaW5nIHdpdGggaGl0cyBmcm9tIG90aGVyIGNvbXBvbmVudHNcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCJpbXBvcnQgeyBFdmVudEFwaSB9IGZyb20gJy4uL2FwaS9FdmVudEFwaSdcbmltcG9ydCB7IFNlZyB9IGZyb20gJy4uL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuaW1wb3J0IHsgRGF0ZVJhbmdlIH0gZnJvbSAnLi4vZGF0ZWxpYi9kYXRlLXJhbmdlJ1xuaW1wb3J0IHsgYWRkRGF5cywgRGF0ZU1hcmtlciB9IGZyb20gJy4uL2RhdGVsaWIvbWFya2VyJ1xuaW1wb3J0IHsgRGF0ZVByb2ZpbGUgfSBmcm9tICcuLi9EYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi9vcHRpb25zJ1xuaW1wb3J0IHsgZWxlbWVudENsb3Nlc3QgfSBmcm9tICcuLi91dGlsL2RvbS1tYW5pcCdcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVFbGVtZW50LCBjcmVhdGVSZWYsIEZyYWdtZW50LCBSZWYsIFJlZk9iamVjdCwgVk5vZGUgfSBmcm9tICcuLi92ZG9tJ1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJy4uL3Zkb20tdXRpbCdcbmltcG9ydCB7IFZpZXdBcGkgfSBmcm9tICcuLi9WaWV3QXBpJ1xuaW1wb3J0IHsgVmlld0NvbnRleHQsIFZpZXdDb250ZXh0VHlwZSB9IGZyb20gJy4uL1ZpZXdDb250ZXh0J1xuaW1wb3J0IHsgTW9yZVBvcG92ZXIgfSBmcm9tICcuL01vcmVQb3BvdmVyJ1xuaW1wb3J0IHsgTW91bnRBcmcsIFJlbmRlckhvb2sgfSBmcm9tICcuL3JlbmRlci1ob29rJ1xuXG5leHBvcnQgdHlwZSBNb3JlTGlua0NoaWxkcmVuID0gKFxuICByb290RWxSZWY6IFJlZjxhbnk+LFxuICBjbGFzc05hbWVzOiBzdHJpbmdbXSxcbiAgaW5uZXJFbFJlZjogUmVmPGFueT4sXG4gIGlubmVyQ29udGVudDogQ29tcG9uZW50Q2hpbGRyZW4sXG4gIGhhbmRsZUNsaWNrOiAoZXY6IE1vdXNlRXZlbnQpID0+IHZvaWQsXG4pID0+IENvbXBvbmVudENoaWxkcmVuXG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9yZUxpbmtSb290UHJvcHMgeyAvLyB3aGF0IHRoZSBNb3JlTGlua1Jvb3QgY29tcG9uZW50IHJlY2VpdmVzXG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgYWxsRGF5RGF0ZTogRGF0ZU1hcmtlciB8IG51bGxcbiAgbW9yZUNudDogbnVtYmVyIC8vIGNhbid0IGFsd2F5cyBkZXJpdmUgZnJvbSBoaWRkZW5TZWdzLiBzb21lIGhpZGRlblNlZ3MgbWlnaHQgYmUgZHVlIHRvIGxhY2sgb2YgZGltZW5zaW9uc1xuICBhbGxTZWdzOiBTZWdbXVxuICBoaWRkZW5TZWdzOiBTZWdbXVxuICBleHRyYURhdGVTcGFuPzogRGljdGlvbmFyeVxuICBhbGlnbm1lbnRFbFJlZjogUmVmT2JqZWN0PEhUTUxFbGVtZW50PiAvLyBmb3IgcG9wb3ZlclxuICBhbGlnbkdyaWRUb3A/OiBib29sZWFuIC8vIGZvciBwb3BvdmVyXG4gIHRvcEFsaWdubWVudEVsUmVmPzogUmVmT2JqZWN0PEhUTUxFbGVtZW50PlxuICBkZWZhdWx0Q29udGVudD86IChob29rUHJvcHM6IE1vcmVMaW5rQ29udGVudEFyZykgPT4gQ29tcG9uZW50Q2hpbGRyZW5cbiAgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IFZOb2RlXG4gIGNoaWxkcmVuOiBNb3JlTGlua0NoaWxkcmVuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9yZUxpbmtDb250ZW50QXJnIHsgLy8gd2hhdCB0aGUgcmVuZGVyLWhvb2tzIHJlY2VpdmVcbiAgbnVtOiBudW1iZXJcbiAgdGV4dDogc3RyaW5nXG4gIHNob3J0VGV4dDogc3RyaW5nXG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuZXhwb3J0IHR5cGUgTW9yZUxpbmtNb3VudEFyZyA9IE1vdW50QXJnPE1vcmVMaW5rQ29udGVudEFyZz5cblxuaW50ZXJmYWNlIE1vcmVMaW5rUm9vdFN0YXRlIHtcbiAgaXNQb3BvdmVyT3BlbjogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgTW9yZUxpbmtSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxNb3JlTGlua1Jvb3RQcm9wcywgTW9yZUxpbmtSb290U3RhdGU+IHtcbiAgcHJpdmF0ZSBsaW5rRWxSZWYgPSBjcmVhdGVSZWY8SFRNTEVsZW1lbnQ+KClcbiAgcHJpdmF0ZSBwYXJlbnRFbDogSFRNTEVsZW1lbnRcblxuICBzdGF0ZSA9IHtcbiAgICBpc1BvcG92ZXJPcGVuOiBmYWxzZSxcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIHJldHVybiAoXG4gICAgICA8Vmlld0NvbnRleHRUeXBlLkNvbnN1bWVyPlxuICAgICAgICB7KGNvbnRleHQ6IFZpZXdDb250ZXh0KSA9PiB7XG4gICAgICAgICAgbGV0IHsgdmlld0FwaSwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHRcbiAgICAgICAgICBsZXQgeyBtb3JlTGlua1RleHQgfSA9IG9wdGlvbnNcbiAgICAgICAgICBsZXQgeyBtb3JlQ250IH0gPSBwcm9wc1xuICAgICAgICAgIGxldCByYW5nZSA9IGNvbXB1dGVSYW5nZShwcm9wcylcblxuICAgICAgICAgIGxldCBob29rUHJvcHM6IE1vcmVMaW5rQ29udGVudEFyZyA9IHtcbiAgICAgICAgICAgIG51bTogbW9yZUNudCxcbiAgICAgICAgICAgIHNob3J0VGV4dDogYCske21vcmVDbnR9YCwgLy8gVE9ETzogb2ZmZXIgaG9vayBvciBpMThuP1xuICAgICAgICAgICAgdGV4dDogdHlwZW9mIG1vcmVMaW5rVGV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICA/IG1vcmVMaW5rVGV4dC5jYWxsKGNhbGVuZGFyQXBpLCBtb3JlQ250KVxuICAgICAgICAgICAgICA6IGArJHttb3JlQ250fSAke21vcmVMaW5rVGV4dH1gLFxuICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgICB7Qm9vbGVhbihwcm9wcy5tb3JlQ250KSAmJiAoXG4gICAgICAgICAgICAgICAgPFJlbmRlckhvb2s8TW9yZUxpbmtDb250ZW50QXJnPlxuICAgICAgICAgICAgICAgICAgZWxSZWY9e3RoaXMubGlua0VsUmVmfVxuICAgICAgICAgICAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lc31cbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ9e29wdGlvbnMubW9yZUxpbmtDb250ZW50fVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3Byb3BzLmRlZmF1bHRDb250ZW50IHx8IHJlbmRlck1vcmVMaW5rSW5uZXJ9XG4gICAgICAgICAgICAgICAgICBkaWRNb3VudD17b3B0aW9ucy5tb3JlTGlua0RpZE1vdW50fVxuICAgICAgICAgICAgICAgICAgd2lsbFVubW91bnQ9e29wdGlvbnMubW9yZUxpbmtXaWxsVW5tb3VudH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7KHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiBwcm9wcy5jaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsUmVmLCBbJ2ZjLW1vcmUtbGluayddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCB0aGlzLmhhbmRsZUNsaWNrLFxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L1JlbmRlckhvb2s+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIHt0aGlzLnN0YXRlLmlzUG9wb3Zlck9wZW4gJiYgKFxuICAgICAgICAgICAgICAgIDxNb3JlUG9wb3ZlclxuICAgICAgICAgICAgICAgICAgc3RhcnREYXRlPXtyYW5nZS5zdGFydH1cbiAgICAgICAgICAgICAgICAgIGVuZERhdGU9e3JhbmdlLmVuZH1cbiAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlPXtwcm9wcy5kYXRlUHJvZmlsZX1cbiAgICAgICAgICAgICAgICAgIHRvZGF5UmFuZ2U9e3Byb3BzLnRvZGF5UmFuZ2V9XG4gICAgICAgICAgICAgICAgICBleHRyYURhdGVTcGFuPXtwcm9wcy5leHRyYURhdGVTcGFufVxuICAgICAgICAgICAgICAgICAgcGFyZW50RWw9e3RoaXMucGFyZW50RWx9XG4gICAgICAgICAgICAgICAgICBhbGlnbm1lbnRFbD17cHJvcHMuYWxpZ25tZW50RWxSZWYuY3VycmVudH1cbiAgICAgICAgICAgICAgICAgIGFsaWduR3JpZFRvcD17cHJvcHMuYWxpZ25HcmlkVG9wfVxuICAgICAgICAgICAgICAgICAgb25DbG9zZT17dGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2V9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3Byb3BzLnBvcG92ZXJDb250ZW50KCl9XG4gICAgICAgICAgICAgICAgPC9Nb3JlUG9wb3Zlcj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9WaWV3Q29udGV4dFR5cGUuQ29uc3VtZXI+XG4gICAgKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpXG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpXG4gIH1cblxuICB1cGRhdGVQYXJlbnRFbCgpIHtcbiAgICBpZiAodGhpcy5saW5rRWxSZWYuY3VycmVudCkge1xuICAgICAgdGhpcy5wYXJlbnRFbCA9IGVsZW1lbnRDbG9zZXN0KHRoaXMubGlua0VsUmVmLmN1cnJlbnQsICcuZmMtdmlldy1oYXJuZXNzJylcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDbGljayA9IChldjogTW91c2VFdmVudCkgPT4ge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgbW9yZUxpbmtDbGljayB9ID0gY29udGV4dC5vcHRpb25zXG4gICAgbGV0IGRhdGUgPSBjb21wdXRlUmFuZ2UocHJvcHMpLnN0YXJ0XG5cbiAgICBmdW5jdGlvbiBidWlsZFB1YmxpY1NlZyhzZWc6IFNlZykge1xuICAgICAgbGV0IHsgZGVmLCBpbnN0YW5jZSwgcmFuZ2UgfSA9IHNlZy5ldmVudFJhbmdlXG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICBzdGFydDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogY29udGV4dC5kYXRlRW52LnRvRGF0ZShyYW5nZS5lbmQpLFxuICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCxcbiAgICAgICAgaXNFbmQ6IHNlZy5pc0VuZCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxuICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgIH0pIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiB0cnVlIH0pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcbiAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuem9vbVRvKGRhdGUsIG1vcmVMaW5rQ2xpY2spXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUG9wb3ZlckNsb3NlID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHM6IE1vcmVMaW5rQ29udGVudEFyZykge1xuICByZXR1cm4gcHJvcHMudGV4dFxufVxuXG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHM6IE1vcmVMaW5rUm9vdFByb3BzKTogRGF0ZVJhbmdlIHtcbiAgaWYgKHByb3BzLmFsbERheURhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgfVxuICB9XG5cbiAgbGV0IHsgaGlkZGVuU2VncyB9ID0gcHJvcHNcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXG4gICAgZW5kOiBjb21wdXRlTGF0ZXN0U2VnRW5kKGhpZGRlblNlZ3MpLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRWFybGllc3RTZWdTdGFydChzZWdzOiBTZWdbXSk6IERhdGVNYXJrZXIge1xuICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0VhcmxpZXN0U3RhcnQpLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnRcbn1cblxuZnVuY3Rpb24gcGlja0VhcmxpZXN0U3RhcnQoc2VnMDogU2VnLCBzZWcxOiBTZWcpOiBTZWcge1xuICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzFcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUxhdGVzdFNlZ0VuZChzZWdzOiBTZWdbXSk6IERhdGVNYXJrZXIge1xuICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmRcbn1cblxuZnVuY3Rpb24gcGlja0xhdGVzdEVuZChzZWcwOiBTZWcsIHNlZzE6IFNlZyk6IFNlZyB7XG4gIHJldHVybiBzZWcwLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID4gc2VnMS5ldmVudFJhbmdlLnJhbmdlLmVuZCA/IHNlZzAgOiBzZWcxXG59XG4iLCJpbXBvcnQgJy4vbWFpbi5jc3MnXG5cbi8vIGV4cG9ydHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uOiBzdHJpbmcgPSAnPCU9IHZlcnNpb24gJT4nIC8vIGltcG9ydGFudCB0byB0eXBlIGl0LCBzbyAuZC50cyBoYXMgZ2VuZXJpYyBzdHJpbmdcblxuLy8gZXhwbGljaXQgQVBJXG5leHBvcnQgeyBFdmVudFNvdXJjZUFwaSB9IGZyb20gJy4vYXBpL0V2ZW50U291cmNlQXBpJ1xuZXhwb3J0IHsgRXZlbnRBcGksIGJ1aWxkRXZlbnRBcGlzIH0gZnJvbSAnLi9hcGkvRXZlbnRBcGknXG5leHBvcnQgeyBDYWxlbmRhckFwaSB9IGZyb20gJy4vQ2FsZW5kYXJBcGknXG5leHBvcnQgeyBmb3JtYXREYXRlLCBmb3JtYXRSYW5nZSwgRm9ybWF0RGF0ZU9wdGlvbnMsIEZvcm1hdFJhbmdlT3B0aW9ucyB9IGZyb20gJy4vZm9ybWF0dGluZy1hcGknXG5leHBvcnQgeyBWaWV3QXBpIH0gZnJvbSAnLi9WaWV3QXBpJ1xuZXhwb3J0ICogZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgeyAvLyB0aGluZ3MgZm9yIHBsdWdpbnMuIGV2ZXJ5dGhpbmcgZWxzZSBpcyBleHBvcnRlZCBpbiBhcGktdHlwZS1kZXBzXG4gIEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBCQVNFX09QVElPTl9SRUZJTkVSUywgaWRlbnRpdHksIElkZW50aXR5LCBEaWN0aW9uYXJ5LCByZWZpbmVQcm9wcyxcbiAgQmFzZU9wdGlvblJlZmluZXJzLCBCYXNlT3B0aW9uc1JlZmluZWQsIENhbGVuZGFyT3B0aW9uUmVmaW5lcnMsIENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gIFZpZXdPcHRpb25SZWZpbmVycywgVmlld09wdGlvbnNSZWZpbmVkLCBSYXdPcHRpb25zRnJvbVJlZmluZXJzLCBSZWZpbmVkT3B0aW9uc0Zyb21SZWZpbmVycyxcbiAgQ2FsZW5kYXJMaXN0ZW5lclJlZmluZXJzLFxufSBmcm9tICcuL29wdGlvbnMnXG5cbmV4cG9ydCB7IEV2ZW50RGVmLCBFdmVudERlZkhhc2ggfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtZGVmJ1xuZXhwb3J0IHsgRXZlbnRJbnN0YW5jZSwgRXZlbnRJbnN0YW5jZUhhc2gsIGNyZWF0ZUV2ZW50SW5zdGFuY2UgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtaW5zdGFuY2UnXG5leHBvcnQgeyBFdmVudElucHV0LCBFdmVudFJlZmluZWQsIHBhcnNlRXZlbnREZWYsIEV2ZW50VHVwbGUsIEV2ZW50UmVmaW5lcnMsIHJlZmluZUV2ZW50RGVmIH0gZnJvbSAnLi9zdHJ1Y3RzL2V2ZW50LXBhcnNlJ1xuZXhwb3J0IHsgQnVzaW5lc3NIb3Vyc0lucHV0LCBwYXJzZUJ1c2luZXNzSG91cnMgfSBmcm9tICcuL3N0cnVjdHMvYnVzaW5lc3MtaG91cnMnXG5cbmV4cG9ydCB7XG4gIHBhZFN0YXJ0LFxuICBpc0ludCxcbiAgcGFyc2VGaWVsZFNwZWNzLFxuICBjb21wYXJlQnlGaWVsZFNwZWNzLFxuICBjb21wYXJlQnlGaWVsZFNwZWMsXG4gIGZsZXhpYmxlQ29tcGFyZSxcbiAgcHJldmVudFNlbGVjdGlvbiwgYWxsb3dTZWxlY3Rpb24sIHByZXZlbnRDb250ZXh0TWVudSwgYWxsb3dDb250ZXh0TWVudSxcbiAgY29tcGFyZU51bWJlcnMsIGVuYWJsZUN1cnNvciwgZGlzYWJsZUN1cnNvcixcbiAgZ3VpZCxcbiAgY29tcHV0ZVNtYWxsZXN0Q2VsbFdpZHRoLFxuICBPcmRlclNwZWMsXG59IGZyb20gJy4vdXRpbC9taXNjJ1xuXG5leHBvcnQge1xuICBjb21wdXRlVmlzaWJsZURheVJhbmdlLFxuICBpc011bHRpRGF5UmFuZ2UsXG4gIGRpZmZEYXRlcyxcbn0gZnJvbSAnLi91dGlsL2RhdGUnXG5cbmV4cG9ydCB7XG4gIHJlbW92ZUV4YWN0LFxuICBpc0FycmF5c0VxdWFsLFxufSBmcm9tICcuL3V0aWwvYXJyYXknXG5cbmV4cG9ydCB7IG1lbW9pemUsIG1lbW9pemVPYmpBcmcsIG1lbW9pemVBcnJheWxpa2UsIG1lbW9pemVIYXNobGlrZSB9IGZyb20gJy4vdXRpbC9tZW1vaXplJ1xuXG5leHBvcnQge1xuICBpbnRlcnNlY3RSZWN0cyxcbiAgUmVjdCwgcG9pbnRJbnNpZGVSZWN0LFxuICBjb25zdHJhaW5Qb2ludCxcbiAgZ2V0UmVjdENlbnRlciwgZGlmZlBvaW50cywgUG9pbnQsXG4gIHRyYW5zbGF0ZVJlY3QsXG59IGZyb20gJy4vdXRpbC9nZW9tJ1xuXG5leHBvcnQgeyBtYXBIYXNoLCBmaWx0ZXJIYXNoLCBpc1Byb3BzRXF1YWwsIGNvbXBhcmVPYmpzLCBidWlsZEhhc2hGcm9tQXJyYXksIGNvbGxlY3RGcm9tSGFzaCwgZ2V0VW5lcXVhbFByb3BzIH0gZnJvbSAnLi91dGlsL29iamVjdCdcblxuZXhwb3J0IHtcbiAgZmluZEVsZW1lbnRzLFxuICBmaW5kRGlyZWN0Q2hpbGRyZW4sXG4gIHJlbW92ZUVsZW1lbnQsXG4gIGFwcGx5U3R5bGUsXG4gIGFwcGx5U3R5bGVQcm9wLFxuICBlbGVtZW50TWF0Y2hlcyxcbiAgZWxlbWVudENsb3Nlc3QsXG4gIGdldEVsUm9vdCxcbiAgZ2V0RXZlbnRUYXJnZXRWaWFSb290LFxufSBmcm9tICcuL3V0aWwvZG9tLW1hbmlwJ1xuZXhwb3J0IHsgcGFyc2VDbGFzc05hbWVzIH0gZnJvbSAnLi91dGlsL2h0bWwnXG5cbmV4cG9ydCB7IGdldENhblZHcm93V2l0aGluQ2VsbCB9IGZyb20gJy4vdXRpbC90YWJsZS1zdHlsaW5nJ1xuXG5leHBvcnQge1xuICBFdmVudFN0b3JlLFxuICBmaWx0ZXJFdmVudFN0b3JlRGVmcyxcbiAgY3JlYXRlRW1wdHlFdmVudFN0b3JlLFxuICBtZXJnZUV2ZW50U3RvcmVzLFxuICBnZXRSZWxldmFudEV2ZW50cyxcbiAgZXZlbnRUdXBsZVRvU3RvcmUsXG59IGZyb20gJy4vc3RydWN0cy9ldmVudC1zdG9yZSdcbmV4cG9ydCB7IEV2ZW50VWlIYXNoLCBFdmVudFVpLCBjb21iaW5lRXZlbnRVaXMsIGNyZWF0ZUV2ZW50VWkgfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC11aSdcbmV4cG9ydCB7IFNwbGl0dGVyLCBTcGxpdHRhYmxlUHJvcHMgfSBmcm9tICcuL2NvbXBvbmVudC9ldmVudC1zcGxpdHRpbmcnXG5leHBvcnQgeyBnZXREYXlDbGFzc05hbWVzLCBnZXREYXRlTWV0YSwgRGF0ZU1ldGEsIGdldFNsb3RDbGFzc05hbWVzIH0gZnJvbSAnLi9jb21wb25lbnQvZGF0ZS1yZW5kZXJpbmcnXG5leHBvcnQgeyBidWlsZE5hdkxpbmtEYXRhIH0gZnJvbSAnLi9jb21tb24vbmF2LWxpbmsnXG5cbmV4cG9ydCB7XG4gIHByZXZlbnREZWZhdWx0LFxuICBsaXN0ZW5CeVNlbGVjdG9yLFxuICB3aGVuVHJhbnNpdGlvbkRvbmUsXG59IGZyb20gJy4vdXRpbC9kb20tZXZlbnQnXG5cbmV4cG9ydCB7XG4gIGNvbXB1dGVJbm5lclJlY3QsXG4gIGNvbXB1dGVFZGdlcyxcbiAgY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMsXG4gIGdldENsaXBwaW5nUGFyZW50cyxcbiAgY29tcHV0ZVJlY3QsXG59IGZyb20gJy4vdXRpbC9kb20tZ2VvbSdcblxuZXhwb3J0IHsgdW5wcm9taXNpZnkgfSBmcm9tICcuL3V0aWwvcHJvbWlzZSdcblxuZXhwb3J0IHsgRW1pdHRlciB9IGZyb20gJy4vY29tbW9uL0VtaXR0ZXInXG5leHBvcnQgeyBEYXRlUmFuZ2UsIHJhbmdlQ29udGFpbnNNYXJrZXIsIGludGVyc2VjdFJhbmdlcywgcmFuZ2VzRXF1YWwsIHJhbmdlc0ludGVyc2VjdCwgcmFuZ2VDb250YWluc1JhbmdlIH0gZnJvbSAnLi9kYXRlbGliL2RhdGUtcmFuZ2UnXG5leHBvcnQgeyBQb3NpdGlvbkNhY2hlIH0gZnJvbSAnLi9jb21tb24vUG9zaXRpb25DYWNoZSdcbmV4cG9ydCB7IFNjcm9sbENvbnRyb2xsZXIsIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLCBXaW5kb3dTY3JvbGxDb250cm9sbGVyIH0gZnJvbSAnLi9jb21tb24vc2Nyb2xsLWNvbnRyb2xsZXInXG5leHBvcnQgeyBUaGVtZSB9IGZyb20gJy4vdGhlbWUvVGhlbWUnXG5leHBvcnQgeyBWaWV3Q29udGV4dCwgVmlld0NvbnRleHRUeXBlIH0gZnJvbSAnLi9WaWV3Q29udGV4dCdcbmV4cG9ydCB7IERhdGVDb21wb25lbnQsIFNlZywgRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfSBmcm9tICcuL2NvbXBvbmVudC9EYXRlQ29tcG9uZW50J1xuZXhwb3J0IHsgQ2FsZW5kYXJEYXRhIH0gZnJvbSAnLi9yZWR1Y2Vycy9kYXRhLXR5cGVzJ1xuZXhwb3J0IHsgQ2FsZW5kYXJEYXRhTWFuYWdlciB9IGZyb20gJy4vcmVkdWNlcnMvQ2FsZW5kYXJEYXRhTWFuYWdlcidcbmV4cG9ydCB7IENhbGVuZGFyRGF0YVByb3ZpZGVyLCBDYWxlbmRhckRhdGFQcm92aWRlclByb3BzIH0gZnJvbSAnLi9jb21wb25lbnQvQ2FsZW5kYXJEYXRhUHJvdmlkZXInXG5leHBvcnQgeyBWaWV3UHJvcHMsIHNsaWNlRXZlbnRzIH0gZnJvbSAnLi9WaWV3J1xuXG5leHBvcnQgeyBEYXRlUHJvZmlsZUdlbmVyYXRvciwgRGF0ZVByb2ZpbGUgfSBmcm9tICcuL0RhdGVQcm9maWxlR2VuZXJhdG9yJ1xuZXhwb3J0IHsgVmlld0RlZiB9IGZyb20gJy4vc3RydWN0cy92aWV3LWRlZidcbmV4cG9ydCB7IFZpZXdTcGVjIH0gZnJvbSAnLi9zdHJ1Y3RzL3ZpZXctc3BlYydcbmV4cG9ydCB7IERhdGVTcGFuLCBEYXRlU3BhbkFwaSwgRGF0ZVBvaW50QXBpLCBpc0RhdGVTcGFuc0VxdWFsIH0gZnJvbSAnLi9zdHJ1Y3RzL2RhdGUtc3BhbidcblxuZXhwb3J0IHtcbiAgRGF0ZU1hcmtlcixcbiAgYWRkRGF5cyxcbiAgc3RhcnRPZkRheSxcbiAgYWRkTXMsXG4gIGFkZFdlZWtzLFxuICBkaWZmV2Vla3MsXG4gIGRpZmZXaG9sZVdlZWtzLFxuICBkaWZmV2hvbGVEYXlzLFxuICBkaWZmRGF5QW5kVGltZSxcbiAgZGlmZkRheXMsXG4gIGlzVmFsaWREYXRlLFxufSBmcm9tICcuL2RhdGVsaWIvbWFya2VyJ1xuZXhwb3J0IHtcbiAgRHVyYXRpb24sIGNyZWF0ZUR1cmF0aW9uLFxuICBhc0NsZWFuRGF5cywgbXVsdGlwbHlEdXJhdGlvbiwgYWRkRHVyYXRpb25zLFxuICBhc1JvdWdoTWludXRlcywgYXNSb3VnaFNlY29uZHMsIGFzUm91Z2hNcyxcbiAgd2hvbGVEaXZpZGVEdXJhdGlvbnMsIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcixcbn0gZnJvbSAnLi9kYXRlbGliL2R1cmF0aW9uJ1xuZXhwb3J0IHsgRGF0ZUVudiwgRGF0ZU1hcmtlck1ldGEgfSBmcm9tICcuL2RhdGVsaWIvZW52J1xuXG5leHBvcnQge1xuICBjcmVhdGVGb3JtYXR0ZXIsXG4gIEZvcm1hdHRlcklucHV0LFxufSBmcm9tICcuL2RhdGVsaWIvZm9ybWF0dGluZydcbmV4cG9ydCB7XG4gIERhdGVGb3JtYXR0ZXIsXG4gIFZlcmJvc2VGb3JtYXR0aW5nQXJnLFxufSBmcm9tICcuL2RhdGVsaWIvRGF0ZUZvcm1hdHRlcidcbmV4cG9ydCB7XG4gIGZvcm1hdElzb1RpbWVTdHJpbmcsXG4gIGZvcm1hdERheVN0cmluZyxcbiAgYnVpbGRJc29TdHJpbmcsXG59IGZyb20gJy4vZGF0ZWxpYi9mb3JtYXR0aW5nLXV0aWxzJ1xuZXhwb3J0IHsgTmFtZWRUaW1lWm9uZUltcGwgfSBmcm9tICcuL2RhdGVsaWIvdGltZXpvbmUnXG5leHBvcnQgeyBwYXJzZSBhcyBwYXJzZU1hcmtlciB9IGZyb20gJy4vZGF0ZWxpYi9wYXJzaW5nJ1xuZXhwb3J0IHsgTG9jYWxlSW5wdXQgfSBmcm9tICcuL2RhdGVsaWIvbG9jYWxlJ1xuXG5leHBvcnQgeyBFdmVudFNvdXJjZURlZiB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UtZGVmJ1xuZXhwb3J0IHsgRXZlbnRTb3VyY2UsIEV2ZW50U291cmNlSGFzaCB9IGZyb20gJy4vc3RydWN0cy9ldmVudC1zb3VyY2UnXG5leHBvcnQgeyBFdmVudFNvdXJjZVJlZmluZXJzLCBFdmVudFNvdXJjZVJlZmluZWQgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtc291cmNlLXBhcnNlJ1xuXG5leHBvcnQge1xuICBTZWdTcGFuLCBTZWdSZWN0LCBTZWdIaWVyYXJjaHksIFNlZ0VudHJ5LCBTZWdJbnNlcnRpb24sIGJ1aWxkRW50cnlLZXksXG4gIGdldEVudHJ5U3BhbkVuZCwgYmluYXJ5U2VhcmNoLCBTZWdFbnRyeUdyb3VwLCBncm91cEludGVyc2VjdGluZ0VudHJpZXMsXG4gIGpvaW5TcGFucywgaW50ZXJzZWN0U3BhbnMsXG59IGZyb20gJy4vc2VnLWhpZXJhcmNoeSdcblxuZXhwb3J0IHtcbiAgSW50ZXJhY3Rpb24sXG4gIEludGVyYWN0aW9uU2V0dGluZ3MsXG4gIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLFxuICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXG4gIEludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSxcbn0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24nXG5leHBvcnQgeyBQb2ludGVyRHJhZ0V2ZW50IH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvcG9pbnRlcidcbmV4cG9ydCB7IEhpdCB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2hpdCdcbmV4cG9ydCB7IGRhdGVTZWxlY3Rpb25Kb2luVHJhbnNmb3JtZXIgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9kYXRlLXNlbGVjdGluZydcbmV4cG9ydCB7IGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXIsIEV2ZW50RHJvcFRyYW5zZm9ybWVycyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWRyYWdnaW5nJ1xuZXhwb3J0IHsgRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvRWxlbWVudERyYWdnaW5nJ1xuXG5leHBvcnQgeyBjb25maWcgfSBmcm9tICcuL2dsb2JhbC1jb25maWcnXG5leHBvcnQgeyBnbG9iYWxMb2NhbGVzIH0gZnJvbSAnLi9nbG9iYWwtbG9jYWxlcydcblxuZXhwb3J0IHsgUmVjdXJyaW5nVHlwZSwgUGFyc2VkUmVjdXJyaW5nIH0gZnJvbSAnLi9zdHJ1Y3RzL3JlY3VycmluZy1ldmVudCdcblxuZXhwb3J0IHsgRHJhZ01ldGFJbnB1dCwgRHJhZ01ldGEsIHBhcnNlRHJhZ01ldGEgfSBmcm9tICcuL3N0cnVjdHMvZHJhZy1tZXRhJ1xuXG5leHBvcnQgeyBQbHVnaW5EZWYsIFBsdWdpbkRlZklucHV0LCBWaWV3UHJvcHNUcmFuc2Zvcm1lciwgVmlld0NvbnRhaW5lckFwcGVuZCB9IGZyb20gJy4vcGx1Z2luLXN5c3RlbS1zdHJ1Y3QnXG5leHBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICcuL3BsdWdpbi1zeXN0ZW0nXG5leHBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL3JlZHVjZXJzL0FjdGlvbidcbmV4cG9ydCB7IENhbGVuZGFyQ29udGV4dCB9IGZyb20gJy4vQ2FsZW5kYXJDb250ZXh0J1xuZXhwb3J0IHsgQ2FsZW5kYXJDb250ZW50UHJvcHMsIENhbGVuZGFyQ29udGVudCB9IGZyb20gJy4vQ2FsZW5kYXJDb250ZW50J1xuZXhwb3J0IHsgQ2FsZW5kYXJSb290IH0gZnJvbSAnLi9DYWxlbmRhclJvb3QnXG5cbmV4cG9ydCB7IERheUhlYWRlciB9IGZyb20gJy4vY29tbW9uL0RheUhlYWRlcidcbmV4cG9ydCB7IGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCB9IGZyb20gJy4vY29tbW9uL3RhYmxlLXV0aWxzJ1xuZXhwb3J0IHsgVGFibGVEYXRlQ2VsbCB9IGZyb20gJy4vY29tbW9uL1RhYmxlRGF0ZUNlbGwnXG5leHBvcnQgeyBUYWJsZURvd0NlbGwgfSBmcm9tICcuL2NvbW1vbi9UYWJsZURvd0NlbGwnXG5cbmV4cG9ydCB7IERheVNlcmllc01vZGVsIH0gZnJvbSAnLi9jb21tb24vRGF5U2VyaWVzTW9kZWwnXG5cbmV4cG9ydCB7IEV2ZW50SW50ZXJhY3Rpb25TdGF0ZSB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL2V2ZW50LWludGVyYWN0aW9uLXN0YXRlJ1xuZXhwb3J0IHtcbiAgRXZlbnRSZW5kZXJSYW5nZSwgc2xpY2VFdmVudFN0b3JlLCBoYXNCZ1JlbmRlcmluZywgc2V0RWxTZWcsIGdldEVsU2VnLFxuICBjb21wdXRlU2VnRHJhZ2dhYmxlLCBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUsIGNvbXB1dGVTZWdFbmRSZXNpemFibGUsXG4gIGdldEV2ZW50Q2xhc3NOYW1lcywgYnVpbGRTZWdUaW1lVGV4dCxcbiAgYnVpbGRTZWdDb21wYXJlT2JqLCBzb3J0RXZlbnRTZWdzLFxuICBnZXRTZWdNZXRhLCBFdmVudENvbnRlbnRBcmcsIGJ1aWxkRXZlbnRSYW5nZUtleSxcbn0gZnJvbSAnLi9jb21wb25lbnQvZXZlbnQtcmVuZGVyaW5nJ1xuXG5leHBvcnQgeyBEYXlUYWJsZU1vZGVsLCBEYXlUYWJsZVNlZywgRGF5VGFibGVDZWxsIH0gZnJvbSAnLi9jb21tb24vRGF5VGFibGVNb2RlbCdcblxuZXhwb3J0IHsgU2xpY2VyLCBTbGljZWRQcm9wcyB9IGZyb20gJy4vY29tbW9uL3NsaWNpbmctdXRpbHMnXG5cbmV4cG9ydCB7IEV2ZW50TXV0YXRpb24sIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgfSBmcm9tICcuL3N0cnVjdHMvZXZlbnQtbXV0YXRpb24nXG5leHBvcnQgeyBDb25zdHJhaW50LCBDb25zdHJhaW50SW5wdXQsIEFsbG93RnVuYyB9IGZyb20gJy4vc3RydWN0cy9jb25zdHJhaW50J1xuZXhwb3J0IHsgaXNQcm9wc1ZhbGlkLCBpc0ludGVyYWN0aW9uVmFsaWQsIGlzRGF0ZVNlbGVjdGlvblZhbGlkIH0gZnJvbSAnLi92YWxpZGF0aW9uJ1xuXG5leHBvcnQgeyByZXF1ZXN0SnNvbiB9IGZyb20gJy4vdXRpbC9yZXF1ZXN0SnNvbidcblxuZXhwb3J0ICogZnJvbSAnLi92ZG9tJ1xuZXhwb3J0IHsgQmFzZUNvbXBvbmVudCwgc2V0UmVmIH0gZnJvbSAnLi92ZG9tLXV0aWwnXG5leHBvcnQgeyBEZWxheWVkUnVubmVyIH0gZnJvbSAnLi91dGlsL0RlbGF5ZWRSdW5uZXInXG5cbmV4cG9ydCB7XG4gIFNjcm9sbEdyaWRQcm9wcyxcbiAgU2Nyb2xsR3JpZFNlY3Rpb25Db25maWcsXG4gIENvbEdyb3VwQ29uZmlnLFxuICBTY3JvbGxHcmlkSW1wbCxcbiAgU2Nyb2xsR3JpZENodW5rQ29uZmlnLFxufSBmcm9tICcuL3Njcm9sbGdyaWQvU2Nyb2xsR3JpZEltcGwnXG5leHBvcnQgeyBTaW1wbGVTY3JvbGxHcmlkLCBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbiB9IGZyb20gJy4vc2Nyb2xsZ3JpZC9TaW1wbGVTY3JvbGxHcmlkJ1xuZXhwb3J0IHtcbiAgQ3NzRGltVmFsdWUsIFNjcm9sbGVyTGlrZSwgU2VjdGlvbkNvbmZpZywgQ29sUHJvcHMsIENodW5rQ29uZmlnLCBoYXNTaHJpbmtXaWR0aCwgcmVuZGVyTWljcm9Db2xHcm91cCxcbiAgZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMsIGdldFNlY3Rpb25DbGFzc05hbWVzLCBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0LCBnZXRBbGxvd1lTY3JvbGxpbmcsIHJlbmRlckNodW5rQ29udGVudCwgY29tcHV0ZVNocmlua1dpZHRoLFxuICBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MsXG4gIHNhbml0aXplU2hyaW5rV2lkdGgsXG4gIENodW5rQ29uZmlnUm93Q29udGVudCwgQ2h1bmtDb25maWdDb250ZW50LFxuICBpc0NvbFByb3BzRXF1YWwsXG4gIHJlbmRlclNjcm9sbFNoaW0sXG4gIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcixcbiAgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsXG59IGZyb20gJy4vc2Nyb2xsZ3JpZC91dGlsJ1xuZXhwb3J0IHsgU2Nyb2xsZXIsIFNjcm9sbGVyUHJvcHMsIE92ZXJmbG93VmFsdWUgfSBmcm9tICcuL3Njcm9sbGdyaWQvU2Nyb2xsZXInXG5leHBvcnQgeyBnZXRTY3JvbGxiYXJXaWR0aHMgfSBmcm9tICcuL3V0aWwvc2Nyb2xsYmFyLXdpZHRoJ1xuZXhwb3J0IHsgUmVmTWFwIH0gZnJvbSAnLi91dGlsL1JlZk1hcCdcbmV4cG9ydCB7IGdldElzUnRsU2Nyb2xsYmFyT25MZWZ0IH0gZnJvbSAnLi91dGlsL3Njcm9sbGJhci1zaWRlJ1xuXG5leHBvcnQgeyBOb3dUaW1lciB9IGZyb20gJy4vTm93VGltZXInXG5leHBvcnQgeyBTY3JvbGxSZXNwb25kZXIsIFNjcm9sbFJlcXVlc3QgfSBmcm9tICcuL1Njcm9sbFJlc3BvbmRlcidcbmV4cG9ydCB7IGdsb2JhbFBsdWdpbnMgfSBmcm9tICcuL2dsb2JhbC1wbHVnaW5zJ1xuZXhwb3J0IHtcbiAgUmVuZGVySG9vaywgUmVuZGVySG9va1Byb3BzLCBSZW5kZXJIb29rUHJvcHNDaGlsZHJlbiwgTW91bnRIb29rLCBNb3VudEhvb2tQcm9wcywgYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyLCBDb250ZW50SG9vayxcbiAgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQsIENsYXNzTmFtZXNHZW5lcmF0b3IsIEN1c3RvbUNvbnRlbnRHZW5lcmF0b3IsIERpZE1vdW50SGFuZGxlciwgV2lsbFVubW91bnRIYW5kbGVyLCBNb3VudEFyZyxcbn0gZnJvbSAnLi9jb21tb24vcmVuZGVyLWhvb2snXG5leHBvcnQgeyBTdGFuZGFyZEV2ZW50LCBTdGFuZGFyZEV2ZW50UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9TdGFuZGFyZEV2ZW50J1xuZXhwb3J0IHsgTm93SW5kaWNhdG9yUm9vdCwgTm93SW5kaWNhdG9yUm9vdFByb3BzIH0gZnJvbSAnLi9jb21tb24vTm93SW5kaWNhdG9yUm9vdCdcblxuZXhwb3J0IHsgRGF5Q2VsbFJvb3QsIERheUNlbGxSb290UHJvcHMsIERheUNlbGxDb250ZW50QXJnIH0gZnJvbSAnLi9jb21tb24vRGF5Q2VsbFJvb3QnXG5leHBvcnQgeyBEYXlDZWxsQ29udGVudCwgRGF5Q2VsbENvbnRlbnRQcm9wcyB9IGZyb20gJy4vY29tbW9uL0RheUNlbGxDb250ZW50J1xuZXhwb3J0IHsgRXZlbnRSb290LCBNaW5pbWFsRXZlbnRQcm9wcyB9IGZyb20gJy4vY29tbW9uL0V2ZW50Um9vdCdcbmV4cG9ydCB7IHJlbmRlckZpbGwsIEJnRXZlbnQsIEJnRXZlbnRQcm9wcyB9IGZyb20gJy4vY29tbW9uL2JnLWZpbGwnXG5leHBvcnQgeyBXZWVrTnVtYmVyUm9vdCwgV2Vla051bWJlclJvb3RQcm9wcyB9IGZyb20gJy4vY29tbW9uL1dlZWtOdW1iZXJSb290J1xuZXhwb3J0IHsgTW9yZUxpbmtSb290LCBNb3JlTGlua1Jvb3RQcm9wcywgTW9yZUxpbmtDb250ZW50QXJnLCBNb3JlTGlua01vdW50QXJnLCBjb21wdXRlRWFybGllc3RTZWdTdGFydCB9IGZyb20gJy4vY29tbW9uL01vcmVMaW5rUm9vdCdcblxuZXhwb3J0IHsgVmlld1Jvb3QsIFZpZXdSb290UHJvcHMgfSBmcm9tICcuL2NvbW1vbi9WaWV3Um9vdCdcbmV4cG9ydCB7IHRyaWdnZXJEYXRlU2VsZWN0LCBEYXRlUG9pbnRUcmFuc2Zvcm0sIERhdGVTcGFuVHJhbnNmb3JtLCBEYXRlU2VsZWN0aW9uQXBpLCBnZXREZWZhdWx0RXZlbnRFbmQgfSBmcm9tICcuL2NhbGVuZGFyLXV0aWxzJ1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.js":
/*!***************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Component\": function() { return /* binding */ Component; },\n/* harmony export */   \"Fragment\": function() { return /* binding */ Fragment; },\n/* harmony export */   \"createContext\": function() { return /* binding */ createContext; },\n/* harmony export */   \"createElement\": function() { return /* binding */ createElement; },\n/* harmony export */   \"createPortal\": function() { return /* binding */ createPortal; },\n/* harmony export */   \"createRef\": function() { return /* binding */ createRef; },\n/* harmony export */   \"flushToDom\": function() { return /* binding */ flushToDom; },\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* binding */ unmountComponentAtNode; }\n/* harmony export */ });\n/// <reference types=\"@fullcalendar/core-preact\" />\nif (typeof FullCalendarVDom === 'undefined') {\n  throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');\n}\n\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushToDom = FullCalendarVDom.flushToDom;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL3Zkb20uanM/ZGU4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cIkBmdWxsY2FsZW5kYXIvY29yZS1wcmVhY3RcIiAvPlxuaWYgKHR5cGVvZiBGdWxsQ2FsZW5kYXJWRG9tID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGltcG9ydCB0aGUgdG9wLWxldmVsIGZ1bGxjYWxlbmRhciBsaWIgYmVmb3JlIGF0dGVtcHRpbmcgdG8gaW1wb3J0IGEgcGx1Z2luLicpO1xufVxudmFyIENvbXBvbmVudCA9IEZ1bGxDYWxlbmRhclZEb20uQ29tcG9uZW50O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUVsZW1lbnQ7XG52YXIgcmVuZGVyID0gRnVsbENhbGVuZGFyVkRvbS5yZW5kZXI7XG52YXIgY3JlYXRlUmVmID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVSZWY7XG52YXIgRnJhZ21lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLkZyYWdtZW50O1xudmFyIGNyZWF0ZUNvbnRleHQgPSBGdWxsQ2FsZW5kYXJWRG9tLmNyZWF0ZUNvbnRleHQ7XG52YXIgY3JlYXRlUG9ydGFsID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVQb3J0YWw7XG52YXIgZmx1c2hUb0RvbSA9IEZ1bGxDYWxlbmRhclZEb20uZmx1c2hUb0RvbTtcbnZhciB1bm1vdW50Q29tcG9uZW50QXROb2RlID0gRnVsbENhbGVuZGFyVkRvbS51bm1vdW50Q29tcG9uZW50QXROb2RlO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5leHBvcnQgeyBDb21wb25lbnQsIEZyYWdtZW50LCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBjcmVhdGVQb3J0YWwsIGNyZWF0ZVJlZiwgZmx1c2hUb0RvbSwgcmVuZGVyLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/locales-all.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/core/locales-all.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar l0 = {\n  code: 'af',\n  week: {\n    dow: 1,\n    // Maandag is die eerste dag van die week.\n    doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.\n\n  },\n  buttonText: {\n    prev: 'Vorige',\n    next: 'Volgende',\n    today: 'Vandag',\n    year: 'Jaar',\n    month: 'Maand',\n    week: 'Week',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  allDayText: 'Heeldag',\n  moreLinkText: 'Addisionele',\n  noEventsText: 'Daar is geen gebeurtenisse nie'\n};\nvar l1 = {\n  code: 'ar-dz',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 4 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l2 = {\n  code: 'ar-kw',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l3 = {\n  code: 'ar-ly',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l4 = {\n  code: 'ar-ma',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l5 = {\n  code: 'ar-sa',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l6 = {\n  code: 'ar-tn',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l7 = {\n  code: 'ar',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'السابق',\n    next: 'التالي',\n    today: 'اليوم',\n    month: 'شهر',\n    week: 'أسبوع',\n    day: 'يوم',\n    list: 'أجندة'\n  },\n  weekText: 'أسبوع',\n  allDayText: 'اليوم كله',\n  moreLinkText: 'أخرى',\n  noEventsText: 'أي أحداث لعرض'\n};\nvar l8 = {\n  code: 'az',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Əvvəl',\n    next: 'Sonra',\n    today: 'Bu Gün',\n    month: 'Ay',\n    week: 'Həftə',\n    day: 'Gün',\n    list: 'Gündəm'\n  },\n  weekText: 'Həftə',\n  allDayText: 'Bütün Gün',\n  moreLinkText: function moreLinkText(n) {\n    return '+ daha çox ' + n;\n  },\n  noEventsText: 'Göstərmək üçün hadisə yoxdur'\n};\nvar l9 = {\n  code: 'bg',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'назад',\n    next: 'напред',\n    today: 'днес',\n    month: 'Месец',\n    week: 'Седмица',\n    day: 'Ден',\n    list: 'График'\n  },\n  allDayText: 'Цял ден',\n  moreLinkText: function moreLinkText(n) {\n    return '+още ' + n;\n  },\n  noEventsText: 'Няма събития за показване'\n};\nvar l10 = {\n  code: 'bn',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'পেছনে',\n    next: 'সামনে',\n    today: 'আজ',\n    month: 'মাস',\n    week: 'সপ্তাহ',\n    day: 'দিন',\n    list: 'তালিকা'\n  },\n  weekText: 'সপ্তাহ',\n  allDayText: 'সারাদিন',\n  moreLinkText: function moreLinkText(n) {\n    return '+অন্যান্য ' + n;\n  },\n  noEventsText: 'কোনো ইভেন্ট নেই'\n};\nvar l11 = {\n  code: 'bs',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prošli',\n    next: 'Sljedeći',\n    today: 'Danas',\n    month: 'Mjesec',\n    week: 'Sedmica',\n    day: 'Dan',\n    list: 'Raspored'\n  },\n  weekText: 'Sed',\n  allDayText: 'Cijeli dan',\n  moreLinkText: function moreLinkText(n) {\n    return '+ još ' + n;\n  },\n  noEventsText: 'Nema događaja za prikazivanje'\n};\nvar l12 = {\n  code: 'ca',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Anterior',\n    next: 'Següent',\n    today: 'Avui',\n    month: 'Mes',\n    week: 'Setmana',\n    day: 'Dia',\n    list: 'Agenda'\n  },\n  weekText: 'Set',\n  allDayText: 'Tot el dia',\n  moreLinkText: 'més',\n  noEventsText: 'No hi ha esdeveniments per mostrar'\n};\nvar l13 = {\n  code: 'cs',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Dříve',\n    next: 'Později',\n    today: 'Nyní',\n    month: 'Měsíc',\n    week: 'Týden',\n    day: 'Den',\n    list: 'Agenda'\n  },\n  weekText: 'Týd',\n  allDayText: 'Celý den',\n  moreLinkText: function moreLinkText(n) {\n    return '+další: ' + n;\n  },\n  noEventsText: 'Žádné akce k zobrazení'\n};\nvar l14 = {\n  code: 'cy',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Blaenorol',\n    next: 'Nesaf',\n    today: 'Heddiw',\n    year: 'Blwyddyn',\n    month: 'Mis',\n    week: 'Wythnos',\n    day: 'Dydd',\n    list: 'Rhestr'\n  },\n  weekText: 'Wythnos',\n  allDayText: 'Trwy\\'r dydd',\n  moreLinkText: 'Mwy',\n  noEventsText: 'Dim digwyddiadau'\n};\nvar l15 = {\n  code: 'da',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Forrige',\n    next: 'Næste',\n    today: 'I dag',\n    month: 'Måned',\n    week: 'Uge',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  weekText: 'Uge',\n  allDayText: 'Hele dagen',\n  moreLinkText: 'flere',\n  noEventsText: 'Ingen arrangementer at vise'\n};\nvar l16 = {\n  code: 'de-at',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Zurück',\n    next: 'Vor',\n    today: 'Heute',\n    year: 'Jahr',\n    month: 'Monat',\n    week: 'Woche',\n    day: 'Tag',\n    list: 'Terminübersicht'\n  },\n  weekText: 'KW',\n  allDayText: 'Ganztägig',\n  moreLinkText: function moreLinkText(n) {\n    return '+ weitere ' + n;\n  },\n  noEventsText: 'Keine Ereignisse anzuzeigen'\n};\nvar l17 = {\n  code: 'de',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Zurück',\n    next: 'Vor',\n    today: 'Heute',\n    year: 'Jahr',\n    month: 'Monat',\n    week: 'Woche',\n    day: 'Tag',\n    list: 'Terminübersicht'\n  },\n  weekText: 'KW',\n  allDayText: 'Ganztägig',\n  moreLinkText: function moreLinkText(n) {\n    return '+ weitere ' + n;\n  },\n  noEventsText: 'Keine Ereignisse anzuzeigen'\n};\nvar l18 = {\n  code: 'el',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Προηγούμενος',\n    next: 'Επόμενος',\n    today: 'Σήμερα',\n    month: 'Μήνας',\n    week: 'Εβδομάδα',\n    day: 'Ημέρα',\n    list: 'Ατζέντα'\n  },\n  weekText: 'Εβδ',\n  allDayText: 'Ολοήμερο',\n  moreLinkText: 'περισσότερα',\n  noEventsText: 'Δεν υπάρχουν γεγονότα προς εμφάνιση'\n};\nvar l19 = {\n  code: 'en-au',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  }\n};\nvar l20 = {\n  code: 'en-gb',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  }\n};\nvar l21 = {\n  code: 'en-nz',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  }\n};\nvar l22 = {\n  code: 'eo',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Antaŭa',\n    next: 'Sekva',\n    today: 'Hodiaŭ',\n    month: 'Monato',\n    week: 'Semajno',\n    day: 'Tago',\n    list: 'Tagordo'\n  },\n  weekText: 'Sm',\n  allDayText: 'Tuta tago',\n  moreLinkText: 'pli',\n  noEventsText: 'Neniuj eventoj por montri'\n};\nvar l23 = {\n  code: 'es',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Ant',\n    next: 'Sig',\n    today: 'Hoy',\n    month: 'Mes',\n    week: 'Semana',\n    day: 'Día',\n    list: 'Agenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Todo el día',\n  moreLinkText: 'más',\n  noEventsText: 'No hay eventos para mostrar'\n};\nvar l24 = {\n  code: 'es',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Ant',\n    next: 'Sig',\n    today: 'Hoy',\n    month: 'Mes',\n    week: 'Semana',\n    day: 'Día',\n    list: 'Agenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Todo el día',\n  moreLinkText: 'más',\n  noEventsText: 'No hay eventos para mostrar'\n};\nvar l25 = {\n  code: 'et',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Eelnev',\n    next: 'Järgnev',\n    today: 'Täna',\n    month: 'Kuu',\n    week: 'Nädal',\n    day: 'Päev',\n    list: 'Päevakord'\n  },\n  weekText: 'näd',\n  allDayText: 'Kogu päev',\n  moreLinkText: function moreLinkText(n) {\n    return '+ veel ' + n;\n  },\n  noEventsText: 'Kuvamiseks puuduvad sündmused'\n};\nvar l26 = {\n  code: 'eu',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Aur',\n    next: 'Hur',\n    today: 'Gaur',\n    month: 'Hilabetea',\n    week: 'Astea',\n    day: 'Eguna',\n    list: 'Agenda'\n  },\n  weekText: 'As',\n  allDayText: 'Egun osoa',\n  moreLinkText: 'gehiago',\n  noEventsText: 'Ez dago ekitaldirik erakusteko'\n};\nvar l27 = {\n  code: 'fa',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'قبلی',\n    next: 'بعدی',\n    today: 'امروز',\n    month: 'ماه',\n    week: 'هفته',\n    day: 'روز',\n    list: 'برنامه'\n  },\n  weekText: 'هف',\n  allDayText: 'تمام روز',\n  moreLinkText: function moreLinkText(n) {\n    return 'بیش از ' + n;\n  },\n  noEventsText: 'هیچ رویدادی به نمایش'\n};\nvar l28 = {\n  code: 'fi',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Edellinen',\n    next: 'Seuraava',\n    today: 'Tänään',\n    month: 'Kuukausi',\n    week: 'Viikko',\n    day: 'Päivä',\n    list: 'Tapahtumat'\n  },\n  weekText: 'Vk',\n  allDayText: 'Koko päivä',\n  moreLinkText: 'lisää',\n  noEventsText: 'Ei näytettäviä tapahtumia'\n};\nvar l29 = {\n  code: 'fr',\n  buttonText: {\n    prev: 'Précédent',\n    next: 'Suivant',\n    today: \"Aujourd'hui\",\n    year: 'Année',\n    month: 'Mois',\n    week: 'Semaine',\n    day: 'Jour',\n    list: 'Mon planning'\n  },\n  weekText: 'Sem.',\n  allDayText: 'Toute la journée',\n  moreLinkText: 'en plus',\n  noEventsText: 'Aucun événement à afficher'\n};\nvar l30 = {\n  code: 'fr-ch',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Précédent',\n    next: 'Suivant',\n    today: 'Courant',\n    year: 'Année',\n    month: 'Mois',\n    week: 'Semaine',\n    day: 'Jour',\n    list: 'Mon planning'\n  },\n  weekText: 'Sm',\n  allDayText: 'Toute la journée',\n  moreLinkText: 'en plus',\n  noEventsText: 'Aucun événement à afficher'\n};\nvar l31 = {\n  code: 'fr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Précédent',\n    next: 'Suivant',\n    today: \"Aujourd'hui\",\n    year: 'Année',\n    month: 'Mois',\n    week: 'Semaine',\n    day: 'Jour',\n    list: 'Planning'\n  },\n  weekText: 'Sem.',\n  allDayText: 'Toute la journée',\n  moreLinkText: 'en plus',\n  noEventsText: 'Aucun événement à afficher'\n};\nvar l32 = {\n  code: 'gl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Ant',\n    next: 'Seg',\n    today: 'Hoxe',\n    month: 'Mes',\n    week: 'Semana',\n    day: 'Día',\n    list: 'Axenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Todo o día',\n  moreLinkText: 'máis',\n  noEventsText: 'Non hai eventos para amosar'\n};\nvar l33 = {\n  code: 'he',\n  direction: 'rtl',\n  buttonText: {\n    prev: 'הקודם',\n    next: 'הבא',\n    today: 'היום',\n    month: 'חודש',\n    week: 'שבוע',\n    day: 'יום',\n    list: 'סדר יום'\n  },\n  allDayText: 'כל היום',\n  moreLinkText: 'אחר',\n  noEventsText: 'אין אירועים להצגה',\n  weekText: 'שבוע'\n};\nvar l34 = {\n  code: 'hi',\n  week: {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'पिछला',\n    next: 'अगला',\n    today: 'आज',\n    month: 'महीना',\n    week: 'सप्ताह',\n    day: 'दिन',\n    list: 'कार्यसूची'\n  },\n  weekText: 'हफ्ता',\n  allDayText: 'सभी दिन',\n  moreLinkText: function moreLinkText(n) {\n    return '+अधिक ' + n;\n  },\n  noEventsText: 'कोई घटनाओं को प्रदर्शित करने के लिए'\n};\nvar l35 = {\n  code: 'hr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prijašnji',\n    next: 'Sljedeći',\n    today: 'Danas',\n    month: 'Mjesec',\n    week: 'Tjedan',\n    day: 'Dan',\n    list: 'Raspored'\n  },\n  weekText: 'Tje',\n  allDayText: 'Cijeli dan',\n  moreLinkText: function moreLinkText(n) {\n    return '+ još ' + n;\n  },\n  noEventsText: 'Nema događaja za prikaz'\n};\nvar l36 = {\n  code: 'hu',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'vissza',\n    next: 'előre',\n    today: 'ma',\n    month: 'Hónap',\n    week: 'Hét',\n    day: 'Nap',\n    list: 'Lista'\n  },\n  weekText: 'Hét',\n  allDayText: 'Egész nap',\n  moreLinkText: 'további',\n  noEventsText: 'Nincs megjeleníthető esemény'\n};\nvar l37 = {\n  code: 'hy-am',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Նախորդ',\n    next: 'Հաջորդ',\n    today: 'Այսօր',\n    month: 'Ամիս',\n    week: 'Շաբաթ',\n    day: 'Օր',\n    list: 'Օրվա ցուցակ'\n  },\n  weekText: 'Շաբ',\n  allDayText: 'Ամբողջ օր',\n  moreLinkText: function moreLinkText(n) {\n    return '+ ևս ' + n;\n  },\n  noEventsText: 'Բացակայում է իրադարձությունը ցուցադրելու'\n};\nvar l38 = {\n  code: 'id',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'mundur',\n    next: 'maju',\n    today: 'hari ini',\n    month: 'Bulan',\n    week: 'Minggu',\n    day: 'Hari',\n    list: 'Agenda'\n  },\n  weekText: 'Mg',\n  allDayText: 'Sehari penuh',\n  moreLinkText: 'lebih',\n  noEventsText: 'Tidak ada acara untuk ditampilkan'\n};\nvar l39 = {\n  code: 'is',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Fyrri',\n    next: 'Næsti',\n    today: 'Í dag',\n    month: 'Mánuður',\n    week: 'Vika',\n    day: 'Dagur',\n    list: 'Dagskrá'\n  },\n  weekText: 'Vika',\n  allDayText: 'Allan daginn',\n  moreLinkText: 'meira',\n  noEventsText: 'Engir viðburðir til að sýna'\n};\nvar l40 = {\n  code: 'it',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prec',\n    next: 'Succ',\n    today: 'Oggi',\n    month: 'Mese',\n    week: 'Settimana',\n    day: 'Giorno',\n    list: 'Agenda'\n  },\n  weekText: 'Sm',\n  allDayText: 'Tutto il giorno',\n  moreLinkText: function moreLinkText(n) {\n    return '+altri ' + n;\n  },\n  noEventsText: 'Non ci sono eventi da visualizzare'\n};\nvar l41 = {\n  code: 'ja',\n  buttonText: {\n    prev: '前',\n    next: '次',\n    today: '今日',\n    month: '月',\n    week: '週',\n    day: '日',\n    list: '予定リスト'\n  },\n  weekText: '週',\n  allDayText: '終日',\n  moreLinkText: function moreLinkText(n) {\n    return '他 ' + n + ' 件';\n  },\n  noEventsText: '表示する予定はありません'\n};\nvar l42 = {\n  code: 'ka',\n  week: {\n    dow: 1,\n    doy: 7\n  },\n  buttonText: {\n    prev: 'წინა',\n    next: 'შემდეგი',\n    today: 'დღეს',\n    month: 'თვე',\n    week: 'კვირა',\n    day: 'დღე',\n    list: 'დღის წესრიგი'\n  },\n  weekText: 'კვ',\n  allDayText: 'მთელი დღე',\n  moreLinkText: function moreLinkText(n) {\n    return '+ კიდევ ' + n;\n  },\n  noEventsText: 'ღონისძიებები არ არის'\n};\nvar l43 = {\n  code: 'kk',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Алдыңғы',\n    next: 'Келесі',\n    today: 'Бүгін',\n    month: 'Ай',\n    week: 'Апта',\n    day: 'Күн',\n    list: 'Күн тәртібі'\n  },\n  weekText: 'Не',\n  allDayText: 'Күні бойы',\n  moreLinkText: function moreLinkText(n) {\n    return '+ тағы ' + n;\n  },\n  noEventsText: 'Көрсету үшін оқиғалар жоқ'\n};\nvar l44 = {\n  code: 'km',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'មុន',\n    next: 'បន្ទាប់',\n    today: 'ថ្ងៃនេះ',\n    year: 'ឆ្នាំ',\n    month: 'ខែ',\n    week: 'សប្តាហ៍',\n    day: 'ថ្ងៃ',\n    list: 'បញ្ជី'\n  },\n  weekText: 'សប្តាហ៍',\n  allDayText: 'ពេញមួយថ្ងៃ',\n  moreLinkText: 'ច្រើនទៀត',\n  noEventsText: 'គ្មានព្រឹត្តិការណ៍ត្រូវបង្ហាញ'\n};\nvar l45 = {\n  code: 'ko',\n  buttonText: {\n    prev: '이전달',\n    next: '다음달',\n    today: '오늘',\n    month: '월',\n    week: '주',\n    day: '일',\n    list: '일정목록'\n  },\n  weekText: '주',\n  allDayText: '종일',\n  moreLinkText: '개',\n  noEventsText: '일정이 없습니다'\n};\nvar l46 = {\n  code: 'ku',\n  week: {\n    dow: 6,\n    // Saturday is the first day of the week.\n    doy: 12 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  direction: 'rtl',\n  buttonText: {\n    prev: 'پێشتر',\n    next: 'دواتر',\n    today: 'ئەمڕو',\n    month: 'مانگ',\n    week: 'هەفتە',\n    day: 'ڕۆژ',\n    list: 'بەرنامە'\n  },\n  weekText: 'هەفتە',\n  allDayText: 'هەموو ڕۆژەکە',\n  moreLinkText: 'زیاتر',\n  noEventsText: 'هیچ ڕووداوێك نیە'\n};\nvar l47 = {\n  code: 'lb',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Zréck',\n    next: 'Weider',\n    today: 'Haut',\n    month: 'Mount',\n    week: 'Woch',\n    day: 'Dag',\n    list: 'Terminiwwersiicht'\n  },\n  weekText: 'W',\n  allDayText: 'Ganzen Dag',\n  moreLinkText: 'méi',\n  noEventsText: 'Nee Evenementer ze affichéieren'\n};\nvar l48 = {\n  code: 'lt',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Atgal',\n    next: 'Pirmyn',\n    today: 'Šiandien',\n    month: 'Mėnuo',\n    week: 'Savaitė',\n    day: 'Diena',\n    list: 'Darbotvarkė'\n  },\n  weekText: 'SAV',\n  allDayText: 'Visą dieną',\n  moreLinkText: 'daugiau',\n  noEventsText: 'Nėra įvykių rodyti'\n};\nvar l49 = {\n  code: 'lv',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Iepr.',\n    next: 'Nāk.',\n    today: 'Šodien',\n    month: 'Mēnesis',\n    week: 'Nedēļa',\n    day: 'Diena',\n    list: 'Dienas kārtība'\n  },\n  weekText: 'Ned.',\n  allDayText: 'Visu dienu',\n  moreLinkText: function moreLinkText(n) {\n    return '+vēl ' + n;\n  },\n  noEventsText: 'Nav notikumu'\n};\nvar l50 = {\n  code: 'mk',\n  buttonText: {\n    prev: 'претходно',\n    next: 'следно',\n    today: 'Денес',\n    month: 'Месец',\n    week: 'Недела',\n    day: 'Ден',\n    list: 'График'\n  },\n  weekText: 'Сед',\n  allDayText: 'Цел ден',\n  moreLinkText: function moreLinkText(n) {\n    return '+повеќе ' + n;\n  },\n  noEventsText: 'Нема настани за прикажување'\n};\nvar l51 = {\n  code: 'ms',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Sebelum',\n    next: 'Selepas',\n    today: 'hari ini',\n    month: 'Bulan',\n    week: 'Minggu',\n    day: 'Hari',\n    list: 'Agenda'\n  },\n  weekText: 'Mg',\n  allDayText: 'Sepanjang hari',\n  moreLinkText: function moreLinkText(n) {\n    return 'masih ada ' + n + ' acara';\n  },\n  noEventsText: 'Tiada peristiwa untuk dipaparkan'\n};\nvar l52 = {\n  code: 'nb',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Forrige',\n    next: 'Neste',\n    today: 'I dag',\n    month: 'Måned',\n    week: 'Uke',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  weekText: 'Uke',\n  allDayText: 'Hele dagen',\n  moreLinkText: 'til',\n  noEventsText: 'Ingen hendelser å vise'\n};\nvar l53 = {\n  code: 'ne',\n  // code for nepal\n  week: {\n    dow: 7,\n    // Sunday is the first day of the week.\n    doy: 1 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'अघिल्लो',\n    next: 'अर्को',\n    today: 'आज',\n    month: 'महिना',\n    week: 'हप्ता',\n    day: 'दिन',\n    list: 'सूची'\n  },\n  weekText: 'हप्ता',\n  allDayText: 'दिनभरि',\n  moreLinkText: 'थप लिंक',\n  noEventsText: 'देखाउनको लागि कुनै घटनाहरू छैनन्'\n};\nvar l54 = {\n  code: 'nl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Vorige',\n    next: 'Volgende',\n    today: 'Vandaag',\n    year: 'Jaar',\n    month: 'Maand',\n    week: 'Week',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  allDayText: 'Hele dag',\n  moreLinkText: 'extra',\n  noEventsText: 'Geen evenementen om te laten zien'\n};\nvar l55 = {\n  code: 'nn',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Førre',\n    next: 'Neste',\n    today: 'I dag',\n    month: 'Månad',\n    week: 'Veke',\n    day: 'Dag',\n    list: 'Agenda'\n  },\n  weekText: 'Veke',\n  allDayText: 'Heile dagen',\n  moreLinkText: 'til',\n  noEventsText: 'Ingen hendelser å vise'\n};\nvar l56 = {\n  code: 'pl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Poprzedni',\n    next: 'Następny',\n    today: 'Dziś',\n    month: 'Miesiąc',\n    week: 'Tydzień',\n    day: 'Dzień',\n    list: 'Plan dnia'\n  },\n  weekText: 'Tydz',\n  allDayText: 'Cały dzień',\n  moreLinkText: 'więcej',\n  noEventsText: 'Brak wydarzeń do wyświetlenia'\n};\nvar l57 = {\n  code: 'pt-br',\n  buttonText: {\n    prev: 'Anterior',\n    next: 'Próximo',\n    today: 'Hoje',\n    month: 'Mês',\n    week: 'Semana',\n    day: 'Dia',\n    list: 'Lista'\n  },\n  weekText: 'Sm',\n  allDayText: 'dia inteiro',\n  moreLinkText: function moreLinkText(n) {\n    return 'mais +' + n;\n  },\n  noEventsText: 'Não há eventos para mostrar'\n};\nvar l58 = {\n  code: 'pt',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Anterior',\n    next: 'Seguinte',\n    today: 'Hoje',\n    month: 'Mês',\n    week: 'Semana',\n    day: 'Dia',\n    list: 'Agenda'\n  },\n  weekText: 'Sem',\n  allDayText: 'Todo o dia',\n  moreLinkText: 'mais',\n  noEventsText: 'Não há eventos para mostrar'\n};\nvar l59 = {\n  code: 'ro',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'precedentă',\n    next: 'următoare',\n    today: 'Azi',\n    month: 'Lună',\n    week: 'Săptămână',\n    day: 'Zi',\n    list: 'Agendă'\n  },\n  weekText: 'Săpt',\n  allDayText: 'Toată ziua',\n  moreLinkText: function moreLinkText(n) {\n    return '+alte ' + n;\n  },\n  noEventsText: 'Nu există evenimente de afișat'\n};\nvar l60 = {\n  code: 'ru',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Пред',\n    next: 'След',\n    today: 'Сегодня',\n    month: 'Месяц',\n    week: 'Неделя',\n    day: 'День',\n    list: 'Повестка дня'\n  },\n  weekText: 'Нед',\n  allDayText: 'Весь день',\n  moreLinkText: function moreLinkText(n) {\n    return '+ ещё ' + n;\n  },\n  noEventsText: 'Нет событий для отображения'\n};\nvar l61 = {\n  code: 'sk',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Predchádzajúci',\n    next: 'Nasledujúci',\n    today: 'Dnes',\n    month: 'Mesiac',\n    week: 'Týždeň',\n    day: 'Deň',\n    list: 'Rozvrh'\n  },\n  weekText: 'Ty',\n  allDayText: 'Celý deň',\n  moreLinkText: function moreLinkText(n) {\n    return '+ďalšie: ' + n;\n  },\n  noEventsText: 'Žiadne akcie na zobrazenie'\n};\nvar l62 = {\n  code: 'sl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prejšnji',\n    next: 'Naslednji',\n    today: 'Trenutni',\n    month: 'Mesec',\n    week: 'Teden',\n    day: 'Dan',\n    list: 'Dnevni red'\n  },\n  weekText: 'Teden',\n  allDayText: 'Ves dan',\n  moreLinkText: 'več',\n  noEventsText: 'Ni dogodkov za prikaz'\n};\nvar l63 = {\n  code: 'sm',\n  buttonText: {\n    prev: 'Talu ai',\n    next: 'Mulimuli atu',\n    today: 'Aso nei',\n    month: 'Masina',\n    week: 'Vaiaso',\n    day: 'Aso',\n    list: 'Faasologa'\n  },\n  weekText: 'Vaiaso',\n  allDayText: 'Aso atoa',\n  moreLinkText: 'sili atu',\n  noEventsText: 'Leai ni mea na tutupu'\n};\nvar l64 = {\n  code: 'sq',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'mbrapa',\n    next: 'Përpara',\n    today: 'sot',\n    month: 'Muaj',\n    week: 'Javë',\n    day: 'Ditë',\n    list: 'Listë'\n  },\n  weekText: 'Ja',\n  allDayText: 'Gjithë ditën',\n  moreLinkText: function moreLinkText(n) {\n    return '+më tepër ' + n;\n  },\n  noEventsText: 'Nuk ka evente për të shfaqur'\n};\nvar l65 = {\n  code: 'sr-cyrl',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Претходна',\n    next: 'следећи',\n    today: 'Данас',\n    month: 'Месец',\n    week: 'Недеља',\n    day: 'Дан',\n    list: 'Планер'\n  },\n  weekText: 'Сед',\n  allDayText: 'Цео дан',\n  moreLinkText: function moreLinkText(n) {\n    return '+ још ' + n;\n  },\n  noEventsText: 'Нема догађаја за приказ'\n};\nvar l66 = {\n  code: 'sr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Prethodna',\n    next: 'Sledeći',\n    today: 'Danas',\n    month: 'Mеsеc',\n    week: 'Nеdеlja',\n    day: 'Dan',\n    list: 'Planеr'\n  },\n  weekText: 'Sed',\n  allDayText: 'Cеo dan',\n  moreLinkText: function moreLinkText(n) {\n    return '+ još ' + n;\n  },\n  noEventsText: 'Nеma događaja za prikaz'\n};\nvar l67 = {\n  code: 'sv',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Förra',\n    next: 'Nästa',\n    today: 'Idag',\n    month: 'Månad',\n    week: 'Vecka',\n    day: 'Dag',\n    list: 'Program'\n  },\n  weekText: 'v.',\n  allDayText: 'Heldag',\n  moreLinkText: 'till',\n  noEventsText: 'Inga händelser att visa'\n};\nvar l68 = {\n  code: 'ta-in',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'முந்தைய',\n    next: 'அடுத்தது',\n    today: 'இன்று',\n    month: 'மாதம்',\n    week: 'வாரம்',\n    day: 'நாள்',\n    list: 'தினசரி அட்டவணை'\n  },\n  weekText: 'வாரம்',\n  allDayText: 'நாள் முழுவதும்',\n  moreLinkText: function moreLinkText(n) {\n    return '+ மேலும் ' + n;\n  },\n  noEventsText: 'காண்பிக்க நிகழ்வுகள் இல்லை'\n};\nvar l69 = {\n  code: 'th',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'ก่อนหน้า',\n    next: 'ถัดไป',\n    prevYear: 'ปีก่อนหน้า',\n    nextYear: 'ปีถัดไป',\n    year: 'ปี',\n    today: 'วันนี้',\n    month: 'เดือน',\n    week: 'สัปดาห์',\n    day: 'วัน',\n    list: 'กำหนดการ'\n  },\n  weekText: 'สัปดาห์',\n  allDayText: 'ตลอดวัน',\n  moreLinkText: 'เพิ่มเติม',\n  noEventsText: 'ไม่มีกิจกรรมที่จะแสดง'\n};\nvar l70 = {\n  code: 'tr',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'geri',\n    next: 'ileri',\n    today: 'bugün',\n    month: 'Ay',\n    week: 'Hafta',\n    day: 'Gün',\n    list: 'Ajanda'\n  },\n  weekText: 'Hf',\n  allDayText: 'Tüm gün',\n  moreLinkText: 'daha fazla',\n  noEventsText: 'Gösterilecek etkinlik yok'\n};\nvar l71 = {\n  code: 'ug',\n  buttonText: {\n    month: 'ئاي',\n    week: 'ھەپتە',\n    day: 'كۈن',\n    list: 'كۈنتەرتىپ'\n  },\n  allDayText: 'پۈتۈن كۈن'\n};\nvar l72 = {\n  code: 'uk',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 7 // The week that contains Jan 1st is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Попередній',\n    next: 'далі',\n    today: 'Сьогодні',\n    month: 'Місяць',\n    week: 'Тиждень',\n    day: 'День',\n    list: 'Порядок денний'\n  },\n  weekText: 'Тиж',\n  allDayText: 'Увесь день',\n  moreLinkText: function moreLinkText(n) {\n    return '+ще ' + n + '...';\n  },\n  noEventsText: 'Немає подій для відображення'\n};\nvar l73 = {\n  code: 'uz',\n  buttonText: {\n    month: 'Oy',\n    week: 'Xafta',\n    day: 'Kun',\n    list: 'Kun tartibi'\n  },\n  allDayText: \"Kun bo'yi\",\n  moreLinkText: function moreLinkText(n) {\n    return '+ yana ' + n;\n  },\n  noEventsText: \"Ko'rsatish uchun voqealar yo'q\"\n};\nvar l74 = {\n  code: 'vi',\n  week: {\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: 'Trước',\n    next: 'Tiếp',\n    today: 'Hôm nay',\n    month: 'Tháng',\n    week: 'Tuần',\n    day: 'Ngày',\n    list: 'Lịch biểu'\n  },\n  weekText: 'Tu',\n  allDayText: 'Cả ngày',\n  moreLinkText: function moreLinkText(n) {\n    return '+ thêm ' + n;\n  },\n  noEventsText: 'Không có sự kiện để hiển thị'\n};\nvar l75 = {\n  code: 'zh-cn',\n  week: {\n    // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效\n    dow: 1,\n    // Monday is the first day of the week.\n    doy: 4 // The week that contains Jan 4th is the first week of the year.\n\n  },\n  buttonText: {\n    prev: '上月',\n    next: '下月',\n    today: '今天',\n    month: '月',\n    week: '周',\n    day: '日',\n    list: '日程'\n  },\n  weekText: '周',\n  allDayText: '全天',\n  moreLinkText: function moreLinkText(n) {\n    return '另外 ' + n + ' 个';\n  },\n  noEventsText: '没有事件显示'\n};\nvar l76 = {\n  code: 'zh-tw',\n  buttonText: {\n    prev: '上月',\n    next: '下月',\n    today: '今天',\n    month: '月',\n    week: '週',\n    day: '天',\n    list: '活動列表'\n  },\n  weekText: '周',\n  allDayText: '整天',\n  moreLinkText: '顯示更多',\n  noEventsText: '没有任何活動'\n};\n/* eslint max-len: off */\n\nvar localesAll = [l0, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14, l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, l25, l26, l27, l28, l29, l30, l31, l32, l33, l34, l35, l36, l37, l38, l39, l40, l41, l42, l43, l44, l45, l46, l47, l48, l49, l50, l51, l52, l53, l54, l55, l56, l57, l58, l59, l60, l61, l62, l63, l64, l65, l66, l67, l68, l69, l70, l71, l72, l73, l74, l75, l76];\nexports[\"default\"] = localesAll;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL2xvY2FsZXMtYWxsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFGQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUZBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBRkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUF3QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFxQkE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWxCQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFSQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcEJBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBaUJBOztBQUVBO0FBSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbG9jYWxlcy1hbGwuanM/NzgyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBsMCA9IHtcbiAgY29kZTogJ2FmJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTWFhbmRhZyBpcyBkaWUgZWVyc3RlIGRhZyB2YW4gZGllIHdlZWsuXG4gICAgZG95OiA0LCAvLyBEaWUgd2VlayB3YXQgZGllIDRkZSBKYW51YXJpZSBiZXZhdCBpcyBkaWUgZWVyc3RlIHdlZWsgdmFuIGRpZSBqYWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1ZvcmlnZScsXG4gICAgbmV4dDogJ1ZvbGdlbmRlJyxcbiAgICB0b2RheTogJ1ZhbmRhZycsXG4gICAgeWVhcjogJ0phYXInLFxuICAgIG1vbnRoOiAnTWFhbmQnLFxuICAgIHdlZWs6ICdXZWVrJyxcbiAgICBkYXk6ICdEYWcnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICBhbGxEYXlUZXh0OiAnSGVlbGRhZycsXG4gIG1vcmVMaW5rVGV4dDogJ0FkZGlzaW9uZWxlJyxcbiAgbm9FdmVudHNUZXh0OiAnRGFhciBpcyBnZWVuIGdlYmV1cnRlbmlzc2UgbmllJyxcbn07XG5cbnZhciBsMSA9IHtcbiAgY29kZTogJ2FyLWR6JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn2KfZhNiz2KfYqNmCJyxcbiAgICBuZXh0OiAn2KfZhNiq2KfZhNmKJyxcbiAgICB0b2RheTogJ9in2YTZitmI2YUnLFxuICAgIG1vbnRoOiAn2LTZh9ixJyxcbiAgICB3ZWVrOiAn2KPYs9io2YjYuScsXG4gICAgZGF5OiAn2YrZiNmFJyxcbiAgICBsaXN0OiAn2KPYrNmG2K/YqScsXG4gIH0sXG4gIHdlZWtUZXh0OiAn2KPYs9io2YjYuScsXG4gIGFsbERheVRleHQ6ICfYp9mE2YrZiNmFINmD2YTZhycsXG4gIG1vcmVMaW5rVGV4dDogJ9ij2K7YsdmJJyxcbiAgbm9FdmVudHNUZXh0OiAn2KPZiiDYo9it2K/Yp9irINmE2LnYsdi2Jyxcbn07XG5cbnZhciBsMiA9IHtcbiAgY29kZTogJ2FyLWt3JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDMgPSB7XG4gIGNvZGU6ICdhci1seScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDQgPSB7XG4gIGNvZGU6ICdhci1tYScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDUgPSB7XG4gIGNvZGU6ICdhci1zYScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDYgPSB7XG4gIGNvZGU6ICdhci10bicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDcgPSB7XG4gIGNvZGU6ICdhcicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDYsIC8vIFNhdHVyZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiAxMiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBkaXJlY3Rpb246ICdydGwnLFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9in2YTYs9in2KjZgicsXG4gICAgbmV4dDogJ9in2YTYqtin2YTZiicsXG4gICAgdG9kYXk6ICfYp9mE2YrZiNmFJyxcbiAgICBtb250aDogJ9i02YfYsScsXG4gICAgd2VlazogJ9ij2LPYqNmI2LknLFxuICAgIGRheTogJ9mK2YjZhScsXG4gICAgbGlzdDogJ9ij2KzZhtiv2KknLFxuICB9LFxuICB3ZWVrVGV4dDogJ9ij2LPYqNmI2LknLFxuICBhbGxEYXlUZXh0OiAn2KfZhNmK2YjZhSDZg9mE2YcnLFxuICBtb3JlTGlua1RleHQ6ICfYo9iu2LHZiScsXG4gIG5vRXZlbnRzVGV4dDogJ9ij2Yog2KPYrdiv2KfYqyDZhNi52LHYticsXG59O1xuXG52YXIgbDggPSB7XG4gIGNvZGU6ICdheicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ8aPdnbJmWwnLFxuICAgIG5leHQ6ICdTb25yYScsXG4gICAgdG9kYXk6ICdCdSBHw7xuJyxcbiAgICBtb250aDogJ0F5JyxcbiAgICB3ZWVrOiAnSMmZZnTJmScsXG4gICAgZGF5OiAnR8O8bicsXG4gICAgbGlzdDogJ0fDvG5kyZltJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdIyZlmdMmZJyxcbiAgYWxsRGF5VGV4dDogJ0LDvHTDvG4gR8O8bicsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyBkYWhhIMOnb3ggJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnR8O2c3TJmXJtyZlrIMO8w6fDvG4gaGFkaXPJmSB5b3hkdXInLFxufTtcblxudmFyIGw5ID0ge1xuICBjb2RlOiAnYmcnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfQvdCw0LfQsNC0JyxcbiAgICBuZXh0OiAn0L3QsNC/0YDQtdC0JyxcbiAgICB0b2RheTogJ9C00L3QtdGBJyxcbiAgICBtb250aDogJ9Cc0LXRgdC10YYnLFxuICAgIHdlZWs6ICfQodC10LTQvNC40YbQsCcsXG4gICAgZGF5OiAn0JTQtdC9JyxcbiAgICBsaXN0OiAn0JPRgNCw0YTQuNC6JyxcbiAgfSxcbiAgYWxsRGF5VGV4dDogJ9Cm0Y/QuyDQtNC10L0nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyvQvtGJ0LUgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn0J3Rj9C80LAg0YHRitCx0LjRgtC40Y8g0LfQsCDQv9C+0LrQsNC30LLQsNC90LUnLFxufTtcblxudmFyIGwxMCA9IHtcbiAgY29kZTogJ2JuJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn4Kaq4KeH4Kab4Kao4KeHJyxcbiAgICBuZXh0OiAn4Ka44Ka+4Kau4Kao4KeHJyxcbiAgICB0b2RheTogJ+CmhuCmnCcsXG4gICAgbW9udGg6ICfgpq7gpr7gprgnLFxuICAgIHdlZWs6ICfgprjgpqrgp43gpqTgpr7gprknLFxuICAgIGRheTogJ+CmpuCmv+CmqCcsXG4gICAgbGlzdDogJ+CmpOCmvuCmsuCmv+CmleCmvicsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4Ka44Kaq4KeN4Kak4Ka+4Ka5JyxcbiAgYWxsRGF5VGV4dDogJ+CmuOCmvuCmsOCmvuCmpuCmv+CmqCcsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnK+CmheCmqOCnjeCmr+CmvuCmqOCnjeCmryAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfgppXgp4vgpqjgp4sg4KaH4Kat4KeH4Kao4KeN4KafIOCmqOCnh+CmhycsXG59O1xuXG52YXIgbDExID0ge1xuICBjb2RlOiAnYnMnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdQcm/FoWxpJyxcbiAgICBuZXh0OiAnU2xqZWRlxIdpJyxcbiAgICB0b2RheTogJ0RhbmFzJyxcbiAgICBtb250aDogJ01qZXNlYycsXG4gICAgd2VlazogJ1NlZG1pY2EnLFxuICAgIGRheTogJ0RhbicsXG4gICAgbGlzdDogJ1Jhc3BvcmVkJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTZWQnLFxuICBhbGxEYXlUZXh0OiAnQ2lqZWxpIGRhbicsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyBqb8WhICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ05lbWEgZG9nYcSRYWphIHphIHByaWtheml2YW5qZScsXG59O1xuXG52YXIgbDEyID0ge1xuICBjb2RlOiAnY2EnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdBbnRlcmlvcicsXG4gICAgbmV4dDogJ1NlZ8O8ZW50JyxcbiAgICB0b2RheTogJ0F2dWknLFxuICAgIG1vbnRoOiAnTWVzJyxcbiAgICB3ZWVrOiAnU2V0bWFuYScsXG4gICAgZGF5OiAnRGlhJyxcbiAgICBsaXN0OiAnQWdlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTZXQnLFxuICBhbGxEYXlUZXh0OiAnVG90IGVsIGRpYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DqXMnLFxuICBub0V2ZW50c1RleHQ6ICdObyBoaSBoYSBlc2RldmVuaW1lbnRzIHBlciBtb3N0cmFyJyxcbn07XG5cbnZhciBsMTMgPSB7XG4gIGNvZGU6ICdjcycsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ0TFmcOtdmUnLFxuICAgIG5leHQ6ICdQb3pkxJtqaScsXG4gICAgdG9kYXk6ICdOeW7DrScsXG4gICAgbW9udGg6ICdNxJtzw61jJyxcbiAgICB3ZWVrOiAnVMO9ZGVuJyxcbiAgICBkYXk6ICdEZW4nLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1TDvWQnLFxuICBhbGxEYXlUZXh0OiAnQ2Vsw70gZGVuJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrZGFsxaHDrTogJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnxb3DoWRuw6kgYWtjZSBrIHpvYnJhemVuw60nLFxufTtcblxudmFyIGwxNCA9IHtcbiAgY29kZTogJ2N5JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQmxhZW5vcm9sJyxcbiAgICBuZXh0OiAnTmVzYWYnLFxuICAgIHRvZGF5OiAnSGVkZGl3JyxcbiAgICB5ZWFyOiAnQmx3eWRkeW4nLFxuICAgIG1vbnRoOiAnTWlzJyxcbiAgICB3ZWVrOiAnV3l0aG5vcycsXG4gICAgZGF5OiAnRHlkZCcsXG4gICAgbGlzdDogJ1JoZXN0cicsXG4gIH0sXG4gIHdlZWtUZXh0OiAnV3l0aG5vcycsXG4gIGFsbERheVRleHQ6ICdUcnd5XFwnciBkeWRkJyxcbiAgbW9yZUxpbmtUZXh0OiAnTXd5JyxcbiAgbm9FdmVudHNUZXh0OiAnRGltIGRpZ3d5ZGRpYWRhdScsXG59O1xuXG52YXIgbDE1ID0ge1xuICBjb2RlOiAnZGEnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGb3JyaWdlJyxcbiAgICBuZXh0OiAnTsOmc3RlJyxcbiAgICB0b2RheTogJ0kgZGFnJyxcbiAgICBtb250aDogJ03DpW5lZCcsXG4gICAgd2VlazogJ1VnZScsXG4gICAgZGF5OiAnRGFnJyxcbiAgICBsaXN0OiAnQWdlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdVZ2UnLFxuICBhbGxEYXlUZXh0OiAnSGVsZSBkYWdlbicsXG4gIG1vcmVMaW5rVGV4dDogJ2ZsZXJlJyxcbiAgbm9FdmVudHNUZXh0OiAnSW5nZW4gYXJyYW5nZW1lbnRlciBhdCB2aXNlJyxcbn07XG5cbnZhciBsMTYgPSB7XG4gIGNvZGU6ICdkZS1hdCcsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1p1csO8Y2snLFxuICAgIG5leHQ6ICdWb3InLFxuICAgIHRvZGF5OiAnSGV1dGUnLFxuICAgIHllYXI6ICdKYWhyJyxcbiAgICBtb250aDogJ01vbmF0JyxcbiAgICB3ZWVrOiAnV29jaGUnLFxuICAgIGRheTogJ1RhZycsXG4gICAgbGlzdDogJ1Rlcm1pbsO8YmVyc2ljaHQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ0tXJyxcbiAgYWxsRGF5VGV4dDogJ0dhbnp0w6RnaWcnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgd2VpdGVyZSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICdLZWluZSBFcmVpZ25pc3NlIGFuenV6ZWlnZW4nLFxufTtcblxudmFyIGwxNyA9IHtcbiAgY29kZTogJ2RlJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnWnVyw7xjaycsXG4gICAgbmV4dDogJ1ZvcicsXG4gICAgdG9kYXk6ICdIZXV0ZScsXG4gICAgeWVhcjogJ0phaHInLFxuICAgIG1vbnRoOiAnTW9uYXQnLFxuICAgIHdlZWs6ICdXb2NoZScsXG4gICAgZGF5OiAnVGFnJyxcbiAgICBsaXN0OiAnVGVybWluw7xiZXJzaWNodCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnS1cnLFxuICBhbGxEYXlUZXh0OiAnR2FuenTDpGdpZycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyB3ZWl0ZXJlICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ0tlaW5lIEVyZWlnbmlzc2UgYW56dXplaWdlbicsXG59O1xuXG52YXIgbDE4ID0ge1xuICBjb2RlOiAnZWwnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDRzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfOoM+Bzr/Ot86zzr/Pjc68zrXOvc6/z4InLFxuICAgIG5leHQ6ICfOlc+Az4zOvM61zr3Ov8+CJyxcbiAgICB0b2RheTogJ86jzq7OvM61z4HOsScsXG4gICAgbW9udGg6ICfOnM6uzr3Osc+CJyxcbiAgICB3ZWVrOiAnzpXOss60zr/OvM6szrTOsScsXG4gICAgZGF5OiAnzpfOvM6tz4HOsScsXG4gICAgbGlzdDogJ86Rz4TOts6tzr3PhM6xJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfOlc6yzrQnLFxuICBhbGxEYXlUZXh0OiAnzp/Ou86/zq7OvM61z4HOvycsXG4gIG1vcmVMaW5rVGV4dDogJ8+AzrXPgc65z4PPg8+Mz4TOtc+BzrEnLFxuICBub0V2ZW50c1RleHQ6ICfOlM61zr0gz4XPgM6sz4HPh86/z4XOvSDOs861zrPOv869z4zPhM6xIM+Az4HOv8+CIM61zrzPhs6szr3Ouc+DzrcnLFxufTtcblxudmFyIGwxOSA9IHtcbiAgY29kZTogJ2VuLWF1JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG59O1xuXG52YXIgbDIwID0ge1xuICBjb2RlOiAnZW4tZ2InLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbn07XG5cbnZhciBsMjEgPSB7XG4gIGNvZGU6ICdlbi1ueicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxufTtcblxudmFyIGwyMiA9IHtcbiAgY29kZTogJ2VvJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50YcWtYScsXG4gICAgbmV4dDogJ1Nla3ZhJyxcbiAgICB0b2RheTogJ0hvZGlhxa0nLFxuICAgIG1vbnRoOiAnTW9uYXRvJyxcbiAgICB3ZWVrOiAnU2VtYWpubycsXG4gICAgZGF5OiAnVGFnbycsXG4gICAgbGlzdDogJ1RhZ29yZG8nLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1R1dGEgdGFnbycsXG4gIG1vcmVMaW5rVGV4dDogJ3BsaScsXG4gIG5vRXZlbnRzVGV4dDogJ05lbml1aiBldmVudG9qIHBvciBtb250cmknLFxufTtcblxudmFyIGwyMyA9IHtcbiAgY29kZTogJ2VzJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50JyxcbiAgICBuZXh0OiAnU2lnJyxcbiAgICB0b2RheTogJ0hveScsXG4gICAgbW9udGg6ICdNZXMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0TDrWEnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1RvZG8gZWwgZMOtYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DoXMnLFxuICBub0V2ZW50c1RleHQ6ICdObyBoYXkgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGwyNCA9IHtcbiAgY29kZTogJ2VzJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50JyxcbiAgICBuZXh0OiAnU2lnJyxcbiAgICB0b2RheTogJ0hveScsXG4gICAgbW9udGg6ICdNZXMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0TDrWEnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1RvZG8gZWwgZMOtYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DoXMnLFxuICBub0V2ZW50c1RleHQ6ICdObyBoYXkgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGwyNSA9IHtcbiAgY29kZTogJ2V0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnRWVsbmV2JyxcbiAgICBuZXh0OiAnSsOkcmduZXYnLFxuICAgIHRvZGF5OiAnVMOkbmEnLFxuICAgIG1vbnRoOiAnS3V1JyxcbiAgICB3ZWVrOiAnTsOkZGFsJyxcbiAgICBkYXk6ICdQw6RldicsXG4gICAgbGlzdDogJ1DDpGV2YWtvcmQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ27DpGQnLFxuICBhbGxEYXlUZXh0OiAnS29ndSBww6RldicsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyB2ZWVsICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ0t1dmFtaXNla3MgcHV1ZHV2YWQgc8O8bmRtdXNlZCcsXG59O1xuXG52YXIgbDI2ID0ge1xuICBjb2RlOiAnZXUnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdBdXInLFxuICAgIG5leHQ6ICdIdXInLFxuICAgIHRvZGF5OiAnR2F1cicsXG4gICAgbW9udGg6ICdIaWxhYmV0ZWEnLFxuICAgIHdlZWs6ICdBc3RlYScsXG4gICAgZGF5OiAnRWd1bmEnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ0FzJyxcbiAgYWxsRGF5VGV4dDogJ0VndW4gb3NvYScsXG4gIG1vcmVMaW5rVGV4dDogJ2dlaGlhZ28nLFxuICBub0V2ZW50c1RleHQ6ICdFeiBkYWdvIGVraXRhbGRpcmlrIGVyYWt1c3Rla28nLFxufTtcblxudmFyIGwyNyA9IHtcbiAgY29kZTogJ2ZhJyxcbiAgd2Vlazoge1xuICAgIGRvdzogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDEyLCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn2YLYqNmE24wnLFxuICAgIG5leHQ6ICfYqNi52K/bjCcsXG4gICAgdG9kYXk6ICfYp9mF2LHZiNiyJyxcbiAgICBtb250aDogJ9mF2KfZhycsXG4gICAgd2VlazogJ9mH2YHYqtmHJyxcbiAgICBkYXk6ICfYsdmI2LInLFxuICAgIGxpc3Q6ICfYqNix2YbYp9mF2YcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ9mH2YEnLFxuICBhbGxEYXlUZXh0OiAn2KrZhdin2YUg2LHZiNiyJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICfYqNuM2LQg2KfYsiAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfZh9uM2oYg2LHZiNuM2K/Yp9iv24wg2KjZhyDZhtmF2KfbjNi0Jyxcbn07XG5cbnZhciBsMjggPSB7XG4gIGNvZGU6ICdmaScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ0VkZWxsaW5lbicsXG4gICAgbmV4dDogJ1NldXJhYXZhJyxcbiAgICB0b2RheTogJ1TDpG7DpMOkbicsXG4gICAgbW9udGg6ICdLdXVrYXVzaScsXG4gICAgd2VlazogJ1ZpaWtrbycsXG4gICAgZGF5OiAnUMOkaXbDpCcsXG4gICAgbGlzdDogJ1RhcGFodHVtYXQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1ZrJyxcbiAgYWxsRGF5VGV4dDogJ0tva28gcMOkaXbDpCcsXG4gIG1vcmVMaW5rVGV4dDogJ2xpc8Okw6QnLFxuICBub0V2ZW50c1RleHQ6ICdFaSBuw6R5dGV0dMOkdmnDpCB0YXBhaHR1bWlhJyxcbn07XG5cbnZhciBsMjkgPSB7XG4gIGNvZGU6ICdmcicsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHLDqWPDqWRlbnQnLFxuICAgIG5leHQ6ICdTdWl2YW50JyxcbiAgICB0b2RheTogXCJBdWpvdXJkJ2h1aVwiLFxuICAgIHllYXI6ICdBbm7DqWUnLFxuICAgIG1vbnRoOiAnTW9pcycsXG4gICAgd2VlazogJ1NlbWFpbmUnLFxuICAgIGRheTogJ0pvdXInLFxuICAgIGxpc3Q6ICdNb24gcGxhbm5pbmcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NlbS4nLFxuICBhbGxEYXlUZXh0OiAnVG91dGUgbGEgam91cm7DqWUnLFxuICBtb3JlTGlua1RleHQ6ICdlbiBwbHVzJyxcbiAgbm9FdmVudHNUZXh0OiAnQXVjdW4gw6l2w6luZW1lbnQgw6AgYWZmaWNoZXInLFxufTtcblxudmFyIGwzMCA9IHtcbiAgY29kZTogJ2ZyLWNoJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHLDqWPDqWRlbnQnLFxuICAgIG5leHQ6ICdTdWl2YW50JyxcbiAgICB0b2RheTogJ0NvdXJhbnQnLFxuICAgIHllYXI6ICdBbm7DqWUnLFxuICAgIG1vbnRoOiAnTW9pcycsXG4gICAgd2VlazogJ1NlbWFpbmUnLFxuICAgIGRheTogJ0pvdXInLFxuICAgIGxpc3Q6ICdNb24gcGxhbm5pbmcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1RvdXRlIGxhIGpvdXJuw6llJyxcbiAgbW9yZUxpbmtUZXh0OiAnZW4gcGx1cycsXG4gIG5vRXZlbnRzVGV4dDogJ0F1Y3VuIMOpdsOpbmVtZW50IMOgIGFmZmljaGVyJyxcbn07XG5cbnZhciBsMzEgPSB7XG4gIGNvZGU6ICdmcicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1Byw6ljw6lkZW50JyxcbiAgICBuZXh0OiAnU3VpdmFudCcsXG4gICAgdG9kYXk6IFwiQXVqb3VyZCdodWlcIixcbiAgICB5ZWFyOiAnQW5uw6llJyxcbiAgICBtb250aDogJ01vaXMnLFxuICAgIHdlZWs6ICdTZW1haW5lJyxcbiAgICBkYXk6ICdKb3VyJyxcbiAgICBsaXN0OiAnUGxhbm5pbmcnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NlbS4nLFxuICBhbGxEYXlUZXh0OiAnVG91dGUgbGEgam91cm7DqWUnLFxuICBtb3JlTGlua1RleHQ6ICdlbiBwbHVzJyxcbiAgbm9FdmVudHNUZXh0OiAnQXVjdW4gw6l2w6luZW1lbnQgw6AgYWZmaWNoZXInLFxufTtcblxudmFyIGwzMiA9IHtcbiAgY29kZTogJ2dsJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50JyxcbiAgICBuZXh0OiAnU2VnJyxcbiAgICB0b2RheTogJ0hveGUnLFxuICAgIG1vbnRoOiAnTWVzJyxcbiAgICB3ZWVrOiAnU2VtYW5hJyxcbiAgICBkYXk6ICdEw61hJyxcbiAgICBsaXN0OiAnQXhlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTbScsXG4gIGFsbERheVRleHQ6ICdUb2RvIG8gZMOtYScsXG4gIG1vcmVMaW5rVGV4dDogJ23DoWlzJyxcbiAgbm9FdmVudHNUZXh0OiAnTm9uIGhhaSBldmVudG9zIHBhcmEgYW1vc2FyJyxcbn07XG5cbnZhciBsMzMgPSB7XG4gIGNvZGU6ICdoZScsXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn15TXp9eV15PXnScsXG4gICAgbmV4dDogJ9eU15HXkCcsXG4gICAgdG9kYXk6ICfXlNeZ15XXnScsXG4gICAgbW9udGg6ICfXl9eV15PXqScsXG4gICAgd2VlazogJ9ep15HXldeiJyxcbiAgICBkYXk6ICfXmdeV150nLFxuICAgIGxpc3Q6ICfXodeT16gg15nXldedJyxcbiAgfSxcbiAgYWxsRGF5VGV4dDogJ9eb15wg15TXmdeV150nLFxuICBtb3JlTGlua1RleHQ6ICfXkNeX16gnLFxuICBub0V2ZW50c1RleHQ6ICfXkNeZ158g15DXmdeo15XXoteZ150g15zXlNem15LXlCcsXG4gIHdlZWtUZXh0OiAn16nXkdeV16InLFxufTtcblxudmFyIGwzNCA9IHtcbiAgY29kZTogJ2hpJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn4KSq4KS/4KSb4KSy4KS+JyxcbiAgICBuZXh0OiAn4KSF4KSX4KSy4KS+JyxcbiAgICB0b2RheTogJ+CkhuCknCcsXG4gICAgbW9udGg6ICfgpK7gpLngpYDgpKjgpL4nLFxuICAgIHdlZWs6ICfgpLjgpKrgpY3gpKTgpL7gpLknLFxuICAgIGRheTogJ+CkpuCkv+CkqCcsXG4gICAgbGlzdDogJ+CkleCkvuCksOCljeCkr+CkuOClguCkmuClgCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4KS54KSr4KWN4KSk4KS+JyxcbiAgYWxsRGF5VGV4dDogJ+CkuOCkreClgCDgpKbgpL/gpKgnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyvgpIXgpKfgpL/gpJUgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn4KSV4KWL4KSIIOCkmOCkn+CkqOCkvuCkk+CkgiDgpJXgpYsg4KSq4KWN4KSw4KSm4KSw4KWN4KS24KS/4KSkIOCkleCksOCkqOClhyDgpJXgpYcg4KSy4KS/4KSPJyxcbn07XG5cbnZhciBsMzUgPSB7XG4gIGNvZGU6ICdocicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNywgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ1ByaWphxaFuamknLFxuICAgIG5leHQ6ICdTbGplZGXEh2knLFxuICAgIHRvZGF5OiAnRGFuYXMnLFxuICAgIG1vbnRoOiAnTWplc2VjJyxcbiAgICB3ZWVrOiAnVGplZGFuJyxcbiAgICBkYXk6ICdEYW4nLFxuICAgIGxpc3Q6ICdSYXNwb3JlZCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVGplJyxcbiAgYWxsRGF5VGV4dDogJ0NpamVsaSBkYW4nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgam/FoSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICdOZW1hIGRvZ2HEkWFqYSB6YSBwcmlrYXonLFxufTtcblxudmFyIGwzNiA9IHtcbiAgY29kZTogJ2h1JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAndmlzc3phJyxcbiAgICBuZXh0OiAnZWzFkXJlJyxcbiAgICB0b2RheTogJ21hJyxcbiAgICBtb250aDogJ0jDs25hcCcsXG4gICAgd2VlazogJ0jDqXQnLFxuICAgIGRheTogJ05hcCcsXG4gICAgbGlzdDogJ0xpc3RhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdIw6l0JyxcbiAgYWxsRGF5VGV4dDogJ0Vnw6lzeiBuYXAnLFxuICBtb3JlTGlua1RleHQ6ICd0b3bDoWJiaScsXG4gIG5vRXZlbnRzVGV4dDogJ05pbmNzIG1lZ2plbGVuw610aGV0xZEgZXNlbcOpbnknLFxufTtcblxudmFyIGwzNyA9IHtcbiAgY29kZTogJ2h5LWFtJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn1YbVodWt1bjWgNWkJyxcbiAgICBuZXh0OiAn1YDVodW71bjWgNWkJyxcbiAgICB0b2RheTogJ9Sx1bXVvdaF1oAnLFxuICAgIG1vbnRoOiAn1LHVtNWr1b0nLFxuICAgIHdlZWs6ICfVh9Wh1aLVodWpJyxcbiAgICBkYXk6ICfVldaAJyxcbiAgICBsaXN0OiAn1ZXWgNW+1aEg1oHVuNaC1oHVodWvJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfVh9Wh1aInLFxuICBhbGxEYXlUZXh0OiAn1LHVtNWi1bjVstW7INaF1oAnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysg1ofVvSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfUstWh1oHVodWv1aHVtdW41oLVtCDVpyDVq9aA1aHVpNWh1oDVsdW41oLVqdW11bjWgtW21agg1oHVuNaC1oHVodWk1oDVpdWs1bjWgicsXG59O1xuXG52YXIgbDM4ID0ge1xuICBjb2RlOiAnaWQnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdtdW5kdXInLFxuICAgIG5leHQ6ICdtYWp1JyxcbiAgICB0b2RheTogJ2hhcmkgaW5pJyxcbiAgICBtb250aDogJ0J1bGFuJyxcbiAgICB3ZWVrOiAnTWluZ2d1JyxcbiAgICBkYXk6ICdIYXJpJyxcbiAgICBsaXN0OiAnQWdlbmRhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdNZycsXG4gIGFsbERheVRleHQ6ICdTZWhhcmkgcGVudWgnLFxuICBtb3JlTGlua1RleHQ6ICdsZWJpaCcsXG4gIG5vRXZlbnRzVGV4dDogJ1RpZGFrIGFkYSBhY2FyYSB1bnR1ayBkaXRhbXBpbGthbicsXG59O1xuXG52YXIgbDM5ID0ge1xuICBjb2RlOiAnaXMnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGeXJyaScsXG4gICAgbmV4dDogJ07DpnN0aScsXG4gICAgdG9kYXk6ICfDjSBkYWcnLFxuICAgIG1vbnRoOiAnTcOhbnXDsHVyJyxcbiAgICB3ZWVrOiAnVmlrYScsXG4gICAgZGF5OiAnRGFndXInLFxuICAgIGxpc3Q6ICdEYWdza3LDoScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVmlrYScsXG4gIGFsbERheVRleHQ6ICdBbGxhbiBkYWdpbm4nLFxuICBtb3JlTGlua1RleHQ6ICdtZWlyYScsXG4gIG5vRXZlbnRzVGV4dDogJ0VuZ2lyIHZpw7BidXLDsGlyIHRpbCBhw7Agc8O9bmEnLFxufTtcblxudmFyIGw0MCA9IHtcbiAgY29kZTogJ2l0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHJlYycsXG4gICAgbmV4dDogJ1N1Y2MnLFxuICAgIHRvZGF5OiAnT2dnaScsXG4gICAgbW9udGg6ICdNZXNlJyxcbiAgICB3ZWVrOiAnU2V0dGltYW5hJyxcbiAgICBkYXk6ICdHaW9ybm8nLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1NtJyxcbiAgYWxsRGF5VGV4dDogJ1R1dHRvIGlsIGdpb3JubycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnK2FsdHJpICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ05vbiBjaSBzb25vIGV2ZW50aSBkYSB2aXN1YWxpenphcmUnLFxufTtcblxudmFyIGw0MSA9IHtcbiAgY29kZTogJ2phJyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfliY0nLFxuICAgIG5leHQ6ICfmrKEnLFxuICAgIHRvZGF5OiAn5LuK5pelJyxcbiAgICBtb250aDogJ+aciCcsXG4gICAgd2VlazogJ+mAsScsXG4gICAgZGF5OiAn5pelJyxcbiAgICBsaXN0OiAn5LqI5a6a44Oq44K544OIJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfpgLEnLFxuICBhbGxEYXlUZXh0OiAn57WC5pelJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICfku5YgJyArIG4gKyAnIOS7tidcbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn6KGo56S644GZ44KL5LqI5a6a44Gv44GC44KK44G+44Gb44KTJyxcbn07XG5cbnZhciBsNDIgPSB7XG4gIGNvZGU6ICdrYScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsXG4gICAgZG95OiA3LFxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ+GDrOGDmOGDnOGDkCcsXG4gICAgbmV4dDogJ+GDqOGDlOGDm+GDk+GDlOGDkuGDmCcsXG4gICAgdG9kYXk6ICfhg5Phg6bhg5Thg6EnLFxuICAgIG1vbnRoOiAn4YOX4YOV4YOUJyxcbiAgICB3ZWVrOiAn4YOZ4YOV4YOY4YOg4YOQJyxcbiAgICBkYXk6ICfhg5Phg6bhg5QnLFxuICAgIGxpc3Q6ICfhg5Phg6bhg5jhg6Eg4YOs4YOU4YOh4YOg4YOY4YOS4YOYJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfhg5nhg5UnLFxuICBhbGxEYXlUZXh0OiAn4YOb4YOX4YOU4YOa4YOYIOGDk+GDpuGDlCcsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyDhg5nhg5jhg5Phg5Thg5UgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn4YOm4YOd4YOc4YOY4YOh4YOr4YOY4YOU4YOR4YOU4YOR4YOYIOGDkOGDoCDhg5Dhg6Dhg5jhg6EnLFxufTtcblxudmFyIGw0MyA9IHtcbiAgY29kZTogJ2trJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn0JDQu9C00YvSo9KT0YsnLFxuICAgIG5leHQ6ICfQmtC10LvQtdGB0ZYnLFxuICAgIHRvZGF5OiAn0JHSr9Cz0ZbQvScsXG4gICAgbW9udGg6ICfQkNC5JyxcbiAgICB3ZWVrOiAn0JDQv9GC0LAnLFxuICAgIGRheTogJ9Ca0q/QvScsXG4gICAgbGlzdDogJ9Ca0q/QvSDRgtOZ0YDRgtGW0LHRlicsXG4gIH0sXG4gIHdlZWtUZXh0OiAn0J3QtScsXG4gIGFsbERheVRleHQ6ICfQmtKv0L3RliDQsdC+0LnRiycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyDRgtCw0pPRiyAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfQmtOp0YDRgdC10YLRgyDSr9GI0ZbQvSDQvtKb0LjSk9Cw0LvQsNGAINC20L7SmycsXG59O1xuXG52YXIgbDQ0ID0ge1xuICBjb2RlOiAna20nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfhnpjhnrvhnpMnLFxuICAgIG5leHQ6ICfhnpThnpPhn5LhnpHhnrbhnpThn4snLFxuICAgIHRvZGF5OiAn4Z6Q4Z+S4Z6E4Z+D4Z6T4Z+B4Z+HJyxcbiAgICB5ZWFyOiAn4Z6G4Z+S4Z6T4Z624Z+GJyxcbiAgICBtb250aDogJ+GegeGfgicsXG4gICAgd2VlazogJ+Gen+GelOGfkuGej+GetuGeoOGfjScsXG4gICAgZGF5OiAn4Z6Q4Z+S4Z6E4Z+DJyxcbiAgICBsaXN0OiAn4Z6U4Z6J4Z+S4Z6H4Z64JyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfhnp/hnpThn5Lhno/hnrbhnqDhn40nLFxuICBhbGxEYXlUZXh0OiAn4Z6W4Z+B4Z6J4Z6Y4Z694Z6Z4Z6Q4Z+S4Z6E4Z+DJyxcbiAgbW9yZUxpbmtUZXh0OiAn4Z6F4Z+S4Z6a4Z6+4Z6T4Z6R4Z+A4Z6PJyxcbiAgbm9FdmVudHNUZXh0OiAn4Z6C4Z+S4Z6Y4Z624Z6T4Z6W4Z+S4Z6a4Z654Z6P4Z+S4Z6P4Z634Z6A4Z624Z6a4Z6O4Z+N4Z6P4Z+S4Z6a4Z684Z6c4Z6U4Z6E4Z+S4Z6g4Z624Z6JJyxcbn07XG5cbnZhciBsNDUgPSB7XG4gIGNvZGU6ICdrbycsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn7J207KCE64usJyxcbiAgICBuZXh0OiAn64uk7J2M64usJyxcbiAgICB0b2RheTogJ+yYpOuKmCcsXG4gICAgbW9udGg6ICfsm5QnLFxuICAgIHdlZWs6ICfso7wnLFxuICAgIGRheTogJ+ydvCcsXG4gICAgbGlzdDogJ+ydvOygleuqqeuhnScsXG4gIH0sXG4gIHdlZWtUZXh0OiAn7KO8JyxcbiAgYWxsRGF5VGV4dDogJ+yiheydvCcsXG4gIG1vcmVMaW5rVGV4dDogJ+qwnCcsXG4gIG5vRXZlbnRzVGV4dDogJ+ydvOygleydtCDsl4bsirXri4jri6QnLFxufTtcblxudmFyIGw0NiA9IHtcbiAgY29kZTogJ2t1JyxcbiAgd2Vlazoge1xuICAgIGRvdzogNiwgLy8gU2F0dXJkYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDEyLCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGRpcmVjdGlvbjogJ3J0bCcsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn2b7bjti02KrYsScsXG4gICAgbmV4dDogJ9iv2YjYp9iq2LEnLFxuICAgIHRvZGF5OiAn2KbbldmF2pXZiCcsXG4gICAgbW9udGg6ICfZhdin2YbarycsXG4gICAgd2VlazogJ9mH25XZgdiq25UnLFxuICAgIGRheTogJ9qV24bamCcsXG4gICAgbGlzdDogJ9io25XYsdmG2KfZhduVJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfZh9uV2YHYqtuVJyxcbiAgYWxsRGF5VGV4dDogJ9mH25XZhdmI2Ygg2pXbhtqY25XaqduVJyxcbiAgbW9yZUxpbmtUZXh0OiAn2LLbjNin2KrYsScsXG4gIG5vRXZlbnRzVGV4dDogJ9mH24zahiDaldmI2YjYr9in2YjbjtmDINmG24zblScsXG59O1xuXG52YXIgbDQ3ID0ge1xuICBjb2RlOiAnbGInLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdacsOpY2snLFxuICAgIG5leHQ6ICdXZWlkZXInLFxuICAgIHRvZGF5OiAnSGF1dCcsXG4gICAgbW9udGg6ICdNb3VudCcsXG4gICAgd2VlazogJ1dvY2gnLFxuICAgIGRheTogJ0RhZycsXG4gICAgbGlzdDogJ1Rlcm1pbml3d2Vyc2lpY2h0JyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdXJyxcbiAgYWxsRGF5VGV4dDogJ0dhbnplbiBEYWcnLFxuICBtb3JlTGlua1RleHQ6ICdtw6lpJyxcbiAgbm9FdmVudHNUZXh0OiAnTmVlIEV2ZW5lbWVudGVyIHplIGFmZmljaMOpaWVyZW4nLFxufTtcblxudmFyIGw0OCA9IHtcbiAgY29kZTogJ2x0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQXRnYWwnLFxuICAgIG5leHQ6ICdQaXJteW4nLFxuICAgIHRvZGF5OiAnxaBpYW5kaWVuJyxcbiAgICBtb250aDogJ03El251bycsXG4gICAgd2VlazogJ1NhdmFpdMSXJyxcbiAgICBkYXk6ICdEaWVuYScsXG4gICAgbGlzdDogJ0RhcmJvdHZhcmvElycsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU0FWJyxcbiAgYWxsRGF5VGV4dDogJ1Zpc8SFIGRpZW7EhScsXG4gIG1vcmVMaW5rVGV4dDogJ2RhdWdpYXUnLFxuICBub0V2ZW50c1RleHQ6ICdOxJdyYSDEr3Z5a2nFsyByb2R5dGknLFxufTtcblxudmFyIGw0OSA9IHtcbiAgY29kZTogJ2x2JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnSWVwci4nLFxuICAgIG5leHQ6ICdOxIFrLicsXG4gICAgdG9kYXk6ICfFoG9kaWVuJyxcbiAgICBtb250aDogJ03Ek25lc2lzJyxcbiAgICB3ZWVrOiAnTmVkxJPEvGEnLFxuICAgIGRheTogJ0RpZW5hJyxcbiAgICBsaXN0OiAnRGllbmFzIGvEgXJ0xKtiYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnTmVkLicsXG4gIGFsbERheVRleHQ6ICdWaXN1IGRpZW51JyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrdsSTbCAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICdOYXYgbm90aWt1bXUnLFxufTtcblxudmFyIGw1MCA9IHtcbiAgY29kZTogJ21rJyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfQv9GA0LXRgtGF0L7QtNC90L4nLFxuICAgIG5leHQ6ICfRgdC70LXQtNC90L4nLFxuICAgIHRvZGF5OiAn0JTQtdC90LXRgScsXG4gICAgbW9udGg6ICfQnNC10YHQtdGGJyxcbiAgICB3ZWVrOiAn0J3QtdC00LXQu9CwJyxcbiAgICBkYXk6ICfQlNC10L0nLFxuICAgIGxpc3Q6ICfQk9GA0LDRhNC40LonLFxuICB9LFxuICB3ZWVrVGV4dDogJ9Ch0LXQtCcsXG4gIGFsbERheVRleHQ6ICfQptC10Lsg0LTQtdC9JyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcr0L/QvtCy0LXRnNC1ICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ9Cd0LXQvNCwINC90LDRgdGC0LDQvdC4INC30LAg0L/RgNC40LrQsNC20YPQstCw0ZrQtScsXG59O1xuXG52YXIgbDUxID0ge1xuICBjb2RlOiAnbXMnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdTZWJlbHVtJyxcbiAgICBuZXh0OiAnU2VsZXBhcycsXG4gICAgdG9kYXk6ICdoYXJpIGluaScsXG4gICAgbW9udGg6ICdCdWxhbicsXG4gICAgd2VlazogJ01pbmdndScsXG4gICAgZGF5OiAnSGFyaScsXG4gICAgbGlzdDogJ0FnZW5kYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnTWcnLFxuICBhbGxEYXlUZXh0OiAnU2VwYW5qYW5nIGhhcmknLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJ21hc2loIGFkYSAnICsgbiArICcgYWNhcmEnXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ1RpYWRhIHBlcmlzdGl3YSB1bnR1ayBkaXBhcGFya2FuJyxcbn07XG5cbnZhciBsNTIgPSB7XG4gIGNvZGU6ICduYicsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ0ZvcnJpZ2UnLFxuICAgIG5leHQ6ICdOZXN0ZScsXG4gICAgdG9kYXk6ICdJIGRhZycsXG4gICAgbW9udGg6ICdNw6VuZWQnLFxuICAgIHdlZWs6ICdVa2UnLFxuICAgIGRheTogJ0RhZycsXG4gICAgbGlzdDogJ0FnZW5kYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVWtlJyxcbiAgYWxsRGF5VGV4dDogJ0hlbGUgZGFnZW4nLFxuICBtb3JlTGlua1RleHQ6ICd0aWwnLFxuICBub0V2ZW50c1RleHQ6ICdJbmdlbiBoZW5kZWxzZXIgw6UgdmlzZScsXG59O1xuXG52YXIgbDUzID0ge1xuICBjb2RlOiAnbmUnLCAvLyBjb2RlIGZvciBuZXBhbFxuICB3ZWVrOiB7XG4gICAgZG93OiA3LCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDEsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfgpIXgpJjgpL/gpLLgpY3gpLLgpYsnLFxuICAgIG5leHQ6ICfgpIXgpLDgpY3gpJXgpYsnLFxuICAgIHRvZGF5OiAn4KSG4KScJyxcbiAgICBtb250aDogJ+CkruCkueCkv+CkqOCkvicsXG4gICAgd2VlazogJ+CkueCkquCljeCkpOCkvicsXG4gICAgZGF5OiAn4KSm4KS/4KSoJyxcbiAgICBsaXN0OiAn4KS44KWC4KSa4KWAJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfgpLngpKrgpY3gpKTgpL4nLFxuICBhbGxEYXlUZXh0OiAn4KSm4KS/4KSo4KSt4KSw4KS/JyxcbiAgbW9yZUxpbmtUZXh0OiAn4KSl4KSqIOCksuCkv+CkguCklScsXG4gIG5vRXZlbnRzVGV4dDogJ+CkpuClh+CkluCkvuCkieCkqOCkleCliyDgpLLgpL7gpJfgpL8g4KSV4KWB4KSo4KWIIOCkmOCkn+CkqOCkvuCkueCksOClgiDgpJvgpYjgpKjgpKjgpY0nLFxufTtcblxudmFyIGw1NCA9IHtcbiAgY29kZTogJ25sJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnVm9yaWdlJyxcbiAgICBuZXh0OiAnVm9sZ2VuZGUnLFxuICAgIHRvZGF5OiAnVmFuZGFhZycsXG4gICAgeWVhcjogJ0phYXInLFxuICAgIG1vbnRoOiAnTWFhbmQnLFxuICAgIHdlZWs6ICdXZWVrJyxcbiAgICBkYXk6ICdEYWcnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICBhbGxEYXlUZXh0OiAnSGVsZSBkYWcnLFxuICBtb3JlTGlua1RleHQ6ICdleHRyYScsXG4gIG5vRXZlbnRzVGV4dDogJ0dlZW4gZXZlbmVtZW50ZW4gb20gdGUgbGF0ZW4gemllbicsXG59O1xuXG52YXIgbDU1ID0ge1xuICBjb2RlOiAnbm4nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGw7hycmUnLFxuICAgIG5leHQ6ICdOZXN0ZScsXG4gICAgdG9kYXk6ICdJIGRhZycsXG4gICAgbW9udGg6ICdNw6VuYWQnLFxuICAgIHdlZWs6ICdWZWtlJyxcbiAgICBkYXk6ICdEYWcnLFxuICAgIGxpc3Q6ICdBZ2VuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1Zla2UnLFxuICBhbGxEYXlUZXh0OiAnSGVpbGUgZGFnZW4nLFxuICBtb3JlTGlua1RleHQ6ICd0aWwnLFxuICBub0V2ZW50c1RleHQ6ICdJbmdlbiBoZW5kZWxzZXIgw6UgdmlzZScsXG59O1xuXG52YXIgbDU2ID0ge1xuICBjb2RlOiAncGwnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdQb3ByemVkbmknLFxuICAgIG5leHQ6ICdOYXN0xJlwbnknLFxuICAgIHRvZGF5OiAnRHppxZsnLFxuICAgIG1vbnRoOiAnTWllc2nEhWMnLFxuICAgIHdlZWs6ICdUeWR6aWXFhCcsXG4gICAgZGF5OiAnRHppZcWEJyxcbiAgICBsaXN0OiAnUGxhbiBkbmlhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdUeWR6JyxcbiAgYWxsRGF5VGV4dDogJ0NhxYJ5IGR6aWXFhCcsXG4gIG1vcmVMaW5rVGV4dDogJ3dpxJljZWonLFxuICBub0V2ZW50c1RleHQ6ICdCcmFrIHd5ZGFyemXFhCBkbyB3ecWbd2lldGxlbmlhJyxcbn07XG5cbnZhciBsNTcgPSB7XG4gIGNvZGU6ICdwdC1icicsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50ZXJpb3InLFxuICAgIG5leHQ6ICdQcsOzeGltbycsXG4gICAgdG9kYXk6ICdIb2plJyxcbiAgICBtb250aDogJ03DqnMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0RpYScsXG4gICAgbGlzdDogJ0xpc3RhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdTbScsXG4gIGFsbERheVRleHQ6ICdkaWEgaW50ZWlybycsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnbWFpcyArJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnTsOjbyBow6EgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGw1OCA9IHtcbiAgY29kZTogJ3B0JyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnQW50ZXJpb3InLFxuICAgIG5leHQ6ICdTZWd1aW50ZScsXG4gICAgdG9kYXk6ICdIb2plJyxcbiAgICBtb250aDogJ03DqnMnLFxuICAgIHdlZWs6ICdTZW1hbmEnLFxuICAgIGRheTogJ0RpYScsXG4gICAgbGlzdDogJ0FnZW5kYScsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU2VtJyxcbiAgYWxsRGF5VGV4dDogJ1RvZG8gbyBkaWEnLFxuICBtb3JlTGlua1RleHQ6ICdtYWlzJyxcbiAgbm9FdmVudHNUZXh0OiAnTsOjbyBow6EgZXZlbnRvcyBwYXJhIG1vc3RyYXInLFxufTtcblxudmFyIGw1OSA9IHtcbiAgY29kZTogJ3JvJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAncHJlY2VkZW50xIMnLFxuICAgIG5leHQ6ICd1cm3Eg3RvYXJlJyxcbiAgICB0b2RheTogJ0F6aScsXG4gICAgbW9udGg6ICdMdW7EgycsXG4gICAgd2VlazogJ1PEg3B0xINtw6JuxIMnLFxuICAgIGRheTogJ1ppJyxcbiAgICBsaXN0OiAnQWdlbmTEgycsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU8SDcHQnLFxuICBhbGxEYXlUZXh0OiAnVG9hdMSDIHppdWEnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJythbHRlICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ051IGV4aXN0xIMgZXZlbmltZW50ZSBkZSBhZmnImWF0Jyxcbn07XG5cbnZhciBsNjAgPSB7XG4gIGNvZGU6ICdydScsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9Cf0YDQtdC0JyxcbiAgICBuZXh0OiAn0KHQu9C10LQnLFxuICAgIHRvZGF5OiAn0KHQtdCz0L7QtNC90Y8nLFxuICAgIG1vbnRoOiAn0JzQtdGB0Y/RhicsXG4gICAgd2VlazogJ9Cd0LXQtNC10LvRjycsXG4gICAgZGF5OiAn0JTQtdC90YwnLFxuICAgIGxpc3Q6ICfQn9C+0LLQtdGB0YLQutCwINC00L3RjycsXG4gIH0sXG4gIHdlZWtUZXh0OiAn0J3QtdC0JyxcbiAgYWxsRGF5VGV4dDogJ9CS0LXRgdGMINC00LXQvdGMJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrINC10YnRkSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfQndC10YIg0YHQvtCx0YvRgtC40Lkg0LTQu9GPINC+0YLQvtCx0YDQsNC20LXQvdC40Y8nLFxufTtcblxudmFyIGw2MSA9IHtcbiAgY29kZTogJ3NrJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA0LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHJlZGNow6FkemFqw7pjaScsXG4gICAgbmV4dDogJ05hc2xlZHVqw7pjaScsXG4gICAgdG9kYXk6ICdEbmVzJyxcbiAgICBtb250aDogJ01lc2lhYycsXG4gICAgd2VlazogJ1TDvcW+ZGXFiCcsXG4gICAgZGF5OiAnRGXFiCcsXG4gICAgbGlzdDogJ1JvenZyaCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAnVHknLFxuICBhbGxEYXlUZXh0OiAnQ2Vsw70gZGXFiCcsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnK8SPYWzFoWllOiAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6ICfFvWlhZG5lIGFrY2llIG5hIHpvYnJhemVuaWUnLFxufTtcblxudmFyIGw2MiA9IHtcbiAgY29kZTogJ3NsJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnUHJlasWhbmppJyxcbiAgICBuZXh0OiAnTmFzbGVkbmppJyxcbiAgICB0b2RheTogJ1RyZW51dG5pJyxcbiAgICBtb250aDogJ01lc2VjJyxcbiAgICB3ZWVrOiAnVGVkZW4nLFxuICAgIGRheTogJ0RhbicsXG4gICAgbGlzdDogJ0RuZXZuaSByZWQnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1RlZGVuJyxcbiAgYWxsRGF5VGV4dDogJ1ZlcyBkYW4nLFxuICBtb3JlTGlua1RleHQ6ICd2ZcSNJyxcbiAgbm9FdmVudHNUZXh0OiAnTmkgZG9nb2Rrb3YgemEgcHJpa2F6Jyxcbn07XG5cbnZhciBsNjMgPSB7XG4gIGNvZGU6ICdzbScsXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAnVGFsdSBhaScsXG4gICAgbmV4dDogJ011bGltdWxpIGF0dScsXG4gICAgdG9kYXk6ICdBc28gbmVpJyxcbiAgICBtb250aDogJ01hc2luYScsXG4gICAgd2VlazogJ1ZhaWFzbycsXG4gICAgZGF5OiAnQXNvJyxcbiAgICBsaXN0OiAnRmFhc29sb2dhJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICdWYWlhc28nLFxuICBhbGxEYXlUZXh0OiAnQXNvIGF0b2EnLFxuICBtb3JlTGlua1RleHQ6ICdzaWxpIGF0dScsXG4gIG5vRXZlbnRzVGV4dDogJ0xlYWkgbmkgbWVhIG5hIHR1dHVwdScsXG59O1xuXG52YXIgbDY0ID0ge1xuICBjb2RlOiAnc3EnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdtYnJhcGEnLFxuICAgIG5leHQ6ICdQw6tycGFyYScsXG4gICAgdG9kYXk6ICdzb3QnLFxuICAgIG1vbnRoOiAnTXVhaicsXG4gICAgd2VlazogJ0phdsOrJyxcbiAgICBkYXk6ICdEaXTDqycsXG4gICAgbGlzdDogJ0xpc3TDqycsXG4gIH0sXG4gIHdlZWtUZXh0OiAnSmEnLFxuICBhbGxEYXlUZXh0OiAnR2ppdGjDqyBkaXTDq24nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyttw6sgdGVww6tyICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ051ayBrYSBldmVudGUgcMOrciB0w6sgc2hmYXF1cicsXG59O1xuXG52YXIgbDY1ID0ge1xuICBjb2RlOiAnc3ItY3lybCcsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNywgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gMXN0IGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ9Cf0YDQtdGC0YXQvtC00L3QsCcsXG4gICAgbmV4dDogJ9GB0LvQtdC00LXRm9C4JyxcbiAgICB0b2RheTogJ9CU0LDQvdCw0YEnLFxuICAgIG1vbnRoOiAn0JzQtdGB0LXRhicsXG4gICAgd2VlazogJ9Cd0LXQtNC10ZnQsCcsXG4gICAgZGF5OiAn0JTQsNC9JyxcbiAgICBsaXN0OiAn0J/Qu9Cw0L3QtdGAJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICfQodC10LQnLFxuICBhbGxEYXlUZXh0OiAn0KbQtdC+INC00LDQvScsXG4gIG1vcmVMaW5rVGV4dDogZnVuY3Rpb24obikge1xuICAgIHJldHVybiAnKyDRmNC+0YggJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn0J3QtdC80LAg0LTQvtCz0LDRktCw0ZjQsCDQt9CwINC/0YDQuNC60LDQtycsXG59O1xuXG52YXIgbDY2ID0ge1xuICBjb2RlOiAnc3InLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdQcmV0aG9kbmEnLFxuICAgIG5leHQ6ICdTbGVkZWPMgWknLFxuICAgIHRvZGF5OiAnRGFuYXMnLFxuICAgIG1vbnRoOiAnTdC1c9C1YycsXG4gICAgd2VlazogJ07QtWTQtWxqYScsXG4gICAgZGF5OiAnRGFuJyxcbiAgICBsaXN0OiAnUGxhbtC1cicsXG4gIH0sXG4gIHdlZWtUZXh0OiAnU2VkJyxcbiAgYWxsRGF5VGV4dDogJ0PQtW8gZGFuJyxcbiAgbW9yZUxpbmtUZXh0OiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICcrIGpvxaEgJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnTtC1bWEgZG9nYcSRYWphIHphIHByaWtheicsXG59O1xuXG52YXIgbDY3ID0ge1xuICBjb2RlOiAnc3YnLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdGw7ZycmEnLFxuICAgIG5leHQ6ICdOw6RzdGEnLFxuICAgIHRvZGF5OiAnSWRhZycsXG4gICAgbW9udGg6ICdNw6VuYWQnLFxuICAgIHdlZWs6ICdWZWNrYScsXG4gICAgZGF5OiAnRGFnJyxcbiAgICBsaXN0OiAnUHJvZ3JhbScsXG4gIH0sXG4gIHdlZWtUZXh0OiAndi4nLFxuICBhbGxEYXlUZXh0OiAnSGVsZGFnJyxcbiAgbW9yZUxpbmtUZXh0OiAndGlsbCcsXG4gIG5vRXZlbnRzVGV4dDogJ0luZ2EgaMOkbmRlbHNlciBhdHQgdmlzYScsXG59O1xuXG52YXIgbDY4ID0ge1xuICBjb2RlOiAndGEtaW4nLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfgrq7gr4Hgrqjgr43grqTgr4jgrq8nLFxuICAgIG5leHQ6ICfgroXgrp/gr4HgrqTgr43grqTgrqTgr4EnLFxuICAgIHRvZGF5OiAn4K6H4K6p4K+N4K6x4K+BJyxcbiAgICBtb250aDogJ+CuruCuvuCupOCuruCvjScsXG4gICAgd2VlazogJ+CuteCuvuCusOCuruCvjScsXG4gICAgZGF5OiAn4K6o4K6+4K6z4K+NJyxcbiAgICBsaXN0OiAn4K6k4K6/4K6p4K6a4K6w4K6/IOCuheCun+CvjeCun+CuteCuo+CviCcsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4K614K6+4K6w4K6u4K+NJyxcbiAgYWxsRGF5VGV4dDogJ+CuqOCuvuCus+CvjSDgrq7gr4HgrrTgr4HgrrXgrqTgr4Hgrq7gr40nLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysg4K6u4K+H4K6y4K+B4K6u4K+NICcgKyBuXG4gIH0sXG4gIG5vRXZlbnRzVGV4dDogJ+CuleCuvuCuo+CvjeCuquCuv+CuleCvjeCulSDgrqjgrr/grpXgrrTgr43grrXgr4HgrpXgrrPgr40g4K6H4K6y4K+N4K6y4K+IJyxcbn07XG5cbnZhciBsNjkgPSB7XG4gIGNvZGU6ICd0aCcsXG4gIHdlZWs6IHtcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ+C4geC5iOC4reC4meC4q+C4meC5ieC4sicsXG4gICAgbmV4dDogJ+C4luC4seC4lOC5hOC4mycsXG4gICAgcHJldlllYXI6ICfguJvguLXguIHguYjguK3guJnguKvguJnguYnguLInLFxuICAgIG5leHRZZWFyOiAn4Lib4Li14LiW4Lix4LiU4LmE4LibJyxcbiAgICB5ZWFyOiAn4Lib4Li1JyxcbiAgICB0b2RheTogJ+C4p+C4seC4meC4meC4teC5iScsXG4gICAgbW9udGg6ICfguYDguJTguLfguK3guJknLFxuICAgIHdlZWs6ICfguKrguLHguJvguJTguLLguKvguYwnLFxuICAgIGRheTogJ+C4p+C4seC4mScsXG4gICAgbGlzdDogJ+C4geC4s+C4q+C4meC4lOC4geC4suC4oycsXG4gIH0sXG4gIHdlZWtUZXh0OiAn4Liq4Lix4Lib4LiU4Liy4Lir4LmMJyxcbiAgYWxsRGF5VGV4dDogJ+C4leC4peC4reC4lOC4p+C4seC4mScsXG4gIG1vcmVMaW5rVGV4dDogJ+C5gOC4nuC4tOC5iOC4oeC5gOC4leC4tOC4oScsXG4gIG5vRXZlbnRzVGV4dDogJ+C5hOC4oeC5iOC4oeC4teC4geC4tOC4iOC4geC4o+C4o+C4oeC4l+C4teC5iOC4iOC4sOC5geC4quC4lOC4hycsXG59O1xuXG52YXIgbDcwID0ge1xuICBjb2RlOiAndHInLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDcsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdnZXJpJyxcbiAgICBuZXh0OiAnaWxlcmknLFxuICAgIHRvZGF5OiAnYnVnw7xuJyxcbiAgICBtb250aDogJ0F5JyxcbiAgICB3ZWVrOiAnSGFmdGEnLFxuICAgIGRheTogJ0fDvG4nLFxuICAgIGxpc3Q6ICdBamFuZGEnLFxuICB9LFxuICB3ZWVrVGV4dDogJ0hmJyxcbiAgYWxsRGF5VGV4dDogJ1TDvG0gZ8O8bicsXG4gIG1vcmVMaW5rVGV4dDogJ2RhaGEgZmF6bGEnLFxuICBub0V2ZW50c1RleHQ6ICdHw7ZzdGVyaWxlY2VrIGV0a2lubGlrIHlvaycsXG59O1xuXG52YXIgbDcxID0ge1xuICBjb2RlOiAndWcnLFxuICBidXR0b25UZXh0OiB7XG4gICAgbW9udGg6ICfYptin2YonLFxuICAgIHdlZWs6ICfavtuV2b7YqtuVJyxcbiAgICBkYXk6ICfZg9uI2YYnLFxuICAgIGxpc3Q6ICfZg9uI2YbYqtuV2LHYqtmJ2b4nLFxuICB9LFxuICBhbGxEYXlUZXh0OiAn2b7biNiq24jZhiDZg9uI2YYnLFxufTtcblxudmFyIGw3MiA9IHtcbiAgY29kZTogJ3VrJyxcbiAgd2Vlazoge1xuICAgIGRvdzogMSwgLy8gTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgZG95OiA3LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gIH0sXG4gIGJ1dHRvblRleHQ6IHtcbiAgICBwcmV2OiAn0J/QvtC/0LXRgNC10LTQvdGW0LknLFxuICAgIG5leHQ6ICfQtNCw0LvRlicsXG4gICAgdG9kYXk6ICfQodGM0L7Qs9C+0LTQvdGWJyxcbiAgICBtb250aDogJ9Cc0ZbRgdGP0YbRjCcsXG4gICAgd2VlazogJ9Ci0LjQttC00LXQvdGMJyxcbiAgICBkYXk6ICfQlNC10L3RjCcsXG4gICAgbGlzdDogJ9Cf0L7RgNGP0LTQvtC6INC00LXQvdC90LjQuScsXG4gIH0sXG4gIHdlZWtUZXh0OiAn0KLQuNC2JyxcbiAgYWxsRGF5VGV4dDogJ9Cj0LLQtdGB0Ywg0LTQtdC90YwnLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJyvRidC1ICcgKyBuICsgJy4uLidcbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAn0J3QtdC80LDRlCDQv9C+0LTRltC5INC00LvRjyDQstGW0LTQvtCx0YDQsNC20LXQvdC90Y8nLFxufTtcblxudmFyIGw3MyA9IHtcbiAgY29kZTogJ3V6JyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIG1vbnRoOiAnT3knLFxuICAgIHdlZWs6ICdYYWZ0YScsXG4gICAgZGF5OiAnS3VuJyxcbiAgICBsaXN0OiAnS3VuIHRhcnRpYmknLFxuICB9LFxuICBhbGxEYXlUZXh0OiBcIkt1biBibyd5aVwiLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgeWFuYSAnICsgblxuICB9LFxuICBub0V2ZW50c1RleHQ6IFwiS28ncnNhdGlzaCB1Y2h1biB2b3FlYWxhciB5bydxXCIsXG59O1xuXG52YXIgbDc0ID0ge1xuICBjb2RlOiAndmknLFxuICB3ZWVrOiB7XG4gICAgZG93OiAxLCAvLyBNb25kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3k6IDQsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDR0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgfSxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICdUcsaw4bubYycsXG4gICAgbmV4dDogJ1Rp4bq/cCcsXG4gICAgdG9kYXk6ICdIw7RtIG5heScsXG4gICAgbW9udGg6ICdUaMOhbmcnLFxuICAgIHdlZWs6ICdUdcOizIBuJyxcbiAgICBkYXk6ICdOZ8OgeScsXG4gICAgbGlzdDogJ0zhu4tjaCBiaeG7g3UnLFxuICB9LFxuICB3ZWVrVGV4dDogJ1R1JyxcbiAgYWxsRGF5VGV4dDogJ0PhuqMgbmfDoHknLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJysgdGjDqm0gJyArIG5cbiAgfSxcbiAgbm9FdmVudHNUZXh0OiAnS2jDtG5nIGPDsyBz4buxIGtp4buHbiDEkeG7gyBoaeG7g24gdGjhu4snLFxufTtcblxudmFyIGw3NSA9IHtcbiAgY29kZTogJ3poLWNuJyxcbiAgd2Vlazoge1xuICAgIC8vIEdCL1QgNzQwOC0xOTk044CK5pWw5o2u5YWD5ZKM5Lqk5o2i5qC85byPwrfkv6Hmga/kuqTmjaLCt+aXpeacn+WSjOaXtumXtOihqOekuuazleOAi+S4jklTTyA4NjAxOjE5ODjnrYnmlYhcbiAgICBkb3c6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveTogNCwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNHRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICB9LFxuICBidXR0b25UZXh0OiB7XG4gICAgcHJldjogJ+S4iuaciCcsXG4gICAgbmV4dDogJ+S4i+aciCcsXG4gICAgdG9kYXk6ICfku4rlpKknLFxuICAgIG1vbnRoOiAn5pyIJyxcbiAgICB3ZWVrOiAn5ZGoJyxcbiAgICBkYXk6ICfml6UnLFxuICAgIGxpc3Q6ICfml6XnqIsnLFxuICB9LFxuICB3ZWVrVGV4dDogJ+WRqCcsXG4gIGFsbERheVRleHQ6ICflhajlpKknLFxuICBtb3JlTGlua1RleHQ6IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gJ+WPpuWkliAnICsgbiArICcg5LiqJ1xuICB9LFxuICBub0V2ZW50c1RleHQ6ICfmsqHmnInkuovku7bmmL7npLonLFxufTtcblxudmFyIGw3NiA9IHtcbiAgY29kZTogJ3poLXR3JyxcbiAgYnV0dG9uVGV4dDoge1xuICAgIHByZXY6ICfkuIrmnIgnLFxuICAgIG5leHQ6ICfkuIvmnIgnLFxuICAgIHRvZGF5OiAn5LuK5aSpJyxcbiAgICBtb250aDogJ+aciCcsXG4gICAgd2VlazogJ+mAsScsXG4gICAgZGF5OiAn5aSpJyxcbiAgICBsaXN0OiAn5rS75YuV5YiX6KGoJyxcbiAgfSxcbiAgd2Vla1RleHQ6ICflkagnLFxuICBhbGxEYXlUZXh0OiAn5pW05aSpJyxcbiAgbW9yZUxpbmtUZXh0OiAn6aGv56S65pu05aSaJyxcbiAgbm9FdmVudHNUZXh0OiAn5rKh5pyJ5Lu75L2V5rS75YuVJyxcbn07XG5cbi8qIGVzbGludCBtYXgtbGVuOiBvZmYgKi9cblxudmFyIGxvY2FsZXNBbGwgPSBbXG4gIGwwLCBsMSwgbDIsIGwzLCBsNCwgbDUsIGw2LCBsNywgbDgsIGw5LCBsMTAsIGwxMSwgbDEyLCBsMTMsIGwxNCwgbDE1LCBsMTYsIGwxNywgbDE4LCBsMTksIGwyMCwgbDIxLCBsMjIsIGwyMywgbDI0LCBsMjUsIGwyNiwgbDI3LCBsMjgsIGwyOSwgbDMwLCBsMzEsIGwzMiwgbDMzLCBsMzQsIGwzNSwgbDM2LCBsMzcsIGwzOCwgbDM5LCBsNDAsIGw0MSwgbDQyLCBsNDMsIGw0NCwgbDQ1LCBsNDYsIGw0NywgbDQ4LCBsNDksIGw1MCwgbDUxLCBsNTIsIGw1MywgbDU0LCBsNTUsIGw1NiwgbDU3LCBsNTgsIGw1OSwgbDYwLCBsNjEsIGw2MiwgbDYzLCBsNjQsIGw2NSwgbDY2LCBsNjcsIGw2OCwgbDY5LCBsNzAsIGw3MSwgbDcyLCBsNzMsIGw3NCwgbDc1LCBsNzYsIFxuXTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbG9jYWxlc0FsbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/locales-all.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/main.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/main.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BASE_OPTION_DEFAULTS\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BASE_OPTION_DEFAULTS; },\n/* harmony export */   \"BASE_OPTION_REFINERS\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BASE_OPTION_REFINERS; },\n/* harmony export */   \"BaseComponent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent; },\n/* harmony export */   \"BgEvent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BgEvent; },\n/* harmony export */   \"CalendarApi\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarApi; },\n/* harmony export */   \"CalendarContent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarContent; },\n/* harmony export */   \"CalendarDataManager\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarDataManager; },\n/* harmony export */   \"CalendarDataProvider\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarDataProvider; },\n/* harmony export */   \"CalendarRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarRoot; },\n/* harmony export */   \"Component\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Component; },\n/* harmony export */   \"ContentHook\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ContentHook; },\n/* harmony export */   \"CustomContentRenderContext\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CustomContentRenderContext; },\n/* harmony export */   \"DateComponent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent; },\n/* harmony export */   \"DateEnv\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateEnv; },\n/* harmony export */   \"DateProfileGenerator\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateProfileGenerator; },\n/* harmony export */   \"DayCellContent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellContent; },\n/* harmony export */   \"DayCellRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellRoot; },\n/* harmony export */   \"DayHeader\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayHeader; },\n/* harmony export */   \"DaySeriesModel\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DaySeriesModel; },\n/* harmony export */   \"DayTableModel\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayTableModel; },\n/* harmony export */   \"DelayedRunner\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DelayedRunner; },\n/* harmony export */   \"ElementDragging\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ElementDragging; },\n/* harmony export */   \"ElementScrollController\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ElementScrollController; },\n/* harmony export */   \"Emitter\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Emitter; },\n/* harmony export */   \"EventApi\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventApi; },\n/* harmony export */   \"EventRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot; },\n/* harmony export */   \"EventSourceApi\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventSourceApi; },\n/* harmony export */   \"Fragment\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment; },\n/* harmony export */   \"Interaction\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Interaction; },\n/* harmony export */   \"MoreLinkRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MoreLinkRoot; },\n/* harmony export */   \"MountHook\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MountHook; },\n/* harmony export */   \"NamedTimeZoneImpl\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NamedTimeZoneImpl; },\n/* harmony export */   \"NowIndicatorRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowIndicatorRoot; },\n/* harmony export */   \"NowTimer\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer; },\n/* harmony export */   \"PositionCache\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache; },\n/* harmony export */   \"RefMap\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap; },\n/* harmony export */   \"RenderHook\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook; },\n/* harmony export */   \"ScrollController\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ScrollController; },\n/* harmony export */   \"ScrollResponder\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ScrollResponder; },\n/* harmony export */   \"Scroller\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Scroller; },\n/* harmony export */   \"SegHierarchy\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SegHierarchy; },\n/* harmony export */   \"SimpleScrollGrid\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SimpleScrollGrid; },\n/* harmony export */   \"Slicer\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Slicer; },\n/* harmony export */   \"Splitter\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Splitter; },\n/* harmony export */   \"StandardEvent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.StandardEvent; },\n/* harmony export */   \"TableDateCell\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.TableDateCell; },\n/* harmony export */   \"TableDowCell\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.TableDowCell; },\n/* harmony export */   \"Theme\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Theme; },\n/* harmony export */   \"ViewApi\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewApi; },\n/* harmony export */   \"ViewContextType\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewContextType; },\n/* harmony export */   \"ViewRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot; },\n/* harmony export */   \"WeekNumberRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WeekNumberRoot; },\n/* harmony export */   \"WindowScrollController\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WindowScrollController; },\n/* harmony export */   \"addDays\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays; },\n/* harmony export */   \"addDurations\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDurations; },\n/* harmony export */   \"addMs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addMs; },\n/* harmony export */   \"addWeeks\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks; },\n/* harmony export */   \"allowContextMenu\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.allowContextMenu; },\n/* harmony export */   \"allowSelection\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.allowSelection; },\n/* harmony export */   \"applyMutationToEventStore\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyMutationToEventStore; },\n/* harmony export */   \"applyStyle\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyStyle; },\n/* harmony export */   \"applyStyleProp\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyStyleProp; },\n/* harmony export */   \"asCleanDays\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asCleanDays; },\n/* harmony export */   \"asRoughMinutes\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMinutes; },\n/* harmony export */   \"asRoughMs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughMs; },\n/* harmony export */   \"asRoughSeconds\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.asRoughSeconds; },\n/* harmony export */   \"binarySearch\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.binarySearch; },\n/* harmony export */   \"buildClassNameNormalizer\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildClassNameNormalizer; },\n/* harmony export */   \"buildEntryKey\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey; },\n/* harmony export */   \"buildEventApis\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventApis; },\n/* harmony export */   \"buildEventRangeKey\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventRangeKey; },\n/* harmony export */   \"buildHashFromArray\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildHashFromArray; },\n/* harmony export */   \"buildIsoString\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildIsoString; },\n/* harmony export */   \"buildNavLinkData\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData; },\n/* harmony export */   \"buildSegCompareObj\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegCompareObj; },\n/* harmony export */   \"buildSegTimeText\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText; },\n/* harmony export */   \"collectFromHash\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.collectFromHash; },\n/* harmony export */   \"combineEventUis\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.combineEventUis; },\n/* harmony export */   \"compareByFieldSpec\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareByFieldSpec; },\n/* harmony export */   \"compareByFieldSpecs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareByFieldSpecs; },\n/* harmony export */   \"compareNumbers\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareNumbers; },\n/* harmony export */   \"compareObjs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.compareObjs; },\n/* harmony export */   \"computeEarliestSegStart\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeEarliestSegStart; },\n/* harmony export */   \"computeEdges\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeEdges; },\n/* harmony export */   \"computeFallbackHeaderFormat\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeFallbackHeaderFormat; },\n/* harmony export */   \"computeHeightAndMargins\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeHeightAndMargins; },\n/* harmony export */   \"computeInnerRect\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeInnerRect; },\n/* harmony export */   \"computeRect\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeRect; },\n/* harmony export */   \"computeSegDraggable\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSegDraggable; },\n/* harmony export */   \"computeSegEndResizable\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSegEndResizable; },\n/* harmony export */   \"computeSegStartResizable\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSegStartResizable; },\n/* harmony export */   \"computeShrinkWidth\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeShrinkWidth; },\n/* harmony export */   \"computeSmallestCellWidth\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeSmallestCellWidth; },\n/* harmony export */   \"computeVisibleDayRange\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.computeVisibleDayRange; },\n/* harmony export */   \"config\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.config; },\n/* harmony export */   \"constrainPoint\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.constrainPoint; },\n/* harmony export */   \"createContext\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createContext; },\n/* harmony export */   \"createDuration\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createDuration; },\n/* harmony export */   \"createElement\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement; },\n/* harmony export */   \"createEmptyEventStore\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createEmptyEventStore; },\n/* harmony export */   \"createEventInstance\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createEventInstance; },\n/* harmony export */   \"createEventUi\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createEventUi; },\n/* harmony export */   \"createFormatter\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter; },\n/* harmony export */   \"createPlugin\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin; },\n/* harmony export */   \"createPortal\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPortal; },\n/* harmony export */   \"createRef\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef; },\n/* harmony export */   \"diffDates\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDates; },\n/* harmony export */   \"diffDayAndTime\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDayAndTime; },\n/* harmony export */   \"diffDays\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffDays; },\n/* harmony export */   \"diffPoints\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffPoints; },\n/* harmony export */   \"diffWeeks\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWeeks; },\n/* harmony export */   \"diffWholeDays\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWholeDays; },\n/* harmony export */   \"diffWholeWeeks\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWholeWeeks; },\n/* harmony export */   \"disableCursor\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.disableCursor; },\n/* harmony export */   \"elementClosest\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.elementClosest; },\n/* harmony export */   \"elementMatches\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.elementMatches; },\n/* harmony export */   \"enableCursor\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.enableCursor; },\n/* harmony export */   \"eventTupleToStore\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.eventTupleToStore; },\n/* harmony export */   \"filterEventStoreDefs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.filterEventStoreDefs; },\n/* harmony export */   \"filterHash\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.filterHash; },\n/* harmony export */   \"findDirectChildren\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.findDirectChildren; },\n/* harmony export */   \"findElements\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.findElements; },\n/* harmony export */   \"flexibleCompare\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flexibleCompare; },\n/* harmony export */   \"flushToDom\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flushToDom; },\n/* harmony export */   \"formatDate\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatDate; },\n/* harmony export */   \"formatDayString\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatDayString; },\n/* harmony export */   \"formatIsoTimeString\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatIsoTimeString; },\n/* harmony export */   \"formatRange\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatRange; },\n/* harmony export */   \"getAllowYScrolling\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getAllowYScrolling; },\n/* harmony export */   \"getCanVGrowWithinCell\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getCanVGrowWithinCell; },\n/* harmony export */   \"getClippingParents\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getClippingParents; },\n/* harmony export */   \"getDateMeta\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDateMeta; },\n/* harmony export */   \"getDayClassNames\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDayClassNames; },\n/* harmony export */   \"getDefaultEventEnd\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDefaultEventEnd; },\n/* harmony export */   \"getElRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getElRoot; },\n/* harmony export */   \"getElSeg\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getElSeg; },\n/* harmony export */   \"getEntrySpanEnd\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEntrySpanEnd; },\n/* harmony export */   \"getEventClassNames\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEventClassNames; },\n/* harmony export */   \"getEventTargetViaRoot\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getEventTargetViaRoot; },\n/* harmony export */   \"getIsRtlScrollbarOnLeft\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getIsRtlScrollbarOnLeft; },\n/* harmony export */   \"getRectCenter\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getRectCenter; },\n/* harmony export */   \"getRelevantEvents\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getRelevantEvents; },\n/* harmony export */   \"getScrollGridClassNames\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getScrollGridClassNames; },\n/* harmony export */   \"getScrollbarWidths\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getScrollbarWidths; },\n/* harmony export */   \"getSectionClassNames\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSectionClassNames; },\n/* harmony export */   \"getSectionHasLiquidHeight\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSectionHasLiquidHeight; },\n/* harmony export */   \"getSegMeta\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta; },\n/* harmony export */   \"getSlotClassNames\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSlotClassNames; },\n/* harmony export */   \"getStickyFooterScrollbar\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyFooterScrollbar; },\n/* harmony export */   \"getStickyHeaderDates\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates; },\n/* harmony export */   \"getUnequalProps\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getUnequalProps; },\n/* harmony export */   \"globalLocales\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.globalLocales; },\n/* harmony export */   \"globalPlugins\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.globalPlugins; },\n/* harmony export */   \"greatestDurationDenominator\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.greatestDurationDenominator; },\n/* harmony export */   \"groupIntersectingEntries\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.groupIntersectingEntries; },\n/* harmony export */   \"guid\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.guid; },\n/* harmony export */   \"hasBgRendering\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.hasBgRendering; },\n/* harmony export */   \"hasShrinkWidth\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.hasShrinkWidth; },\n/* harmony export */   \"identity\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity; },\n/* harmony export */   \"interactionSettingsStore\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.interactionSettingsStore; },\n/* harmony export */   \"interactionSettingsToStore\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.interactionSettingsToStore; },\n/* harmony export */   \"intersectRanges\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges; },\n/* harmony export */   \"intersectRects\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRects; },\n/* harmony export */   \"intersectSpans\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectSpans; },\n/* harmony export */   \"isArraysEqual\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isArraysEqual; },\n/* harmony export */   \"isColPropsEqual\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isColPropsEqual; },\n/* harmony export */   \"isDateSelectionValid\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isDateSelectionValid; },\n/* harmony export */   \"isDateSpansEqual\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isDateSpansEqual; },\n/* harmony export */   \"isInt\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isInt; },\n/* harmony export */   \"isInteractionValid\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isInteractionValid; },\n/* harmony export */   \"isMultiDayRange\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isMultiDayRange; },\n/* harmony export */   \"isPropsEqual\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual; },\n/* harmony export */   \"isPropsValid\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsValid; },\n/* harmony export */   \"isValidDate\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isValidDate; },\n/* harmony export */   \"joinSpans\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.joinSpans; },\n/* harmony export */   \"listenBySelector\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.listenBySelector; },\n/* harmony export */   \"mapHash\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.mapHash; },\n/* harmony export */   \"memoize\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize; },\n/* harmony export */   \"memoizeArraylike\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoizeArraylike; },\n/* harmony export */   \"memoizeHashlike\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoizeHashlike; },\n/* harmony export */   \"memoizeObjArg\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoizeObjArg; },\n/* harmony export */   \"mergeEventStores\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.mergeEventStores; },\n/* harmony export */   \"multiplyDuration\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.multiplyDuration; },\n/* harmony export */   \"padStart\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.padStart; },\n/* harmony export */   \"parseBusinessHours\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseBusinessHours; },\n/* harmony export */   \"parseClassNames\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseClassNames; },\n/* harmony export */   \"parseDragMeta\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseDragMeta; },\n/* harmony export */   \"parseEventDef\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseEventDef; },\n/* harmony export */   \"parseFieldSpecs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseFieldSpecs; },\n/* harmony export */   \"parseMarker\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.parseMarker; },\n/* harmony export */   \"pointInsideRect\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.pointInsideRect; },\n/* harmony export */   \"preventContextMenu\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.preventContextMenu; },\n/* harmony export */   \"preventDefault\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.preventDefault; },\n/* harmony export */   \"preventSelection\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.preventSelection; },\n/* harmony export */   \"rangeContainsMarker\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangeContainsMarker; },\n/* harmony export */   \"rangeContainsRange\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangeContainsRange; },\n/* harmony export */   \"rangesEqual\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangesEqual; },\n/* harmony export */   \"rangesIntersect\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.rangesIntersect; },\n/* harmony export */   \"refineEventDef\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.refineEventDef; },\n/* harmony export */   \"refineProps\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.refineProps; },\n/* harmony export */   \"removeElement\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.removeElement; },\n/* harmony export */   \"removeExact\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.removeExact; },\n/* harmony export */   \"render\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.render; },\n/* harmony export */   \"renderChunkContent\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderChunkContent; },\n/* harmony export */   \"renderFill\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderFill; },\n/* harmony export */   \"renderMicroColGroup\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderMicroColGroup; },\n/* harmony export */   \"renderScrollShim\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim; },\n/* harmony export */   \"requestJson\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.requestJson; },\n/* harmony export */   \"sanitizeShrinkWidth\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sanitizeShrinkWidth; },\n/* harmony export */   \"setElSeg\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setElSeg; },\n/* harmony export */   \"setRef\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef; },\n/* harmony export */   \"sliceEventStore\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sliceEventStore; },\n/* harmony export */   \"sliceEvents\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sliceEvents; },\n/* harmony export */   \"sortEventSegs\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs; },\n/* harmony export */   \"startOfDay\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.startOfDay; },\n/* harmony export */   \"translateRect\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.translateRect; },\n/* harmony export */   \"triggerDateSelect\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.triggerDateSelect; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode; },\n/* harmony export */   \"unpromisify\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.unpromisify; },\n/* harmony export */   \"version\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.version; },\n/* harmony export */   \"whenTransitionDone\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.whenTransitionDone; },\n/* harmony export */   \"wholeDivideDurations\": function() { return /* reexport safe */ _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.wholeDivideDurations; },\n/* harmony export */   \"Calendar\": function() { return /* binding */ Calendar; }\n/* harmony export */ });\n/* harmony import */ var _vdom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vdom.js */ \"./node_modules/@fullcalendar/core/vdom.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n\n\nvar Calendar = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Calendar, _super);\n\n  function Calendar(el, optionOverrides) {\n    if (optionOverrides === void 0) {\n      optionOverrides = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.isRendering = false;\n    _this.isRendered = false;\n    _this.currentClassNames = [];\n    _this.customContentRenderId = 0; // will affect custom generated classNames?\n\n    _this.handleAction = function (action) {\n      // actions we know we want to render immediately\n      switch (action.type) {\n        case 'SET_EVENT_DRAG':\n        case 'SET_EVENT_RESIZE':\n          _this.renderRunner.tryDrain();\n\n      }\n    };\n\n    _this.handleData = function (data) {\n      _this.currentData = data;\n\n      _this.renderRunner.request(data.calendarOptions.rerenderDelay);\n    };\n\n    _this.handleRenderRequest = function () {\n      if (_this.isRendering) {\n        _this.isRendered = true;\n        var currentData_1 = _this.currentData;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.render)((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarRoot, {\n          options: currentData_1.calendarOptions,\n          theme: currentData_1.theme,\n          emitter: currentData_1.emitter\n        }, function (classNames, height, isHeightAuto, forPrint) {\n          _this.setClassNames(classNames);\n\n          _this.setHeight(height);\n\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CustomContentRenderContext.Provider, {\n            value: _this.customContentRenderId\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarContent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            isHeightAuto: isHeightAuto,\n            forPrint: forPrint\n          }, currentData_1)));\n        }), _this.el);\n      } else if (_this.isRendered) {\n        _this.isRendered = false;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.unmountComponentAtNode)(_this.el);\n\n        _this.setClassNames([]);\n\n        _this.setHeight('');\n      }\n\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flushToDom)();\n    };\n\n    _this.el = el;\n    _this.renderRunner = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DelayedRunner(_this.handleRenderRequest);\n    new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarDataManager({\n      optionOverrides: optionOverrides,\n      calendarApi: _this,\n      onAction: _this.handleAction,\n      onData: _this.handleData\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Calendar.prototype, \"view\", {\n    get: function get() {\n      return this.currentData.viewApi;\n    } // for public API\n    ,\n    enumerable: false,\n    configurable: true\n  });\n\n  Calendar.prototype.render = function () {\n    var wasRendering = this.isRendering;\n\n    if (!wasRendering) {\n      this.isRendering = true;\n    } else {\n      this.customContentRenderId += 1;\n    }\n\n    this.renderRunner.request();\n\n    if (wasRendering) {\n      this.updateSize();\n    }\n  };\n\n  Calendar.prototype.destroy = function () {\n    if (this.isRendering) {\n      this.isRendering = false;\n      this.renderRunner.request();\n    }\n  };\n\n  Calendar.prototype.updateSize = function () {\n    _super.prototype.updateSize.call(this);\n\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.flushToDom)();\n  };\n\n  Calendar.prototype.batchRendering = function (func) {\n    this.renderRunner.pause('batchRendering');\n    func();\n    this.renderRunner.resume('batchRendering');\n  };\n\n  Calendar.prototype.pauseRendering = function () {\n    this.renderRunner.pause('pauseRendering');\n  };\n\n  Calendar.prototype.resumeRendering = function () {\n    this.renderRunner.resume('pauseRendering', true);\n  };\n\n  Calendar.prototype.resetOptions = function (optionOverrides, append) {\n    this.currentDataManager.resetOptions(optionOverrides, append);\n  };\n\n  Calendar.prototype.setClassNames = function (classNames) {\n    if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isArraysEqual)(classNames, this.currentClassNames)) {\n      var classList = this.el.classList;\n\n      for (var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++) {\n        var className = _a[_i];\n        classList.remove(className);\n      }\n\n      for (var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++) {\n        var className = classNames_1[_b];\n        classList.add(className);\n      }\n\n      this.currentClassNames = classNames;\n    }\n  };\n\n  Calendar.prototype.setHeight = function (height) {\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.applyStyleProp)(this.el, 'height', height);\n  };\n\n  return Calendar;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.CalendarApi);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTUE7O0FBV0E7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBUEE7QUFDQTtBQUNBO0FBQ0E7O0FBa0JBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUhBO0FBS0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBOztBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFGQTtBQU9BO0FBSUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUF6REE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFNQTs7QUFkQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBZ0VBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUExSUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvQ2FsZW5kYXIudHN4PzUwMzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2FsZW5kYXJPcHRpb25zLCBBY3Rpb24sIENhbGVuZGFyQ29udGVudCwgcmVuZGVyLCBjcmVhdGVFbGVtZW50LCBEZWxheWVkUnVubmVyLCBDc3NEaW1WYWx1ZSwgYXBwbHlTdHlsZVByb3AsXG4gIENhbGVuZGFyQXBpLCBDYWxlbmRhclJvb3QsIGlzQXJyYXlzRXF1YWwsIENhbGVuZGFyRGF0YU1hbmFnZXIsIENhbGVuZGFyRGF0YSxcbiAgQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQsIGZsdXNoVG9Eb20sIHVubW91bnRDb21wb25lbnRBdE5vZGUsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXIgZXh0ZW5kcyBDYWxlbmRhckFwaSB7XG4gIGN1cnJlbnREYXRhOiBDYWxlbmRhckRhdGFcbiAgcmVuZGVyUnVubmVyOiBEZWxheWVkUnVubmVyXG4gIGVsOiBIVE1MRWxlbWVudFxuICBpc1JlbmRlcmluZyA9IGZhbHNlXG4gIGlzUmVuZGVyZWQgPSBmYWxzZVxuICBjdXJyZW50Q2xhc3NOYW1lczogc3RyaW5nW10gPSBbXVxuICBjdXN0b21Db250ZW50UmVuZGVySWQgPSAwIC8vIHdpbGwgYWZmZWN0IGN1c3RvbSBnZW5lcmF0ZWQgY2xhc3NOYW1lcz9cblxuICBnZXQgdmlldygpIHsgcmV0dXJuIHRoaXMuY3VycmVudERhdGEudmlld0FwaSB9IC8vIGZvciBwdWJsaWMgQVBJXG5cbiAgY29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25PdmVycmlkZXM6IENhbGVuZGFyT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5yZW5kZXJSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QpXG5cbiAgICBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICBjYWxlbmRhckFwaTogdGhpcyxcbiAgICAgIG9uQWN0aW9uOiB0aGlzLmhhbmRsZUFjdGlvbixcbiAgICAgIG9uRGF0YTogdGhpcy5oYW5kbGVEYXRhLFxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVBY3Rpb24gPSAoYWN0aW9uOiBBY3Rpb24pID0+IHtcbiAgICAvLyBhY3Rpb25zIHdlIGtub3cgd2Ugd2FudCB0byByZW5kZXIgaW1tZWRpYXRlbHlcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdTRVRfRVZFTlRfRFJBRyc6XG4gICAgICBjYXNlICdTRVRfRVZFTlRfUkVTSVpFJzpcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIudHJ5RHJhaW4oKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZURhdGEgPSAoZGF0YTogQ2FsZW5kYXJEYXRhKSA9PiB7XG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGFcbiAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KGRhdGEuY2FsZW5kYXJPcHRpb25zLnJlcmVuZGVyRGVsYXkpXG4gIH1cblxuICBoYW5kbGVSZW5kZXJSZXF1ZXN0ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICB0aGlzLmlzUmVuZGVyZWQgPSB0cnVlXG4gICAgICBsZXQgeyBjdXJyZW50RGF0YSB9ID0gdGhpc1xuXG4gICAgICByZW5kZXIoXG4gICAgICAgIDxDYWxlbmRhclJvb3Qgb3B0aW9ucz17Y3VycmVudERhdGEuY2FsZW5kYXJPcHRpb25zfSB0aGVtZT17Y3VycmVudERhdGEudGhlbWV9IGVtaXR0ZXI9e2N1cnJlbnREYXRhLmVtaXR0ZXJ9PlxuICAgICAgICAgIHsoY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoY2xhc3NOYW1lcylcbiAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodClcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZH0+XG4gICAgICAgICAgICAgICAgPENhbGVuZGFyQ29udGVudFxuICAgICAgICAgICAgICAgICAgaXNIZWlnaHRBdXRvPXtpc0hlaWdodEF1dG99XG4gICAgICAgICAgICAgICAgICBmb3JQcmludD17Zm9yUHJpbnR9XG4gICAgICAgICAgICAgICAgICB7Li4uY3VycmVudERhdGF9XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC9DdXN0b21Db250ZW50UmVuZGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9fVxuICAgICAgICA8L0NhbGVuZGFyUm9vdD4sXG4gICAgICAgIHRoaXMuZWwsXG4gICAgICApXG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmVuZGVyZWQpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IGZhbHNlXG4gICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlKHRoaXMuZWwpXG4gICAgICB0aGlzLnNldENsYXNzTmFtZXMoW10pXG4gICAgICB0aGlzLnNldEhlaWdodCgnJylcbiAgICB9XG5cbiAgICBmbHVzaFRvRG9tKClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgd2FzUmVuZGVyaW5nID0gdGhpcy5pc1JlbmRlcmluZ1xuXG4gICAgaWYgKCF3YXNSZW5kZXJpbmcpIHtcbiAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkICs9IDFcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KClcblxuICAgIGlmICh3YXNSZW5kZXJpbmcpIHtcbiAgICAgIHRoaXMudXBkYXRlU2l6ZSgpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlXG4gICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KClcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTaXplKCkge1xuICAgIHN1cGVyLnVwZGF0ZVNpemUoKVxuICAgIGZsdXNoVG9Eb20oKVxuICB9XG5cbiAgYmF0Y2hSZW5kZXJpbmcoZnVuYykge1xuICAgIHRoaXMucmVuZGVyUnVubmVyLnBhdXNlKCdiYXRjaFJlbmRlcmluZycpXG4gICAgZnVuYygpXG4gICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdiYXRjaFJlbmRlcmluZycpXG4gIH1cblxuICBwYXVzZVJlbmRlcmluZygpIHsgLy8gYXZhaWxhYmxlIHRvIHBsdWdpbnNcbiAgICB0aGlzLnJlbmRlclJ1bm5lci5wYXVzZSgncGF1c2VSZW5kZXJpbmcnKVxuICB9XG5cbiAgcmVzdW1lUmVuZGVyaW5nKCkgeyAvLyBhdmFpbGFibGUgdG8gcGx1Z2luc1xuICAgIHRoaXMucmVuZGVyUnVubmVyLnJlc3VtZSgncGF1c2VSZW5kZXJpbmcnLCB0cnVlKVxuICB9XG5cbiAgcmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgYXBwZW5kPykge1xuICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLnJlc2V0T3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGFwcGVuZClcbiAgfVxuXG4gIHNldENsYXNzTmFtZXMoY2xhc3NOYW1lczogc3RyaW5nW10pIHtcbiAgICBpZiAoIWlzQXJyYXlzRXF1YWwoY2xhc3NOYW1lcywgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykpIHtcbiAgICAgIGxldCB7IGNsYXNzTGlzdCB9ID0gdGhpcy5lbFxuXG4gICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcykge1xuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICAgICAgY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBjbGFzc05hbWVzXG4gICAgfVxuICB9XG5cbiAgc2V0SGVpZ2h0KGhlaWdodDogQ3NzRGltVmFsdWUpIHtcbiAgICBhcHBseVN0eWxlUHJvcCh0aGlzLmVsLCAnaGVpZ2h0JywgaGVpZ2h0KVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/core/vdom.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/core/vdom.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact/compat */ \"./node_modules/preact/compat/dist/compat.module.js\");\n\n\n\nvar globalObj = typeof globalThis !== 'undefined' ? globalThis : window; // // TODO: streamline when killing IE11 support\n\nif (globalObj.FullCalendarVDom) {\n  console.warn('FullCalendar VDOM already loaded');\n} else {\n  globalObj.FullCalendarVDom = {\n    Component: preact__WEBPACK_IMPORTED_MODULE_0__.Component,\n    createElement: preact__WEBPACK_IMPORTED_MODULE_0__.createElement,\n    render: preact__WEBPACK_IMPORTED_MODULE_0__.render,\n    createRef: preact__WEBPACK_IMPORTED_MODULE_0__.createRef,\n    Fragment: preact__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    createContext: createContext,\n    createPortal: preact_compat__WEBPACK_IMPORTED_MODULE_1__.createPortal,\n    flushToDom: flushToDom,\n    unmountComponentAtNode: unmountComponentAtNode\n  };\n} // HACKS...\n// TODO: lock version\n// TODO: link gh issues\n\n\nfunction flushToDom() {\n  var oldDebounceRendering = preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering; // orig\n\n  var callbackQ = [];\n\n  function execCallbackSync(callback) {\n    callbackQ.push(callback);\n  }\n\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = execCallbackSync;\n  preact__WEBPACK_IMPORTED_MODULE_0__.render(preact__WEBPACK_IMPORTED_MODULE_0__.createElement(FakeComponent, {}), document.createElement('div'));\n\n  while (callbackQ.length) {\n    callbackQ.shift()();\n  }\n\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.debounceRendering = oldDebounceRendering;\n}\n\nvar FakeComponent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(FakeComponent, _super);\n\n  function FakeComponent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  FakeComponent.prototype.render = function () {\n    return preact__WEBPACK_IMPORTED_MODULE_0__.createElement('div', {});\n  };\n\n  FakeComponent.prototype.componentDidMount = function () {\n    this.setState({});\n  };\n\n  return FakeComponent;\n}(preact__WEBPACK_IMPORTED_MODULE_0__.Component);\n\nfunction createContext(defaultValue) {\n  var ContextType = preact__WEBPACK_IMPORTED_MODULE_0__.createContext(defaultValue);\n  var origProvider = ContextType.Provider;\n\n  ContextType.Provider = function () {\n    var _this = this;\n\n    var isNew = !this.getChildContext;\n    var children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n\n    if (isNew) {\n      var subs_1 = [];\n\n      this.shouldComponentUpdate = function (_props) {\n        if (_this.props.value !== _props.value) {\n          subs_1.forEach(function (c) {\n            c.context = _props.value;\n            c.forceUpdate();\n          });\n        }\n      };\n\n      this.sub = function (c) {\n        subs_1.push(c);\n        var old = c.componentWillUnmount;\n\n        c.componentWillUnmount = function () {\n          subs_1.splice(subs_1.indexOf(c), 1);\n          old && old.call(c);\n        };\n      };\n    }\n\n    return children;\n  };\n\n  return ContextType;\n}\n\nfunction unmountComponentAtNode(node) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.render(null, node);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL3Zkb20uanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS92ZG9tLmpzPzU1NzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0ICogYXMgcHJlYWN0IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgKiBhcyBwcmVhY3RDb21wYXQgZnJvbSAncHJlYWN0L2NvbXBhdCc7XG5cbnZhciBnbG9iYWxPYmogPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogd2luZG93OyAvLyAvLyBUT0RPOiBzdHJlYW1saW5lIHdoZW4ga2lsbGluZyBJRTExIHN1cHBvcnRcbmlmIChnbG9iYWxPYmouRnVsbENhbGVuZGFyVkRvbSkge1xuICAgIGNvbnNvbGUud2FybignRnVsbENhbGVuZGFyIFZET00gYWxyZWFkeSBsb2FkZWQnKTtcbn1cbmVsc2Uge1xuICAgIGdsb2JhbE9iai5GdWxsQ2FsZW5kYXJWRG9tID0ge1xuICAgICAgICBDb21wb25lbnQ6IHByZWFjdC5Db21wb25lbnQsXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQ6IHByZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgICAgICByZW5kZXI6IHByZWFjdC5yZW5kZXIsXG4gICAgICAgIGNyZWF0ZVJlZjogcHJlYWN0LmNyZWF0ZVJlZixcbiAgICAgICAgRnJhZ21lbnQ6IHByZWFjdC5GcmFnbWVudCxcbiAgICAgICAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcbiAgICAgICAgY3JlYXRlUG9ydGFsOiBwcmVhY3RDb21wYXQuY3JlYXRlUG9ydGFsLFxuICAgICAgICBmbHVzaFRvRG9tOiBmbHVzaFRvRG9tLFxuICAgICAgICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiB1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuICAgIH07XG59XG4vLyBIQUNLUy4uLlxuLy8gVE9ETzogbG9jayB2ZXJzaW9uXG4vLyBUT0RPOiBsaW5rIGdoIGlzc3Vlc1xuZnVuY3Rpb24gZmx1c2hUb0RvbSgpIHtcbiAgICB2YXIgb2xkRGVib3VuY2VSZW5kZXJpbmcgPSBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZzsgLy8gb3JpZ1xuICAgIHZhciBjYWxsYmFja1EgPSBbXTtcbiAgICBmdW5jdGlvbiBleGVjQ2FsbGJhY2tTeW5jKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrUS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBleGVjQ2FsbGJhY2tTeW5jO1xuICAgIHByZWFjdC5yZW5kZXIocHJlYWN0LmNyZWF0ZUVsZW1lbnQoRmFrZUNvbXBvbmVudCwge30pLCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgd2hpbGUgKGNhbGxiYWNrUS5sZW5ndGgpIHtcbiAgICAgICAgY2FsbGJhY2tRLnNoaWZ0KCkoKTtcbiAgICB9XG4gICAgcHJlYWN0Lm9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBvbGREZWJvdW5jZVJlbmRlcmluZztcbn1cbnZhciBGYWtlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGYWtlQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZha2VDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRmFrZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHt9KTsgfTtcbiAgICBGYWtlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zZXRTdGF0ZSh7fSk7IH07XG4gICAgcmV0dXJuIEZha2VDb21wb25lbnQ7XG59KHByZWFjdC5Db21wb25lbnQpKTtcbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIENvbnRleHRUeXBlID0gcHJlYWN0LmNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlKTtcbiAgICB2YXIgb3JpZ1Byb3ZpZGVyID0gQ29udGV4dFR5cGUuUHJvdmlkZXI7XG4gICAgQ29udGV4dFR5cGUuUHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpc05ldyA9ICF0aGlzLmdldENoaWxkQ29udGV4dDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb3JpZ1Byb3ZpZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgICAgdmFyIHN1YnNfMSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAoX3Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnZhbHVlICE9PSBfcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic18xLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc3ViID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBzdWJzXzEucHVzaChjKTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcbiAgICAgICAgICAgICAgICBjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzXzEuc3BsaWNlKHN1YnNfMS5pbmRleE9mKGMpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZC5jYWxsKGMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0VHlwZTtcbn1cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUobm9kZSkge1xuICAgIHByZWFjdC5yZW5kZXIobnVsbCwgbm9kZSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/core/vdom.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.js":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DayGridView\": function() { return /* binding */ DayTableView; },\n/* harmony export */   \"DayTable\": function() { return /* binding */ DayTable; },\n/* harmony export */   \"DayTableSlicer\": function() { return /* binding */ DayTableSlicer; },\n/* harmony export */   \"Table\": function() { return /* binding */ Table; },\n/* harmony export */   \"TableView\": function() { return /* binding */ TableView; },\n/* harmony export */   \"buildDayTableModel\": function() { return /* binding */ buildDayTableModel; }\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/daygrid/main.css\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableView, _super);\n\n  function TableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.headerElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var sections = [];\n    var stickyHeaderDates = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunk: {\n        content: bodyContent\n      }\n    });\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    });\n  };\n\n  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var stickyHeaderDates = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyHeaderDates)(context.options);\n    var stickyFooterScrollbar = !props.forPrint && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getStickyFooterScrollbar)(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'main',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'main',\n        content: bodyContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'main',\n          content: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderScrollShim\n        }]\n      });\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  return TableView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i += 1) {\n    byRow[i] = [];\n  }\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    byRow[seg.row].push(seg);\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i += 1) {\n    byCol[i] = [];\n  }\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    byCol[seg.firstCol].push(seg);\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.row].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TableCellTop = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCellTop, _super);\n\n  function TableCellTop() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableCellTop.prototype.render = function () {\n    var props = this.props;\n    var navLinkAttrs = this.context.options.navLinks ? {\n      'data-navlink': (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData)(props.date),\n      tabIndex: 0\n    } : {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      defaultContent: renderTopInner\n    }, function (innerElRef, innerContent) {\n      return (innerContent || props.forceDayTop) && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-top\",\n        ref: innerElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        className: \"fc-daygrid-day-number\"\n      }, navLinkAttrs), innerContent || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xA0\")));\n    });\n  };\n\n  return TableCellTop;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText;\n}\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n  seg.isStart && // \"\n  seg.isEnd // \"\n  ;\n}\n\nvar TableBlockEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableBlockEvent, _super);\n\n  function TableBlockEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBlockEvent.prototype.render = function () {\n    var props = this.props;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.StandardEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, props, {\n      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n      defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n      disableResizing: !props.seg.eventRange.def.allDay\n    }));\n  };\n\n  return TableBlockEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nvar TableListItemEvent = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableListItemEvent, _super);\n\n  function TableListItemEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableListItemEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n    var timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot, {\n      seg: props.seg,\n      timeText: timeText,\n      defaultContent: renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (// we don't use styles!\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, getSegAnchorAttrs(props.seg)), innerContent)\n      );\n    });\n  };\n\n  return TableListItemEvent;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderInnerContent(innerProps) {\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-daygrid-event-dot\",\n    style: {\n      borderColor: innerProps.borderColor || innerProps.backgroundColor\n    }\n  }), innerProps.timeText && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n    className: \"fc-event-title\"\n  }, innerProps.event.title || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, \"\\xA0\")));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar TableCellMoreLink = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCellMoreLink, _super);\n\n  function TableCellMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.compileSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(compileSegs);\n    return _this;\n  }\n\n  TableCellMoreLink.prototype.render = function () {\n    var props = this.props;\n\n    var _a = this.compileSegs(props.singlePlacements),\n        allSegs = _a.allSegs,\n        invisibleSegs = _a.invisibleSegs;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.MoreLinkRoot, {\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      allDayDate: props.allDayDate,\n      moreCnt: props.moreCnt,\n      allSegs: allSegs,\n      hiddenSegs: invisibleSegs,\n      alignmentElRef: props.alignmentElRef,\n      alignGridTop: props.alignGridTop,\n      extraDateSpan: props.extraDateSpan,\n      popoverContent: function popoverContent() {\n        var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, allSegs.map(function (seg) {\n          var instanceId = seg.eventRange.instance.instanceId;\n          return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n            className: \"fc-daygrid-event-harness\",\n            key: instanceId,\n            style: {\n              visibility: isForcedInvisible[instanceId] ? 'hidden' : ''\n            }\n          }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === props.eventSelection,\n            defaultDisplayEventEnd: false\n          }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, props.todayRange))));\n        }));\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", {\n        ref: rootElRef,\n        className: ['fc-daygrid-more-link'].concat(classNames).join(' '),\n        onClick: handleClick\n      }, innerContent);\n    });\n  };\n\n  return TableCellMoreLink;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction compileSegs(singlePlacements) {\n  var allSegs = [];\n  var invisibleSegs = [];\n\n  for (var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++) {\n    var placement = singlePlacements_1[_i];\n    allSegs.push(placement.seg);\n\n    if (!placement.isVisible) {\n      invisibleSegs.push(placement.seg);\n    }\n  }\n\n  return {\n    allSegs: allSegs,\n    invisibleSegs: invisibleSegs\n  };\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n  week: 'narrow'\n});\n\nvar TableCell = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableCell, _super);\n\n  function TableCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n\n    _this.handleRootEl = function (el) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.rootElRef, el);\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.setRef)(_this.props.elRef, el);\n    };\n\n    return _this;\n  }\n\n  TableCell.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context,\n        rootElRef = _a.rootElRef;\n\n    var options = context.options;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var navLinkAttrs = options.navLinks ? {\n      'data-navlink': (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData)(date, 'week'),\n      tabIndex: 0\n    } : {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayCellRoot, {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      elRef: this.handleRootEl\n    }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n        ref: dayElRef,\n        className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')\n      }, rootDataAttrs, props.extraDataAttrs), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n        ref: props.innerElRef\n        /* different from hook system! RENAME */\n\n      }, props.showWeekNumber && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.WeekNumberRoot, {\n        date: date,\n        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n      }, function (weekElRef, weekClassNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          ref: weekElRef,\n          className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')\n        }, navLinkAttrs), innerContent);\n      }), !isDisabled && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellTop, {\n        date: date,\n        dateProfile: dateProfile,\n        showDayNumber: props.showDayNumber,\n        forceDayTop: props.forceDayTop,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      }), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-events\",\n        ref: props.fgContentElRef\n      }, props.fgContent, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-bottom\",\n        style: {\n          marginTop: props.moreMarginTop\n        }\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCellMoreLink, {\n        allDayDate: date,\n        singlePlacements: props.singlePlacements,\n        moreCnt: props.moreCnt,\n        alignmentElRef: rootElRef,\n        alignGridTop: !props.showDayNumber,\n        extraDateSpan: props.extraDateSpan,\n        dateProfile: props.dateProfile,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        todayRange: props.todayRange\n      }))), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-daygrid-day-bg\"\n      }, props.bgContent)));\n    });\n  };\n\n  return TableCell;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction computeFgSegPlacement(segs, // assumed already sorted\ndayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n  var hierarchy = new DayGridSegHierarchy();\n  hierarchy.allowReslicing = true;\n  hierarchy.strictOrder = strictOrder;\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    hierarchy.maxCoord = maxContentHeight;\n    hierarchy.hiddenConsumes = true;\n  } else if (typeof dayMaxEvents === 'number') {\n    hierarchy.maxStackCnt = dayMaxEvents;\n  } else if (typeof dayMaxEventRows === 'number') {\n    hierarchy.maxStackCnt = dayMaxEventRows;\n    hierarchy.hiddenConsumes = true;\n  } // create segInputs only for segs with known heights\n\n\n  var segInputs = [];\n  var unknownHeightSegs = [];\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventInstanceHeights[instanceId];\n\n    if (eventHeight != null) {\n      segInputs.push({\n        index: i,\n        thickness: eventHeight,\n        span: {\n          start: seg.firstCol,\n          end: seg.lastCol + 1\n        }\n      });\n    } else {\n      unknownHeightSegs.push(seg);\n    }\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var segRects = hierarchy.toRects();\n\n  var _a = placeRects(segRects, segs, cells),\n      singleColPlacements = _a.singleColPlacements,\n      multiColPlacements = _a.multiColPlacements,\n      leftoverMargins = _a.leftoverMargins;\n\n  var moreCnts = [];\n  var moreMarginTops = []; // add segs with unknown heights\n\n  for (var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++) {\n    var seg = unknownHeightSegs_1[_i];\n    multiColPlacements[seg.firstCol].push({\n      seg: seg,\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // add the hidden entries\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreCnts.push(0);\n  }\n\n  for (var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++) {\n    var hiddenEntry = hiddenEntries_1[_b];\n    var seg = segs[hiddenEntry.index];\n    var hiddenSpan = hiddenEntry.span;\n    multiColPlacements[hiddenSpan.start].push({\n      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n      isVisible: false,\n      isAbsolute: true,\n      absoluteTop: 0,\n      marginTop: 0\n    });\n\n    for (var col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {\n      moreCnts[col] += 1;\n      singleColPlacements[col].push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: false,\n        isAbsolute: false,\n        absoluteTop: 0,\n        marginTop: 0\n      });\n    }\n  } // deal with leftover margins\n\n\n  for (var col = 0; col < cells.length; col += 1) {\n    moreMarginTops.push(leftoverMargins[col]);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    moreCnts: moreCnts,\n    moreMarginTops: moreMarginTops\n  };\n} // rects ordered by top coord, then left\n\n\nfunction placeRects(allRects, segs, cells) {\n  var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n  var singleColPlacements = [];\n  var multiColPlacements = [];\n  var leftoverMargins = [];\n\n  for (var col = 0; col < cells.length; col += 1) {\n    var rects = rectsByEachCol[col]; // compute all static segs in singlePlacements\n\n    var singlePlacements = [];\n    var currentHeight = 0;\n    var currentMarginTop = 0;\n\n    for (var _i = 0, rects_1 = rects; _i < rects_1.length; _i++) {\n      var rect = rects_1[_i];\n      var seg = segs[rect.index];\n      singlePlacements.push({\n        seg: resliceSeg(seg, col, col + 1, cells),\n        isVisible: true,\n        isAbsolute: false,\n        absoluteTop: rect.levelCoord,\n        marginTop: rect.levelCoord - currentHeight\n      });\n      currentHeight = rect.levelCoord + rect.thickness;\n    } // compute mixed static/absolute segs in multiPlacements\n\n\n    var multiPlacements = [];\n    currentHeight = 0;\n    currentMarginTop = 0;\n\n    for (var _a = 0, rects_2 = rects; _a < rects_2.length; _a++) {\n      var rect = rects_2[_a];\n      var seg = segs[rect.index];\n      var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n\n      var isFirstCol = rect.span.start === col;\n      currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n\n      currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n\n      if (isAbsolute) {\n        currentMarginTop += rect.thickness;\n\n        if (isFirstCol) {\n          multiPlacements.push({\n            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: rect.levelCoord,\n            marginTop: 0\n          });\n        }\n      } else if (isFirstCol) {\n        multiPlacements.push({\n          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n          isVisible: true,\n          isAbsolute: false,\n          absoluteTop: rect.levelCoord,\n          marginTop: currentMarginTop // claim the margin\n\n        });\n        currentMarginTop = 0;\n      }\n    }\n\n    singleColPlacements.push(singlePlacements);\n    multiColPlacements.push(multiPlacements);\n    leftoverMargins.push(currentMarginTop);\n  }\n\n  return {\n    singleColPlacements: singleColPlacements,\n    multiColPlacements: multiColPlacements,\n    leftoverMargins: leftoverMargins\n  };\n}\n\nfunction groupRectsByEachCol(rects, colCnt) {\n  var rectsByEachCol = [];\n\n  for (var col = 0; col < colCnt; col += 1) {\n    rectsByEachCol.push([]);\n  }\n\n  for (var _i = 0, rects_3 = rects; _i < rects_3.length; _i++) {\n    var rect = rects_3[_i];\n\n    for (var col = rect.span.start; col < rect.span.end; col += 1) {\n      rectsByEachCol[col].push(rect);\n    }\n  }\n\n  return rectsByEachCol;\n}\n\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n    return seg;\n  }\n\n  var eventRange = seg.eventRange;\n  var origRange = eventRange.range;\n  var slicedRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges)(origRange, {\n    start: cells[spanStart].date,\n    end: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(cells[spanEnd - 1].date, 1)\n  });\n  return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, seg), {\n    firstCol: spanStart,\n    lastCol: spanEnd - 1,\n    eventRange: {\n      def: eventRange.def,\n      ui: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, eventRange.ui), {\n        durationEditable: false\n      }),\n      instance: eventRange.instance,\n      range: slicedRange\n    },\n    isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n    isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n  });\n}\n\nvar DayGridSegHierarchy = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayGridSegHierarchy, _super);\n\n  function DayGridSegHierarchy() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // config\n\n\n    _this.hiddenConsumes = false; // allows us to keep hidden entries in the hierarchy so they take up space\n\n    _this.forceHidden = {};\n    return _this;\n  }\n\n  DayGridSegHierarchy.prototype.addSegs = function (segInputs) {\n    var _this = this;\n\n    var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n\n    var entriesByLevel = this.entriesByLevel;\n\n    var excludeHidden = function excludeHidden(entry) {\n      return !_this.forceHidden[(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(entry)];\n    }; // remove the forced-hidden segs\n\n\n    for (var level = 0; level < entriesByLevel.length; level += 1) {\n      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n    }\n\n    return hiddenSegs;\n  };\n\n  DayGridSegHierarchy.prototype.handleInvalidInsertion = function (insertion, entry, hiddenEntries) {\n    var _a = this,\n        entriesByLevel = _a.entriesByLevel,\n        forceHidden = _a.forceHidden;\n\n    var touchingEntry = insertion.touchingEntry,\n        touchingLevel = insertion.touchingLevel,\n        touchingLateral = insertion.touchingLateral;\n\n    if (this.hiddenConsumes && touchingEntry) {\n      var touchingEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(touchingEntry); // if not already hidden\n\n      if (!forceHidden[touchingEntryId]) {\n        if (this.allowReslicing) {\n          var placeholderEntry = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, touchingEntry), {\n            span: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectSpans)(touchingEntry.span, entry.span)\n          });\n\n          var placeholderEntryId = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEntryKey)(placeholderEntry);\n          forceHidden[placeholderEntryId] = true;\n          entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n\n          this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n        } else {\n          forceHidden[touchingEntryId] = true;\n          hiddenEntries.push(touchingEntry);\n        }\n      }\n    }\n\n    return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n  };\n\n  return DayGridSegHierarchy;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.SegHierarchy);\n\nvar TableRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableRow, _super);\n\n  function TableRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the <td>\n\n    _this.frameElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the fc-daygrid-day-frame\n\n    _this.fgElRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // the fc-daygrid-day-events\n\n    _this.segHarnessRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap(); // indexed by \"instanceId:firstCol\"\n\n    _this.rootElRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      eventInstanceHeights: {}\n    };\n    return _this;\n  }\n\n  TableRow.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var colCnt = props.cells.length;\n    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n    var _b = computeFgSegPlacement((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs)(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells),\n        singleColPlacements = _b.singleColPlacements,\n        multiColPlacements = _b.multiColPlacements,\n        moreCnts = _b.moreCnts,\n        moreMarginTops = _b.moreMarginTops;\n\n    var isForcedInvisible = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n      ref: this.rootElRef\n    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n      var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n\n      var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableCell, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        innerElRef: _this.frameElRefs.createRef(cell.key)\n        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n        ,\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        showDayNumber: props.showDayNumbers,\n        showWeekNumber: props.showWeekNumbers && col === 0,\n        forceDayTop: props.showWeekNumbers\n        /* even displaying weeknum for row, not necessarily day */\n        ,\n        todayRange: props.todayRange,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        extraDateSpan: cell.extraDateSpan,\n        moreCnt: moreCnts[col],\n        moreMarginTop: moreMarginTops[col],\n        singlePlacements: singleColPlacements[col],\n        fgContentElRef: _this.fgElRefs.createRef(cell.key),\n        fgContent: // Fragment scopes the keys\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, normalFgNodes), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, mirrorFgNodes)),\n        bgContent: // Fragment scopes the keys\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n      });\n    }));\n  };\n\n  TableRow.prototype.componentDidMount = function () {\n    this.updateSizing(true);\n  };\n\n  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var currentProps = this.props;\n    this.updateSizing(!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual)(prevProps, currentProps));\n  };\n\n  TableRow.prototype.getHighlightSegs = function () {\n    var props = this.props;\n\n    if (props.eventDrag && props.eventDrag.segs.length) {\n      // messy check\n      return props.eventDrag.segs;\n    }\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return props.dateSelectionSegs;\n  };\n\n  TableRow.prototype.getMirrorSegs = function () {\n    var props = this.props;\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return [];\n  };\n\n  TableRow.prototype.renderFgSegs = function (col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    var context = this.context;\n    var eventSelection = this.props.eventSelection;\n    var framePositions = this.state.framePositions;\n    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++) {\n        var placement = segPlacements_1[_i];\n        var seg = placement.seg;\n        var instanceId = seg.eventRange.instance.instanceId;\n        var key = instanceId + ':' + col;\n        var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n        var isAbsolute = placement.isAbsolute;\n        var left = '';\n        var right = '';\n\n        if (isAbsolute) {\n          if (context.isRtl) {\n            right = 0;\n            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n          } else {\n            left = 0;\n            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n          }\n        }\n        /*\n        known bug: events that are force to be list-item but span multiple days still take up space in later columns\n        todo: in print view, for multi-day events, don't display title within non-start/end segs\n        */\n\n\n        nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n          key: key,\n          ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n          style: {\n            visibility: isVisible ? '' : 'hidden',\n            marginTop: isAbsolute ? '' : placement.marginTop,\n            top: isAbsolute ? placement.absoluteTop : '',\n            left: left,\n            right: right\n          }\n        }, hasListItemDisplay(seg) ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableListItemEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          seg: seg,\n          isDragging: isDragging,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableBlockEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange)))));\n      }\n    }\n\n    return nodes;\n  };\n\n  TableRow.prototype.renderFillSegs = function (segs, fillType) {\n    var isRtl = this.context.isRtl;\n    var todayRange = this.props.todayRange;\n    var framePositions = this.state.framePositions;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        var leftRightCss = isRtl ? {\n          right: 0,\n          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n        } : {\n          left: 0,\n          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n        };\n        nodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n          key: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildEventRangeKey)(seg.eventRange),\n          className: \"fc-daygrid-bg-harness\",\n          style: leftRightCss\n        }, fillType === 'bg-event' ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BgEvent, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          seg: seg\n        }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange))) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.renderFill)(fillType)));\n      }\n    }\n\n    return _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__spreadArray)([_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, {}], nodes));\n  };\n\n  TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n    var _a = this,\n        props = _a.props,\n        frameElRefs = _a.frameElRefs;\n\n    if (!props.forPrint && props.clientWidth !== null // positioning ready?\n    ) {\n      if (isExternalSizingChange) {\n        var frameEls = props.cells.map(function (cell) {\n          return frameElRefs.currentMap[cell.key];\n        });\n\n        if (frameEls.length) {\n          var originEl = this.rootElRef.current;\n          this.setState({\n            framePositions: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(originEl, frameEls, true, // isHorizontal\n            false)\n          });\n        }\n      }\n\n      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n      this.setState({\n        eventInstanceHeights: this.queryEventInstanceHeights(),\n        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n      });\n    }\n  };\n\n  TableRow.prototype.queryEventInstanceHeights = function () {\n    var segElMap = this.segHarnessRefs.currentMap;\n    var eventInstanceHeights = {}; // get the max height amongst instance segs\n\n    for (var key in segElMap) {\n      var height = Math.round(segElMap[key].getBoundingClientRect().height);\n      var instanceId = key.split(':')[0]; // deconstruct how renderFgSegs makes the key\n\n      eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n    }\n\n    return eventInstanceHeights;\n  };\n\n  TableRow.prototype.computeMaxContentHeight = function () {\n    var firstKey = this.props.cells[0].key;\n    var cellEl = this.cellElRefs.currentMap[firstKey];\n    var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n  };\n\n  TableRow.prototype.getCellEls = function () {\n    var elMap = this.cellElRefs.currentMap;\n    return this.props.cells.map(function (cell) {\n      return elMap[cell.key];\n    });\n  };\n\n  return TableRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nTableRow.addStateEquality({\n  eventInstanceHeights: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n  if (!mirrorSegs.length) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      isVisible: true,\n      isAbsolute: true,\n      absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n      marginTop: 0\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(colPlacements) {\n  var topsByInstanceId = {};\n\n  for (var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++) {\n    var placements = colPlacements_1[_i];\n\n    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n      var placement = placements_1[_a];\n      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n    }\n  }\n\n  return topsByInstanceId;\n}\n\nvar Table = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(Table, _super);\n\n  function Table() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitBusinessHourSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitBgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitFgEventSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitDateSelectionSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitSegsByRow);\n    _this.splitEventDrag = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByRow);\n    _this.splitEventResize = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(splitInteractionByRow);\n    _this.rowRefs = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RefMap();\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl,\n          isHitComboAllowed: _this.props.isHitComboAllowed\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  Table.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var dateProfile = props.dateProfile,\n        dayMaxEventRows = props.dayMaxEventRows,\n        dayMaxEvents = props.dayMaxEvents,\n        expandRows = props.expandRows;\n    var rowCnt = props.cells.length;\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n    // TODO: best place to normalize these options?\n\n    if (limitViaBalanced && !expandRows) {\n      limitViaBalanced = false;\n      dayMaxEventRows = null;\n      dayMaxEvents = null;\n    }\n\n    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural' // will height of one row depend on the others?\n    ];\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n      className: classNames.join(' '),\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n          height: expandRows ? props.clientHeight : ''\n        }\n      }, props.colGroupNode, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, props.cells.map(function (cells, row) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(TableRow, {\n          ref: _this.rowRefs.createRef(row),\n          key: cells.length ? cells[0].date.toISOString()\n          /* best? or put key on cell? or use diff formatter? */\n          : row // in case there are no cells (like when resource view is loading)\n          ,\n          showDayNumbers: rowCnt > 1,\n          showWeekNumbers: props.showWeekNumbers,\n          todayRange: todayRange,\n          dateProfile: dateProfile,\n          cells: cells,\n          renderIntro: props.renderRowIntro,\n          businessHourSegs: businessHourSegsByRow[row],\n          eventSelection: props.eventSelection,\n          bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)\n          /* hack */\n          ,\n          fgEventSegs: fgEventSegsByRow[row],\n          dateSelectionSegs: dateSelectionSegsByRow[row],\n          eventDrag: eventDragByRow[row],\n          eventResize: eventResizeByRow[row],\n          dayMaxEvents: dayMaxEvents,\n          dayMaxEventRows: dayMaxEventRows,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          forPrint: props.forPrint\n        });\n      }))));\n    }));\n  }; // Hit System\n  // ----------------------------------------------------------------------------------------------------\n\n\n  Table.prototype.prepareHits = function () {\n    this.rowPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n      return rowObj.getCellEls()[0];\n    }), // first cell el in each row. TODO: not optimal\n    false, true);\n    this.colPositions = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n    true, // horizontal\n    false);\n  };\n\n  Table.prototype.queryHit = function (positionLeft, positionTop) {\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(positionLeft);\n    var row = rowPositions.topToIndex(positionTop);\n\n    if (row != null && col != null) {\n      var cell = this.props.cells[row][col];\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n          range: this.getCellRange(row, col),\n          allDay: true\n        }, cell.extraDateSpan),\n        dayEl: this.getCellEl(row, col),\n        rect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  Table.prototype.getCellEl = function (row, col) {\n    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n  };\n\n  Table.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return Table;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction isSegAllDay(seg) {\n  return seg.eventRange.def.allDay;\n}\n\nvar DayTableSlicer = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTableSlicer, _super);\n\n  function DayTableSlicer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.forceDayIfListItem = true;\n    return _this;\n  }\n\n  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n    return dayTableModel.sliceRange(dateRange);\n  };\n\n  return DayTableSlicer;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Slicer);\n\nvar DayTable = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTable, _super);\n\n  function DayTable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new DayTableSlicer();\n    _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  DayTable.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(Table, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      ref: this.tableRef\n    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n      dateProfile: props.dateProfile,\n      cells: props.dayTableModel.cells,\n      colGroupNode: props.colGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      renderRowIntro: props.renderRowIntro,\n      dayMaxEvents: props.dayMaxEvents,\n      dayMaxEventRows: props.dayMaxEventRows,\n      showWeekNumbers: props.showWeekNumbers,\n      expandRows: props.expandRows,\n      headerAlignElRef: props.headerAlignElRef,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: props.forPrint\n    }));\n  };\n\n  return DayTable;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nvar DayTableView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(DayTableView, _super);\n\n  function DayTableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTableModel = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(buildDayTableModel);\n    _this.headerRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    _this.tableRef = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    return _this;\n  }\n\n  DayTableView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n    var headerContent = options.dayHeaders && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayHeader, {\n      ref: this.headerRef,\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: dayTableModel.rowCnt === 1\n    });\n\n    var bodyContent = function bodyContent(contentArg) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(DayTable, {\n        ref: _this.tableRef,\n        dateProfile: props.dateProfile,\n        dayTableModel: dayTableModel,\n        businessHours: props.businessHours,\n        dateSelection: props.dateSelection,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        nextDayThreshold: options.nextDayThreshold,\n        colGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        dayMaxEvents: options.dayMaxEvents,\n        dayMaxEventRows: options.dayMaxEventRows,\n        showWeekNumbers: options.weekNumbers,\n        expandRows: !props.isHeightAuto,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      });\n    };\n\n    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n  };\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar TableDateProfileGenerator = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(TableDateProfileGenerator, _super);\n\n  function TableDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.props.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.props.monthMode && this.props.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.diffWeeks)(start, end));\n      end = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addWeeks)(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return TableDateProfileGenerator;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateProfileGenerator);\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n  initialView: 'dayGridMonth',\n  views: {\n    dayGrid: {\n      component: DayTableView,\n      dateProfileGeneratorClass: TableDateProfileGenerator\n    },\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7O0FBRUE7QUFDQTs7O0FBRUE7O0FBQUE7QUFBQTs7QUFDQTs7QUFrSEE7O0FBaEhBO0FBSUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFKQTtBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBSEE7QUFJQTtBQUpBO0FBT0E7QUFHQTs7QUFFQTtBQU1BOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFKQTtBQVdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFKQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFKQTtBQVNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFPQTtBQUdBOztBQUNBO0FBbkhBOztBQ2JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FDdENBO0FBQUE7O0FBQUE7O0FBNkJBOztBQTVCQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBS0E7QUFHQTs7QUFDQTtBQTdCQTs7QUErQkE7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUxBO0FBT0E7O0FDYkE7QUFBQTs7QUFBQTs7QUFjQTs7QUFiQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7O0FBQ0E7QUFkQTs7QUNNQTtBQUFBOztBQUFBOztBQXFDQTs7QUFwQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFEQTtBQVFBO0FBR0E7O0FBQ0E7QUFyQ0E7O0FBdUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBS0E7QUFBQTtBQUVBO0FBQUE7QUFLQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FDdENBO0FBQUE7O0FBQUE7QUFBQTs7QUFDQTs7QUF3RUE7O0FBdEVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFIQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVlBO0FBR0E7QUFuREE7QUFxREE7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU9BO0FBR0E7O0FBQ0E7QUF6RUE7O0FBMkVBO0FBSUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUNoRkE7QUFBQTtBQUFBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTs7QUFDQTs7QUFpRkE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQW5GQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBRUE7QUFDQTtBQUZBO0FBTUE7QUFBQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFPQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBVUE7QUFDQTtBQUZBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQWVBO0FBQUE7QUFLQTtBQUdBOztBQU1BO0FBdEZBOztBQ3pCQTtBQUVBO0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUxBO0FBT0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFWQTtBQVlBOztBQUVBO0FBQUE7O0FBQUE7QUFBQTs7O0FBRUE7O0FBR0E7O0FBeUNBOztBQXZDQTtBQUFBOztBQUNBOztBQUNBOztBQUNBO0FBQUE7QUFBQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFEQTs7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQTlDQTs7QUMzTEE7QUFBQTs7QUFBQTtBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUErU0E7O0FBelNBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFDQTtBQUlBO0FBQ0E7QUFBQTtBQUdBOztBQU9BOztBQVVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVJBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUE1QkE7QUFvQ0E7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUpBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBWUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRkE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFBQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUxBO0FBUUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBdFRBOztBQXdUQTtBQUNBO0FBREE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FDOVZBOztBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBNkZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUEyREE7O0FBL0pBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQU1BO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSkE7QUFIQTtBQVVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBVUE7QUFFQTtBQUNBO0FBRUE7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFmQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEwQkE7QUFJQTtBQUlBOzs7O0FBa0JBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBZEE7QUFnQkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQTNLQTs7QUE2S0E7QUFDQTtBQUNBOzs7QUMxTkE7O0FBQUE7QUFBQTs7QUFDQTs7QUFLQTs7QUFIQTtBQUNBO0FBQ0E7O0FBQ0E7QUFOQTs7O0FDc0NBOztBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUF5QkE7O0FBdkJBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBRUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFnQkE7O0FBQ0E7QUEzQkE7OztBQzVCQTs7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUE4Q0E7O0FBNUNBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFRQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBdUJBOztBQUVBO0FBR0E7O0FBQ0E7QUFqREE7O0FBbURBO0FBQ0E7QUFFQTtBQUlBOztBQ2pFQTtBQUFBOztBQUFBOztBQWlDQTs7O0FBL0JBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQWpDQTs7QUNPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSkE7QUFqQkE7QUFGQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9UYWJsZVZpZXcudHN4P2M2NDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlU2VnLnRzP2UzYzkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlQ2VsbFRvcC50c3g/YzFlMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZXZlbnQtcmVuZGVyaW5nLnRzP2JjYmEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlQmxvY2tFdmVudC50c3g/MzIwZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVGFibGVMaXN0SXRlbUV2ZW50LnRzeD8wZTJkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9UYWJsZUNlbGxNb3JlTGluay50c3g/MTM1ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVGFibGVDZWxsLnRzeD8xNDNjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudC1wbGFjZW1lbnQudHM/Njk1NyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVGFibGVSb3cudHN4Pzk0NmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1RhYmxlLnRzeD81NDE3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9EYXlUYWJsZVNsaWNlci50c3g/NDdlMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvRGF5VGFibGUudHN4PzI4NDYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL0RheVRhYmxlVmlldy50c3g/NzY2OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvci50cz9jZGRiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9tYWluLnRzP2I5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgVk5vZGUsIGNyZWF0ZUVsZW1lbnQsXG4gIFNpbXBsZVNjcm9sbEdyaWQsXG4gIFNpbXBsZVNjcm9sbEdyaWRTZWN0aW9uLFxuICBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MsXG4gIGNyZWF0ZVJlZixcbiAgU2Nyb2xsR3JpZFNlY3Rpb25Db25maWcsXG4gIFZpZXdSb290LFxuICBEYXRlQ29tcG9uZW50LFxuICBWaWV3UHJvcHMsXG4gIFJlZk9iamVjdCxcbiAgcmVuZGVyU2Nyb2xsU2hpbSxcbiAgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsXG4gIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcixcbiAgQ2h1bmtDb25maWdSb3dDb250ZW50LFxuICBEaWN0aW9uYXJ5LFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBkYXlncmlkIHZpZXdzLCBhcyB3ZWxsIGFzIG1vbnRoIHZpZXcuIFJlbmRlcnMgb25lIG9yIG1vcmUgcm93cyBvZiBkYXkgY2VsbHMuXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBUYWJsZSBzdWJjb21wb25lbnQsIHdoaWNoIGRvZXMgbW9zdCBvZiB0aGUgaGVhdnkgbGlmdGluZy5cbi8vIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBtYW5hZ2luZyB3aWR0aC9oZWlnaHQuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUYWJsZVZpZXc8U3RhdGU9RGljdGlvbmFyeT4gZXh0ZW5kcyBEYXRlQ29tcG9uZW50PFZpZXdQcm9wcywgU3RhdGU+IHtcbiAgcHJvdGVjdGVkIGhlYWRlckVsUmVmOiBSZWZPYmplY3Q8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+ID0gY3JlYXRlUmVmPEhUTUxUYWJsZUNlbGxFbGVtZW50PigpXG5cbiAgcmVuZGVyU2ltcGxlTGF5b3V0KFxuICAgIGhlYWRlclJvd0NvbnRlbnQ6IENodW5rQ29uZmlnUm93Q29udGVudCxcbiAgICBib2R5Q29udGVudDogKGNvbnRlbnRBcmc6IENodW5rQ29udGVudENhbGxiYWNrQXJncykgPT4gVk5vZGUsXG4gICkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHNlY3Rpb25zOiBTaW1wbGVTY3JvbGxHcmlkU2VjdGlvbltdID0gW11cbiAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSBnZXRTdGlja3lIZWFkZXJEYXRlcyhjb250ZXh0Lm9wdGlvbnMpXG5cbiAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgIGtleTogJ2JvZHknLFxuICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxWaWV3Um9vdCB2aWV3U3BlYz17Y29udGV4dC52aWV3U3BlY30+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzKSA9PiAoXG4gICAgICAgICAgPGRpdiByZWY9e3Jvb3RFbFJlZn0gY2xhc3NOYW1lPXtbJ2ZjLWRheWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfT5cbiAgICAgICAgICAgIDxTaW1wbGVTY3JvbGxHcmlkXG4gICAgICAgICAgICAgIGxpcXVpZD17IXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnR9XG4gICAgICAgICAgICAgIGNvbGxhcHNpYmxlV2lkdGg9e3Byb3BzLmZvclByaW50fVxuICAgICAgICAgICAgICBjb2xzPXtbXSAvKiBUT0RPOiBtYWtlIG9wdGlvbmFsPyAqL31cbiAgICAgICAgICAgICAgc2VjdGlvbnM9e3NlY3Rpb25zfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvVmlld1Jvb3Q+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVySFNjcm9sbExheW91dChcbiAgICBoZWFkZXJSb3dDb250ZW50OiBDaHVua0NvbmZpZ1Jvd0NvbnRlbnQsXG4gICAgYm9keUNvbnRlbnQ6IChjb250ZW50QXJnOiBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MpID0+IFZOb2RlLFxuICAgIGNvbENudDogbnVtYmVyLFxuICAgIGRheU1pbldpZHRoOiBudW1iZXIsXG4gICkge1xuICAgIGxldCBTY3JvbGxHcmlkID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLnNjcm9sbEdyaWRJbXBsXG5cbiAgICBpZiAoIVNjcm9sbEdyaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gU2Nyb2xsR3JpZCBpbXBsZW1lbnRhdGlvbicpXG4gICAgfVxuXG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgc3RpY2t5SGVhZGVyRGF0ZXMgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKVxuICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucylcbiAgICBsZXQgc2VjdGlvbnM6IFNjcm9sbEdyaWRTZWN0aW9uQ29uZmlnW10gPSBbXVxuXG4gICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgZWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsXG4gICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICB9XSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICB0eXBlOiAnYm9keScsXG4gICAgICBrZXk6ICdib2R5JyxcbiAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgIGNodW5rczogW3tcbiAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgIGNvbnRlbnQ6IGJvZHlDb250ZW50LFxuICAgICAgfV0sXG4gICAgfSlcblxuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICB0eXBlOiAnZm9vdGVyJyxcbiAgICAgICAga2V5OiAnZm9vdGVyJyxcbiAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgIGNodW5rczogW3tcbiAgICAgICAgICBrZXk6ICdtYWluJyxcbiAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICB9XSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxWaWV3Um9vdCB2aWV3U3BlYz17Y29udGV4dC52aWV3U3BlY30+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzKSA9PiAoXG4gICAgICAgICAgPGRpdiByZWY9e3Jvb3RFbFJlZn0gY2xhc3NOYW1lPXtbJ2ZjLWRheWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfT5cbiAgICAgICAgICAgIDxTY3JvbGxHcmlkXG4gICAgICAgICAgICAgIGxpcXVpZD17IXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnR9XG4gICAgICAgICAgICAgIGNvbGxhcHNpYmxlV2lkdGg9e3Byb3BzLmZvclByaW50fVxuICAgICAgICAgICAgICBjb2xHcm91cHM9e1t7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dfVxuICAgICAgICAgICAgICBzZWN0aW9ucz17c2VjdGlvbnN9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9WaWV3Um9vdD5cbiAgICApXG4gIH1cbn1cbiIsImltcG9ydCB7IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlLCBTZWcgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuLy8gdGhpcyBpcyBhIERBVEEgU1RSVUNUVVJFLCBub3QgYSBjb21wb25lbnRcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVNlZyBleHRlbmRzIFNlZyB7XG4gIHJvdzogbnVtYmVyXG4gIGZpcnN0Q29sOiBudW1iZXJcbiAgbGFzdENvbDogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFNlZ3NCeVJvdyhzZWdzOiBUYWJsZVNlZ1tdLCByb3dDbnQ6IG51bWJlcikge1xuICBsZXQgYnlSb3c6IFRhYmxlU2VnW11bXSA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgIGJ5Um93W2ldID0gW11cbiAgfVxuXG4gIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgYnlSb3dbc2VnLnJvd10ucHVzaChzZWcpXG4gIH1cblxuICByZXR1cm4gYnlSb3dcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0U2Vnc0J5Rmlyc3RDb2woc2VnczogVGFibGVTZWdbXSwgY29sQ250OiBudW1iZXIpIHtcbiAgbGV0IGJ5Q29sOiBUYWJsZVNlZ1tdW10gPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICBieUNvbFtpXSA9IFtdXG4gIH1cblxuICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgIGJ5Q29sW3NlZy5maXJzdENvbF0ucHVzaChzZWcpXG4gIH1cblxuICByZXR1cm4gYnlDb2xcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0SW50ZXJhY3Rpb25CeVJvdyh1aTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsLCByb3dDbnQ6IG51bWJlcikge1xuICBsZXQgYnlSb3c6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlW10gPSBbXVxuXG4gIGlmICghdWkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICBieVJvd1tpXSA9IG51bGxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgYnlSb3dbaV0gPSB7XG4gICAgICAgIGFmZmVjdGVkSW5zdGFuY2VzOiB1aS5hZmZlY3RlZEluc3RhbmNlcyxcbiAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgc2VnczogW10sXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgIGJ5Um93W3NlZy5yb3ddLnNlZ3MucHVzaChzZWcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5Um93XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVFbGVtZW50LFxuICBEYXRlTWFya2VyLFxuICBEYXRlUmFuZ2UsXG4gIGJ1aWxkTmF2TGlua0RhdGEsXG4gIERheUNlbGxDb250ZW50QXJnLFxuICBEYXlDZWxsQ29udGVudCxcbiAgQmFzZUNvbXBvbmVudCxcbiAgRGF0ZVByb2ZpbGUsXG4gIERpY3Rpb25hcnksXG4gIEZyYWdtZW50LFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuaW50ZXJmYWNlIFRhYmxlQ2VsbFRvcFByb3BzIHtcbiAgZGF0ZTogRGF0ZU1hcmtlclxuICBkYXRlUHJvZmlsZTogRGF0ZVByb2ZpbGVcbiAgc2hvd0RheU51bWJlcjogYm9vbGVhblxuICBmb3JjZURheVRvcDogYm9vbGVhbiAvLyBoYWNrIHRvIGZvcmNlLWNyZWF0ZSBhbiBlbGVtZW50IHdpdGggaGVpZ2h0IChjcmVhdGVkIGJ5IGEgbmJzcClcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG4gIGV4dHJhSG9va1Byb3BzPzogRGljdGlvbmFyeVxufVxuXG5leHBvcnQgY2xhc3MgVGFibGVDZWxsVG9wIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUYWJsZUNlbGxUb3BQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIGxldCBuYXZMaW5rQXR0cnMgPSB0aGlzLmNvbnRleHQub3B0aW9ucy5uYXZMaW5rc1xuICAgICAgPyB7ICdkYXRhLW5hdmxpbmsnOiBidWlsZE5hdkxpbmtEYXRhKHByb3BzLmRhdGUpLCB0YWJJbmRleDogMCB9XG4gICAgICA6IHt9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPERheUNlbGxDb250ZW50XG4gICAgICAgIGRhdGU9e3Byb3BzLmRhdGV9XG4gICAgICAgIGRhdGVQcm9maWxlPXtwcm9wcy5kYXRlUHJvZmlsZX1cbiAgICAgICAgdG9kYXlSYW5nZT17cHJvcHMudG9kYXlSYW5nZX1cbiAgICAgICAgc2hvd0RheU51bWJlcj17cHJvcHMuc2hvd0RheU51bWJlcn1cbiAgICAgICAgZXh0cmFIb29rUHJvcHM9e3Byb3BzLmV4dHJhSG9va1Byb3BzfVxuICAgICAgICBkZWZhdWx0Q29udGVudD17cmVuZGVyVG9wSW5uZXJ9XG4gICAgICA+XG4gICAgICAgIHsoaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgKGlubmVyQ29udGVudCB8fCBwcm9wcy5mb3JjZURheVRvcCkgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1kYXlncmlkLWRheS10b3BcIiByZWY9e2lubmVyRWxSZWZ9PlxuICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJmYy1kYXlncmlkLWRheS1udW1iZXJcIiB7Li4ubmF2TGlua0F0dHJzfT5cbiAgICAgICAgICAgICAgICB7aW5uZXJDb250ZW50IHx8IDxGcmFnbWVudD4mbmJzcDs8L0ZyYWdtZW50Pn1cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKVxuICAgICAgICApfVxuICAgICAgPC9EYXlDZWxsQ29udGVudD5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVG9wSW5uZXIocHJvcHM6IERheUNlbGxDb250ZW50QXJnKSB7XG4gIHJldHVybiBwcm9wcy5kYXlOdW1iZXJUZXh0XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICBob3VyOiAnbnVtZXJpYycsXG4gIG1pbnV0ZTogJzItZGlnaXQnLFxuICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgbWVyaWRpZW06ICduYXJyb3cnLFxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0xpc3RJdGVtRGlzcGxheShzZWc6IFRhYmxlU2VnKSB7XG4gIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpXG5cbiAgcmV0dXJuIGRpc3BsYXkgPT09ICdsaXN0LWl0ZW0nIHx8IChcbiAgICBkaXNwbGF5ID09PSAnYXV0bycgJiZcbiAgICAhc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheSAmJlxuICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XG4gICAgc2VnLmlzU3RhcnQgJiYgLy8gXCJcbiAgICBzZWcuaXNFbmQgLy8gXCJcbiAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgU3RhbmRhcmRFdmVudCwgQmFzZUNvbXBvbmVudCwgTWluaW1hbEV2ZW50UHJvcHMgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQgfSBmcm9tICcuL2V2ZW50LXJlbmRlcmluZydcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUJsb2NrRXZlbnRQcm9wcyBleHRlbmRzIE1pbmltYWxFdmVudFByb3BzIHtcbiAgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgVGFibGVCbG9ja0V2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUYWJsZUJsb2NrRXZlbnRQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIHJldHVybiAoXG4gICAgICA8U3RhbmRhcmRFdmVudFxuICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgIGV4dHJhQ2xhc3NOYW1lcz17WydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtYmxvY2stZXZlbnQnLCAnZmMtaC1ldmVudCddfVxuICAgICAgICBkZWZhdWx0VGltZUZvcm1hdD17REVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVH1cbiAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17cHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudEVuZH1cbiAgICAgICAgZGlzYWJsZVJlc2l6aW5nPXshcHJvcHMuc2VnLmV2ZW50UmFuZ2UuZGVmLmFsbERheX1cbiAgICAgIC8+XG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBCYXNlQ29tcG9uZW50LCBTZWcsIEV2ZW50Um9vdCwgYnVpbGRTZWdUaW1lVGV4dCwgRXZlbnRDb250ZW50QXJnLCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCB9IGZyb20gJy4vZXZlbnQtcmVuZGVyaW5nJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERvdFRhYmxlRXZlbnRQcm9wcyB7XG4gIHNlZzogU2VnXG4gIGlzRHJhZ2dpbmc6IGJvb2xlYW5cbiAgaXNTZWxlY3RlZDogYm9vbGVhblxuICBpc1Bhc3Q6IGJvb2xlYW5cbiAgaXNGdXR1cmU6IGJvb2xlYW5cbiAgaXNUb2RheTogYm9vbGVhblxuICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBUYWJsZUxpc3RJdGVtRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50PERvdFRhYmxlRXZlbnRQcm9wcz4ge1xuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgdGltZUZvcm1hdCA9IGNvbnRleHQub3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVFxuICAgIGxldCB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoXG4gICAgICBwcm9wcy5zZWcsXG4gICAgICB0aW1lRm9ybWF0LFxuICAgICAgY29udGV4dCxcbiAgICAgIHRydWUsXG4gICAgICBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLFxuICAgIClcblxuICAgIHJldHVybiAoXG4gICAgICA8RXZlbnRSb290XG4gICAgICAgIHNlZz17cHJvcHMuc2VnfVxuICAgICAgICB0aW1lVGV4dD17dGltZVRleHR9XG4gICAgICAgIGRlZmF1bHRDb250ZW50PXtyZW5kZXJJbm5lckNvbnRlbnR9XG4gICAgICAgIGlzRHJhZ2dpbmc9e3Byb3BzLmlzRHJhZ2dpbmd9XG4gICAgICAgIGlzUmVzaXppbmc9e2ZhbHNlfVxuICAgICAgICBpc0RhdGVTZWxlY3Rpbmc9e2ZhbHNlfVxuICAgICAgICBpc1NlbGVjdGVkPXtwcm9wcy5pc1NlbGVjdGVkfVxuICAgICAgICBpc1Bhc3Q9e3Byb3BzLmlzUGFzdH1cbiAgICAgICAgaXNGdXR1cmU9e3Byb3BzLmlzRnV0dXJlfVxuICAgICAgICBpc1RvZGF5PXtwcm9wcy5pc1RvZGF5fVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoIC8vIHdlIGRvbid0IHVzZSBzdHlsZXMhXG4gICAgICAgICAgPGFcbiAgICAgICAgICAgIGNsYXNzTmFtZT17WydmYy1kYXlncmlkLWV2ZW50JywgJ2ZjLWRheWdyaWQtZG90LWV2ZW50J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgICAgIHJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgey4uLmdldFNlZ0FuY2hvckF0dHJzKHByb3BzLnNlZyl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICA8L2E+XG4gICAgICAgICl9XG4gICAgICA8L0V2ZW50Um9vdD5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KGlubmVyUHJvcHM6IEV2ZW50Q29udGVudEFyZykge1xuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPVwiZmMtZGF5Z3JpZC1ldmVudC1kb3RcIlxuICAgICAgICBzdHlsZT17eyBib3JkZXJDb2xvcjogaW5uZXJQcm9wcy5ib3JkZXJDb2xvciB8fCBpbm5lclByb3BzLmJhY2tncm91bmRDb2xvciB9fVxuICAgICAgLz5cbiAgICAgIHtpbm5lclByb3BzLnRpbWVUZXh0ICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1ldmVudC10aW1lXCI+e2lubmVyUHJvcHMudGltZVRleHR9PC9kaXY+XG4gICAgICApfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1ldmVudC10aXRsZVwiPlxuICAgICAgICB7aW5uZXJQcm9wcy5ldmVudC50aXRsZSB8fCA8RnJhZ21lbnQ+Jm5ic3A7PC9GcmFnbWVudD59XG4gICAgICA8L2Rpdj5cbiAgICA8L0ZyYWdtZW50PlxuICApXG59XG5cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZzogU2VnKSB7IC8vIG5vdCBkcnkuIGluIFN0YW5kYXJkRXZlbnQgdG9vXG4gIGxldCB7IHVybCB9ID0gc2VnLmV2ZW50UmFuZ2UuZGVmXG4gIHJldHVybiB1cmwgPyB7IGhyZWY6IHVybCB9IDoge31cbn1cbiIsImltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIE1vcmVMaW5rUm9vdCxcbiAgUmVmT2JqZWN0LFxuICBCYXNlQ29tcG9uZW50LFxuICBtZW1vaXplLFxuICBEYXRlTWFya2VyLFxuICBEaWN0aW9uYXJ5LFxuICBEYXRlUHJvZmlsZSxcbiAgRGF0ZVJhbmdlLFxuICBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSxcbiAgZ2V0U2VnTWV0YSxcbiAgRnJhZ21lbnQsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgVGFibGVTZWdQbGFjZW1lbnQgfSBmcm9tICcuL2V2ZW50LXBsYWNlbWVudCdcbmltcG9ydCB7IGhhc0xpc3RJdGVtRGlzcGxheSB9IGZyb20gJy4vZXZlbnQtcmVuZGVyaW5nJ1xuaW1wb3J0IHsgVGFibGVCbG9ja0V2ZW50IH0gZnJvbSAnLi9UYWJsZUJsb2NrRXZlbnQnXG5pbXBvcnQgeyBUYWJsZUxpc3RJdGVtRXZlbnQgfSBmcm9tICcuL1RhYmxlTGlzdEl0ZW1FdmVudCdcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxNb3JlTGlua1Byb3BzIHtcbiAgYWxsRGF5RGF0ZTogRGF0ZU1hcmtlclxuICBzaW5nbGVQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdXG4gIG1vcmVDbnQ6IG51bWJlclxuICBhbGlnbm1lbnRFbFJlZjogUmVmT2JqZWN0PEhUTUxFbGVtZW50PiAvLyBmb3IgcG9wb3ZlclxuICBhbGlnbkdyaWRUb3A6IGJvb2xlYW4gLy8gZm9yIHBvcG92ZXJcbiAgZXh0cmFEYXRlU3Bhbj86IERpY3Rpb25hcnlcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIHRvZGF5UmFuZ2U6IERhdGVSYW5nZVxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG4gIGV2ZW50RHJhZzogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGV2ZW50UmVzaXplOiBFdmVudFNlZ1VpSW50ZXJhY3Rpb25TdGF0ZSB8IG51bGxcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlQ2VsbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudDxUYWJsZUNlbGxNb3JlTGlua1Byb3BzPiB7XG4gIGNvbXBpbGVTZWdzID0gbWVtb2l6ZShjb21waWxlU2VncylcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBhbGxTZWdzLCBpbnZpc2libGVTZWdzIH0gPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPE1vcmVMaW5rUm9vdFxuICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgIHRvZGF5UmFuZ2U9e3Byb3BzLnRvZGF5UmFuZ2V9XG4gICAgICAgIGFsbERheURhdGU9e3Byb3BzLmFsbERheURhdGV9XG4gICAgICAgIG1vcmVDbnQ9e3Byb3BzLm1vcmVDbnR9XG4gICAgICAgIGFsbFNlZ3M9e2FsbFNlZ3N9XG4gICAgICAgIGhpZGRlblNlZ3M9e2ludmlzaWJsZVNlZ3N9XG4gICAgICAgIGFsaWdubWVudEVsUmVmPXtwcm9wcy5hbGlnbm1lbnRFbFJlZn1cbiAgICAgICAgYWxpZ25HcmlkVG9wPXtwcm9wcy5hbGlnbkdyaWRUb3B9XG4gICAgICAgIGV4dHJhRGF0ZVNwYW49e3Byb3BzLmV4dHJhRGF0ZVNwYW59XG4gICAgICAgIHBvcG92ZXJDb250ZW50PXsoKSA9PiB7XG4gICAgICAgICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID1cbiAgICAgICAgICAgIChwcm9wcy5ldmVudERyYWcgPyBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplID8gcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICAgICAge31cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPEZyYWdtZW50PlxuICAgICAgICAgICAgICB7YWxsU2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZFxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiXG4gICAgICAgICAgICAgICAgICAgIGtleT17aW5zdGFuY2VJZH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc0ZvcmNlZEludmlzaWJsZVtpbnN0YW5jZUlkXSA/ICdoaWRkZW4nIDogKCcnIGFzIGFueSksXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChcbiAgICAgICAgICAgICAgICAgICAgICA8VGFibGVMaXN0SXRlbUV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZD17aW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5nZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSl9XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICA8VGFibGVCbG9ja0V2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXNpemluZz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RhdGVTZWxlY3Rpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZD17aW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0RGlzcGxheUV2ZW50RW5kPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5nZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSl9XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaGFuZGxlQ2xpY2spID0+IChcbiAgICAgICAgICA8YVxuICAgICAgICAgICAgcmVmPXtyb290RWxSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9e1snZmMtZGF5Z3JpZC1tb3JlLWxpbmsnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICA8L2E+XG4gICAgICAgICl9XG4gICAgICA8L01vcmVMaW5rUm9vdD5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVNlZ3Moc2luZ2xlUGxhY2VtZW50czogVGFibGVTZWdQbGFjZW1lbnRbXSk6IHtcbiAgYWxsU2VnczogVGFibGVTZWdbXVxuICBpbnZpc2libGVTZWdzOiBUYWJsZVNlZ1tdXG59IHtcbiAgbGV0IGFsbFNlZ3M6IFRhYmxlU2VnW10gPSBbXVxuICBsZXQgaW52aXNpYmxlU2VnczogVGFibGVTZWdbXSA9IFtdXG5cbiAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNpbmdsZVBsYWNlbWVudHMpIHtcbiAgICBhbGxTZWdzLnB1c2gocGxhY2VtZW50LnNlZylcblxuICAgIGlmICghcGxhY2VtZW50LmlzVmlzaWJsZSkge1xuICAgICAgaW52aXNpYmxlU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9XG59XG4iLCJpbXBvcnQge1xuICBSZWYsXG4gIENvbXBvbmVudENoaWxkcmVuLFxuICBjcmVhdGVFbGVtZW50LFxuICBEYXRlTWFya2VyLFxuICBEYXRlQ29tcG9uZW50LFxuICBEYXRlUmFuZ2UsXG4gIGJ1aWxkTmF2TGlua0RhdGEsXG4gIFdlZWtOdW1iZXJSb290LFxuICBEYXlDZWxsUm9vdCxcbiAgRGF0ZVByb2ZpbGUsXG4gIHNldFJlZixcbiAgY3JlYXRlRm9ybWF0dGVyLFxuICBEaWN0aW9uYXJ5LFxuICBjcmVhdGVSZWYsXG4gIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlQ2VsbFRvcCB9IGZyb20gJy4vVGFibGVDZWxsVG9wJ1xuaW1wb3J0IHsgVGFibGVDZWxsTW9yZUxpbmsgfSBmcm9tICcuL1RhYmxlQ2VsbE1vcmVMaW5rJ1xuaW1wb3J0IHsgVGFibGVTZWdQbGFjZW1lbnQgfSBmcm9tICcuL2V2ZW50LXBsYWNlbWVudCdcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxQcm9wcyB7XG4gIGRhdGU6IERhdGVNYXJrZXJcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIGV4dHJhSG9va1Byb3BzPzogRGljdGlvbmFyeVxuICBleHRyYURhdGFBdHRycz86IERpY3Rpb25hcnlcbiAgZXh0cmFDbGFzc05hbWVzPzogc3RyaW5nW11cbiAgZXh0cmFEYXRlU3Bhbj86IERpY3Rpb25hcnlcbiAgZWxSZWY/OiBSZWY8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+XG4gIGlubmVyRWxSZWY/OiBSZWY8SFRNTERpdkVsZW1lbnQ+XG4gIGJnQ29udGVudDogQ29tcG9uZW50Q2hpbGRyZW5cbiAgZmdDb250ZW50RWxSZWY/OiBSZWY8SFRNTERpdkVsZW1lbnQ+IC8vIFRPRE86IHJlbmFtZSEhISBjbGFzc25hbWUgY29uZnVzaW9uLiBpcyB0aGUgXCJldmVudFwiIGRpdlxuICBmZ0NvbnRlbnQ6IENvbXBvbmVudENoaWxkcmVuXG4gIG1vcmVDbnQ6IG51bWJlclxuICBtb3JlTWFyZ2luVG9wOiBudW1iZXJcbiAgc2hvd0RheU51bWJlcjogYm9vbGVhblxuICBzaG93V2Vla051bWJlcjogYm9vbGVhblxuICBmb3JjZURheVRvcDogYm9vbGVhblxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudERyYWc6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIHNpbmdsZVBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W11cbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbmFycm93JyB9KVxuXG5leHBvcnQgY2xhc3MgVGFibGVDZWxsIGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxUYWJsZUNlbGxQcm9wcz4ge1xuICBwcml2YXRlIHJvb3RFbFJlZiA9IGNyZWF0ZVJlZjxIVE1MRWxlbWVudD4oKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCwgcm9vdEVsUmVmIH0gPSB0aGlzXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dFxuICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wc1xuICAgIGxldCBuYXZMaW5rQXR0cnMgPSBvcHRpb25zLm5hdkxpbmtzXG4gICAgICA/IHsgJ2RhdGEtbmF2bGluayc6IGJ1aWxkTmF2TGlua0RhdGEoZGF0ZSwgJ3dlZWsnKSwgdGFiSW5kZXg6IDAgfVxuICAgICAgOiB7fVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxEYXlDZWxsUm9vdFxuICAgICAgICBkYXRlPXtkYXRlfVxuICAgICAgICBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9XG4gICAgICAgIHRvZGF5UmFuZ2U9e3Byb3BzLnRvZGF5UmFuZ2V9XG4gICAgICAgIHNob3dEYXlOdW1iZXI9e3Byb3BzLnNob3dEYXlOdW1iZXJ9XG4gICAgICAgIGV4dHJhSG9va1Byb3BzPXtwcm9wcy5leHRyYUhvb2tQcm9wc31cbiAgICAgICAgZWxSZWY9e3RoaXMuaGFuZGxlUm9vdEVsfVxuICAgICAgPlxuICAgICAgICB7KGRheUVsUmVmLCBkYXlDbGFzc05hbWVzLCByb290RGF0YUF0dHJzLCBpc0Rpc2FibGVkKSA9PiAoXG4gICAgICAgICAgPHRkXG4gICAgICAgICAgICByZWY9e2RheUVsUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtbJ2ZjLWRheWdyaWQtZGF5J10uY29uY2F0KGRheUNsYXNzTmFtZXMsIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSkuam9pbignICcpfVxuICAgICAgICAgICAgey4uLnJvb3REYXRhQXR0cnN9XG4gICAgICAgICAgICB7Li4ucHJvcHMuZXh0cmFEYXRhQXR0cnN9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1kYXlncmlkLWRheS1mcmFtZSBmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiByZWY9e3Byb3BzLmlubmVyRWxSZWYgLyogZGlmZmVyZW50IGZyb20gaG9vayBzeXN0ZW0hIFJFTkFNRSAqL30+XG4gICAgICAgICAgICAgIHtwcm9wcy5zaG93V2Vla051bWJlciAmJiAoXG4gICAgICAgICAgICAgICAgPFdlZWtOdW1iZXJSb290IGRhdGU9e2RhdGV9IGRlZmF1bHRGb3JtYXQ9e0RFRkFVTFRfV0VFS19OVU1fRk9STUFUfT5cbiAgICAgICAgICAgICAgICAgIHsod2Vla0VsUmVmLCB3ZWVrQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICAgICAgcmVmPXt3ZWVrRWxSZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXS5jb25jYXQod2Vla0NsYXNzTmFtZXMpLmpvaW4oJyAnKX1cbiAgICAgICAgICAgICAgICAgICAgICB7Li4ubmF2TGlua0F0dHJzfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge2lubmVyQ29udGVudH1cbiAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L1dlZWtOdW1iZXJSb290PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICB7IWlzRGlzYWJsZWQgJiYgKFxuICAgICAgICAgICAgICAgIDxUYWJsZUNlbGxUb3BcbiAgICAgICAgICAgICAgICAgIGRhdGU9e2RhdGV9XG4gICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZT17ZGF0ZVByb2ZpbGV9XG4gICAgICAgICAgICAgICAgICBzaG93RGF5TnVtYmVyPXtwcm9wcy5zaG93RGF5TnVtYmVyfVxuICAgICAgICAgICAgICAgICAgZm9yY2VEYXlUb3A9e3Byb3BzLmZvcmNlRGF5VG9wfVxuICAgICAgICAgICAgICAgICAgdG9kYXlSYW5nZT17cHJvcHMudG9kYXlSYW5nZX1cbiAgICAgICAgICAgICAgICAgIGV4dHJhSG9va1Byb3BzPXtwcm9wcy5leHRyYUhvb2tQcm9wc31cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmMtZGF5Z3JpZC1kYXktZXZlbnRzXCJcbiAgICAgICAgICAgICAgICByZWY9e3Byb3BzLmZnQ29udGVudEVsUmVmfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3Byb3BzLmZnQ29udGVudH1cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWRheWdyaWQtZGF5LWJvdHRvbVwiIHN0eWxlPXt7IG1hcmdpblRvcDogcHJvcHMubW9yZU1hcmdpblRvcCB9fT5cbiAgICAgICAgICAgICAgICAgIDxUYWJsZUNlbGxNb3JlTGlua1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXlEYXRlPXtkYXRlfVxuICAgICAgICAgICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzPXtwcm9wcy5zaW5nbGVQbGFjZW1lbnRzfVxuICAgICAgICAgICAgICAgICAgICBtb3JlQ250PXtwcm9wcy5tb3JlQ250fVxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRFbFJlZj17cm9vdEVsUmVmfVxuICAgICAgICAgICAgICAgICAgICBhbGlnbkdyaWRUb3A9eyFwcm9wcy5zaG93RGF5TnVtYmVyfVxuICAgICAgICAgICAgICAgICAgICBleHRyYURhdGVTcGFuPXtwcm9wcy5leHRyYURhdGVTcGFufVxuICAgICAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uPXtwcm9wcy5ldmVudFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgZXZlbnREcmFnPXtwcm9wcy5ldmVudERyYWd9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplPXtwcm9wcy5ldmVudFJlc2l6ZX1cbiAgICAgICAgICAgICAgICAgICAgdG9kYXlSYW5nZT17cHJvcHMudG9kYXlSYW5nZX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZjLWRheWdyaWQtZGF5LWJnXCI+XG4gICAgICAgICAgICAgICAge3Byb3BzLmJnQ29udGVudH1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L3RkPlxuICAgICAgICApfVxuICAgICAgPC9EYXlDZWxsUm9vdD5cbiAgICApXG4gIH1cblxuICBoYW5kbGVSb290RWwgPSAoZWw6IEhUTUxFbGVtZW50KSA9PiB7XG4gICAgc2V0UmVmKHRoaXMucm9vdEVsUmVmLCBlbClcbiAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIFNlZ0hpZXJhcmNoeSxcbiAgU2VnUmVjdCxcbiAgU2VnRW50cnksXG4gIFNlZ0luc2VydGlvbixcbiAgYnVpbGRFbnRyeUtleSxcbiAgRXZlbnRSZW5kZXJSYW5nZSxcbiAgaW50ZXJzZWN0UmFuZ2VzLFxuICBhZGREYXlzLFxuICBEYXlUYWJsZUNlbGwsXG4gIGludGVyc2VjdFNwYW5zLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnIH0gZnJvbSAnLi9UYWJsZVNlZydcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVNlZ1BsYWNlbWVudCB7XG4gIHNlZzogVGFibGVTZWdcbiAgaXNWaXNpYmxlOiBib29sZWFuXG4gIGlzQWJzb2x1dGU6IGJvb2xlYW5cbiAgYWJzb2x1dGVUb3A6IG51bWJlciAvLyBwb3B1bGF0ZWQgcmVnYXJkbGVzcyBvZiBpc0Fic29sdXRlXG4gIG1hcmdpblRvcDogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoXG4gIHNlZ3M6IFRhYmxlU2VnW10sIC8vIGFzc3VtZWQgYWxyZWFkeSBzb3J0ZWRcbiAgZGF5TWF4RXZlbnRzOiBib29sZWFuIHwgbnVtYmVyLFxuICBkYXlNYXhFdmVudFJvd3M6IGJvb2xlYW4gfCBudW1iZXIsXG4gIHN0cmljdE9yZGVyOiBib29sZWFuLFxuICBldmVudEluc3RhbmNlSGVpZ2h0czogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogbnVtYmVyIH0sXG4gIG1heENvbnRlbnRIZWlnaHQ6IG51bWJlciB8IG51bGwsXG4gIGNlbGxzOiBEYXlUYWJsZUNlbGxbXSxcbikge1xuICBsZXQgaGllcmFyY2h5ID0gbmV3IERheUdyaWRTZWdIaWVyYXJjaHkoKVxuICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlXG4gIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyXG5cbiAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHtcbiAgICBoaWVyYXJjaHkubWF4Q29vcmQgPSBtYXhDb250ZW50SGVpZ2h0XG4gICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XG4gICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcbiAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudFJvd3NcbiAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlXG4gIH1cblxuICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXG4gIGxldCBzZWdJbnB1dHM6IFNlZ0VudHJ5W10gPSBbXVxuICBsZXQgdW5rbm93bkhlaWdodFNlZ3M6IFRhYmxlU2VnW10gPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgc2VnID0gc2Vnc1tpXVxuICAgIGxldCB7IGluc3RhbmNlSWQgfSA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlXG4gICAgbGV0IGV2ZW50SGVpZ2h0ID0gZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF1cblxuICAgIGlmIChldmVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICB0aGlja25lc3M6IGV2ZW50SGVpZ2h0LFxuICAgICAgICBzcGFuOiB7XG4gICAgICAgICAgc3RhcnQ6IHNlZy5maXJzdENvbCxcbiAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHVua25vd25IZWlnaHRTZWdzLnB1c2goc2VnKVxuICAgIH1cbiAgfVxuXG4gIGxldCBoaWRkZW5FbnRyaWVzID0gaGllcmFyY2h5LmFkZFNlZ3Moc2VnSW5wdXRzKVxuICBsZXQgc2VnUmVjdHMgPSBoaWVyYXJjaHkudG9SZWN0cygpXG4gIGxldCB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zIH0gPSBwbGFjZVJlY3RzKHNlZ1JlY3RzLCBzZWdzLCBjZWxscylcblxuICBsZXQgbW9yZUNudHM6IG51bWJlcltdID0gW11cbiAgbGV0IG1vcmVNYXJnaW5Ub3BzOiBudW1iZXJbXSA9IFtdXG5cbiAgLy8gYWRkIHNlZ3Mgd2l0aCB1bmtub3duIGhlaWdodHNcbiAgZm9yIChsZXQgc2VnIG9mIHVua25vd25IZWlnaHRTZWdzKSB7XG4gICAgbXVsdGlDb2xQbGFjZW1lbnRzW3NlZy5maXJzdENvbF0ucHVzaCh7XG4gICAgICBzZWcsXG4gICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgbWFyZ2luVG9wOiAwLFxuICAgIH0pXG5cbiAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcbiAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgdGhlIGhpZGRlbiBlbnRyaWVzXG4gIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICBtb3JlQ250cy5wdXNoKDApXG4gIH1cbiAgZm9yIChsZXQgaGlkZGVuRW50cnkgb2YgaGlkZGVuRW50cmllcykge1xuICAgIGxldCBzZWcgPSBzZWdzW2hpZGRlbkVudHJ5LmluZGV4XVxuICAgIGxldCBoaWRkZW5TcGFuID0gaGlkZGVuRW50cnkuc3BhblxuXG4gICAgbXVsdGlDb2xQbGFjZW1lbnRzW2hpZGRlblNwYW4uc3RhcnRdLnB1c2goe1xuICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgaGlkZGVuU3Bhbi5zdGFydCwgaGlkZGVuU3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgfSlcblxuICAgIGZvciAobGV0IGNvbCA9IGhpZGRlblNwYW4uc3RhcnQ7IGNvbCA8IGhpZGRlblNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgbW9yZUNudHNbY29sXSArPSAxXG4gICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLy8gZGVhbCB3aXRoIGxlZnRvdmVyIG1hcmdpbnNcbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY2VsbHMubGVuZ3RoOyBjb2wgKz0gMSkge1xuICAgIG1vcmVNYXJnaW5Ub3BzLnB1c2gobGVmdG92ZXJNYXJnaW5zW2NvbF0pXG4gIH1cblxuICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9XG59XG5cbi8vIHJlY3RzIG9yZGVyZWQgYnkgdG9wIGNvb3JkLCB0aGVuIGxlZnRcbmZ1bmN0aW9uIHBsYWNlUmVjdHMoYWxsUmVjdHM6IFNlZ1JlY3RbXSwgc2VnczogVGFibGVTZWdbXSwgY2VsbHM6IERheVRhYmxlQ2VsbFtdKSB7XG4gIGxldCByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aClcbiAgbGV0IHNpbmdsZUNvbFBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W11bXSA9IFtdXG4gIGxldCBtdWx0aUNvbFBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W11bXSA9IFtdXG4gIGxldCBsZWZ0b3Zlck1hcmdpbnM6IG51bWJlcltdID0gW11cblxuICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgbGV0IHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXVxuXG4gICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xuICAgIGxldCBzaW5nbGVQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdID0gW11cbiAgICBsZXQgY3VycmVudEhlaWdodCA9IDBcbiAgICBsZXQgY3VycmVudE1hcmdpblRvcCA9IDBcbiAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XVxuICAgICAgc2luZ2xlUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcbiAgICAgIH0pXG4gICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3NcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIG1peGVkIHN0YXRpYy9hYnNvbHV0ZSBzZWdzIGluIG11bHRpUGxhY2VtZW50c1xuICAgIGxldCBtdWx0aVBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W10gPSBbXVxuICAgIGN1cnJlbnRIZWlnaHQgPSAwXG4gICAgY3VycmVudE1hcmdpblRvcCA9IDBcbiAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XVxuICAgICAgbGV0IGlzQWJzb2x1dGUgPSByZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0ID4gMSAvLyBtdWx0aS1jb2x1bW4/XG4gICAgICBsZXQgaXNGaXJzdENvbCA9IHJlY3Quc3Bhbi5zdGFydCA9PT0gY29sXG5cbiAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCAvLyBhbW91bnQgb2Ygc3BhY2Ugc2luY2UgYm90dG9tIG9mIHByZXZpb3VzIHNlZ1xuICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzIC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcblxuICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzc1xuICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICBtYXJnaW5Ub3A6IGN1cnJlbnRNYXJnaW5Ub3AsIC8vIGNsYWltIHRoZSBtYXJnaW5cbiAgICAgICAgfSlcbiAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaW5nbGVDb2xQbGFjZW1lbnRzLnB1c2goc2luZ2xlUGxhY2VtZW50cylcbiAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpXG4gICAgbGVmdG92ZXJNYXJnaW5zLnB1c2goY3VycmVudE1hcmdpblRvcClcbiAgfVxuXG4gIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zIH1cbn1cblxuZnVuY3Rpb24gZ3JvdXBSZWN0c0J5RWFjaENvbChyZWN0czogU2VnUmVjdFtdLCBjb2xDbnQ6IG51bWJlcik6IFNlZ1JlY3RbXVtdIHtcbiAgbGV0IHJlY3RzQnlFYWNoQ29sOiBTZWdSZWN0W11bXSA9IFtdXG5cbiAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wgKz0gMSkge1xuICAgIHJlY3RzQnlFYWNoQ29sLnB1c2goW10pXG4gIH1cblxuICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgZm9yIChsZXQgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlY3RzQnlFYWNoQ29sXG59XG5cbmZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnOiBUYWJsZVNlZywgc3BhblN0YXJ0OiBudW1iZXIsIHNwYW5FbmQ6IG51bWJlciwgY2VsbHM6IERheVRhYmxlQ2VsbFtdKTogVGFibGVTZWcge1xuICBpZiAoc2VnLmZpcnN0Q29sID09PSBzcGFuU3RhcnQgJiYgc2VnLmxhc3RDb2wgPT09IHNwYW5FbmQgLSAxKSB7XG4gICAgcmV0dXJuIHNlZ1xuICB9XG5cbiAgbGV0IGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZVxuICBsZXQgb3JpZ1JhbmdlID0gZXZlbnRSYW5nZS5yYW5nZVxuICBsZXQgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMob3JpZ1JhbmdlLCB7XG4gICAgc3RhcnQ6IGNlbGxzW3NwYW5TdGFydF0uZGF0ZSxcbiAgICBlbmQ6IGFkZERheXMoY2VsbHNbc3BhbkVuZCAtIDFdLmRhdGUsIDEpLFxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgLi4uc2VnLFxuICAgIGZpcnN0Q29sOiBzcGFuU3RhcnQsXG4gICAgbGFzdENvbDogc3BhbkVuZCAtIDEsXG4gICAgZXZlbnRSYW5nZToge1xuICAgICAgZGVmOiBldmVudFJhbmdlLmRlZixcbiAgICAgIHVpOiB7IC4uLmV2ZW50UmFuZ2UudWksIGR1cmF0aW9uRWRpdGFibGU6IGZhbHNlIH0sIC8vIGhhY2sgdG8gZGlzYWJsZSByZXNpemluZ1xuICAgICAgaW5zdGFuY2U6IGV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgfSBhcyBFdmVudFJlbmRlclJhbmdlLFxuICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpLFxuICB9XG59XG5cbmNsYXNzIERheUdyaWRTZWdIaWVyYXJjaHkgZXh0ZW5kcyBTZWdIaWVyYXJjaHkge1xuICAvLyBjb25maWdcbiAgaGlkZGVuQ29uc3VtZXM6IGJvb2xlYW4gPSBmYWxzZVxuXG4gIC8vIGFsbG93cyB1cyB0byBrZWVwIGhpZGRlbiBlbnRyaWVzIGluIHRoZSBoaWVyYXJjaHkgc28gdGhleSB0YWtlIHVwIHNwYWNlXG4gIGZvcmNlSGlkZGVuOiB7IFtlbnRyeUlkOiBzdHJpbmddOiB0cnVlIH0gPSB7fVxuXG4gIGFkZFNlZ3Moc2VnSW5wdXRzOiBTZWdFbnRyeVtdKTogU2VnRW50cnlbXSB7XG4gICAgY29uc3QgaGlkZGVuU2VncyA9IHN1cGVyLmFkZFNlZ3Moc2VnSW5wdXRzKVxuICAgIGNvbnN0IHsgZW50cmllc0J5TGV2ZWwgfSA9IHRoaXNcbiAgICBjb25zdCBleGNsdWRlSGlkZGVuID0gKGVudHJ5OiBTZWdFbnRyeSkgPT4gIXRoaXMuZm9yY2VIaWRkZW5bYnVpbGRFbnRyeUtleShlbnRyeSldXG5cbiAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xuICAgIGZvciAobGV0IGxldmVsID0gMDsgbGV2ZWwgPCBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7IGxldmVsICs9IDEpIHtcbiAgICAgIGVudHJpZXNCeUxldmVsW2xldmVsXSA9IGVudHJpZXNCeUxldmVsW2xldmVsXS5maWx0ZXIoZXhjbHVkZUhpZGRlbilcbiAgICB9XG5cbiAgICByZXR1cm4gaGlkZGVuU2Vnc1xuICB9XG5cbiAgaGFuZGxlSW52YWxpZEluc2VydGlvbihpbnNlcnRpb246IFNlZ0luc2VydGlvbiwgZW50cnk6IFNlZ0VudHJ5LCBoaWRkZW5FbnRyaWVzOiBTZWdFbnRyeVtdKSB7XG4gICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gfSA9IHRoaXNcbiAgICBjb25zdCB7IHRvdWNoaW5nRW50cnksIHRvdWNoaW5nTGV2ZWwsIHRvdWNoaW5nTGF0ZXJhbCB9ID0gaW5zZXJ0aW9uXG5cbiAgICBpZiAodGhpcy5oaWRkZW5Db25zdW1lcyAmJiB0b3VjaGluZ0VudHJ5KSB7XG4gICAgICBjb25zdCB0b3VjaGluZ0VudHJ5SWQgPSBidWlsZEVudHJ5S2V5KHRvdWNoaW5nRW50cnkpXG4gICAgICAvLyBpZiBub3QgYWxyZWFkeSBoaWRkZW5cbiAgICAgIGlmICghZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSkge1xuICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZykge1xuICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRW50cnk6IFNlZ0VudHJ5ID0geyAvLyBwbGFjZWhvbGRlciBvZiB0aGUgXCJtb3JlXCIgbGlua1xuICAgICAgICAgICAgLi4udG91Y2hpbmdFbnRyeSxcbiAgICAgICAgICAgIHNwYW46IGludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbiksXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkocGxhY2Vob2xkZXJFbnRyeSlcbiAgICAgICAgICBmb3JjZUhpZGRlbltwbGFjZWhvbGRlckVudHJ5SWRdID0gdHJ1ZVxuICAgICAgICAgIGVudHJpZXNCeUxldmVsW3RvdWNoaW5nTGV2ZWxdW3RvdWNoaW5nTGF0ZXJhbF0gPSBwbGFjZWhvbGRlckVudHJ5IC8vIHJlcGxhY2UgdG91Y2hpbmdFbnRyeSB3aXRoIG91ciBwbGFjZWhvbGRlclxuICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcykgLy8gc3BsaXQgdXAgdGhlIHRvdWNoaW5nRW50cnksIHJlaW5zZXJ0IGl0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yY2VIaWRkZW5bdG91Y2hpbmdFbnRyeUlkXSA9IHRydWVcbiAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2godG91Y2hpbmdFbnRyeSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlLFxuICBWTm9kZSxcbiAgRGF0ZUNvbXBvbmVudCxcbiAgY3JlYXRlRWxlbWVudCxcbiAgUG9zaXRpb25DYWNoZSxcbiAgUmVmTWFwLFxuICBDc3NEaW1WYWx1ZSxcbiAgRGF0ZVJhbmdlLFxuICBnZXRTZWdNZXRhLFxuICBEYXRlUHJvZmlsZSxcbiAgRnJhZ21lbnQsXG4gIEJnRXZlbnQsXG4gIHJlbmRlckZpbGwsXG4gIGlzUHJvcHNFcXVhbCxcbiAgY3JlYXRlUmVmLFxuICBidWlsZEV2ZW50UmFuZ2VLZXksXG4gIHNvcnRFdmVudFNlZ3MsXG4gIERheVRhYmxlQ2VsbCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVNlZywgc3BsaXRTZWdzQnlGaXJzdENvbCB9IGZyb20gJy4vVGFibGVTZWcnXG5pbXBvcnQgeyBUYWJsZUNlbGwgfSBmcm9tICcuL1RhYmxlQ2VsbCdcbmltcG9ydCB7IFRhYmxlTGlzdEl0ZW1FdmVudCB9IGZyb20gJy4vVGFibGVMaXN0SXRlbUV2ZW50J1xuaW1wb3J0IHsgVGFibGVCbG9ja0V2ZW50IH0gZnJvbSAnLi9UYWJsZUJsb2NrRXZlbnQnXG5pbXBvcnQgeyBjb21wdXRlRmdTZWdQbGFjZW1lbnQsIFRhYmxlU2VnUGxhY2VtZW50IH0gZnJvbSAnLi9ldmVudC1wbGFjZW1lbnQnXG5pbXBvcnQgeyBoYXNMaXN0SXRlbURpc3BsYXkgfSBmcm9tICcuL2V2ZW50LXJlbmRlcmluZydcblxuLy8gVE9ETzogYXR0YWNoIHRvIHdpbmRvdyByZXNpemU/XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVSb3dQcm9wcyB7XG4gIGNlbGxzOiBEYXlUYWJsZUNlbGxbXVxuICByZW5kZXJJbnRybz86ICgpID0+IFZOb2RlXG4gIGJ1c2luZXNzSG91clNlZ3M6IFRhYmxlU2VnW11cbiAgYmdFdmVudFNlZ3M6IFRhYmxlU2VnW11cbiAgZmdFdmVudFNlZ3M6IFRhYmxlU2VnW11cbiAgZGF0ZVNlbGVjdGlvblNlZ3M6IFRhYmxlU2VnW11cbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudERyYWc6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGRheU1heEV2ZW50czogYm9vbGVhbiB8IG51bWJlclxuICBkYXlNYXhFdmVudFJvd3M6IGJvb2xlYW4gfCBudW1iZXJcbiAgY2xpZW50V2lkdGg6IG51bWJlciB8IG51bGxcbiAgY2xpZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsIC8vIHNpbXBseSBmb3IgY2F1c2luZyBhbiB1cGRhdGVTaXplLCBmb3Igd2hlbiBsaXF1aWQgaGVpZ2h0XG4gIGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZVxuICB0b2RheVJhbmdlOiBEYXRlUmFuZ2VcbiAgc2hvd0RheU51bWJlcnM6IGJvb2xlYW5cbiAgc2hvd1dlZWtOdW1iZXJzOiBib29sZWFuXG4gIGZvclByaW50OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBUYWJsZVJvd1N0YXRlIHtcbiAgZnJhbWVQb3NpdGlvbnM6IFBvc2l0aW9uQ2FjaGVcbiAgbWF4Q29udGVudEhlaWdodDogbnVtYmVyIHwgbnVsbFxuICBldmVudEluc3RhbmNlSGVpZ2h0czogeyBbaW5zdGFuY2VJZDogc3RyaW5nXTogbnVtYmVyIH0gLy8gaW50ZWdlcnNcbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlUm93IGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxUYWJsZVJvd1Byb3BzLCBUYWJsZVJvd1N0YXRlPiB7XG4gIHByaXZhdGUgY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXA8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+KCkgLy8gdGhlIDx0ZD5cbiAgcHJpdmF0ZSBmcmFtZUVsUmVmcyA9IG5ldyBSZWZNYXA8SFRNTEVsZW1lbnQ+KCkgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXG4gIHByaXZhdGUgZmdFbFJlZnMgPSBuZXcgUmVmTWFwPEhUTUxEaXZFbGVtZW50PigpIC8vIHRoZSBmYy1kYXlncmlkLWRheS1ldmVudHNcbiAgcHJpdmF0ZSBzZWdIYXJuZXNzUmVmcyA9IG5ldyBSZWZNYXA8SFRNTERpdkVsZW1lbnQ+KCkgLy8gaW5kZXhlZCBieSBcImluc3RhbmNlSWQ6Zmlyc3RDb2xcIlxuICBwcml2YXRlIHJvb3RFbFJlZiA9IGNyZWF0ZVJlZjxIVE1MVGFibGVSb3dFbGVtZW50PigpXG5cbiAgc3RhdGU6IFRhYmxlUm93U3RhdGUgPSB7XG4gICAgZnJhbWVQb3NpdGlvbnM6IG51bGwsXG4gICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcbiAgICBldmVudEluc3RhbmNlSGVpZ2h0czoge30sXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dFxuICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGhcblxuICAgIGxldCBidXNpbmVzc0hvdXJzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudClcbiAgICBsZXQgYmdFdmVudFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYmdFdmVudFNlZ3MsIGNvbENudClcbiAgICBsZXQgaGlnaGxpZ2h0U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldEhpZ2hsaWdodFNlZ3MoKSwgY29sQ250KVxuICAgIGxldCBtaXJyb3JTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0TWlycm9yU2VncygpLCBjb2xDbnQpXG5cbiAgICBsZXQgeyBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzLCBtb3JlTWFyZ2luVG9wcyB9ID0gY29tcHV0ZUZnU2VnUGxhY2VtZW50KFxuICAgICAgc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKSBhcyBUYWJsZVNlZ1tdLFxuICAgICAgcHJvcHMuZGF5TWF4RXZlbnRzLFxuICAgICAgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLFxuICAgICAgb3B0aW9ucy5ldmVudE9yZGVyU3RyaWN0LFxuICAgICAgc3RhdGUuZXZlbnRJbnN0YW5jZUhlaWdodHMsXG4gICAgICBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LFxuICAgICAgcHJvcHMuY2VsbHMsXG4gICAgKVxuXG4gICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID0gLy8gVE9ETzogbWVzc3kgd2F5IHRvIGNvbXB1dGUgdGhpc1xuICAgICAgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMpIHx8XG4gICAgICB7fVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDx0ciByZWY9e3RoaXMucm9vdEVsUmVmfT5cbiAgICAgICAge3Byb3BzLnJlbmRlckludHJvICYmIHByb3BzLnJlbmRlckludHJvKCl9XG4gICAgICAgIHtwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGNvbCkgPT4ge1xuICAgICAgICAgIGxldCBub3JtYWxGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoXG4gICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLFxuICAgICAgICAgICAgcHJvcHMudG9kYXlSYW5nZSxcbiAgICAgICAgICAgIGlzRm9yY2VkSW52aXNpYmxlLFxuICAgICAgICAgIClcblxuICAgICAgICAgIGxldCBtaXJyb3JGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoXG4gICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2Vnc0J5Q29sW2NvbF0sIG11bHRpQ29sUGxhY2VtZW50cyksXG4gICAgICAgICAgICBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBCb29sZWFuKHByb3BzLmV2ZW50RHJhZyksXG4gICAgICAgICAgICBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSxcbiAgICAgICAgICAgIGZhbHNlLCAvLyBkYXRlLXNlbGVjdGluZyAoYmVjYXVzZSBtaXJyb3IgaXMgbmV2ZXIgZHJhd24gZm9yIGRhdGUgc2VsZWN0aW9uKVxuICAgICAgICAgIClcblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8VGFibGVDZWxsXG4gICAgICAgICAgICAgIGtleT17Y2VsbC5rZXl9XG4gICAgICAgICAgICAgIGVsUmVmPXt0aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KX1cbiAgICAgICAgICAgICAgaW5uZXJFbFJlZj17dGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqL31cbiAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU9e3Byb3BzLmRhdGVQcm9maWxlfVxuICAgICAgICAgICAgICBkYXRlPXtjZWxsLmRhdGV9XG4gICAgICAgICAgICAgIHNob3dEYXlOdW1iZXI9e3Byb3BzLnNob3dEYXlOdW1iZXJzfVxuICAgICAgICAgICAgICBzaG93V2Vla051bWJlcj17cHJvcHMuc2hvd1dlZWtOdW1iZXJzICYmIGNvbCA9PT0gMH1cbiAgICAgICAgICAgICAgZm9yY2VEYXlUb3A9e3Byb3BzLnNob3dXZWVrTnVtYmVycyAvKiBldmVuIGRpc3BsYXlpbmcgd2Vla251bSBmb3Igcm93LCBub3QgbmVjZXNzYXJpbHkgZGF5ICovfVxuICAgICAgICAgICAgICB0b2RheVJhbmdlPXtwcm9wcy50b2RheVJhbmdlfVxuICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbj17cHJvcHMuZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgIGV2ZW50RHJhZz17cHJvcHMuZXZlbnREcmFnfVxuICAgICAgICAgICAgICBldmVudFJlc2l6ZT17cHJvcHMuZXZlbnRSZXNpemV9XG4gICAgICAgICAgICAgIGV4dHJhSG9va1Byb3BzPXtjZWxsLmV4dHJhSG9va1Byb3BzfVxuICAgICAgICAgICAgICBleHRyYURhdGFBdHRycz17Y2VsbC5leHRyYURhdGFBdHRyc31cbiAgICAgICAgICAgICAgZXh0cmFDbGFzc05hbWVzPXtjZWxsLmV4dHJhQ2xhc3NOYW1lc31cbiAgICAgICAgICAgICAgZXh0cmFEYXRlU3Bhbj17Y2VsbC5leHRyYURhdGVTcGFufVxuICAgICAgICAgICAgICBtb3JlQ250PXttb3JlQ250c1tjb2xdfVxuICAgICAgICAgICAgICBtb3JlTWFyZ2luVG9wPXttb3JlTWFyZ2luVG9wc1tjb2xdfVxuICAgICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzPXtzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF19XG4gICAgICAgICAgICAgIGZnQ29udGVudEVsUmVmPXt0aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSl9XG4gICAgICAgICAgICAgIGZnQ29udGVudD17KCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICA8RnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgICA8RnJhZ21lbnQ+e25vcm1hbEZnTm9kZXN9PC9GcmFnbWVudD5cbiAgICAgICAgICAgICAgICAgIDxGcmFnbWVudD57bWlycm9yRmdOb2Rlc308L0ZyYWdtZW50PlxuICAgICAgICAgICAgICAgIDwvRnJhZ21lbnQ+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIGJnQ29udGVudD17KCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICA8RnJhZ21lbnQ+XG4gICAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJGaWxsU2VncyhoaWdobGlnaHRTZWdzQnlDb2xbY29sXSwgJ2hpZ2hsaWdodCcpfVxuICAgICAgICAgICAgICAgICAge3RoaXMucmVuZGVyRmlsbFNlZ3MoYnVzaW5lc3NIb3Vyc0J5Q29sW2NvbF0sICdub24tYnVzaW5lc3MnKX1cbiAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckZpbGxTZWdzKGJnRXZlbnRTZWdzQnlDb2xbY29sXSwgJ2JnLWV2ZW50Jyl9XG4gICAgICAgICAgICAgICAgPC9GcmFnbWVudD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKVxuICAgICAgICB9KX1cbiAgICAgIDwvdHI+XG4gICAgKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSlcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFRhYmxlUm93UHJvcHMsIHByZXZTdGF0ZTogVGFibGVSb3dTdGF0ZSkge1xuICAgIGxldCBjdXJyZW50UHJvcHMgPSB0aGlzLnByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVNpemluZyhcbiAgICAgICFpc1Byb3BzRXF1YWwocHJldlByb3BzLCBjdXJyZW50UHJvcHMpLFxuICAgIClcbiAgfVxuXG4gIGdldEhpZ2hsaWdodFNlZ3MoKTogVGFibGVTZWdbXSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcblxuICAgIGlmIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICByZXR1cm4gcHJvcHMuZXZlbnREcmFnLnNlZ3MgYXMgVGFibGVTZWdbXVxuICAgIH1cblxuICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MgYXMgVGFibGVTZWdbXVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5kYXRlU2VsZWN0aW9uU2Vnc1xuICB9XG5cbiAgZ2V0TWlycm9yU2VncygpOiBUYWJsZVNlZ1tdIHtcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuXG4gICAgaWYgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MubGVuZ3RoKSB7IC8vIG1lc3N5IGNoZWNrXG4gICAgICByZXR1cm4gcHJvcHMuZXZlbnRSZXNpemUuc2VncyBhcyBUYWJsZVNlZ1tdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZW5kZXJGZ1NlZ3MoXG4gICAgY29sOiBudW1iZXIsXG4gICAgc2VnUGxhY2VtZW50czogVGFibGVTZWdQbGFjZW1lbnRbXSxcbiAgICB0b2RheVJhbmdlOiBEYXRlUmFuZ2UsXG4gICAgaXNGb3JjZWRJbnZpc2libGU6IHsgW2luc3RhbmNlSWQ6IHN0cmluZ106IGFueSB9LFxuICAgIGlzRHJhZ2dpbmc/OiBib29sZWFuLFxuICAgIGlzUmVzaXppbmc/OiBib29sZWFuLFxuICAgIGlzRGF0ZVNlbGVjdGluZz86IGJvb2xlYW4sXG4gICk6IFZOb2RlW10ge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXNcbiAgICBsZXQgeyBldmVudFNlbGVjdGlvbiB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCB7IGZyYW1lUG9zaXRpb25zIH0gPSB0aGlzLnN0YXRlXG4gICAgbGV0IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgPSB0aGlzLnByb3BzLmNlbGxzLmxlbmd0aCA9PT0gMSAvLyBjb2xDbnQgPT09IDFcbiAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nXG4gICAgbGV0IG5vZGVzOiBWTm9kZVtdID0gW11cblxuICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHNlZ1BsYWNlbWVudHMpIHtcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwbGFjZW1lbnRcbiAgICAgICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgbGV0IGtleSA9IGluc3RhbmNlSWQgKyAnOicgKyBjb2xcbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHBsYWNlbWVudC5pc1Zpc2libGUgJiYgIWlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdXG4gICAgICAgIGxldCBpc0Fic29sdXRlID0gcGxhY2VtZW50LmlzQWJzb2x1dGVcbiAgICAgICAgbGV0IGxlZnQ6IENzc0RpbVZhbHVlID0gJydcbiAgICAgICAgbGV0IHJpZ2h0OiBDc3NEaW1WYWx1ZSA9ICcnXG5cbiAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5pc1J0bCkge1xuICAgICAgICAgICAgcmlnaHQgPSAwXG4gICAgICAgICAgICBsZWZ0ID0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZWZ0ID0gMFxuICAgICAgICAgICAgcmlnaHQgPSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICBrbm93biBidWc6IGV2ZW50cyB0aGF0IGFyZSBmb3JjZSB0byBiZSBsaXN0LWl0ZW0gYnV0IHNwYW4gbXVsdGlwbGUgZGF5cyBzdGlsbCB0YWtlIHVwIHNwYWNlIGluIGxhdGVyIGNvbHVtbnNcbiAgICAgICAgdG9kbzogaW4gcHJpbnQgdmlldywgZm9yIG11bHRpLWRheSBldmVudHMsIGRvbid0IGRpc3BsYXkgdGl0bGUgd2l0aGluIG5vbi1zdGFydC9lbmQgc2Vnc1xuICAgICAgICAqL1xuICAgICAgICBub2Rlcy5wdXNoKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17J2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyl9XG4gICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgIHJlZj17aXNNaXJyb3IgPyBudWxsIDogdGhpcy5zZWdIYXJuZXNzUmVmcy5jcmVhdGVSZWYoa2V5KX1cbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHZpc2liaWxpdHk6IGlzVmlzaWJsZSA/ICgnJyBhcyBhbnkpIDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgIG1hcmdpblRvcDogaXNBYnNvbHV0ZSA/ICcnIDogcGxhY2VtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7aGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykgPyAoXG4gICAgICAgICAgICAgIDxUYWJsZUxpc3RJdGVtRXZlbnRcbiAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtpc0RyYWdnaW5nfVxuICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQ9e2luc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9ufVxuICAgICAgICAgICAgICAgIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ9e2RlZmF1bHREaXNwbGF5RXZlbnRFbmR9XG4gICAgICAgICAgICAgICAgey4uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDxUYWJsZUJsb2NrRXZlbnRcbiAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nPXtpc0RyYWdnaW5nfVxuICAgICAgICAgICAgICAgIGlzUmVzaXppbmc9e2lzUmVzaXppbmd9XG4gICAgICAgICAgICAgICAgaXNEYXRlU2VsZWN0aW5nPXtpc0RhdGVTZWxlY3Rpbmd9XG4gICAgICAgICAgICAgICAgaXNTZWxlY3RlZD17aW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb259XG4gICAgICAgICAgICAgICAgZGVmYXVsdERpc3BsYXlFdmVudEVuZD17ZGVmYXVsdERpc3BsYXlFdmVudEVuZH1cbiAgICAgICAgICAgICAgICB7Li4uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj4sXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuXG4gIHJlbmRlckZpbGxTZWdzKHNlZ3M6IFRhYmxlU2VnW10sIGZpbGxUeXBlOiBzdHJpbmcpOiBWTm9kZSB7XG4gICAgbGV0IHsgaXNSdGwgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCB7IHRvZGF5UmFuZ2UgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZVxuICAgIGxldCBub2RlczogVk5vZGVbXSA9IFtdXG5cbiAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGxldCBsZWZ0UmlnaHRDc3MgPSBpc1J0bCA/IHtcbiAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICB9IDoge1xuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgcmlnaHQ6IGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcuZmlyc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5sYXN0Q29sXSxcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVzLnB1c2goXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAga2V5PXtidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmMtZGF5Z3JpZC1iZy1oYXJuZXNzXCJcbiAgICAgICAgICAgIHN0eWxlPXtsZWZ0UmlnaHRDc3N9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2ZpbGxUeXBlID09PSAnYmctZXZlbnQnID9cbiAgICAgICAgICAgICAgPEJnRXZlbnQgc2VnPXtzZWd9IHsuLi5nZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSl9IC8+IDpcbiAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSl9XG4gICAgICAgICAgPC9kaXY+LFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCAuLi5ub2RlcylcbiAgfVxuXG4gIHVwZGF0ZVNpemluZyhpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgbGV0IHsgcHJvcHMsIGZyYW1lRWxSZWZzIH0gPSB0aGlzXG5cbiAgICBpZiAoXG4gICAgICAhcHJvcHMuZm9yUHJpbnQgJiZcbiAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuICAgICkge1xuICAgICAgaWYgKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgbGV0IGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKChjZWxsKSA9PiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XSlcblxuICAgICAgICBpZiAoZnJhbWVFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IG9yaWdpbkVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudFxuXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IC8vIHdpbGwgdHJpZ2dlciBpc0NlbGxQb3NpdGlvbnNDaGFuZ2VkLi4uXG4gICAgICAgICAgICBmcmFtZVBvc2l0aW9uczogbmV3IFBvc2l0aW9uQ2FjaGUoXG4gICAgICAgICAgICAgIG9yaWdpbkVsLFxuICAgICAgICAgICAgICBmcmFtZUVscyxcbiAgICAgICAgICAgICAgdHJ1ZSwgLy8gaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBsaW1pdEJ5Q29udGVudEhlaWdodCA9IHByb3BzLmRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBwcm9wcy5kYXlNYXhFdmVudFJvd3MgPT09IHRydWVcblxuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiB0aGlzLnF1ZXJ5RXZlbnRJbnN0YW5jZUhlaWdodHMoKSxcbiAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBxdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzKCkge1xuICAgIGxldCBzZWdFbE1hcCA9IHRoaXMuc2VnSGFybmVzc1JlZnMuY3VycmVudE1hcFxuICAgIGxldCBldmVudEluc3RhbmNlSGVpZ2h0czogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG5cbiAgICAvLyBnZXQgdGhlIG1heCBoZWlnaHQgYW1vbmdzdCBpbnN0YW5jZSBzZWdzXG4gICAgZm9yIChsZXQga2V5IGluIHNlZ0VsTWFwKSB7XG4gICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5yb3VuZChzZWdFbE1hcFtrZXldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodClcbiAgICAgIGxldCBpbnN0YW5jZUlkID0ga2V5LnNwbGl0KCc6JylbMF0gLy8gZGVjb25zdHJ1Y3QgaG93IHJlbmRlckZnU2VncyBtYWtlcyB0aGUga2V5XG4gICAgICBldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSA9IE1hdGgubWF4KGV2ZW50SW5zdGFuY2VIZWlnaHRzW2luc3RhbmNlSWRdIHx8IDAsIGhlaWdodClcbiAgICB9XG5cbiAgICByZXR1cm4gZXZlbnRJbnN0YW5jZUhlaWdodHNcbiAgfVxuXG4gIGNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkge1xuICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5XG4gICAgbGV0IGNlbGxFbCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XVxuICAgIGxldCBmY0NvbnRhaW5lckVsID0gdGhpcy5mZ0VsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XVxuXG4gICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBmY0NvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICB9XG5cbiAgcHVibGljIGdldENlbGxFbHMoKSB7XG4gICAgbGV0IGVsTWFwID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBcblxuICAgIHJldHVybiB0aGlzLnByb3BzLmNlbGxzLm1hcCgoY2VsbCkgPT4gZWxNYXBbY2VsbC5rZXldKVxuICB9XG59XG5cblRhYmxlUm93LmFkZFN0YXRlRXF1YWxpdHkoe1xuICBldmVudEluc3RhbmNlSGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSlcblxuZnVuY3Rpb24gYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3M6IFRhYmxlU2VnW10sIGNvbFBsYWNlbWVudHM6IFRhYmxlU2VnUGxhY2VtZW50W11bXSk6IFRhYmxlU2VnUGxhY2VtZW50W10ge1xuICBpZiAoIW1pcnJvclNlZ3MubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgbGV0IHRvcHNCeUluc3RhbmNlSWQgPSBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzKSAvLyBUT0RPOiBjYWNoZSB0aGlzIGF0IGZpcnN0IHJlbmRlcj9cbiAgcmV0dXJuIG1pcnJvclNlZ3MubWFwKChzZWc6IFRhYmxlU2VnKSA9PiAoe1xuICAgIHNlZyxcbiAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcbiAgICBtYXJnaW5Ub3A6IDAsXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBidWlsZEFic29sdXRlVG9wSGFzaChjb2xQbGFjZW1lbnRzOiBUYWJsZVNlZ1BsYWNlbWVudFtdW10pOiB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBudW1iZXIgfSB7XG4gIGxldCB0b3BzQnlJbnN0YW5jZUlkOiB7IFtpbnN0YW5jZUlkOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9XG5cbiAgZm9yIChsZXQgcGxhY2VtZW50cyBvZiBjb2xQbGFjZW1lbnRzKSB7XG4gICAgZm9yIChsZXQgcGxhY2VtZW50IG9mIHBsYWNlbWVudHMpIHtcbiAgICAgIHRvcHNCeUluc3RhbmNlSWRbcGxhY2VtZW50LnNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gcGxhY2VtZW50LmFic29sdXRlVG9wXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWRcbn1cbiIsImltcG9ydCB7XG4gIEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlLFxuICBWTm9kZSxcbiAgRGF0ZUNvbXBvbmVudCxcbiAgUmVmT2JqZWN0LFxuICBDc3NEaW1WYWx1ZSxcbiAgY3JlYXRlRWxlbWVudCxcbiAgUG9zaXRpb25DYWNoZSxcbiAgbWVtb2l6ZSxcbiAgYWRkRGF5cyxcbiAgUmVmTWFwLFxuICBEYXRlUmFuZ2UsXG4gIE5vd1RpbWVyLFxuICBEYXRlTWFya2VyLFxuICBEYXRlUHJvZmlsZSxcbiAgRnJhZ21lbnQsXG4gIEhpdCxcbiAgRGF5VGFibGVDZWxsLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlU2VnLCBzcGxpdFNlZ3NCeVJvdywgc3BsaXRJbnRlcmFjdGlvbkJ5Um93IH0gZnJvbSAnLi9UYWJsZVNlZydcbmltcG9ydCB7IFRhYmxlUm93IH0gZnJvbSAnLi9UYWJsZVJvdydcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVByb3BzIHtcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlXG4gIGNlbGxzOiBEYXlUYWJsZUNlbGxbXVtdIC8vIGNlbGxzLUJZLVJPV1xuICByZW5kZXJSb3dJbnRybz86ICgpID0+IFZOb2RlXG4gIGNvbEdyb3VwTm9kZTogVk5vZGVcbiAgdGFibGVNaW5XaWR0aDogQ3NzRGltVmFsdWVcbiAgZXhwYW5kUm93czogYm9vbGVhblxuICBzaG93V2Vla051bWJlcnM6IGJvb2xlYW5cbiAgY2xpZW50V2lkdGg6IG51bWJlciB8IG51bGxcbiAgY2xpZW50SGVpZ2h0OiBudW1iZXIgfCBudWxsXG4gIGJ1c2luZXNzSG91clNlZ3M6IFRhYmxlU2VnW11cbiAgYmdFdmVudFNlZ3M6IFRhYmxlU2VnW11cbiAgZmdFdmVudFNlZ3M6IFRhYmxlU2VnW11cbiAgZGF0ZVNlbGVjdGlvblNlZ3M6IFRhYmxlU2VnW11cbiAgZXZlbnRTZWxlY3Rpb246IHN0cmluZ1xuICBldmVudERyYWc6IEV2ZW50U2VnVWlJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRTZWdVaUludGVyYWN0aW9uU3RhdGUgfCBudWxsXG4gIGRheU1heEV2ZW50czogYm9vbGVhbiB8IG51bWJlclxuICBkYXlNYXhFdmVudFJvd3M6IGJvb2xlYW4gfCBudW1iZXJcbiAgaGVhZGVyQWxpZ25FbFJlZj86IFJlZk9iamVjdDxIVE1MRWxlbWVudD5cbiAgZm9yUHJpbnQ6IGJvb2xlYW5cbiAgaXNIaXRDb21ib0FsbG93ZWQ/OiAoaGl0MDogSGl0LCBoaXQxOiBIaXQpID0+IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxUYWJsZVByb3BzPiB7XG4gIHByaXZhdGUgc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdylcbiAgcHJpdmF0ZSBzcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdylcbiAgcHJpdmF0ZSBzcGxpdEZnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdylcbiAgcHJpdmF0ZSBzcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdylcbiAgcHJpdmF0ZSBzcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KVxuICBwcml2YXRlIHNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdylcbiAgcHJpdmF0ZSByb290RWw6IEhUTUxFbGVtZW50XG4gIHByaXZhdGUgcm93UmVmcyA9IG5ldyBSZWZNYXA8VGFibGVSb3c+KClcbiAgcHJpdmF0ZSByb3dQb3NpdGlvbnM6IFBvc2l0aW9uQ2FjaGVcbiAgcHJpdmF0ZSBjb2xQb3NpdGlvbnM6IFBvc2l0aW9uQ2FjaGVcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMgfSA9IHRoaXNcbiAgICBsZXQgeyBkYXRlUHJvZmlsZSwgZGF5TWF4RXZlbnRSb3dzLCBkYXlNYXhFdmVudHMsIGV4cGFuZFJvd3MgfSA9IHByb3BzXG4gICAgbGV0IHJvd0NudCA9IHByb3BzLmNlbGxzLmxlbmd0aFxuXG4gICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIHJvd0NudClcbiAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2Vncywgcm93Q250KVxuICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpXG4gICAgbGV0IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3cgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MocHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MsIHJvd0NudClcbiAgICBsZXQgZXZlbnREcmFnQnlSb3cgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZywgcm93Q250KVxuICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpXG5cbiAgICBsZXQgbGltaXRWaWFCYWxhbmNlZCA9IGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWVcblxuICAgIC8vIGlmIHJvd3MgY2FuJ3QgZXhwYW5kIHRvIGZpbGwgZml4ZWQgaGVpZ2h0LCBjYW4ndCBkbyBiYWxhbmNlZC1oZWlnaHQgZXZlbnQgbGltaXRcbiAgICAvLyBUT0RPOiBiZXN0IHBsYWNlIHRvIG5vcm1hbGl6ZSB0aGVzZSBvcHRpb25zP1xuICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2VcbiAgICAgIGRheU1heEV2ZW50Um93cyA9IG51bGxcbiAgICAgIGRheU1heEV2ZW50cyA9IG51bGxcbiAgICB9XG5cbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJywgLy8gd2lsbCBhbGwgcm93IGhlaWdodHMgYmUgZXF1YWw/XG4gICAgICBleHBhbmRSb3dzID8gJycgOiAnZmMtZGF5Z3JpZC1ib2R5LW5hdHVyYWwnLCAvLyB3aWxsIGhlaWdodCBvZiBvbmUgcm93IGRlcGVuZCBvbiB0aGUgb3RoZXJzP1xuICAgIF1cblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5qb2luKCcgJyl9XG4gICAgICAgIHJlZj17dGhpcy5oYW5kbGVSb290RWx9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxOb3dUaW1lciB1bml0PVwiZGF5XCI+XG4gICAgICAgICAgeyhub3dEYXRlOiBEYXRlTWFya2VyLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UpID0+IChcbiAgICAgICAgICAgIDxGcmFnbWVudD5cbiAgICAgICAgICAgICAgPHRhYmxlXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJyxcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3Byb3BzLmNvbEdyb3VwTm9kZX1cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICB7cHJvcHMuY2VsbHMubWFwKChjZWxscywgcm93KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxUYWJsZVJvd1xuICAgICAgICAgICAgICAgICAgICAgIHJlZj17dGhpcy5yb3dSZWZzLmNyZWF0ZVJlZihyb3cpfVxuICAgICAgICAgICAgICAgICAgICAgIGtleT17XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjZWxsc1swXS5kYXRlLnRvSVNPU3RyaW5nKCkgLyogYmVzdD8gb3IgcHV0IGtleSBvbiBjZWxsPyBvciB1c2UgZGlmZiBmb3JtYXR0ZXI/ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogcm93IC8vIGluIGNhc2UgdGhlcmUgYXJlIG5vIGNlbGxzIChsaWtlIHdoZW4gcmVzb3VyY2UgdmlldyBpcyBsb2FkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBzaG93RGF5TnVtYmVycz17cm93Q250ID4gMX1cbiAgICAgICAgICAgICAgICAgICAgICBzaG93V2Vla051bWJlcnM9e3Byb3BzLnNob3dXZWVrTnVtYmVyc31cbiAgICAgICAgICAgICAgICAgICAgICB0b2RheVJhbmdlPXt0b2RheVJhbmdlfVxuICAgICAgICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlPXtkYXRlUHJvZmlsZX1cbiAgICAgICAgICAgICAgICAgICAgICBjZWxscz17Y2VsbHN9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVySW50cm89e3Byb3BzLnJlbmRlclJvd0ludHJvfVxuICAgICAgICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91clNlZ3M9e2J1c2luZXNzSG91clNlZ3NCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uPXtwcm9wcy5ldmVudFNlbGVjdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICBiZ0V2ZW50U2Vncz17YmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqL31cbiAgICAgICAgICAgICAgICAgICAgICBmZ0V2ZW50U2Vncz17ZmdFdmVudFNlZ3NCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzPXtkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W3Jvd119XG4gICAgICAgICAgICAgICAgICAgICAgZXZlbnREcmFnPXtldmVudERyYWdCeVJvd1tyb3ddfVxuICAgICAgICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplPXtldmVudFJlc2l6ZUJ5Um93W3Jvd119XG4gICAgICAgICAgICAgICAgICAgICAgZGF5TWF4RXZlbnRzPXtkYXlNYXhFdmVudHN9XG4gICAgICAgICAgICAgICAgICAgICAgZGF5TWF4RXZlbnRSb3dzPXtkYXlNYXhFdmVudFJvd3N9XG4gICAgICAgICAgICAgICAgICAgICAgY2xpZW50V2lkdGg9e3Byb3BzLmNsaWVudFdpZHRofVxuICAgICAgICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodD17cHJvcHMuY2xpZW50SGVpZ2h0fVxuICAgICAgICAgICAgICAgICAgICAgIGZvclByaW50PXtwcm9wcy5mb3JQcmludH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvTm93VGltZXI+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cblxuICBoYW5kbGVSb290RWwgPSAocm9vdEVsOiBIVE1MRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICB0aGlzLnJvb3RFbCA9IHJvb3RFbFxuXG4gICAgaWYgKHJvb3RFbCkge1xuICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywge1xuICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcylcbiAgICB9XG4gIH1cblxuICAvLyBIaXQgU3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBwcmVwYXJlSGl0cygpIHtcbiAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKFxuICAgICAgdGhpcy5yb290RWwsXG4gICAgICB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcCgocm93T2JqKSA9PiByb3dPYmouZ2V0Q2VsbEVscygpWzBdKSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgIGZhbHNlLFxuICAgICAgdHJ1ZSwgLy8gdmVydGljYWxcbiAgICApXG5cbiAgICB0aGlzLmNvbFBvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKFxuICAgICAgdGhpcy5yb290RWwsXG4gICAgICB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKCksIC8vIGNlbGwgZWxzIGluIGZpcnN0IHJvd1xuICAgICAgdHJ1ZSwgLy8gaG9yaXpvbnRhbFxuICAgICAgZmFsc2UsXG4gICAgKVxuICB9XG5cbiAgcXVlcnlIaXQocG9zaXRpb25MZWZ0OiBudW1iZXIsIHBvc2l0aW9uVG9wOiBudW1iZXIpOiBIaXQge1xuICAgIGxldCB7IGNvbFBvc2l0aW9ucywgcm93UG9zaXRpb25zIH0gPSB0aGlzXG4gICAgbGV0IGNvbCA9IGNvbFBvc2l0aW9ucy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpXG4gICAgbGV0IHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKVxuXG4gICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG4gICAgICBsZXQgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGVQcm9maWxlOiB0aGlzLnByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICBkYXRlU3Bhbjoge1xuICAgICAgICAgIHJhbmdlOiB0aGlzLmdldENlbGxSYW5nZShyb3csIGNvbCksXG4gICAgICAgICAgYWxsRGF5OiB0cnVlLFxuICAgICAgICAgIC4uLmNlbGwuZXh0cmFEYXRlU3BhbixcbiAgICAgICAgfSxcbiAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgcmVjdDoge1xuICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgIHJpZ2h0OiBjb2xQb3NpdGlvbnMucmlnaHRzW2NvbF0sXG4gICAgICAgICAgdG9wOiByb3dQb3NpdGlvbnMudG9wc1tyb3ddLFxuICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XSxcbiAgICAgICAgfSxcbiAgICAgICAgbGF5ZXI6IDAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2VsbEVsKHJvdywgY29sKSB7XG4gICAgcmV0dXJuIHRoaXMucm93UmVmcy5jdXJyZW50TWFwW3Jvd10uZ2V0Q2VsbEVscygpW2NvbF0gLy8gVE9ETzogbm90IG9wdGltYWxcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSB7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZVxuICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCAxKVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2VnQWxsRGF5KHNlZzogVGFibGVTZWcpIHtcbiAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXlcbn1cbiIsImltcG9ydCB7IERheVRhYmxlTW9kZWwsIERhdGVSYW5nZSwgU2xpY2VyIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVNlZyB9IGZyb20gJy4vVGFibGVTZWcnXG5cbmV4cG9ydCBjbGFzcyBEYXlUYWJsZVNsaWNlciBleHRlbmRzIFNsaWNlcjxUYWJsZVNlZywgW0RheVRhYmxlTW9kZWxdPiB7XG4gIGZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWVcblxuICBzbGljZVJhbmdlKGRhdGVSYW5nZTogRGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsOiBEYXlUYWJsZU1vZGVsKTogVGFibGVTZWdbXSB7XG4gICAgcmV0dXJuIGRheVRhYmxlTW9kZWwuc2xpY2VSYW5nZShkYXRlUmFuZ2UpXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZiwgVk5vZGUsXG4gIEV2ZW50U3RvcmUsXG4gIEV2ZW50VWlIYXNoLFxuICBEYXRlU3BhbixcbiAgRXZlbnRJbnRlcmFjdGlvblN0YXRlLFxuICBEYXlUYWJsZU1vZGVsLFxuICBEdXJhdGlvbixcbiAgRGF0ZUNvbXBvbmVudCxcbiAgVmlld0NvbnRleHQsXG4gIFJlZk9iamVjdCxcbiAgQ3NzRGltVmFsdWUsXG4gIERhdGVQcm9maWxlLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi9UYWJsZSdcbmltcG9ydCB7IERheVRhYmxlU2xpY2VyIH0gZnJvbSAnLi9EYXlUYWJsZVNsaWNlcidcblxuZXhwb3J0IGludGVyZmFjZSBEYXlUYWJsZVByb3BzIHtcbiAgZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlLFxuICBkYXlUYWJsZU1vZGVsOiBEYXlUYWJsZU1vZGVsXG4gIG5leHREYXlUaHJlc2hvbGQ6IER1cmF0aW9uXG4gIGJ1c2luZXNzSG91cnM6IEV2ZW50U3RvcmVcbiAgZXZlbnRTdG9yZTogRXZlbnRTdG9yZVxuICBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoXG4gIGRhdGVTZWxlY3Rpb246IERhdGVTcGFuIHwgbnVsbFxuICBldmVudFNlbGVjdGlvbjogc3RyaW5nXG4gIGV2ZW50RHJhZzogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBldmVudFJlc2l6ZTogRXZlbnRJbnRlcmFjdGlvblN0YXRlIHwgbnVsbFxuICBjb2xHcm91cE5vZGU6IFZOb2RlXG4gIHRhYmxlTWluV2lkdGg6IENzc0RpbVZhbHVlXG4gIHJlbmRlclJvd0ludHJvPzogKCkgPT4gVk5vZGVcbiAgZGF5TWF4RXZlbnRzOiBib29sZWFuIHwgbnVtYmVyXG4gIGRheU1heEV2ZW50Um93czogYm9vbGVhbiB8IG51bWJlclxuICBleHBhbmRSb3dzOiBib29sZWFuXG4gIHNob3dXZWVrTnVtYmVyczogYm9vbGVhblxuICBoZWFkZXJBbGlnbkVsUmVmPzogUmVmT2JqZWN0PEhUTUxFbGVtZW50PiAvLyBmb3IgbW9yZSBwb3BvdmVyIGFsaWdubWVudFxuICBjbGllbnRXaWR0aDogbnVtYmVyIHwgbnVsbFxuICBjbGllbnRIZWlnaHQ6IG51bWJlciB8IG51bGxcbiAgZm9yUHJpbnQ6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIERheVRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxEYXlUYWJsZVByb3BzLCBWaWV3Q29udGV4dD4ge1xuICBwcml2YXRlIHNsaWNlciA9IG5ldyBEYXlUYWJsZVNsaWNlcigpXG4gIHByaXZhdGUgdGFibGVSZWYgPSBjcmVhdGVSZWY8VGFibGU+KClcblxuICByZW5kZXIoKSB7XG4gICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGVcbiAgICAgICAgcmVmPXt0aGlzLnRhYmxlUmVmfVxuICAgICAgICB7Li4udGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIHByb3BzLmRheVRhYmxlTW9kZWwpfVxuICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgIGNlbGxzPXtwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzfVxuICAgICAgICBjb2xHcm91cE5vZGU9e3Byb3BzLmNvbEdyb3VwTm9kZX1cbiAgICAgICAgdGFibGVNaW5XaWR0aD17cHJvcHMudGFibGVNaW5XaWR0aH1cbiAgICAgICAgcmVuZGVyUm93SW50cm89e3Byb3BzLnJlbmRlclJvd0ludHJvfVxuICAgICAgICBkYXlNYXhFdmVudHM9e3Byb3BzLmRheU1heEV2ZW50c31cbiAgICAgICAgZGF5TWF4RXZlbnRSb3dzPXtwcm9wcy5kYXlNYXhFdmVudFJvd3N9XG4gICAgICAgIHNob3dXZWVrTnVtYmVycz17cHJvcHMuc2hvd1dlZWtOdW1iZXJzfVxuICAgICAgICBleHBhbmRSb3dzPXtwcm9wcy5leHBhbmRSb3dzfVxuICAgICAgICBoZWFkZXJBbGlnbkVsUmVmPXtwcm9wcy5oZWFkZXJBbGlnbkVsUmVmfVxuICAgICAgICBjbGllbnRXaWR0aD17cHJvcHMuY2xpZW50V2lkdGh9XG4gICAgICAgIGNsaWVudEhlaWdodD17cHJvcHMuY2xpZW50SGVpZ2h0fVxuICAgICAgICBmb3JQcmludD17cHJvcHMuZm9yUHJpbnR9XG4gICAgICAvPlxuICAgIClcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLFxuICBEYXlIZWFkZXIsXG4gIERhdGVQcm9maWxlR2VuZXJhdG9yLFxuICBEYXRlUHJvZmlsZSxcbiAgbWVtb2l6ZSxcbiAgRGF5U2VyaWVzTW9kZWwsXG4gIERheVRhYmxlTW9kZWwsXG4gIENodW5rQ29udGVudENhbGxiYWNrQXJncyxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBUYWJsZVZpZXcgfSBmcm9tICcuL1RhYmxlVmlldydcbmltcG9ydCB7IERheVRhYmxlIH0gZnJvbSAnLi9EYXlUYWJsZSdcblxuZXhwb3J0IGNsYXNzIERheVRhYmxlVmlldyBleHRlbmRzIFRhYmxlVmlldyB7XG4gIHByaXZhdGUgYnVpbGREYXlUYWJsZU1vZGVsID0gbWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpXG4gIHByaXZhdGUgaGVhZGVyUmVmID0gY3JlYXRlUmVmPERheUhlYWRlcj4oKVxuICBwcml2YXRlIHRhYmxlUmVmID0gY3JlYXRlUmVmPERheVRhYmxlPigpXG5cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IG9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgeyBwcm9wcyB9ID0gdGhpc1xuICAgIGxldCBkYXlUYWJsZU1vZGVsID0gdGhpcy5idWlsZERheVRhYmxlTW9kZWwocHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKVxuXG4gICAgbGV0IGhlYWRlckNvbnRlbnQgPSBvcHRpb25zLmRheUhlYWRlcnMgJiYgKFxuICAgICAgPERheUhlYWRlclxuICAgICAgICByZWY9e3RoaXMuaGVhZGVyUmVmfVxuICAgICAgICBkYXRlUHJvZmlsZT17cHJvcHMuZGF0ZVByb2ZpbGV9XG4gICAgICAgIGRhdGVzPXtkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzfVxuICAgICAgICBkYXRlc1JlcERpc3RpbmN0RGF5cz17ZGF5VGFibGVNb2RlbC5yb3dDbnQgPT09IDF9XG4gICAgICAvPlxuICAgIClcblxuICAgIGxldCBib2R5Q29udGVudCA9IChjb250ZW50QXJnOiBDaHVua0NvbnRlbnRDYWxsYmFja0FyZ3MpID0+IChcbiAgICAgIDxEYXlUYWJsZVxuICAgICAgICByZWY9e3RoaXMudGFibGVSZWZ9XG4gICAgICAgIGRhdGVQcm9maWxlPXtwcm9wcy5kYXRlUHJvZmlsZX1cbiAgICAgICAgZGF5VGFibGVNb2RlbD17ZGF5VGFibGVNb2RlbH1cbiAgICAgICAgYnVzaW5lc3NIb3Vycz17cHJvcHMuYnVzaW5lc3NIb3Vyc31cbiAgICAgICAgZGF0ZVNlbGVjdGlvbj17cHJvcHMuZGF0ZVNlbGVjdGlvbn1cbiAgICAgICAgZXZlbnRTdG9yZT17cHJvcHMuZXZlbnRTdG9yZX1cbiAgICAgICAgZXZlbnRVaUJhc2VzPXtwcm9wcy5ldmVudFVpQmFzZXN9XG4gICAgICAgIGV2ZW50U2VsZWN0aW9uPXtwcm9wcy5ldmVudFNlbGVjdGlvbn1cbiAgICAgICAgZXZlbnREcmFnPXtwcm9wcy5ldmVudERyYWd9XG4gICAgICAgIGV2ZW50UmVzaXplPXtwcm9wcy5ldmVudFJlc2l6ZX1cbiAgICAgICAgbmV4dERheVRocmVzaG9sZD17b3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkfVxuICAgICAgICBjb2xHcm91cE5vZGU9e2NvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGV9XG4gICAgICAgIHRhYmxlTWluV2lkdGg9e2NvbnRlbnRBcmcudGFibGVNaW5XaWR0aH1cbiAgICAgICAgZGF5TWF4RXZlbnRzPXtvcHRpb25zLmRheU1heEV2ZW50c31cbiAgICAgICAgZGF5TWF4RXZlbnRSb3dzPXtvcHRpb25zLmRheU1heEV2ZW50Um93c31cbiAgICAgICAgc2hvd1dlZWtOdW1iZXJzPXtvcHRpb25zLndlZWtOdW1iZXJzfVxuICAgICAgICBleHBhbmRSb3dzPXshcHJvcHMuaXNIZWlnaHRBdXRvfVxuICAgICAgICBoZWFkZXJBbGlnbkVsUmVmPXt0aGlzLmhlYWRlckVsUmVmfVxuICAgICAgICBjbGllbnRXaWR0aD17Y29udGVudEFyZy5jbGllbnRXaWR0aH1cbiAgICAgICAgY2xpZW50SGVpZ2h0PXtjb250ZW50QXJnLmNsaWVudEhlaWdodH1cbiAgICAgICAgZm9yUHJpbnQ9e3Byb3BzLmZvclByaW50fVxuICAgICAgLz5cbiAgICApXG5cbiAgICByZXR1cm4gb3B0aW9ucy5kYXlNaW5XaWR0aFxuICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYm9keUNvbnRlbnQsIGRheVRhYmxlTW9kZWwuY29sQ250LCBvcHRpb25zLmRheU1pbldpZHRoKVxuICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlOiBEYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3I6IERhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gIGxldCBkYXlTZXJpZXMgPSBuZXcgRGF5U2VyaWVzTW9kZWwoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKVxuXG4gIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChcbiAgICBkYXlTZXJpZXMsXG4gICAgL3llYXJ8bW9udGh8d2Vlay8udGVzdChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSxcbiAgKVxufVxuIiwiaW1wb3J0IHtcbiAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gIGFkZFdlZWtzLCBkaWZmV2Vla3MsXG4gIERhdGVSYW5nZSxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbmV4cG9ydCBjbGFzcyBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIGV4dGVuZHMgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAvLyBDb21wdXRlcyB0aGUgZGF0ZSByYW5nZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuXG4gIGJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTogRGF0ZVJhbmdlIHtcbiAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHJlbmRlclJhbmdlID0gc3VwZXIuYnVpbGRSZW5kZXJSYW5nZShjdXJyZW50UmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpXG4gICAgbGV0IHN0YXJ0ID0gcmVuZGVyUmFuZ2Uuc3RhcnRcbiAgICBsZXQgZW5kID0gcmVuZGVyUmFuZ2UuZW5kXG4gICAgbGV0IGVuZE9mV2Vla1xuXG4gICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcbiAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpXG5cbiAgICAgIC8vIG1ha2UgZW5kLW9mLXdlZWsgaWYgbm90IGFscmVhZHlcbiAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKVxuICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcbiAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kT2ZXZWVrLCAxKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSA2IHdlZWtzXG4gICAgaWYgKFxuICAgICAgdGhpcy5wcm9wcy5tb250aE1vZGUgJiZcbiAgICAgIHRoaXMucHJvcHMuZml4ZWRXZWVrQ291bnRcbiAgICApIHtcbiAgICAgIGxldCByb3dDbnQgPSBNYXRoLmNlaWwoIC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcbiAgICAgICAgZGlmZldlZWtzKHN0YXJ0LCBlbmQpLFxuICAgICAgKVxuICAgICAgZW5kID0gYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KVxuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IERheVRhYmxlVmlldyB9IGZyb20gJy4vRGF5VGFibGVWaWV3J1xuaW1wb3J0IHsgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4vVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvcidcbmltcG9ydCAnLi9tYWluLmNzcydcblxuZXhwb3J0IHsgRGF5VGFibGUgfSBmcm9tICcuL0RheVRhYmxlJ1xuZXhwb3J0IHsgRGF5VGFibGVTbGljZXIgfSBmcm9tICcuL0RheVRhYmxlU2xpY2VyJ1xuZXhwb3J0IHsgVGFibGUgfSBmcm9tICcuL1RhYmxlJ1xuZXhwb3J0IHsgVGFibGVTZWcgfSBmcm9tICcuL1RhYmxlU2VnJ1xuZXhwb3J0IHsgVGFibGVWaWV3IH0gZnJvbSAnLi9UYWJsZVZpZXcnXG5leHBvcnQgeyBidWlsZERheVRhYmxlTW9kZWwgfSBmcm9tICcuL0RheVRhYmxlVmlldydcbmV4cG9ydCB7IERheVRhYmxlVmlldyBhcyBEYXlHcmlkVmlldyB9IC8vIGV4cG9ydCBhcyBvbGQgbmFtZSFcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGx1Z2luKHtcbiAgaW5pdGlhbFZpZXc6ICdkYXlHcmlkTW9udGgnLFxuICB2aWV3czoge1xuXG4gICAgZGF5R3JpZDoge1xuICAgICAgY29tcG9uZW50OiBEYXlUYWJsZVZpZXcsXG4gICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgIH0sXG5cbiAgICBkYXlHcmlkRGF5OiB7XG4gICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgfSxcblxuICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgIH0sXG5cbiAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxuICAgICAgbW9udGhNb2RlOiB0cnVlLFxuICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXG4gICAgfSxcblxuICB9LFxufSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/interaction/main.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/interaction/main.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Draggable\": function() { return /* binding */ ExternalDraggable; },\n/* harmony export */   \"FeaturefulElementDragging\": function() { return /* binding */ FeaturefulElementDragging; },\n/* harmony export */   \"PointerDragging\": function() { return /* binding */ PointerDragging; },\n/* harmony export */   \"ThirdPartyDraggable\": function() { return /* binding */ ThirdPartyDraggable; }\n/* harmony export */ });\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait = 500;\nvar ignoreMouseDepth = 0;\nvar listenerCnt = 0;\nvar isWindowTouchMoveCancelled = false;\n/*\nUses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\nTracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\nAlso, tracks if there was touch-scrolling.\nAlso, can prevent touch-scrolling from happening.\nAlso, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\nemits:\n- pointerdown\n- pointermove\n- pointerup\n*/\n\nvar PointerDragging = function () {\n  function PointerDragging(containerEl) {\n    var _this = this;\n\n    this.subjectEl = null; // options that can be directly assigned by caller\n\n    this.selector = ''; // will cause subjectEl in all emitted events to be this element\n\n    this.handleSelector = '';\n    this.shouldIgnoreMove = false;\n    this.shouldWatchScroll = true; // for simulating pointermove on scroll\n    // internal states\n\n    this.isDragging = false;\n    this.isTouchDragging = false;\n    this.wasTouchScroll = false; // Mouse\n    // ----------------------------------------------------------------------------------------------------\n\n    this.handleMouseDown = function (ev) {\n      if (!_this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && _this.tryStart(ev)) {\n        var pev = _this.createEventFromMouse(ev, true);\n\n        _this.emitter.trigger('pointerdown', pev);\n\n        _this.initScrollWatch(pev);\n\n        if (!_this.shouldIgnoreMove) {\n          document.addEventListener('mousemove', _this.handleMouseMove);\n        }\n\n        document.addEventListener('mouseup', _this.handleMouseUp);\n      }\n    };\n\n    this.handleMouseMove = function (ev) {\n      var pev = _this.createEventFromMouse(ev);\n\n      _this.recordCoords(pev);\n\n      _this.emitter.trigger('pointermove', pev);\n    };\n\n    this.handleMouseUp = function (ev) {\n      document.removeEventListener('mousemove', _this.handleMouseMove);\n      document.removeEventListener('mouseup', _this.handleMouseUp);\n\n      _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));\n\n      _this.cleanup(); // call last so that pointerup has access to props\n\n    }; // Touch\n    // ----------------------------------------------------------------------------------------------------\n\n\n    this.handleTouchStart = function (ev) {\n      if (_this.tryStart(ev)) {\n        _this.isTouchDragging = true;\n\n        var pev = _this.createEventFromTouch(ev, true);\n\n        _this.emitter.trigger('pointerdown', pev);\n\n        _this.initScrollWatch(pev); // unlike mouse, need to attach to target, not document\n        // https://stackoverflow.com/a/45760014\n\n\n        var targetEl = ev.target;\n\n        if (!_this.shouldIgnoreMove) {\n          targetEl.addEventListener('touchmove', _this.handleTouchMove);\n        }\n\n        targetEl.addEventListener('touchend', _this.handleTouchEnd);\n        targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end\n        // attach a handler to get called when ANY scroll action happens on the page.\n        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n        // http://stackoverflow.com/a/32954565/96342\n\n        window.addEventListener('scroll', _this.handleTouchScroll, true);\n      }\n    };\n\n    this.handleTouchMove = function (ev) {\n      var pev = _this.createEventFromTouch(ev);\n\n      _this.recordCoords(pev);\n\n      _this.emitter.trigger('pointermove', pev);\n    };\n\n    this.handleTouchEnd = function (ev) {\n      if (_this.isDragging) {\n        // done to guard against touchend followed by touchcancel\n        var targetEl = ev.target;\n        targetEl.removeEventListener('touchmove', _this.handleTouchMove);\n        targetEl.removeEventListener('touchend', _this.handleTouchEnd);\n        targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);\n        window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true\n\n        _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));\n\n        _this.cleanup(); // call last so that pointerup has access to props\n\n\n        _this.isTouchDragging = false;\n        startIgnoringMouse();\n      }\n    };\n\n    this.handleTouchScroll = function () {\n      _this.wasTouchScroll = true;\n    };\n\n    this.handleScroll = function (ev) {\n      if (!_this.shouldIgnoreMove) {\n        var pageX = window.pageXOffset - _this.prevScrollX + _this.prevPageX;\n        var pageY = window.pageYOffset - _this.prevScrollY + _this.prevPageY;\n\n        _this.emitter.trigger('pointermove', {\n          origEvent: ev,\n          isTouch: _this.isTouchDragging,\n          subjectEl: _this.subjectEl,\n          pageX: pageX,\n          pageY: pageY,\n          deltaX: pageX - _this.origPageX,\n          deltaY: pageY - _this.origPageY\n        });\n      }\n    };\n\n    this.containerEl = containerEl;\n    this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n    containerEl.addEventListener('mousedown', this.handleMouseDown);\n    containerEl.addEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    listenerCreated();\n  }\n\n  PointerDragging.prototype.destroy = function () {\n    this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n    this.containerEl.removeEventListener('touchstart', this.handleTouchStart, {\n      passive: true\n    });\n    listenerDestroyed();\n  };\n\n  PointerDragging.prototype.tryStart = function (ev) {\n    var subjectEl = this.querySubjectEl(ev);\n    var downEl = ev.target;\n\n    if (subjectEl && (!this.handleSelector || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, this.handleSelector))) {\n      this.subjectEl = subjectEl;\n      this.isDragging = true; // do this first so cancelTouchScroll will work\n\n      this.wasTouchScroll = false;\n      return true;\n    }\n\n    return false;\n  };\n\n  PointerDragging.prototype.cleanup = function () {\n    isWindowTouchMoveCancelled = false;\n    this.isDragging = false;\n    this.subjectEl = null; // keep wasTouchScroll around for later access\n\n    this.destroyScrollWatch();\n  };\n\n  PointerDragging.prototype.querySubjectEl = function (ev) {\n    if (this.selector) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.target, this.selector);\n    }\n\n    return this.containerEl;\n  };\n\n  PointerDragging.prototype.shouldIgnoreMouse = function () {\n    return ignoreMouseDepth || this.isTouchDragging;\n  }; // can be called by user of this class, to cancel touch-based scrolling for the current drag\n\n\n  PointerDragging.prototype.cancelTouchScroll = function () {\n    if (this.isDragging) {\n      isWindowTouchMoveCancelled = true;\n    }\n  }; // Scrolling that simulates pointermoves\n  // ----------------------------------------------------------------------------------------------------\n\n\n  PointerDragging.prototype.initScrollWatch = function (ev) {\n    if (this.shouldWatchScroll) {\n      this.recordCoords(ev);\n      window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n    }\n  };\n\n  PointerDragging.prototype.recordCoords = function (ev) {\n    if (this.shouldWatchScroll) {\n      this.prevPageX = ev.pageX;\n      this.prevPageY = ev.pageY;\n      this.prevScrollX = window.pageXOffset;\n      this.prevScrollY = window.pageYOffset;\n    }\n  };\n\n  PointerDragging.prototype.destroyScrollWatch = function () {\n    if (this.shouldWatchScroll) {\n      window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n    }\n  }; // Event Normalization\n  // ----------------------------------------------------------------------------------------------------\n\n\n  PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {\n    var deltaX = 0;\n    var deltaY = 0; // TODO: repeat code\n\n    if (isFirst) {\n      this.origPageX = ev.pageX;\n      this.origPageY = ev.pageY;\n    } else {\n      deltaX = ev.pageX - this.origPageX;\n      deltaY = ev.pageY - this.origPageY;\n    }\n\n    return {\n      origEvent: ev,\n      isTouch: false,\n      subjectEl: this.subjectEl,\n      pageX: ev.pageX,\n      pageY: ev.pageY,\n      deltaX: deltaX,\n      deltaY: deltaY\n    };\n  };\n\n  PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {\n    var touches = ev.touches;\n    var pageX;\n    var pageY;\n    var deltaX = 0;\n    var deltaY = 0; // if touch coords available, prefer,\n    // because FF would give bad ev.pageX ev.pageY\n\n    if (touches && touches.length) {\n      pageX = touches[0].pageX;\n      pageY = touches[0].pageY;\n    } else {\n      pageX = ev.pageX;\n      pageY = ev.pageY;\n    } // TODO: repeat code\n\n\n    if (isFirst) {\n      this.origPageX = pageX;\n      this.origPageY = pageY;\n    } else {\n      deltaX = pageX - this.origPageX;\n      deltaY = pageY - this.origPageY;\n    }\n\n    return {\n      origEvent: ev,\n      isTouch: true,\n      subjectEl: this.subjectEl,\n      pageX: pageX,\n      pageY: pageY,\n      deltaX: deltaX,\n      deltaY: deltaY\n    };\n  };\n\n  return PointerDragging;\n}(); // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n\n\nfunction isPrimaryMouseButton(ev) {\n  return ev.button === 0 && !ev.ctrlKey;\n} // Ignoring fake mouse events generated by touch\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction startIgnoringMouse() {\n  ignoreMouseDepth += 1;\n  setTimeout(function () {\n    ignoreMouseDepth -= 1;\n  }, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.touchMouseIgnoreWait);\n} // We want to attach touchmove as early as possible for Safari\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction listenerCreated() {\n  listenerCnt += 1;\n\n  if (listenerCnt === 1) {\n    window.addEventListener('touchmove', onWindowTouchMove, {\n      passive: false\n    });\n  }\n}\n\nfunction listenerDestroyed() {\n  listenerCnt -= 1;\n\n  if (!listenerCnt) {\n    window.removeEventListener('touchmove', onWindowTouchMove, {\n      passive: false\n    });\n  }\n}\n\nfunction onWindowTouchMove(ev) {\n  if (isWindowTouchMoveCancelled) {\n    ev.preventDefault();\n  }\n}\n/*\nAn effect in which an element follows the movement of a pointer across the screen.\nThe moving element is a clone of some other element.\nMust call start + handleMove + stop.\n*/\n\n\nvar ElementMirror = function () {\n  function ElementMirror() {\n    this.isVisible = false; // must be explicitly enabled\n\n    this.sourceEl = null;\n    this.mirrorEl = null;\n    this.sourceElRect = null; // screen coords relative to viewport\n    // options that can be set directly by caller\n\n    this.parentNode = document.body; // HIGHLY SUGGESTED to set this to sidestep ShadowDOM issues\n\n    this.zIndex = 9999;\n    this.revertDuration = 0;\n  }\n\n  ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {\n    this.sourceEl = sourceEl;\n    this.sourceElRect = this.sourceEl.getBoundingClientRect();\n    this.origScreenX = pageX - window.pageXOffset;\n    this.origScreenY = pageY - window.pageYOffset;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.updateElPosition();\n  };\n\n  ElementMirror.prototype.handleMove = function (pageX, pageY) {\n    this.deltaX = pageX - window.pageXOffset - this.origScreenX;\n    this.deltaY = pageY - window.pageYOffset - this.origScreenY;\n    this.updateElPosition();\n  }; // can be called before start\n\n\n  ElementMirror.prototype.setIsVisible = function (bool) {\n    if (bool) {\n      if (!this.isVisible) {\n        if (this.mirrorEl) {\n          this.mirrorEl.style.display = '';\n        }\n\n        this.isVisible = bool; // needs to happen before updateElPosition\n\n        this.updateElPosition(); // because was not updating the position while invisible\n      }\n    } else if (this.isVisible) {\n      if (this.mirrorEl) {\n        this.mirrorEl.style.display = 'none';\n      }\n\n      this.isVisible = bool;\n    }\n  }; // always async\n\n\n  ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {\n    var _this = this;\n\n    var done = function done() {\n      _this.cleanup();\n\n      callback();\n    };\n\n    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) // if same coords, transition won't work\n    ) {\n      this.doRevertAnimation(done, this.revertDuration);\n    } else {\n      setTimeout(done, 0);\n    }\n  };\n\n  ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {\n    var mirrorEl = this.mirrorEl;\n    var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n\n    mirrorEl.style.transition = 'top ' + revertDuration + 'ms,' + 'left ' + revertDuration + 'ms';\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n      left: finalSourceElRect.left,\n      top: finalSourceElRect.top\n    });\n    (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.whenTransitionDone)(mirrorEl, function () {\n      mirrorEl.style.transition = '';\n      callback();\n    });\n  };\n\n  ElementMirror.prototype.cleanup = function () {\n    if (this.mirrorEl) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.removeElement)(this.mirrorEl);\n      this.mirrorEl = null;\n    }\n\n    this.sourceEl = null;\n  };\n\n  ElementMirror.prototype.updateElPosition = function () {\n    if (this.sourceEl && this.isVisible) {\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(this.getMirrorEl(), {\n        left: this.sourceElRect.left + this.deltaX,\n        top: this.sourceElRect.top + this.deltaY\n      });\n    }\n  };\n\n  ElementMirror.prototype.getMirrorEl = function () {\n    var sourceElRect = this.sourceElRect;\n    var mirrorEl = this.mirrorEl;\n\n    if (!mirrorEl) {\n      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n      // we don't want long taps or any mouse interaction causing selection/menus.\n      // would use preventSelection(), but that prevents selectstart, causing problems.\n\n      mirrorEl.classList.add('fc-unselectable');\n      mirrorEl.classList.add('fc-event-dragging');\n      (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyStyle)(mirrorEl, {\n        position: 'fixed',\n        zIndex: this.zIndex,\n        visibility: '',\n        boxSizing: 'border-box',\n        width: sourceElRect.right - sourceElRect.left,\n        height: sourceElRect.bottom - sourceElRect.top,\n        right: 'auto',\n        bottom: 'auto',\n        margin: 0\n      });\n      this.parentNode.appendChild(mirrorEl);\n    }\n\n    return mirrorEl;\n  };\n\n  return ElementMirror;\n}();\n/*\nIs a cache for a given element's scroll information (all the info that ScrollController stores)\nin addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\nThe cache can be in one of two modes:\n- doesListening:false - ignores when the container is scrolled by someone else\n- doesListening:true - watch for scrolling and update the cache\n*/\n\n\nvar ScrollGeomCache = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ScrollGeomCache, _super);\n\n  function ScrollGeomCache(scrollController, doesListening) {\n    var _this = _super.call(this) || this;\n\n    _this.handleScroll = function () {\n      _this.scrollTop = _this.scrollController.getScrollTop();\n      _this.scrollLeft = _this.scrollController.getScrollLeft();\n\n      _this.handleScrollChange();\n    };\n\n    _this.scrollController = scrollController;\n    _this.doesListening = doesListening;\n    _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();\n    _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();\n    _this.scrollWidth = scrollController.getScrollWidth();\n    _this.scrollHeight = scrollController.getScrollHeight();\n    _this.clientWidth = scrollController.getClientWidth();\n    _this.clientHeight = scrollController.getClientHeight();\n    _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values\n\n    if (_this.doesListening) {\n      _this.getEventTarget().addEventListener('scroll', _this.handleScroll);\n    }\n\n    return _this;\n  }\n\n  ScrollGeomCache.prototype.destroy = function () {\n    if (this.doesListening) {\n      this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n    }\n  };\n\n  ScrollGeomCache.prototype.getScrollTop = function () {\n    return this.scrollTop;\n  };\n\n  ScrollGeomCache.prototype.getScrollLeft = function () {\n    return this.scrollLeft;\n  };\n\n  ScrollGeomCache.prototype.setScrollTop = function (top) {\n    this.scrollController.setScrollTop(top);\n\n    if (!this.doesListening) {\n      // we are not relying on the element to normalize out-of-bounds scroll values\n      // so we need to sanitize ourselves\n      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n      this.handleScrollChange();\n    }\n  };\n\n  ScrollGeomCache.prototype.setScrollLeft = function (top) {\n    this.scrollController.setScrollLeft(top);\n\n    if (!this.doesListening) {\n      // we are not relying on the element to normalize out-of-bounds scroll values\n      // so we need to sanitize ourselves\n      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n      this.handleScrollChange();\n    }\n  };\n\n  ScrollGeomCache.prototype.getClientWidth = function () {\n    return this.clientWidth;\n  };\n\n  ScrollGeomCache.prototype.getClientHeight = function () {\n    return this.clientHeight;\n  };\n\n  ScrollGeomCache.prototype.getScrollWidth = function () {\n    return this.scrollWidth;\n  };\n\n  ScrollGeomCache.prototype.getScrollHeight = function () {\n    return this.scrollHeight;\n  };\n\n  ScrollGeomCache.prototype.handleScrollChange = function () {};\n\n  return ScrollGeomCache;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ScrollController);\n\nvar ElementScrollGeomCache = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(ElementScrollGeomCache, _super);\n\n  function ElementScrollGeomCache(el, doesListening) {\n    return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementScrollController(el), doesListening) || this;\n  }\n\n  ElementScrollGeomCache.prototype.getEventTarget = function () {\n    return this.scrollController.el;\n  };\n\n  ElementScrollGeomCache.prototype.computeClientRect = function () {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeInnerRect)(this.scrollController.el);\n  };\n\n  return ElementScrollGeomCache;\n}(ScrollGeomCache);\n\nvar WindowScrollGeomCache = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WindowScrollGeomCache, _super);\n\n  function WindowScrollGeomCache(doesListening) {\n    return _super.call(this, new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.WindowScrollController(), doesListening) || this;\n  }\n\n  WindowScrollGeomCache.prototype.getEventTarget = function () {\n    return window;\n  };\n\n  WindowScrollGeomCache.prototype.computeClientRect = function () {\n    return {\n      left: this.scrollLeft,\n      right: this.scrollLeft + this.clientWidth,\n      top: this.scrollTop,\n      bottom: this.scrollTop + this.clientHeight\n    };\n  }; // the window is the only scroll object that changes it's rectangle relative\n  // to the document's topleft as it scrolls\n\n\n  WindowScrollGeomCache.prototype.handleScrollChange = function () {\n    this.clientRect = this.computeClientRect();\n  };\n\n  return WindowScrollGeomCache;\n}(ScrollGeomCache); // If available we are using native \"performance\" API instead of \"Date\"\n// Read more about it on MDN:\n// https://developer.mozilla.org/en-US/docs/Web/API/Performance\n\n\nvar getTime = typeof performance === 'function' ? performance.now : Date.now;\n/*\nFor a pointer interaction, automatically scrolls certain scroll containers when the pointer\napproaches the edge.\n\nThe caller must call start + handleMove + stop.\n*/\n\nvar AutoScroller = function () {\n  function AutoScroller() {\n    var _this = this; // options that can be set by caller\n\n\n    this.isEnabled = true;\n    this.scrollQuery = [window, '.fc-scroller'];\n    this.edgeThreshold = 50; // pixels\n\n    this.maxVelocity = 300; // pixels per second\n    // internal state\n\n    this.pointerScreenX = null;\n    this.pointerScreenY = null;\n    this.isAnimating = false;\n    this.scrollCaches = null; // protect against the initial pointerdown being too close to an edge and starting the scroll\n\n    this.everMovedUp = false;\n    this.everMovedDown = false;\n    this.everMovedLeft = false;\n    this.everMovedRight = false;\n\n    this.animate = function () {\n      if (_this.isAnimating) {\n        // wasn't cancelled between animation calls\n        var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);\n\n        if (edge) {\n          var now = getTime();\n\n          _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);\n\n          _this.requestAnimation(now);\n        } else {\n          _this.isAnimating = false; // will stop animation\n        }\n      }\n    };\n  }\n\n  AutoScroller.prototype.start = function (pageX, pageY, scrollStartEl) {\n    if (this.isEnabled) {\n      this.scrollCaches = this.buildCaches(scrollStartEl);\n      this.pointerScreenX = null;\n      this.pointerScreenY = null;\n      this.everMovedUp = false;\n      this.everMovedDown = false;\n      this.everMovedLeft = false;\n      this.everMovedRight = false;\n      this.handleMove(pageX, pageY);\n    }\n  };\n\n  AutoScroller.prototype.handleMove = function (pageX, pageY) {\n    if (this.isEnabled) {\n      var pointerScreenX = pageX - window.pageXOffset;\n      var pointerScreenY = pageY - window.pageYOffset;\n      var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n      var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n\n      if (yDelta < 0) {\n        this.everMovedUp = true;\n      } else if (yDelta > 0) {\n        this.everMovedDown = true;\n      }\n\n      if (xDelta < 0) {\n        this.everMovedLeft = true;\n      } else if (xDelta > 0) {\n        this.everMovedRight = true;\n      }\n\n      this.pointerScreenX = pointerScreenX;\n      this.pointerScreenY = pointerScreenY;\n\n      if (!this.isAnimating) {\n        this.isAnimating = true;\n        this.requestAnimation(getTime());\n      }\n    }\n  };\n\n  AutoScroller.prototype.stop = function () {\n    if (this.isEnabled) {\n      this.isAnimating = false; // will stop animation\n\n      for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n        var scrollCache = _a[_i];\n        scrollCache.destroy();\n      }\n\n      this.scrollCaches = null;\n    }\n  };\n\n  AutoScroller.prototype.requestAnimation = function (now) {\n    this.msSinceRequest = now;\n    requestAnimationFrame(this.animate);\n  };\n\n  AutoScroller.prototype.handleSide = function (edge, seconds) {\n    var scrollCache = edge.scrollCache;\n    var edgeThreshold = this.edgeThreshold;\n    var invDistance = edgeThreshold - edge.distance;\n    var velocity = // the closer to the edge, the faster we scroll\n    invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic\n    this.maxVelocity * seconds;\n    var sign = 1;\n\n    switch (edge.name) {\n      case 'left':\n        sign = -1;\n      // falls through\n\n      case 'right':\n        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n        break;\n\n      case 'top':\n        sign = -1;\n      // falls through\n\n      case 'bottom':\n        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n        break;\n    }\n  }; // left/top are relative to document topleft\n\n\n  AutoScroller.prototype.computeBestEdge = function (left, top) {\n    var edgeThreshold = this.edgeThreshold;\n    var bestSide = null;\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      var rect = scrollCache.clientRect;\n      var leftDist = left - rect.left;\n      var rightDist = rect.right - left;\n      var topDist = top - rect.top;\n      var bottomDist = rect.bottom - top; // completely within the rect?\n\n      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'top',\n            distance: topDist\n          };\n        }\n\n        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'bottom',\n            distance: bottomDist\n          };\n        }\n\n        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'left',\n            distance: leftDist\n          };\n        }\n\n        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {\n          bestSide = {\n            scrollCache: scrollCache,\n            name: 'right',\n            distance: rightDist\n          };\n        }\n      }\n    }\n\n    return bestSide;\n  };\n\n  AutoScroller.prototype.buildCaches = function (scrollStartEl) {\n    return this.queryScrollEls(scrollStartEl).map(function (el) {\n      if (el === window) {\n        return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n      }\n\n      return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n    });\n  };\n\n  AutoScroller.prototype.queryScrollEls = function (scrollStartEl) {\n    var els = [];\n\n    for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {\n      var query = _a[_i];\n\n      if (_typeof(query) === 'object') {\n        els.push(query);\n      } else {\n        els.push.apply(els, Array.prototype.slice.call((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(scrollStartEl).querySelectorAll(query)));\n      }\n    }\n\n    return els;\n  };\n\n  return AutoScroller;\n}();\n/*\nMonitors dragging on an element. Has a number of high-level features:\n- minimum distance required before dragging\n- minimum wait time (\"delay\") before dragging\n- a mirror element that follows the pointer\n*/\n\n\nvar FeaturefulElementDragging = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(FeaturefulElementDragging, _super);\n\n  function FeaturefulElementDragging(containerEl, selector) {\n    var _this = _super.call(this, containerEl) || this;\n\n    _this.containerEl = containerEl; // options that can be directly set by caller\n    // the caller can also set the PointerDragging's options as well\n\n    _this.delay = null;\n    _this.minDistance = 0;\n    _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n\n    _this.mirrorNeedsRevert = false;\n    _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n\n    _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n\n    _this.isDelayEnded = false;\n    _this.isDistanceSurpassed = false;\n    _this.delayTimeoutId = null;\n\n    _this.onPointerDown = function (ev) {\n      if (!_this.isDragging) {\n        // so new drag doesn't happen while revert animation is going\n        _this.isInteracting = true;\n        _this.isDelayEnded = false;\n        _this.isDistanceSurpassed = false;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventSelection)(document.body);\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.preventContextMenu)(document.body); // prevent links from being visited if there's an eventual drag.\n        // also prevents selection in older browsers (maybe?).\n        // not necessary for touch, besides, browser would complain about passiveness.\n\n        if (!ev.isTouch) {\n          ev.origEvent.preventDefault();\n        }\n\n        _this.emitter.trigger('pointerdown', ev);\n\n        if (_this.isInteracting && // not destroyed via pointerdown handler\n        !_this.pointer.shouldIgnoreMove) {\n          // actions related to initiating dragstart+dragmove+dragend...\n          _this.mirror.setIsVisible(false); // reset. caller must set-visible\n\n\n          _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n\n\n          _this.startDelay(ev);\n\n          if (!_this.minDistance) {\n            _this.handleDistanceSurpassed(ev);\n          }\n        }\n      }\n    };\n\n    _this.onPointerMove = function (ev) {\n      if (_this.isInteracting) {\n        _this.emitter.trigger('pointermove', ev);\n\n        if (!_this.isDistanceSurpassed) {\n          var minDistance = _this.minDistance;\n          var distanceSq = void 0; // current distance from the origin, squared\n\n          var deltaX = ev.deltaX,\n              deltaY = ev.deltaY;\n          distanceSq = deltaX * deltaX + deltaY * deltaY;\n\n          if (distanceSq >= minDistance * minDistance) {\n            // use pythagorean theorem\n            _this.handleDistanceSurpassed(ev);\n          }\n        }\n\n        if (_this.isDragging) {\n          // a real pointer move? (not one simulated by scrolling)\n          if (ev.origEvent.type !== 'scroll') {\n            _this.mirror.handleMove(ev.pageX, ev.pageY);\n\n            _this.autoScroller.handleMove(ev.pageX, ev.pageY);\n          }\n\n          _this.emitter.trigger('dragmove', ev);\n        }\n      }\n    };\n\n    _this.onPointerUp = function (ev) {\n      if (_this.isInteracting) {\n        _this.isInteracting = false;\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowSelection)(document.body);\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.allowContextMenu)(document.body);\n\n        _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n\n\n        if (_this.isDragging) {\n          _this.autoScroller.stop();\n\n          _this.tryStopDrag(ev); // which will stop the mirror\n\n        }\n\n        if (_this.delayTimeoutId) {\n          clearTimeout(_this.delayTimeoutId);\n          _this.delayTimeoutId = null;\n        }\n      }\n    };\n\n    var pointer = _this.pointer = new PointerDragging(containerEl);\n    pointer.emitter.on('pointerdown', _this.onPointerDown);\n    pointer.emitter.on('pointermove', _this.onPointerMove);\n    pointer.emitter.on('pointerup', _this.onPointerUp);\n\n    if (selector) {\n      pointer.selector = selector;\n    }\n\n    _this.mirror = new ElementMirror();\n    _this.autoScroller = new AutoScroller();\n    return _this;\n  }\n\n  FeaturefulElementDragging.prototype.destroy = function () {\n    this.pointer.destroy(); // HACK: simulate a pointer-up to end the current drag\n    // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n\n    this.onPointerUp({});\n  };\n\n  FeaturefulElementDragging.prototype.startDelay = function (ev) {\n    var _this = this;\n\n    if (typeof this.delay === 'number') {\n      this.delayTimeoutId = setTimeout(function () {\n        _this.delayTimeoutId = null;\n\n        _this.handleDelayEnd(ev);\n      }, this.delay); // not assignable to number!\n    } else {\n      this.handleDelayEnd(ev);\n    }\n  };\n\n  FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {\n    this.isDelayEnded = true;\n    this.tryStartDrag(ev);\n  };\n\n  FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {\n    this.isDistanceSurpassed = true;\n    this.tryStartDrag(ev);\n  };\n\n  FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {\n    if (this.isDelayEnded && this.isDistanceSurpassed) {\n      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n        this.isDragging = true;\n        this.mirrorNeedsRevert = false;\n        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);\n        this.emitter.trigger('dragstart', ev);\n\n        if (this.touchScrollAllowed === false) {\n          this.pointer.cancelTouchScroll();\n        }\n      }\n    }\n  };\n\n  FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {\n    // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n    // that come from the document to fire beforehand. much more convenient this way.\n    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n  };\n\n  FeaturefulElementDragging.prototype.stopDrag = function (ev) {\n    this.isDragging = false;\n    this.emitter.trigger('dragend', ev);\n  }; // fill in the implementations...\n\n\n  FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {\n    this.pointer.shouldIgnoreMove = bool;\n  };\n\n  FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {\n    this.mirror.setIsVisible(bool);\n  };\n\n  FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {\n    this.mirrorNeedsRevert = bool;\n  };\n\n  FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {\n    this.autoScroller.isEnabled = bool;\n  };\n\n  return FeaturefulElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging);\n/*\nWhen this class is instantiated, it records the offset of an element (relative to the document topleft),\nand continues to monitor scrolling, updating the cached coordinates if it needs to.\nDoes not access the DOM after instantiation, so highly performant.\n\nAlso keeps track of all scrolling/overflow:hidden containers that are parents of the given element\nand an determine if a given point is inside the combined clipping rectangle.\n*/\n\n\nvar OffsetTracker = function () {\n  function OffsetTracker(el) {\n    this.origRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(el); // will work fine for divs that have overflow:hidden\n\n    this.scrollCaches = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getClippingParents)(el).map(function (scrollEl) {\n      return new ElementScrollGeomCache(scrollEl, true);\n    });\n  }\n\n  OffsetTracker.prototype.destroy = function () {\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      scrollCache.destroy();\n    }\n  };\n\n  OffsetTracker.prototype.computeLeft = function () {\n    var left = this.origRect.left;\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n    }\n\n    return left;\n  };\n\n  OffsetTracker.prototype.computeTop = function () {\n    var top = this.origRect.top;\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n      top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n    }\n\n    return top;\n  };\n\n  OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {\n    var point = {\n      left: pageX,\n      top: pageY\n    };\n\n    for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n      var scrollCache = _a[_i];\n\n      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.pointInsideRect)(point, scrollCache.clientRect)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return OffsetTracker;\n}(); // certain clipping containers should never constrain interactions, like <html> and <body>\n// https://github.com/fullcalendar/fullcalendar/issues/3615\n\n\nfunction isIgnoredClipping(node) {\n  var tagName = node.tagName;\n  return tagName === 'HTML' || tagName === 'BODY';\n}\n/*\nTracks movement over multiple droppable areas (aka \"hits\")\nthat exist in one or more DateComponents.\nRelies on an existing draggable.\n\nemits:\n- pointerdown\n- dragstart\n- hitchange - fires initially, even if not over a hit\n- pointerup\n- (hitchange - again, to null, if ended over a hit)\n- dragend\n*/\n\n\nvar HitDragging = function () {\n  function HitDragging(dragging, droppableStore) {\n    var _this = this; // options that can be set by caller\n\n\n    this.useSubjectCenter = false;\n    this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n\n    this.initialHit = null;\n    this.movingHit = null;\n    this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n\n    this.handlePointerDown = function (ev) {\n      var dragging = _this.dragging;\n      _this.initialHit = null;\n      _this.movingHit = null;\n      _this.finalHit = null;\n\n      _this.prepareHits();\n\n      _this.processFirstCoord(ev);\n\n      if (_this.initialHit || !_this.requireInitial) {\n        dragging.setIgnoreMove(false); // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n\n        _this.emitter.trigger('pointerdown', ev);\n      } else {\n        dragging.setIgnoreMove(true);\n      }\n    };\n\n    this.handleDragStart = function (ev) {\n      _this.emitter.trigger('dragstart', ev);\n\n      _this.handleMove(ev, true); // force = fire even if initially null\n\n    };\n\n    this.handleDragMove = function (ev) {\n      _this.emitter.trigger('dragmove', ev);\n\n      _this.handleMove(ev);\n    };\n\n    this.handlePointerUp = function (ev) {\n      _this.releaseHits();\n\n      _this.emitter.trigger('pointerup', ev);\n    };\n\n    this.handleDragEnd = function (ev) {\n      if (_this.movingHit) {\n        _this.emitter.trigger('hitupdate', null, true, ev);\n      }\n\n      _this.finalHit = _this.movingHit;\n      _this.movingHit = null;\n\n      _this.emitter.trigger('dragend', ev);\n    };\n\n    this.droppableStore = droppableStore;\n    dragging.emitter.on('pointerdown', this.handlePointerDown);\n    dragging.emitter.on('dragstart', this.handleDragStart);\n    dragging.emitter.on('dragmove', this.handleDragMove);\n    dragging.emitter.on('pointerup', this.handlePointerUp);\n    dragging.emitter.on('dragend', this.handleDragEnd);\n    this.dragging = dragging;\n    this.emitter = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Emitter();\n  } // sets initialHit\n  // sets coordAdjust\n\n\n  HitDragging.prototype.processFirstCoord = function (ev) {\n    var origPoint = {\n      left: ev.pageX,\n      top: ev.pageY\n    };\n    var adjustedPoint = origPoint;\n    var subjectEl = ev.subjectEl;\n    var subjectRect;\n\n    if (subjectEl instanceof HTMLElement) {\n      // i.e. not a Document/ShadowRoot\n      subjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.computeRect)(subjectEl);\n      adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.constrainPoint)(adjustedPoint, subjectRect);\n    }\n\n    var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n\n    if (initialHit) {\n      if (this.useSubjectCenter && subjectRect) {\n        var slicedSubjectRect = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.intersectRects)(subjectRect, initialHit.rect);\n\n        if (slicedSubjectRect) {\n          adjustedPoint = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRectCenter)(slicedSubjectRect);\n        }\n      }\n\n      this.coordAdjust = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffPoints)(adjustedPoint, origPoint);\n    } else {\n      this.coordAdjust = {\n        left: 0,\n        top: 0\n      };\n    }\n  };\n\n  HitDragging.prototype.handleMove = function (ev, forceHandle) {\n    var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n\n    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n      this.movingHit = hit;\n      this.emitter.trigger('hitupdate', hit, false, ev);\n    }\n  };\n\n  HitDragging.prototype.prepareHits = function () {\n    this.offsetTrackers = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.mapHash)(this.droppableStore, function (interactionSettings) {\n      interactionSettings.component.prepareHits();\n      return new OffsetTracker(interactionSettings.el);\n    });\n  };\n\n  HitDragging.prototype.releaseHits = function () {\n    var offsetTrackers = this.offsetTrackers;\n\n    for (var id in offsetTrackers) {\n      offsetTrackers[id].destroy();\n    }\n\n    this.offsetTrackers = {};\n  };\n\n  HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {\n    var _a = this,\n        droppableStore = _a.droppableStore,\n        offsetTrackers = _a.offsetTrackers;\n\n    var bestHit = null;\n\n    for (var id in droppableStore) {\n      var component = droppableStore[id].component;\n      var offsetTracker = offsetTrackers[id];\n\n      if (offsetTracker && // wasn't destroyed mid-drag\n      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n        var originLeft = offsetTracker.computeLeft();\n        var originTop = offsetTracker.computeTop();\n        var positionLeft = offsetLeft - originLeft;\n        var positionTop = offsetTop - originTop;\n        var origRect = offsetTracker.origRect;\n        var width = origRect.right - origRect.left;\n        var height = origRect.bottom - origRect.top;\n\n        if ( // must be within the element's bounds\n        positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height) {\n          var hit = component.queryHit(positionLeft, positionTop, width, height);\n\n          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell\n          (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.rangeContainsRange)(hit.dateProfile.activeRange, hit.dateSpan.range) && (!bestHit || hit.layer > bestHit.layer)) {\n            hit.componentId = id;\n            hit.context = component.context; // TODO: better way to re-orient rectangle\n\n            hit.rect.left += originLeft;\n            hit.rect.right += originLeft;\n            hit.rect.top += originTop;\n            hit.rect.bottom += originTop;\n            bestHit = hit;\n          }\n        }\n      }\n    }\n\n    return bestHit;\n  };\n\n  return HitDragging;\n}();\n\nfunction isHitsEqual(hit0, hit1) {\n  if (!hit0 && !hit1) {\n    return true;\n  }\n\n  if (Boolean(hit0) !== Boolean(hit1)) {\n    return false;\n  }\n\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSpansEqual)(hit0.dateSpan, hit1.dateSpan);\n}\n\nfunction buildDatePointApiWithContext(dateSpan, context) {\n  var props = {};\n\n  for (var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, transform(dateSpan, context));\n  }\n\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, buildDatePointApi(dateSpan, context.dateEnv));\n\n  return props;\n}\n\nfunction buildDatePointApi(span, dateEnv) {\n  return {\n    date: dateEnv.toDate(span.range.start),\n    dateStr: dateEnv.formatIso(span.range.start, {\n      omitTime: span.allDay\n    }),\n    allDay: span.allDay\n  };\n}\n/*\nMonitors when the user clicks on a specific date/time of a component.\nA pointerdown+pointerup on the same \"hit\" constitutes a click.\n*/\n\n\nvar DateClicking = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateClicking, _super);\n\n  function DateClicking(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.handlePointerDown = function (pev) {\n      var dragging = _this.dragging;\n      var downEl = pev.origEvent.target; // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n\n      dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));\n    }; // won't even fire if moving was ignored\n\n\n    _this.handleDragEnd = function (ev) {\n      var component = _this.component;\n      var pointer = _this.dragging.pointer;\n\n      if (!pointer.wasTouchScroll) {\n        var _a = _this.hitDragging,\n            initialHit = _a.initialHit,\n            finalHit = _a.finalHit;\n\n        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n          var context = component.context;\n\n          var arg = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), {\n            dayEl: initialHit.dayEl,\n            jsEvent: ev.origEvent,\n            view: context.viewApi || context.calendarApi.view\n          });\n\n          context.emitter.trigger('dateClick', arg);\n        }\n      }\n    }; // we DO want to watch pointer moves because otherwise finalHit won't get populated\n\n\n    _this.dragging = new FeaturefulElementDragging(settings.el);\n    _this.dragging.autoScroller.isEnabled = false;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragend', _this.handleDragEnd);\n    return _this;\n  }\n\n  DateClicking.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return DateClicking;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n/*\nTracks when the user selects a portion of time of a component,\nconstituted by a drag over date cells, with a possible delay at the beginning of the drag.\n*/\n\n\nvar DateSelecting = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(DateSelecting, _super);\n\n  function DateSelecting(settings) {\n    var _this = _super.call(this, settings) || this;\n\n    _this.dragSelection = null;\n\n    _this.handlePointerDown = function (ev) {\n      var _a = _this,\n          component = _a.component,\n          dragging = _a.dragging;\n      var options = component.context.options;\n      var canSelect = options.selectable && component.isValidDateDownEl(ev.origEvent.target); // don't bother to watch expensive moves if component won't do selection\n\n      dragging.setIgnoreMove(!canSelect); // if touch, require user to hold down\n\n      dragging.delay = ev.isTouch ? getComponentTouchDelay$1(component) : null;\n    };\n\n    _this.handleDragStart = function (ev) {\n      _this.component.context.calendarApi.unselect(ev); // unselect previous selections\n\n    };\n\n    _this.handleHitUpdate = function (hit, isFinal) {\n      var context = _this.component.context;\n      var dragSelection = null;\n      var isInvalid = false;\n\n      if (hit) {\n        var initialHit = _this.hitDragging.initialHit;\n        var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n\n        if (!disallowed) {\n          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n        }\n\n        if (!dragSelection || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isDateSelectionValid)(dragSelection, hit.dateProfile, context)) {\n          isInvalid = true;\n          dragSelection = null;\n        }\n      }\n\n      if (dragSelection) {\n        context.dispatch({\n          type: 'SELECT_DATES',\n          selection: dragSelection\n        });\n      } else if (!isFinal) {\n        // only unselect if moved away while dragging\n        context.dispatch({\n          type: 'UNSELECT_DATES'\n        });\n      }\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n      }\n    };\n\n    _this.handlePointerUp = function (pev) {\n      if (_this.dragSelection) {\n        // selection is already rendered, so just need to report selection\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.triggerDateSelect)(_this.dragSelection, pev, _this.component.context);\n        _this.dragSelection = null;\n      }\n    };\n\n    var component = settings.component;\n    var options = component.context.options;\n    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.touchScrollAllowed = false;\n    dragging.minDistance = options.selectMinDistance || 0;\n    dragging.autoScroller.isEnabled = options.dragScroll;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n    hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n    return _this;\n  }\n\n  DateSelecting.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return DateSelecting;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n\nfunction getComponentTouchDelay$1(component) {\n  var options = component.context.options;\n  var delay = options.selectLongPressDelay;\n\n  if (delay == null) {\n    delay = options.longPressDelay;\n  }\n\n  return delay;\n}\n\nfunction joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n  var dateSpan0 = hit0.dateSpan;\n  var dateSpan1 = hit1.dateSpan;\n  var ms = [dateSpan0.range.start, dateSpan0.range.end, dateSpan1.range.start, dateSpan1.range.end];\n  ms.sort(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.compareNumbers);\n  var props = {};\n\n  for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {\n    var transformer = dateSelectionTransformers_1[_i];\n    var res = transformer(hit0, hit1);\n\n    if (res === false) {\n      return null;\n    }\n\n    if (res) {\n      (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(props, res);\n    }\n  }\n\n  props.range = {\n    start: ms[0],\n    end: ms[3]\n  };\n  props.allDay = dateSpan0.allDay;\n  return props;\n}\n\nvar EventDragging = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventDragging, _super);\n\n  function EventDragging(settings) {\n    var _this = _super.call(this, settings) || this; // internal state\n\n\n    _this.subjectEl = null;\n    _this.subjectSeg = null; // the seg being selected/dragged\n\n    _this.isDragging = false;\n    _this.eventRange = null;\n    _this.relevantEvents = null; // the events being dragged\n\n    _this.receivingContext = null;\n    _this.validMutation = null;\n    _this.mutatedRelevantEvents = null;\n\n    _this.handlePointerDown = function (ev) {\n      var origTarget = ev.origEvent.target;\n      var _a = _this,\n          component = _a.component,\n          dragging = _a.dragging;\n      var mirror = dragging.mirror;\n      var options = component.context.options;\n      var initialContext = component.context;\n      _this.subjectEl = ev.subjectEl;\n      var subjectSeg = _this.subjectSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(ev.subjectEl);\n      var eventRange = _this.eventRange = subjectSeg.eventRange;\n      var eventInstanceId = eventRange.instance.instanceId;\n      _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(initialContext.getCurrentData().eventStore, eventInstanceId);\n      dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n      dragging.delay = // only do a touch delay if touch and this event hasn't been selected yet\n      ev.isTouch && eventInstanceId !== component.props.eventSelection ? getComponentTouchDelay(component) : null;\n\n      if (options.fixedMirrorParent) {\n        mirror.parentNode = options.fixedMirrorParent;\n      } else {\n        mirror.parentNode = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, '.fc');\n      }\n\n      mirror.revertDuration = options.dragRevertDuration;\n      var isValid = component.isValidSegDownEl(origTarget) && !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(origTarget, '.fc-event-resizer'); // NOT on a resizer\n\n      dragging.setIgnoreMove(!isValid); // disable dragging for elements that are resizable (ie, selectable)\n      // but are not draggable\n\n      _this.isDragging = isValid && ev.subjectEl.classList.contains('fc-event-draggable');\n    };\n\n    _this.handleDragStart = function (ev) {\n      var initialContext = _this.component.context;\n      var eventRange = _this.eventRange;\n      var eventInstanceId = eventRange.instance.instanceId;\n\n      if (ev.isTouch) {\n        // need to select a different event?\n        if (eventInstanceId !== _this.component.props.eventSelection) {\n          initialContext.dispatch({\n            type: 'SELECT_EVENT',\n            eventInstanceId: eventInstanceId\n          });\n        }\n      } else {\n        // if now using mouse, but was previous touch interaction, clear selected event\n        initialContext.dispatch({\n          type: 'UNSELECT_EVENT'\n        });\n      }\n\n      if (_this.isDragging) {\n        initialContext.calendarApi.unselect(ev); // unselect *date* selection\n\n        initialContext.emitter.trigger('eventDragStart', {\n          el: _this.subjectEl,\n          event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext, eventRange.def, eventRange.instance),\n          jsEvent: ev.origEvent,\n          view: initialContext.viewApi\n        });\n      }\n    };\n\n    _this.handleHitUpdate = function (hit, isFinal) {\n      if (!_this.isDragging) {\n        return;\n      }\n\n      var relevantEvents = _this.relevantEvents;\n      var initialHit = _this.hitDragging.initialHit;\n      var initialContext = _this.component.context; // states based on new hit\n\n      var receivingContext = null;\n      var mutation = null;\n      var mutatedRelevantEvents = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: relevantEvents,\n        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        isEvent: true\n      };\n\n      if (hit) {\n        receivingContext = hit.context;\n        var receivingOptions = receivingContext.options;\n\n        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {\n          mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n\n          if (mutation) {\n            mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n            interaction.mutatedEvents = mutatedRelevantEvents;\n\n            if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext)) {\n              isInvalid = true;\n              mutation = null;\n              mutatedRelevantEvents = null;\n              interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n            }\n          }\n        } else {\n          receivingContext = null;\n        }\n      }\n\n      _this.displayDrag(receivingContext, interaction);\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        if (initialContext === receivingContext && // TODO: write test for this\n        isHitsEqual(initialHit, hit)) {\n          mutation = null;\n        }\n\n        _this.dragging.setMirrorNeedsRevert(!mutation); // render the mirror if no already-rendered mirror\n        // TODO: wish we could somehow wait for dispatch to guarantee render\n\n\n        _this.dragging.setMirrorIsVisible(!hit || !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElRoot)(_this.subjectEl).querySelector('.fc-event-mirror')); // assign states based on new hit\n\n\n        _this.receivingContext = receivingContext;\n        _this.validMutation = mutation;\n        _this.mutatedRelevantEvents = mutatedRelevantEvents;\n      }\n    };\n\n    _this.handlePointerUp = function () {\n      if (!_this.isDragging) {\n        _this.cleanup(); // because handleDragEnd won't fire\n\n      }\n    };\n\n    _this.handleDragEnd = function (ev) {\n      if (_this.isDragging) {\n        var initialContext_1 = _this.component.context;\n        var initialView = initialContext_1.viewApi;\n        var _a = _this,\n            receivingContext_1 = _a.receivingContext,\n            validMutation = _a.validMutation;\n        var eventDef = _this.eventRange.def;\n        var eventInstance = _this.eventRange.instance;\n        var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, eventDef, eventInstance);\n        var relevantEvents_1 = _this.relevantEvents;\n        var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;\n        var finalHit = _this.hitDragging.finalHit;\n\n        _this.clearDrag(); // must happen after revert animation\n\n\n        initialContext_1.emitter.trigger('eventDragStop', {\n          el: _this.subjectEl,\n          event: eventApi,\n          jsEvent: ev.origEvent,\n          view: initialView\n        });\n\n        if (validMutation) {\n          // dropped within same calendar\n          if (receivingContext_1 === initialContext_1) {\n            var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);\n            initialContext_1.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: mutatedRelevantEvents_1\n            });\n            var eventChangeArg = {\n              oldEvent: eventApi,\n              event: updatedEventApi,\n              relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, initialContext_1, eventInstance),\n              revert: function revert() {\n                initialContext_1.dispatch({\n                  type: 'MERGE_EVENTS',\n                  eventStore: relevantEvents_1 // the pre-change data\n\n                });\n              }\n            };\n            var transformed = {};\n\n            for (var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++) {\n              var transformer = _b[_i];\n\n              (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(transformed, transformer(validMutation, initialContext_1));\n            }\n\n            initialContext_1.emitter.trigger('eventDrop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), transformed), {\n              el: ev.subjectEl,\n              delta: validMutation.datesDelta,\n              jsEvent: ev.origEvent,\n              view: initialView\n            }));\n            initialContext_1.emitter.trigger('eventChange', eventChangeArg); // dropped in different calendar\n          } else if (receivingContext_1) {\n            var eventRemoveArg = {\n              event: eventApi,\n              relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(relevantEvents_1, initialContext_1, eventInstance),\n              revert: function revert() {\n                initialContext_1.dispatch({\n                  type: 'MERGE_EVENTS',\n                  eventStore: relevantEvents_1\n                });\n              }\n            };\n            initialContext_1.emitter.trigger('eventLeave', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventRemoveArg), {\n              draggedEl: ev.subjectEl,\n              view: initialView\n            }));\n            initialContext_1.dispatch({\n              type: 'REMOVE_EVENTS',\n              eventStore: relevantEvents_1\n            });\n            initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);\n            var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];\n            var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];\n            var addedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext_1, addedEventDef, addedEventInstance);\n            receivingContext_1.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: mutatedRelevantEvents_1\n            });\n            var eventAddArg = {\n              event: addedEventApi,\n              relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),\n              revert: function revert() {\n                receivingContext_1.dispatch({\n                  type: 'REMOVE_EVENTS',\n                  eventStore: mutatedRelevantEvents_1\n                });\n              }\n            };\n            receivingContext_1.emitter.trigger('eventAdd', eventAddArg);\n\n            if (ev.isTouch) {\n              receivingContext_1.dispatch({\n                type: 'SELECT_EVENT',\n                eventInstanceId: eventInstance.instanceId\n              });\n            }\n\n            receivingContext_1.emitter.trigger('drop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), {\n              draggedEl: ev.subjectEl,\n              jsEvent: ev.origEvent,\n              view: finalHit.context.viewApi\n            }));\n            receivingContext_1.emitter.trigger('eventReceive', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventAddArg), {\n              draggedEl: ev.subjectEl,\n              view: finalHit.context.viewApi\n            }));\n          }\n        } else {\n          initialContext_1.emitter.trigger('_noEventDrop');\n        }\n      }\n\n      _this.cleanup();\n    };\n\n    var component = _this.component;\n    var options = component.context.options;\n    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.pointer.selector = EventDragging.SELECTOR;\n    dragging.touchScrollAllowed = false;\n    dragging.autoScroller.isEnabled = options.dragScroll;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n    hitDragging.useSubjectCenter = settings.useEventCenter;\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n    hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n    hitDragging.emitter.on('dragend', _this.handleDragEnd);\n    return _this;\n  }\n\n  EventDragging.prototype.destroy = function () {\n    this.dragging.destroy();\n  }; // render a drag state on the next receivingCalendar\n\n\n  EventDragging.prototype.displayDrag = function (nextContext, state) {\n    var initialContext = this.component.context;\n    var prevContext = this.receivingContext; // does the previous calendar need to be cleared?\n\n    if (prevContext && prevContext !== nextContext) {\n      // does the initial calendar need to be cleared?\n      // if so, don't clear all the way. we still need to to hide the affectedEvents\n      if (prevContext === initialContext) {\n        prevContext.dispatch({\n          type: 'SET_EVENT_DRAG',\n          state: {\n            affectedEvents: state.affectedEvents,\n            mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n            isEvent: true\n          }\n        }); // completely clear the old calendar if it wasn't the initial\n      } else {\n        prevContext.dispatch({\n          type: 'UNSET_EVENT_DRAG'\n        });\n      }\n    }\n\n    if (nextContext) {\n      nextContext.dispatch({\n        type: 'SET_EVENT_DRAG',\n        state: state\n      });\n    }\n  };\n\n  EventDragging.prototype.clearDrag = function () {\n    var initialCalendar = this.component.context;\n    var receivingContext = this.receivingContext;\n\n    if (receivingContext) {\n      receivingContext.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    } // the initial calendar might have an dummy drag state from displayDrag\n\n\n    if (initialCalendar !== receivingContext) {\n      initialCalendar.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    }\n  };\n\n  EventDragging.prototype.cleanup = function () {\n    this.subjectSeg = null;\n    this.isDragging = false;\n    this.eventRange = null;\n    this.relevantEvents = null;\n    this.receivingContext = null;\n    this.validMutation = null;\n    this.mutatedRelevantEvents = null;\n  }; // TODO: test this in IE11\n  // QUESTION: why do we need it on the resizable???\n\n\n  EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\n  return EventDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n\nfunction computeEventMutation(hit0, hit1, massagers) {\n  var dateSpan0 = hit0.dateSpan;\n  var dateSpan1 = hit1.dateSpan;\n  var date0 = dateSpan0.range.start;\n  var date1 = dateSpan1.range.start;\n  var standardProps = {};\n\n  if (dateSpan0.allDay !== dateSpan1.allDay) {\n    standardProps.allDay = dateSpan1.allDay;\n    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;\n\n    if (dateSpan1.allDay) {\n      // means date1 is already start-of-day,\n      // but date0 needs to be converted\n      date0 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.startOfDay)(date0);\n    }\n  }\n\n  var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);\n\n  if (delta.milliseconds) {\n    // has hours/minutes/seconds\n    standardProps.allDay = false;\n  }\n\n  var mutation = {\n    datesDelta: delta,\n    standardProps: standardProps\n  };\n\n  for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {\n    var massager = massagers_1[_i];\n    massager(mutation, hit0, hit1);\n  }\n\n  return mutation;\n}\n\nfunction getComponentTouchDelay(component) {\n  var options = component.context.options;\n  var delay = options.eventLongPressDelay;\n\n  if (delay == null) {\n    delay = options.longPressDelay;\n  }\n\n  return delay;\n}\n\nvar EventResizing = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(EventResizing, _super);\n\n  function EventResizing(settings) {\n    var _this = _super.call(this, settings) || this; // internal state\n\n\n    _this.draggingSegEl = null;\n    _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n\n    _this.eventRange = null;\n    _this.relevantEvents = null;\n    _this.validMutation = null;\n    _this.mutatedRelevantEvents = null;\n\n    _this.handlePointerDown = function (ev) {\n      var component = _this.component;\n\n      var segEl = _this.querySegEl(ev);\n\n      var seg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n      var eventRange = _this.eventRange = seg.eventRange;\n      _this.dragging.minDistance = component.context.options.eventDragMinDistance; // if touch, need to be working with a selected event\n\n      _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId);\n    };\n\n    _this.handleDragStart = function (ev) {\n      var context = _this.component.context;\n      var eventRange = _this.eventRange;\n      _this.relevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getRelevantEvents)(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);\n\n      var segEl = _this.querySegEl(ev);\n\n      _this.draggingSegEl = segEl;\n      _this.draggingSeg = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getElSeg)(segEl);\n      context.calendarApi.unselect();\n      context.emitter.trigger('eventResizeStart', {\n        el: segEl,\n        event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventRange.def, eventRange.instance),\n        jsEvent: ev.origEvent,\n        view: context.viewApi\n      });\n    };\n\n    _this.handleHitUpdate = function (hit, isFinal, ev) {\n      var context = _this.component.context;\n      var relevantEvents = _this.relevantEvents;\n      var initialHit = _this.hitDragging.initialHit;\n      var eventInstance = _this.eventRange.instance;\n      var mutation = null;\n      var mutatedRelevantEvents = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: relevantEvents,\n        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        isEvent: true\n      };\n\n      if (hit) {\n        var disallowed = hit.componentId === initialHit.componentId && _this.isHitComboAllowed && !_this.isHitComboAllowed(initialHit, hit);\n\n        if (!disallowed) {\n          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range);\n        }\n      }\n\n      if (mutation) {\n        mutatedRelevantEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.applyMutationToEventStore)(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n        interaction.mutatedEvents = mutatedRelevantEvents;\n\n        if (!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, context)) {\n          isInvalid = true;\n          mutation = null;\n          mutatedRelevantEvents = null;\n          interaction.mutatedEvents = null;\n        }\n      }\n\n      if (mutatedRelevantEvents) {\n        context.dispatch({\n          type: 'SET_EVENT_RESIZE',\n          state: interaction\n        });\n      } else {\n        context.dispatch({\n          type: 'UNSET_EVENT_RESIZE'\n        });\n      }\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        if (mutation && isHitsEqual(initialHit, hit)) {\n          mutation = null;\n        }\n\n        _this.validMutation = mutation;\n        _this.mutatedRelevantEvents = mutatedRelevantEvents;\n      }\n    };\n\n    _this.handleDragEnd = function (ev) {\n      var context = _this.component.context;\n      var eventDef = _this.eventRange.def;\n      var eventInstance = _this.eventRange.instance;\n      var eventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, eventDef, eventInstance);\n      var relevantEvents = _this.relevantEvents;\n      var mutatedRelevantEvents = _this.mutatedRelevantEvents;\n      context.emitter.trigger('eventResizeStop', {\n        el: _this.draggingSegEl,\n        event: eventApi,\n        jsEvent: ev.origEvent,\n        view: context.viewApi\n      });\n\n      if (_this.validMutation) {\n        var updatedEventApi = new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n        context.dispatch({\n          type: 'MERGE_EVENTS',\n          eventStore: mutatedRelevantEvents\n        });\n        var eventChangeArg = {\n          oldEvent: eventApi,\n          event: updatedEventApi,\n          relatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.buildEventApis)(mutatedRelevantEvents, context, eventInstance),\n          revert: function revert() {\n            context.dispatch({\n              type: 'MERGE_EVENTS',\n              eventStore: relevantEvents // the pre-change events\n\n            });\n          }\n        };\n        context.emitter.trigger('eventResize', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, eventChangeArg), {\n          el: _this.draggingSegEl,\n          startDelta: _this.validMutation.startDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0),\n          endDelta: _this.validMutation.endDelta || (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createDuration)(0),\n          jsEvent: ev.origEvent,\n          view: context.viewApi\n        }));\n        context.emitter.trigger('eventChange', eventChangeArg);\n      } else {\n        context.emitter.trigger('_noEventResize');\n      } // reset all internal state\n\n\n      _this.draggingSeg = null;\n      _this.relevantEvents = null;\n      _this.validMutation = null; // okay to keep eventInstance around. useful to set it in handlePointerDown\n    };\n\n    var component = settings.component;\n    var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n    dragging.pointer.selector = '.fc-event-resizer';\n    dragging.touchScrollAllowed = false;\n    dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n    var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsToStore)(settings));\n    hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n    hitDragging.emitter.on('dragstart', _this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n    hitDragging.emitter.on('dragend', _this.handleDragEnd);\n    return _this;\n  }\n\n  EventResizing.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  EventResizing.prototype.querySegEl = function (ev) {\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(ev.subjectEl, '.fc-event');\n  };\n\n  return EventResizing;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.Interaction);\n\nfunction computeMutation(hit0, hit1, isFromStart, instanceRange) {\n  var dateEnv = hit0.context.dateEnv;\n  var date0 = hit0.dateSpan.range.start;\n  var date1 = hit1.dateSpan.range.start;\n  var delta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.diffDates)(date0, date1, dateEnv, hit0.largeUnit);\n\n  if (isFromStart) {\n    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n      return {\n        startDelta: delta\n      };\n    }\n  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n    return {\n      endDelta: delta\n    };\n  }\n\n  return null;\n}\n\nvar UnselectAuto = function () {\n  function UnselectAuto(context) {\n    var _this = this;\n\n    this.context = context;\n    this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n\n    this.matchesCancel = false;\n    this.matchesEvent = false;\n\n    this.onSelect = function (selectInfo) {\n      if (selectInfo.jsEvent) {\n        _this.isRecentPointerDateSelect = true;\n      }\n    };\n\n    this.onDocumentPointerDown = function (pev) {\n      var unselectCancel = _this.context.options.unselectCancel;\n      var downEl = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getEventTargetViaRoot)(pev.origEvent);\n      _this.matchesCancel = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, unselectCancel);\n      _this.matchesEvent = !!(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementClosest)(downEl, EventDragging.SELECTOR); // interaction started on an event?\n    };\n\n    this.onDocumentPointerUp = function (pev) {\n      var context = _this.context;\n      var documentPointer = _this.documentPointer;\n      var calendarState = context.getCurrentData(); // touch-scrolling should never unfocus any type of selection\n\n      if (!documentPointer.wasTouchScroll) {\n        if (calendarState.dateSelection && // an existing date selection?\n        !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n        ) {\n          var unselectAuto = context.options.unselectAuto;\n\n          if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {\n            context.calendarApi.unselect(pev);\n          }\n        }\n\n        if (calendarState.eventSelection && // an existing event selected?\n        !_this.matchesEvent // interaction DIDN'T start on an event\n        ) {\n          context.dispatch({\n            type: 'UNSELECT_EVENT'\n          });\n        }\n      }\n\n      _this.isRecentPointerDateSelect = false;\n    };\n\n    var documentPointer = this.documentPointer = new PointerDragging(document);\n    documentPointer.shouldIgnoreMove = true;\n    documentPointer.shouldWatchScroll = false;\n    documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n    documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n    /*\n    TODO: better way to know about whether there was a selection with the pointer\n    */\n\n    context.emitter.on('select', this.onSelect);\n  }\n\n  UnselectAuto.prototype.destroy = function () {\n    this.context.emitter.off('select', this.onSelect);\n    this.documentPointer.destroy();\n  };\n\n  return UnselectAuto;\n}();\n\nvar OPTION_REFINERS = {\n  fixedMirrorParent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity\n};\nvar LISTENER_REFINERS = {\n  dateClick: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventDragStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventDragStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventDrop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventResizeStart: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventResizeStop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventResize: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  drop: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventReceive: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity,\n  eventLeave: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.identity\n};\n/*\nGiven an already instantiated draggable object for one-or-more elements,\nInterprets any dragging as an attempt to drag an events that lives outside\nof a calendar onto a calendar.\n*/\n\nvar ExternalElementDragging = function () {\n  function ExternalElementDragging(dragging, suppliedDragMeta) {\n    var _this = this;\n\n    this.receivingContext = null;\n    this.droppableEvent = null; // will exist for all drags, even if create:false\n\n    this.suppliedDragMeta = null;\n    this.dragMeta = null;\n\n    this.handleDragStart = function (ev) {\n      _this.dragMeta = _this.buildDragMeta(ev.subjectEl);\n    };\n\n    this.handleHitUpdate = function (hit, isFinal, ev) {\n      var dragging = _this.hitDragging.dragging;\n      var receivingContext = null;\n      var droppableEvent = null;\n      var isInvalid = false;\n      var interaction = {\n        affectedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        mutatedEvents: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)(),\n        isEvent: _this.dragMeta.create\n      };\n\n      if (hit) {\n        receivingContext = hit.context;\n\n        if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n          droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);\n          interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n          isInvalid = !(0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.isInteractionValid)(interaction, hit.dateProfile, receivingContext);\n\n          if (isInvalid) {\n            interaction.mutatedEvents = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEmptyEventStore)();\n            droppableEvent = null;\n          }\n        }\n      }\n\n      _this.displayDrag(receivingContext, interaction); // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n      // TODO: wish we could somehow wait for dispatch to guarantee render\n\n\n      dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n\n      if (!isInvalid) {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.enableCursor)();\n      } else {\n        (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.disableCursor)();\n      }\n\n      if (!isFinal) {\n        dragging.setMirrorNeedsRevert(!droppableEvent);\n        _this.receivingContext = receivingContext;\n        _this.droppableEvent = droppableEvent;\n      }\n    };\n\n    this.handleDragEnd = function (pev) {\n      var _a = _this,\n          receivingContext = _a.receivingContext,\n          droppableEvent = _a.droppableEvent;\n\n      _this.clearDrag();\n\n      if (receivingContext && droppableEvent) {\n        var finalHit = _this.hitDragging.finalHit;\n        var finalView = finalHit.context.viewApi;\n        var dragMeta = _this.dragMeta;\n        receivingContext.emitter.trigger('drop', (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)((0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), {\n          draggedEl: pev.subjectEl,\n          jsEvent: pev.origEvent,\n          view: finalView\n        }));\n\n        if (dragMeta.create) {\n          var addingEvents_1 = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.eventTupleToStore)(droppableEvent);\n          receivingContext.dispatch({\n            type: 'MERGE_EVENTS',\n            eventStore: addingEvents_1\n          });\n\n          if (pev.isTouch) {\n            receivingContext.dispatch({\n              type: 'SELECT_EVENT',\n              eventInstanceId: droppableEvent.instance.instanceId\n            });\n          } // signal that an external event landed\n\n\n          receivingContext.emitter.trigger('eventReceive', {\n            event: new _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),\n            relatedEvents: [],\n            revert: function revert() {\n              receivingContext.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: addingEvents_1\n              });\n            },\n            draggedEl: pev.subjectEl,\n            view: finalView\n          });\n        }\n      }\n\n      _this.receivingContext = null;\n      _this.droppableEvent = null;\n    };\n\n    var hitDragging = this.hitDragging = new HitDragging(dragging, _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.interactionSettingsStore);\n    hitDragging.requireInitial = false; // will start outside of a component\n\n    hitDragging.emitter.on('dragstart', this.handleDragStart);\n    hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n    hitDragging.emitter.on('dragend', this.handleDragEnd);\n    this.suppliedDragMeta = suppliedDragMeta;\n  }\n\n  ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {\n    if (_typeof(this.suppliedDragMeta) === 'object') {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta);\n    }\n\n    if (typeof this.suppliedDragMeta === 'function') {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(this.suppliedDragMeta(subjectEl));\n    }\n\n    return getDragMetaFromEl(subjectEl);\n  };\n\n  ExternalElementDragging.prototype.displayDrag = function (nextContext, state) {\n    var prevContext = this.receivingContext;\n\n    if (prevContext && prevContext !== nextContext) {\n      prevContext.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    }\n\n    if (nextContext) {\n      nextContext.dispatch({\n        type: 'SET_EVENT_DRAG',\n        state: state\n      });\n    }\n  };\n\n  ExternalElementDragging.prototype.clearDrag = function () {\n    if (this.receivingContext) {\n      this.receivingContext.dispatch({\n        type: 'UNSET_EVENT_DRAG'\n      });\n    }\n  };\n\n  ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingContext) {\n    var dropAccept = receivingContext.options.dropAccept;\n\n    if (typeof dropAccept === 'function') {\n      return dropAccept.call(receivingContext.calendarApi, el);\n    }\n\n    if (typeof dropAccept === 'string' && dropAccept) {\n      return Boolean((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.elementMatches)(el, dropAccept));\n    }\n\n    return true;\n  };\n\n  return ExternalElementDragging;\n}(); // Utils for computing event store from the DragMeta\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction computeEventForDateSpan(dateSpan, dragMeta, context) {\n  var defProps = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)({}, dragMeta.leftoverProps);\n\n  for (var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++) {\n    var transform = _a[_i];\n\n    (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__assign)(defProps, transform(dateSpan, dragMeta));\n  }\n\n  var _b = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.refineEventDef)(defProps, context),\n      refined = _b.refined,\n      extra = _b.extra;\n\n  var def = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseEventDef)(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd\n  context);\n  var start = dateSpan.range.start; // only rely on time info if drop zone is all-day,\n  // otherwise, we already know the time\n\n  if (dateSpan.allDay && dragMeta.startTime) {\n    start = context.dateEnv.add(start, dragMeta.startTime);\n  }\n\n  var end = dragMeta.duration ? context.dateEnv.add(start, dragMeta.duration) : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.getDefaultEventEnd)(dateSpan.allDay, start, context);\n  var instance = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createEventInstance)(def.defId, {\n    start: start,\n    end: end\n  });\n  return {\n    def: def,\n    instance: instance\n  };\n} // Utils for extracting data from element\n// ----------------------------------------------------------------------------------------------------\n\n\nfunction getDragMetaFromEl(el) {\n  var str = getEmbeddedElData(el, 'event');\n  var obj = str ? JSON.parse(str) : {\n    create: false\n  }; // if no embedded data, assume no event creation\n\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.parseDragMeta)(obj);\n}\n\n_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix = '';\n\nfunction getEmbeddedElData(el, name) {\n  var prefix = _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.config.dataAttrPrefix;\n  var prefixedName = (prefix ? prefix + '-' : '') + name;\n  return el.getAttribute('data-' + prefixedName) || '';\n}\n/*\nMakes an element (that is *external* to any calendar) draggable.\nCan pass in data that determines how an event will be created when dropped onto a calendar.\nLeverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n*/\n\n\nvar ExternalDraggable = function () {\n  function ExternalDraggable(el, settings) {\n    var _this = this;\n\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    this.handlePointerDown = function (ev) {\n      var dragging = _this.dragging;\n      var _a = _this.settings,\n          minDistance = _a.minDistance,\n          longPressDelay = _a.longPressDelay;\n      dragging.minDistance = minDistance != null ? minDistance : ev.isTouch ? 0 : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.eventDragMinDistance;\n      dragging.delay = ev.isTouch ? longPressDelay != null ? longPressDelay : _fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.BASE_OPTION_DEFAULTS.longPressDelay : 0;\n    };\n\n    this.handleDragStart = function (ev) {\n      if (ev.isTouch && _this.dragging.delay && ev.subjectEl.classList.contains('fc-event')) {\n        _this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n      }\n    };\n\n    this.settings = settings;\n    var dragging = this.dragging = new FeaturefulElementDragging(el);\n    dragging.touchScrollAllowed = false;\n\n    if (settings.itemSelector != null) {\n      dragging.pointer.selector = settings.itemSelector;\n    }\n\n    if (settings.appendTo != null) {\n      dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n    }\n\n    dragging.emitter.on('pointerdown', this.handlePointerDown);\n    dragging.emitter.on('dragstart', this.handleDragStart);\n    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n  }\n\n  ExternalDraggable.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return ExternalDraggable;\n}();\n/*\nDetects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\nThe third-party system is responsible for drawing the visuals effects of the drag.\nThis class simply monitors for pointer movements and fires events.\nIt also has the ability to hide the moving element (the \"mirror\") during the drag.\n*/\n\n\nvar InferredElementDragging = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(InferredElementDragging, _super);\n\n  function InferredElementDragging(containerEl) {\n    var _this = _super.call(this, containerEl) || this;\n\n    _this.shouldIgnoreMove = false;\n    _this.mirrorSelector = '';\n    _this.currentMirrorEl = null;\n\n    _this.handlePointerDown = function (ev) {\n      _this.emitter.trigger('pointerdown', ev);\n\n      if (!_this.shouldIgnoreMove) {\n        // fire dragstart right away. does not support delay or min-distance\n        _this.emitter.trigger('dragstart', ev);\n      }\n    };\n\n    _this.handlePointerMove = function (ev) {\n      if (!_this.shouldIgnoreMove) {\n        _this.emitter.trigger('dragmove', ev);\n      }\n    };\n\n    _this.handlePointerUp = function (ev) {\n      _this.emitter.trigger('pointerup', ev);\n\n      if (!_this.shouldIgnoreMove) {\n        // fire dragend right away. does not support a revert animation\n        _this.emitter.trigger('dragend', ev);\n      }\n    };\n\n    var pointer = _this.pointer = new PointerDragging(containerEl);\n    pointer.emitter.on('pointerdown', _this.handlePointerDown);\n    pointer.emitter.on('pointermove', _this.handlePointerMove);\n    pointer.emitter.on('pointerup', _this.handlePointerUp);\n    return _this;\n  }\n\n  InferredElementDragging.prototype.destroy = function () {\n    this.pointer.destroy();\n  };\n\n  InferredElementDragging.prototype.setIgnoreMove = function (bool) {\n    this.shouldIgnoreMove = bool;\n  };\n\n  InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {\n    if (bool) {\n      // restore a previously hidden element.\n      // use the reference in case the selector class has already been removed.\n      if (this.currentMirrorEl) {\n        this.currentMirrorEl.style.visibility = '';\n        this.currentMirrorEl = null;\n      }\n    } else {\n      var mirrorEl = this.mirrorSelector // TODO: somehow query FullCalendars WITHIN shadow-roots\n      ? document.querySelector(this.mirrorSelector) : null;\n\n      if (mirrorEl) {\n        this.currentMirrorEl = mirrorEl;\n        mirrorEl.style.visibility = 'hidden';\n      }\n    }\n  };\n\n  return InferredElementDragging;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.ElementDragging);\n/*\nBridges third-party drag-n-drop systems with FullCalendar.\nMust be instantiated and destroyed by caller.\n*/\n\n\nvar ThirdPartyDraggable = function () {\n  function ThirdPartyDraggable(containerOrSettings, settings) {\n    var containerEl = document;\n\n    if ( // wish we could just test instanceof EventTarget, but doesn't work in IE11\n    containerOrSettings === document || containerOrSettings instanceof Element) {\n      containerEl = containerOrSettings;\n      settings = settings || {};\n    } else {\n      settings = containerOrSettings || {};\n    }\n\n    var dragging = this.dragging = new InferredElementDragging(containerEl);\n\n    if (typeof settings.itemSelector === 'string') {\n      dragging.pointer.selector = settings.itemSelector;\n    } else if (containerEl === document) {\n      dragging.pointer.selector = '[data-event]';\n    }\n\n    if (typeof settings.mirrorSelector === 'string') {\n      dragging.mirrorSelector = settings.mirrorSelector;\n    }\n\n    new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n  }\n\n  ThirdPartyDraggable.prototype.destroy = function () {\n    this.dragging.destroy();\n  };\n\n  return ThirdPartyDraggable;\n}();\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_0__.createPlugin)({\n  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],\n  calendarInteractions: [UnselectAuto],\n  elementDraggingImpl: FeaturefulElementDragging,\n  optionRefiners: OPTION_REFINERS,\n  listenerRefiners: LISTENER_REFINERS\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9tYWluLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTtBQUFBOztBQXBCQTs7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBMERBO0FBQ0E7QUFLQTs7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTs7QUEzTEE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFJQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFzQ0E7QUFDQTtBQUNBOzs7QUErREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBS0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBOztBQUNBO0FBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JWQTs7Ozs7OztBQUtBO0FBQUE7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7OztBQUdBOztBQUNBO0FBQ0E7QUE2SEE7O0FBM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFZQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQy9JQTs7Ozs7Ozs7OztBQVFBO0FBQUE7O0FBY0E7QUFBQTs7QUEwQkE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFoR0E7O0FDUEE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQVpBOztBQ0FBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BOzs7O0FBSUE7QUFDQTtBQUNBOztBQUNBO0FBdkJBO0FDU0E7QUFDQTs7O0FBQ0E7QUFFQTs7Ozs7OztBQU1BO0FBQUE7QUFBQTs7O0FBRUE7QUFDQTtBQUNBOztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUE4REE7QUFDQTtBQUFBO0FBQ0E7O0FBS0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtR0E7O0FBOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBYkE7QUFlQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUM1TUE7Ozs7Ozs7OztBQU1BOztBQWtCQTtBQUFBOztBQUFBOzs7QUFYQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBMEJBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFFQTs7QUFJQTs7O0FBQ0E7OztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFFQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOzs7QUFFQTtBQUNBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUF2R0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTs7O0FBSUE7QUFDQTs7QUFzRkE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBbE1BO0FDWkE7Ozs7Ozs7Ozs7QUFRQTtBQUlBO0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUFBOztBQUNBO0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUdBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQzlEQTs7Ozs7Ozs7Ozs7Ozs7O0FBYUE7QUFnQkE7QUFBQTs7O0FBVkE7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7O0FBZ0JBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQThCQTtBQUNBOztBQUNBOztBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQW5GQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7QUF3QkE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQTJCQTtBQUNBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBR0E7O0FBQ0E7QUFHQTtBQUlBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUN4TUE7QUFDQTs7QUFFQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBS0E7QUN0QkE7Ozs7OztBQUlBO0FBQUE7O0FBSUE7QUFBQTs7QUFnQkE7QUFDQTtBQUNBOztBQUdBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7OztBQTFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFpQ0E7QUFuREE7QUNUQTs7Ozs7O0FBSUE7QUFBQTs7QUFLQTtBQUFBOztBQUZBOztBQXVCQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7O0FBSUE7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUF0RkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBc0VBO0FBOUZBOztBQWdHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUVBOztBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7O0FDakhBO0FBQUE7O0FBa0JBO0FBQUE7OztBQVRBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUF5QkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFLQTtBQUNBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOztBQUlBOzs7QUFJQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOztBQU1BO0FBQ0E7QUFDQTs7QUFFQTtBQUlBOztBQUVBO0FBQ0E7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBT0E7O0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFGQTtBQUlBO0FBVEE7QUFZQTs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQVJBO0FBV0E7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFSQTtBQVdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFFQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBM1RBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBMlNBO0FBQ0E7QUFDQTs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUZBO0FBVUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBbFlBO0FBbVlBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQVFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQzdiQTtBQUFBOztBQVlBO0FBQUE7OztBQVBBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBc0JBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBOztBQUdBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBS0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTs7QUFJQTtBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUZBO0FBSUE7QUFUQTtBQVlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUdBOztBQXBMQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBc0tBO0FBQ0E7QUFDQTs7QUFDQTtBQXZNQTs7QUF5TUE7QUFNQTtBQUNBO0FBQ0E7QUFFQTs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FDNVBBO0FBTUE7QUFBQTs7QUFBQTtBQUpBOztBQUNBO0FBQ0E7O0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUZBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQTFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBNENBO0FBQUE7O0FDbEVBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQ2tCQTs7Ozs7O0FBS0E7QUFPQTtBQUFBOztBQUxBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFZQTtBQUNBO0FBQ0E7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSEE7O0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7O0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQW5JQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBZ0hBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBR0E7OztBQUVBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQU1BO0FBR0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQy9QQTs7Ozs7Ozs7QUFTQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFvQkE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBS0E7QUFJQTs7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBOztBQTFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTs7QUEyQkE7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUNsRUE7Ozs7Ozs7O0FBTUE7QUFBQTs7QUFNQTtBQUFBOztBQUpBO0FBQ0E7QUFDQTs7QUFlQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQWhDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBMEJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFuRUE7QUNBQTs7Ozs7OztBQU9BO0FBSUE7O0FBRUE7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZG5kL1BvaW50ZXJEcmFnZ2luZy50cz85NDVhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kbmQvRWxlbWVudE1pcnJvci50cz8xMTExIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9TY3JvbGxHZW9tQ2FjaGUudHM/YTcwOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvRWxlbWVudFNjcm9sbEdlb21DYWNoZS50cz8yYzNkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9XaW5kb3dTY3JvbGxHZW9tQ2FjaGUudHM/OWExMSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvZG5kL0F1dG9TY3JvbGxlci50cz82ZmU5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9kbmQvRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZy50cz80YjRhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9PZmZzZXRUcmFja2VyLnRzPzRiMzUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9IaXREcmFnZ2luZy50cz9kYzY4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy91dGlscy50cz9lYTA1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9pbnRlcmFjdGlvbnMvRGF0ZUNsaWNraW5nLnRzPzBiMDYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9EYXRlU2VsZWN0aW5nLnRzPzIwZmMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9FdmVudERyYWdnaW5nLnRzP2E2ODciLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9FdmVudFJlc2l6aW5nLnRzPzA3YTQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy9VbnNlbGVjdEF1dG8udHM/ZWI1OCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvb3B0aW9ucy50cz85MTgxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9pbnRlcmFjdGlvbnMtZXh0ZXJuYWwvRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcudHM/Zjk0YSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvaW50ZXJhY3Rpb25zLWV4dGVybmFsL0V4dGVybmFsRHJhZ2dhYmxlLnRzPzA5MjYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL2ludGVyYWN0aW9ucy1leHRlcm5hbC9JbmZlcnJlZEVsZW1lbnREcmFnZ2luZy50cz9kYzlkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9pbnRlcmFjdGlvbnMtZXh0ZXJuYWwvVGhpcmRQYXJ0eURyYWdnYWJsZS50cz9mMWE4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9tYWluLnRzP2I5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29uZmlnLCBlbGVtZW50Q2xvc2VzdCwgRW1pdHRlciwgUG9pbnRlckRyYWdFdmVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5jb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQgPSA1MDBcblxubGV0IGlnbm9yZU1vdXNlRGVwdGggPSAwXG5sZXQgbGlzdGVuZXJDbnQgPSAwXG5sZXQgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZVxuXG4vKlxuVXNlcyBhIFwicG9pbnRlclwiIGFic3RyYWN0aW9uLCB3aGljaCBtb25pdG9ycyBVSSBldmVudHMgZm9yIGJvdGggbW91c2UgYW5kIHRvdWNoLlxuVHJhY2tzIHdoZW4gdGhlIHBvaW50ZXIgXCJkcmFnc1wiIG9uIGEgY2VydGFpbiBlbGVtZW50LCBtZWFuaW5nIGRvd24rbW92ZSt1cC5cblxuQWxzbywgdHJhY2tzIGlmIHRoZXJlIHdhcyB0b3VjaC1zY3JvbGxpbmcuXG5BbHNvLCBjYW4gcHJldmVudCB0b3VjaC1zY3JvbGxpbmcgZnJvbSBoYXBwZW5pbmcuXG5BbHNvLCBjYW4gZmlyZSBwb2ludGVybW92ZSBldmVudHMgd2hlbiBzY3JvbGxpbmcgaGFwcGVucyB1bmRlcm5lYXRoLCBldmVuIHdoZW4gbm8gcmVhbCBwb2ludGVyIG1vdmVtZW50LlxuXG5lbWl0czpcbi0gcG9pbnRlcmRvd25cbi0gcG9pbnRlcm1vdmVcbi0gcG9pbnRlcnVwXG4qL1xuZXhwb3J0IGNsYXNzIFBvaW50ZXJEcmFnZ2luZyB7XG4gIGNvbnRhaW5lckVsOiBFdmVudFRhcmdldFxuICBzdWJqZWN0RWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgZW1pdHRlcjogRW1pdHRlcjxhbnk+XG5cbiAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBkaXJlY3RseSBhc3NpZ25lZCBieSBjYWxsZXJcbiAgc2VsZWN0b3I6IHN0cmluZyA9ICcnIC8vIHdpbGwgY2F1c2Ugc3ViamVjdEVsIGluIGFsbCBlbWl0dGVkIGV2ZW50cyB0byBiZSB0aGlzIGVsZW1lbnRcbiAgaGFuZGxlU2VsZWN0b3I6IHN0cmluZyA9ICcnXG4gIHNob3VsZElnbm9yZU1vdmU6IGJvb2xlYW4gPSBmYWxzZVxuICBzaG91bGRXYXRjaFNjcm9sbDogYm9vbGVhbiA9IHRydWUgLy8gZm9yIHNpbXVsYXRpbmcgcG9pbnRlcm1vdmUgb24gc2Nyb2xsXG5cbiAgLy8gaW50ZXJuYWwgc3RhdGVzXG4gIGlzRHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICBpc1RvdWNoRHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICB3YXNUb3VjaFNjcm9sbDogYm9vbGVhbiA9IGZhbHNlXG4gIG9yaWdQYWdlWDogbnVtYmVyXG4gIG9yaWdQYWdlWTogbnVtYmVyXG4gIHByZXZQYWdlWDogbnVtYmVyXG4gIHByZXZQYWdlWTogbnVtYmVyXG4gIHByZXZTY3JvbGxYOiBudW1iZXIgLy8gYXQgdGltZSBvZiBsYXN0IHBvaW50ZXIgcGFnZVgvcGFnZVkgY2FwdHVyZVxuICBwcmV2U2Nyb2xsWTogbnVtYmVyIC8vIFwiXG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVyRWw6IEV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5jb250YWluZXJFbCA9IGNvbnRhaW5lckVsXG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKVxuICAgIGNvbnRhaW5lckVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duIGFzIEV2ZW50TGlzdGVuZXIpXG4gICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuaGFuZGxlVG91Y2hTdGFydCBhcyBFdmVudExpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSlcbiAgICBsaXN0ZW5lckNyZWF0ZWQoKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duIGFzIEV2ZW50TGlzdGVuZXIpXG4gICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0IGFzIEV2ZW50TGlzdGVuZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9IGFzIEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKVxuICAgIGxpc3RlbmVyRGVzdHJveWVkKClcbiAgfVxuXG4gIHRyeVN0YXJ0KGV2OiBVSUV2ZW50KTogYm9vbGVhbiB7XG4gICAgbGV0IHN1YmplY3RFbCA9IHRoaXMucXVlcnlTdWJqZWN0RWwoZXYpXG4gICAgbGV0IGRvd25FbCA9IGV2LnRhcmdldCBhcyBIVE1MRWxlbWVudFxuXG4gICAgaWYgKFxuICAgICAgc3ViamVjdEVsICYmXG4gICAgICAoIXRoaXMuaGFuZGxlU2VsZWN0b3IgfHwgZWxlbWVudENsb3Nlc3QoZG93bkVsLCB0aGlzLmhhbmRsZVNlbGVjdG9yKSlcbiAgICApIHtcbiAgICAgIHRoaXMuc3ViamVjdEVsID0gc3ViamVjdEVsXG4gICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlIC8vIGRvIHRoaXMgZmlyc3Qgc28gY2FuY2VsVG91Y2hTY3JvbGwgd2lsbCB3b3JrXG4gICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2VcblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNsZWFudXAoKSB7XG4gICAgaXNXaW5kb3dUb3VjaE1vdmVDYW5jZWxsZWQgPSBmYWxzZVxuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsXG4gICAgLy8ga2VlcCB3YXNUb3VjaFNjcm9sbCBhcm91bmQgZm9yIGxhdGVyIGFjY2Vzc1xuICAgIHRoaXMuZGVzdHJveVNjcm9sbFdhdGNoKClcbiAgfVxuXG4gIHF1ZXJ5U3ViamVjdEVsKGV2OiBVSUV2ZW50KTogSFRNTEVsZW1lbnQge1xuICAgIGlmICh0aGlzLnNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCB0aGlzLnNlbGVjdG9yKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbCBhcyBIVE1MRWxlbWVudFxuICB9XG5cbiAgLy8gTW91c2VcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGhhbmRsZU1vdXNlRG93biA9IChldjogTW91c2VFdmVudCkgPT4ge1xuICAgIGlmIChcbiAgICAgICF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcbiAgICAgIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2KSAmJlxuICAgICAgdGhpcy50cnlTdGFydChldilcbiAgICApIHtcbiAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2LCB0cnVlKVxuICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgcGV2KVxuICAgICAgdGhpcy5pbml0U2Nyb2xsV2F0Y2gocGV2KVxuXG4gICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmhhbmRsZU1vdXNlTW92ZSlcbiAgICAgIH1cblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlTW91c2VVcClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVNb3VzZU1vdmUgPSAoZXY6IE1vdXNlRXZlbnQpID0+IHtcbiAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldilcbiAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpXG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KVxuICB9XG5cbiAgaGFuZGxlTW91c2VVcCA9IChldjogTW91c2VFdmVudCkgPT4ge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApXG5cbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgdGhpcy5jcmVhdGVFdmVudEZyb21Nb3VzZShldikpXG5cbiAgICB0aGlzLmNsZWFudXAoKSAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICB9XG5cbiAgc2hvdWxkSWdub3JlTW91c2UoKSB7XG4gICAgcmV0dXJuIGlnbm9yZU1vdXNlRGVwdGggfHwgdGhpcy5pc1RvdWNoRHJhZ2dpbmdcbiAgfVxuXG4gIC8vIFRvdWNoXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBoYW5kbGVUb3VjaFN0YXJ0ID0gKGV2OiBUb3VjaEV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMudHJ5U3RhcnQoZXYpKSB7XG4gICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IHRydWVcblxuICAgICAgbGV0IHBldiA9IHRoaXMuY3JlYXRlRXZlbnRGcm9tVG91Y2goZXYsIHRydWUpXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpXG4gICAgICB0aGlzLmluaXRTY3JvbGxXYXRjaChwZXYpXG5cbiAgICAgIC8vIHVubGlrZSBtb3VzZSwgbmVlZCB0byBhdHRhY2ggdG8gdGFyZ2V0LCBub3QgZG9jdW1lbnRcbiAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc2MDAxNFxuICAgICAgbGV0IHRhcmdldEVsID0gZXYudGFyZ2V0IGFzIEhUTUxFbGVtZW50XG5cbiAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKVxuICAgICAgfVxuXG4gICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpXG4gICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpIC8vIHRyZWF0IGl0IGFzIGEgdG91Y2ggZW5kXG5cbiAgICAgIC8vIGF0dGFjaCBhIGhhbmRsZXIgdG8gZ2V0IGNhbGxlZCB3aGVuIEFOWSBzY3JvbGwgYWN0aW9uIGhhcHBlbnMgb24gdGhlIHBhZ2UuXG4gICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCxcbiAgICAgICAgdHJ1ZSwgLy8gdXNlQ2FwdHVyZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRvdWNoTW92ZSA9IChldjogVG91Y2hFdmVudCkgPT4ge1xuICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2KVxuICAgIHRoaXMucmVjb3JkQ29vcmRzKHBldilcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpXG4gIH1cblxuICBoYW5kbGVUb3VjaEVuZCA9IChldjogVG91Y2hFdmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHsgLy8gZG9uZSB0byBndWFyZCBhZ2FpbnN0IHRvdWNoZW5kIGZvbGxvd2VkIGJ5IHRvdWNoY2FuY2VsXG4gICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpXG4gICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpXG4gICAgICB0YXJnZXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuaGFuZGxlVG91Y2hFbmQpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSkgLy8gdXNlQ2FwdHVyZWQ9dHJ1ZVxuXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpXG5cbiAgICAgIHRoaXMuY2xlYW51cCgpIC8vIGNhbGwgbGFzdCBzbyB0aGF0IHBvaW50ZXJ1cCBoYXMgYWNjZXNzIHRvIHByb3BzXG4gICAgICB0aGlzLmlzVG91Y2hEcmFnZ2luZyA9IGZhbHNlXG4gICAgICBzdGFydElnbm9yaW5nTW91c2UoKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVRvdWNoU2Nyb2xsID0gKCkgPT4ge1xuICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSB0cnVlXG4gIH1cblxuICAvLyBjYW4gYmUgY2FsbGVkIGJ5IHVzZXIgb2YgdGhpcyBjbGFzcywgdG8gY2FuY2VsIHRvdWNoLWJhc2VkIHNjcm9sbGluZyBmb3IgdGhlIGN1cnJlbnQgZHJhZ1xuICBjYW5jZWxUb3VjaFNjcm9sbCgpIHtcbiAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBTY3JvbGxpbmcgdGhhdCBzaW11bGF0ZXMgcG9pbnRlcm1vdmVzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBpbml0U2Nyb2xsV2F0Y2goZXY6IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgdGhpcy5yZWNvcmRDb29yZHMoZXYpXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpIC8vIHVzZUNhcHR1cmU9dHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJlY29yZENvb3JkcyhldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICB0aGlzLnByZXZQYWdlWCA9IChldiBhcyBhbnkpLnBhZ2VYXG4gICAgICB0aGlzLnByZXZQYWdlWSA9IChldiBhcyBhbnkpLnBhZ2VZXG4gICAgICB0aGlzLnByZXZTY3JvbGxYID0gd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgICB0aGlzLnByZXZTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsID0gKGV2OiBVSUV2ZW50KSA9PiB7XG4gICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgIGxldCBwYWdlWCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgLSB0aGlzLnByZXZTY3JvbGxYKSArIHRoaXMucHJldlBhZ2VYXG4gICAgICBsZXQgcGFnZVkgPSAod2luZG93LnBhZ2VZT2Zmc2V0IC0gdGhpcy5wcmV2U2Nyb2xsWSkgKyB0aGlzLnByZXZQYWdlWVxuXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCB7XG4gICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgIGlzVG91Y2g6IHRoaXMuaXNUb3VjaERyYWdnaW5nLFxuICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVksXG4gICAgICAgIGRlbHRhWDogcGFnZVggLSB0aGlzLm9yaWdQYWdlWCxcbiAgICAgICAgZGVsdGFZOiBwYWdlWSAtIHRoaXMub3JpZ1BhZ2VZLFxuICAgICAgfSBhcyBQb2ludGVyRHJhZ0V2ZW50KVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lTY3JvbGxXYXRjaCgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKSAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gRXZlbnQgTm9ybWFsaXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgY3JlYXRlRXZlbnRGcm9tTW91c2UoZXY6IE1vdXNlRXZlbnQsIGlzRmlyc3Q/OiBib29sZWFuKTogUG9pbnRlckRyYWdFdmVudCB7XG4gICAgbGV0IGRlbHRhWCA9IDBcbiAgICBsZXQgZGVsdGFZID0gMFxuXG4gICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgdGhpcy5vcmlnUGFnZVggPSBldi5wYWdlWFxuICAgICAgdGhpcy5vcmlnUGFnZVkgPSBldi5wYWdlWVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YVggPSBldi5wYWdlWCAtIHRoaXMub3JpZ1BhZ2VYXG4gICAgICBkZWx0YVkgPSBldi5wYWdlWSAtIHRoaXMub3JpZ1BhZ2VZXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICBpc1RvdWNoOiBmYWxzZSxcbiAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICBwYWdlWDogZXYucGFnZVgsXG4gICAgICBwYWdlWTogZXYucGFnZVksXG4gICAgICBkZWx0YVgsXG4gICAgICBkZWx0YVksXG4gICAgfVxuICB9XG5cbiAgY3JlYXRlRXZlbnRGcm9tVG91Y2goZXY6IFRvdWNoRXZlbnQsIGlzRmlyc3Q/OiBib29sZWFuKTogUG9pbnRlckRyYWdFdmVudCB7XG4gICAgbGV0IHRvdWNoZXMgPSBldi50b3VjaGVzXG4gICAgbGV0IHBhZ2VYXG4gICAgbGV0IHBhZ2VZXG4gICAgbGV0IGRlbHRhWCA9IDBcbiAgICBsZXQgZGVsdGFZID0gMFxuXG4gICAgLy8gaWYgdG91Y2ggY29vcmRzIGF2YWlsYWJsZSwgcHJlZmVyLFxuICAgIC8vIGJlY2F1c2UgRkYgd291bGQgZ2l2ZSBiYWQgZXYucGFnZVggZXYucGFnZVlcbiAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xuICAgICAgcGFnZVggPSB0b3VjaGVzWzBdLnBhZ2VYXG4gICAgICBwYWdlWSA9IHRvdWNoZXNbMF0ucGFnZVlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnZVggPSAoZXYgYXMgYW55KS5wYWdlWFxuICAgICAgcGFnZVkgPSAoZXYgYXMgYW55KS5wYWdlWVxuICAgIH1cblxuICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgIHRoaXMub3JpZ1BhZ2VYID0gcGFnZVhcbiAgICAgIHRoaXMub3JpZ1BhZ2VZID0gcGFnZVlcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsdGFYID0gcGFnZVggLSB0aGlzLm9yaWdQYWdlWFxuICAgICAgZGVsdGFZID0gcGFnZVkgLSB0aGlzLm9yaWdQYWdlWVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgaXNUb3VjaDogdHJ1ZSxcbiAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZLFxuICAgICAgZGVsdGFYLFxuICAgICAgZGVsdGFZLFxuICAgIH1cbiAgfVxufVxuXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcbmZ1bmN0aW9uIGlzUHJpbWFyeU1vdXNlQnV0dG9uKGV2OiBNb3VzZUV2ZW50KSB7XG4gIHJldHVybiBldi5idXR0b24gPT09IDAgJiYgIWV2LmN0cmxLZXlcbn1cblxuLy8gSWdub3JpbmcgZmFrZSBtb3VzZSBldmVudHMgZ2VuZXJhdGVkIGJ5IHRvdWNoXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHN0YXJ0SWdub3JpbmdNb3VzZSgpIHsgLy8gY2FuIGJlIG1hZGUgbm9uLWNsYXNzIGZ1bmN0aW9uXG4gIGlnbm9yZU1vdXNlRGVwdGggKz0gMVxuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlnbm9yZU1vdXNlRGVwdGggLT0gMVxuICB9LCBjb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQpXG59XG5cbi8vIFdlIHdhbnQgdG8gYXR0YWNoIHRvdWNobW92ZSBhcyBlYXJseSBhcyBwb3NzaWJsZSBmb3IgU2FmYXJpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGxpc3RlbmVyQ3JlYXRlZCgpIHtcbiAgbGlzdGVuZXJDbnQgKz0gMVxuXG4gIGlmIChsaXN0ZW5lckNudCA9PT0gMSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbldpbmRvd1RvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGxpc3RlbmVyRGVzdHJveWVkKCkge1xuICBsaXN0ZW5lckNudCAtPSAxXG5cbiAgaWYgKCFsaXN0ZW5lckNudCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbldpbmRvd1RvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9IGFzIEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uV2luZG93VG91Y2hNb3ZlKGV2OiBVSUV2ZW50KSB7XG4gIGlmIChpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCkge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuIiwiaW1wb3J0IHsgcmVtb3ZlRWxlbWVudCwgYXBwbHlTdHlsZSwgd2hlblRyYW5zaXRpb25Eb25lLCBSZWN0IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbi8qXG5BbiBlZmZlY3QgaW4gd2hpY2ggYW4gZWxlbWVudCBmb2xsb3dzIHRoZSBtb3ZlbWVudCBvZiBhIHBvaW50ZXIgYWNyb3NzIHRoZSBzY3JlZW4uXG5UaGUgbW92aW5nIGVsZW1lbnQgaXMgYSBjbG9uZSBvZiBzb21lIG90aGVyIGVsZW1lbnQuXG5NdXN0IGNhbGwgc3RhcnQgKyBoYW5kbGVNb3ZlICsgc3RvcC5cbiovXG5leHBvcnQgY2xhc3MgRWxlbWVudE1pcnJvciB7XG4gIGlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlIC8vIG11c3QgYmUgZXhwbGljaXRseSBlbmFibGVkXG4gIG9yaWdTY3JlZW5YPzogbnVtYmVyXG4gIG9yaWdTY3JlZW5ZPzogbnVtYmVyXG4gIGRlbHRhWD86IG51bWJlclxuICBkZWx0YVk/OiBudW1iZXJcbiAgc291cmNlRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgbWlycm9yRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgc291cmNlRWxSZWN0OiBSZWN0IHwgbnVsbCA9IG51bGwgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxuXG4gIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0IGRpcmVjdGx5IGJ5IGNhbGxlclxuICBwYXJlbnROb2RlOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmJvZHkgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXG4gIHpJbmRleDogbnVtYmVyID0gOTk5OVxuICByZXZlcnREdXJhdGlvbjogbnVtYmVyID0gMFxuXG4gIHN0YXJ0KHNvdXJjZUVsOiBIVE1MRWxlbWVudCwgcGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcikge1xuICAgIHRoaXMuc291cmNlRWwgPSBzb3VyY2VFbFxuICAgIHRoaXMuc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldFxuICAgIHRoaXMub3JpZ1NjcmVlblkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIHRoaXMuZGVsdGFYID0gMFxuICAgIHRoaXMuZGVsdGFZID0gMFxuICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpXG4gIH1cblxuICBoYW5kbGVNb3ZlKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpIHtcbiAgICB0aGlzLmRlbHRhWCA9IChwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCkgLSB0aGlzLm9yaWdTY3JlZW5YIVxuICAgIHRoaXMuZGVsdGFZID0gKHBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSAtIHRoaXMub3JpZ1NjcmVlblkhXG4gICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKClcbiAgfVxuXG4gIC8vIGNhbiBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0XG4gIHNldElzVmlzaWJsZShib29sOiBib29sZWFuKSB7XG4gICAgaWYgKGJvb2wpIHtcbiAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sIC8vIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdXBkYXRlRWxQb3NpdGlvblxuICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKSAvLyBiZWNhdXNlIHdhcyBub3QgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIGludmlzaWJsZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIGlmICh0aGlzLm1pcnJvckVsKSB7XG4gICAgICAgIHRoaXMubWlycm9yRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2xcbiAgICB9XG4gIH1cblxuICAvLyBhbHdheXMgYXN5bmNcbiAgc3RvcChuZWVkc1JldmVydEFuaW1hdGlvbjogYm9vbGVhbiwgY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcbiAgICBsZXQgZG9uZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW51cCgpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbmVlZHNSZXZlcnRBbmltYXRpb24gJiZcbiAgICAgIHRoaXMubWlycm9yRWwgJiZcbiAgICAgIHRoaXMuaXNWaXNpYmxlICYmXG4gICAgICB0aGlzLnJldmVydER1cmF0aW9uICYmIC8vIGlmIDAsIHRyYW5zaXRpb24gd29uJ3Qgd29ya1xuICAgICAgKHRoaXMuZGVsdGFYIHx8IHRoaXMuZGVsdGFZKSAvLyBpZiBzYW1lIGNvb3JkcywgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgKSB7XG4gICAgICB0aGlzLmRvUmV2ZXJ0QW5pbWF0aW9uKGRvbmUsIHRoaXMucmV2ZXJ0RHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQoZG9uZSwgMClcbiAgICB9XG4gIH1cblxuICBkb1JldmVydEFuaW1hdGlvbihjYWxsYmFjazogKCkgPT4gdm9pZCwgcmV2ZXJ0RHVyYXRpb246IG51bWJlcikge1xuICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWwhXG4gICAgbGV0IGZpbmFsU291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbCEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgLy8gYmVjYXVzZSBhdXRvc2Nyb2xsaW5nIG1pZ2h0IGhhdmUgaGFwcGVuZWRcblxuICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPVxuICAgICAgJ3RvcCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMsJyArXG4gICAgICAnbGVmdCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMnXG5cbiAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICBsZWZ0OiBmaW5hbFNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgdG9wOiBmaW5hbFNvdXJjZUVsUmVjdC50b3AsXG4gICAgfSlcblxuICAgIHdoZW5UcmFuc2l0aW9uRG9uZShtaXJyb3JFbCwgKCkgPT4ge1xuICAgICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9ICcnXG4gICAgICBjYWxsYmFjaygpXG4gICAgfSlcbiAgfVxuXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgIHJlbW92ZUVsZW1lbnQodGhpcy5taXJyb3JFbClcbiAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsXG4gICAgfVxuXG4gICAgdGhpcy5zb3VyY2VFbCA9IG51bGxcbiAgfVxuXG4gIHVwZGF0ZUVsUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuc291cmNlRWwgJiYgdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIGFwcGx5U3R5bGUodGhpcy5nZXRNaXJyb3JFbCgpLCB7XG4gICAgICAgIGxlZnQ6IHRoaXMuc291cmNlRWxSZWN0IS5sZWZ0ICsgdGhpcy5kZWx0YVghLFxuICAgICAgICB0b3A6IHRoaXMuc291cmNlRWxSZWN0IS50b3AgKyB0aGlzLmRlbHRhWSEsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGdldE1pcnJvckVsKCk6IEhUTUxFbGVtZW50IHtcbiAgICBsZXQgc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbFJlY3QhXG4gICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JFbFxuXG4gICAgaWYgKCFtaXJyb3JFbCkge1xuICAgICAgbWlycm9yRWwgPSB0aGlzLm1pcnJvckVsID0gdGhpcy5zb3VyY2VFbCEuY2xvbmVOb2RlKHRydWUpIGFzIEhUTUxFbGVtZW50IC8vIGNsb25lQ2hpbGRyZW49dHJ1ZVxuXG4gICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXG4gICAgICAvLyB3b3VsZCB1c2UgcHJldmVudFNlbGVjdGlvbigpLCBidXQgdGhhdCBwcmV2ZW50cyBzZWxlY3RzdGFydCwgY2F1c2luZyBwcm9ibGVtcy5cbiAgICAgIG1pcnJvckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLXVuc2VsZWN0YWJsZScpXG5cbiAgICAgIG1pcnJvckVsLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LWRyYWdnaW5nJylcblxuICAgICAgYXBwbHlTdHlsZShtaXJyb3JFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgekluZGV4OiB0aGlzLnpJbmRleCxcbiAgICAgICAgdmlzaWJpbGl0eTogJycsIC8vIGluIGNhc2Ugb3JpZ2luYWwgZWxlbWVudCB3YXMgaGlkZGVuIGJ5IHRoZSBkcmFnIGVmZmVjdFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JywgLy8gZm9yIGVhc3kgd2lkdGgvaGVpZ2h0XG4gICAgICAgIHdpZHRoOiBzb3VyY2VFbFJlY3QucmlnaHQgLSBzb3VyY2VFbFJlY3QubGVmdCwgLy8gZXhwbGljaXQgaGVpZ2h0IGluIGNhc2UgdGhlcmUgd2FzIGEgJ3JpZ2h0JyB2YWx1ZVxuICAgICAgICBoZWlnaHQ6IHNvdXJjZUVsUmVjdC5ib3R0b20gLSBzb3VyY2VFbFJlY3QudG9wLCAvLyBleHBsaWNpdCB3aWR0aCBpbiBjYXNlIHRoZXJlIHdhcyBhICdib3R0b20nIHZhbHVlXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsIC8vIGVyYXNlIGFuZCBzZXQgd2lkdGggaW5zdGVhZFxuICAgICAgICBib3R0b206ICdhdXRvJywgLy8gZXJhc2UgYW5kIHNldCBoZWlnaHQgaW5zdGVhZFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICB9KVxuXG4gICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobWlycm9yRWwpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1pcnJvckVsXG4gIH1cbn1cbiIsImltcG9ydCB7IFJlY3QsIFNjcm9sbENvbnRyb2xsZXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuLypcbklzIGEgY2FjaGUgZm9yIGEgZ2l2ZW4gZWxlbWVudCdzIHNjcm9sbCBpbmZvcm1hdGlvbiAoYWxsIHRoZSBpbmZvIHRoYXQgU2Nyb2xsQ29udHJvbGxlciBzdG9yZXMpXG5pbiBhZGRpdGlvbiB0aGUgXCJjbGllbnQgcmVjdGFuZ2xlXCIgb2YgdGhlIGVsZW1lbnQuLiB0aGUgYXJlYSB3aXRoaW4gdGhlIHNjcm9sbGJhcnMuXG5cblRoZSBjYWNoZSBjYW4gYmUgaW4gb25lIG9mIHR3byBtb2Rlczpcbi0gZG9lc0xpc3RlbmluZzpmYWxzZSAtIGlnbm9yZXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIHNjcm9sbGVkIGJ5IHNvbWVvbmUgZWxzZVxuLSBkb2VzTGlzdGVuaW5nOnRydWUgLSB3YXRjaCBmb3Igc2Nyb2xsaW5nIGFuZCB1cGRhdGUgdGhlIGNhY2hlXG4qL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICBjbGllbnRSZWN0OiBSZWN0XG4gIG9yaWdTY3JvbGxUb3A6IG51bWJlclxuICBvcmlnU2Nyb2xsTGVmdDogbnVtYmVyXG5cbiAgcHJvdGVjdGVkIHNjcm9sbENvbnRyb2xsZXI6IFNjcm9sbENvbnRyb2xsZXJcbiAgcHJvdGVjdGVkIGRvZXNMaXN0ZW5pbmc6IGJvb2xlYW5cbiAgcHJvdGVjdGVkIHNjcm9sbFRvcDogbnVtYmVyXG4gIHByb3RlY3RlZCBzY3JvbGxMZWZ0OiBudW1iZXJcbiAgcHJvdGVjdGVkIHNjcm9sbFdpZHRoOiBudW1iZXJcbiAgcHJvdGVjdGVkIHNjcm9sbEhlaWdodDogbnVtYmVyXG4gIHByb3RlY3RlZCBjbGllbnRXaWR0aDogbnVtYmVyXG4gIHByb3RlY3RlZCBjbGllbnRIZWlnaHQ6IG51bWJlclxuXG4gIGNvbnN0cnVjdG9yKHNjcm9sbENvbnRyb2xsZXI6IFNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmc6IGJvb2xlYW4pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zY3JvbGxDb250cm9sbGVyID0gc2Nyb2xsQ29udHJvbGxlclxuICAgIHRoaXMuZG9lc0xpc3RlbmluZyA9IGRvZXNMaXN0ZW5pbmdcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMub3JpZ1Njcm9sbFRvcCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKClcbiAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLm9yaWdTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KClcbiAgICB0aGlzLnNjcm9sbFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxXaWR0aCgpXG4gICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpXG4gICAgdGhpcy5jbGllbnRXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50V2lkdGgoKVxuICAgIHRoaXMuY2xpZW50SGVpZ2h0ID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRIZWlnaHQoKVxuICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKSAvLyBkbyBsYXN0IGluIGNhc2UgaXQgbmVlZHMgY2FjaGVkIHZhbHVlc1xuXG4gICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKVxuICAgIH1cbiAgfVxuXG4gIGFic3RyYWN0IGdldEV2ZW50VGFyZ2V0KCk6IEV2ZW50VGFyZ2V0XG4gIGFic3RyYWN0IGNvbXB1dGVDbGllbnRSZWN0KCk6IFJlY3RcblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgIHRoaXMuZ2V0RXZlbnRUYXJnZXQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbClcbiAgICB9XG4gIH1cblxuICBoYW5kbGVTY3JvbGwgPSAoKSA9PiB7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKClcbiAgICB0aGlzLnNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsTGVmdCgpXG4gICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKVxuICB9XG5cbiAgZ2V0U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbFRvcFxuICB9XG5cbiAgZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxMZWZ0XG4gIH1cblxuICBzZXRTY3JvbGxUb3AodG9wOiBudW1iZXIpIHtcbiAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsVG9wKHRvcClcblxuICAgIGlmICghdGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAvLyB3ZSBhcmUgbm90IHJlbHlpbmcgb24gdGhlIGVsZW1lbnQgdG8gbm9ybWFsaXplIG91dC1vZi1ib3VuZHMgc2Nyb2xsIHZhbHVlc1xuICAgICAgLy8gc28gd2UgbmVlZCB0byBzYW5pdGl6ZSBvdXJzZWx2ZXNcbiAgICAgIHRoaXMuc2Nyb2xsVG9wID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbFRvcCgpKSwgMClcblxuICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKVxuICAgIH1cbiAgfVxuXG4gIHNldFNjcm9sbExlZnQodG9wOiBudW1iZXIpIHtcbiAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIuc2V0U2Nyb2xsTGVmdCh0b3ApXG5cbiAgICBpZiAoIXRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgLy8gd2UgYXJlIG5vdCByZWx5aW5nIG9uIHRoZSBlbGVtZW50IHRvIG5vcm1hbGl6ZSBvdXQtb2YtYm91bmRzIHNjcm9sbCB2YWx1ZXNcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gc2FuaXRpemUgb3Vyc2VsdmVzXG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpKSwgMClcblxuICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKVxuICAgIH1cbiAgfVxuXG4gIGdldENsaWVudFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudFdpZHRoXG4gIH1cblxuICBnZXRDbGllbnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50SGVpZ2h0XG4gIH1cblxuICBnZXRTY3JvbGxXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxXaWR0aFxuICB9XG5cbiAgZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbEhlaWdodFxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICB9XG59XG4iLCJpbXBvcnQgeyBjb21wdXRlSW5uZXJSZWN0LCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgU2Nyb2xsR2VvbUNhY2hlIH0gZnJvbSAnLi9TY3JvbGxHZW9tQ2FjaGUnXG5cbmV4cG9ydCBjbGFzcyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsR2VvbUNhY2hlIHtcbiAgY29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50LCBkb2VzTGlzdGVuaW5nOiBib29sZWFuKSB7XG4gICAgc3VwZXIobmV3IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKGVsKSwgZG9lc0xpc3RlbmluZylcbiAgfVxuXG4gIGdldEV2ZW50VGFyZ2V0KCk6IEV2ZW50VGFyZ2V0IHtcbiAgICByZXR1cm4gKHRoaXMuc2Nyb2xsQ29udHJvbGxlciBhcyBFbGVtZW50U2Nyb2xsQ29udHJvbGxlcikuZWxcbiAgfVxuXG4gIGNvbXB1dGVDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiBjb21wdXRlSW5uZXJSZWN0KCh0aGlzLnNjcm9sbENvbnRyb2xsZXIgYXMgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIpLmVsKVxuICB9XG59XG4iLCJpbXBvcnQgeyBSZWN0LCBXaW5kb3dTY3JvbGxDb250cm9sbGVyIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBTY3JvbGxHZW9tQ2FjaGUgfSBmcm9tICcuL1Njcm9sbEdlb21DYWNoZSdcblxuZXhwb3J0IGNsYXNzIFdpbmRvd1Njcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbEdlb21DYWNoZSB7XG4gIGNvbnN0cnVjdG9yKGRvZXNMaXN0ZW5pbmc6IGJvb2xlYW4pIHtcbiAgICBzdXBlcihuZXcgV2luZG93U2Nyb2xsQ29udHJvbGxlcigpLCBkb2VzTGlzdGVuaW5nKVxuICB9XG5cbiAgZ2V0RXZlbnRUYXJnZXQoKTogRXZlbnRUYXJnZXQge1xuICAgIHJldHVybiB3aW5kb3dcbiAgfVxuXG4gIGNvbXB1dGVDbGllbnRSZWN0KCk6IFJlY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICByaWdodDogdGhpcy5zY3JvbGxMZWZ0ICsgdGhpcy5jbGllbnRXaWR0aCxcbiAgICAgIHRvcDogdGhpcy5zY3JvbGxUb3AsXG4gICAgICBib3R0b206IHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5jbGllbnRIZWlnaHQsXG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIHdpbmRvdyBpcyB0aGUgb25seSBzY3JvbGwgb2JqZWN0IHRoYXQgY2hhbmdlcyBpdCdzIHJlY3RhbmdsZSByZWxhdGl2ZVxuICAvLyB0byB0aGUgZG9jdW1lbnQncyB0b3BsZWZ0IGFzIGl0IHNjcm9sbHNcbiAgaGFuZGxlU2Nyb2xsQ2hhbmdlKCkge1xuICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKVxuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRFbFJvb3QgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFNjcm9sbEdlb21DYWNoZSB9IGZyb20gJy4uL1Njcm9sbEdlb21DYWNoZSdcbmltcG9ydCB7IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUgfSBmcm9tICcuLi9FbGVtZW50U2Nyb2xsR2VvbUNhY2hlJ1xuaW1wb3J0IHsgV2luZG93U2Nyb2xsR2VvbUNhY2hlIH0gZnJvbSAnLi4vV2luZG93U2Nyb2xsR2VvbUNhY2hlJ1xuXG5pbnRlcmZhY2UgRWRnZSB7XG4gIHNjcm9sbENhY2hlOiBTY3JvbGxHZW9tQ2FjaGVcbiAgbmFtZTogJ3RvcCcgfCAnbGVmdCcgfCAncmlnaHQnIHwgJ2JvdHRvbSdcbiAgZGlzdGFuY2U6IG51bWJlciAvLyBob3cgbWFueSBwaXhlbHMgdGhlIGN1cnJlbnQgcG9pbnRlciBpcyBmcm9tIHRoZSBlZGdlXG59XG5cbi8vIElmIGF2YWlsYWJsZSB3ZSBhcmUgdXNpbmcgbmF0aXZlIFwicGVyZm9ybWFuY2VcIiBBUEkgaW5zdGVhZCBvZiBcIkRhdGVcIlxuLy8gUmVhZCBtb3JlIGFib3V0IGl0IG9uIE1ETjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZVxuY29uc3QgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IChwZXJmb3JtYW5jZSBhcyBhbnkpLm5vdyA6IERhdGUubm93XG5cbi8qXG5Gb3IgYSBwb2ludGVyIGludGVyYWN0aW9uLCBhdXRvbWF0aWNhbGx5IHNjcm9sbHMgY2VydGFpbiBzY3JvbGwgY29udGFpbmVycyB3aGVuIHRoZSBwb2ludGVyXG5hcHByb2FjaGVzIHRoZSBlZGdlLlxuXG5UaGUgY2FsbGVyIG11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmV4cG9ydCBjbGFzcyBBdXRvU2Nyb2xsZXIge1xuICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBieSBjYWxsZXJcbiAgaXNFbmFibGVkOiBib29sZWFuID0gdHJ1ZVxuICBzY3JvbGxRdWVyeTogKFdpbmRvdyB8IHN0cmluZylbXSA9IFt3aW5kb3csICcuZmMtc2Nyb2xsZXInXVxuICBlZGdlVGhyZXNob2xkOiBudW1iZXIgPSA1MCAvLyBwaXhlbHNcbiAgbWF4VmVsb2NpdHk6IG51bWJlciA9IDMwMCAvLyBwaXhlbHMgcGVyIHNlY29uZFxuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIHBvaW50ZXJTY3JlZW5YOiBudW1iZXIgfCBudWxsID0gbnVsbFxuICBwb2ludGVyU2NyZWVuWTogbnVtYmVyIHwgbnVsbCA9IG51bGxcbiAgaXNBbmltYXRpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICBzY3JvbGxDYWNoZXM6IFNjcm9sbEdlb21DYWNoZVtdIHwgbnVsbCA9IG51bGxcbiAgbXNTaW5jZVJlcXVlc3Q/OiBudW1iZXJcblxuICAvLyBwcm90ZWN0IGFnYWluc3QgdGhlIGluaXRpYWwgcG9pbnRlcmRvd24gYmVpbmcgdG9vIGNsb3NlIHRvIGFuIGVkZ2UgYW5kIHN0YXJ0aW5nIHRoZSBzY3JvbGxcbiAgZXZlck1vdmVkVXA6IGJvb2xlYW4gPSBmYWxzZVxuICBldmVyTW92ZWREb3duOiBib29sZWFuID0gZmFsc2VcbiAgZXZlck1vdmVkTGVmdDogYm9vbGVhbiA9IGZhbHNlXG4gIGV2ZXJNb3ZlZFJpZ2h0OiBib29sZWFuID0gZmFsc2VcblxuICBzdGFydChwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyLCBzY3JvbGxTdGFydEVsOiBIVE1MRWxlbWVudCkge1xuICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSB0aGlzLmJ1aWxkQ2FjaGVzKHNjcm9sbFN0YXJ0RWwpXG4gICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbFxuICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGxcbiAgICAgIHRoaXMuZXZlck1vdmVkVXAgPSBmYWxzZVxuICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gZmFsc2VcbiAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlXG4gICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gZmFsc2VcbiAgICAgIHRoaXMuaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTW92ZShwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICBsZXQgcG9pbnRlclNjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldFxuICAgICAgbGV0IHBvaW50ZXJTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXRcblxuICAgICAgbGV0IHlEZWx0YSA9IHRoaXMucG9pbnRlclNjcmVlblkgPT09IG51bGwgPyAwIDogcG9pbnRlclNjcmVlblkgLSB0aGlzLnBvaW50ZXJTY3JlZW5ZXG4gICAgICBsZXQgeERlbHRhID0gdGhpcy5wb2ludGVyU2NyZWVuWCA9PT0gbnVsbCA/IDAgOiBwb2ludGVyU2NyZWVuWCAtIHRoaXMucG9pbnRlclNjcmVlblhcblxuICAgICAgaWYgKHlEZWx0YSA8IDApIHtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoeURlbHRhID4gMCkge1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh4RGVsdGEgPCAwKSB7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoeERlbHRhID4gMCkge1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gcG9pbnRlclNjcmVlblhcbiAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWVxuXG4gICAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmcpIHtcbiAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IHRydWVcbiAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKGdldFRpbWUoKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlIC8vIHdpbGwgc3RvcCBhbmltYXRpb25cblxuICAgICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMhKSB7XG4gICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbENhY2hlcyA9IG51bGxcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0QW5pbWF0aW9uKG5vdzogbnVtYmVyKSB7XG4gICAgdGhpcy5tc1NpbmNlUmVxdWVzdCA9IG5vd1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGUpXG4gIH1cblxuICBwcml2YXRlIGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMuaXNBbmltYXRpbmcpIHsgLy8gd2Fzbid0IGNhbmNlbGxlZCBiZXR3ZWVuIGFuaW1hdGlvbiBjYWxsc1xuICAgICAgbGV0IGVkZ2UgPSB0aGlzLmNvbXB1dGVCZXN0RWRnZShcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWCEgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkhICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgKVxuXG4gICAgICBpZiAoZWRnZSkge1xuICAgICAgICBsZXQgbm93ID0gZ2V0VGltZSgpXG4gICAgICAgIHRoaXMuaGFuZGxlU2lkZShlZGdlLCAobm93IC0gdGhpcy5tc1NpbmNlUmVxdWVzdCEpIC8gMTAwMClcbiAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKG5vdylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZSAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTaWRlKGVkZ2U6IEVkZ2UsIHNlY29uZHM6IG51bWJlcikge1xuICAgIGxldCB7IHNjcm9sbENhY2hlIH0gPSBlZGdlXG4gICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpc1xuICAgIGxldCBpbnZEaXN0YW5jZSA9IGVkZ2VUaHJlc2hvbGQgLSBlZGdlLmRpc3RhbmNlXG4gICAgbGV0IHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcbiAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xuICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHNcbiAgICBsZXQgc2lnbiA9IDFcblxuICAgIHN3aXRjaCAoZWRnZS5uYW1lKSB7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgc2lnbiA9IC0xXG4gICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsTGVmdChzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KCkgKyB2ZWxvY2l0eSAqIHNpZ24pXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHNpZ24gPSAtMVxuICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxUb3Aoc2Nyb2xsQ2FjaGUuZ2V0U2Nyb2xsVG9wKCkgKyB2ZWxvY2l0eSAqIHNpZ24pXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gbGVmdC90b3AgYXJlIHJlbGF0aXZlIHRvIGRvY3VtZW50IHRvcGxlZnRcbiAgcHJpdmF0ZSBjb21wdXRlQmVzdEVkZ2UobGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcik6IEVkZ2UgfCBudWxsIHtcbiAgICBsZXQgeyBlZGdlVGhyZXNob2xkIH0gPSB0aGlzXG4gICAgbGV0IGJlc3RTaWRlOiBFZGdlIHwgbnVsbCA9IG51bGxcblxuICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzISkge1xuICAgICAgbGV0IHJlY3QgPSBzY3JvbGxDYWNoZS5jbGllbnRSZWN0XG4gICAgICBsZXQgbGVmdERpc3QgPSBsZWZ0IC0gcmVjdC5sZWZ0XG4gICAgICBsZXQgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnRcbiAgICAgIGxldCB0b3BEaXN0ID0gdG9wIC0gcmVjdC50b3BcbiAgICAgIGxldCBib3R0b21EaXN0ID0gcmVjdC5ib3R0b20gLSB0b3BcblxuICAgICAgLy8gY29tcGxldGVseSB3aXRoaW4gdGhlIHJlY3Q/XG4gICAgICBpZiAobGVmdERpc3QgPj0gMCAmJiByaWdodERpc3QgPj0gMCAmJiB0b3BEaXN0ID49IDAgJiYgYm90dG9tRGlzdCA+PSAwKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXG4gICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IHRvcERpc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ3RvcCcsIGRpc3RhbmNlOiB0b3BEaXN0IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBib3R0b21EaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWREb3duICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbERvd24oKSAmJlxuICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiBib3R0b21EaXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdib3R0b20nLCBkaXN0YW5jZTogYm90dG9tRGlzdCB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgbGVmdERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZExlZnQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsTGVmdCgpICYmXG4gICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGxlZnREaXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdsZWZ0JywgZGlzdGFuY2U6IGxlZnREaXN0IH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICByaWdodERpc3QgPD0gZWRnZVRocmVzaG9sZCAmJiB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbFJpZ2h0KCkgJiZcbiAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gcmlnaHREaXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdyaWdodCcsIGRpc3RhbmNlOiByaWdodERpc3QgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RTaWRlXG4gIH1cblxuICBwcml2YXRlIGJ1aWxkQ2FjaGVzKHNjcm9sbFN0YXJ0RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTY3JvbGxFbHMoc2Nyb2xsU3RhcnRFbCkubWFwKChlbCkgPT4ge1xuICAgICAgaWYgKGVsID09PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUoZmFsc2UpIC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFNjcm9sbEdlb21DYWNoZShlbCwgZmFsc2UpIC8vIGZhbHNlID0gZG9uJ3QgbGlzdGVuIHRvIHVzZXItZ2VuZXJhdGVkIHNjcm9sbHNcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBxdWVyeVNjcm9sbEVscyhzY3JvbGxTdGFydEVsOiBIVE1MRWxlbWVudCkge1xuICAgIGxldCBlbHMgPSBbXVxuXG4gICAgZm9yIChsZXQgcXVlcnkgb2YgdGhpcy5zY3JvbGxRdWVyeSkge1xuICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZWxzLnB1c2gocXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbHMucHVzaCguLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChcbiAgICAgICAgICBnZXRFbFJvb3Qoc2Nyb2xsU3RhcnRFbCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksXG4gICAgICAgICkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsc1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBQb2ludGVyRHJhZ0V2ZW50LFxuICBwcmV2ZW50U2VsZWN0aW9uLFxuICBhbGxvd1NlbGVjdGlvbixcbiAgcHJldmVudENvbnRleHRNZW51LFxuICBhbGxvd0NvbnRleHRNZW51LFxuICBFbGVtZW50RHJhZ2dpbmcsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgUG9pbnRlckRyYWdnaW5nIH0gZnJvbSAnLi9Qb2ludGVyRHJhZ2dpbmcnXG5pbXBvcnQgeyBFbGVtZW50TWlycm9yIH0gZnJvbSAnLi9FbGVtZW50TWlycm9yJ1xuaW1wb3J0IHsgQXV0b1Njcm9sbGVyIH0gZnJvbSAnLi9BdXRvU2Nyb2xsZXInXG5cbi8qXG5Nb25pdG9ycyBkcmFnZ2luZyBvbiBhbiBlbGVtZW50LiBIYXMgYSBudW1iZXIgb2YgaGlnaC1sZXZlbCBmZWF0dXJlczpcbi0gbWluaW11bSBkaXN0YW5jZSByZXF1aXJlZCBiZWZvcmUgZHJhZ2dpbmdcbi0gbWluaW11bSB3YWl0IHRpbWUgKFwiZGVsYXlcIikgYmVmb3JlIGRyYWdnaW5nXG4tIGEgbWlycm9yIGVsZW1lbnQgdGhhdCBmb2xsb3dzIHRoZSBwb2ludGVyXG4qL1xuZXhwb3J0IGNsYXNzIEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcgZXh0ZW5kcyBFbGVtZW50RHJhZ2dpbmcge1xuICBwb2ludGVyOiBQb2ludGVyRHJhZ2dpbmdcbiAgbWlycm9yOiBFbGVtZW50TWlycm9yXG4gIGF1dG9TY3JvbGxlcjogQXV0b1Njcm9sbGVyXG5cbiAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBkaXJlY3RseSBzZXQgYnkgY2FsbGVyXG4gIC8vIHRoZSBjYWxsZXIgY2FuIGFsc28gc2V0IHRoZSBQb2ludGVyRHJhZ2dpbmcncyBvcHRpb25zIGFzIHdlbGxcbiAgZGVsYXk6IG51bWJlciB8IG51bGwgPSBudWxsXG4gIG1pbkRpc3RhbmNlOiBudW1iZXIgPSAwXG4gIHRvdWNoU2Nyb2xsQWxsb3dlZDogYm9vbGVhbiA9IHRydWUgLy8gcHJldmVudHMgZHJhZyBmcm9tIHN0YXJ0aW5nIGFuZCBibG9ja3Mgc2Nyb2xsaW5nIGR1cmluZyBkcmFnXG5cbiAgbWlycm9yTmVlZHNSZXZlcnQ6IGJvb2xlYW4gPSBmYWxzZVxuICBpc0ludGVyYWN0aW5nOiBib29sZWFuID0gZmFsc2UgLy8gaXMgdGhlIHVzZXIgdmFsaWRseSBtb3ZpbmcgdGhlIHBvaW50ZXI/IGxhc3RzIHVudGlsIHBvaW50ZXJ1cFxuICBpc0RyYWdnaW5nOiBib29sZWFuID0gZmFsc2UgLy8gaXMgaXQgSU5URU5URlVMTFkgZHJhZ2dpbmc/IGxhc3RzIHVudGlsIGFmdGVyIHJldmVydCBhbmltYXRpb25cbiAgaXNEZWxheUVuZGVkOiBib29sZWFuID0gZmFsc2VcbiAgaXNEaXN0YW5jZVN1cnBhc3NlZDogYm9vbGVhbiA9IGZhbHNlXG4gIGRlbGF5VGltZW91dElkOiBudW1iZXIgfCBudWxsID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBzZWxlY3Rvcj86IHN0cmluZykge1xuICAgIHN1cGVyKGNvbnRhaW5lckVsKVxuXG4gICAgbGV0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKVxuICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pXG4gICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSlcbiAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXApXG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHBvaW50ZXIuc2VsZWN0b3IgPSBzZWxlY3RvclxuICAgIH1cblxuICAgIHRoaXMubWlycm9yID0gbmV3IEVsZW1lbnRNaXJyb3IoKVxuICAgIHRoaXMuYXV0b1Njcm9sbGVyID0gbmV3IEF1dG9TY3JvbGxlcigpXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucG9pbnRlci5kZXN0cm95KClcblxuICAgIC8vIEhBQ0s6IHNpbXVsYXRlIGEgcG9pbnRlci11cCB0byBlbmQgdGhlIGN1cnJlbnQgZHJhZ1xuICAgIC8vIFRPRE86IGZpcmUgJ2RyYWdlbmQnIGRpcmVjdGx5IGFuZCBzdG9wIGludGVyYWN0aW9uLiBkaXNjb3VyYWdlIHVzZSBvZiBwb2ludGVydXAgZXZlbnQgKGIvYyBtaWdodCBub3QgZmlyZSlcbiAgICB0aGlzLm9uUG9pbnRlclVwKHt9IGFzIGFueSlcbiAgfVxuXG4gIG9uUG9pbnRlckRvd24gPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBzbyBuZXcgZHJhZyBkb2Vzbid0IGhhcHBlbiB3aGlsZSByZXZlcnQgYW5pbWF0aW9uIGlzIGdvaW5nXG4gICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlXG4gICAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IGZhbHNlXG4gICAgICB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQgPSBmYWxzZVxuXG4gICAgICBwcmV2ZW50U2VsZWN0aW9uKGRvY3VtZW50LmJvZHkpXG4gICAgICBwcmV2ZW50Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSlcblxuICAgICAgLy8gcHJldmVudCBsaW5rcyBmcm9tIGJlaW5nIHZpc2l0ZWQgaWYgdGhlcmUncyBhbiBldmVudHVhbCBkcmFnLlxuICAgICAgLy8gYWxzbyBwcmV2ZW50cyBzZWxlY3Rpb24gaW4gb2xkZXIgYnJvd3NlcnMgKG1heWJlPykuXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciB0b3VjaCwgYmVzaWRlcywgYnJvd3NlciB3b3VsZCBjb21wbGFpbiBhYm91dCBwYXNzaXZlbmVzcy5cbiAgICAgIGlmICghZXYuaXNUb3VjaCkge1xuICAgICAgICBldi5vcmlnRXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldilcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgJiYgLy8gbm90IGRlc3Ryb3llZCB2aWEgcG9pbnRlcmRvd24gaGFuZGxlclxuICAgICAgICAhdGhpcy5wb2ludGVyLnNob3VsZElnbm9yZU1vdmVcbiAgICAgICkge1xuICAgICAgICAvLyBhY3Rpb25zIHJlbGF0ZWQgdG8gaW5pdGlhdGluZyBkcmFnc3RhcnQrZHJhZ21vdmUrZHJhZ2VuZC4uLlxuXG4gICAgICAgIHRoaXMubWlycm9yLnNldElzVmlzaWJsZShmYWxzZSkgLy8gcmVzZXQuIGNhbGxlciBtdXN0IHNldC12aXNpYmxlXG4gICAgICAgIHRoaXMubWlycm9yLnN0YXJ0KGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCwgZXYucGFnZVgsIGV2LnBhZ2VZKSAvLyBtdXN0IGhhcHBlbiBvbiBmaXJzdCBwb2ludGVyIGRvd25cblxuICAgICAgICB0aGlzLnN0YXJ0RGVsYXkoZXYpXG5cbiAgICAgICAgaWYgKCF0aGlzLm1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uUG9pbnRlck1vdmUgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBldilcblxuICAgICAgaWYgKCF0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZVxuICAgICAgICBsZXQgZGlzdGFuY2VTcSAvLyBjdXJyZW50IGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiwgc3F1YXJlZFxuICAgICAgICBsZXQgeyBkZWx0YVgsIGRlbHRhWSB9ID0gZXZcblxuICAgICAgICBkaXN0YW5jZVNxID0gZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZXG4gICAgICAgIGlmIChkaXN0YW5jZVNxID49IG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UpIHsgLy8gdXNlIHB5dGhhZ29yZWFuIHRoZW9yZW1cbiAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgLy8gYSByZWFsIHBvaW50ZXIgbW92ZT8gKG5vdCBvbmUgc2ltdWxhdGVkIGJ5IHNjcm9sbGluZylcbiAgICAgICAgaWYgKGV2Lm9yaWdFdmVudC50eXBlICE9PSAnc2Nyb2xsJykge1xuICAgICAgICAgIHRoaXMubWlycm9yLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKVxuICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb2ludGVyVXAgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XG4gICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZVxuXG4gICAgICBhbGxvd1NlbGVjdGlvbihkb2N1bWVudC5ib2R5KVxuICAgICAgYWxsb3dDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KVxuXG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpIC8vIGNhbiBwb3RlbnRpYWxseSBzZXQgbWlycm9yTmVlZHNSZXZlcnRcblxuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5zdG9wKClcbiAgICAgICAgdGhpcy50cnlTdG9wRHJhZyhldikgLy8gd2hpY2ggd2lsbCBzdG9wIHRoZSBtaXJyb3JcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGVsYXlUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVsYXlUaW1lb3V0SWQpXG4gICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhcnREZWxheShldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGxcbiAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldilcbiAgICAgIH0sIHRoaXMuZGVsYXkpIGFzIGFueSAvLyBub3QgYXNzaWduYWJsZSB0byBudW1iZXIhXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFuZGxlRGVsYXlFbmQoZXYpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRGVsYXlFbmQoZXY6IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICB0aGlzLmlzRGVsYXlFbmRlZCA9IHRydWVcbiAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldilcbiAgfVxuXG4gIGhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gdHJ1ZVxuICAgIHRoaXMudHJ5U3RhcnREcmFnKGV2KVxuICB9XG5cbiAgdHJ5U3RhcnREcmFnKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNEZWxheUVuZGVkICYmIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuICAgICAgaWYgKCF0aGlzLnBvaW50ZXIud2FzVG91Y2hTY3JvbGwgfHwgdGhpcy50b3VjaFNjcm9sbEFsbG93ZWQpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZVxuICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2VcblxuICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5zdGFydChldi5wYWdlWCwgZXYucGFnZVksIHRoaXMuY29udGFpbmVyRWwpXG4gICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldilcblxuICAgICAgICBpZiAodGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5wb2ludGVyLmNhbmNlbFRvdWNoU2Nyb2xsKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRyeVN0b3BEcmFnKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSB7XG4gICAgLy8gLnN0b3AoKSBpcyBBTFdBWVMgYXN5bmNocm9ub3VzLCB3aGljaCB3ZSBORUVEIGJlY2F1c2Ugd2Ugd2FudCBhbGwgcG9pbnRlcnVwIGV2ZW50c1xuICAgIC8vIHRoYXQgY29tZSBmcm9tIHRoZSBkb2N1bWVudCB0byBmaXJlIGJlZm9yZWhhbmQuIG11Y2ggbW9yZSBjb252ZW5pZW50IHRoaXMgd2F5LlxuICAgIHRoaXMubWlycm9yLnN0b3AoXG4gICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0LFxuICAgICAgdGhpcy5zdG9wRHJhZy5iaW5kKHRoaXMsIGV2KSwgLy8gYm91bmQgd2l0aCBhcmdzXG4gICAgKVxuICB9XG5cbiAgc3RvcERyYWcoZXY6IFBvaW50ZXJEcmFnRXZlbnQpIHtcbiAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZVxuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpXG4gIH1cblxuICAvLyBmaWxsIGluIHRoZSBpbXBsZW1lbnRhdGlvbnMuLi5cblxuICBzZXRJZ25vcmVNb3ZlKGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnBvaW50ZXIuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2xcbiAgfVxuXG4gIHNldE1pcnJvcklzVmlzaWJsZShib29sOiBib29sZWFuKSB7XG4gICAgdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGJvb2wpXG4gIH1cblxuICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sOiBib29sZWFuKSB7XG4gICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGJvb2xcbiAgfVxuXG4gIHNldEF1dG9TY3JvbGxFbmFibGVkKGJvb2w6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBib29sXG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIGdldENsaXBwaW5nUGFyZW50cywgY29tcHV0ZVJlY3QsXG4gIHBvaW50SW5zaWRlUmVjdCwgUmVjdCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlIH0gZnJvbSAnLi9FbGVtZW50U2Nyb2xsR2VvbUNhY2hlJ1xuXG4vKlxuV2hlbiB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgaXQgcmVjb3JkcyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0b3BsZWZ0KSxcbmFuZCBjb250aW51ZXMgdG8gbW9uaXRvciBzY3JvbGxpbmcsIHVwZGF0aW5nIHRoZSBjYWNoZWQgY29vcmRpbmF0ZXMgaWYgaXQgbmVlZHMgdG8uXG5Eb2VzIG5vdCBhY2Nlc3MgdGhlIERPTSBhZnRlciBpbnN0YW50aWF0aW9uLCBzbyBoaWdobHkgcGVyZm9ybWFudC5cblxuQWxzbyBrZWVwcyB0cmFjayBvZiBhbGwgc2Nyb2xsaW5nL292ZXJmbG93OmhpZGRlbiBjb250YWluZXJzIHRoYXQgYXJlIHBhcmVudHMgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbmFuZCBhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGNvbWJpbmVkIGNsaXBwaW5nIHJlY3RhbmdsZS5cbiovXG5leHBvcnQgY2xhc3MgT2Zmc2V0VHJhY2tlciB7IC8vIEVsZW1lbnRPZmZzZXRUcmFja2VyXG4gIHNjcm9sbENhY2hlczogRWxlbWVudFNjcm9sbEdlb21DYWNoZVtdXG4gIG9yaWdSZWN0OiBSZWN0XG5cbiAgY29uc3RydWN0b3IoZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5vcmlnUmVjdCA9IGNvbXB1dGVSZWN0KGVsKVxuXG4gICAgLy8gd2lsbCB3b3JrIGZpbmUgZm9yIGRpdnMgdGhhdCBoYXZlIG92ZXJmbG93OmhpZGRlblxuICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKS5tYXAoXG4gICAgICAoc2Nyb2xsRWwpID0+IG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKHNjcm9sbEVsLCB0cnVlKSwgLy8gbGlzdGVuPXRydWVcbiAgICApXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICBjb21wdXRlTGVmdCgpIHtcbiAgICBsZXQgbGVmdCA9IHRoaXMub3JpZ1JlY3QubGVmdFxuXG4gICAgZm9yIChsZXQgc2Nyb2xsQ2FjaGUgb2YgdGhpcy5zY3JvbGxDYWNoZXMpIHtcbiAgICAgIGxlZnQgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbExlZnQgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxMZWZ0KClcbiAgICB9XG5cbiAgICByZXR1cm4gbGVmdFxuICB9XG5cbiAgY29tcHV0ZVRvcCgpIHtcbiAgICBsZXQgdG9wID0gdGhpcy5vcmlnUmVjdC50b3BcblxuICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICB0b3AgKz0gc2Nyb2xsQ2FjaGUub3JpZ1Njcm9sbFRvcCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRvcFxuICB9XG5cbiAgaXNXaXRoaW5DbGlwcGluZyhwYWdlWDogbnVtYmVyLCBwYWdlWTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgbGV0IHBvaW50ID0geyBsZWZ0OiBwYWdlWCwgdG9wOiBwYWdlWSB9XG5cbiAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgaWYgKFxuICAgICAgICAhaXNJZ25vcmVkQ2xpcHBpbmcoc2Nyb2xsQ2FjaGUuZ2V0RXZlbnRUYXJnZXQoKSkgJiZcbiAgICAgICAgIXBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbi8vIGNlcnRhaW4gY2xpcHBpbmcgY29udGFpbmVycyBzaG91bGQgbmV2ZXIgY29uc3RyYWluIGludGVyYWN0aW9ucywgbGlrZSA8aHRtbD4gYW5kIDxib2R5PlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxjYWxlbmRhci9mdWxsY2FsZW5kYXIvaXNzdWVzLzM2MTVcbmZ1bmN0aW9uIGlzSWdub3JlZENsaXBwaW5nKG5vZGU6IEV2ZW50VGFyZ2V0KSB7XG4gIGxldCB0YWdOYW1lID0gKG5vZGUgYXMgSFRNTEVsZW1lbnQpLnRhZ05hbWVcblxuICByZXR1cm4gdGFnTmFtZSA9PT0gJ0hUTUwnIHx8IHRhZ05hbWUgPT09ICdCT0RZJ1xufVxuIiwiaW1wb3J0IHtcbiAgRW1pdHRlciwgUG9pbnRlckRyYWdFdmVudCxcbiAgaXNEYXRlU3BhbnNFcXVhbCxcbiAgY29tcHV0ZVJlY3QsXG4gIGNvbnN0cmFpblBvaW50LCBpbnRlcnNlY3RSZWN0cywgZ2V0UmVjdENlbnRlciwgZGlmZlBvaW50cywgUG9pbnQsXG4gIHJhbmdlQ29udGFpbnNSYW5nZSxcbiAgSGl0LFxuICBJbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXG4gIG1hcEhhc2gsXG4gIEVsZW1lbnREcmFnZ2luZyxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBPZmZzZXRUcmFja2VyIH0gZnJvbSAnLi4vT2Zmc2V0VHJhY2tlcidcblxuLypcblRyYWNrcyBtb3ZlbWVudCBvdmVyIG11bHRpcGxlIGRyb3BwYWJsZSBhcmVhcyAoYWthIFwiaGl0c1wiKVxudGhhdCBleGlzdCBpbiBvbmUgb3IgbW9yZSBEYXRlQ29tcG9uZW50cy5cblJlbGllcyBvbiBhbiBleGlzdGluZyBkcmFnZ2FibGUuXG5cbmVtaXRzOlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gaGl0Y2hhbmdlIC0gZmlyZXMgaW5pdGlhbGx5LCBldmVuIGlmIG5vdCBvdmVyIGEgaGl0XG4tIHBvaW50ZXJ1cFxuLSAoaGl0Y2hhbmdlIC0gYWdhaW4sIHRvIG51bGwsIGlmIGVuZGVkIG92ZXIgYSBoaXQpXG4tIGRyYWdlbmRcbiovXG5leHBvcnQgY2xhc3MgSGl0RHJhZ2dpbmcge1xuICBkcm9wcGFibGVTdG9yZTogSW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlXG4gIGRyYWdnaW5nOiBFbGVtZW50RHJhZ2dpbmdcbiAgZW1pdHRlcjogRW1pdHRlcjxhbnk+XG5cbiAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gIHVzZVN1YmplY3RDZW50ZXI6IGJvb2xlYW4gPSBmYWxzZVxuICByZXF1aXJlSW5pdGlhbDogYm9vbGVhbiA9IHRydWUgLy8gaWYgZG9lc24ndCBzdGFydCBvdXQgb24gYSBoaXQsIHdvbid0IGVtaXQgYW55IGV2ZW50c1xuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIG9mZnNldFRyYWNrZXJzOiB7IFtjb21wb25lbnRVaWQ6IHN0cmluZ106IE9mZnNldFRyYWNrZXIgfVxuICBpbml0aWFsSGl0OiBIaXQgfCBudWxsID0gbnVsbFxuICBtb3ZpbmdIaXQ6IEhpdCB8IG51bGwgPSBudWxsXG4gIGZpbmFsSGl0OiBIaXQgfCBudWxsID0gbnVsbCAvLyB3b24ndCBldmVyIGJlIHBvcHVsYXRlZCBpZiBzaG91bGRJZ25vcmVNb3ZlXG4gIGNvb3JkQWRqdXN0PzogUG9pbnRcblxuICBjb25zdHJ1Y3RvcihkcmFnZ2luZzogRWxlbWVudERyYWdnaW5nLCBkcm9wcGFibGVTdG9yZTogSW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKSB7XG4gICAgdGhpcy5kcm9wcGFibGVTdG9yZSA9IGRyb3BwYWJsZVN0b3JlXG5cbiAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pXG4gICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpXG4gICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ21vdmUnLCB0aGlzLmhhbmRsZURyYWdNb3ZlKVxuICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKVxuICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpXG5cbiAgICB0aGlzLmRyYWdnaW5nID0gZHJhZ2dpbmdcbiAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCB7IGRyYWdnaW5nIH0gPSB0aGlzXG5cbiAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsXG4gICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsXG4gICAgdGhpcy5maW5hbEhpdCA9IG51bGxcblxuICAgIHRoaXMucHJlcGFyZUhpdHMoKVxuICAgIHRoaXMucHJvY2Vzc0ZpcnN0Q29vcmQoZXYpXG5cbiAgICBpZiAodGhpcy5pbml0aWFsSGl0IHx8ICF0aGlzLnJlcXVpcmVJbml0aWFsKSB7XG4gICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKGZhbHNlKVxuXG4gICAgICAvLyBUT0RPOiBmaXJlIHRoaXMgYmVmb3JlIGNvbXB1dGluZyBwcm9jZXNzRmlyc3RDb29yZCwgc28gbGlzdGVuZXJzIGNhbiBjYW5jZWwuIHRoaXMgZ2V0cyBmaXJlZCBieSBhbG1vc3QgZXZlcnkgaGFuZGxlciA6KFxuICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUodHJ1ZSlcbiAgICB9XG4gIH1cblxuICAvLyBzZXRzIGluaXRpYWxIaXRcbiAgLy8gc2V0cyBjb29yZEFkanVzdFxuICBwcm9jZXNzRmlyc3RDb29yZChldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIGxldCBvcmlnUG9pbnQgPSB7IGxlZnQ6IGV2LnBhZ2VYLCB0b3A6IGV2LnBhZ2VZIH1cbiAgICBsZXQgYWRqdXN0ZWRQb2ludCA9IG9yaWdQb2ludFxuICAgIGxldCBzdWJqZWN0RWwgPSBldi5zdWJqZWN0RWxcbiAgICBsZXQgc3ViamVjdFJlY3RcblxuICAgIGlmIChzdWJqZWN0RWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyBpLmUuIG5vdCBhIERvY3VtZW50L1NoYWRvd1Jvb3RcbiAgICAgIHN1YmplY3RSZWN0ID0gY29tcHV0ZVJlY3Qoc3ViamVjdEVsKVxuICAgICAgYWRqdXN0ZWRQb2ludCA9IGNvbnN0cmFpblBvaW50KGFkanVzdGVkUG9pbnQsIHN1YmplY3RSZWN0KVxuICAgIH1cblxuICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5pbml0aWFsSGl0ID0gdGhpcy5xdWVyeUhpdEZvck9mZnNldChhZGp1c3RlZFBvaW50LmxlZnQsIGFkanVzdGVkUG9pbnQudG9wKVxuICAgIGlmIChpbml0aWFsSGl0KSB7XG4gICAgICBpZiAodGhpcy51c2VTdWJqZWN0Q2VudGVyICYmIHN1YmplY3RSZWN0KSB7XG4gICAgICAgIGxldCBzbGljZWRTdWJqZWN0UmVjdCA9IGludGVyc2VjdFJlY3RzKHN1YmplY3RSZWN0LCBpbml0aWFsSGl0LnJlY3QpXG4gICAgICAgIGlmIChzbGljZWRTdWJqZWN0UmVjdCkge1xuICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBnZXRSZWN0Q2VudGVyKHNsaWNlZFN1YmplY3RSZWN0KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29vcmRBZGp1c3QgPSBkaWZmUG9pbnRzKGFkanVzdGVkUG9pbnQsIG9yaWdQb2ludClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHsgbGVmdDogMCwgdG9wOiAwIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVEcmFnU3RhcnQgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpXG4gICAgdGhpcy5oYW5kbGVNb3ZlKGV2LCB0cnVlKSAvLyBmb3JjZSA9IGZpcmUgZXZlbiBpZiBpbml0aWFsbHkgbnVsbFxuICB9XG5cbiAgaGFuZGxlRHJhZ01vdmUgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldilcbiAgICB0aGlzLmhhbmRsZU1vdmUoZXYpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyVXAgPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICB0aGlzLnJlbGVhc2VIaXRzKClcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpXG4gIH1cblxuICBoYW5kbGVEcmFnRW5kID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMubW92aW5nSGl0KSB7XG4gICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignaGl0dXBkYXRlJywgbnVsbCwgdHJ1ZSwgZXYpXG4gICAgfVxuXG4gICAgdGhpcy5maW5hbEhpdCA9IHRoaXMubW92aW5nSGl0XG4gICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsXG4gICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldilcbiAgfVxuXG4gIGhhbmRsZU1vdmUoZXY6IFBvaW50ZXJEcmFnRXZlbnQsIGZvcmNlSGFuZGxlPzogYm9vbGVhbikge1xuICAgIGxldCBoaXQgPSB0aGlzLnF1ZXJ5SGl0Rm9yT2Zmc2V0KFxuICAgICAgZXYucGFnZVggKyB0aGlzLmNvb3JkQWRqdXN0IS5sZWZ0LFxuICAgICAgZXYucGFnZVkgKyB0aGlzLmNvb3JkQWRqdXN0IS50b3AsXG4gICAgKVxuXG4gICAgaWYgKGZvcmNlSGFuZGxlIHx8ICFpc0hpdHNFcXVhbCh0aGlzLm1vdmluZ0hpdCwgaGl0KSkge1xuICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBoaXRcbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBoaXQsIGZhbHNlLCBldilcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlSGl0cygpIHtcbiAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0gbWFwSGFzaCh0aGlzLmRyb3BwYWJsZVN0b3JlLCAoaW50ZXJhY3Rpb25TZXR0aW5ncykgPT4ge1xuICAgICAgaW50ZXJhY3Rpb25TZXR0aW5ncy5jb21wb25lbnQucHJlcGFyZUhpdHMoKVxuICAgICAgcmV0dXJuIG5ldyBPZmZzZXRUcmFja2VyKGludGVyYWN0aW9uU2V0dGluZ3MuZWwpXG4gICAgfSlcbiAgfVxuXG4gIHJlbGVhc2VIaXRzKCkge1xuICAgIGxldCB7IG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzXG5cbiAgICBmb3IgKGxldCBpZCBpbiBvZmZzZXRUcmFja2Vycykge1xuICAgICAgb2Zmc2V0VHJhY2tlcnNbaWRdLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSB7fVxuICB9XG5cbiAgcXVlcnlIaXRGb3JPZmZzZXQob2Zmc2V0TGVmdDogbnVtYmVyLCBvZmZzZXRUb3A6IG51bWJlcik6IEhpdCB8IG51bGwge1xuICAgIGxldCB7IGRyb3BwYWJsZVN0b3JlLCBvZmZzZXRUcmFja2VycyB9ID0gdGhpc1xuICAgIGxldCBiZXN0SGl0OiBIaXQgfCBudWxsID0gbnVsbFxuXG4gICAgZm9yIChsZXQgaWQgaW4gZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgIGxldCBjb21wb25lbnQgPSBkcm9wcGFibGVTdG9yZVtpZF0uY29tcG9uZW50XG4gICAgICBsZXQgb2Zmc2V0VHJhY2tlciA9IG9mZnNldFRyYWNrZXJzW2lkXVxuXG4gICAgICBpZiAoXG4gICAgICAgIG9mZnNldFRyYWNrZXIgJiYgLy8gd2Fzbid0IGRlc3Ryb3llZCBtaWQtZHJhZ1xuICAgICAgICBvZmZzZXRUcmFja2VyLmlzV2l0aGluQ2xpcHBpbmcob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKVxuICAgICAgKSB7XG4gICAgICAgIGxldCBvcmlnaW5MZWZ0ID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlTGVmdCgpXG4gICAgICAgIGxldCBvcmlnaW5Ub3AgPSBvZmZzZXRUcmFja2VyLmNvbXB1dGVUb3AoKVxuICAgICAgICBsZXQgcG9zaXRpb25MZWZ0ID0gb2Zmc2V0TGVmdCAtIG9yaWdpbkxlZnRcbiAgICAgICAgbGV0IHBvc2l0aW9uVG9wID0gb2Zmc2V0VG9wIC0gb3JpZ2luVG9wXG4gICAgICAgIGxldCB7IG9yaWdSZWN0IH0gPSBvZmZzZXRUcmFja2VyXG4gICAgICAgIGxldCB3aWR0aCA9IG9yaWdSZWN0LnJpZ2h0IC0gb3JpZ1JlY3QubGVmdFxuICAgICAgICBsZXQgaGVpZ2h0ID0gb3JpZ1JlY3QuYm90dG9tIC0gb3JpZ1JlY3QudG9wXG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIG11c3QgYmUgd2l0aGluIHRoZSBlbGVtZW50J3MgYm91bmRzXG4gICAgICAgICAgcG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgd2lkdGggJiZcbiAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgaGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgIGxldCBoaXQgPSBjb21wb25lbnQucXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBoaXQgJiYgKFxuICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGhpdCBpcyB3aXRoaW4gYWN0aXZlUmFuZ2UsIG1lYW5pbmcgaXQncyBub3QgYSBkZWFkIGNlbGxcbiAgICAgICAgICAgICAgcmFuZ2VDb250YWluc1JhbmdlKGhpdC5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgaGl0LmRhdGVTcGFuLnJhbmdlKVxuICAgICAgICAgICAgKSAmJlxuICAgICAgICAgICAgKCFiZXN0SGl0IHx8IGhpdC5sYXllciA+IGJlc3RIaXQubGF5ZXIpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBoaXQuY29tcG9uZW50SWQgPSBpZFxuICAgICAgICAgICAgaGl0LmNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dFxuXG4gICAgICAgICAgICAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIHJlLW9yaWVudCByZWN0YW5nbGVcbiAgICAgICAgICAgIGhpdC5yZWN0LmxlZnQgKz0gb3JpZ2luTGVmdFxuICAgICAgICAgICAgaGl0LnJlY3QucmlnaHQgKz0gb3JpZ2luTGVmdFxuICAgICAgICAgICAgaGl0LnJlY3QudG9wICs9IG9yaWdpblRvcFxuICAgICAgICAgICAgaGl0LnJlY3QuYm90dG9tICs9IG9yaWdpblRvcFxuXG4gICAgICAgICAgICBiZXN0SGl0ID0gaGl0XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3RIaXRcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNIaXRzRXF1YWwoaGl0MDogSGl0IHwgbnVsbCwgaGl0MTogSGl0IHwgbnVsbCk6IGJvb2xlYW4ge1xuICBpZiAoIWhpdDAgJiYgIWhpdDEpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKEJvb2xlYW4oaGl0MCkgIT09IEJvb2xlYW4oaGl0MSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiBpc0RhdGVTcGFuc0VxdWFsKGhpdDAhLmRhdGVTcGFuLCBoaXQxIS5kYXRlU3Bhbilcbn1cbiIsImltcG9ydCB7IERhdGVTcGFuLCBDYWxlbmRhckNvbnRleHQsIERhdGVQb2ludEFwaSwgRGF0ZUVudiwgVmlld0FwaSwgRXZlbnRBcGkgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcEFyZyBleHRlbmRzIERhdGVQb2ludEFwaSB7XG4gIGRyYWdnZWRFbDogSFRNTEVsZW1lbnRcbiAganNFdmVudDogTW91c2VFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCB0eXBlIEV2ZW50UmVjZWl2ZUFyZyA9IEV2ZW50UmVjZWl2ZUxlYXZlQXJnXG5leHBvcnQgdHlwZSBFdmVudExlYXZlQXJnID0gRXZlbnRSZWNlaXZlTGVhdmVBcmdcbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZWNlaXZlTGVhdmVBcmcgeyAvLyB3aWxsIHRoaXMgYmVjb21lIHB1YmxpYz9cbiAgZHJhZ2dlZEVsOiBIVE1MRWxlbWVudFxuICBldmVudDogRXZlbnRBcGlcbiAgcmVsYXRlZEV2ZW50czogRXZlbnRBcGlbXVxuICByZXZlcnQ6ICgpID0+IHZvaWRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChkYXRlU3BhbjogRGF0ZVNwYW4sIGNvbnRleHQ6IENhbGVuZGFyQ29udGV4dCkge1xuICBsZXQgcHJvcHMgPSB7fSBhcyBEYXRlUG9pbnRBcGlcblxuICBmb3IgKGxldCB0cmFuc2Zvcm0gb2YgY29udGV4dC5wbHVnaW5Ib29rcy5kYXRlUG9pbnRUcmFuc2Zvcm1zKSB7XG4gICAgX19hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgY29udGV4dCkpXG4gIH1cblxuICBfX2Fzc2lnbihwcm9wcywgYnVpbGREYXRlUG9pbnRBcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpXG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaShzcGFuOiBEYXRlU3BhbiwgZGF0ZUVudjogRGF0ZUVudik6IERhdGVQb2ludEFwaSB7XG4gIHJldHVybiB7XG4gICAgZGF0ZTogZGF0ZUVudi50b0RhdGUoc3Bhbi5yYW5nZS5zdGFydCksXG4gICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXG4gICAgYWxsRGF5OiBzcGFuLmFsbERheSxcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgUG9pbnRlckRyYWdFdmVudCwgSW50ZXJhY3Rpb24sIEludGVyYWN0aW9uU2V0dGluZ3MsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLFxuICBEYXRlUG9pbnRBcGksXG4gIFZpZXdBcGksXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4uL2RuZC9GZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nJ1xuaW1wb3J0IHsgSGl0RHJhZ2dpbmcsIGlzSGl0c0VxdWFsIH0gZnJvbSAnLi9IaXREcmFnZ2luZydcbmltcG9ydCB7IGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQgfSBmcm9tICcuLi91dGlscydcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlQ2xpY2tBcmcgZXh0ZW5kcyBEYXRlUG9pbnRBcGkge1xuICBkYXlFbDogSFRNTEVsZW1lbnRcbiAganNFdmVudDogTW91c2VFdmVudFxuICB2aWV3OiBWaWV3QXBpXG59XG5cbi8qXG5Nb25pdG9ycyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhIHNwZWNpZmljIGRhdGUvdGltZSBvZiBhIGNvbXBvbmVudC5cbkEgcG9pbnRlcmRvd24rcG9pbnRlcnVwIG9uIHRoZSBzYW1lIFwiaGl0XCIgY29uc3RpdHV0ZXMgYSBjbGljay5cbiovXG5leHBvcnQgY2xhc3MgRGF0ZUNsaWNraW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICBkcmFnZ2luZzogRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZ1xuICBoaXREcmFnZ2luZzogSGl0RHJhZ2dpbmdcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKVxuXG4gICAgLy8gd2UgRE8gd2FudCB0byB3YXRjaCBwb2ludGVyIG1vdmVzIGJlY2F1c2Ugb3RoZXJ3aXNlIGZpbmFsSGl0IHdvbid0IGdldCBwb3B1bGF0ZWRcbiAgICB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpXG4gICAgdGhpcy5kcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gZmFsc2VcblxuICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlckRvd24gPSAocGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXNcbiAgICBsZXQgZG93bkVsID0gcGV2Lm9yaWdFdmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcblxuICAgIC8vIGRvIHRoaXMgaW4gcG9pbnRlcmRvd24gKG5vdCBkcmFnZW5kKSBiZWNhdXNlIERPTSBtaWdodCBiZSBtdXRhdGVkIGJ5IHRoZSB0aW1lIGRyYWdlbmQgaXMgZmlyZWRcbiAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKFxuICAgICAgIXRoaXMuY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGRvd25FbCksXG4gICAgKVxuICB9XG5cbiAgLy8gd29uJ3QgZXZlbiBmaXJlIGlmIG1vdmluZyB3YXMgaWdub3JlZFxuICBoYW5kbGVEcmFnRW5kID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzXG4gICAgbGV0IHsgcG9pbnRlciB9ID0gdGhpcy5kcmFnZ2luZ1xuXG4gICAgaWYgKCFwb2ludGVyLndhc1RvdWNoU2Nyb2xsKSB7XG4gICAgICBsZXQgeyBpbml0aWFsSGl0LCBmaW5hbEhpdCB9ID0gdGhpcy5oaXREcmFnZ2luZ1xuXG4gICAgICBpZiAoaW5pdGlhbEhpdCAmJiBmaW5hbEhpdCAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBmaW5hbEhpdCkpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gY29tcG9uZW50XG4gICAgICAgIGxldCBhcmc6IERhdGVDbGlja0FyZyA9IHtcbiAgICAgICAgICAuLi5idWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGluaXRpYWxIaXQuZGF0ZVNwYW4sIGNvbnRleHQpLFxuICAgICAgICAgIGRheUVsOiBpbml0aWFsSGl0LmRheUVsLFxuICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50LFxuICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcsXG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZUNsaWNrJywgYXJnKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgY29tcGFyZU51bWJlcnMsIGVuYWJsZUN1cnNvciwgZGlzYWJsZUN1cnNvciwgRGF0ZUNvbXBvbmVudCwgSGl0LFxuICBEYXRlU3BhbiwgUG9pbnRlckRyYWdFdmVudCwgZGF0ZVNlbGVjdGlvbkpvaW5UcmFuc2Zvcm1lcixcbiAgSW50ZXJhY3Rpb24sIEludGVyYWN0aW9uU2V0dGluZ3MsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlLFxuICB0cmlnZ2VyRGF0ZVNlbGVjdCwgaXNEYXRlU2VsZWN0aW9uVmFsaWQsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IEhpdERyYWdnaW5nIH0gZnJvbSAnLi9IaXREcmFnZ2luZydcbmltcG9ydCB7IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcgfSBmcm9tICcuLi9kbmQvRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZydcblxuLypcblRyYWNrcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBwb3J0aW9uIG9mIHRpbWUgb2YgYSBjb21wb25lbnQsXG5jb25zdGl0dXRlZCBieSBhIGRyYWcgb3ZlciBkYXRlIGNlbGxzLCB3aXRoIGEgcG9zc2libGUgZGVsYXkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZHJhZy5cbiovXG5leHBvcnQgY2xhc3MgRGF0ZVNlbGVjdGluZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgZHJhZ2dpbmc6IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmdcbiAgaGl0RHJhZ2dpbmc6IEhpdERyYWdnaW5nXG4gIGRyYWdTZWxlY3Rpb246IERhdGVTcGFuIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKVxuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3NcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dFxuXG4gICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKVxuICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlXG4gICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBvcHRpb25zLnNlbGVjdE1pbkRpc3RhbmNlIHx8IDBcbiAgICBkcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gb3B0aW9ucy5kcmFnU2Nyb2xsXG5cbiAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKHRoaXMuZHJhZ2dpbmcsIGludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlKHNldHRpbmdzKSlcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpXG4gIH1cblxuICBoYW5kbGVQb2ludGVyRG93biA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCB7IGNvbXBvbmVudCwgZHJhZ2dpbmcgfSA9IHRoaXNcbiAgICBsZXQgeyBvcHRpb25zIH0gPSBjb21wb25lbnQuY29udGV4dFxuXG4gICAgbGV0IGNhblNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0YWJsZSAmJlxuICAgICAgY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpXG5cbiAgICAvLyBkb24ndCBib3RoZXIgdG8gd2F0Y2ggZXhwZW5zaXZlIG1vdmVzIGlmIGNvbXBvbmVudCB3b24ndCBkbyBzZWxlY3Rpb25cbiAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCFjYW5TZWxlY3QpXG5cbiAgICAvLyBpZiB0b3VjaCwgcmVxdWlyZSB1c2VyIHRvIGhvbGQgZG93blxuICAgIGRyYWdnaW5nLmRlbGF5ID0gZXYuaXNUb3VjaCA/IGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSA6IG51bGxcbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMuY29tcG9uZW50LmNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpIC8vIHVuc2VsZWN0IHByZXZpb3VzIHNlbGVjdGlvbnNcbiAgfVxuXG4gIGhhbmRsZUhpdFVwZGF0ZSA9IChoaXQ6IEhpdCB8IG51bGwsIGlzRmluYWw6IGJvb2xlYW4pID0+IHtcbiAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudFxuICAgIGxldCBkcmFnU2VsZWN0aW9uOiBEYXRlU3BhbiB8IG51bGwgPSBudWxsXG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlXG5cbiAgICBpZiAoaGl0KSB7XG4gICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdCFcbiAgICAgIGxldCBkaXNhbGxvd2VkID0gaGl0LmNvbXBvbmVudElkID09PSBpbml0aWFsSGl0LmNvbXBvbmVudElkXG4gICAgICAgICYmIHRoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgJiYgIXRoaXMuaXNIaXRDb21ib0FsbG93ZWQoaW5pdGlhbEhpdCwgaGl0KVxuXG4gICAgICBpZiAoIWRpc2FsbG93ZWQpIHtcbiAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IGpvaW5IaXRzSW50b1NlbGVjdGlvbihcbiAgICAgICAgICBpbml0aWFsSGl0LFxuICAgICAgICAgIGhpdCxcbiAgICAgICAgICBjb250ZXh0LnBsdWdpbkhvb2tzLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcmFnU2VsZWN0aW9uIHx8ICFpc0RhdGVTZWxlY3Rpb25WYWxpZChkcmFnU2VsZWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIGNvbnRleHQpKSB7XG4gICAgICAgIGlzSW52YWxpZCA9IHRydWVcbiAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IG51bGxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHJhZ1NlbGVjdGlvbikge1xuICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb246IGRyYWdTZWxlY3Rpb24gfSlcbiAgICB9IGVsc2UgaWYgKCFpc0ZpbmFsKSB7IC8vIG9ubHkgdW5zZWxlY3QgaWYgbW92ZWQgYXdheSB3aGlsZSBkcmFnZ2luZ1xuICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSlcbiAgICB9XG5cbiAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgZW5hYmxlQ3Vyc29yKClcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzYWJsZUN1cnNvcigpXG4gICAgfVxuXG4gICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICB0aGlzLmRyYWdTZWxlY3Rpb24gPSBkcmFnU2VsZWN0aW9uIC8vIG9ubHkgY2xlYXIgaWYgbW92ZWQgYXdheSBmcm9tIGFsbCBoaXRzIHdoaWxlIGRyYWdnaW5nXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlclVwID0gKHBldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmRyYWdTZWxlY3Rpb24pIHtcbiAgICAgIC8vIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHJlbmRlcmVkLCBzbyBqdXN0IG5lZWQgdG8gcmVwb3J0IHNlbGVjdGlvblxuICAgICAgdHJpZ2dlckRhdGVTZWxlY3QodGhpcy5kcmFnU2VsZWN0aW9uLCBwZXYsIHRoaXMuY29tcG9uZW50LmNvbnRleHQpXG5cbiAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQ6IERhdGVDb21wb25lbnQ8YW55Pik6IG51bWJlciB7XG4gIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0XG4gIGxldCBkZWxheSA9IG9wdGlvbnMuc2VsZWN0TG9uZ1ByZXNzRGVsYXlcblxuICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheVxuICB9XG5cbiAgcmV0dXJuIGRlbGF5XG59XG5cbmZ1bmN0aW9uIGpvaW5IaXRzSW50b1NlbGVjdGlvbihoaXQwOiBIaXQsIGhpdDE6IEhpdCwgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogZGF0ZVNlbGVjdGlvbkpvaW5UcmFuc2Zvcm1lcltdKTogRGF0ZVNwYW4ge1xuICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhblxuICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhblxuICBsZXQgbXMgPSBbXG4gICAgZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0LFxuICAgIGRhdGVTcGFuMC5yYW5nZS5lbmQsXG4gICAgZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0LFxuICAgIGRhdGVTcGFuMS5yYW5nZS5lbmQsXG4gIF1cblxuICBtcy5zb3J0KGNvbXBhcmVOdW1iZXJzKVxuXG4gIGxldCBwcm9wcyA9IHt9IGFzIERhdGVTcGFuXG5cbiAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xuICAgIGxldCByZXMgPSB0cmFuc2Zvcm1lcihoaXQwLCBoaXQxKVxuXG4gICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHJlcykge1xuICAgICAgX19hc3NpZ24ocHJvcHMsIHJlcylcbiAgICB9XG4gIH1cblxuICBwcm9wcy5yYW5nZSA9IHsgc3RhcnQ6IG1zWzBdLCBlbmQ6IG1zWzNdIH1cbiAgcHJvcHMuYWxsRGF5ID0gZGF0ZVNwYW4wLmFsbERheVxuXG4gIHJldHVybiBwcm9wc1xufVxuIiwiaW1wb3J0IHtcbiAgRGF0ZUNvbXBvbmVudCwgU2VnLFxuICBQb2ludGVyRHJhZ0V2ZW50LCBIaXQsXG4gIEV2ZW50TXV0YXRpb24sIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsXG4gIHN0YXJ0T2ZEYXksXG4gIGVsZW1lbnRDbG9zZXN0LFxuICBFdmVudFN0b3JlLCBnZXRSZWxldmFudEV2ZW50cywgY3JlYXRlRW1wdHlFdmVudFN0b3JlLFxuICBFdmVudEludGVyYWN0aW9uU3RhdGUsXG4gIGRpZmZEYXRlcywgZW5hYmxlQ3Vyc29yLCBkaXNhYmxlQ3Vyc29yLFxuICBFdmVudFJlbmRlclJhbmdlLCBnZXRFbFNlZyxcbiAgRXZlbnRBcGksXG4gIGV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXIsXG4gIEludGVyYWN0aW9uLCBJbnRlcmFjdGlvblNldHRpbmdzLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXG4gIEV2ZW50RHJvcFRyYW5zZm9ybWVycyxcbiAgQ2FsZW5kYXJDb250ZXh0LFxuICBWaWV3QXBpLFxuICBFdmVudENoYW5nZUFyZyxcbiAgYnVpbGRFdmVudEFwaXMsXG4gIEV2ZW50QWRkQXJnLFxuICBFdmVudFJlbW92ZUFyZyxcbiAgaXNJbnRlcmFjdGlvblZhbGlkLFxuICBnZXRFbFJvb3QsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IEhpdERyYWdnaW5nLCBpc0hpdHNFcXVhbCB9IGZyb20gJy4vSGl0RHJhZ2dpbmcnXG5pbXBvcnQgeyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIH0gZnJvbSAnLi4vZG5kL0ZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcnXG5pbXBvcnQgeyBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0IH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCB0eXBlIEV2ZW50RHJhZ1N0b3BBcmcgPSBFdmVudERyYWdBcmdcbmV4cG9ydCB0eXBlIEV2ZW50RHJhZ1N0YXJ0QXJnID0gRXZlbnREcmFnQXJnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnREcmFnQXJnIHtcbiAgZWw6IEhUTUxFbGVtZW50XG4gIGV2ZW50OiBFdmVudEFwaVxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuZXhwb3J0IGNsYXNzIEV2ZW50RHJhZ2dpbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7IC8vIFRPRE86IHJlbmFtZSB0byBFdmVudFNlbGVjdGluZ0FuZERyYWdnaW5nXG4gIC8vIFRPRE86IHRlc3QgdGhpcyBpbiBJRTExXG4gIC8vIFFVRVNUSU9OOiB3aHkgZG8gd2UgbmVlZCBpdCBvbiB0aGUgcmVzaXphYmxlPz8/XG4gIHN0YXRpYyBTRUxFQ1RPUiA9ICcuZmMtZXZlbnQtZHJhZ2dhYmxlLCAuZmMtZXZlbnQtcmVzaXphYmxlJ1xuXG4gIGRyYWdnaW5nOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nXG4gIGhpdERyYWdnaW5nOiBIaXREcmFnZ2luZ1xuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIHN1YmplY3RFbDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbFxuICBzdWJqZWN0U2VnOiBTZWcgfCBudWxsID0gbnVsbCAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcbiAgaXNEcmFnZ2luZzogYm9vbGVhbiA9IGZhbHNlXG4gIGV2ZW50UmFuZ2U6IEV2ZW50UmVuZGVyUmFuZ2UgfCBudWxsID0gbnVsbFxuICByZWxldmFudEV2ZW50czogRXZlbnRTdG9yZSB8IG51bGwgPSBudWxsIC8vIHRoZSBldmVudHMgYmVpbmcgZHJhZ2dlZFxuICByZWNlaXZpbmdDb250ZXh0OiBDYWxlbmRhckNvbnRleHQgfCBudWxsID0gbnVsbFxuICB2YWxpZE11dGF0aW9uOiBFdmVudE11dGF0aW9uIHwgbnVsbCA9IG51bGxcbiAgbXV0YXRlZFJlbGV2YW50RXZlbnRzOiBFdmVudFN0b3JlIHwgbnVsbCA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihzZXR0aW5nczogSW50ZXJhY3Rpb25TZXR0aW5ncykge1xuICAgIHN1cGVyKHNldHRpbmdzKVxuICAgIGxldCB7IGNvbXBvbmVudCB9ID0gdGhpc1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0XG5cbiAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpXG4gICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1JcbiAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZVxuICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGxcblxuICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKVxuICAgIGhpdERyYWdnaW5nLnVzZVN1YmplY3RDZW50ZXIgPSBzZXR0aW5ncy51c2VFdmVudENlbnRlclxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydClcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSlcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcClcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlckRvd24gPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgb3JpZ1RhcmdldCA9IGV2Lm9yaWdFdmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgICBsZXQgeyBjb21wb25lbnQsIGRyYWdnaW5nIH0gPSB0aGlzXG4gICAgbGV0IHsgbWlycm9yIH0gPSBkcmFnZ2luZ1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0XG4gICAgbGV0IGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHRcbiAgICB0aGlzLnN1YmplY3RFbCA9IGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudFxuICAgIGxldCBzdWJqZWN0U2VnID0gdGhpcy5zdWJqZWN0U2VnID0gZ2V0RWxTZWcoZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50KSFcbiAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHN1YmplY3RTZWcuZXZlbnRSYW5nZSFcbiAgICBsZXQgZXZlbnRJbnN0YW5jZUlkID0gZXZlbnRSYW5nZS5pbnN0YW5jZSEuaW5zdGFuY2VJZFxuXG4gICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzKFxuICAgICAgaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlLFxuICAgICAgZXZlbnRJbnN0YW5jZUlkLFxuICAgIClcblxuICAgIGRyYWdnaW5nLm1pbkRpc3RhbmNlID0gZXYuaXNUb3VjaCA/IDAgOiBvcHRpb25zLmV2ZW50RHJhZ01pbkRpc3RhbmNlXG4gICAgZHJhZ2dpbmcuZGVsYXkgPVxuICAgICAgLy8gb25seSBkbyBhIHRvdWNoIGRlbGF5IGlmIHRvdWNoIGFuZCB0aGlzIGV2ZW50IGhhc24ndCBiZWVuIHNlbGVjdGVkIHlldFxuICAgICAgKGV2LmlzVG91Y2ggJiYgZXZlbnRJbnN0YW5jZUlkICE9PSBjb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pID9cbiAgICAgICAgZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIDpcbiAgICAgICAgbnVsbFxuXG4gICAgaWYgKG9wdGlvbnMuZml4ZWRNaXJyb3JQYXJlbnQpIHtcbiAgICAgIG1pcnJvci5wYXJlbnROb2RlID0gb3B0aW9ucy5maXhlZE1pcnJvclBhcmVudFxuICAgIH0gZWxzZSB7XG4gICAgICBtaXJyb3IucGFyZW50Tm9kZSA9IGVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMnKVxuICAgIH1cblxuICAgIG1pcnJvci5yZXZlcnREdXJhdGlvbiA9IG9wdGlvbnMuZHJhZ1JldmVydER1cmF0aW9uXG5cbiAgICBsZXQgaXNWYWxpZCA9XG4gICAgICBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChvcmlnVGFyZ2V0KSAmJlxuICAgICAgIWVsZW1lbnRDbG9zZXN0KG9yaWdUYXJnZXQsICcuZmMtZXZlbnQtcmVzaXplcicpIC8vIE5PVCBvbiBhIHJlc2l6ZXJcblxuICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWlzVmFsaWQpXG5cbiAgICAvLyBkaXNhYmxlIGRyYWdnaW5nIGZvciBlbGVtZW50cyB0aGF0IGFyZSByZXNpemFibGUgKGllLCBzZWxlY3RhYmxlKVxuICAgIC8vIGJ1dCBhcmUgbm90IGRyYWdnYWJsZVxuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGlzVmFsaWQgJiZcbiAgICAgIChldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtZHJhZ2dhYmxlJylcbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHRcbiAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSFcbiAgICBsZXQgZXZlbnRJbnN0YW5jZUlkID0gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG5cbiAgICBpZiAoZXYuaXNUb3VjaCkge1xuICAgICAgLy8gbmVlZCB0byBzZWxlY3QgYSBkaWZmZXJlbnQgZXZlbnQ/XG4gICAgICBpZiAoZXZlbnRJbnN0YW5jZUlkICE9PSB0aGlzLmNvbXBvbmVudC5wcm9wcy5ldmVudFNlbGVjdGlvbikge1xuICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfRVZFTlQnLCBldmVudEluc3RhbmNlSWQgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm93IHVzaW5nIG1vdXNlLCBidXQgd2FzIHByZXZpb3VzIHRvdWNoIGludGVyYWN0aW9uLCBjbGVhciBzZWxlY3RlZCBldmVudFxuICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpIC8vIHVuc2VsZWN0ICpkYXRlKiBzZWxlY3Rpb25cbiAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RhcnQnLCB7XG4gICAgICAgIGVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQgYXMgTW91c2VFdmVudCwgLy8gSXMgdGhpcyBhbHdheXMgYSBtb3VzZSBldmVudD8gU2VlICM0NjU1XG4gICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXG4gICAgICB9IGFzIEV2ZW50RHJhZ1N0YXJ0QXJnKVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUhpdFVwZGF0ZSA9IChoaXQ6IEhpdCB8IG51bGwsIGlzRmluYWw6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cyFcbiAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdCFcbiAgICBsZXQgaW5pdGlhbENvbnRleHQgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0XG5cbiAgICAvLyBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxuICAgIGxldCByZWNlaXZpbmdDb250ZXh0OiBDYWxlbmRhckNvbnRleHQgfCBudWxsID0gbnVsbFxuICAgIGxldCBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbiB8IG51bGwgPSBudWxsXG4gICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50czogRXZlbnRTdG9yZSB8IG51bGwgPSBudWxsXG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlXG4gICAgbGV0IGludGVyYWN0aW9uOiBFdmVudEludGVyYWN0aW9uU3RhdGUgPSB7XG4gICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgfVxuXG4gICAgaWYgKGhpdCkge1xuICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0XG4gICAgICBsZXQgcmVjZWl2aW5nT3B0aW9ucyA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9uc1xuXG4gICAgICBpZiAoXG4gICAgICAgIGluaXRpYWxDb250ZXh0ID09PSByZWNlaXZpbmdDb250ZXh0IHx8XG4gICAgICAgIChyZWNlaXZpbmdPcHRpb25zLmVkaXRhYmxlICYmIHJlY2VpdmluZ09wdGlvbnMuZHJvcHBhYmxlKVxuICAgICAgKSB7XG4gICAgICAgIG11dGF0aW9uID0gY29tcHV0ZUV2ZW50TXV0YXRpb24oaW5pdGlhbEhpdCwgaGl0LCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkucGx1Z2luSG9va3MuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpXG5cbiAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShcbiAgICAgICAgICAgIHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIG11dGF0aW9uLFxuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCxcbiAgICAgICAgICApXG4gICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50c1xuXG4gICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgIGlzSW52YWxpZCA9IHRydWVcbiAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbFxuICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbFxuICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNlaXZpbmdDb250ZXh0ID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheURyYWcocmVjZWl2aW5nQ29udGV4dCwgaW50ZXJhY3Rpb24pXG5cbiAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgZW5hYmxlQ3Vyc29yKClcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzYWJsZUN1cnNvcigpXG4gICAgfVxuXG4gICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluaXRpYWxDb250ZXh0ID09PSByZWNlaXZpbmdDb250ZXh0ICYmIC8vIFRPRE86IHdyaXRlIHRlc3QgZm9yIHRoaXNcbiAgICAgICAgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgaGl0KVxuICAgICAgKSB7XG4gICAgICAgIG11dGF0aW9uID0gbnVsbFxuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFtdXRhdGlvbilcblxuICAgICAgLy8gcmVuZGVyIHRoZSBtaXJyb3IgaWYgbm8gYWxyZWFkeS1yZW5kZXJlZCBtaXJyb3JcbiAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgICB0aGlzLmRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShcbiAgICAgICAgIWhpdCB8fCAhZ2V0RWxSb290KHRoaXMuc3ViamVjdEVsKS5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJyksIC8vIFRPRE86IHR1cm4gY2xhc3NOYW1lIGludG8gY29uc3RhbnRcbiAgICAgIClcblxuICAgICAgLy8gYXNzaWduIHN0YXRlcyBiYXNlZCBvbiBuZXcgaGl0XG4gICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0XG4gICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvblxuICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQb2ludGVyVXAgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuY2xlYW51cCgpIC8vIGJlY2F1c2UgaGFuZGxlRHJhZ0VuZCB3b24ndCBmaXJlXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRHJhZ0VuZCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgIGxldCBpbml0aWFsQ29udGV4dCA9IHRoaXMuY29tcG9uZW50LmNvbnRleHRcbiAgICAgIGxldCBpbml0aWFsVmlldyA9IGluaXRpYWxDb250ZXh0LnZpZXdBcGlcbiAgICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQsIHZhbGlkTXV0YXRpb24gfSA9IHRoaXNcbiAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZSEuZGVmXG4gICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZSEuaW5zdGFuY2VcbiAgICAgIGxldCBldmVudEFwaSA9IG5ldyBFdmVudEFwaShpbml0aWFsQ29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpXG4gICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzIVxuICAgICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzIVxuICAgICAgbGV0IHsgZmluYWxIaXQgfSA9IHRoaXMuaGl0RHJhZ2dpbmdcblxuICAgICAgdGhpcy5jbGVhckRyYWcoKSAvLyBtdXN0IGhhcHBlbiBhZnRlciByZXZlcnQgYW5pbWF0aW9uXG5cbiAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHtcbiAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50LCAvLyBJcyB0aGlzIGFsd2F5cyBhIG1vdXNlIGV2ZW50PyBTZWUgIzQ2NTVcbiAgICAgICAgdmlldzogaW5pdGlhbFZpZXcsXG4gICAgICB9IGFzIEV2ZW50RHJhZ1N0b3BBcmcpXG5cbiAgICAgIGlmICh2YWxpZE11dGF0aW9uKSB7XG4gICAgICAgIC8vIGRyb3BwZWQgd2l0aGluIHNhbWUgY2FsZW5kYXJcbiAgICAgICAgaWYgKHJlY2VpdmluZ0NvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgbGV0IHVwZGF0ZWRFdmVudEFwaSA9IG5ldyBFdmVudEFwaShcbiAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LFxuICAgICAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLFxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwsXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZzogRXZlbnRDaGFuZ2VBcmcgPSB7XG4gICAgICAgICAgICBvbGRFdmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCBpbml0aWFsQ29udGV4dCwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZGF0YVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgdHJhbnNmb3JtZWQ6IFJldHVyblR5cGU8RXZlbnREcm9wVHJhbnNmb3JtZXJzPiA9IHt9XG4gICAgICAgICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgaW5pdGlhbENvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5wbHVnaW5Ib29rcy5ldmVudERyb3BUcmFuc2Zvcm1lcnMpIHtcbiAgICAgICAgICAgIF9fYXNzaWduKHRyYW5zZm9ybWVkLCB0cmFuc2Zvcm1lcih2YWxpZE11dGF0aW9uLCBpbml0aWFsQ29udGV4dCkpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyb3AnLCB7XG4gICAgICAgICAgICAuLi5ldmVudENoYW5nZUFyZyxcbiAgICAgICAgICAgIC4uLnRyYW5zZm9ybWVkLFxuICAgICAgICAgICAgZWw6IGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCxcbiAgICAgICAgICAgIGRlbHRhOiB2YWxpZE11dGF0aW9uLmRhdGVzRGVsdGEhLFxuICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsIC8vIGJhZFxuICAgICAgICAgICAgdmlldzogaW5pdGlhbFZpZXcsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRDaGFuZ2UnLCBldmVudENoYW5nZUFyZylcblxuICAgICAgICAvLyBkcm9wcGVkIGluIGRpZmZlcmVudCBjYWxlbmRhclxuICAgICAgICB9IGVsc2UgaWYgKHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgICBsZXQgZXZlbnRSZW1vdmVBcmc6IEV2ZW50UmVtb3ZlQXJnID0ge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50TGVhdmUnLCB7XG4gICAgICAgICAgICAuLi5ldmVudFJlbW92ZUFyZyxcbiAgICAgICAgICAgIGRyYWdnZWRFbDogZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgICAgdmlldzogaW5pdGlhbFZpZXcsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywgZXZlbnRSZW1vdmVBcmcpXG5cbiAgICAgICAgICBsZXQgYWRkZWRFdmVudERlZiA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXVxuICAgICAgICAgIGxldCBhZGRlZEV2ZW50SW5zdGFuY2UgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF1cbiAgICAgICAgICBsZXQgYWRkZWRFdmVudEFwaSA9IG5ldyBFdmVudEFwaShyZWNlaXZpbmdDb250ZXh0LCBhZGRlZEV2ZW50RGVmLCBhZGRlZEV2ZW50SW5zdGFuY2UpXG5cbiAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBsZXQgZXZlbnRBZGRBcmc6IEV2ZW50QWRkQXJnID0ge1xuICAgICAgICAgICAgZXZlbnQ6IGFkZGVkRXZlbnRBcGksXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIHJlY2VpdmluZ0NvbnRleHQsIGFkZGVkRXZlbnRJbnN0YW5jZSksXG4gICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudEFkZCcsIGV2ZW50QWRkQXJnKVxuXG4gICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICB0eXBlOiAnU0VMRUNUX0VWRU5UJyxcbiAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUlkOiBldmVudEluc3RhbmNlLmluc3RhbmNlSWQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywge1xuICAgICAgICAgICAgLi4uYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dChmaW5hbEhpdC5kYXRlU3BhbiwgcmVjZWl2aW5nQ29udGV4dCksXG4gICAgICAgICAgICBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCBhcyBIVE1MRWxlbWVudCxcbiAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCBhcyBNb3VzZUV2ZW50LCAvLyBJcyB0aGlzIGFsd2F5cyBhIG1vdXNlIGV2ZW50PyBTZWUgIzQ2NTVcbiAgICAgICAgICAgIHZpZXc6IGZpbmFsSGl0LmNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIHtcbiAgICAgICAgICAgIC4uLmV2ZW50QWRkQXJnLFxuICAgICAgICAgICAgZHJhZ2dlZEVsOiBldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgICAgICB2aWV3OiBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudERyb3AnKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2xlYW51cCgpXG4gIH1cblxuICAvLyByZW5kZXIgYSBkcmFnIHN0YXRlIG9uIHRoZSBuZXh0IHJlY2VpdmluZ0NhbGVuZGFyXG4gIGRpc3BsYXlEcmFnKG5leHRDb250ZXh0OiBDYWxlbmRhckNvbnRleHQgfCBudWxsLCBzdGF0ZTogRXZlbnRJbnRlcmFjdGlvblN0YXRlKSB7XG4gICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dFxuICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dFxuXG4gICAgLy8gZG9lcyB0aGUgcHJldmlvdXMgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIC8vIGRvZXMgdGhlIGluaXRpYWwgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgLy8gaWYgc28sIGRvbid0IGNsZWFyIGFsbCB0aGUgd2F5LiB3ZSBzdGlsbCBuZWVkIHRvIHRvIGhpZGUgdGhlIGFmZmVjdGVkRXZlbnRzXG4gICAgICBpZiAocHJldkNvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLFxuICAgICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogc3RhdGUuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgLy8gY29tcGxldGVseSBjbGVhciB0aGUgb2xkIGNhbGVuZGFyIGlmIGl0IHdhc24ndCB0aGUgaW5pdGlhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1NFVF9FVkVOVF9EUkFHJywgc3RhdGUgfSlcbiAgICB9XG4gIH1cblxuICBjbGVhckRyYWcoKSB7XG4gICAgbGV0IGluaXRpYWxDYWxlbmRhciA9IHRoaXMuY29tcG9uZW50LmNvbnRleHRcbiAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0IH0gPSB0aGlzXG5cbiAgICBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KVxuICAgIH1cblxuICAgIC8vIHRoZSBpbml0aWFsIGNhbGVuZGFyIG1pZ2h0IGhhdmUgYW4gZHVtbXkgZHJhZyBzdGF0ZSBmcm9tIGRpc3BsYXlEcmFnXG4gICAgaWYgKGluaXRpYWxDYWxlbmRhciAhPT0gcmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgaW5pdGlhbENhbGVuZGFyLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pXG4gICAgfVxuICB9XG5cbiAgY2xlYW51cCgpIHsgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbFxuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlXG4gICAgdGhpcy5ldmVudFJhbmdlID0gbnVsbFxuICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsXG4gICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbFxuICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGxcbiAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlRXZlbnRNdXRhdGlvbihoaXQwOiBIaXQsIGhpdDE6IEhpdCwgbWFzc2FnZXJzOiBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyW10pOiBFdmVudE11dGF0aW9uIHtcbiAgbGV0IGRhdGVTcGFuMCA9IGhpdDAuZGF0ZVNwYW5cbiAgbGV0IGRhdGVTcGFuMSA9IGhpdDEuZGF0ZVNwYW5cbiAgbGV0IGRhdGUwID0gZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0XG4gIGxldCBkYXRlMSA9IGRhdGVTcGFuMS5yYW5nZS5zdGFydFxuICBsZXQgc3RhbmRhcmRQcm9wcyA9IHt9IGFzIGFueVxuXG4gIGlmIChkYXRlU3BhbjAuYWxsRGF5ICE9PSBkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjEuYWxsRGF5XG4gICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSBoaXQxLmNvbnRleHQub3B0aW9ucy5hbGxEYXlNYWludGFpbkR1cmF0aW9uXG5cbiAgICBpZiAoZGF0ZVNwYW4xLmFsbERheSkge1xuICAgICAgLy8gbWVhbnMgZGF0ZTEgaXMgYWxyZWFkeSBzdGFydC1vZi1kYXksXG4gICAgICAvLyBidXQgZGF0ZTAgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICBkYXRlMCA9IHN0YXJ0T2ZEYXkoZGF0ZTApXG4gICAgfVxuICB9XG5cbiAgbGV0IGRlbHRhID0gZGlmZkRhdGVzKFxuICAgIGRhdGUwLCBkYXRlMSxcbiAgICBoaXQwLmNvbnRleHQuZGF0ZUVudixcbiAgICBoaXQwLmNvbXBvbmVudElkID09PSBoaXQxLmNvbXBvbmVudElkID9cbiAgICAgIGhpdDAubGFyZ2VVbml0IDpcbiAgICAgIG51bGwsXG4gIClcblxuICBpZiAoZGVsdGEubWlsbGlzZWNvbmRzKSB7IC8vIGhhcyBob3Vycy9taW51dGVzL3NlY29uZHNcbiAgICBzdGFuZGFyZFByb3BzLmFsbERheSA9IGZhbHNlXG4gIH1cblxuICBsZXQgbXV0YXRpb246IEV2ZW50TXV0YXRpb24gPSB7XG4gICAgZGF0ZXNEZWx0YTogZGVsdGEsXG4gICAgc3RhbmRhcmRQcm9wcyxcbiAgfVxuXG4gIGZvciAobGV0IG1hc3NhZ2VyIG9mIG1hc3NhZ2Vycykge1xuICAgIG1hc3NhZ2VyKG11dGF0aW9uLCBoaXQwLCBoaXQxKVxuICB9XG5cbiAgcmV0dXJuIG11dGF0aW9uXG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50OiBEYXRlQ29tcG9uZW50PGFueT4pOiBudW1iZXIgfCBudWxsIHtcbiAgbGV0IHsgb3B0aW9ucyB9ID0gY29tcG9uZW50LmNvbnRleHRcbiAgbGV0IGRlbGF5ID0gb3B0aW9ucy5ldmVudExvbmdQcmVzc0RlbGF5XG5cbiAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICBkZWxheSA9IG9wdGlvbnMubG9uZ1ByZXNzRGVsYXlcbiAgfVxuXG4gIHJldHVybiBkZWxheVxufVxuIiwiaW1wb3J0IHtcbiAgU2VnLCBIaXQsXG4gIEV2ZW50TXV0YXRpb24sIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUsXG4gIGVsZW1lbnRDbG9zZXN0LFxuICBQb2ludGVyRHJhZ0V2ZW50LFxuICBFdmVudFN0b3JlLCBnZXRSZWxldmFudEV2ZW50cywgY3JlYXRlRW1wdHlFdmVudFN0b3JlLFxuICBkaWZmRGF0ZXMsIGVuYWJsZUN1cnNvciwgZGlzYWJsZUN1cnNvcixcbiAgRGF0ZVJhbmdlLFxuICBFdmVudEFwaSxcbiAgRXZlbnRSZW5kZXJSYW5nZSwgZ2V0RWxTZWcsXG4gIGNyZWF0ZUR1cmF0aW9uLFxuICBFdmVudEludGVyYWN0aW9uU3RhdGUsXG4gIEludGVyYWN0aW9uLCBJbnRlcmFjdGlvblNldHRpbmdzLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZSwgVmlld0FwaSwgRHVyYXRpb24sIEV2ZW50Q2hhbmdlQXJnLCBidWlsZEV2ZW50QXBpcywgaXNJbnRlcmFjdGlvblZhbGlkLFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInXG5pbXBvcnQgeyBIaXREcmFnZ2luZywgaXNIaXRzRXF1YWwgfSBmcm9tICcuL0hpdERyYWdnaW5nJ1xuaW1wb3J0IHsgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4uL2RuZC9GZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nJ1xuXG5leHBvcnQgdHlwZSBFdmVudFJlc2l6ZVN0YXJ0QXJnID0gRXZlbnRSZXNpemVTdGFydFN0b3BBcmdcbmV4cG9ydCB0eXBlIEV2ZW50UmVzaXplU3RvcEFyZyA9IEV2ZW50UmVzaXplU3RhcnRTdG9wQXJnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRXZlbnRSZXNpemVTdGFydFN0b3BBcmcge1xuICBlbDogSFRNTEVsZW1lbnRcbiAgZXZlbnQ6IEV2ZW50QXBpXG4gIGpzRXZlbnQ6IE1vdXNlRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV2ZW50UmVzaXplRG9uZUFyZyBleHRlbmRzIEV2ZW50Q2hhbmdlQXJnIHtcbiAgZWw6IEhUTUxFbGVtZW50XG4gIHN0YXJ0RGVsdGE6IER1cmF0aW9uXG4gIGVuZERlbHRhOiBEdXJhdGlvblxuICBqc0V2ZW50OiBNb3VzZUV2ZW50XG4gIHZpZXc6IFZpZXdBcGlcbn1cblxuZXhwb3J0IGNsYXNzIEV2ZW50UmVzaXppbmcgZXh0ZW5kcyBJbnRlcmFjdGlvbiB7XG4gIGRyYWdnaW5nOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nXG4gIGhpdERyYWdnaW5nOiBIaXREcmFnZ2luZ1xuXG4gIC8vIGludGVybmFsIHN0YXRlXG4gIGRyYWdnaW5nU2VnRWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGxcbiAgZHJhZ2dpbmdTZWc6IFNlZyB8IG51bGwgPSBudWxsIC8vIFRPRE86IHJlbmFtZSB0byByZXNpemluZ1NlZz8gc3ViamVjdFNlZz9cbiAgZXZlbnRSYW5nZTogRXZlbnRSZW5kZXJSYW5nZSB8IG51bGwgPSBudWxsXG4gIHJlbGV2YW50RXZlbnRzOiBFdmVudFN0b3JlIHwgbnVsbCA9IG51bGxcbiAgdmFsaWRNdXRhdGlvbjogRXZlbnRNdXRhdGlvbiB8IG51bGwgPSBudWxsXG4gIG11dGF0ZWRSZWxldmFudEV2ZW50czogRXZlbnRTdG9yZSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M6IEludGVyYWN0aW9uU2V0dGluZ3MpIHtcbiAgICBzdXBlcihzZXR0aW5ncylcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHNldHRpbmdzXG5cbiAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpXG4gICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICcuZmMtZXZlbnQtcmVzaXplcidcbiAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZVxuICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBjb21wb25lbnQuY29udGV4dC5vcHRpb25zLmRyYWdTY3JvbGxcblxuICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKVxuICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydClcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSlcbiAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlckRvd24gPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXNcbiAgICBsZXQgc2VnRWwgPSB0aGlzLnF1ZXJ5U2VnRWwoZXYpXG4gICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKVxuICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlID0gc2VnLmV2ZW50UmFuZ2UhXG5cbiAgICB0aGlzLmRyYWdnaW5nLm1pbkRpc3RhbmNlID0gY29tcG9uZW50LmNvbnRleHQub3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZVxuXG4gICAgLy8gaWYgdG91Y2gsIG5lZWQgdG8gYmUgd29ya2luZyB3aXRoIGEgc2VsZWN0ZWQgZXZlbnRcbiAgICB0aGlzLmRyYWdnaW5nLnNldElnbm9yZU1vdmUoXG4gICAgICAhdGhpcy5jb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSB8fFxuICAgICAgKGV2LmlzVG91Y2ggJiYgdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24gIT09IGV2ZW50UmFuZ2UuaW5zdGFuY2UhLmluc3RhbmNlSWQpLFxuICAgIClcbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50XG4gICAgbGV0IGV2ZW50UmFuZ2UgPSB0aGlzLmV2ZW50UmFuZ2UhXG5cbiAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoXG4gICAgICBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTdG9yZSxcbiAgICAgIHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZSEuaW5zdGFuY2VJZCxcbiAgICApXG5cbiAgICBsZXQgc2VnRWwgPSB0aGlzLnF1ZXJ5U2VnRWwoZXYpXG4gICAgdGhpcy5kcmFnZ2luZ1NlZ0VsID0gc2VnRWxcbiAgICB0aGlzLmRyYWdnaW5nU2VnID0gZ2V0RWxTZWcoc2VnRWwpXG5cbiAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KClcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZXNpemVTdGFydCcsIHtcbiAgICAgIGVsOiBzZWdFbCxcbiAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgIH0gYXMgRXZlbnRSZXNpemVTdGFydEFyZylcbiAgfVxuXG4gIGhhbmRsZUhpdFVwZGF0ZSA9IChoaXQ6IEhpdCB8IG51bGwsIGlzRmluYWw6IGJvb2xlYW4sIGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnRcbiAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzIVxuICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0IVxuICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlIVxuICAgIGxldCBtdXRhdGlvbjogRXZlbnRNdXRhdGlvbiB8IG51bGwgPSBudWxsXG4gICAgbGV0IG11dGF0ZWRSZWxldmFudEV2ZW50czogRXZlbnRTdG9yZSB8IG51bGwgPSBudWxsXG4gICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlXG4gICAgbGV0IGludGVyYWN0aW9uOiBFdmVudEludGVyYWN0aW9uU3RhdGUgPSB7XG4gICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgIGlzRXZlbnQ6IHRydWUsXG4gICAgfVxuXG4gICAgaWYgKGhpdCkge1xuICAgICAgbGV0IGRpc2FsbG93ZWQgPSBoaXQuY29tcG9uZW50SWQgPT09IGluaXRpYWxIaXQuY29tcG9uZW50SWRcbiAgICAgICAgJiYgdGhpcy5pc0hpdENvbWJvQWxsb3dlZFxuICAgICAgICAmJiAhdGhpcy5pc0hpdENvbWJvQWxsb3dlZChpbml0aWFsSGl0LCBoaXQpXG5cbiAgICAgIGlmICghZGlzYWxsb3dlZCkge1xuICAgICAgICBtdXRhdGlvbiA9IGNvbXB1dGVNdXRhdGlvbihcbiAgICAgICAgICBpbml0aWFsSGl0LFxuICAgICAgICAgIGhpdCxcbiAgICAgICAgICAoZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50KS5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LXJlc2l6ZXItc3RhcnQnKSxcbiAgICAgICAgICBldmVudEluc3RhbmNlLnJhbmdlLFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dClcbiAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNcblxuICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgY29udGV4dCkpIHtcbiAgICAgICAgaXNJbnZhbGlkID0gdHJ1ZVxuICAgICAgICBtdXRhdGlvbiA9IG51bGxcbiAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbFxuICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcbiAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX1JFU0laRScsXG4gICAgICAgIHN0YXRlOiBpbnRlcmFjdGlvbixcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfUkVTSVpFJyB9KVxuICAgIH1cblxuICAgIGlmICghaXNJbnZhbGlkKSB7XG4gICAgICBlbmFibGVDdXJzb3IoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXNhYmxlQ3Vyc29yKClcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluYWwpIHtcbiAgICAgIGlmIChtdXRhdGlvbiAmJiBpc0hpdHNFcXVhbChpbml0aWFsSGl0LCBoaXQpKSB7XG4gICAgICAgIG11dGF0aW9uID0gbnVsbFxuICAgICAgfVxuXG4gICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvblxuICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHNcbiAgICB9XG4gIH1cblxuICBoYW5kbGVEcmFnRW5kID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnRcbiAgICBsZXQgZXZlbnREZWYgPSB0aGlzLmV2ZW50UmFuZ2UhLmRlZlxuICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlIS5pbnN0YW5jZVxuICAgIGxldCBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSlcbiAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzIVxuICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyFcblxuICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XG4gICAgICBlbDogdGhpcy5kcmFnZ2luZ1NlZ0VsLFxuICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgIH0gYXMgRXZlbnRSZXNpemVTdG9wQXJnKVxuXG4gICAgaWYgKHRoaXMudmFsaWRNdXRhdGlvbikge1xuICAgICAgbGV0IHVwZGF0ZWRFdmVudEFwaSA9IG5ldyBFdmVudEFwaShcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdLFxuICAgICAgICBldmVudEluc3RhbmNlID8gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmluc3RhbmNlc1tldmVudEluc3RhbmNlLmluc3RhbmNlSWRdIDogbnVsbCxcbiAgICAgIClcblxuICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICB9KVxuXG4gICAgICBsZXQgZXZlbnRDaGFuZ2VBcmc6IEV2ZW50Q2hhbmdlQXJnID0ge1xuICAgICAgICBvbGRFdmVudDogZXZlbnRBcGksXG4gICAgICAgIGV2ZW50OiB1cGRhdGVkRXZlbnRBcGksXG4gICAgICAgIHJlbGF0ZWRFdmVudHM6IGJ1aWxkRXZlbnRBcGlzKG11dGF0ZWRSZWxldmFudEV2ZW50cywgY29udGV4dCwgZXZlbnRJbnN0YW5jZSksXG4gICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsIC8vIHRoZSBwcmUtY2hhbmdlIGV2ZW50c1xuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZScsIHtcbiAgICAgICAgLi4uZXZlbnRDaGFuZ2VBcmcsXG4gICAgICAgIGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsXG4gICAgICAgIHN0YXJ0RGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLFxuICAgICAgICBlbmREZWx0YTogdGhpcy52YWxpZE11dGF0aW9uLmVuZERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLFxuICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQgYXMgTW91c2VFdmVudCxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgfSlcblxuICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywgZXZlbnRDaGFuZ2VBcmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdfbm9FdmVudFJlc2l6ZScpXG4gICAgfVxuXG4gICAgLy8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlXG4gICAgdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGxcbiAgICB0aGlzLnJlbGV2YW50RXZlbnRzID0gbnVsbFxuICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGxcblxuICAgIC8vIG9rYXkgdG8ga2VlcCBldmVudEluc3RhbmNlIGFyb3VuZC4gdXNlZnVsIHRvIHNldCBpdCBpbiBoYW5kbGVQb2ludGVyRG93blxuICB9XG5cbiAgcXVlcnlTZWdFbChldjogUG9pbnRlckRyYWdFdmVudCkge1xuICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQsICcuZmMtZXZlbnQnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNdXRhdGlvbihcbiAgaGl0MDogSGl0LFxuICBoaXQxOiBIaXQsXG4gIGlzRnJvbVN0YXJ0OiBib29sZWFuLFxuICBpbnN0YW5jZVJhbmdlOiBEYXRlUmFuZ2UsXG4pOiBFdmVudE11dGF0aW9uIHwgbnVsbCB7XG4gIGxldCBkYXRlRW52ID0gaGl0MC5jb250ZXh0LmRhdGVFbnZcbiAgbGV0IGRhdGUwID0gaGl0MC5kYXRlU3Bhbi5yYW5nZS5zdGFydFxuICBsZXQgZGF0ZTEgPSBoaXQxLmRhdGVTcGFuLnJhbmdlLnN0YXJ0XG5cbiAgbGV0IGRlbHRhID0gZGlmZkRhdGVzKFxuICAgIGRhdGUwLCBkYXRlMSxcbiAgICBkYXRlRW52LFxuICAgIGhpdDAubGFyZ2VVbml0LFxuICApXG5cbiAgaWYgKGlzRnJvbVN0YXJ0KSB7XG4gICAgaWYgKGRhdGVFbnYuYWRkKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIGRlbHRhKSA8IGluc3RhbmNlUmFuZ2UuZW5kKSB7XG4gICAgICByZXR1cm4geyBzdGFydERlbHRhOiBkZWx0YSB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGVFbnYuYWRkKGluc3RhbmNlUmFuZ2UuZW5kLCBkZWx0YSkgPiBpbnN0YW5jZVJhbmdlLnN0YXJ0KSB7XG4gICAgcmV0dXJuIHsgZW5kRGVsdGE6IGRlbHRhIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG4iLCJpbXBvcnQge1xuICBEYXRlU2VsZWN0aW9uQXBpLFxuICBQb2ludGVyRHJhZ0V2ZW50LFxuICBlbGVtZW50Q2xvc2VzdCxcbiAgQ2FsZW5kYXJDb250ZXh0LFxuICBnZXRFdmVudFRhcmdldFZpYVJvb3QsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgUG9pbnRlckRyYWdnaW5nIH0gZnJvbSAnLi4vZG5kL1BvaW50ZXJEcmFnZ2luZydcbmltcG9ydCB7IEV2ZW50RHJhZ2dpbmcgfSBmcm9tICcuL0V2ZW50RHJhZ2dpbmcnXG5cbmV4cG9ydCBjbGFzcyBVbnNlbGVjdEF1dG8ge1xuICBkb2N1bWVudFBvaW50ZXI6IFBvaW50ZXJEcmFnZ2luZyAvLyBmb3IgdW5mb2N1c2luZ1xuICBpc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0ID0gZmFsc2UgLy8gd2lzaCB3ZSBjb3VsZCB1c2UgYSBzZWxlY3RvciB0byBkZXRlY3QgZGF0ZSBzZWxlY3Rpb24sIGJ1dCB1c2VzIGhpdCBzeXN0ZW1cbiAgbWF0Y2hlc0NhbmNlbCA9IGZhbHNlXG4gIG1hdGNoZXNFdmVudCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpIHtcbiAgICBsZXQgZG9jdW1lbnRQb2ludGVyID0gdGhpcy5kb2N1bWVudFBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGRvY3VtZW50KVxuICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gdHJ1ZVxuICAgIGRvY3VtZW50UG9pbnRlci5zaG91bGRXYXRjaFNjcm9sbCA9IGZhbHNlXG4gICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24pXG4gICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Eb2N1bWVudFBvaW50ZXJVcClcblxuICAgIC8qXG4gICAgVE9ETzogYmV0dGVyIHdheSB0byBrbm93IGFib3V0IHdoZXRoZXIgdGhlcmUgd2FzIGEgc2VsZWN0aW9uIHdpdGggdGhlIHBvaW50ZXJcbiAgICAqL1xuICAgIGNvbnRleHQuZW1pdHRlci5vbignc2VsZWN0JywgdGhpcy5vblNlbGVjdClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIub2ZmKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KVxuICAgIHRoaXMuZG9jdW1lbnRQb2ludGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgb25TZWxlY3QgPSAoc2VsZWN0SW5mbzogRGF0ZVNlbGVjdGlvbkFwaSkgPT4ge1xuICAgIGlmIChzZWxlY3RJbmZvLmpzRXZlbnQpIHtcbiAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBvbkRvY3VtZW50UG9pbnRlckRvd24gPSAocGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHVuc2VsZWN0Q2FuY2VsID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RDYW5jZWxcbiAgICBsZXQgZG93bkVsID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KHBldi5vcmlnRXZlbnQpIGFzIEhUTUxFbGVtZW50XG5cbiAgICB0aGlzLm1hdGNoZXNDYW5jZWwgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdW5zZWxlY3RDYW5jZWwpXG4gICAgdGhpcy5tYXRjaGVzRXZlbnQgPSAhIWVsZW1lbnRDbG9zZXN0KGRvd25FbCwgRXZlbnREcmFnZ2luZy5TRUxFQ1RPUikgLy8gaW50ZXJhY3Rpb24gc3RhcnRlZCBvbiBhbiBldmVudD9cbiAgfVxuXG4gIG9uRG9jdW1lbnRQb2ludGVyVXAgPSAocGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgY29udGV4dCB9ID0gdGhpc1xuICAgIGxldCB7IGRvY3VtZW50UG9pbnRlciB9ID0gdGhpc1xuICAgIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpXG5cbiAgICAvLyB0b3VjaC1zY3JvbGxpbmcgc2hvdWxkIG5ldmVyIHVuZm9jdXMgYW55IHR5cGUgb2Ygc2VsZWN0aW9uXG4gICAgaWYgKCFkb2N1bWVudFBvaW50ZXIud2FzVG91Y2hTY3JvbGwpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY2FsZW5kYXJTdGF0ZS5kYXRlU2VsZWN0aW9uICYmIC8vIGFuIGV4aXN0aW5nIGRhdGUgc2VsZWN0aW9uP1xuICAgICAgICAhdGhpcy5pc1JlY2VudFBvaW50ZXJEYXRlU2VsZWN0IC8vIGEgbmV3IHBvaW50ZXItaW5pdGlhdGVkIGRhdGUgc2VsZWN0aW9uIHNpbmNlIGxhc3Qgb25Eb2N1bWVudFBvaW50ZXJVcD9cbiAgICAgICkge1xuICAgICAgICBsZXQgdW5zZWxlY3RBdXRvID0gY29udGV4dC5vcHRpb25zLnVuc2VsZWN0QXV0b1xuXG4gICAgICAgIGlmICh1bnNlbGVjdEF1dG8gJiYgKCF1bnNlbGVjdEF1dG8gfHwgIXRoaXMubWF0Y2hlc0NhbmNlbCkpIHtcbiAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KHBldilcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGNhbGVuZGFyU3RhdGUuZXZlbnRTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZXZlbnQgc2VsZWN0ZWQ/XG4gICAgICAgICF0aGlzLm1hdGNoZXNFdmVudCAvLyBpbnRlcmFjdGlvbiBESUROJ1Qgc3RhcnQgb24gYW4gZXZlbnRcbiAgICAgICkge1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0VWRU5UJyB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlXG4gIH1cbn1cbiIsImltcG9ydCB7IGlkZW50aXR5LCBJZGVudGl0eSwgRXZlbnREcm9wQXJnIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbi8vIHB1YmxpY1xuaW1wb3J0IHtcbiAgRGF0ZUNsaWNrQXJnLFxuICBFdmVudERyYWdTdGFydEFyZywgRXZlbnREcmFnU3RvcEFyZyxcbiAgRXZlbnRSZXNpemVTdGFydEFyZywgRXZlbnRSZXNpemVTdG9wQXJnLCBFdmVudFJlc2l6ZURvbmVBcmcsXG4gIERyb3BBcmcsIEV2ZW50UmVjZWl2ZUFyZywgRXZlbnRMZWF2ZUFyZyxcbn0gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgY29uc3QgT1BUSU9OX1JFRklORVJTID0ge1xuICBmaXhlZE1pcnJvclBhcmVudDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8SFRNTEVsZW1lbnQ+LFxufVxuXG5leHBvcnQgY29uc3QgTElTVEVORVJfUkVGSU5FUlMgPSB7XG4gIGRhdGVDbGljazogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRGF0ZUNsaWNrQXJnKSA9PiB2b2lkPixcbiAgZXZlbnREcmFnU3RhcnQ6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50RHJhZ1N0YXJ0QXJnKSA9PiB2b2lkPixcbiAgZXZlbnREcmFnU3RvcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnREcmFnU3RvcEFyZykgPT4gdm9pZD4sXG4gIGV2ZW50RHJvcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnREcm9wQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRSZXNpemVTdGFydDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRSZXNpemVTdGFydEFyZykgPT4gdm9pZD4sXG4gIGV2ZW50UmVzaXplU3RvcDogaWRlbnRpdHkgYXMgSWRlbnRpdHk8KGFyZzogRXZlbnRSZXNpemVTdG9wQXJnKSA9PiB2b2lkPixcbiAgZXZlbnRSZXNpemU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50UmVzaXplRG9uZUFyZykgPT4gdm9pZD4sXG4gIGRyb3A6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IERyb3BBcmcpID0+IHZvaWQ+LFxuICBldmVudFJlY2VpdmU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50UmVjZWl2ZUFyZykgPT4gdm9pZD4sXG4gIGV2ZW50TGVhdmU6IGlkZW50aXR5IGFzIElkZW50aXR5PChhcmc6IEV2ZW50TGVhdmVBcmcpID0+IHZvaWQ+LFxufVxuIiwiaW1wb3J0IHtcbiAgSGl0LFxuICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsXG4gIFBvaW50ZXJEcmFnRXZlbnQsXG4gIHBhcnNlRXZlbnREZWYsIGNyZWF0ZUV2ZW50SW5zdGFuY2UsIEV2ZW50VHVwbGUsXG4gIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSwgZXZlbnRUdXBsZVRvU3RvcmUsXG4gIGNvbmZpZyxcbiAgRGF0ZVNwYW4sIERhdGVQb2ludEFwaSxcbiAgRXZlbnRJbnRlcmFjdGlvblN0YXRlLFxuICBEcmFnTWV0YUlucHV0LCBEcmFnTWV0YSwgcGFyc2VEcmFnTWV0YSxcbiAgRXZlbnRBcGksXG4gIGVsZW1lbnRNYXRjaGVzLFxuICBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsXG4gIGlzSW50ZXJhY3Rpb25WYWxpZCxcbiAgRWxlbWVudERyYWdnaW5nLFxuICBWaWV3QXBpLFxuICBDYWxlbmRhckNvbnRleHQsXG4gIGdldERlZmF1bHRFdmVudEVuZCxcbiAgcmVmaW5lRXZlbnREZWYsXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYidcbmltcG9ydCB7IEhpdERyYWdnaW5nIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25zL0hpdERyYWdnaW5nJ1xuaW1wb3J0IHsgYnVpbGREYXRlUG9pbnRBcGlXaXRoQ29udGV4dCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgdHlwZSBEcmFnTWV0YUdlbmVyYXRvciA9IERyYWdNZXRhSW5wdXQgfCAoKGVsOiBIVE1MRWxlbWVudCkgPT4gRHJhZ01ldGFJbnB1dClcblxuZXhwb3J0IGludGVyZmFjZSBFeHRlcm5hbERyb3BBcGkgZXh0ZW5kcyBEYXRlUG9pbnRBcGkge1xuICBkcmFnZ2VkRWw6IEhUTUxFbGVtZW50XG4gIGpzRXZlbnQ6IFVJRXZlbnRcbiAgdmlldzogVmlld0FwaVxufVxuXG4vKlxuR2l2ZW4gYW4gYWxyZWFkeSBpbnN0YW50aWF0ZWQgZHJhZ2dhYmxlIG9iamVjdCBmb3Igb25lLW9yLW1vcmUgZWxlbWVudHMsXG5JbnRlcnByZXRzIGFueSBkcmFnZ2luZyBhcyBhbiBhdHRlbXB0IHRvIGRyYWcgYW4gZXZlbnRzIHRoYXQgbGl2ZXMgb3V0c2lkZVxub2YgYSBjYWxlbmRhciBvbnRvIGEgY2FsZW5kYXIuXG4qL1xuZXhwb3J0IGNsYXNzIEV4dGVybmFsRWxlbWVudERyYWdnaW5nIHtcbiAgaGl0RHJhZ2dpbmc6IEhpdERyYWdnaW5nXG4gIHJlY2VpdmluZ0NvbnRleHQ6IENhbGVuZGFyQ29udGV4dCB8IG51bGwgPSBudWxsXG4gIGRyb3BwYWJsZUV2ZW50OiBFdmVudFR1cGxlIHwgbnVsbCA9IG51bGwgLy8gd2lsbCBleGlzdCBmb3IgYWxsIGRyYWdzLCBldmVuIGlmIGNyZWF0ZTpmYWxzZVxuICBzdXBwbGllZERyYWdNZXRhOiBEcmFnTWV0YUdlbmVyYXRvciB8IG51bGwgPSBudWxsXG4gIGRyYWdNZXRhOiBEcmFnTWV0YSB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoZHJhZ2dpbmc6IEVsZW1lbnREcmFnZ2luZywgc3VwcGxpZWREcmFnTWV0YT86IERyYWdNZXRhR2VuZXJhdG9yKSB7XG4gICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyhkcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKVxuICAgIGhpdERyYWdnaW5nLnJlcXVpcmVJbml0aWFsID0gZmFsc2UgLy8gd2lsbCBzdGFydCBvdXRzaWRlIG9mIGEgY29tcG9uZW50XG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignaGl0dXBkYXRlJywgdGhpcy5oYW5kbGVIaXRVcGRhdGUpXG4gICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZClcblxuICAgIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9IHN1cHBsaWVkRHJhZ01ldGFcbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMuZHJhZ01ldGEgPSB0aGlzLmJ1aWxkRHJhZ01ldGEoZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50KVxuICB9XG5cbiAgYnVpbGREcmFnTWV0YShzdWJqZWN0RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5zdXBwbGllZERyYWdNZXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcGFyc2VEcmFnTWV0YSh0aGlzLnN1cHBsaWVkRHJhZ01ldGEoc3ViamVjdEVsKSlcbiAgICB9XG4gICAgcmV0dXJuIGdldERyYWdNZXRhRnJvbUVsKHN1YmplY3RFbClcbiAgfVxuXG4gIGhhbmRsZUhpdFVwZGF0ZSA9IChoaXQ6IEhpdCB8IG51bGwsIGlzRmluYWw6IGJvb2xlYW4sIGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXMuaGl0RHJhZ2dpbmdcbiAgICBsZXQgcmVjZWl2aW5nQ29udGV4dDogQ2FsZW5kYXJDb250ZXh0IHwgbnVsbCA9IG51bGxcbiAgICBsZXQgZHJvcHBhYmxlRXZlbnQ6IEV2ZW50VHVwbGUgfCBudWxsID0gbnVsbFxuICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZVxuICAgIGxldCBpbnRlcmFjdGlvbjogRXZlbnRJbnRlcmFjdGlvblN0YXRlID0ge1xuICAgICAgYWZmZWN0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICBpc0V2ZW50OiB0aGlzLmRyYWdNZXRhIS5jcmVhdGUsXG4gICAgfVxuXG4gICAgaWYgKGhpdCkge1xuICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0XG5cbiAgICAgIGlmICh0aGlzLmNhbkRyb3BFbE9uQ2FsZW5kYXIoZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50LCByZWNlaXZpbmdDb250ZXh0KSkge1xuICAgICAgICBkcm9wcGFibGVFdmVudCA9IGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKFxuICAgICAgICAgIGhpdC5kYXRlU3BhbixcbiAgICAgICAgICB0aGlzLmRyYWdNZXRhISxcbiAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LFxuICAgICAgICApXG5cbiAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KVxuICAgICAgICBpc0ludmFsaWQgPSAhaXNJbnRlcmFjdGlvblZhbGlkKGludGVyYWN0aW9uLCBoaXQuZGF0ZVByb2ZpbGUsIHJlY2VpdmluZ0NvbnRleHQpXG5cbiAgICAgICAgaWYgKGlzSW52YWxpZCkge1xuICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKVxuICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbilcblxuICAgIC8vIHNob3cgbWlycm9yIGlmIG5vIGFscmVhZHktcmVuZGVyZWQgbWlycm9yIGVsZW1lbnQgT1IgaWYgd2UgYXJlIHNodXR0aW5nIGRvd24gdGhlIG1pcnJvciAoPylcbiAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxuICAgIGRyYWdnaW5nLnNldE1pcnJvcklzVmlzaWJsZShcbiAgICAgIGlzRmluYWwgfHwgIWRyb3BwYWJsZUV2ZW50IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJyksIC8vIFRPRE86IHR1cm4gY2xhc3NOYW1lIGludG8gY29uc3RhbnRcbiAgICAgIC8vIFRPRE86IHNvbWVob3cgcXVlcnkgRnVsbENhbGVuZGFycyBXSVRISU4gc2hhZG93LXJvb3RzIGZvciBleGlzdGluZyBldmVudC1taXJyb3IgZWxzXG4gICAgKVxuXG4gICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgIGVuYWJsZUN1cnNvcigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2FibGVDdXJzb3IoKVxuICAgIH1cblxuICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIWRyb3BwYWJsZUV2ZW50KVxuXG4gICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSByZWNlaXZpbmdDb250ZXh0XG4gICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gZHJvcHBhYmxlRXZlbnRcbiAgICB9XG4gIH1cblxuICBoYW5kbGVEcmFnRW5kID0gKHBldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50IH0gPSB0aGlzXG5cbiAgICB0aGlzLmNsZWFyRHJhZygpXG5cbiAgICBpZiAocmVjZWl2aW5nQ29udGV4dCAmJiBkcm9wcGFibGVFdmVudCkge1xuICAgICAgbGV0IGZpbmFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5maW5hbEhpdCFcbiAgICAgIGxldCBmaW5hbFZpZXcgPSBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGlcbiAgICAgIGxldCBkcmFnTWV0YSA9IHRoaXMuZHJhZ01ldGEhXG5cbiAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkcm9wJywge1xuICAgICAgICAuLi5idWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGZpbmFsSGl0LmRhdGVTcGFuLCByZWNlaXZpbmdDb250ZXh0KSxcbiAgICAgICAgZHJhZ2dlZEVsOiBwZXYuc3ViamVjdEVsIGFzIEhUTUxFbGVtZW50LFxuICAgICAgICBqc0V2ZW50OiBwZXYub3JpZ0V2ZW50IGFzIE1vdXNlRXZlbnQsIC8vIElzIHRoaXMgYWx3YXlzIGEgbW91c2UgZXZlbnQ/IFNlZSAjNDY1NVxuICAgICAgICB2aWV3OiBmaW5hbFZpZXcsXG4gICAgICB9KVxuXG4gICAgICBpZiAoZHJhZ01ldGEuY3JlYXRlKSB7XG4gICAgICAgIGxldCBhZGRpbmdFdmVudHMgPSBldmVudFR1cGxlVG9TdG9yZShkcm9wcGFibGVFdmVudClcblxuICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICBldmVudFN0b3JlOiBhZGRpbmdFdmVudHMsXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHBldi5pc1RvdWNoKSB7XG4gICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnU0VMRUNUX0VWRU5UJyxcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UuaW5zdGFuY2VJZCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2lnbmFsIHRoYXQgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXG4gICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XG4gICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQsXG4gICAgICAgICAgICBkcm9wcGFibGVFdmVudC5kZWYsXG4gICAgICAgICAgICBkcm9wcGFibGVFdmVudC5pbnN0YW5jZSxcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgIHJlY2VpdmluZ0NvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFkZGluZ0V2ZW50cyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgICAgdmlldzogZmluYWxWaWV3LFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGxcbiAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gbnVsbFxuICB9XG5cbiAgZGlzcGxheURyYWcobmV4dENvbnRleHQ6IENhbGVuZGFyQ29udGV4dCB8IG51bGwsIHN0YXRlOiBFdmVudEludGVyYWN0aW9uU3RhdGUpIHtcbiAgICBsZXQgcHJldkNvbnRleHQgPSB0aGlzLnJlY2VpdmluZ0NvbnRleHRcblxuICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pXG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZXh0KSB7XG4gICAgICBuZXh0Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdTRVRfRVZFTlRfRFJBRycsIHN0YXRlIH0pXG4gICAgfVxuICB9XG5cbiAgY2xlYXJEcmFnKCkge1xuICAgIGlmICh0aGlzLnJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KVxuICAgIH1cbiAgfVxuXG4gIGNhbkRyb3BFbE9uQ2FsZW5kYXIoZWw6IEhUTUxFbGVtZW50LCByZWNlaXZpbmdDb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBib29sZWFuIHtcbiAgICBsZXQgZHJvcEFjY2VwdCA9IHJlY2VpdmluZ0NvbnRleHQub3B0aW9ucy5kcm9wQWNjZXB0XG5cbiAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkcm9wQWNjZXB0LmNhbGwocmVjZWl2aW5nQ29udGV4dC5jYWxlbmRhckFwaSwgZWwpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnc3RyaW5nJyAmJiBkcm9wQWNjZXB0KSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihlbGVtZW50TWF0Y2hlcyhlbCwgZHJvcEFjY2VwdCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vLyBVdGlscyBmb3IgY29tcHV0aW5nIGV2ZW50IHN0b3JlIGZyb20gdGhlIERyYWdNZXRhXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudEZvckRhdGVTcGFuKGRhdGVTcGFuOiBEYXRlU3BhbiwgZHJhZ01ldGE6IERyYWdNZXRhLCBjb250ZXh0OiBDYWxlbmRhckNvbnRleHQpOiBFdmVudFR1cGxlIHtcbiAgbGV0IGRlZlByb3BzID0geyAuLi5kcmFnTWV0YS5sZWZ0b3ZlclByb3BzIH1cblxuICBmb3IgKGxldCB0cmFuc2Zvcm0gb2YgY29udGV4dC5wbHVnaW5Ib29rcy5leHRlcm5hbERlZlRyYW5zZm9ybXMpIHtcbiAgICBfX2Fzc2lnbihkZWZQcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBkcmFnTWV0YSkpXG4gIH1cblxuICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lRXZlbnREZWYoZGVmUHJvcHMsIGNvbnRleHQpXG4gIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKFxuICAgIHJlZmluZWQsXG4gICAgZXh0cmEsXG4gICAgZHJhZ01ldGEuc291cmNlSWQsXG4gICAgZGF0ZVNwYW4uYWxsRGF5LFxuICAgIGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgQm9vbGVhbihkcmFnTWV0YS5kdXJhdGlvbiksIC8vIGhhc0VuZFxuICAgIGNvbnRleHQsXG4gIClcblxuICBsZXQgc3RhcnQgPSBkYXRlU3Bhbi5yYW5nZS5zdGFydFxuXG4gIC8vIG9ubHkgcmVseSBvbiB0aW1lIGluZm8gaWYgZHJvcCB6b25lIGlzIGFsbC1kYXksXG4gIC8vIG90aGVyd2lzZSwgd2UgYWxyZWFkeSBrbm93IHRoZSB0aW1lXG4gIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XG4gICAgc3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKHN0YXJ0LCBkcmFnTWV0YS5zdGFydFRpbWUpXG4gIH1cblxuICBsZXQgZW5kID0gZHJhZ01ldGEuZHVyYXRpb24gP1xuICAgIGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnQsIGRyYWdNZXRhLmR1cmF0aW9uKSA6XG4gICAgZ2V0RGVmYXVsdEV2ZW50RW5kKGRhdGVTcGFuLmFsbERheSwgc3RhcnQsIGNvbnRleHQpXG5cbiAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHsgc3RhcnQsIGVuZCB9KVxuXG4gIHJldHVybiB7IGRlZiwgaW5zdGFuY2UgfVxufVxuXG4vLyBVdGlscyBmb3IgZXh0cmFjdGluZyBkYXRhIGZyb20gZWxlbWVudFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBnZXREcmFnTWV0YUZyb21FbChlbDogSFRNTEVsZW1lbnQpOiBEcmFnTWV0YSB7XG4gIGxldCBzdHIgPSBnZXRFbWJlZGRlZEVsRGF0YShlbCwgJ2V2ZW50JylcbiAgbGV0IG9iaiA9IHN0ciA/XG4gICAgSlNPTi5wYXJzZShzdHIpIDpcbiAgICB7IGNyZWF0ZTogZmFsc2UgfSAvLyBpZiBubyBlbWJlZGRlZCBkYXRhLCBhc3N1bWUgbm8gZXZlbnQgY3JlYXRpb25cblxuICByZXR1cm4gcGFyc2VEcmFnTWV0YShvYmopXG59XG5cbmNvbmZpZy5kYXRhQXR0clByZWZpeCA9ICcnXG5cbmZ1bmN0aW9uIGdldEVtYmVkZGVkRWxEYXRhKGVsOiBIVE1MRWxlbWVudCwgbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHByZWZpeCA9IGNvbmZpZy5kYXRhQXR0clByZWZpeFxuICBsZXQgcHJlZml4ZWROYW1lID0gKHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnKSArIG5hbWVcblxuICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBwcmVmaXhlZE5hbWUpIHx8ICcnXG59XG4iLCJpbXBvcnQgeyBCQVNFX09QVElPTl9ERUZBVUxUUywgUG9pbnRlckRyYWdFdmVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4uL2RuZC9GZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nJ1xuaW1wb3J0IHsgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcsIERyYWdNZXRhR2VuZXJhdG9yIH0gZnJvbSAnLi9FeHRlcm5hbEVsZW1lbnREcmFnZ2luZydcblxuZXhwb3J0IGludGVyZmFjZSBFeHRlcm5hbERyYWdnYWJsZVNldHRpbmdzIHtcbiAgZXZlbnREYXRhPzogRHJhZ01ldGFHZW5lcmF0b3JcbiAgaXRlbVNlbGVjdG9yPzogc3RyaW5nXG4gIG1pbkRpc3RhbmNlPzogbnVtYmVyXG4gIGxvbmdQcmVzc0RlbGF5PzogbnVtYmVyXG4gIGFwcGVuZFRvPzogSFRNTEVsZW1lbnRcbn1cblxuLypcbk1ha2VzIGFuIGVsZW1lbnQgKHRoYXQgaXMgKmV4dGVybmFsKiB0byBhbnkgY2FsZW5kYXIpIGRyYWdnYWJsZS5cbkNhbiBwYXNzIGluIGRhdGEgdGhhdCBkZXRlcm1pbmVzIGhvdyBhbiBldmVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBkcm9wcGVkIG9udG8gYSBjYWxlbmRhci5cbkxldmVyYWdlcyBGdWxsQ2FsZW5kYXIncyBpbnRlcm5hbCBkcmFnLW4tZHJvcCBmdW5jdGlvbmFsaXR5IFdJVEhPVVQgYSB0aGlyZC1wYXJ0eSBkcmFnIHN5c3RlbS5cbiovXG5leHBvcnQgY2xhc3MgRXh0ZXJuYWxEcmFnZ2FibGUge1xuICBkcmFnZ2luZzogRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZ1xuICBzZXR0aW5nczogRXh0ZXJuYWxEcmFnZ2FibGVTZXR0aW5nc1xuXG4gIGNvbnN0cnVjdG9yKGVsOiBIVE1MRWxlbWVudCwgc2V0dGluZ3M6IEV4dGVybmFsRHJhZ2dhYmxlU2V0dGluZ3MgPSB7fSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5nc1xuXG4gICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGVsKVxuICAgIGRyYWdnaW5nLnRvdWNoU2Nyb2xsQWxsb3dlZCA9IGZhbHNlXG5cbiAgICBpZiAoc2V0dGluZ3MuaXRlbVNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSBzZXR0aW5ncy5pdGVtU2VsZWN0b3JcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuYXBwZW5kVG8gIT0gbnVsbCkge1xuICAgICAgZHJhZ2dpbmcubWlycm9yLnBhcmVudE5vZGUgPSBzZXR0aW5ncy5hcHBlbmRUbyAvLyBUT0RPOiB3cml0ZSB0ZXN0c1xuICAgIH1cblxuICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bilcbiAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydClcblxuICAgIG5ldyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc2V0dGluZ3MuZXZlbnREYXRhKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9XG5cbiAgaGFuZGxlUG9pbnRlckRvd24gPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpc1xuICAgIGxldCB7IG1pbkRpc3RhbmNlLCBsb25nUHJlc3NEZWxheSB9ID0gdGhpcy5zZXR0aW5nc1xuXG4gICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPVxuICAgICAgbWluRGlzdGFuY2UgIT0gbnVsbCA/XG4gICAgICAgIG1pbkRpc3RhbmNlIDpcbiAgICAgICAgKGV2LmlzVG91Y2ggPyAwIDogQkFTRV9PUFRJT05fREVGQVVMVFMuZXZlbnREcmFnTWluRGlzdGFuY2UpXG5cbiAgICBkcmFnZ2luZy5kZWxheSA9XG4gICAgICBldi5pc1RvdWNoID8gLy8gVE9ETzogZXZlbnR1YWxseSByZWFkIGV2ZW50TG9uZ1ByZXNzRGVsYXkgaW5zdGVhZCB2dnZcbiAgICAgICAgKGxvbmdQcmVzc0RlbGF5ICE9IG51bGwgPyBsb25nUHJlc3NEZWxheSA6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmxvbmdQcmVzc0RlbGF5KSA6XG4gICAgICAgIDBcbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIGlmIChcbiAgICAgIGV2LmlzVG91Y2ggJiZcbiAgICAgIHRoaXMuZHJhZ2dpbmcuZGVsYXkgJiZcbiAgICAgIChldi5zdWJqZWN0RWwgYXMgSFRNTEVsZW1lbnQpLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQnKVxuICAgICkge1xuICAgICAgdGhpcy5kcmFnZ2luZy5taXJyb3IuZ2V0TWlycm9yRWwoKS5jbGFzc0xpc3QuYWRkKCdmYy1ldmVudC1zZWxlY3RlZCcpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdnaW5nLmRlc3Ryb3koKVxuICB9XG59XG4iLCJpbXBvcnQgeyBQb2ludGVyRHJhZ0V2ZW50LCBFbGVtZW50RHJhZ2dpbmcgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcbmltcG9ydCB7IFBvaW50ZXJEcmFnZ2luZyB9IGZyb20gJy4uL2RuZC9Qb2ludGVyRHJhZ2dpbmcnXG5cbi8qXG5EZXRlY3RzIHdoZW4gYSAqVEhJUkQtUEFSVFkqIGRyYWctbi1kcm9wIHN5c3RlbSBpbnRlcmFjdHMgd2l0aCBlbGVtZW50cy5cblRoZSB0aGlyZC1wYXJ0eSBzeXN0ZW0gaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmcgdGhlIHZpc3VhbHMgZWZmZWN0cyBvZiB0aGUgZHJhZy5cblRoaXMgY2xhc3Mgc2ltcGx5IG1vbml0b3JzIGZvciBwb2ludGVyIG1vdmVtZW50cyBhbmQgZmlyZXMgZXZlbnRzLlxuSXQgYWxzbyBoYXMgdGhlIGFiaWxpdHkgdG8gaGlkZSB0aGUgbW92aW5nIGVsZW1lbnQgKHRoZSBcIm1pcnJvclwiKSBkdXJpbmcgdGhlIGRyYWcuXG4qL1xuZXhwb3J0IGNsYXNzIEluZmVycmVkRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcbiAgcG9pbnRlcjogUG9pbnRlckRyYWdnaW5nXG4gIHNob3VsZElnbm9yZU1vdmU6IGJvb2xlYW4gPSBmYWxzZVxuICBtaXJyb3JTZWxlY3Rvcjogc3RyaW5nID0gJydcbiAgY3VycmVudE1pcnJvckVsOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsXG5cbiAgY29uc3RydWN0b3IoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgc3VwZXIoY29udGFpbmVyRWwpXG5cbiAgICBsZXQgcG9pbnRlciA9IHRoaXMucG9pbnRlciA9IG5ldyBQb2ludGVyRHJhZ2dpbmcoY29udGFpbmVyRWwpXG4gICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pXG4gICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpXG4gICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVydXAnLCB0aGlzLmhhbmRsZVBvaW50ZXJVcClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgaGFuZGxlUG9pbnRlckRvd24gPSAoZXY6IFBvaW50ZXJEcmFnRXZlbnQpID0+IHtcbiAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBldilcblxuICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAvLyBmaXJlIGRyYWdzdGFydCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGRlbGF5IG9yIG1pbi1kaXN0YW5jZVxuICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdzdGFydCcsIGV2KVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJNb3ZlID0gKGV2OiBQb2ludGVyRHJhZ0V2ZW50KSA9PiB7XG4gICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnbW92ZScsIGV2KVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVBvaW50ZXJVcCA9IChldjogUG9pbnRlckRyYWdFdmVudCkgPT4ge1xuICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldilcblxuICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAvLyBmaXJlIGRyYWdlbmQgcmlnaHQgYXdheS4gZG9lcyBub3Qgc3VwcG9ydCBhIHJldmVydCBhbmltYXRpb25cbiAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpXG4gICAgfVxuICB9XG5cbiAgc2V0SWdub3JlTW92ZShib29sOiBib29sZWFuKSB7XG4gICAgdGhpcy5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbFxuICB9XG5cbiAgc2V0TWlycm9ySXNWaXNpYmxlKGJvb2w6IGJvb2xlYW4pIHtcbiAgICBpZiAoYm9vbCkge1xuICAgICAgLy8gcmVzdG9yZSBhIHByZXZpb3VzbHkgaGlkZGVuIGVsZW1lbnQuXG4gICAgICAvLyB1c2UgdGhlIHJlZmVyZW5jZSBpbiBjYXNlIHRoZSBzZWxlY3RvciBjbGFzcyBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG4gICAgICBpZiAodGhpcy5jdXJyZW50TWlycm9yRWwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWlycm9yRWwuc3R5bGUudmlzaWJpbGl0eSA9ICcnXG4gICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsID0gbnVsbFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXG4gICAgICAgIC8vIFRPRE86IHNvbWVob3cgcXVlcnkgRnVsbENhbGVuZGFycyBXSVRISU4gc2hhZG93LXJvb3RzXG4gICAgICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLm1pcnJvclNlbGVjdG9yKSBhcyBIVE1MRWxlbWVudFxuICAgICAgICA6IG51bGxcblxuICAgICAgaWYgKG1pcnJvckVsKSB7XG4gICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsID0gbWlycm9yRWxcbiAgICAgICAgbWlycm9yRWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZywgRHJhZ01ldGFHZW5lcmF0b3IgfSBmcm9tICcuL0V4dGVybmFsRWxlbWVudERyYWdnaW5nJ1xuaW1wb3J0IHsgSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmcgfSBmcm9tICcuL0luZmVycmVkRWxlbWVudERyYWdnaW5nJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFRoaXJkUGFydHlEcmFnZ2FibGVTZXR0aW5ncyB7XG4gIGV2ZW50RGF0YT86IERyYWdNZXRhR2VuZXJhdG9yXG4gIGl0ZW1TZWxlY3Rvcj86IHN0cmluZ1xuICBtaXJyb3JTZWxlY3Rvcj86IHN0cmluZ1xufVxuXG4vKlxuQnJpZGdlcyB0aGlyZC1wYXJ0eSBkcmFnLW4tZHJvcCBzeXN0ZW1zIHdpdGggRnVsbENhbGVuZGFyLlxuTXVzdCBiZSBpbnN0YW50aWF0ZWQgYW5kIGRlc3Ryb3llZCBieSBjYWxsZXIuXG4qL1xuZXhwb3J0IGNsYXNzIFRoaXJkUGFydHlEcmFnZ2FibGUge1xuICBkcmFnZ2luZzogSW5mZXJyZWRFbGVtZW50RHJhZ2dpbmdcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb250YWluZXJPclNldHRpbmdzPzogRXZlbnRUYXJnZXQgfCBUaGlyZFBhcnR5RHJhZ2dhYmxlU2V0dGluZ3MsXG4gICAgc2V0dGluZ3M/OiBUaGlyZFBhcnR5RHJhZ2dhYmxlU2V0dGluZ3MsXG4gICkge1xuICAgIGxldCBjb250YWluZXJFbDogRXZlbnRUYXJnZXQgPSBkb2N1bWVudFxuXG4gICAgaWYgKFxuICAgICAgLy8gd2lzaCB3ZSBjb3VsZCBqdXN0IHRlc3QgaW5zdGFuY2VvZiBFdmVudFRhcmdldCwgYnV0IGRvZXNuJ3Qgd29yayBpbiBJRTExXG4gICAgICBjb250YWluZXJPclNldHRpbmdzID09PSBkb2N1bWVudCB8fFxuICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyBpbnN0YW5jZW9mIEVsZW1lbnRcbiAgICApIHtcbiAgICAgIGNvbnRhaW5lckVsID0gY29udGFpbmVyT3JTZXR0aW5ncyBhcyBFdmVudFRhcmdldFxuICAgICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0aW5ncyA9IChjb250YWluZXJPclNldHRpbmdzIHx8IHt9KSBhcyBUaGlyZFBhcnR5RHJhZ2dhYmxlU2V0dGluZ3NcbiAgICB9XG5cbiAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEluZmVycmVkRWxlbWVudERyYWdnaW5nKGNvbnRhaW5lckVsIGFzIEhUTUxFbGVtZW50KVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5pdGVtU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gc2V0dGluZ3MuaXRlbVNlbGVjdG9yXG4gICAgfSBlbHNlIGlmIChjb250YWluZXJFbCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnW2RhdGEtZXZlbnRdJ1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubWlycm9yU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkcmFnZ2luZy5taXJyb3JTZWxlY3RvciA9IHNldHRpbmdzLm1pcnJvclNlbGVjdG9yXG4gICAgfVxuXG4gICAgbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpXG4gIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgRGF0ZUNsaWNraW5nIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvRGF0ZUNsaWNraW5nJ1xuaW1wb3J0IHsgRGF0ZVNlbGVjdGluZyB9IGZyb20gJy4vaW50ZXJhY3Rpb25zL0RhdGVTZWxlY3RpbmcnXG5pbXBvcnQgeyBFdmVudERyYWdnaW5nIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvRXZlbnREcmFnZ2luZydcbmltcG9ydCB7IEV2ZW50UmVzaXppbmcgfSBmcm9tICcuL2ludGVyYWN0aW9ucy9FdmVudFJlc2l6aW5nJ1xuaW1wb3J0IHsgVW5zZWxlY3RBdXRvIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMvVW5zZWxlY3RBdXRvJ1xuaW1wb3J0IHsgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyB9IGZyb20gJy4vZG5kL0ZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcnXG5pbXBvcnQgeyBPUFRJT05fUkVGSU5FUlMsIExJU1RFTkVSX1JFRklORVJTIH0gZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0ICcuL29wdGlvbnMtZGVjbGFyZSdcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlUGx1Z2luKHtcbiAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbRGF0ZUNsaWNraW5nLCBEYXRlU2VsZWN0aW5nLCBFdmVudERyYWdnaW5nLCBFdmVudFJlc2l6aW5nXSxcbiAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtVbnNlbGVjdEF1dG9dLFxuICBlbGVtZW50RHJhZ2dpbmdJbXBsOiBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nLFxuICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICBsaXN0ZW5lclJlZmluZXJzOiBMSVNURU5FUl9SRUZJTkVSUyxcbn0pXG5cbmV4cG9ydCAqIGZyb20gJy4vYXBpLXR5cGUtZGVwcydcbmV4cG9ydCB7IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcgfVxuZXhwb3J0IHsgUG9pbnRlckRyYWdnaW5nIH0gZnJvbSAnLi9kbmQvUG9pbnRlckRyYWdnaW5nJ1xuZXhwb3J0IHsgRXh0ZXJuYWxEcmFnZ2FibGUgYXMgRHJhZ2dhYmxlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMtZXh0ZXJuYWwvRXh0ZXJuYWxEcmFnZ2FibGUnXG5leHBvcnQgeyBUaGlyZFBhcnR5RHJhZ2dhYmxlIH0gZnJvbSAnLi9pbnRlcmFjdGlvbnMtZXh0ZXJuYWwvVGhpcmRQYXJ0eURyYWdnYWJsZSdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/interaction/main.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/list/main.js":
/*!*************************************************!*\
  !*** ./node_modules/@fullcalendar/list/main.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ListView\": function() { return /* binding */ ListView; }\n/* harmony export */ });\n/* harmony import */ var _main_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./main.css */ \"./node_modules/@fullcalendar/list/main.css\");\n/* harmony import */ var _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.js\");\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/*!\nFullCalendar v5.9.0\nDocs & License: https://fullcalendar.io/\n(c) 2021 Adam Shaw\n*/\n\n\n\n\nvar ListViewHeaderRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ListViewHeaderRow, _super);\n\n  function ListViewHeaderRow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ListViewHeaderRow.prototype.render = function () {\n    var _a = this.props,\n        dayDate = _a.dayDate,\n        todayRange = _a.todayRange;\n    var _b = this.context,\n        theme = _b.theme,\n        dateEnv = _b.dateEnv,\n        options = _b.options,\n        viewApi = _b.viewApi;\n    var dayMeta = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDateMeta)(dayDate, todayRange); // will ever be falsy?\n\n    var text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : ''; // will ever be falsy? also, BAD NAME \"alt\"\n\n    var sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';\n    var navLinkData = options.navLinks ? (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildNavLinkData)(dayDate) : null;\n\n    var hookProps = (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n      date: dateEnv.toDate(dayDate),\n      view: viewApi,\n      text: text,\n      sideText: sideText,\n      navLinkData: navLinkData\n    }, dayMeta);\n\n    var classNames = ['fc-list-day'].concat((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getDayClassNames)(dayMeta, theme)); // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n      hookProps: hookProps,\n      classNames: options.dayHeaderClassNames,\n      content: options.dayHeaderContent,\n      defaultContent: renderInnerContent,\n      didMount: options.dayHeaderDidMount,\n      willUnmount: options.dayHeaderWillUnmount\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.formatDayString)(dayDate)\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"th\", {\n        colSpan: 3\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: 'fc-list-day-cushion ' + theme.getClass('tableCellShaded'),\n        ref: innerElRef\n      }, innerContent)));\n    });\n  };\n\n  return ListViewHeaderRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderInnerContent(props) {\n  var navLinkAttrs = props.navLinkData // is there a type for this?\n  ? {\n    'data-navlink': props.navLinkData,\n    tabIndex: 0\n  } : {};\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, props.text && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    className: \"fc-list-day-text\"\n  }, navLinkAttrs), props.text), props.sideText && (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n    className: \"fc-list-day-side-text\"\n  }, navLinkAttrs), props.sideText));\n}\n\nvar DEFAULT_TIME_FORMAT = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)({\n  hour: 'numeric',\n  minute: '2-digit',\n  meridiem: 'short'\n});\n\nvar ListViewEventRow = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ListViewEventRow, _super);\n\n  function ListViewEventRow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ListViewEventRow.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var seg = props.seg;\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TIME_FORMAT;\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.EventRoot, {\n      seg: seg,\n      timeText: \"\" // BAD. because of all-day content\n      ,\n      disableDragging: true,\n      disableResizing: true,\n      defaultContent: renderEventInnerContent,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday,\n      isSelected: props.isSelected,\n      isDragging: props.isDragging,\n      isResizing: props.isResizing,\n      isDateSelecting: props.isDateSelecting\n    }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tr\", {\n        className: ['fc-list-event', hookProps.event.url ? 'fc-event-forced-url' : ''].concat(classNames).join(' '),\n        ref: rootElRef\n      }, buildTimeContent(seg, timeFormat, context), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n        className: \"fc-list-event-graphic\"\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"span\", {\n        className: \"fc-list-event-dot\",\n        style: {\n          borderColor: hookProps.borderColor || hookProps.backgroundColor\n        }\n      })), (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n        className: \"fc-list-event-title\",\n        ref: innerElRef\n      }, innerContent));\n    });\n  };\n\n  return ListViewEventRow;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.BaseComponent);\n\nfunction renderEventInnerContent(props) {\n  var event = props.event;\n  var url = event.url;\n  var anchorAttrs = url ? {\n    href: url\n  } : {};\n  return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"a\", (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, anchorAttrs), event.title);\n}\n\nfunction buildTimeContent(seg, timeFormat, context) {\n  var options = context.options;\n\n  if (options.displayEventTime !== false) {\n    var eventDef = seg.eventRange.def;\n    var eventInstance = seg.eventRange.instance;\n    var doAllDay = false;\n    var timeText = void 0;\n\n    if (eventDef.allDay) {\n      doAllDay = true;\n    } else if ((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.isMultiDayRange)(seg.eventRange.range)) {\n      // TODO: use (!isStart || !isEnd) instead?\n      if (seg.isStart) {\n        timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);\n      } else if (seg.isEnd) {\n        timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);\n      } else {\n        doAllDay = true;\n      }\n    } else {\n      timeText = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.buildSegTimeText)(seg, timeFormat, context);\n    }\n\n    if (doAllDay) {\n      var hookProps = {\n        text: context.options.allDayText,\n        view: context.viewApi\n      };\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n        hookProps: hookProps,\n        classNames: options.allDayClassNames,\n        content: options.allDayContent,\n        defaultContent: renderAllDayInner,\n        didMount: options.allDayDidMount,\n        willUnmount: options.allDayWillUnmount\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n          className: ['fc-list-event-time'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, innerContent);\n      });\n    }\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"td\", {\n      className: \"fc-list-event-time\"\n    }, timeText);\n  }\n\n  return null;\n}\n\nfunction renderAllDayInner(hookProps) {\n  return hookProps.text;\n}\n/*\nResponsible for the scroller, and forwarding event-related actions into the \"grid\".\n*/\n\n\nvar ListView = function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(ListView, _super);\n\n  function ListView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.computeDateVars = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(computeDateVars);\n    _this.eventStoreToSegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.memoize)(_this._eventStoreToSegs);\n\n    _this.setRootEl = function (rootEl) {\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  ListView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var extraClassNames = ['fc-list', context.theme.getClass('table'), context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : ''];\n\n    var _b = this.computeDateVars(props.dateProfile),\n        dayDates = _b.dayDates,\n        dayRanges = _b.dayRanges;\n\n    var eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.ViewRoot, {\n      viewSpec: context.viewSpec,\n      elRef: this.setRootEl\n    }, function (rootElRef, classNames) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        ref: rootElRef,\n        className: extraClassNames.concat(classNames).join(' ')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.Scroller, {\n        liquid: !props.isHeightAuto,\n        overflowX: props.isHeightAuto ? 'visible' : 'hidden',\n        overflowY: props.isHeightAuto ? 'visible' : 'auto'\n      }, eventSegs.length > 0 ? _this.renderSegList(eventSegs, dayDates) : _this.renderEmptyMessage()));\n    });\n  };\n\n  ListView.prototype.renderEmptyMessage = function () {\n    var _a = this.context,\n        options = _a.options,\n        viewApi = _a.viewApi;\n    var hookProps = {\n      text: options.noEventsText,\n      view: viewApi\n    };\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.RenderHook, {\n      hookProps: hookProps,\n      classNames: options.noEventsClassNames,\n      content: options.noEventsContent,\n      defaultContent: renderNoEventsInner,\n      didMount: options.noEventsDidMount,\n      willUnmount: options.noEventsWillUnmount\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: ['fc-list-empty'].concat(classNames).join(' '),\n        ref: rootElRef\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"div\", {\n        className: \"fc-list-empty-cushion\",\n        ref: innerElRef\n      }, innerContent));\n    });\n  };\n\n  ListView.prototype.renderSegList = function (allSegs, dayDates) {\n    var _a = this.context,\n        theme = _a.theme,\n        options = _a.options;\n    var segsByDay = groupSegsByDay(allSegs); // sparse array\n\n    return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      var innerNodes = [];\n\n      for (var dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {\n        var daySegs = segsByDay[dayIndex];\n\n        if (daySegs) {\n          // sparse array, so might be undefined\n          var dayStr = dayDates[dayIndex].toISOString(); // append a day header\n\n          innerNodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ListViewHeaderRow, {\n            key: dayStr,\n            dayDate: dayDates[dayIndex],\n            todayRange: todayRange\n          }));\n          daySegs = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sortEventSegs)(daySegs, options.eventOrder);\n\n          for (var _i = 0, daySegs_1 = daySegs; _i < daySegs_1.length; _i++) {\n            var seg = daySegs_1[_i];\n            innerNodes.push((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(ListViewEventRow, (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({\n              key: dayStr + ':' + seg.eventRange.instance.instanceId\n              /* are multiple segs for an instanceId */\n              ,\n              seg: seg,\n              isDragging: false,\n              isResizing: false,\n              isDateSelecting: false,\n              isSelected: false\n            }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.getSegMeta)(seg, todayRange, nowDate))));\n          }\n        }\n      }\n\n      return (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"table\", {\n        className: 'fc-list-table ' + theme.getClass('table')\n      }, (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createElement)(\"tbody\", null, innerNodes));\n    });\n  };\n\n  ListView.prototype._eventStoreToSegs = function (eventStore, eventUiBases, dayRanges) {\n    return this.eventRangesToSegs((0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.sliceEventStore)(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);\n  };\n\n  ListView.prototype.eventRangesToSegs = function (eventRanges, dayRanges) {\n    var segs = [];\n\n    for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n      var eventRange = eventRanges_1[_i];\n      segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));\n    }\n\n    return segs;\n  };\n\n  ListView.prototype.eventRangeToSegs = function (eventRange, dayRanges) {\n    var dateEnv = this.context.dateEnv;\n    var nextDayThreshold = this.context.options.nextDayThreshold;\n    var range = eventRange.range;\n    var allDay = eventRange.def.allDay;\n    var dayIndex;\n    var segRange;\n    var seg;\n    var segs = [];\n\n    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {\n      segRange = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.intersectRanges)(range, dayRanges[dayIndex]);\n\n      if (segRange) {\n        seg = {\n          component: this,\n          eventRange: eventRange,\n          start: segRange.start,\n          end: segRange.end,\n          isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),\n          dayIndex: dayIndex\n        };\n        segs.push(seg); // detect when range won't go fully into the next day,\n        // and mutate the latest seg to the be the end.\n\n        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {\n          seg.end = range.end;\n          seg.isEnd = true;\n          break;\n        }\n      }\n    }\n\n    return segs;\n  };\n\n  return ListView;\n}(_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.DateComponent);\n\nfunction renderNoEventsInner(hookProps) {\n  return hookProps.text;\n}\n\nfunction computeDateVars(dateProfile) {\n  var dayStart = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.startOfDay)(dateProfile.renderRange.start);\n  var viewEnd = dateProfile.renderRange.end;\n  var dayDates = [];\n  var dayRanges = [];\n\n  while (dayStart < viewEnd) {\n    dayDates.push(dayStart);\n    dayRanges.push({\n      start: dayStart,\n      end: (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(dayStart, 1)\n    });\n    dayStart = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.addDays)(dayStart, 1);\n  }\n\n  return {\n    dayDates: dayDates,\n    dayRanges: dayRanges\n  };\n} // Returns a sparse array of arrays, segs grouped by their dayIndex\n\n\nfunction groupSegsByDay(segs) {\n  var segsByDay = []; // sparse array\n\n  var i;\n  var seg;\n\n  for (i = 0; i < segs.length; i += 1) {\n    seg = segs[i];\n    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);\n  }\n\n  return segsByDay;\n}\n\nvar OPTION_REFINERS = {\n  listDayFormat: createFalsableFormatter,\n  listDaySideFormat: createFalsableFormatter,\n  noEventsClassNames: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity,\n  noEventsContent: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity,\n  noEventsDidMount: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity,\n  noEventsWillUnmount: _fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.identity // noEventsText is defined in base options\n\n};\n\nfunction createFalsableFormatter(input) {\n  return input === false ? null : (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createFormatter)(input);\n}\n\nvar main = (0,_fullcalendar_common__WEBPACK_IMPORTED_MODULE_1__.createPlugin)({\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    list: {\n      component: ListView,\n      buttonTextKey: 'list',\n      listDayFormat: {\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric'\n      } // like \"January 1, 2016\"\n\n    },\n    listDay: {\n      type: 'list',\n      duration: {\n        days: 1\n      },\n      listDayFormat: {\n        weekday: 'long'\n      } // day-of-week is all we need. full date is probably in headerToolbar\n\n    },\n    listWeek: {\n      type: 'list',\n      duration: {\n        weeks: 1\n      },\n      listDayFormat: {\n        weekday: 'long'\n      },\n      listDaySideFormat: {\n        month: 'long',\n        day: 'numeric',\n        year: 'numeric'\n      }\n    },\n    listMonth: {\n      type: 'list',\n      duration: {\n        month: 1\n      },\n      listDaySideFormat: {\n        weekday: 'long'\n      } // day-of-week is nice-to-have\n\n    },\n    listYear: {\n      type: 'list',\n      duration: {\n        year: 1\n      },\n      listDaySideFormat: {\n        weekday: 'long'\n      } // day-of-week is nice-to-have\n\n    }\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9saXN0L21haW4uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQUE7O0FBQUE7O0FBdURBOztBQXREQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFHQTs7QUFHQTtBQUVBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVNBOztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUVBO0FBQ0E7QUFBQTtBQUZBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUtBO0FBR0E7O0FBQ0E7QUF2REE7O0FBeURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFBQTtBQUtBO0FBQUE7QUFNQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTs7QUFNQTtBQUFBOztBQUFBOztBQW9DQTs7QUFuQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUZBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFJQTtBQUdBOztBQUNBO0FBcENBOztBQXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQU1BOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUdBOztBQUVBO0FBQ0E7QUFBQTtBQUlBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FDekdBOzs7Ozs7QUFHQTs7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBcUpBOztBQTVMQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFNQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFVQTtBQUdBOztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUdBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQU9BOztBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFJQTtBQUdBOztBQUVBO0FBQ0E7QUFTQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFVQTs7O0FBSUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQWhNQTs7QUFrTUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUM3UEE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBUEE7O0FBWUE7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSkE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFIQTtBQTNCQTtBQUZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL0xpc3RWaWV3SGVhZGVyUm93LnRzeD8zMGY0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9MaXN0Vmlld0V2ZW50Um93LnRzeD8wYTM1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9MaXN0Vmlldy50c3g/Njk2YiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvb3B0aW9ucy50cz85MTgxIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9tYWluLnRzP2I5OWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmFzZUNvbXBvbmVudCwgRGF0ZU1hcmtlciwgY3JlYXRlRWxlbWVudCwgRGF0ZVJhbmdlLCBnZXREYXRlTWV0YSxcbiAgUmVuZGVySG9vaywgYnVpbGROYXZMaW5rRGF0YSwgRGF5SGVhZGVyQ29udGVudEFyZywgZ2V0RGF5Q2xhc3NOYW1lcywgZm9ybWF0RGF5U3RyaW5nLCBGcmFnbWVudCxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFZpZXdIZWFkZXJSb3dQcm9wcyB7XG4gIGRheURhdGU6IERhdGVNYXJrZXJcbiAgdG9kYXlSYW5nZTogRGF0ZVJhbmdlXG59XG5cbmludGVyZmFjZSBIb29rUHJvcHMgZXh0ZW5kcyBEYXlIZWFkZXJDb250ZW50QXJnIHsgLy8gZG9lc24ndCBlbmZvcmNlIG11Y2ggc2luY2UgRGF5Q2VsbENvbnRlbnRBcmcgYWxsb3cgZXh0cmEgcHJvcHNcbiAgdGV4dDogc3RyaW5nXG4gIHNpZGVUZXh0OiBzdHJpbmdcbn1cblxuZXhwb3J0IGNsYXNzIExpc3RWaWV3SGVhZGVyUm93IGV4dGVuZHMgQmFzZUNvbXBvbmVudDxMaXN0Vmlld0hlYWRlclJvd1Byb3BzPiB7XG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBkYXlEYXRlLCB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzXG4gICAgbGV0IHsgdGhlbWUsIGRhdGVFbnYsIG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF5RGF0ZSwgdG9kYXlSYW5nZSlcblxuICAgIC8vIHdpbGwgZXZlciBiZSBmYWxzeT9cbiAgICBsZXQgdGV4dCA9IG9wdGlvbnMubGlzdERheUZvcm1hdCA/IGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIG9wdGlvbnMubGlzdERheUZvcm1hdCkgOiAnJ1xuXG4gICAgLy8gd2lsbCBldmVyIGJlIGZhbHN5PyBhbHNvLCBCQUQgTkFNRSBcImFsdFwiXG4gICAgbGV0IHNpZGVUZXh0ID0gb3B0aW9ucy5saXN0RGF5U2lkZUZvcm1hdCA/IGRhdGVFbnYuZm9ybWF0KGRheURhdGUsIG9wdGlvbnMubGlzdERheVNpZGVGb3JtYXQpIDogJydcblxuICAgIGxldCBuYXZMaW5rRGF0YSA9IG9wdGlvbnMubmF2TGlua3NcbiAgICAgID8gYnVpbGROYXZMaW5rRGF0YShkYXlEYXRlKVxuICAgICAgOiBudWxsXG5cbiAgICBsZXQgaG9va1Byb3BzOiBIb29rUHJvcHMgPSB7XG4gICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXlEYXRlKSxcbiAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICB0ZXh0LFxuICAgICAgc2lkZVRleHQsXG4gICAgICBuYXZMaW5rRGF0YSxcbiAgICAgIC4uLmRheU1ldGEsXG4gICAgfVxuXG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbJ2ZjLWxpc3QtZGF5J10uY29uY2F0KFxuICAgICAgZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSksXG4gICAgKVxuXG4gICAgLy8gVE9ETzogbWFrZSBhIHJldXNhYmxlIEhPQyBmb3IgZGF5SGVhZGVyICh1c2VkIGluIGRheWdyaWQvdGltZWdyaWQgdG9vKVxuICAgIHJldHVybiAoXG4gICAgICA8UmVuZGVySG9vazxIb29rUHJvcHM+XG4gICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICBjbGFzc05hbWVzPXtvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXN9XG4gICAgICAgIGNvbnRlbnQ9e29wdGlvbnMuZGF5SGVhZGVyQ29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlcklubmVyQ29udGVudH1cbiAgICAgICAgZGlkTW91bnQ9e29wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnR9XG4gICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50fVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSA9PiAoXG4gICAgICAgICAgPHRyXG4gICAgICAgICAgICByZWY9e3Jvb3RFbFJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpfVxuICAgICAgICAgICAgZGF0YS1kYXRlPXtmb3JtYXREYXlTdHJpbmcoZGF5RGF0ZSl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHRoIGNvbFNwYW49ezN9PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17J2ZjLWxpc3QtZGF5LWN1c2hpb24gJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKX0gcmVmPXtpbm5lckVsUmVmfT5cbiAgICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgKX1cbiAgICAgIDwvUmVuZGVySG9vaz5cbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzOiBIb29rUHJvcHMpIHtcbiAgbGV0IG5hdkxpbmtBdHRycyA9IHByb3BzLm5hdkxpbmtEYXRhIC8vIGlzIHRoZXJlIGEgdHlwZSBmb3IgdGhpcz9cbiAgICA/IHsgJ2RhdGEtbmF2bGluayc6IHByb3BzLm5hdkxpbmtEYXRhLCB0YWJJbmRleDogMCB9XG4gICAgOiB7fVxuXG4gIHJldHVybiAoXG4gICAgPEZyYWdtZW50PlxuICAgICAge3Byb3BzLnRleHQgJiYgKFxuICAgICAgICA8YSBjbGFzc05hbWU9XCJmYy1saXN0LWRheS10ZXh0XCIgey4uLm5hdkxpbmtBdHRyc30+XG4gICAgICAgICAge3Byb3BzLnRleHR9XG4gICAgICAgIDwvYT5cbiAgICAgICl9XG4gICAgICB7cHJvcHMuc2lkZVRleHQgJiYgKFxuICAgICAgICA8YSBjbGFzc05hbWU9XCJmYy1saXN0LWRheS1zaWRlLXRleHRcIiB7Li4ubmF2TGlua0F0dHJzfT5cbiAgICAgICAgICB7cHJvcHMuc2lkZVRleHR9XG4gICAgICAgIDwvYT5cbiAgICAgICl9XG4gICAgPC9GcmFnbWVudD5cbiAgKVxufVxuIiwiaW1wb3J0IHtcbiAgTWluaW1hbEV2ZW50UHJvcHMsIEJhc2VDb21wb25lbnQsIFZpZXdDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBBbGxEYXlDb250ZW50QXJnLFxuICBTZWcsIGlzTXVsdGlEYXlSYW5nZSwgRGF0ZUZvcm1hdHRlciwgYnVpbGRTZWdUaW1lVGV4dCwgY3JlYXRlRm9ybWF0dGVyLCBFdmVudENvbnRlbnRBcmcsIEV2ZW50Um9vdCwgQ29tcG9uZW50Q2hpbGRyZW4sIFJlbmRlckhvb2ssXG59IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuXG5jb25zdCBERUZBVUxUX1RJTUVfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHtcbiAgaG91cjogJ251bWVyaWMnLFxuICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgbWVyaWRpZW06ICdzaG9ydCcsXG59KVxuXG5leHBvcnQgY2xhc3MgTGlzdFZpZXdFdmVudFJvdyBleHRlbmRzIEJhc2VDb21wb25lbnQ8TWluaW1hbEV2ZW50UHJvcHM+IHtcbiAgcmVuZGVyKCkge1xuICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzXG4gICAgbGV0IHsgc2VnIH0gPSBwcm9wc1xuXG4gICAgbGV0IHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IERFRkFVTFRfVElNRV9GT1JNQVRcblxuICAgIHJldHVybiAoXG4gICAgICA8RXZlbnRSb290XG4gICAgICAgIHNlZz17c2VnfVxuICAgICAgICB0aW1lVGV4dD1cIlwiIC8vIEJBRC4gYmVjYXVzZSBvZiBhbGwtZGF5IGNvbnRlbnRcbiAgICAgICAgZGlzYWJsZURyYWdnaW5nXG4gICAgICAgIGRpc2FibGVSZXNpemluZ1xuICAgICAgICBkZWZhdWx0Q29udGVudD17cmVuZGVyRXZlbnRJbm5lckNvbnRlbnR9XG4gICAgICAgIGlzUGFzdD17cHJvcHMuaXNQYXN0fVxuICAgICAgICBpc0Z1dHVyZT17cHJvcHMuaXNGdXR1cmV9XG4gICAgICAgIGlzVG9kYXk9e3Byb3BzLmlzVG9kYXl9XG4gICAgICAgIGlzU2VsZWN0ZWQ9e3Byb3BzLmlzU2VsZWN0ZWR9XG4gICAgICAgIGlzRHJhZ2dpbmc9e3Byb3BzLmlzRHJhZ2dpbmd9XG4gICAgICAgIGlzUmVzaXppbmc9e3Byb3BzLmlzUmVzaXppbmd9XG4gICAgICAgIGlzRGF0ZVNlbGVjdGluZz17cHJvcHMuaXNEYXRlU2VsZWN0aW5nfVxuICAgICAgPlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpID0+IChcbiAgICAgICAgICA8dHIgY2xhc3NOYW1lPXtbJ2ZjLWxpc3QtZXZlbnQnLCBob29rUHJvcHMuZXZlbnQudXJsID8gJ2ZjLWV2ZW50LWZvcmNlZC11cmwnIDogJyddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyl9IHJlZj17cm9vdEVsUmVmfT5cbiAgICAgICAgICAgIHtidWlsZFRpbWVDb250ZW50KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCl9XG4gICAgICAgICAgICA8dGQgY2xhc3NOYW1lPVwiZmMtbGlzdC1ldmVudC1ncmFwaGljXCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZjLWxpc3QtZXZlbnQtZG90XCIgc3R5bGU9e3sgYm9yZGVyQ29sb3I6IGhvb2tQcm9wcy5ib3JkZXJDb2xvciB8fCBob29rUHJvcHMuYmFja2dyb3VuZENvbG9yIH19IC8+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT1cImZjLWxpc3QtZXZlbnQtdGl0bGVcIiByZWY9e2lubmVyRWxSZWZ9PlxuICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICApfVxuICAgICAgPC9FdmVudFJvb3Q+XG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckV2ZW50SW5uZXJDb250ZW50KHByb3BzOiBFdmVudENvbnRlbnRBcmcpIHtcbiAgbGV0IHsgZXZlbnQgfSA9IHByb3BzXG4gIGxldCB1cmwgPSBldmVudC51cmxcbiAgbGV0IGFuY2hvckF0dHJzID0gdXJsID8geyBocmVmOiB1cmwgfSA6IHt9XG5cbiAgcmV0dXJuIChcbiAgICA8YSB7Li4uYW5jaG9yQXR0cnN9PlxuICAgICAgey8qIFRPRE86IGRvY3VtZW50IGhvdyB3aG9sZSByb3cgYmVjb21lIGNsaWNrYWJsZSAqL31cbiAgICAgIHtldmVudC50aXRsZX1cbiAgICA8L2E+XG4gIClcbn1cblxuZnVuY3Rpb24gYnVpbGRUaW1lQ29udGVudChzZWc6IFNlZywgdGltZUZvcm1hdDogRGF0ZUZvcm1hdHRlciwgY29udGV4dDogVmlld0NvbnRleHQpOiBDb21wb25lbnRDaGlsZHJlbiB7XG4gIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHRcblxuICBpZiAob3B0aW9ucy5kaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZSkge1xuICAgIGxldCBldmVudERlZiA9IHNlZy5ldmVudFJhbmdlLmRlZlxuICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICBsZXQgZG9BbGxEYXkgPSBmYWxzZVxuICAgIGxldCB0aW1lVGV4dDogc3RyaW5nXG5cbiAgICBpZiAoZXZlbnREZWYuYWxsRGF5KSB7XG4gICAgICBkb0FsbERheSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGlEYXlSYW5nZShzZWcuZXZlbnRSYW5nZS5yYW5nZSkpIHsgLy8gVE9ETzogdXNlICghaXNTdGFydCB8fCAhaXNFbmQpIGluc3RlYWQ/XG4gICAgICBpZiAoc2VnLmlzU3RhcnQpIHtcbiAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KFxuICAgICAgICAgIHNlZyxcbiAgICAgICAgICB0aW1lRm9ybWF0LFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgc2VnLmVuZCxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChzZWcuaXNFbmQpIHtcbiAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KFxuICAgICAgICAgIHNlZyxcbiAgICAgICAgICB0aW1lRm9ybWF0LFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHNlZy5zdGFydCxcbiAgICAgICAgICBldmVudEluc3RhbmNlLnJhbmdlLmVuZCxcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9BbGxEYXkgPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChcbiAgICAgICAgc2VnLFxuICAgICAgICB0aW1lRm9ybWF0LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChkb0FsbERheSkge1xuICAgICAgbGV0IGhvb2tQcm9wczogQWxsRGF5Q29udGVudEFyZyA9IHtcbiAgICAgICAgdGV4dDogY29udGV4dC5vcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPFJlbmRlckhvb2s8QWxsRGF5Q29udGVudEFyZz4gLy8gbmVlZGVkP1xuICAgICAgICAgIGhvb2tQcm9wcz17aG9va1Byb3BzfVxuICAgICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMuYWxsRGF5Q2xhc3NOYW1lc31cbiAgICAgICAgICBjb250ZW50PXtvcHRpb25zLmFsbERheUNvbnRlbnR9XG4gICAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlckFsbERheUlubmVyfVxuICAgICAgICAgIGRpZE1vdW50PXtvcHRpb25zLmFsbERheURpZE1vdW50fVxuICAgICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLmFsbERheVdpbGxVbm1vdW50fVxuICAgICAgICA+XG4gICAgICAgICAgeyhyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgPT4gKFxuICAgICAgICAgICAgPHRkIGNsYXNzTmFtZT17WydmYy1saXN0LWV2ZW50LXRpbWUnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpfSByZWY9e3Jvb3RFbFJlZn0+XG4gICAgICAgICAgICAgIHtpbm5lckNvbnRlbnR9XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvUmVuZGVySG9vaz5cbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPHRkIGNsYXNzTmFtZT1cImZjLWxpc3QtZXZlbnQtdGltZVwiPlxuICAgICAgICB7dGltZVRleHR9XG4gICAgICA8L3RkPlxuICAgIClcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHJlbmRlckFsbERheUlubmVyKGhvb2tQcm9wcykge1xuICByZXR1cm4gaG9va1Byb3BzLnRleHRcbn1cbiIsImltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIFZpZXdQcm9wcyxcbiAgU2Nyb2xsZXIsXG4gIERhdGVNYXJrZXIsXG4gIGFkZERheXMsXG4gIHN0YXJ0T2ZEYXksXG4gIERhdGVSYW5nZSxcbiAgaW50ZXJzZWN0UmFuZ2VzLFxuICBEYXRlUHJvZmlsZSxcbiAgRXZlbnRVaUhhc2gsXG4gIEV2ZW50UmVuZGVyUmFuZ2UsXG4gIHNsaWNlRXZlbnRTdG9yZSxcbiAgRXZlbnRTdG9yZSxcbiAgbWVtb2l6ZSxcbiAgU2VnLFxuICBWTm9kZSxcbiAgc29ydEV2ZW50U2VncyxcbiAgZ2V0U2VnTWV0YSxcbiAgTm93VGltZXIsXG4gIFZpZXdSb290LFxuICBSZW5kZXJIb29rLFxuICBEYXRlQ29tcG9uZW50LFxuICBWaWV3QXBpLFxuICBNb3VudEFyZyxcbn0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb21tb24nXG5pbXBvcnQgeyBMaXN0Vmlld0hlYWRlclJvdyB9IGZyb20gJy4vTGlzdFZpZXdIZWFkZXJSb3cnXG5pbXBvcnQgeyBMaXN0Vmlld0V2ZW50Um93IH0gZnJvbSAnLi9MaXN0Vmlld0V2ZW50Um93J1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vRXZlbnRzQ29udGVudEFyZyB7XG4gIHRleHQ6IHN0cmluZ1xuICB2aWV3OiBWaWV3QXBpXG59XG5cbmV4cG9ydCB0eXBlIE5vRXZlbnRzTW91bnRBcmcgPSBNb3VudEFyZzxOb0V2ZW50c0NvbnRlbnRBcmc+XG5cbi8qXG5SZXNwb25zaWJsZSBmb3IgdGhlIHNjcm9sbGVyLCBhbmQgZm9yd2FyZGluZyBldmVudC1yZWxhdGVkIGFjdGlvbnMgaW50byB0aGUgXCJncmlkXCIuXG4qL1xuZXhwb3J0IGNsYXNzIExpc3RWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudDxWaWV3UHJvcHM+IHtcbiAgcHJpdmF0ZSBjb21wdXRlRGF0ZVZhcnMgPSBtZW1vaXplKGNvbXB1dGVEYXRlVmFycylcbiAgcHJpdmF0ZSBldmVudFN0b3JlVG9TZWdzID0gbWVtb2l6ZSh0aGlzLl9ldmVudFN0b3JlVG9TZWdzKVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpc1xuXG4gICAgbGV0IGV4dHJhQ2xhc3NOYW1lcyA9IFtcbiAgICAgICdmYy1saXN0JyxcbiAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIC8vIGp1c3QgZm9yIHRoZSBvdXRlciBib3JkZXIuIHdpbGwgYmUgb24gZGl2XG4gICAgICBjb250ZXh0Lm9wdGlvbnMuc3RpY2t5SGVhZGVyRGF0ZXMgIT09IGZhbHNlID8gJ2ZjLWxpc3Qtc3RpY2t5JyA6ICcnLFxuICAgIF1cblxuICAgIGxldCB7IGRheURhdGVzLCBkYXlSYW5nZXMgfSA9IHRoaXMuY29tcHV0ZURhdGVWYXJzKHByb3BzLmRhdGVQcm9maWxlKVxuICAgIGxldCBldmVudFNlZ3MgPSB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MocHJvcHMuZXZlbnRTdG9yZSwgcHJvcHMuZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFZpZXdSb290IHZpZXdTcGVjPXtjb250ZXh0LnZpZXdTcGVjfSBlbFJlZj17dGhpcy5zZXRSb290RWx9PlxuICAgICAgICB7KHJvb3RFbFJlZiwgY2xhc3NOYW1lcykgPT4gKFxuICAgICAgICAgIDxkaXYgcmVmPXtyb290RWxSZWZ9IGNsYXNzTmFtZT17ZXh0cmFDbGFzc05hbWVzLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyl9PlxuICAgICAgICAgICAgPFNjcm9sbGVyXG4gICAgICAgICAgICAgIGxpcXVpZD17IXByb3BzLmlzSGVpZ2h0QXV0b31cbiAgICAgICAgICAgICAgb3ZlcmZsb3dYPXtwcm9wcy5pc0hlaWdodEF1dG8gPyAndmlzaWJsZScgOiAnaGlkZGVuJ31cbiAgICAgICAgICAgICAgb3ZlcmZsb3dZPXtwcm9wcy5pc0hlaWdodEF1dG8gPyAndmlzaWJsZScgOiAnYXV0byd9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtldmVudFNlZ3MubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWdMaXN0KGV2ZW50U2VncywgZGF5RGF0ZXMpIDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckVtcHR5TWVzc2FnZSgpfVxuICAgICAgICAgICAgPC9TY3JvbGxlcj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgIDwvVmlld1Jvb3Q+XG4gICAgKVxuICB9XG5cbiAgc2V0Um9vdEVsID0gKHJvb3RFbDogSFRNTERpdkVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgaWYgKHJvb3RFbCkge1xuICAgICAgdGhpcy5jb250ZXh0LnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcywgeyAvLyBUT0RPOiBtYWtlIGF3YXJlIHRoYXQgaXQgZG9lc24ndCBkbyBIaXRzXG4gICAgICAgIGVsOiByb290RWwsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMpXG4gICAgfVxuICB9XG5cbiAgcmVuZGVyRW1wdHlNZXNzYWdlKCkge1xuICAgIGxldCB7IG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCBob29rUHJvcHM6IE5vRXZlbnRzQ29udGVudEFyZyA9IHtcbiAgICAgIHRleHQ6IG9wdGlvbnMubm9FdmVudHNUZXh0LFxuICAgICAgdmlldzogdmlld0FwaSxcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFJlbmRlckhvb2s8Tm9FdmVudHNDb250ZW50QXJnPiAvLyBuZWVkZWQ/Pz9cbiAgICAgICAgaG9va1Byb3BzPXtob29rUHJvcHN9XG4gICAgICAgIGNsYXNzTmFtZXM9e29wdGlvbnMubm9FdmVudHNDbGFzc05hbWVzfVxuICAgICAgICBjb250ZW50PXtvcHRpb25zLm5vRXZlbnRzQ29udGVudH1cbiAgICAgICAgZGVmYXVsdENvbnRlbnQ9e3JlbmRlck5vRXZlbnRzSW5uZXJ9XG4gICAgICAgIGRpZE1vdW50PXtvcHRpb25zLm5vRXZlbnRzRGlkTW91bnR9XG4gICAgICAgIHdpbGxVbm1vdW50PXtvcHRpb25zLm5vRXZlbnRzV2lsbFVubW91bnR9XG4gICAgICA+XG4gICAgICAgIHsocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpID0+IChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17WydmYy1saXN0LWVtcHR5J10uY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKX0gcmVmPXtyb290RWxSZWZ9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmYy1saXN0LWVtcHR5LWN1c2hpb25cIiByZWY9e2lubmVyRWxSZWZ9PlxuICAgICAgICAgICAgICB7aW5uZXJDb250ZW50fVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L1JlbmRlckhvb2s+XG4gICAgKVxuICB9XG5cbiAgcmVuZGVyU2VnTGlzdChhbGxTZWdzOiBTZWdbXSwgZGF5RGF0ZXM6IERhdGVNYXJrZXJbXSkge1xuICAgIGxldCB7IHRoZW1lLCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHRcbiAgICBsZXQgc2Vnc0J5RGF5ID0gZ3JvdXBTZWdzQnlEYXkoYWxsU2VncykgLy8gc3BhcnNlIGFycmF5XG5cbiAgICByZXR1cm4gKFxuICAgICAgPE5vd1RpbWVyIHVuaXQ9XCJkYXlcIj5cbiAgICAgICAgeyhub3dEYXRlOiBEYXRlTWFya2VyLCB0b2RheVJhbmdlOiBEYXRlUmFuZ2UpID0+IHtcbiAgICAgICAgICBsZXQgaW5uZXJOb2RlczogVk5vZGVbXSA9IFtdXG5cbiAgICAgICAgICBmb3IgKGxldCBkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgc2Vnc0J5RGF5Lmxlbmd0aDsgZGF5SW5kZXggKz0gMSkge1xuICAgICAgICAgICAgbGV0IGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdXG5cbiAgICAgICAgICAgIGlmIChkYXlTZWdzKSB7IC8vIHNwYXJzZSBhcnJheSwgc28gbWlnaHQgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICAgIGxldCBkYXlTdHIgPSBkYXlEYXRlc1tkYXlJbmRleF0udG9JU09TdHJpbmcoKVxuXG4gICAgICAgICAgICAgIC8vIGFwcGVuZCBhIGRheSBoZWFkZXJcbiAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKFxuICAgICAgICAgICAgICAgIDxMaXN0Vmlld0hlYWRlclJvd1xuICAgICAgICAgICAgICAgICAga2V5PXtkYXlTdHJ9XG4gICAgICAgICAgICAgICAgICBkYXlEYXRlPXtkYXlEYXRlc1tkYXlJbmRleF19XG4gICAgICAgICAgICAgICAgICB0b2RheVJhbmdlPXt0b2RheVJhbmdlfVxuICAgICAgICAgICAgICAgIC8+LFxuICAgICAgICAgICAgICApXG5cbiAgICAgICAgICAgICAgZGF5U2VncyA9IHNvcnRFdmVudFNlZ3MoZGF5U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKVxuXG4gICAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBkYXlTZWdzKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJOb2Rlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgPExpc3RWaWV3RXZlbnRSb3dcbiAgICAgICAgICAgICAgICAgICAga2V5PXtkYXlTdHIgKyAnOicgKyBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkIC8qIGFyZSBtdWx0aXBsZSBzZWdzIGZvciBhbiBpbnN0YW5jZUlkICovfVxuICAgICAgICAgICAgICAgICAgICBzZWc9e3NlZ31cbiAgICAgICAgICAgICAgICAgICAgaXNEcmFnZ2luZz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgIGlzUmVzaXppbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICBpc0RhdGVTZWxlY3Rpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgey4uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKX1cbiAgICAgICAgICAgICAgICAgIC8+LFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8dGFibGUgY2xhc3NOYW1lPXsnZmMtbGlzdC10YWJsZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyl9PlxuICAgICAgICAgICAgICA8dGJvZHk+e2lubmVyTm9kZXN9PC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgKVxuICAgICAgICB9fVxuICAgICAgPC9Ob3dUaW1lcj5cbiAgICApXG4gIH1cblxuICBfZXZlbnRTdG9yZVRvU2VncyhldmVudFN0b3JlOiBFdmVudFN0b3JlLCBldmVudFVpQmFzZXM6IEV2ZW50VWlIYXNoLCBkYXlSYW5nZXM6IERhdGVSYW5nZVtdKTogU2VnW10ge1xuICAgIHJldHVybiB0aGlzLmV2ZW50UmFuZ2VzVG9TZWdzKFxuICAgICAgc2xpY2VFdmVudFN0b3JlKFxuICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICBldmVudFVpQmFzZXMsXG4gICAgICAgIHRoaXMucHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsXG4gICAgICAgIHRoaXMuY29udGV4dC5vcHRpb25zLm5leHREYXlUaHJlc2hvbGQsXG4gICAgICApLmZnLFxuICAgICAgZGF5UmFuZ2VzLFxuICAgIClcbiAgfVxuXG4gIGV2ZW50UmFuZ2VzVG9TZWdzKGV2ZW50UmFuZ2VzOiBFdmVudFJlbmRlclJhbmdlW10sIGRheVJhbmdlczogRGF0ZVJhbmdlW10pIHtcbiAgICBsZXQgc2VncyA9IFtdXG5cbiAgICBmb3IgKGxldCBldmVudFJhbmdlIG9mIGV2ZW50UmFuZ2VzKSB7XG4gICAgICBzZWdzLnB1c2goLi4udGhpcy5ldmVudFJhbmdlVG9TZWdzKGV2ZW50UmFuZ2UsIGRheVJhbmdlcykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZ3NcbiAgfVxuXG4gIGV2ZW50UmFuZ2VUb1NlZ3MoZXZlbnRSYW5nZTogRXZlbnRSZW5kZXJSYW5nZSwgZGF5UmFuZ2VzOiBEYXRlUmFuZ2VbXSkge1xuICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuY29udGV4dFxuICAgIGxldCB7IG5leHREYXlUaHJlc2hvbGQgfSA9IHRoaXMuY29udGV4dC5vcHRpb25zXG4gICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZVxuICAgIGxldCBhbGxEYXkgPSBldmVudFJhbmdlLmRlZi5hbGxEYXlcbiAgICBsZXQgZGF5SW5kZXhcbiAgICBsZXQgc2VnUmFuZ2VcbiAgICBsZXQgc2VnXG4gICAgbGV0IHNlZ3MgPSBbXVxuXG4gICAgZm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgZGF5UmFuZ2VzLmxlbmd0aDsgZGF5SW5kZXggKz0gMSkge1xuICAgICAgc2VnUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMocmFuZ2UsIGRheVJhbmdlc1tkYXlJbmRleF0pXG5cbiAgICAgIGlmIChzZWdSYW5nZSkge1xuICAgICAgICBzZWcgPSB7XG4gICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxuICAgICAgICAgIGV2ZW50UmFuZ2UsXG4gICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgIGVuZDogc2VnUmFuZ2UuZW5kLFxuICAgICAgICAgIGlzU3RhcnQ6IGV2ZW50UmFuZ2UuaXNTdGFydCAmJiBzZWdSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICBpc0VuZDogZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgIGRheUluZGV4LFxuICAgICAgICB9XG5cbiAgICAgICAgc2Vncy5wdXNoKHNlZylcblxuICAgICAgICAvLyBkZXRlY3Qgd2hlbiByYW5nZSB3b24ndCBnbyBmdWxseSBpbnRvIHRoZSBuZXh0IGRheSxcbiAgICAgICAgLy8gYW5kIG11dGF0ZSB0aGUgbGF0ZXN0IHNlZyB0byB0aGUgYmUgdGhlIGVuZC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFzZWcuaXNFbmQgJiYgIWFsbERheSAmJlxuICAgICAgICAgIGRheUluZGV4ICsgMSA8IGRheVJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgICByYW5nZS5lbmQgPFxuICAgICAgICAgICAgZGF0ZUVudi5hZGQoXG4gICAgICAgICAgICAgIGRheVJhbmdlc1tkYXlJbmRleCArIDFdLnN0YXJ0LFxuICAgICAgICAgICAgICBuZXh0RGF5VGhyZXNob2xkLFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICBzZWcuZW5kID0gcmFuZ2UuZW5kXG4gICAgICAgICAgc2VnLmlzRW5kID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2Vnc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck5vRXZlbnRzSW5uZXIoaG9va1Byb3BzKSB7XG4gIHJldHVybiBob29rUHJvcHMudGV4dFxufVxuXG5mdW5jdGlvbiBjb21wdXRlRGF0ZVZhcnMoZGF0ZVByb2ZpbGU6IERhdGVQcm9maWxlKSB7XG4gIGxldCBkYXlTdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2Uuc3RhcnQpXG4gIGxldCB2aWV3RW5kID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2UuZW5kXG4gIGxldCBkYXlEYXRlczogRGF0ZU1hcmtlcltdID0gW11cbiAgbGV0IGRheVJhbmdlczogRGF0ZVJhbmdlW10gPSBbXVxuXG4gIHdoaWxlIChkYXlTdGFydCA8IHZpZXdFbmQpIHtcbiAgICBkYXlEYXRlcy5wdXNoKGRheVN0YXJ0KVxuXG4gICAgZGF5UmFuZ2VzLnB1c2goe1xuICAgICAgc3RhcnQ6IGRheVN0YXJ0LFxuICAgICAgZW5kOiBhZGREYXlzKGRheVN0YXJ0LCAxKSxcbiAgICB9KVxuXG4gICAgZGF5U3RhcnQgPSBhZGREYXlzKGRheVN0YXJ0LCAxKVxuICB9XG5cbiAgcmV0dXJuIHsgZGF5RGF0ZXMsIGRheVJhbmdlcyB9XG59XG5cbi8vIFJldHVybnMgYSBzcGFyc2UgYXJyYXkgb2YgYXJyYXlzLCBzZWdzIGdyb3VwZWQgYnkgdGhlaXIgZGF5SW5kZXhcbmZ1bmN0aW9uIGdyb3VwU2Vnc0J5RGF5KHNlZ3MpOiBTZWdbXVtdIHtcbiAgbGV0IHNlZ3NCeURheSA9IFtdIC8vIHNwYXJzZSBhcnJheVxuICBsZXQgaVxuICBsZXQgc2VnXG5cbiAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBzZWcgPSBzZWdzW2ldO1xuICAgIChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSB8fCAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gPSBbXSkpXG4gICAgICAucHVzaChzZWcpXG4gIH1cblxuICByZXR1cm4gc2Vnc0J5RGF5XG59XG4iLCJpbXBvcnQge1xuICBpZGVudGl0eSxcbiAgSWRlbnRpdHksXG4gIENsYXNzTmFtZXNHZW5lcmF0b3IsXG4gIEN1c3RvbUNvbnRlbnRHZW5lcmF0b3IsXG4gIERpZE1vdW50SGFuZGxlcixcbiAgV2lsbFVubW91bnRIYW5kbGVyLFxuICBjcmVhdGVGb3JtYXR0ZXIsXG4gIEZvcm1hdHRlcklucHV0LFxufSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvbW1vbidcblxuLy8gcHVibGljXG5pbXBvcnQge1xuICBOb0V2ZW50c0NvbnRlbnRBcmcsXG4gIE5vRXZlbnRzTW91bnRBcmcsXG59IGZyb20gJy4vYXBpLXR5cGUtZGVwcydcblxuZXhwb3J0IGNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgbGlzdERheUZvcm1hdDogY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIsIC8vIGRlZmF1bHRzIHNwZWNpZmllZCBpbiBsaXN0IHBsdWdpbnNcbiAgbGlzdERheVNpZGVGb3JtYXQ6IGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyLCAvLyBcIlxuXG4gIG5vRXZlbnRzQ2xhc3NOYW1lczogaWRlbnRpdHkgYXMgSWRlbnRpdHk8Q2xhc3NOYW1lc0dlbmVyYXRvcjxOb0V2ZW50c0NvbnRlbnRBcmc+PixcbiAgbm9FdmVudHNDb250ZW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxDdXN0b21Db250ZW50R2VuZXJhdG9yPE5vRXZlbnRzQ29udGVudEFyZz4+LFxuICBub0V2ZW50c0RpZE1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxEaWRNb3VudEhhbmRsZXI8Tm9FdmVudHNNb3VudEFyZz4+LFxuICBub0V2ZW50c1dpbGxVbm1vdW50OiBpZGVudGl0eSBhcyBJZGVudGl0eTxXaWxsVW5tb3VudEhhbmRsZXI8Tm9FdmVudHNNb3VudEFyZz4+LFxuXG4gIC8vIG5vRXZlbnRzVGV4dCBpcyBkZWZpbmVkIGluIGJhc2Ugb3B0aW9uc1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcihpbnB1dDogRm9ybWF0dGVySW5wdXQgfCBmYWxzZSkge1xuICByZXR1cm4gaW5wdXQgPT09IGZhbHNlID8gbnVsbCA6IGNyZWF0ZUZvcm1hdHRlcihpbnB1dClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29tbW9uJ1xuaW1wb3J0IHsgTGlzdFZpZXcgfSBmcm9tICcuL0xpc3RWaWV3J1xuaW1wb3J0IHsgT1BUSU9OX1JFRklORVJTIH0gZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0ICcuL29wdGlvbnMtZGVjbGFyZSdcbmltcG9ydCAnLi9tYWluLmNzcydcblxuZXhwb3J0IHsgTGlzdFZpZXcgfVxuZXhwb3J0ICogZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVQbHVnaW4oe1xuICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICB2aWV3czoge1xuXG4gICAgbGlzdDoge1xuICAgICAgY29tcG9uZW50OiBMaXN0VmlldyxcbiAgICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JywgLy8gd2hhdCB0byBsb29rdXAgaW4gbG9jYWxlIGZpbGVzXG4gICAgICBsaXN0RGF5Rm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSwgLy8gbGlrZSBcIkphbnVhcnkgMSwgMjAxNlwiXG4gICAgfSxcblxuICAgIGxpc3REYXk6IHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgIGxpc3REYXlGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyVG9vbGJhclxuICAgIH0sXG5cbiAgICBsaXN0V2Vlazoge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgIGxpc3REYXlGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIG1vcmUgaW1wb3J0YW50XG4gICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgfSxcblxuICAgIGxpc3RNb250aDoge1xuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgZHVyYXRpb246IHsgbW9udGg6IDEgfSxcbiAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcbiAgICB9LFxuXG4gICAgbGlzdFllYXI6IHtcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcbiAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcbiAgICB9LFxuXG4gIH0sXG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/list/main.js\n");

/***/ }),

/***/ "./node_modules/preact/compat/dist/compat.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/preact/compat/dist/compat.module.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useCallback\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useCallback; },\n/* harmony export */   \"useContext\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useContext; },\n/* harmony export */   \"useDebugValue\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useDebugValue; },\n/* harmony export */   \"useEffect\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useEffect; },\n/* harmony export */   \"useErrorBoundary\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useErrorBoundary; },\n/* harmony export */   \"useImperativeHandle\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle; },\n/* harmony export */   \"useLayoutEffect\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect; },\n/* harmony export */   \"useMemo\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useMemo; },\n/* harmony export */   \"useReducer\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useReducer; },\n/* harmony export */   \"useRef\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useRef; },\n/* harmony export */   \"useState\": function() { return /* reexport safe */ preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useState; },\n/* harmony export */   \"createElement\": function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.createElement; },\n/* harmony export */   \"createContext\": function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.createContext; },\n/* harmony export */   \"createRef\": function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.createRef; },\n/* harmony export */   \"Fragment\": function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.Fragment; },\n/* harmony export */   \"Component\": function() { return /* reexport safe */ preact__WEBPACK_IMPORTED_MODULE_1__.Component; },\n/* harmony export */   \"version\": function() { return /* binding */ B; },\n/* harmony export */   \"Children\": function() { return /* binding */ R; },\n/* harmony export */   \"render\": function() { return /* binding */ T; },\n/* harmony export */   \"hydrate\": function() { return /* binding */ V; },\n/* harmony export */   \"unmountComponentAtNode\": function() { return /* binding */ Q; },\n/* harmony export */   \"createPortal\": function() { return /* binding */ z; },\n/* harmony export */   \"createFactory\": function() { return /* binding */ G; },\n/* harmony export */   \"cloneElement\": function() { return /* binding */ K; },\n/* harmony export */   \"isValidElement\": function() { return /* binding */ J; },\n/* harmony export */   \"findDOMNode\": function() { return /* binding */ X; },\n/* harmony export */   \"PureComponent\": function() { return /* binding */ C; },\n/* harmony export */   \"memo\": function() { return /* binding */ _; },\n/* harmony export */   \"forwardRef\": function() { return /* binding */ S; },\n/* harmony export */   \"unstable_batchedUpdates\": function() { return /* binding */ Y; },\n/* harmony export */   \"Suspense\": function() { return /* binding */ U; },\n/* harmony export */   \"SuspenseList\": function() { return /* binding */ O; },\n/* harmony export */   \"lazy\": function() { return /* binding */ L; }\n/* harmony export */ });\n/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact/hooks */ \"./node_modules/preact/hooks/dist/hooks.module.js\");\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\n\n\n\n\nfunction E(n, t) {\n  for (var e in t) {\n    n[e] = t[e];\n  }\n\n  return n;\n}\n\nfunction w(n, t) {\n  for (var e in n) {\n    if (\"__source\" !== e && !(e in t)) return !0;\n  }\n\n  for (var r in t) {\n    if (\"__source\" !== r && n[r] !== t[r]) return !0;\n  }\n\n  return !1;\n}\n\nvar C = function (n) {\n  var t, e;\n\n  function r(t) {\n    var e;\n    return (e = n.call(this, t) || this).isPureReactComponent = !0, e;\n  }\n\n  return e = n, (t = r).prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e, r.prototype.shouldComponentUpdate = function (n, t) {\n    return w(this.props, n) || w(this.state, t);\n  }, r;\n}(preact__WEBPACK_IMPORTED_MODULE_1__.Component);\n\nfunction _(n, t) {\n  function e(n) {\n    var e = this.props.ref,\n        r = e == n.ref;\n    return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : w(this.props, n);\n  }\n\n  function r(t) {\n    return this.shouldComponentUpdate = e, (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(n, E({}, t));\n  }\n\n  return r.prototype.isReactComponent = !0, r.displayName = \"Memo(\" + (n.displayName || n.name) + \")\", r.t = !0, r;\n}\n\nvar A = preact__WEBPACK_IMPORTED_MODULE_1__.options.__b;\n\nfunction S(n) {\n  function t(t) {\n    var e = E({}, t);\n    return delete e.ref, n(e, t.ref);\n  }\n\n  return t.prototype.isReactComponent = t.t = !0, t.displayName = \"ForwardRef(\" + (n.displayName || n.name) + \")\", t;\n}\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.__b = function (n) {\n  n.type && n.type.t && n.ref && (n.props.ref = n.ref, n.ref = null), A && A(n);\n};\n\nvar k = function k(n, t) {\n  return n ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n).reduce(function (n, e, r) {\n    return n.concat(t(e, r));\n  }, []) : null;\n},\n    R = {\n  map: k,\n  forEach: k,\n  count: function count(n) {\n    return n ? (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n).length : 0;\n  },\n  only: function only(n) {\n    if (1 !== (n = (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n)).length) throw new Error(\"Children.only() expects only one child.\");\n    return n[0];\n  },\n  toArray: preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray\n},\n    F = preact__WEBPACK_IMPORTED_MODULE_1__.options.__e;\n\nfunction N(n) {\n  return n && ((n = E({}, n)).__c = null, n.__k = n.__k && n.__k.map(N)), n;\n}\n\nfunction U() {\n  this.__u = 0, this.o = null, this.__b = null;\n}\n\nfunction M(n) {\n  var t = n.__.__c;\n  return t && t.u && t.u(n);\n}\n\nfunction L(n) {\n  var t, e, r;\n\n  function o(o) {\n    if (t || (t = n()).then(function (n) {\n      e = n[\"default\"] || n;\n    }, function (n) {\n      r = n;\n    }), r) throw r;\n    if (!e) throw t;\n    return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(e, o);\n  }\n\n  return o.displayName = \"Lazy\", o.t = !0, o;\n}\n\nfunction O() {\n  this.i = null, this.l = null;\n}\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.__e = function (n, t, e) {\n  if (n.then) for (var r, o = t; o = o.__;) {\n    if ((r = o.__c) && r.__c) return r.__c(n, t.__c);\n  }\n  F(n, t, e);\n}, (U.prototype = new preact__WEBPACK_IMPORTED_MODULE_1__.Component()).__c = function (n, t) {\n  var e = this;\n  null == e.o && (e.o = []), e.o.push(t);\n\n  var r = M(e.__v),\n      o = !1,\n      u = function u() {\n    o || (o = !0, r ? r(i) : i());\n  };\n\n  t.__c = t.componentWillUnmount, t.componentWillUnmount = function () {\n    u(), t.__c && t.__c();\n  };\n\n  var i = function i() {\n    var n;\n    if (! --e.__u) for (e.__v.__k[0] = e.state.u, e.setState({\n      u: e.__b = null\n    }); n = e.o.pop();) {\n      n.forceUpdate();\n    }\n  };\n\n  e.__u++ || e.setState({\n    u: e.__b = e.__v.__k[0]\n  }), n.then(u, u);\n}, U.prototype.render = function (n, t) {\n  return this.__b && (this.__v.__k[0] = N(this.__b), this.__b = null), [(0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(preact__WEBPACK_IMPORTED_MODULE_1__.Component, null, t.u ? null : n.children), t.u && n.fallback];\n};\n\nvar P = function P(n, t, e) {\n  if (++e[1] === e[0] && n.l[\"delete\"](t), n.props.revealOrder && (\"t\" !== n.props.revealOrder[0] || !n.l.size)) for (e = n.i; e;) {\n    for (; e.length > 3;) {\n      e.pop()();\n    }\n\n    if (e[1] < e[0]) break;\n    n.i = e = e[2];\n  }\n};\n\n(O.prototype = new preact__WEBPACK_IMPORTED_MODULE_1__.Component()).u = function (n) {\n  var t = this,\n      e = M(t.__v),\n      r = t.l.get(n);\n  return r[0]++, function (o) {\n    var u = function u() {\n      t.props.revealOrder ? (r.push(o), P(t, n, r)) : o();\n    };\n\n    e ? e(u) : u();\n  };\n}, O.prototype.render = function (n) {\n  this.i = null, this.l = new Map();\n  var t = (0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(n.children);\n  n.revealOrder && \"b\" === n.revealOrder[0] && t.reverse();\n\n  for (var e = t.length; e--;) {\n    this.l.set(t[e], this.i = [1, 0, this.i]);\n  }\n\n  return n.children;\n}, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function () {\n  var n = this;\n  n.l.forEach(function (t, e) {\n    P(n, e, t);\n  });\n};\n\nvar W = function () {\n  function n() {}\n\n  var t = n.prototype;\n  return t.getChildContext = function () {\n    return this.props.context;\n  }, t.render = function (n) {\n    return n.children;\n  }, n;\n}();\n\nfunction j(n) {\n  var t = this,\n      e = n.container,\n      r = (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(W, {\n    context: t.context\n  }, n.vnode);\n  return t.s && t.s !== e && (t.v.parentNode && t.s.removeChild(t.v), (0,preact__WEBPACK_IMPORTED_MODULE_1__._unmount)(t.h), t.p = !1), n.vnode ? t.p ? (e.__k = t.__k, (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(r, e), t.__k = e.__k) : (t.v = document.createTextNode(\"\"), (0,preact__WEBPACK_IMPORTED_MODULE_1__.hydrate)(\"\", e), e.appendChild(t.v), t.p = !0, t.s = e, (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(r, e, t.v), t.__k = t.v.__k) : t.p && (t.v.parentNode && t.s.removeChild(t.v), (0,preact__WEBPACK_IMPORTED_MODULE_1__._unmount)(t.h)), t.h = r, t.componentWillUnmount = function () {\n    t.v.parentNode && t.s.removeChild(t.v), (0,preact__WEBPACK_IMPORTED_MODULE_1__._unmount)(t.h);\n  }, null;\n}\n\nfunction z(n, t) {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_1__.createElement)(j, {\n    vnode: n,\n    container: t\n  });\n}\n\nvar D = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\npreact__WEBPACK_IMPORTED_MODULE_1__.Component.prototype.isReactComponent = {};\nvar H = \"undefined\" != typeof Symbol && Symbol[\"for\"] && Symbol[\"for\"](\"react.element\") || 60103;\n\nfunction T(n, t, e) {\n  if (null == t.__k) for (; t.firstChild;) {\n    t.removeChild(t.firstChild);\n  }\n  return (0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(n, t), \"function\" == typeof e && e(), n ? n.__c : null;\n}\n\nfunction V(n, t, e) {\n  return (0,preact__WEBPACK_IMPORTED_MODULE_1__.hydrate)(n, t), \"function\" == typeof e && e(), n ? n.__c : null;\n}\n\nvar Z = preact__WEBPACK_IMPORTED_MODULE_1__.options.event;\n\nfunction I(n, t) {\n  n[\"UNSAFE_\" + t] && !n[t] && Object.defineProperty(n, t, {\n    configurable: !1,\n    get: function get() {\n      return this[\"UNSAFE_\" + t];\n    },\n    set: function set(n) {\n      this[\"UNSAFE_\" + t] = n;\n    }\n  });\n}\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.event = function (n) {\n  Z && (n = Z(n)), n.persist = function () {};\n  var t = !1,\n      e = !1,\n      r = n.stopPropagation;\n\n  n.stopPropagation = function () {\n    r.call(n), t = !0;\n  };\n\n  var o = n.preventDefault;\n  return n.preventDefault = function () {\n    o.call(n), e = !0;\n  }, n.isPropagationStopped = function () {\n    return t;\n  }, n.isDefaultPrevented = function () {\n    return e;\n  }, n.nativeEvent = n;\n};\n\nvar $ = {\n  configurable: !0,\n  get: function get() {\n    return this[\"class\"];\n  }\n},\n    q = preact__WEBPACK_IMPORTED_MODULE_1__.options.vnode;\n\npreact__WEBPACK_IMPORTED_MODULE_1__.options.vnode = function (n) {\n  n.$$typeof = H;\n  var t = n.type,\n      e = n.props;\n\n  if (t) {\n    if (e[\"class\"] != e.className && ($.enumerable = \"className\" in e, null != e.className && (e[\"class\"] = e.className), Object.defineProperty(e, \"className\", $)), \"function\" != typeof t) {\n      var r, o, u;\n\n      for (u in e.defaultValue && void 0 !== e.value && (e.value || 0 === e.value || (e.value = e.defaultValue), delete e.defaultValue), Array.isArray(e.value) && e.multiple && \"select\" === t && ((0,preact__WEBPACK_IMPORTED_MODULE_1__.toChildArray)(e.children).forEach(function (n) {\n        -1 != e.value.indexOf(n.props.value) && (n.props.selected = !0);\n      }), delete e.value), e) {\n        if (r = D.test(u)) break;\n      }\n\n      if (r) for (u in o = n.props = {}, e) {\n        o[D.test(u) ? u.replace(/[A-Z0-9]/, \"-$&\").toLowerCase() : u] = e[u];\n      }\n    }\n\n    !function (t) {\n      var e = n.type,\n          r = n.props;\n\n      if (r && \"string\" == typeof e) {\n        var o = {};\n\n        for (var u in r) {\n          /^on(Ani|Tra|Tou)/.test(u) && (r[u.toLowerCase()] = r[u], delete r[u]), o[u.toLowerCase()] = u;\n        }\n\n        if (o.ondoubleclick && (r.ondblclick = r[o.ondoubleclick], delete r[o.ondoubleclick]), o.onbeforeinput && (r.onbeforeinput = r[o.onbeforeinput], delete r[o.onbeforeinput]), o.onchange && (\"textarea\" === e || \"input\" === e.toLowerCase() && !/^fil|che|ra/i.test(r.type))) {\n          var i = o.oninput || \"oninput\";\n          r[i] || (r[i] = r[o.onchange], delete r[o.onchange]);\n        }\n      }\n    }(), \"function\" == typeof t && !t.m && t.prototype && (I(t.prototype, \"componentWillMount\"), I(t.prototype, \"componentWillReceiveProps\"), I(t.prototype, \"componentWillUpdate\"), t.m = !0);\n  }\n\n  q && q(n);\n};\n\nvar B = \"16.8.0\";\n\nfunction G(n) {\n  return preact__WEBPACK_IMPORTED_MODULE_1__.createElement.bind(null, n);\n}\n\nfunction J(n) {\n  return !!n && n.$$typeof === H;\n}\n\nfunction K(n) {\n  return J(n) ? preact__WEBPACK_IMPORTED_MODULE_1__.cloneElement.apply(null, arguments) : n;\n}\n\nfunction Q(n) {\n  return !!n.__k && ((0,preact__WEBPACK_IMPORTED_MODULE_1__.render)(null, n), !0);\n}\n\nfunction X(n) {\n  return n && (n.base || 1 === n.nodeType && n) || null;\n}\n\nvar Y = function Y(n, t) {\n  return n(t);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  useState: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useState,\n  useReducer: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useReducer,\n  useEffect: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useEffect,\n  useLayoutEffect: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect,\n  useRef: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useRef,\n  useImperativeHandle: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle,\n  useMemo: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useMemo,\n  useCallback: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useCallback,\n  useContext: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useContext,\n  useDebugValue: preact_hooks__WEBPACK_IMPORTED_MODULE_0__.useDebugValue,\n  version: \"16.8.0\",\n  Children: R,\n  render: T,\n  hydrate: T,\n  unmountComponentAtNode: Q,\n  createPortal: z,\n  createElement: preact__WEBPACK_IMPORTED_MODULE_1__.createElement,\n  createContext: preact__WEBPACK_IMPORTED_MODULE_1__.createContext,\n  createFactory: G,\n  cloneElement: K,\n  createRef: preact__WEBPACK_IMPORTED_MODULE_1__.createRef,\n  Fragment: preact__WEBPACK_IMPORTED_MODULE_1__.Fragment,\n  isValidElement: J,\n  findDOMNode: X,\n  Component: preact__WEBPACK_IMPORTED_MODULE_1__.Component,\n  PureComponent: C,\n  memo: _,\n  forwardRef: S,\n  unstable_batchedUpdates: Y,\n  Suspense: U,\n  SuspenseList: O,\n  lazy: L\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9kaXN0L2NvbXBhdC5tb2R1bGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQURBOztBQUNBO0FBVUE7O0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBQ0E7QUFDQTtBQURBOztBQUNBO0FBQ0E7O0FBQUE7QUNmQTs7QUFBQTtBQUNBO0FBQUE7QUFHQTs7QUFBQTtBQUdBO0FBRUE7QUFUQTs7QUNJQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBTUE7O0FBQUE7QUFNQTtBQUVBOztBQUFBO0FDeEJBOztBQUFBOztBQWdCQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQUFBO0FBbkJBOztBQUFBO0FBQ0E7QUFJQTs7QUFBQTtBQ1BBO0FBR0E7QUFBQTtBQUZBO0FETUE7QUNHQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUdBO0FBRUE7QUFFQTtBQWJBO0FERkE7O0FFV0E7QUFBQTtBQVVBOztBQUFBO0FBQUE7QUFpR0E7O0FBQUE7QUFBQTtBQUNBO0FBSUE7O0FBQUE7QUFBQTs7QUFHQTtBQUVBO0FBS0E7QUFBQTtBQUdBO0FBQUE7QUFNQTtBQUlBO0FBR0E7O0FBQUE7QUNySkE7O0FBQUE7QUFBQTtBRExBOztBQUFBO0FBQUE7QUFNQTtBQUxBO0FBWUE7QUFBQTtBQTZCQTtBQUlBOztBQUdBO0FBQUE7QUFBQTtBQU1BO0FBT0E7O0FBSUE7QUFHQTtBQUdBOztBQUFBO0FBSUE7QUFLQTtBQUZBO0FBQUE7QUFJQTtBQU5BO0FBTUE7O0FBS0E7QUFDQTtBQUFBO0FBRUE7QUFHQTtBQVFBOztBQ3hGQTtBQUFBO0FBeUJBO0FBRUE7QUFGQTs7QUFFQTtBQUtBO0FBNUNBO0FBQUE7O0FBQUE7QUFxREE7QUFBQTtBQUFBO0FBSUE7QUFHQTtBQUVBO0FBR0E7O0FBTUE7QUFHQTtBQUFBO0FBS0E7QUFFQTtBQUdBOztBQUlBO0FBSUE7QUFKQTs7QUFnQkE7QUFFQTtBQUdBO0FBUUE7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUMxSEE7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7O0FBUUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFpREE7QUFDQTtBQVdBOztBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUMxRUE7O0FBQUE7QUFHQTtBQUVBOztBQVdBO0FBQUE7QUFLQTtBQUZBO0FBRUE7QUFVQTs7QUFBQTtBQUFBO0FBT0E7O0FBQUE7O0FBeUJBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQVZBO0FBMUJBOztBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBS0E7QUFDQTtBQUNBOztBQUFBO0FBR0E7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7QUFzQkE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUhBO0FBQUE7O0FBUUE7QUFDQTtBQUFBO0FBQUE7O0FBR0E7QUFFQTtBQVNBOztBQW9CQTtBQVRBO0FBRUE7QUFRQTtBQURBOztBQUNBO0FBSUE7QUFIQTtBQUtBOztBQUFBO0FDeElBO0FBQUE7O0FBQUE7QUFDQTs7QUFDQTtBQUdBO0FBSEE7O0FBT0E7QUFlQTtBQUVBO0FBRUE7QUFBQTtBRGtIQTtBQWtCQTs7QUFBQTtBQUFBOztBQUFBOztBRWhJQTtBQUFBO0FBU0E7O0FBQUE7QUFBQTtBQVdBOztBQUFBO0FBQUE7QUFVQTs7QUFBQTtBQUFBO0FBYUE7O0FBQUE7QUFBQTtBQWdCQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlsLmpzPzQyMjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL1B1cmVDb21wb25lbnQuanM/ZGU5ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvbWVtby5qcz82NDkyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9mb3J3YXJkUmVmLmpzPzA3YTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL0NoaWxkcmVuLmpzP2YwMWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3N1c3BlbnNlLmpzPzE0NGYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3N1c3BlbnNlLWxpc3QuanM/MGRlMyIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcG9ydGFscy5qcz80NjNlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZW5kZXIuanM/NTBmZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvZXZlbnRzLmpzP2NlOTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2luZGV4LmpzP2ExNzgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBvYmplY3RzIGhhdmUgYSBkaWZmZXJlbnQgc2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XG5cdGZvciAobGV0IGkgaW4gYSkgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgIShpIGluIGIpKSByZXR1cm4gdHJ1ZTtcblx0Zm9yIChsZXQgaSBpbiBiKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiBhW2ldICE9PSBiW2ldKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIFB1cmVDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHQvLyBTb21lIHRoaXJkLXBhcnR5IGxpYnJhcmllcyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IGlzIHByZXNlbnRcblx0XHR0aGlzLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblx0fVxuXG5cdHNob3VsZENvbXBvbmVudFVwZGF0ZShwcm9wcywgc3RhdGUpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0c2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKVxuXHRcdCk7XG5cdH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMsIGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogTWVtb2l6ZSBhIGNvbXBvbmVudCwgc28gdGhhdCBpdCBvbmx5IHVwZGF0ZXMgd2hlbiB0aGUgcHJvcHMgYWN0dWFsbHkgaGF2ZVxuICogY2hhbmdlZC4gVGhpcyB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgUmVhY3QucHVyZWAuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uYWxDb21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uYWxDb21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vKGMsIGNvbXBhcmVyKSB7XG5cdGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShuZXh0UHJvcHMpIHtcblx0XHRsZXQgcmVmID0gdGhpcy5wcm9wcy5yZWY7XG5cdFx0bGV0IHVwZGF0ZVJlZiA9IHJlZiA9PSBuZXh0UHJvcHMucmVmO1xuXHRcdGlmICghdXBkYXRlUmVmICYmIHJlZikge1xuXHRcdFx0cmVmLmNhbGwgPyByZWYobnVsbCkgOiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBhcmVyKSB7XG5cdFx0XHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgbmV4dFByb3BzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIWNvbXBhcmVyKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHwgIXVwZGF0ZVJlZjtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lbW9lZChwcm9wcykge1xuXHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gc2hvdWxkVXBkYXRlO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGMsIGFzc2lnbih7fSwgcHJvcHMpKTtcblx0fVxuXHRNZW1vZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHRNZW1vZWQuZGlzcGxheU5hbWUgPSAnTWVtbygnICsgKGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lKSArICcpJztcblx0TWVtb2VkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTWVtb2VkO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5sZXQgb2xkRGlmZkhvb2sgPSBvcHRpb25zLl9kaWZmO1xub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0aWYgKHZub2RlLnR5cGUgJiYgdm5vZGUudHlwZS5fZm9yd2FyZGVkICYmIHZub2RlLnJlZikge1xuXHRcdHZub2RlLnByb3BzLnJlZiA9IHZub2RlLnJlZjtcblx0XHR2bm9kZS5yZWYgPSBudWxsO1xuXHR9XG5cdGlmIChvbGREaWZmSG9vaykgb2xkRGlmZkhvb2sodm5vZGUpO1xufTtcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbmFsQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmKTtcblx0fVxuXHRGb3J3YXJkZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSBGb3J3YXJkZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdEZvcndhcmRlZC5kaXNwbGF5TmFtZSA9ICdGb3J3YXJkUmVmKCcgKyAoZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSkgKyAnKSc7XG5cdHJldHVybiBGb3J3YXJkZWQ7XG59XG4iLCJpbXBvcnQgeyB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuXG5jb25zdCBtYXBGbiA9IChjaGlsZHJlbiwgZm4pID0+IHtcblx0aWYgKCFjaGlsZHJlbikgcmV0dXJuIG51bGw7XG5cdHJldHVybiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLnJlZHVjZShcblx0XHQoYWNjLCB2YWx1ZSwgaW5kZXgpID0+IGFjYy5jb25jYXQoZm4odmFsdWUsIGluZGV4KSksXG5cdFx0W11cblx0KTtcbn07XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG5cdG1hcDogbWFwRm4sXG5cdGZvckVhY2g6IG1hcEZuLFxuXHRjb3VudChjaGlsZHJlbikge1xuXHRcdHJldHVybiBjaGlsZHJlbiA/IHRvQ2hpbGRBcnJheShjaGlsZHJlbikubGVuZ3RoIDogMDtcblx0fSxcblx0b25seShjaGlsZHJlbikge1xuXHRcdGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KGNoaWxkcmVuKTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkcmVuLm9ubHkoKSBleHBlY3RzIG9ubHkgb25lIGNoaWxkLicpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2hpbGRyZW5bMF07XG5cdH0sXG5cdHRvQXJyYXk6IHRvQ2hpbGRBcnJheVxufTtcbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdC8vIERvbid0IGNhbGwgb2xkQ2F0Y2hFcnJvciBpZiB3ZSBmb3VuZCBhIFN1c3BlbnNlXG5cdFx0XHRcdHJldHVybiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZChlcnJvciwgbmV3Vk5vZGUuX2NvbXBvbmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdHZub2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0dm5vZGUuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0dm5vZGUuX2NoaWxkcmVuID0gdm5vZGUuX2NoaWxkcmVuICYmIHZub2RlLl9jaGlsZHJlbi5tYXAoZGV0YWNoZWRDbG9uZSk7XG5cdH1cblx0cmV0dXJuIHZub2RlO1xufVxuXG4vLyBoYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2UoKSB7XG5cdC8vIHdlIGRvIG5vdCBjYWxsIHN1cGVyIGhlcmUgdG8gZ29sZiBzb21lIGJ5dGVzLi4uXG5cdHRoaXMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQgPSAwO1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gbnVsbDtcblx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcbn1cblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgdGhyb3duIHByb21pc2VcbiAqIEBwYXJhbSB7Q29tcG9uZW50PGFueSwgYW55Pn0gc3VzcGVuZGluZ0NvbXBvbmVudCBUaGUgc3VzcGVuZGluZyBjb21wb25lbnRcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLl9jaGlsZERpZFN1c3BlbmQgPSBmdW5jdGlvbihwcm9taXNlLCBzdXNwZW5kaW5nQ29tcG9uZW50KSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9ICovXG5cdGNvbnN0IGMgPSB0aGlzO1xuXG5cdGlmIChjLl9zdXNwZW5kZXJzID09IG51bGwpIHtcblx0XHRjLl9zdXNwZW5kZXJzID0gW107XG5cdH1cblx0Yy5fc3VzcGVuZGVycy5wdXNoKHN1c3BlbmRpbmdDb21wb25lbnQpO1xuXG5cdGNvbnN0IHJlc29sdmUgPSBzdXNwZW5kZWQoYy5fdm5vZGUpO1xuXG5cdGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXHRjb25zdCBvblJlc29sdmVkID0gKCkgPT4ge1xuXHRcdGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuXG5cdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9zdXNwZW5kZWRDb21wb25lbnRXaWxsVW5tb3VudCA9XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0c3VzcGVuZGluZ0NvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRvblJlc29sdmVkKCk7XG5cblx0XHRpZiAoc3VzcGVuZGluZ0NvbXBvbmVudC5fc3VzcGVuZGVkQ29tcG9uZW50V2lsbFVubW91bnQpIHtcblx0XHRcdHN1c3BlbmRpbmdDb21wb25lbnQuX3N1c3BlbmRlZENvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBjLnN0YXRlLl9zdXNwZW5kZWQ7XG5cdFx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGwpIH0pO1xuXG5cdFx0XHRsZXQgc3VzcGVuZGVkO1xuXHRcdFx0d2hpbGUgKChzdXNwZW5kZWQgPSBjLl9zdXNwZW5kZXJzLnBvcCgpKSkge1xuXHRcdFx0XHRzdXNwZW5kZWQuZm9yY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0aWYgKCFjLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KyspIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZSh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpO1xuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdGNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRzdGF0ZS5fc3VzcGVuZGVkICYmIHByb3BzLmZhbGxiYWNrXG5cdF07XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgY2FsbHMgdGhlIHBhcmVudCBjb21wb25lbnQncyBfc3VzcGVuZGVkIG1ldGhvZCwgcGFzc2luZyBpbiB0aGVcbiAqIHN1c3BlbmRlZCB2bm9kZS4gVGhpcyBpcyBhIHdheSBmb3IgYSBwYXJlbnQgKGUuZy4gU3VzcGVuc2VMaXN0KSB0byBnZXQgbm90aWZpZWRcbiAqIHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbi9kZXNjZW5kYW50cyBzdXNwZW5kZWQuXG4gKlxuICogVGhlIHBhcmVudCBNQVkgcmV0dXJuIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIHN1c3BlbnNpb24gcmVzb2x2ZXMsIG5vdGlmeWluZyB0aGUgcGFyZW50IG9mIHRoZSBmYWN0LlxuICogTW9yZW92ZXIsIHRoZSBjYWxsYmFjayBnZXRzIGZ1bmN0aW9uIGB1bnN1c3BlbmRgIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzb2x2ZWRcbiAqIGNoaWxkIGRlc2NlbmRhbnQgd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHVuc3VzcGVuZGVkIHVudGlsIGB1bnN1c3BlbmRgIGdldHMgY2FsbGVkLlxuICogVGhpcyBpcyBhIHdheSBmb3IgdGhlIHBhcmVudCB0byBkZWxheSB1bnN1c3BlbmRpbmcuXG4gKlxuICogSWYgdGhlIHBhcmVudCBkb2VzIG5vdCByZXR1cm4gYSBjYWxsYmFjayB0aGVuIHRoZSByZXNvbHZlZCB2bm9kZVxuICogZ2V0cyB1bnN1c3BlbmRlZCBpbW1lZGlhdGVseSB3aGVuIGl0IHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9zcmMvaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHsoKHVuc3VzcGVuZDogKCkgPT4gdm9pZCkgPT4gdm9pZCk/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZGVkKHZub2RlKSB7XG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0bGlzdC5fbWFwLmZvckVhY2goKG5vZGUsIGNoaWxkKSA9PiB7XG5cdFx0cmVzb2x2ZShsaXN0LCBjaGlsZCwgbm9kZSk7XG5cdH0pO1xufTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGh5ZHJhdGUsIHJlbmRlciwgX3VubW91bnQgfSBmcm9tICdwcmVhY3QnO1xuXG5jbGFzcyBDb250ZXh0UHJvdmlkZXIge1xuXHRnZXRDaGlsZENvbnRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvcHMuY29udGV4dDtcblx0fVxuXHRyZW5kZXIocHJvcHMpIHtcblx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdH1cbn1cblxuLyoqXG4gKiBQb3J0YWwgY29tcG9uZW50XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3BzXG4gKi9cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuXHRsZXQgX3RoaXMgPSB0aGlzO1xuXHRsZXQgY29udGFpbmVyID0gcHJvcHMuY29udGFpbmVyO1xuXHRsZXQgd3JhcCA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0Q29udGV4dFByb3ZpZGVyLFxuXHRcdHsgY29udGV4dDogX3RoaXMuY29udGV4dCB9LFxuXHRcdHByb3BzLnZub2RlXG5cdCk7XG5cblx0Ly8gV2hlbiB3ZSBjaGFuZ2UgY29udGFpbmVyIHdlIHNob3VsZCBjbGVhciBvdXIgb2xkIGNvbnRhaW5lciBhbmRcblx0Ly8gaW5kaWNhdGUgYSBuZXcgbW91bnQuXG5cdGlmIChfdGhpcy5fY29udGFpbmVyICYmIF90aGlzLl9jb250YWluZXIgIT09IGNvbnRhaW5lcikge1xuXHRcdGlmIChfdGhpcy5fdGVtcC5wYXJlbnROb2RlKSBfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKF90aGlzLl90ZW1wKTtcblx0XHRfdW5tb3VudChfdGhpcy5fd3JhcCk7XG5cdFx0X3RoaXMuX2hhc01vdW50ZWQgPSBmYWxzZTtcblx0fVxuXG5cdC8vIFdoZW4gcHJvcHMudm5vZGUgaXMgdW5kZWZpbmVkL2ZhbHNlL251bGwgd2UgYXJlIGRlYWxpbmcgd2l0aCBzb21lIGtpbmQgb2Zcblx0Ly8gY29uZGl0aW9uYWwgdm5vZGUuIFRoaXMgc2hvdWxkIG5vdCB0cmlnZ2VyIGEgcmVuZGVyLlxuXHRpZiAocHJvcHMudm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl9oYXNNb3VudGVkKSB7XG5cdFx0XHQvLyBDcmVhdGUgYSBwbGFjZWhvbGRlciB0aGF0IHdlIGNhbiB1c2UgdG8gaW5zZXJ0IGludG8uXG5cdFx0XHRfdGhpcy5fdGVtcCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcblx0XHRcdC8vIEh5ZHJhdGUgZXhpc3Rpbmcgbm9kZXMgdG8ga2VlcCB0aGUgZG9tIGludGFjdCwgd2hlbiByZW5kZXJpbmdcblx0XHRcdC8vIHdyYXAgaW50byB0aGUgY29udGFpbmVyLlxuXHRcdFx0aHlkcmF0ZSgnJywgY29udGFpbmVyKTtcblx0XHRcdC8vIEFwcGVuZCB0byB0aGUgY29udGFpbmVyICh0aGlzIG1hdGNoZXMgUmVhY3QncyBiZWhhdmlvcilcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChfdGhpcy5fdGVtcCk7XG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgbW91bnRlZCBhbmQgc2hvdWxkIHNldCBvdXIgY29udGFpbmVyLlxuXHRcdFx0X3RoaXMuX2hhc01vdW50ZWQgPSB0cnVlO1xuXHRcdFx0X3RoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcblx0XHRcdC8vIFJlbmRlciBvdXIgd3JhcHBpbmcgZWxlbWVudCBpbnRvIHRlbXAuXG5cdFx0XHRyZW5kZXIod3JhcCwgY29udGFpbmVyLCBfdGhpcy5fdGVtcCk7XG5cdFx0XHRfdGhpcy5fY2hpbGRyZW4gPSBfdGhpcy5fdGVtcC5fY2hpbGRyZW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBtb3VudGVkIGFuZCB0aGUgdm5vZGUgaXMgcHJlc2VudCBpdCBtZWFucyB0aGVcblx0XHRcdC8vIHByb3BzIGhhdmUgY2hhbmdlZCBvciBhIHBhcmVudCBpcyB0cmlnZ2VyaW5nIGEgcmVyZW5kZXIuXG5cdFx0XHQvLyBUaGlzIGltcGxpZXMgd2Ugb25seSBuZWVkIHRvIGNhbGwgcmVuZGVyLiBCdXQgd2UgbmVlZCB0byBrZWVwXG5cdFx0XHQvLyB0aGUgb2xkIHRyZWUgYXJvdW5kLCBvdGhlcndpc2Ugd2lsbCB0cmVhdCB0aGUgdm5vZGVzIGFzIG5ldyBhbmRcblx0XHRcdC8vIHdpbGwgd3JvbmdseSBjYWxsIGBjb21wb25lbnREaWRNb3VudGAgb24gdGhlbVxuXHRcdFx0Y29udGFpbmVyLl9jaGlsZHJlbiA9IF90aGlzLl9jaGlsZHJlbjtcblx0XHRcdHJlbmRlcih3cmFwLCBjb250YWluZXIpO1xuXHRcdFx0X3RoaXMuX2NoaWxkcmVuID0gY29udGFpbmVyLl9jaGlsZHJlbjtcblx0XHR9XG5cdH1cblx0Ly8gV2hlbiB3ZSBjb21lIGZyb20gYSBjb25kaXRpb25hbCByZW5kZXIsIG9uIGEgbW91bnRlZFxuXHQvLyBwb3J0YWwgd2Ugc2hvdWxkIGNsZWFyIHRoZSBET00uXG5cdGVsc2UgaWYgKF90aGlzLl9oYXNNb3VudGVkKSB7XG5cdFx0aWYgKF90aGlzLl90ZW1wLnBhcmVudE5vZGUpIF90aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoX3RoaXMuX3RlbXApO1xuXHRcdF91bm1vdW50KF90aGlzLl93cmFwKTtcblx0fVxuXHQvLyBTZXQgdGhlIHdyYXBwaW5nIGVsZW1lbnQgZm9yIGZ1dHVyZSB1bm1vdW50aW5nLlxuXHRfdGhpcy5fd3JhcCA9IHdyYXA7XG5cblx0X3RoaXMuY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XG5cdFx0aWYgKF90aGlzLl90ZW1wLnBhcmVudE5vZGUpIF90aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoX3RoaXMuX3RlbXApO1xuXHRcdF91bm1vdW50KF90aGlzLl93cmFwKTtcblx0fTtcblxuXHRyZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgUG9ydGFsYCB0byBjb250aW51ZSByZW5kZXJpbmcgdGhlIHZub2RlIHRyZWUgYXQgYSBkaWZmZXJlbnQgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gY29udGFpbmVyIFRoZSBET00gbm9kZSB0byBjb250aW51ZSByZW5kZXJpbmcgaW4gdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQb3J0YWwodm5vZGUsIGNvbnRhaW5lcikge1xuXHRyZXR1cm4gY3JlYXRlRWxlbWVudChQb3J0YWwsIHsgdm5vZGUsIGNvbnRhaW5lciB9KTtcbn1cbiIsImltcG9ydCB7XG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGh5ZHJhdGUgYXMgcHJlYWN0SHlkcmF0ZSxcblx0b3B0aW9ucyxcblx0dG9DaGlsZEFycmF5LFxuXHRDb21wb25lbnRcbn0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFwcGx5RXZlbnROb3JtYWxpemF0aW9uIH0gZnJvbSAnLi9ldmVudHMnO1xuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS87XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0MHhlYWM3O1xuXG4vKipcbiAqIFByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVk5vZGUgdHJlZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50IERPTSBub2RlIHRvIHJlbmRlciB2bm9kZSB0cmVlIGludG9cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHJlbmRlcmluZ1xuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudCB8IG51bGx9IFRoZSByb290IGNvbXBvbmVudCByZWZlcmVuY2Ugb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdC8vIFJlYWN0IGRlc3Ryb3lzIGFueSBleGlzdGluZyBET00gbm9kZXMsIHNlZSAjMTcyN1xuXHQvLyAuLi5idXQgb25seSBvbiB0aGUgZmlyc3QgcmVuZGVyLCBzZWUgIzE4Mjhcblx0aWYgKHBhcmVudC5fY2hpbGRyZW4gPT0gbnVsbCkge1xuXHRcdHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkge1xuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcblx0XHR9XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gKCkgPT4ge307XG5cdGxldCBzdG9wcGVkUHJvcGFnYXRpbmcgPSBmYWxzZSxcblx0XHRkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cblx0Y29uc3Qgb3JpZ1N0b3BQcm9wYWdhdGlvbiA9IGUuc3RvcFByb3BhZ2F0aW9uO1xuXHRlLnN0b3BQcm9wYWdhdGlvbiA9ICgpID0+IHtcblx0XHRvcmlnU3RvcFByb3BhZ2F0aW9uLmNhbGwoZSk7XG5cdFx0c3RvcHBlZFByb3BhZ2F0aW5nID0gdHJ1ZTtcblx0fTtcblxuXHRjb25zdCBvcmlnUHJldmVudERlZmF1bHQgPSBlLnByZXZlbnREZWZhdWx0O1xuXHRlLnByZXZlbnREZWZhdWx0ID0gKCkgPT4ge1xuXHRcdG9yaWdQcmV2ZW50RGVmYXVsdC5jYWxsKGUpO1xuXHRcdGRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHR9O1xuXG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSAoKSA9PiBzdG9wcGVkUHJvcGFnYXRpbmc7XG5cdGUuaXNEZWZhdWx0UHJldmVudGVkID0gKCkgPT4gZGVmYXVsdFByZXZlbnRlZDtcblx0cmV0dXJuIChlLm5hdGl2ZUV2ZW50ID0gZSk7XG59O1xuXG4vLyBQYXRjaCBpbiBgVU5TQUZFXypgIGxpZmVjeWNsZSBob29rc1xuZnVuY3Rpb24gc2V0U2FmZURlc2NyaXB0b3IocHJvdG8sIGtleSkge1xuXHRpZiAocHJvdG9bJ1VOU0FGRV8nICsga2V5XSAmJiAhcHJvdG9ba2V5XSkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywga2V5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0KCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpc1snVU5TQUZFXycgKyBrZXldO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRoaXMgYHNldGAgaXMgb25seSB1c2VkIGlmIGEgdXNlciBzZXRzIGEgbGlmZWN5Y2xlIGxpa2UgY1dVXG5cdFx0XHQvLyBhZnRlciBzZXR0aW5nIGEgbGlmZWN5Y2xlIGxpa2UgVU5TQUZFX2NXVS4gSSBkb3VidCBhbnlvbmVcblx0XHRcdC8vIGFjdHVhbGx5IGRvZXMgdGhpcyBpbiBwcmFjdGljZSBzbyBub3QgdGVzdGluZyBpdFxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdHNldCh2KSB7XG5cdFx0XHRcdHRoaXNbJ1VOU0FGRV8nICsga2V5XSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn1cblxubGV0IGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5sZXQgb2xkVk5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdHZub2RlLiQkdHlwZW9mID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cdGxldCB0eXBlID0gdm5vZGUudHlwZTtcblx0bGV0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cblx0aWYgKHR5cGUpIHtcblx0XHQvLyBBbGlhcyBgY2xhc3NgIHByb3AgdG8gYGNsYXNzTmFtZWAgaWYgYXZhaWxhYmxlXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIHByb3BzLmNsYXNzID0gcHJvcHMuY2xhc3NOYW1lO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgRE9NIFZOb2RlIGNvbXBhdFxuXHRcdGlmICh0eXBlb2YgdHlwZSAhPSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBBcHBseSBkZWZhdWx0VmFsdWUgdG8gdmFsdWVcblx0XHRcdGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgJiYgcHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRpZiAoIXByb3BzLnZhbHVlICYmIHByb3BzLnZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdFx0cHJvcHMudmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVsZXRlIHByb3BzLmRlZmF1bHRWYWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIGFycmF5IHNlbGVjdCB2YWx1ZXM6IDxzZWxlY3QgdmFsdWU9e1tdfSAvPlxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcHMudmFsdWUpICYmIHByb3BzLm11bHRpcGxlICYmIHR5cGUgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdFx0aWYgKHByb3BzLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xKSB7XG5cdFx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZGVsZXRlIHByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOb3JtYWxpemUgRE9NIHZub2RlIHByb3BlcnRpZXMuXG5cdFx0XHRsZXQgc2hvdWxkU2FuaXRpemUsIGF0dHJzLCBpO1xuXHRcdFx0Zm9yIChpIGluIHByb3BzKSBpZiAoKHNob3VsZFNhbml0aXplID0gQ0FNRUxfUFJPUFMudGVzdChpKSkpIGJyZWFrO1xuXHRcdFx0aWYgKHNob3VsZFNhbml0aXplKSB7XG5cdFx0XHRcdGF0dHJzID0gdm5vZGUucHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0XHRcdFx0YXR0cnNbXG5cdFx0XHRcdFx0XHRDQU1FTF9QUk9QUy50ZXN0KGkpID8gaS5yZXBsYWNlKC9bQS1aMC05XS8sICctJCYnKS50b0xvd2VyQ2FzZSgpIDogaVxuXHRcdFx0XHRcdF0gPSBwcm9wc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEV2ZW50c1xuXHRcdGFwcGx5RXZlbnROb3JtYWxpemF0aW9uKHZub2RlKTtcblxuXHRcdC8vIENvbXBvbmVudCBiYXNlIGNsYXNzIGNvbXBhdFxuXHRcdC8vIFdlIGNhbid0IGp1c3QgcGF0Y2ggdGhlIGJhc2UgY29tcG9uZW50IGNsYXNzLCBiZWNhdXNlIGNvbXBvbmVudHMgdGhhdCB1c2Vcblx0XHQvLyBpbmhlcml0YW5jZSBhbmQgYXJlIHRyYW5zcGlsZWQgZG93biB0byBFUzUgd2lsbCBvdmVyd3JpdGUgb3VyIHBhdGNoZWRcblx0XHQvLyBnZXR0ZXJzIGFuZCBzZXR0ZXJzLiBTZWUgIzE5NDFcblx0XHRpZiAoXG5cdFx0XHR0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHQhdHlwZS5fcGF0Y2hlZExpZmVjeWNsZXMgJiZcblx0XHRcdHR5cGUucHJvdG90eXBlXG5cdFx0KSB7XG5cdFx0XHRzZXRTYWZlRGVzY3JpcHRvcih0eXBlLnByb3RvdHlwZSwgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuXHRcdFx0c2V0U2FmZURlc2NyaXB0b3IodHlwZS5wcm90b3R5cGUsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG5cdFx0XHRzZXRTYWZlRGVzY3JpcHRvcih0eXBlLnByb3RvdHlwZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcblx0XHRcdHR5cGUuX3BhdGNoZWRMaWZlY3ljbGVzID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcbiIsIi8qKlxuICogTm9ybWFsaXplIGV2ZW50IGhhbmRsZXJzIGxpa2UgcmVhY3QgZG9lcy4gTW9zdCBmYW1vdXNseSBpdCB1c2VzIGBvbkNoYW5nZWAgZm9yIGFueSBpbnB1dCBlbGVtZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRvIG5vcm1hbGl6ZSBldmVudHMgb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RXZlbnROb3JtYWxpemF0aW9uKHsgdHlwZSwgcHJvcHMgfSkge1xuXHRpZiAoIXByb3BzIHx8IHR5cGVvZiB0eXBlICE9ICdzdHJpbmcnKSByZXR1cm47XG5cdGxldCBuZXdQcm9wcyA9IHt9O1xuXG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoL15vbihBbml8VHJhfFRvdSkvLnRlc3QoaSkpIHtcblx0XHRcdHByb3BzW2kudG9Mb3dlckNhc2UoKV0gPSBwcm9wc1tpXTtcblx0XHRcdGRlbGV0ZSBwcm9wc1tpXTtcblx0XHR9XG5cdFx0bmV3UHJvcHNbaS50b0xvd2VyQ2FzZSgpXSA9IGk7XG5cdH1cblx0aWYgKG5ld1Byb3BzLm9uZG91YmxlY2xpY2spIHtcblx0XHRwcm9wcy5vbmRibGNsaWNrID0gcHJvcHNbbmV3UHJvcHMub25kb3VibGVjbGlja107XG5cdFx0ZGVsZXRlIHByb3BzW25ld1Byb3BzLm9uZG91YmxlY2xpY2tdO1xuXHR9XG5cdGlmIChuZXdQcm9wcy5vbmJlZm9yZWlucHV0KSB7XG5cdFx0cHJvcHMub25iZWZvcmVpbnB1dCA9IHByb3BzW25ld1Byb3BzLm9uYmVmb3JlaW5wdXRdO1xuXHRcdGRlbGV0ZSBwcm9wc1tuZXdQcm9wcy5vbmJlZm9yZWlucHV0XTtcblx0fVxuXHQvLyBmb3IgKnRleHR1YWwgaW5wdXRzKiAoaW5jbCB0ZXh0YXJlYSksIG5vcm1hbGl6ZSBgb25DaGFuZ2VgIC0+IGBvbklucHV0YDpcblx0aWYgKFxuXHRcdG5ld1Byb3BzLm9uY2hhbmdlICYmXG5cdFx0KHR5cGUgPT09ICd0ZXh0YXJlYScgfHxcblx0XHRcdCh0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgIS9eZmlsfGNoZXxyYS9pLnRlc3QocHJvcHMudHlwZSkpKVxuXHQpIHtcblx0XHRsZXQgbm9ybWFsaXplZCA9IG5ld1Byb3BzLm9uaW5wdXQgfHwgJ29uaW5wdXQnO1xuXHRcdGlmICghcHJvcHNbbm9ybWFsaXplZF0pIHtcblx0XHRcdHByb3BzW25vcm1hbGl6ZWRdID0gcHJvcHNbbmV3UHJvcHMub25jaGFuZ2VdO1xuXHRcdFx0ZGVsZXRlIHByb3BzW25ld1Byb3BzLm9uY2hhbmdlXTtcblx0XHR9XG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdGNyZWF0ZUVsZW1lbnQsXG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGNsb25lRWxlbWVudCBhcyBwcmVhY3RDbG9uZUVsZW1lbnQsXG5cdGNyZWF0ZVJlZixcblx0Q29tcG9uZW50LFxuXHRjcmVhdGVDb250ZXh0LFxuXHRGcmFnbWVudFxufSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHtcblx0dXNlU3RhdGUsXG5cdHVzZVJlZHVjZXIsXG5cdHVzZUVmZmVjdCxcblx0dXNlTGF5b3V0RWZmZWN0LFxuXHR1c2VSZWYsXG5cdHVzZUltcGVyYXRpdmVIYW5kbGUsXG5cdHVzZU1lbW8sXG5cdHVzZUNhbGxiYWNrLFxuXHR1c2VDb250ZXh0LFxuXHR1c2VEZWJ1Z1ZhbHVlXG59IGZyb20gJ3ByZWFjdC9ob29rcyc7XG5pbXBvcnQgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAnLi9QdXJlQ29tcG9uZW50JztcbmltcG9ydCB7IG1lbW8gfSBmcm9tICcuL21lbW8nO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJy4vZm9yd2FyZFJlZic7XG5pbXBvcnQgeyBDaGlsZHJlbiB9IGZyb20gJy4vQ2hpbGRyZW4nO1xuaW1wb3J0IHsgU3VzcGVuc2UsIGxhenkgfSBmcm9tICcuL3N1c3BlbnNlJztcbmltcG9ydCB7IFN1c3BlbnNlTGlzdCB9IGZyb20gJy4vc3VzcGVuc2UtbGlzdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICcuL3BvcnRhbHMnO1xuaW1wb3J0IHsgaHlkcmF0ZSwgcmVuZGVyLCBSRUFDVF9FTEVNRU5UX1RZUEUgfSBmcm9tICcuL3JlbmRlcic7XG5cbmNvbnN0IHZlcnNpb24gPSAnMTYuOC4wJzsgLy8gdHJpY2sgbGlicmFyaWVzIHRvIHRoaW5rIHdlIGFyZSByZWFjdFxuXG4vKipcbiAqIExlZ2FjeSB2ZXJzaW9uIG9mIGNyZWF0ZUVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudCBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcblx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgYSB2YWxpZCAocClyZWFjdCBub2RlLlxuICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuXHRyZXR1cm4gISFlbGVtZW50ICYmIGVsZW1lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxuLyoqXG4gKiBXcmFwIGBjbG9uZUVsZW1lbnRgIHRvIGFib3J0IGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBub3QgYSB2YWxpZCBlbGVtZW50IGFuZCBhcHBseVxuICogYWxsIHZub2RlIG5vcm1hbGl6YXRpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gZWxlbWVudCBUaGUgdm5vZGUgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyB0byBhZGQgd2hlbiBjbG9uaW5nXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkcmVuPn0gcmVzdCBPcHRpb25hbCBjb21wb25lbnQgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQpIHtcblx0aWYgKCFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuIGVsZW1lbnQ7XG5cdHJldHVybiBwcmVhY3RDbG9uZUVsZW1lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjb21wb25lbnQgdHJlZSBmcm9tIHRoZSBET00sIGluY2x1ZGluZyBzdGF0ZSBhbmQgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG5cdGlmIChjb250YWluZXIuX2NoaWxkcmVuKSB7XG5cdFx0cHJlYWN0UmVuZGVyKG51bGwsIGNvbnRhaW5lcik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWF0Y2hpbmcgRE9NIG5vZGUgZm9yIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudCkge1xuXHRyZXR1cm4gKFxuXHRcdChjb21wb25lbnQgJiZcblx0XHRcdChjb21wb25lbnQuYmFzZSB8fCAoY29tcG9uZW50Lm5vZGVUeXBlID09PSAxICYmIGNvbXBvbmVudCkpKSB8fFxuXHRcdG51bGxcblx0KTtcbn1cblxuLyoqXG4gKiBEZXByZWNhdGVkIHdheSB0byBjb250cm9sIGJhdGNoZWQgcmVuZGVyaW5nIGluc2lkZSB0aGUgcmVjb25jaWxlciwgYnV0IHdlXG4gKiBhbHJlYWR5IHNjaGVkdWxlIGluIGJhdGNoZXMgaW5zaWRlIG91ciByZW5kZXJpbmcgY29kZVxuICogQHRlbXBsYXRlIEFyZ1xuICogQHBhcmFtIHsoYXJnOiBBcmcpID0+IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgdHJpZ2dlcnMgdGhlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7QXJnfSBbYXJnXSBPcHRpb25hbCBhcmd1bWVudCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbmNvbnN0IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKGNhbGxiYWNrLCBhcmcpID0+IGNhbGxiYWNrKGFyZyk7XG5cbmV4cG9ydCAqIGZyb20gJ3ByZWFjdC9ob29rcyc7XG5leHBvcnQge1xuXHR2ZXJzaW9uLFxuXHRDaGlsZHJlbixcblx0cmVuZGVyLFxuXHRoeWRyYXRlLFxuXHR1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuXHRjcmVhdGVQb3J0YWwsXG5cdGNyZWF0ZUVsZW1lbnQsXG5cdGNyZWF0ZUNvbnRleHQsXG5cdGNyZWF0ZUZhY3RvcnksXG5cdGNsb25lRWxlbWVudCxcblx0Y3JlYXRlUmVmLFxuXHRGcmFnbWVudCxcblx0aXNWYWxpZEVsZW1lbnQsXG5cdGZpbmRET01Ob2RlLFxuXHRDb21wb25lbnQsXG5cdFB1cmVDb21wb25lbnQsXG5cdG1lbW8sXG5cdGZvcndhcmRSZWYsXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2Vcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdFN1c3BlbnNlLFxuXHRTdXNwZW5zZUxpc3QsXG5cdGxhenlcbn07XG5cbi8vIFJlYWN0IGNvcGllcyB0aGUgbmFtZWQgZXhwb3J0cyB0byB0aGUgZGVmYXVsdCBvbmUuXG5leHBvcnQgZGVmYXVsdCB7XG5cdHVzZVN0YXRlLFxuXHR1c2VSZWR1Y2VyLFxuXHR1c2VFZmZlY3QsXG5cdHVzZUxheW91dEVmZmVjdCxcblx0dXNlUmVmLFxuXHR1c2VJbXBlcmF0aXZlSGFuZGxlLFxuXHR1c2VNZW1vLFxuXHR1c2VDYWxsYmFjayxcblx0dXNlQ29udGV4dCxcblx0dXNlRGVidWdWYWx1ZSxcblx0dmVyc2lvbixcblx0Q2hpbGRyZW4sXG5cdHJlbmRlcixcblx0aHlkcmF0ZTogcmVuZGVyLFxuXHR1bm1vdW50Q29tcG9uZW50QXROb2RlLFxuXHRjcmVhdGVQb3J0YWwsXG5cdGNyZWF0ZUVsZW1lbnQsXG5cdGNyZWF0ZUNvbnRleHQsXG5cdGNyZWF0ZUZhY3RvcnksXG5cdGNsb25lRWxlbWVudCxcblx0Y3JlYXRlUmVmLFxuXHRGcmFnbWVudCxcblx0aXNWYWxpZEVsZW1lbnQsXG5cdGZpbmRET01Ob2RlLFxuXHRDb21wb25lbnQsXG5cdFB1cmVDb21wb25lbnQsXG5cdG1lbW8sXG5cdGZvcndhcmRSZWYsXG5cdHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLFxuXHRTdXNwZW5zZSxcblx0U3VzcGVuc2VMaXN0LFxuXHRsYXp5XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/preact/compat/dist/compat.module.js\n");

/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ H; },\n/* harmony export */   \"hydrate\": function() { return /* binding */ I; },\n/* harmony export */   \"createElement\": function() { return /* binding */ h; },\n/* harmony export */   \"h\": function() { return /* binding */ h; },\n/* harmony export */   \"Fragment\": function() { return /* binding */ d; },\n/* harmony export */   \"createRef\": function() { return /* binding */ y; },\n/* harmony export */   \"isValidElement\": function() { return /* binding */ l; },\n/* harmony export */   \"Component\": function() { return /* binding */ m; },\n/* harmony export */   \"cloneElement\": function() { return /* binding */ L; },\n/* harmony export */   \"createContext\": function() { return /* binding */ M; },\n/* harmony export */   \"toChildArray\": function() { return /* binding */ x; },\n/* harmony export */   \"_unmount\": function() { return /* binding */ D; },\n/* harmony export */   \"options\": function() { return /* binding */ n; }\n/* harmony export */ });\nvar n,\n    l,\n    u,\n    i,\n    t,\n    r,\n    o,\n    f,\n    e = {},\n    c = [],\n    s = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\nfunction a(n, l) {\n  for (var u in l) {\n    n[u] = l[u];\n  }\n\n  return n;\n}\n\nfunction v(n) {\n  var l = n.parentNode;\n  l && l.removeChild(n);\n}\n\nfunction h(n, l, u) {\n  var i,\n      t = arguments,\n      r = {};\n\n  for (i in l) {\n    \"key\" !== i && \"ref\" !== i && (r[i] = l[i]);\n  }\n\n  if (arguments.length > 3) for (u = [u], i = 3; i < arguments.length; i++) {\n    u.push(t[i]);\n  }\n  if (null != u && (r.children = u), \"function\" == typeof n && null != n.defaultProps) for (i in n.defaultProps) {\n    void 0 === r[i] && (r[i] = n.defaultProps[i]);\n  }\n  return p(n, r, l && l.key, l && l.ref, null);\n}\n\nfunction p(l, u, i, t, r) {\n  var o = {\n    type: l,\n    props: u,\n    key: i,\n    ref: t,\n    __k: null,\n    __: null,\n    __b: 0,\n    __e: null,\n    __d: void 0,\n    __c: null,\n    constructor: void 0,\n    __v: r\n  };\n  return null == r && (o.__v = o), n.vnode && n.vnode(o), o;\n}\n\nfunction y() {\n  return {};\n}\n\nfunction d(n) {\n  return n.children;\n}\n\nfunction m(n, l) {\n  this.props = n, this.context = l;\n}\n\nfunction w(n, l) {\n  if (null == l) return n.__ ? w(n.__, n.__.__k.indexOf(n) + 1) : null;\n\n  for (var u; l < n.__k.length; l++) {\n    if (null != (u = n.__k[l]) && null != u.__e) return u.__e;\n  }\n\n  return \"function\" == typeof n.type ? w(n) : null;\n}\n\nfunction k(n) {\n  var l, u;\n\n  if (null != (n = n.__) && null != n.__c) {\n    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {\n      if (null != (u = n.__k[l]) && null != u.__e) {\n        n.__e = n.__c.base = u.__e;\n        break;\n      }\n    }\n\n    return k(n);\n  }\n}\n\nfunction g(l) {\n  (!l.__d && (l.__d = !0) && u.push(l) && !i++ || r !== n.debounceRendering) && ((r = n.debounceRendering) || t)(_);\n}\n\nfunction _() {\n  for (var n; i = u.length;) {\n    n = u.sort(function (n, l) {\n      return n.__v.__b - l.__v.__b;\n    }), u = [], n.some(function (n) {\n      var l, u, i, t, r, o, f;\n      n.__d && (o = (r = (l = n).__v).__e, (f = l.__P) && (u = [], (i = a({}, r)).__v = i, t = A(f, r, i, l.__n, void 0 !== f.ownerSVGElement, null, u, null == o ? w(r) : o), T(u, r), t != o && k(r)));\n    });\n  }\n}\n\nfunction b(n, l, u, i, t, r, o, f, s) {\n  var a,\n      h,\n      p,\n      y,\n      d,\n      m,\n      k,\n      g = u && u.__k || c,\n      _ = g.length;\n  if (f == e && (f = null != r ? r[0] : _ ? w(u, 0) : null), a = 0, l.__k = x(l.__k, function (u) {\n    if (null != u) {\n      if (u.__ = l, u.__b = l.__b + 1, null === (p = g[a]) || p && u.key == p.key && u.type === p.type) g[a] = void 0;else for (h = 0; h < _; h++) {\n        if ((p = g[h]) && u.key == p.key && u.type === p.type) {\n          g[h] = void 0;\n          break;\n        }\n\n        p = null;\n      }\n\n      if (y = A(n, u, p = p || e, i, t, r, o, f, s), (h = u.ref) && p.ref != h && (k || (k = []), p.ref && k.push(p.ref, null, u), k.push(h, u.__c || y, u)), null != y) {\n        var c;\n        if (null == m && (m = y), void 0 !== u.__d) c = u.__d, u.__d = void 0;else if (r == p || y != f || null == y.parentNode) {\n          n: if (null == f || f.parentNode !== n) n.appendChild(y), c = null;else {\n            for (d = f, h = 0; (d = d.nextSibling) && h < _; h += 2) {\n              if (d == y) break n;\n            }\n\n            n.insertBefore(y, f), c = f;\n          }\n\n          \"option\" == l.type && (n.value = \"\");\n        }\n        f = void 0 !== c ? c : y.nextSibling, \"function\" == typeof l.type && (l.__d = f);\n      } else f && p.__e == f && f.parentNode != n && (f = w(p));\n    }\n\n    return a++, u;\n  }), l.__e = m, null != r && \"function\" != typeof l.type) for (a = r.length; a--;) {\n    null != r[a] && v(r[a]);\n  }\n\n  for (a = _; a--;) {\n    null != g[a] && D(g[a], g[a]);\n  }\n\n  if (k) for (a = 0; a < k.length; a++) {\n    j(k[a], k[++a], k[++a]);\n  }\n}\n\nfunction x(n, l, u) {\n  if (null == u && (u = []), null == n || \"boolean\" == typeof n) l && u.push(l(null));else if (Array.isArray(n)) for (var i = 0; i < n.length; i++) {\n    x(n[i], l, u);\n  } else u.push(l ? l(\"string\" == typeof n || \"number\" == typeof n ? p(null, n, null, null, n) : null != n.__e || null != n.__c ? p(n.type, n.props, n.key, null, n.__v) : n) : n);\n  return u;\n}\n\nfunction P(n, l, u, i, t) {\n  var r;\n\n  for (r in u) {\n    \"children\" === r || \"key\" === r || r in l || N(n, r, null, u[r], i);\n  }\n\n  for (r in l) {\n    t && \"function\" != typeof l[r] || \"children\" === r || \"key\" === r || \"value\" === r || \"checked\" === r || u[r] === l[r] || N(n, r, l[r], u[r], i);\n  }\n}\n\nfunction C(n, l, u) {\n  \"-\" === l[0] ? n.setProperty(l, u) : n[l] = \"number\" == typeof u && !1 === s.test(l) ? u + \"px\" : null == u ? \"\" : u;\n}\n\nfunction N(n, l, u, i, t) {\n  var r, o, f, e, c;\n  if (t ? \"className\" === l && (l = \"class\") : \"class\" === l && (l = \"className\"), \"style\" === l) {\n    if (r = n.style, \"string\" == typeof u) r.cssText = u;else {\n      if (\"string\" == typeof i && (r.cssText = \"\", i = null), i) for (e in i) {\n        u && e in u || C(r, e, \"\");\n      }\n      if (u) for (c in u) {\n        i && u[c] === i[c] || C(r, c, u[c]);\n      }\n    }\n  } else \"o\" === l[0] && \"n\" === l[1] ? (o = l !== (l = l.replace(/Capture$/, \"\")), f = l.toLowerCase(), l = (f in n ? f : l).slice(2), u ? (i || n.addEventListener(l, z, o), (n.l || (n.l = {}))[l] = u) : n.removeEventListener(l, z, o)) : \"list\" !== l && \"tagName\" !== l && \"form\" !== l && \"type\" !== l && \"size\" !== l && !t && l in n ? n[l] = null == u ? \"\" : u : \"function\" != typeof u && \"dangerouslySetInnerHTML\" !== l && (l !== (l = l.replace(/^xlink:?/, \"\")) ? null == u || !1 === u ? n.removeAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase()) : n.setAttributeNS(\"http://www.w3.org/1999/xlink\", l.toLowerCase(), u) : null == u || !1 === u && !/^ar/.test(l) ? n.removeAttribute(l) : n.setAttribute(l, u));\n}\n\nfunction z(l) {\n  this.l[l.type](n.event ? n.event(l) : l);\n}\n\nfunction A(l, u, i, t, r, o, f, e, c) {\n  var s,\n      v,\n      h,\n      p,\n      y,\n      w,\n      k,\n      g,\n      _,\n      x,\n      P = u.type;\n\n  if (void 0 !== u.constructor) return null;\n  (s = n.__b) && s(u);\n\n  try {\n    n: if (\"function\" == typeof P) {\n      if (g = u.props, _ = (s = P.contextType) && t[s.__c], x = s ? _ ? _.props.value : s.__ : t, i.__c ? k = (v = u.__c = i.__c).__ = v.__E : (\"prototype\" in P && P.prototype.render ? u.__c = v = new P(g, x) : (u.__c = v = new m(g, x), v.constructor = P, v.render = E), _ && _.sub(v), v.props = g, v.state || (v.state = {}), v.context = x, v.__n = t, h = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != P.getDerivedStateFromProps && (v.__s == v.state && (v.__s = a({}, v.__s)), a(v.__s, P.getDerivedStateFromProps(g, v.__s))), p = v.props, y = v.state, h) null == P.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && v.__h.push(v.componentDidMount);else {\n        if (null == P.getDerivedStateFromProps && g !== p && null != v.componentWillReceiveProps && v.componentWillReceiveProps(g, x), !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(g, v.__s, x) || u.__v === i.__v && !v.__) {\n          for (v.props = g, v.state = v.__s, u.__v !== i.__v && (v.__d = !1), v.__v = u, u.__e = i.__e, u.__k = i.__k, v.__h.length && f.push(v), s = 0; s < u.__k.length; s++) {\n            u.__k[s] && (u.__k[s].__ = u);\n          }\n\n          break n;\n        }\n\n        null != v.componentWillUpdate && v.componentWillUpdate(g, v.__s, x), null != v.componentDidUpdate && v.__h.push(function () {\n          v.componentDidUpdate(p, y, w);\n        });\n      }\n      v.context = x, v.props = g, v.state = v.__s, (s = n.__r) && s(u), v.__d = !1, v.__v = u, v.__P = l, s = v.render(v.props, v.state, v.context), u.__k = null != s && s.type == d && null == s.key ? s.props.children : Array.isArray(s) ? s : [s], null != v.getChildContext && (t = a(a({}, t), v.getChildContext())), h || null == v.getSnapshotBeforeUpdate || (w = v.getSnapshotBeforeUpdate(p, y)), b(l, u, i, t, r, o, f, e, c), v.base = u.__e, v.__h.length && f.push(v), k && (v.__E = v.__ = null), v.__e = !1;\n    } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = $(i.__e, u, i, t, r, o, f, c);\n\n    (s = n.diffed) && s(u);\n  } catch (l) {\n    u.__v = null, n.__e(l, u, i);\n  }\n\n  return u.__e;\n}\n\nfunction T(l, u) {\n  n.__c && n.__c(u, l), l.some(function (u) {\n    try {\n      l = u.__h, u.__h = [], l.some(function (n) {\n        n.call(u);\n      });\n    } catch (l) {\n      n.__e(l, u.__v);\n    }\n  });\n}\n\nfunction $(n, l, u, i, t, r, o, f) {\n  var s,\n      a,\n      v,\n      h,\n      p,\n      y = u.props,\n      d = l.props;\n  if (t = \"svg\" === l.type || t, null != r) for (s = 0; s < r.length; s++) {\n    if (null != (a = r[s]) && ((null === l.type ? 3 === a.nodeType : a.localName === l.type) || n == a)) {\n      n = a, r[s] = null;\n      break;\n    }\n  }\n\n  if (null == n) {\n    if (null === l.type) return document.createTextNode(d);\n    n = t ? document.createElementNS(\"http://www.w3.org/2000/svg\", l.type) : document.createElement(l.type, d.is && {\n      is: d.is\n    }), r = null, f = !1;\n  }\n\n  if (null === l.type) y !== d && n.data != d && (n.data = d);else {\n    if (null != r && (r = c.slice.call(n.childNodes)), v = (y = u.props || e).dangerouslySetInnerHTML, h = d.dangerouslySetInnerHTML, !f) {\n      if (y === e) for (y = {}, p = 0; p < n.attributes.length; p++) {\n        y[n.attributes[p].name] = n.attributes[p].value;\n      }\n      (h || v) && (h && v && h.__html == v.__html || (n.innerHTML = h && h.__html || \"\"));\n    }\n\n    P(n, d, y, t, f), h ? l.__k = [] : (l.__k = l.props.children, b(n, l, u, i, \"foreignObject\" !== l.type && t, r, o, e, f)), f || (\"value\" in d && void 0 !== (s = d.value) && s !== n.value && N(n, \"value\", s, y.value, !1), \"checked\" in d && void 0 !== (s = d.checked) && s !== n.checked && N(n, \"checked\", s, y.checked, !1));\n  }\n  return n;\n}\n\nfunction j(l, u, i) {\n  try {\n    \"function\" == typeof l ? l(u) : l.current = u;\n  } catch (l) {\n    n.__e(l, i);\n  }\n}\n\nfunction D(l, u, i) {\n  var t, r, o;\n\n  if (n.unmount && n.unmount(l), (t = l.ref) && (t.current && t.current !== l.__e || j(t, null, u)), i || \"function\" == typeof l.type || (i = null != (r = l.__e)), l.__e = l.__d = void 0, null != (t = l.__c)) {\n    if (t.componentWillUnmount) try {\n      t.componentWillUnmount();\n    } catch (l) {\n      n.__e(l, u);\n    }\n    t.base = t.__P = null;\n  }\n\n  if (t = l.__k) for (o = 0; o < t.length; o++) {\n    t[o] && D(t[o], u, i);\n  }\n  null != r && v(r);\n}\n\nfunction E(n, l, u) {\n  return this.constructor(n, u);\n}\n\nfunction H(l, u, i) {\n  var t, r, f;\n  n.__ && n.__(l, u), r = (t = i === o) ? null : i && i.__k || u.__k, l = h(d, null, [l]), f = [], A(u, (t ? u : i || u).__k = l, r || e, e, void 0 !== u.ownerSVGElement, i && !t ? [i] : r ? null : c.slice.call(u.childNodes), f, i || e, t), T(f, l);\n}\n\nfunction I(n, l) {\n  H(n, l, o);\n}\n\nfunction L(n, l) {\n  var u, i;\n\n  for (i in l = a(a({}, n.props), l), arguments.length > 2 && (l.children = c.slice.call(arguments, 2)), u = {}, l) {\n    \"key\" !== i && \"ref\" !== i && (u[i] = l[i]);\n  }\n\n  return p(n.type, u, l.key || n.key, l.ref || n.ref, null);\n}\n\nfunction M(n) {\n  var l = {},\n      u = {\n    __c: \"__cC\" + f++,\n    __: n,\n    Consumer: function Consumer(n, l) {\n      return n.children(l);\n    },\n    Provider: function Provider(n) {\n      var i,\n          t = this;\n      return this.getChildContext || (i = [], this.getChildContext = function () {\n        return l[u.__c] = t, l;\n      }, this.shouldComponentUpdate = function (n) {\n        t.props.value !== n.value && i.some(function (l) {\n          l.context = n.value, g(l);\n        });\n      }, this.sub = function (n) {\n        i.push(n);\n        var l = n.componentWillUnmount;\n\n        n.componentWillUnmount = function () {\n          i.splice(i.indexOf(n), 1), l && l.call(n);\n        };\n      }), n.children;\n    }\n  };\n  return u.Consumer.contextType = u, u.Provider.__ = u, u;\n}\n\nn = {\n  __e: function __e(n, l) {\n    for (var u, i; l = l.__;) {\n      if ((u = l.__c) && !u.__) try {\n        if (u.constructor && null != u.constructor.getDerivedStateFromError && (i = !0, u.setState(u.constructor.getDerivedStateFromError(n))), null != u.componentDidCatch && (i = !0, u.componentDidCatch(n)), i) return g(u.__E = u);\n      } catch (l) {\n        n = l;\n      }\n    }\n\n    throw n;\n  }\n}, l = function l(n) {\n  return null != n && void 0 === n.constructor;\n}, m.prototype.setState = function (n, l) {\n  var u;\n  u = this.__s !== this.state ? this.__s : this.__s = a({}, this.state), \"function\" == typeof n && (n = n(u, this.props)), n && a(u, n), null != n && this.__v && (l && this.__h.push(l), g(this));\n}, m.prototype.forceUpdate = function (n) {\n  this.__v && (this.__e = !0, n && this.__h.push(n), g(this));\n}, m.prototype.render = d, u = [], i = 0, t = \"function\" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o = e, f = 0;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2Rpc3QvcHJlYWN0Lm1vZHVsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QU1PQTtBQUFBO0FBQ0E7QUFEQTs7QUFDQTtBQVVBOztBQUFBO0FBQUE7QUFFQTtBSlZBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBR0E7QUFIQTs7QUFHQTtBQU9BO0FBSkE7QUFJQTtBQVVBO0FBREE7QUFHQTtBQTBCQTs7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBZ0JBO0FBU0E7O0FBQUE7QUFBQTtBQUlBOztBQUFBO0FBQUE7QUMvRUE7O0FBQUE7QUFBQTtBQXVFQTs7QUFBQTtBQUFBOztBQUtBO0FBSUE7QUFKQTs7QUFXQTtBQStDQTs7QUFBQTtBQUFBOztBQUlBO0FBSEE7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUxBOztBQUtBO0FBS0E7QUFxQ0E7O0FBQUE7QUFBQTtBQWNBOztBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFoR0E7QUFxR0E7QUE5RUE7QUFzRUE7QUl2TEE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFpQkE7QUFtQkE7QUFDQTtBQW9CQTtBQVNBO0FBQUE7QUFHQTs7QUFBQTtBQUFBOztBQUFBO0FBMEJBO0FBS0E7QUFxQkE7QUFHQTtBQUtBO0FBTEE7O0FBV0E7QUFjQTs7QUFBQTtBQVNBO0FBQUE7QUFjQTtBQVNBOztBQUFBO0FBS0E7QUFTQTtBQUZBOztBQUVBO0FBTUE7QUFOQTs7QUFNQTtBQU1BO0FBRkE7QUFnQkE7O0FBQUE7QUFBQTtBQU9BO0FBRkE7QUFLQTtBQ3BQQTs7QUFBQTtBQUFBOztBQUNBO0FBR0E7QUFIQTs7QUFJQTtBQU1BO0FBTkE7QUFrQkE7O0FBQUE7QUFDQTtBQXNCQTs7QUFBQTtBQUFBO0FBK0JBO0FBcEJBO0FBS0E7QUFRQTtBQUZBO0FBR0E7QUFPQTtBQUZBO0FBR0E7QUFGQTtBQXFFQTs7QUFBQTtBQUFBO0FDdElBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZQTtBQUlBOztBQUVBO0FBR0E7QUFBQTtBQW1FQTtBQWtCQTtBQWFBO0FBYkE7O0FBY0E7QUFPQTs7QUFBQTtBQU1BO0FBQUE7QUFLQTtBQUFBO0FBaURBOztBQWdCQTtBQUtBO0FBQ0E7QUFDQTs7QUFBQTtBQVdBOztBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBR0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBbUJBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFZQTtBQU1BO0FBYUE7QUFDQTtBQUFBO0FBZkE7O0FBZUE7QUFNQTtBQUtBO0FBSUE7QUFBQTtBQUtBOztBQUFBO0FBT0E7QUFZQTtBQUlBO0FBSEE7QUFHQTtBQVlBOztBQUFBO0FBa0NBO0FBQUE7QUFjQTs7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFZQTs7QUFBQTtBQUFBOztBQThCQTtBQWJBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFBQTtBQUFBOztBQUFBO0FBS0E7QUFGQTtBQU1BO0FBSUE7O0FBQUE7QUFBQTtBTG5jQTs7QUFBQTtBQUFBO0FBQ0E7QUErQ0E7O0FBQUE7QUFDQTtBTXJEQTs7QUFBQTtBQUFBOztBQUlBO0FBQ0E7QUFEQTs7QUFDQTtBTFpBOztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFBQTtBQU1BO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQWpDQTtBQWlDQTtBSjdCQTs7QUFBQTtBQUNBO0FVSEE7QUFJQTtBQUNBO0FBbUJBO0FBQ0E7QUFBQTtBQXpCQTs7QUF5QkE7QUFLQTtBVjVCQTtBQ3lGQTtBQUNBO0FDNUVBO0FBSUE7QUFrQkE7QUFVQTtBQU1BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2NvbnN0YW50cy5qcz80N2M4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9vcHRpb25zLmpzPzFhZTUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2NyZWF0ZS1lbGVtZW50LmpzPzQ2ZGUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2NvbXBvbmVudC5qcz9kY2IyIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZW5kZXIuanM/NTBmZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvY3JlYXRlLWNvbnRleHQuanM/M2VmMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbC5qcz80MjI4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9kaWZmL2NoaWxkcmVuLmpzP2IwZWMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2RpZmYvcHJvcHMuanM/YzFkYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvZGlmZi9pbmRleC5qcz9jOTg4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9jbG9uZS1lbGVtZW50LmpzP2FlY2UiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2RpZmYvY2F0Y2gtZXJyb3IuanM/ODhhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmQvaTtcbiIsImltcG9ydCB7IF9jYXRjaEVycm9yIH0gZnJvbSAnLi9kaWZmL2NhdGNoLWVycm9yJztcblxuLyoqXG4gKiBUaGUgYG9wdGlvbmAgb2JqZWN0IGNhbiBwb3RlbnRpYWxseSBjb250YWluIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICogdGhhdCBhcmUgY2FsbGVkIGR1cmluZyB2YXJpb3VzIHN0YWdlcyBvZiBvdXIgcmVuZGVyZXIuIFRoaXMgaXMgdGhlXG4gKiBmb3VuZGF0aW9uIG9uIHdoaWNoIGFsbCBvdXIgYWRkb25zIGxpa2UgYHByZWFjdC9kZWJ1Z2AsIGBwcmVhY3QvY29tcGF0YCxcbiAqIGFuZCBgcHJlYWN0L2hvb2tzYCBhcmUgYmFzZWQgb24uIFNlZSB0aGUgYE9wdGlvbnNgIHR5cGUgaW4gYGludGVybmFsLmQudHNgXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbiBob29rcyAobW9zdCBlZGl0b3JzL0lERXMgYWxsb3cgeW91IHRvXG4gKiBjdHJsK2NsaWNrIG9yIGNtZCtjbGljayBvbiBtYWMgdGhlIHR5cGUgZGVmaW5pdGlvbiBiZWxvdykuXG4gKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuT3B0aW9uc31cbiAqL1xuY29uc3Qgb3B0aW9ucyA9IHtcblx0X2NhdGNoRXJyb3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9wdGlvbnM7XG4iLCJpbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpICE9PSAna2V5JyAmJiBpICE9PSAncmVmJykgbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcblx0XHRjaGlsZHJlbiA9IFtjaGlsZHJlbl07XG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTkxNlxuXHRcdGZvciAoaSA9IDM7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNoaWxkcmVuLnB1c2goYXJndW1lbnRzW2ldKTtcblx0XHR9XG5cdH1cblx0aWYgKGNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZShcblx0XHR0eXBlLFxuXHRcdG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRwcm9wcyAmJiBwcm9wcy5rZXksXG5cdFx0cHJvcHMgJiYgcHJvcHMucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbFxuXHR9O1xuXG5cdGlmIChvcmlnaW5hbCA9PSBudWxsKSB2bm9kZS5fb3JpZ2luYWwgPSB2bm9kZTtcblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHt9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dXBkYXRlID0gdXBkYXRlKHMsIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSBvbGRWTm9kZTtcblxuXHRcdGxldCBuZXdEb20gPSBkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb21cblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmIChuZXdEb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xubGV0IHJlcmVuZGVyQ291bnQgPSAwO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAqIEB0eXBlIHsoY2I6ICgpID0+IHZvaWQpID0+IHZvaWR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBOb3RlIHRoZSBmb2xsb3dpbmcgbGluZSBpc24ndCB0cmVlLXNoYWtlbiBieSByb2xsdXAgY3V6IG9mIHJvbGx1cC9yb2xsdXAjMjU2NlxuY29uc3QgZGVmZXIgPVxuXHR0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nXG5cdFx0PyBQcm9taXNlLnByb3RvdHlwZS50aGVuLmJpbmQoUHJvbWlzZS5yZXNvbHZlKCkpXG5cdFx0OiBzZXRUaW1lb3V0O1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG4vKipcbiAqIEVucXVldWUgYSByZXJlbmRlciBvZiBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGMgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjKSB7XG5cdGlmIChcblx0XHQoIWMuX2RpcnR5ICYmXG5cdFx0XHQoYy5fZGlydHkgPSB0cnVlKSAmJlxuXHRcdFx0cmVyZW5kZXJRdWV1ZS5wdXNoKGMpICYmXG5cdFx0XHQhcmVyZW5kZXJDb3VudCsrKSB8fFxuXHRcdHByZXZEZWJvdW5jZSAhPT0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ1xuXHQpIHtcblx0XHRwcmV2RGVib3VuY2UgPSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nO1xuXHRcdChwcmV2RGVib3VuY2UgfHwgZGVmZXIpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHJlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxuY29uc3QgSVNfSFlEUkFURSA9IEVNUFRZX09CSjtcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHR9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2Vcblx0Ly8gYXJlIGluIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIGBJU19IWURSQVRFYCBpbnN0ZWFkIG9mIGFcblx0Ly8gRE9NIGVsZW1lbnQuXG5cdGxldCBpc0h5ZHJhdGluZyA9IHJlcGxhY2VOb2RlID09PSBJU19IWURSQVRFO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXHR2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdCgoaXNIeWRyYXRpbmcgPyBwYXJlbnREb20gOiByZXBsYWNlTm9kZSB8fCBwYXJlbnREb20pLl9jaGlsZHJlbiA9IHZub2RlKSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRyZXBsYWNlTm9kZSAmJiAhaXNIeWRyYXRpbmdcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IEVNUFRZX0FSUi5zbGljZS5jYWxsKHBhcmVudERvbS5jaGlsZE5vZGVzKSxcblx0XHRjb21taXRRdWV1ZSxcblx0XHRyZXBsYWNlTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBJU19IWURSQVRFKTtcbn1cbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuXHRjb25zdCBjdHggPSB7fTtcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogJ19fY0MnICsgaSsrLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHRDb25zdW1lcihwcm9wcywgY29udGV4dCkge1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHQpO1xuXHRcdH0sXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0Y29uc3Qgc3VicyA9IFtdO1xuXHRcdFx0XHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IHtcblx0XHRcdFx0XHRjdHhbY29udGV4dC5faWRdID0gdGhpcztcblx0XHRcdFx0XHRyZXR1cm4gY3R4O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gX3Byb3BzID0+IHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdG9sZCAmJiBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cdGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0O1xuXG5cdHJldHVybiBjb250ZXh0O1xufVxuIiwiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuIiwiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlIH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgRU1QVFlfT0JKLCBFTVBUWV9BUlIgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgcmVtb3ZlTm9kZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgZ2V0RG9tU2libGluZyB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbi8qKlxuICogRGlmZiB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgd2hvc2VcbiAqIGNoaWxkcmVuIGFyZSBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Tm9kZSB8IFRleHR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBuZXdEb20sIHNpYkRvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0Ly8gT25seSBpbiB2ZXJ5IHNwZWNpZmljIHBsYWNlcyBzaG91bGQgdGhpcyBsb2dpYyBiZSBpbnZva2VkICh0b3AgbGV2ZWwgYHJlbmRlcmAgYW5kIGBkaWZmRWxlbWVudE5vZGVzYCkuXG5cdC8vIEknbSB1c2luZyBgRU1QVFlfT0JKYCB0byBzaWduYWwgd2hlbiBgZGlmZkNoaWxkcmVuYCBpcyBpbnZva2VkIGluIHRoZXNlIHNpdHVhdGlvbnMuIEkgY2FuJ3QgdXNlIGBudWxsYFxuXHQvLyBmb3IgdGhpcyBwdXJwb3NlLCBiZWNhdXNlIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIGZvciBgb2xkRG9tYCB3aGljaCBjYW4gbWVhbiB0byBza2lwIHRvIHRoaXMgbG9naWNcblx0Ly8gKGUuZy4gaWYgbW91bnRpbmcgYSBuZXcgdHJlZSBpbiB3aGljaCB0aGUgb2xkIERPTSBzaG91bGQgYmUgaWdub3JlZCAodXN1YWxseSBmb3IgRnJhZ21lbnRzKS5cblx0aWYgKG9sZERvbSA9PSBFTVBUWV9PQkopIHtcblx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0b2xkRG9tID0gZXhjZXNzRG9tQ2hpbGRyZW5bMF07XG5cdFx0fSBlbHNlIGlmIChvbGRDaGlsZHJlbkxlbmd0aCkge1xuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRQYXJlbnRWTm9kZSwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9sZERvbSA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0aSA9IDA7XG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShcblx0XHRuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW4sXG5cdFx0Y2hpbGRWTm9kZSA9PiB7XG5cdFx0XHRpZiAoY2hpbGRWTm9kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9kZXB0aCA9IG5ld1BhcmVudFZOb2RlLl9kZXB0aCArIDE7XG5cblx0XHRcdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHRcdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdFx0XHQvLyBXZSB1c2UgYHVuZGVmaW5lZGAsIGFzIGBudWxsYCBpcyByZXNlcnZlZCBmb3IgZW1wdHkgcGxhY2Vob2xkZXJzXG5cdFx0XHRcdC8vIChob2xlcykuXG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5baV0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0XHRcdC8vIHNvIGFmdGVyIHRoaXMgbG9vcCBvbGRWTm9kZSA9PSBudWxsIG9yIG9sZFZOb2RlIGlzIGEgdmFsaWQgdmFsdWUuXG5cdFx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdFx0XHQvLyBJZiBjaGlsZFZOb2RlIGlzIHVua2V5ZWQsIHdlIG9ubHkgbWF0Y2ggc2ltaWxhcmx5IHVua2V5ZWQgbm9kZXMsIG90aGVyd2lzZSB3ZSBtYXRjaCBieSBrZXkuXG5cdFx0XHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRvbGRWTm9kZSAmJlxuXHRcdFx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0XHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0XHRcdG5ld0RvbSA9IGRpZmYoXG5cdFx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdFx0XHRpZiAoIXJlZnMpIHJlZnMgPSBbXTtcblx0XHRcdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPbmx5IHByb2NlZWQgaWYgdGhlIHZub2RlIGhhcyBub3QgYmVlbiB1bm1vdW50ZWQgYnkgYGRpZmYoKWAgYWJvdmUuXG5cdFx0XHRcdGlmIChuZXdEb20gIT0gbnVsbCkge1xuXHRcdFx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IG5leHREb207XG5cdFx0XHRcdFx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0XHRcdFx0XHQvLyBoYXZlIGEgbm9uLXVuZGVmaW5lZCBfbmV4dERvbS4gQ29udGludWUgdGhlIGRpZmYgZnJvbSB0aGUgc2libGluZ1xuXHRcdFx0XHRcdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdFx0XHRcdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHRcdFx0XHRcdC8vIEVhZ2VybHkgY2xlYW51cCBfbmV4dERvbS4gV2UgZG9uJ3QgbmVlZCB0byBwZXJzaXN0IHRoZSB2YWx1ZSBiZWNhdXNlXG5cdFx0XHRcdFx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdFx0XHRcdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdFx0XHRcdFx0Ly8gY2FuIGNsZWFuIHVwIHRoZSBwcm9wZXJ0eVxuXHRcdFx0XHRcdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gb2xkVk5vZGUgfHxcblx0XHRcdFx0XHRcdG5ld0RvbSAhPSBvbGREb20gfHxcblx0XHRcdFx0XHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIE5PVEU6IGV4Y2Vzc0RvbUNoaWxkcmVuPT1vbGRWTm9kZSBhYm92ZTpcblx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBjb21wcmVzc2lvbiBvZiBleGNlc3NEb21DaGlsZHJlbj09bnVsbCAmJiBvbGRWTm9kZT09bnVsbCFcblx0XHRcdFx0XHRcdC8vIFRoZSB2YWx1ZXMgb25seSBoYXZlIHRoZSBzYW1lIHR5cGUgd2hlbiBgbnVsbGAuXG5cblx0XHRcdFx0XHRcdG91dGVyOiBpZiAob2xkRG9tID09IG51bGwgfHwgb2xkRG9tLnBhcmVudE5vZGUgIT09IHBhcmVudERvbSkge1xuXHRcdFx0XHRcdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdFx0XHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0XHRcdHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuTGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdGogKz0gMlxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc2liRG9tID09IG5ld0RvbSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0XHRcdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBCcm93c2VycyB3aWxsIGluZmVyIGFuIG9wdGlvbidzIGB2YWx1ZWAgZnJvbSBgdGV4dENvbnRlbnRgIHdoZW5cblx0XHRcdFx0XHRcdC8vIG5vIHZhbHVlIGlzIHByZXNlbnQuIFRoaXMgZXNzZW50aWFsbHkgYnlwYXNzZXMgb3VyIGNvZGUgdG8gc2V0IGl0XG5cdFx0XHRcdFx0XHQvLyBsYXRlciBpbiBgZGlmZigpYC4gSXQgd29ya3MgZmluZSBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IGZvciBJRTExXG5cdFx0XHRcdFx0XHQvLyB3aGVyZSBpdCBicmVha3Mgc2V0dGluZyBgc2VsZWN0LnZhbHVlYC4gVGhlcmUgaXQgd2lsbCBiZSBhbHdheXMgc2V0XG5cdFx0XHRcdFx0XHQvLyB0byBhbiBlbXB0eSBzdHJpbmcuIFJlLWFwcGx5aW5nIGFuIG9wdGlvbnMgdmFsdWUgd2lsbCBmaXggdGhhdCwgc29cblx0XHRcdFx0XHRcdC8vIHRoZXJlIGFyZSBwcm9iYWJseSBzb21lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcyB0aGF0IGFyZW4ndFxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlZCBwcm9wZXJseS5cblx0XHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0XHQvLyBUbyBmaXggaXQgd2UgbWFrZSBzdXJlIHRvIHJlc2V0IHRoZSBpbmZlcnJlZCB2YWx1ZSwgc28gdGhhdCBvdXIgb3duXG5cdFx0XHRcdFx0XHQvLyB2YWx1ZSBjaGVjayBpbiBgZGlmZigpYCB3b24ndCBiZSBza2lwcGVkLlxuXHRcdFx0XHRcdFx0aWYgKG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ29wdGlvbicpIHtcblx0XHRcdFx0XHRcdFx0cGFyZW50RG9tLnZhbHVlID0gJyc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBwcmUtY2FsY3VsYXRlZCB0aGUgbmV4dERPTSBub2RlLCB1c2UgaXQuIEVsc2UgY2FsY3VsYXRlIGl0IG5vd1xuXHRcdFx0XHRcdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdFx0XHRcdFx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdFx0XHRcdFx0aWYgKG5leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0b2xkRG9tID0gbmV4dERvbTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b2xkRG9tID0gbmV3RG9tLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHQvLyBCZWNhdXNlIHRoZSBuZXdQYXJlbnRWTm9kZSBpcyBGcmFnbWVudC1saWtlLCB3ZSBuZWVkIHRvIHNldCBpdCdzXG5cdFx0XHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdFx0Ly8gYG9sZERvbWAgY29udGFpbnMgdGhlIGNvcnJlY3QgdmFsdWUgaGVyZSBiZWNhdXNlIGlmIHRoZSBsYXN0IGNoaWxkXG5cdFx0XHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHRcdFx0Ly8gbm9kZSdzIG5leHRTaWJsaW5nLlxuXG5cdFx0XHRcdFx0XHRuZXdQYXJlbnRWTm9kZS5fbmV4dERvbSA9IG9sZERvbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0b2xkRG9tICYmXG5cdFx0XHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdFx0XHRvbGREb20gPSBnZXREb21TaWJsaW5nKG9sZFZOb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpKys7XG5cdFx0XHRyZXR1cm4gY2hpbGRWTm9kZTtcblx0XHR9XG5cdCk7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwgJiYgdHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgIT0gJ2Z1bmN0aW9uJykge1xuXHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbltpXSAhPSBudWxsKSByZW1vdmVOb2RlKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgcmVtYWluaW5nIG9sZENoaWxkcmVuIGlmIHRoZXJlIGFyZSBhbnkuXG5cdGZvciAoaSA9IG9sZENoaWxkcmVuTGVuZ3RoOyBpLS07ICkge1xuXHRcdGlmIChvbGRDaGlsZHJlbltpXSAhPSBudWxsKSB1bm1vdW50KG9sZENoaWxkcmVuW2ldLCBvbGRDaGlsZHJlbltpXSk7XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0geyh2bm9kZTogaW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlKSA9PiBpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtjYWxsYmFja11cbiAqIEEgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkIGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgZmxhdHRlbmVkIGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZSB8IHN0cmluZyB8IG51bWJlcj59IFtmbGF0dGVuZWRdIEFuIGZsYXQgYXJyYXkgb2YgY2hpbGRyZW4gdG8gbW9kaWZ5XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIGNhbGxiYWNrLCBmbGF0dGVuZWQpIHtcblx0aWYgKGZsYXR0ZW5lZCA9PSBudWxsKSBmbGF0dGVuZWQgPSBbXTtcblxuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSBmbGF0dGVuZWQucHVzaChjYWxsYmFjayhudWxsKSk7XG5cdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGRyZW5baV0sIGNhbGxiYWNrLCBmbGF0dGVuZWQpO1xuXHRcdH1cblx0fSBlbHNlIGlmICghY2FsbGJhY2spIHtcblx0XHRmbGF0dGVuZWQucHVzaChjaGlsZHJlbik7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGNoaWxkcmVuID09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnbnVtYmVyJykge1xuXHRcdGZsYXR0ZW5lZC5wdXNoKGNhbGxiYWNrKGNyZWF0ZVZOb2RlKG51bGwsIGNoaWxkcmVuLCBudWxsLCBudWxsLCBjaGlsZHJlbikpKTtcblx0fSBlbHNlIGlmIChjaGlsZHJlbi5fZG9tICE9IG51bGwgfHwgY2hpbGRyZW4uX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0ZmxhdHRlbmVkLnB1c2goXG5cdFx0XHRjYWxsYmFjayhcblx0XHRcdFx0Y3JlYXRlVk5vZGUoXG5cdFx0XHRcdFx0Y2hpbGRyZW4udHlwZSxcblx0XHRcdFx0XHRjaGlsZHJlbi5wcm9wcyxcblx0XHRcdFx0XHRjaGlsZHJlbi5rZXksXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHRjaGlsZHJlbi5fb3JpZ2luYWxcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0gZWxzZSB7XG5cdFx0ZmxhdHRlbmVkLnB1c2goY2FsbGJhY2soY2hpbGRyZW4pKTtcblx0fVxuXG5cdHJldHVybiBmbGF0dGVuZWQ7XG59XG4iLCJpbXBvcnQgeyBJU19OT05fRElNRU5TSU9OQUwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0aGUgb2xkIGFuZCBuZXcgcHJvcGVydGllcyBvZiBhIFZOb2RlIGFuZCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBhcHBseVxuICogY2hhbmdlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFRoZSBuZXcgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBUaGUgb2xkIHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBoeWRyYXRlIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb24gbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaHlkcmF0ZSkge1xuXHRsZXQgaTtcblxuXHRmb3IgKGkgaW4gb2xkUHJvcHMpIHtcblx0XHRpZiAoaSAhPT0gJ2NoaWxkcmVuJyAmJiBpICE9PSAna2V5JyAmJiAhKGkgaW4gbmV3UHJvcHMpKSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG51bGwsIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpIGluIG5ld1Byb3BzKSB7XG5cdFx0aWYgKFxuXHRcdFx0KCFoeWRyYXRlIHx8IHR5cGVvZiBuZXdQcm9wc1tpXSA9PSAnZnVuY3Rpb24nKSAmJlxuXHRcdFx0aSAhPT0gJ2NoaWxkcmVuJyAmJlxuXHRcdFx0aSAhPT0gJ2tleScgJiZcblx0XHRcdGkgIT09ICd2YWx1ZScgJiZcblx0XHRcdGkgIT09ICdjaGVja2VkJyAmJlxuXHRcdFx0b2xkUHJvcHNbaV0gIT09IG5ld1Byb3BzW2ldXG5cdFx0KSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG5ld1Byb3BzW2ldLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwga2V5LCB2YWx1ZSkge1xuXHRpZiAoa2V5WzBdID09PSAnLScpIHtcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcblx0fSBlbHNlIGlmIChcblx0XHR0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcblx0XHRJU19OT05fRElNRU5TSU9OQUwudGVzdChrZXkpID09PSBmYWxzZVxuXHQpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHMsIHVzZUNhcHR1cmUsIG5hbWVMb3dlcjtcblxuXHRpZiAoaXNTdmcpIHtcblx0XHRpZiAobmFtZSA9PT0gJ2NsYXNzTmFtZScpIHtcblx0XHRcdG5hbWUgPSAnY2xhc3MnO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG5cdFx0bmFtZSA9ICdjbGFzc05hbWUnO1xuXHR9XG5cblx0aWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRzID0gZG9tLnN0eWxlO1xuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0cy5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cy5jc3NUZXh0ID0gJyc7XG5cdFx0XHRcdG9sZFZhbHVlID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBpIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUocywgaSwgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbaV0gIT09IG9sZFZhbHVlW2ldKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShzLCBpLCB2YWx1ZVtpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXHRcdG5hbWVMb3dlciA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRuYW1lID0gKG5hbWVMb3dlciBpbiBkb20gPyBuYW1lTG93ZXIgOiBuYW1lKS5zbGljZSgyKTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkgZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZXZlbnRQcm94eSwgdXNlQ2FwdHVyZSk7XG5cdFx0XHQoZG9tLl9saXN0ZW5lcnMgfHwgKGRvbS5fbGlzdGVuZXJzID0ge30pKVtuYW1lXSA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoXG5cdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0bmFtZSAhPT0gJ3RhZ05hbWUnICYmXG5cdFx0Ly8gSFRNTEJ1dHRvbkVsZW1lbnQuZm9ybSBhbmQgSFRNTElucHV0RWxlbWVudC5mb3JtIGFyZSByZWFkLW9ubHkgYnV0IGNhbiBiZSBzZXQgdXNpbmdcblx0XHQvLyBzZXRBdHRyaWJ1dGVcblx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRuYW1lICE9PSAndHlwZScgJiZcblx0XHRuYW1lICE9PSAnc2l6ZScgJiZcblx0XHQhaXNTdmcgJiZcblx0XHRuYW1lIGluIGRvbVxuXHQpIHtcblx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ2Z1bmN0aW9uJyAmJiBuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9eeGxpbms6Py8sICcnKSkpIHtcblx0XHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlTlMoXG5cdFx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdFx0XHRcdG5hbWUudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9tLnNldEF0dHJpYnV0ZU5TKFxuXHRcdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHRcdFx0XHRuYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dmFsdWUgPT0gbnVsbCB8fFxuXHRcdFx0KHZhbHVlID09PSBmYWxzZSAmJlxuXHRcdFx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBub3Rpb24gb2YgYm9vbGVhbiB2YWx1ZXMuXG5cdFx0XHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0XHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0XHRcdC8vIEFSSUEtYXR0cmlidXRlcyB3ZSBjb3VsZCB0cmVhdCBmYWxzZSBhcyBhIHJlbW92YWwsIGJ1dCB0aGVcblx0XHRcdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0XHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXHRcdFx0XHQhL15hci8udGVzdChuYW1lKSlcblx0XHQpIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFByb3h5IGFuIGV2ZW50IHRvIGhvb2tlZCBldmVudCBoYW5kbGVyc1xuICogQHBhcmFtIHtFdmVudH0gZSBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGJyb3dzZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50UHJveHkoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKLCBFTVBUWV9BUlIgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7RWxlbWVudCB8IFRleHR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdGlmICgodG1wID0gb3B0aW9ucy5fZGlmZikpIHRtcChuZXdWTm9kZSk7XG5cblx0dHJ5IHtcblx0XHRvdXRlcjogaWYgKHR5cGVvZiBuZXdUeXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGxldCBjLCBpc05ldywgb2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCwgY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uO1xuXHRcdFx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0XHRcdC8vIE5lY2Vzc2FyeSBmb3IgY3JlYXRlQ29udGV4dCBhcGkuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHBhc3Ncblx0XHRcdC8vIHRoZSBjb250ZXh0IHZhbHVlIGFzIGB0aGlzLmNvbnRleHRgIGp1c3QgZm9yIHRoaXMgY29tcG9uZW50LlxuXHRcdFx0dG1wID0gbmV3VHlwZS5jb250ZXh0VHlwZTtcblx0XHRcdGxldCBwcm92aWRlciA9IHRtcCAmJiBnbG9iYWxDb250ZXh0W3RtcC5faWRdO1xuXHRcdFx0bGV0IGNvbXBvbmVudENvbnRleHQgPSB0bXBcblx0XHRcdFx0PyBwcm92aWRlclxuXHRcdFx0XHRcdD8gcHJvdmlkZXIucHJvcHMudmFsdWVcblx0XHRcdFx0XHQ6IHRtcC5fZGVmYXVsdFZhbHVlXG5cdFx0XHRcdDogZ2xvYmFsQ29udGV4dDtcblxuXHRcdFx0Ly8gR2V0IGNvbXBvbmVudCBhbmQgc2V0IGl0IHRvIGBjYFxuXHRcdFx0aWYgKG9sZFZOb2RlLl9jb21wb25lbnQpIHtcblx0XHRcdFx0YyA9IG5ld1ZOb2RlLl9jb21wb25lbnQgPSBvbGRWTm9kZS5fY29tcG9uZW50O1xuXHRcdFx0XHRjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcGVuZGluZ0Vycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIG5ldyBjb21wb25lbnRcblx0XHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdChuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbCAmJiAhYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0Ly8gTW9yZSBpbmZvIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSm92aURlQ3Jvb2NrL2JlYzVmMmNlOTM1NDRkMmU2MDcwZWY4ZTAwMzZlNGU4XG5cdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9vcmlnaW5hbCAhPT0gb2xkVk5vZGUuX29yaWdpbmFsKSBjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGZvciAodG1wID0gMDsgdG1wIDwgbmV3Vk5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgdG1wKyspIHtcblx0XHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fY2hpbGRyZW5bdG1wXSkge1xuXHRcdFx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW5bdG1wXS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnRXaWxsVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIGMuX25leHRTdGF0ZSwgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0XHRcdGMuY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuX3JlbmRlcikpIHRtcChuZXdWTm9kZSk7XG5cblx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXHRcdFx0Yy5fcGFyZW50RG9tID0gcGFyZW50RG9tO1xuXG5cdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09IEZyYWdtZW50ICYmIHRtcC5rZXkgPT0gbnVsbDtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IGlzVG9wTGV2ZWxGcmFnbWVudFxuXHRcdFx0XHQ/IHRtcC5wcm9wcy5jaGlsZHJlblxuXHRcdFx0XHQ6IEFycmF5LmlzQXJyYXkodG1wKVxuXHRcdFx0XHQ/IHRtcFxuXHRcdFx0XHQ6IFt0bXBdO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBuZXdWTm9kZSwgb2xkVk5vZGUpO1xuXHR9XG5cblx0cmV0dXJuIG5ld1ZOb2RlLl9kb207XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHJvb3QpIHtcblx0aWYgKG9wdGlvbnMuX2NvbW1pdCkgb3B0aW9ucy5fY29tbWl0KHJvb3QsIGNvbW1pdFF1ZXVlKTtcblxuXHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdGNiLmNhbGwoYyk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgcmVwcmVzZW50aW5nIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZ1xuICogdGhlIHZpcnR1YWwgbm9kZXMgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHsqfSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZFbGVtZW50Tm9kZXMoXG5cdGRvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBpO1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlzU3ZnID0gbmV3Vk5vZGUudHlwZSA9PT0gJ3N2ZycgfHwgaXNTdmc7XG5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICE9IG51bGwgJiZcblx0XHRcdFx0KChuZXdWTm9kZS50eXBlID09PSBudWxsXG5cdFx0XHRcdFx0PyBjaGlsZC5ub2RlVHlwZSA9PT0gM1xuXHRcdFx0XHRcdDogY2hpbGQubG9jYWxOYW1lID09PSBuZXdWTm9kZS50eXBlKSB8fFxuXHRcdFx0XHRcdGRvbSA9PSBjaGlsZClcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobmV3Vk5vZGUudHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRkb20gPSBpc1N2Z1xuXHRcdFx0PyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmV3Vk5vZGUudHlwZSlcblx0XHRcdDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHRuZXdWTm9kZS50eXBlLFxuXHRcdFx0XHRcdG5ld1Byb3BzLmlzICYmIHsgaXM6IG5ld1Byb3BzLmlzIH1cblx0XHRcdCAgKTtcblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChuZXdWTm9kZS50eXBlID09PSBudWxsKSB7XG5cdFx0aWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyAmJiBkb20uZGF0YSAhPSBuZXdQcm9wcykge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gRU1QVFlfQVJSLnNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuXHRcdH1cblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKG9sZFByb3BzID09PSBFTVBUWV9PQkopIHtcblx0XHRcdFx0b2xkUHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKCFuZXdIdG1sIHx8ICFvbGRIdG1sIHx8IG5ld0h0bWwuX19odG1sICE9IG9sZEh0bWwuX19odG1sKSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdG5ld1ZOb2RlLnR5cGUgPT09ICdmb3JlaWduT2JqZWN0JyA/IGZhbHNlIDogaXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0RU1QVFlfT0JKLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20udmFsdWVcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkgYXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHR9XG5cblx0bGV0IGRvbTtcblx0aWYgKCFza2lwUmVtb3ZlICYmIHR5cGVvZiB2bm9kZS50eXBlICE9ICdmdW5jdGlvbicpIHtcblx0XHRza2lwUmVtb3ZlID0gKGRvbSA9IHZub2RlLl9kb20pICE9IG51bGw7XG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCB0byBgdW5kZWZpbmVkYCB0byBwcm9wZXJseSBjbGVhbiB1cCBgX25leHREb21gXG5cdC8vIGZvciB3aGljaCBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZS4gU2VlIGNvbW1lbnQgaW4gYGNyZWF0ZS1lbGVtZW50LmpzYFxuXHR2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkgdW5tb3VudChyW2ldLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSAhPSBudWxsKSByZW1vdmVOb2RlKGRvbSk7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBFTVBUWV9BUlIgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gVk5vZGUsIG9wdGlvbmFsbHkgYWRkaW5nIGF0dHJpYnV0ZXMvcHJvcHMgYW5kIHJlcGxhY2luZyBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBET00gZWxlbWVudCB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBjaGlsZHJlbi5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMpIHtcblx0cHJvcHMgPSBhc3NpZ24oYXNzaWduKHt9LCB2bm9kZS5wcm9wcyksIHByb3BzKTtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSBwcm9wcy5jaGlsZHJlbiA9IEVNUFRZX0FSUi5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fTtcblx0Zm9yIChjb25zdCBpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdrZXknICYmIGkgIT09ICdyZWYnKSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZShcblx0XHR2bm9kZS50eXBlLFxuXHRcdG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRwcm9wcy5rZXkgfHwgdm5vZGUua2V5LFxuXHRcdHByb3BzLnJlZiB8fCB2bm9kZS5yZWYsXG5cdFx0bnVsbFxuXHQpO1xufVxuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hFcnJvcihlcnJvciwgdm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50LCBoYXNDYXVnaHQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRjb21wb25lbnQuY29uc3RydWN0b3IgJiZcblx0XHRcdFx0XHRjb21wb25lbnQuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aGFzQ2F1Z2h0ID0gdHJ1ZTtcblx0XHRcdFx0XHRjb21wb25lbnQuc2V0U3RhdGUoXG5cdFx0XHRcdFx0XHRjb21wb25lbnQuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRoYXNDYXVnaHQgPSB0cnVlO1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaChlcnJvcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaGFzQ2F1Z2h0KVxuXHRcdFx0XHRcdHJldHVybiBlbnF1ZXVlUmVuZGVyKChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/preact/dist/preact.module.js\n");

/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useState\": function() { return /* binding */ m; },\n/* harmony export */   \"useReducer\": function() { return /* binding */ p; },\n/* harmony export */   \"useEffect\": function() { return /* binding */ l; },\n/* harmony export */   \"useLayoutEffect\": function() { return /* binding */ y; },\n/* harmony export */   \"useRef\": function() { return /* binding */ d; },\n/* harmony export */   \"useImperativeHandle\": function() { return /* binding */ s; },\n/* harmony export */   \"useMemo\": function() { return /* binding */ h; },\n/* harmony export */   \"useCallback\": function() { return /* binding */ T; },\n/* harmony export */   \"useContext\": function() { return /* binding */ w; },\n/* harmony export */   \"useDebugValue\": function() { return /* binding */ A; },\n/* harmony export */   \"useErrorBoundary\": function() { return /* binding */ F; }\n/* harmony export */ });\n/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ \"./node_modules/preact/dist/preact.module.js\");\n\nvar t,\n    u,\n    r,\n    i = 0,\n    o = [],\n    c = preact__WEBPACK_IMPORTED_MODULE_0__.options.__r,\n    f = preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed,\n    e = preact__WEBPACK_IMPORTED_MODULE_0__.options.__c,\n    a = preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount;\n\nfunction v(t, r) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.__h && preact__WEBPACK_IMPORTED_MODULE_0__.options.__h(u, t, i || r), i = 0;\n  var o = u.__H || (u.__H = {\n    __: [],\n    __h: []\n  });\n  return t >= o.__.length && o.__.push({}), o.__[t];\n}\n\nfunction m(n) {\n  return i = 1, p(E, n);\n}\n\nfunction p(n, r, i) {\n  var o = v(t++, 2);\n  return o.__c || (o.__c = u, o.__ = [i ? i(r) : E(void 0, r), function (t) {\n    var u = n(o.__[0], t);\n    o.__[0] !== u && (o.__[0] = u, o.__c.setState({}));\n  }]), o.__;\n}\n\nfunction l(r, i) {\n  var o = v(t++, 3);\n  !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && x(o.__H, i) && (o.__ = r, o.__H = i, u.__H.__h.push(o));\n}\n\nfunction y(r, i) {\n  var o = v(t++, 4);\n  !preact__WEBPACK_IMPORTED_MODULE_0__.options.__s && x(o.__H, i) && (o.__ = r, o.__H = i, u.__h.push(o));\n}\n\nfunction d(n) {\n  return i = 5, h(function () {\n    return {\n      current: n\n    };\n  }, []);\n}\n\nfunction s(n, t, u) {\n  i = 6, y(function () {\n    \"function\" == typeof n ? n(t()) : n && (n.current = t());\n  }, null == u ? u : u.concat(n));\n}\n\nfunction h(n, u) {\n  var r = v(t++, 7);\n  return x(r.__H, u) ? (r.__H = u, r.__h = n, r.__ = n()) : r.__;\n}\n\nfunction T(n, t) {\n  return i = 8, h(function () {\n    return n;\n  }, t);\n}\n\nfunction w(n) {\n  var r = u.context[n.__c],\n      i = v(t++, 9);\n  return i.__c = n, r ? (null == i.__ && (i.__ = !0, r.sub(u)), r.props.value) : n.__;\n}\n\nfunction A(t, u) {\n  preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue && preact__WEBPACK_IMPORTED_MODULE_0__.options.useDebugValue(u ? u(t) : t);\n}\n\nfunction F(n) {\n  var r = v(t++, 10),\n      i = m();\n  return r.__ = n, u.componentDidCatch || (u.componentDidCatch = function (n) {\n    r.__ && r.__(n), i[1](n);\n  }), [i[0], function () {\n    i[1](void 0);\n  }];\n}\n\nfunction _() {\n  o.some(function (t) {\n    if (t.__P) try {\n      t.__H.__h.forEach(g), t.__H.__h.forEach(q), t.__H.__h = [];\n    } catch (u) {\n      return t.__H.__h = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(u, t.__v), !0;\n    }\n  }), o = [];\n}\n\nfunction g(n) {\n  n.t && n.t();\n}\n\nfunction q(n) {\n  var t = n.__();\n\n  \"function\" == typeof t && (n.t = t);\n}\n\nfunction x(n, t) {\n  return !n || t.some(function (t, u) {\n    return t !== n[u];\n  });\n}\n\nfunction E(n, t) {\n  return \"function\" == typeof t ? t(n) : t;\n}\n\npreact__WEBPACK_IMPORTED_MODULE_0__.options.__r = function (n) {\n  c && c(n), t = 0, (u = n.__c).__H && (u.__H.__h.forEach(g), u.__H.__h.forEach(q), u.__H.__h = []);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.diffed = function (t) {\n  f && f(t);\n  var u = t.__c;\n\n  if (u) {\n    var i = u.__H;\n    i && i.__h.length && (1 !== o.push(u) && r === preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame || ((r = preact__WEBPACK_IMPORTED_MODULE_0__.options.requestAnimationFrame) || function (n) {\n      var t,\n          u = function u() {\n        clearTimeout(r), cancelAnimationFrame(t), setTimeout(n);\n      },\n          r = setTimeout(u, 100);\n\n      \"undefined\" != typeof window && (t = requestAnimationFrame(u));\n    })(_));\n  }\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.__c = function (t, u) {\n  u.some(function (t) {\n    try {\n      t.__h.forEach(g), t.__h = t.__h.filter(function (n) {\n        return !n.__ || q(n);\n      });\n    } catch (r) {\n      u.some(function (n) {\n        n.__h && (n.__h = []);\n      }), u = [], preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(r, t.__v);\n    }\n  }), e && e(t, u);\n}, preact__WEBPACK_IMPORTED_MODULE_0__.options.unmount = function (t) {\n  a && a(t);\n  var u = t.__c;\n\n  if (u) {\n    var r = u.__H;\n    if (r) try {\n      r.__.forEach(function (n) {\n        return n.t && n.t();\n      });\n    } catch (t) {\n      preact__WEBPACK_IMPORTED_MODULE_0__.options.__e(t, u.__v);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL2Rpc3QvaG9va3MubW9kdWxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBdUZBO0FBQ0E7QUFHQTtBQVVBO0FBQ0E7QUFGQTtBQUVBO0FBWUE7O0FBQUE7QUFBQTtBQVdBOztBQUFBO0FBQUE7QUFFQTtBQU9BO0FBRUE7QUFFQTtBQWFBOztBQUFBO0FBQUE7QUFFQTtBQWFBOztBQUFBO0FBQUE7QUFFQTtBQVNBOztBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQVFBOztBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBVUE7O0FBQUE7QUFBQTtBQUVBO0FBY0E7O0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFNQTs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQWtCQTs7QUFBQTtBQUNBO0FBS0E7O0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFJQTtBQUNBO0FBTUE7QUFBQTtBQVFBOztBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBR0E7QUFBQTtBQUdBO0FBQUE7QUFnREE7O0FBQUE7QUFDQTtBQU9BOztBQUFBO0FBQUE7O0FBRUE7QUFPQTs7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUdBOztBQUFBO0FBQUE7QUFoVkE7O0FBQUE7QUFDQTtBQVFBO0FBS0E7QUFBQTs7QUFFQTtBQUNBO0FBR0E7QUF3UUE7QUFBQTtBQUVBO0FBRUE7QUFKQTs7QUFTQTtBQUNBO0FBY0E7QUFBQTtBQXhSQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUFBO0FBSUE7QUFJQTtBQUFBOztBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5kZXguanM/YTE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xubGV0IG9sZEFmdGVyRGlmZiA9IG9wdGlvbnMuZGlmZmVkO1xubGV0IG9sZENvbW1pdCA9IG9wdGlvbnMuX2NvbW1pdDtcbmxldCBvbGRCZWZvcmVVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xuXG5jb25zdCBSQUZfVElNRU9VVCA9IDEwMDtcbmxldCBwcmV2UmFmO1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0aWYgKGN1cnJlbnRDb21wb25lbnQuX19ob29rcykge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdH1cbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoIWMpIHJldHVybjtcblxuXHRjb25zdCBob29rcyA9IGMuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIHtcblx0XHRcdGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0fVxuXHR9XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmICghYykgcmV0dXJuO1xuXG5cdGNvbnN0IGhvb2tzID0gYy5fX2hvb2tzO1xuXHRpZiAoaG9va3MpIHtcblx0XHR0cnkge1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rID0+IGhvb2suX2NsZWFudXAgJiYgaG9vay5fY2xlYW51cCgpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuSG9va1N0YXRlfVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7fSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBpbml0aWFsU3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBuZXh0VmFsdWUgPSByZWR1Y2VyKGhvb2tTdGF0ZS5fdmFsdWVbMF0sIGFjdGlvbik7XG5cdFx0XHRcdGlmIChob29rU3RhdGUuX3ZhbHVlWzBdICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX3ZhbHVlWzBdID0gbmV4dFZhbHVlO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9hcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9hcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wdXNoKHN0YXRlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuXHRjdXJyZW50SG9vayA9IDU7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+ICh7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9KSwgW10pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7KCkgPT4gb2JqZWN0fSBjcmVhdGVIYW5kbGVcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGVIYW5kbGUsIGFyZ3MpIHtcblx0Y3VycmVudEhvb2sgPSA2O1xuXHR1c2VMYXlvdXRFZmZlY3QoXG5cdFx0KCkgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdGVsc2UgaWYgKHJlZikgcmVmLmN1cnJlbnQgPSBjcmVhdGVIYW5kbGUoKTtcblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9hcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIChzdGF0ZS5fdmFsdWUgPSBmYWN0b3J5KCkpO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgOSk7XG5cdC8vIFRoZSBkZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHRvXG5cdC8vIGJlIGFibGUgdG8gcHVsbCBvZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIG5vIHByb3ZpZGVyXG5cdC8vIGlzIHByZXNlbnQgaW4gdGhlIHRyZWUuXG5cdHN0YXRlLl9jb250ZXh0ID0gY29udGV4dDtcblx0aWYgKCFwcm92aWRlcikgcmV0dXJuIGNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcblx0Ly8gVGhpcyBpcyBwcm9iYWJseSBub3Qgc2FmZSB0byBjb252ZXJ0IHRvIFwiIVwiXG5cdGlmIChzdGF0ZS5fdmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IHRydWU7XG5cdFx0cHJvdmlkZXIuc3ViKGN1cnJlbnRDb21wb25lbnQpO1xuXHR9XG5cdHJldHVybiBwcm92aWRlci5wcm9wcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgY3VzdG9tIGxhYmVsIGZvciBhIGN1c3RvbSBob29rIGZvciB0aGUgZGV2dG9vbHMgcGFuZWxcbiAqIEB0eXBlIHs8VD4odmFsdWU6IFQsIGNiPzogKHZhbHVlOiBUKSA9PiBzdHJpbmcgfCBudW1iZXIpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXIpIHtcblx0aWYgKG9wdGlvbnMudXNlRGVidWdWYWx1ZSkge1xuXHRcdG9wdGlvbnMudXNlRGVidWdWYWx1ZShmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIodmFsdWUpIDogdmFsdWUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSBlcnIgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVycik7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRhZnRlclBhaW50RWZmZWN0cy5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0aWYgKGNvbXBvbmVudC5fcGFyZW50RG9tKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0Y2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrKTtcblx0fTtcblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZG9uZSwgUkFGX1RJTUVPVVQpO1xuXG5cdGxldCByYWY7XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnKSB7XG5cdFx0cmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvbmUpO1xuXHR9XG59XG5cbi8vIE5vdGU6IGlmIHNvbWVvbmUgdXNlZCBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuLy8gdGhlbiBlZmZlY3RzIHdpbGwgQUxXQVlTIHJ1biBvbiB0aGUgTkVYVCBmcmFtZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZSwgaW5jdXJyaW5nIGEgfjE2bXMgZGVsYXkuXG4vLyBQZXJoYXBzIHRoaXMgaXMgbm90IHN1Y2ggYSBiaWcgZGVhbC5cbi8qKlxuICogU2NoZWR1bGUgYWZ0ZXJQYWludEVmZmVjdHMgZmx1c2ggYWZ0ZXIgdGhlIGJyb3dzZXIgcGFpbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3UXVldWVMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJQYWludChuZXdRdWV1ZUxlbmd0aCkge1xuXHRpZiAobmV3UXVldWVMZW5ndGggPT09IDEgfHwgcHJldlJhZiAhPT0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRwcmV2UmFmID0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0KHByZXZSYWYgfHwgYWZ0ZXJOZXh0RnJhbWUpKGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2xlYW51cChob29rKSB7XG5cdGlmIChob29rLl9jbGVhbnVwKSBob29rLl9jbGVhbnVwKCk7XG59XG5cbi8qKlxuICogSW52b2tlIGEgSG9vaydzIGVmZmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlRWZmZWN0KGhvb2spIHtcblx0Y29uc3QgcmVzdWx0ID0gaG9vay5fdmFsdWUoKTtcblx0aWYgKHR5cGVvZiByZXN1bHQgPT0gJ2Z1bmN0aW9uJykgaG9vay5fY2xlYW51cCA9IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBvbGRBcmdzXG4gKiBAcGFyYW0ge2FueVtdfSBuZXdBcmdzXG4gKi9cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3MsIG5ld0FyZ3MpIHtcblx0cmV0dXJuICFvbGRBcmdzIHx8IG5ld0FyZ3Muc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/preact/hooks/dist/hooks.module.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.css":
/*!****************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.css ***!
  \****************************************************/
/***/ (function(module) {

module.exports = "\n/* classes attached to <body> */\n/* TODO: make fc-event selector work when calender in shadow DOM */\n.fc-not-allowed,\n.fc-not-allowed .fc-event { /* override events' custom cursors */\n  cursor: not-allowed;\n}\n\n/* TODO: not attached to body. attached to specific els. move */\n.fc-unselectable {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-touch-callout: none;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n.fc {\n  /* layout of immediate children */\n  display: flex;\n  flex-direction: column;\n\n  font-size: 1em\n}\n.fc,\n  .fc *,\n  .fc *:before,\n  .fc *:after {\n    box-sizing: border-box;\n  }\n.fc table {\n    border-collapse: collapse;\n    border-spacing: 0;\n    font-size: 1em; /* normalize cross-browser */\n  }\n.fc th {\n    text-align: center;\n  }\n.fc th,\n  .fc td {\n    vertical-align: top;\n    padding: 0;\n  }\n.fc a[data-navlink] {\n    cursor: pointer;\n  }\n.fc a[data-navlink]:hover {\n    text-decoration: underline;\n  }\n.fc-direction-ltr {\n  direction: ltr;\n  text-align: left;\n}\n.fc-direction-rtl {\n  direction: rtl;\n  text-align: right;\n}\n.fc-theme-standard td,\n  .fc-theme-standard th {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n  }\n/* for FF, which doesn't expand a 100% div within a table cell. use absolute positioning */\n/* inner-wrappers are responsible for being absolute */\n/* TODO: best place for this? */\n.fc-liquid-hack td,\n  .fc-liquid-hack th {\n    position: relative;\n  }\n\n@font-face {\n  font-family: 'fcicons';\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format('truetype');\n  font-weight: normal;\n  font-style: normal;\n}\n\n.fc-icon {\n  /* added for fc */\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: 'fcicons' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.fc-icon-chevron-left:before {\n  content: \"\\e900\";\n}\n\n.fc-icon-chevron-right:before {\n  content: \"\\e901\";\n}\n\n.fc-icon-chevrons-left:before {\n  content: \"\\e902\";\n}\n\n.fc-icon-chevrons-right:before {\n  content: \"\\e903\";\n}\n\n.fc-icon-minus-square:before {\n  content: \"\\e904\";\n}\n\n.fc-icon-plus-square:before {\n  content: \"\\e905\";\n}\n\n.fc-icon-x:before {\n  content: \"\\e906\";\n}\n/*\nLots taken from Flatly (MIT): https://bootswatch.com/4/flatly/bootstrap.css\n\nThese styles only apply when the standard-theme is activated.\nWhen it's NOT activated, the fc-button classes won't even be in the DOM.\n*/\n.fc {\n\n  /* reset */\n\n}\n.fc .fc-button {\n    border-radius: 0;\n    overflow: visible;\n    text-transform: none;\n    margin: 0;\n    font-family: inherit;\n    font-size: inherit;\n    line-height: inherit;\n  }\n.fc .fc-button:focus {\n    outline: 1px dotted;\n    outline: 5px auto -webkit-focus-ring-color;\n  }\n.fc .fc-button {\n    -webkit-appearance: button;\n  }\n.fc .fc-button:not(:disabled) {\n    cursor: pointer;\n  }\n.fc .fc-button::-moz-focus-inner {\n    padding: 0;\n    border-style: none;\n  }\n.fc {\n\n  /* theme */\n\n}\n.fc .fc-button {\n    display: inline-block;\n    font-weight: 400;\n    text-align: center;\n    vertical-align: middle;\n    -webkit-user-select: none;\n       -moz-user-select: none;\n        -ms-user-select: none;\n            user-select: none;\n    background-color: transparent;\n    border: 1px solid transparent;\n    padding: 0.4em 0.65em;\n    font-size: 1em;\n    line-height: 1.5;\n    border-radius: 0.25em;\n  }\n.fc .fc-button:hover {\n    text-decoration: none;\n  }\n.fc .fc-button:focus {\n    outline: 0;\n    box-shadow: 0 0 0 0.2rem rgba(44, 62, 80, 0.25);\n  }\n.fc .fc-button:disabled {\n    opacity: 0.65;\n  }\n.fc {\n\n  /* \"primary\" coloring */\n\n}\n.fc .fc-button-primary {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #2C3E50;\n    background-color: var(--fc-button-bg-color, #2C3E50);\n    border-color: #2C3E50;\n    border-color: var(--fc-button-border-color, #2C3E50);\n  }\n.fc .fc-button-primary:hover {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #1e2b37;\n    background-color: var(--fc-button-hover-bg-color, #1e2b37);\n    border-color: #1a252f;\n    border-color: var(--fc-button-hover-border-color, #1a252f);\n  }\n.fc .fc-button-primary:disabled { /* not DRY */\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #2C3E50;\n    background-color: var(--fc-button-bg-color, #2C3E50);\n    border-color: #2C3E50;\n    border-color: var(--fc-button-border-color, #2C3E50); /* overrides :hover */\n  }\n.fc .fc-button-primary:focus {\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n  }\n.fc .fc-button-primary:not(:disabled):active,\n  .fc .fc-button-primary:not(:disabled).fc-button-active {\n    color: #fff;\n    color: var(--fc-button-text-color, #fff);\n    background-color: #1a252f;\n    background-color: var(--fc-button-active-bg-color, #1a252f);\n    border-color: #151e27;\n    border-color: var(--fc-button-active-border-color, #151e27);\n  }\n.fc .fc-button-primary:not(:disabled):active:focus,\n  .fc .fc-button-primary:not(:disabled).fc-button-active:focus {\n    box-shadow: 0 0 0 0.2rem rgba(76, 91, 106, 0.5);\n  }\n.fc {\n\n  /* icons within buttons */\n\n}\n.fc .fc-button .fc-icon {\n    vertical-align: middle;\n    font-size: 1.5em; /* bump up the size (but don't make it bigger than line-height of button, which is 1.5em also) */\n  }\n.fc .fc-button-group {\n    position: relative;\n    display: inline-flex;\n    vertical-align: middle;\n  }\n.fc .fc-button-group > .fc-button {\n    position: relative;\n    flex: 1 1 auto;\n  }\n.fc .fc-button-group > .fc-button:hover {\n    z-index: 1;\n  }\n.fc .fc-button-group > .fc-button:focus,\n  .fc .fc-button-group > .fc-button:active,\n  .fc .fc-button-group > .fc-button.fc-button-active {\n    z-index: 1;\n  }\n.fc-direction-ltr .fc-button-group > .fc-button:not(:first-child) {\n    margin-left: -1px;\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n.fc-direction-ltr .fc-button-group > .fc-button:not(:last-child) {\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n.fc-direction-rtl .fc-button-group > .fc-button:not(:first-child) {\n    margin-right: -1px;\n    border-top-right-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n.fc-direction-rtl .fc-button-group > .fc-button:not(:last-child) {\n    border-top-left-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n.fc .fc-toolbar {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n  }\n.fc .fc-toolbar.fc-header-toolbar {\n    margin-bottom: 1.5em;\n  }\n.fc .fc-toolbar.fc-footer-toolbar {\n    margin-top: 1.5em;\n  }\n.fc .fc-toolbar-title {\n    font-size: 1.75em;\n    margin: 0;\n  }\n.fc-direction-ltr .fc-toolbar > * > :not(:first-child) {\n    margin-left: .75em; /* space between */\n  }\n.fc-direction-rtl .fc-toolbar > * > :not(:first-child) {\n    margin-right: .75em; /* space between */\n  }\n.fc-direction-rtl .fc-toolbar-ltr { /* when the toolbar-chunk positioning system is explicitly left-to-right */\n    flex-direction: row-reverse;\n  }\n.fc .fc-scroller {\n    -webkit-overflow-scrolling: touch;\n    position: relative; /* for abs-positioned elements within */\n  }\n.fc .fc-scroller-liquid {\n    height: 100%;\n  }\n.fc .fc-scroller-liquid-absolute {\n    position: absolute;\n    top: 0;\n    right: 0;\n    left: 0;\n    bottom: 0;\n  }\n.fc .fc-scroller-harness {\n    position: relative;\n    overflow: hidden;\n    direction: ltr;\n      /* hack for chrome computing the scroller's right/left wrong for rtl. undone below... */\n      /* TODO: demonstrate in codepen */\n  }\n.fc .fc-scroller-harness-liquid {\n    height: 100%;\n  }\n.fc-direction-rtl .fc-scroller-harness > .fc-scroller { /* undo above hack */\n    direction: rtl;\n  }\n.fc-theme-standard .fc-scrollgrid {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd); /* bootstrap does this. match */\n  }\n.fc .fc-scrollgrid,\n    .fc .fc-scrollgrid table { /* all tables (self included) */\n      width: 100%; /* because tables don't normally do this */\n      table-layout: fixed;\n    }\n.fc .fc-scrollgrid table { /* inner tables */\n      border-top-style: hidden;\n      border-left-style: hidden;\n      border-right-style: hidden;\n    }\n.fc .fc-scrollgrid {\n\n    border-collapse: separate;\n    border-right-width: 0;\n    border-bottom-width: 0;\n\n  }\n.fc .fc-scrollgrid-liquid {\n    height: 100%;\n  }\n.fc .fc-scrollgrid-section { /* a <tr> */\n    height: 1px /* better than 0, for firefox */\n\n  }\n.fc .fc-scrollgrid-section > td {\n      height: 1px; /* needs a height so inner div within grow. better than 0, for firefox */\n    }\n.fc .fc-scrollgrid-section table {\n      height: 1px;\n        /* for most browsers, if a height isn't set on the table, can't do liquid-height within cells */\n        /* serves as a min-height. harmless */\n    }\n.fc .fc-scrollgrid-section-liquid > td {\n      height: 100%; /* better than `auto`, for firefox */\n    }\n.fc .fc-scrollgrid-section > * {\n    border-top-width: 0;\n    border-left-width: 0;\n  }\n.fc .fc-scrollgrid-section-header > *,\n  .fc .fc-scrollgrid-section-footer > * {\n    border-bottom-width: 0;\n  }\n.fc .fc-scrollgrid-section-body table,\n  .fc .fc-scrollgrid-section-footer table {\n    border-bottom-style: hidden; /* head keeps its bottom border tho */\n  }\n.fc {\n\n  /* stickiness */\n\n}\n.fc .fc-scrollgrid-section-sticky > * {\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff);\n    position: sticky;\n    z-index: 3; /* TODO: var */\n    /* TODO: box-shadow when sticking */\n  }\n.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky > * {\n    top: 0; /* because border-sharing causes a gap at the top */\n      /* TODO: give safari -1. has bug */\n  }\n.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky > * {\n    bottom: 0; /* known bug: bottom-stickiness doesn't work in safari */\n  }\n.fc .fc-scrollgrid-sticky-shim { /* for horizontal scrollbar */\n    height: 1px; /* needs height to create scrollbars */\n    margin-bottom: -1px;\n  }\n.fc-sticky { /* no .fc wrap because used as child of body */\n  position: sticky;\n}\n.fc .fc-view-harness {\n    flex-grow: 1; /* because this harness is WITHIN the .fc's flexbox */\n    position: relative;\n  }\n.fc {\n\n  /* when the harness controls the height, make the view liquid */\n\n}\n.fc .fc-view-harness-active > .fc-view {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n  }\n.fc .fc-col-header-cell-cushion {\n    display: inline-block; /* x-browser for when sticky (when multi-tier header) */\n    padding: 2px 4px;\n  }\n.fc .fc-bg-event,\n  .fc .fc-non-business,\n  .fc .fc-highlight {\n    /* will always have a harness with position:relative/absolute, so absolutely expand */\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n.fc .fc-non-business {\n    background: rgba(215, 215, 215, 0.3);\n    background: var(--fc-non-business-color, rgba(215, 215, 215, 0.3));\n  }\n.fc .fc-bg-event {\n    background: rgb(143, 223, 130);\n    background: var(--fc-bg-event-color, rgb(143, 223, 130));\n    opacity: 0.3;\n    opacity: var(--fc-bg-event-opacity, 0.3)\n  }\n.fc .fc-bg-event .fc-event-title {\n      margin: .5em;\n      font-size: .85em;\n      font-size: var(--fc-small-font-size, .85em);\n      font-style: italic;\n    }\n.fc .fc-highlight {\n    background: rgba(188, 232, 241, 0.3);\n    background: var(--fc-highlight-color, rgba(188, 232, 241, 0.3));\n  }\n.fc .fc-cell-shaded,\n  .fc .fc-day-disabled {\n    background: rgba(208, 208, 208, 0.3);\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n/* link resets */\n/* ---------------------------------------------------------------------------------------------------- */\na.fc-event,\na.fc-event:hover {\n  text-decoration: none;\n}\n/* cursor */\n.fc-event[href],\n.fc-event.fc-event-draggable {\n  cursor: pointer;\n}\n/* event text content */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event .fc-event-main {\n    position: relative;\n    z-index: 2;\n  }\n/* dragging */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event-dragging:not(.fc-event-selected) { /* MOUSE */\n    opacity: 0.75;\n  }\n.fc-event-dragging.fc-event-selected { /* TOUCH */\n    box-shadow: 0 2px 7px rgba(0, 0, 0, 0.3);\n  }\n/* resizing */\n/* ---------------------------------------------------------------------------------------------------- */\n/* (subclasses should hone positioning for touch and non-touch) */\n.fc-event .fc-event-resizer {\n    display: none;\n    position: absolute;\n    z-index: 4;\n  }\n.fc-event:hover, /* MOUSE */\n.fc-event-selected { /* TOUCH */\n\n}\n.fc-event:hover .fc-event-resizer, .fc-event-selected .fc-event-resizer {\n    display: block;\n  }\n.fc-event-selected .fc-event-resizer {\n    border-radius: 4px;\n    border-radius: calc(var(--fc-event-resizer-dot-total-width, 8px) / 2);\n    border-width: 1px;\n    border-width: var(--fc-event-resizer-dot-border-width, 1px);\n    width: 8px;\n    width: var(--fc-event-resizer-dot-total-width, 8px);\n    height: 8px;\n    height: var(--fc-event-resizer-dot-total-width, 8px);\n    border-style: solid;\n    border-color: inherit;\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff)\n\n    /* expand hit area */\n\n  }\n.fc-event-selected .fc-event-resizer:before {\n      content: '';\n      position: absolute;\n      top: -20px;\n      left: -20px;\n      right: -20px;\n      bottom: -20px;\n    }\n/* selecting (always TOUCH) */\n/* ---------------------------------------------------------------------------------------------------- */\n.fc-event-selected {\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2)\n\n  /* expand hit area (subclasses should expand) */\n\n}\n.fc-event-selected:before {\n    content: \"\";\n    position: absolute;\n    z-index: 3;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n  }\n.fc-event-selected {\n\n  /* dimmer effect */\n\n}\n.fc-event-selected:after {\n    content: \"\";\n    background: rgba(0, 0, 0, 0.25);\n    background: var(--fc-event-selected-overlay-color, rgba(0, 0, 0, 0.25));\n    position: absolute;\n    z-index: 1;\n\n    /* assume there's a border on all sides. overcome it. */\n    /* sometimes there's NOT a border, in which case the dimmer will go over */\n    /* an adjacent border, which looks fine. */\n    top: -1px;\n    left: -1px;\n    right: -1px;\n    bottom: -1px;\n  }\n/*\nA HORIZONTAL event\n*/\n.fc-h-event { /* allowed to be top-level */\n  display: block;\n  border: 1px solid #3788d8;\n  border: 1px solid var(--fc-event-border-color, #3788d8);\n  background-color: #3788d8;\n  background-color: var(--fc-event-bg-color, #3788d8)\n\n}\n.fc-h-event .fc-event-main {\n    color: #fff;\n    color: var(--fc-event-text-color, #fff);\n  }\n.fc-h-event .fc-event-main-frame {\n    display: flex; /* for make fc-event-title-container expand */\n  }\n.fc-h-event .fc-event-time {\n    max-width: 100%; /* clip overflow on this element */\n    overflow: hidden;\n  }\n.fc-h-event .fc-event-title-container { /* serves as a container for the sticky cushion */\n    flex-grow: 1;\n    flex-shrink: 1;\n    min-width: 0; /* important for allowing to shrink all the way */\n  }\n.fc-h-event .fc-event-title {\n    display: inline-block; /* need this to be sticky cross-browser */\n    vertical-align: top; /* for not messing up line-height */\n    left: 0;  /* for sticky */\n    right: 0; /* for sticky */\n    max-width: 100%; /* clip overflow on this element */\n    overflow: hidden;\n  }\n.fc-h-event.fc-event-selected:before {\n    /* expand hit area */\n    top: -10px;\n    bottom: -10px;\n  }\n/* adjust border and border-radius (if there is any) for non-start/end */\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n  border-left-width: 0;\n}\n.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),\n.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n  border-right-width: 0;\n}\n/* resizers */\n.fc-h-event:not(.fc-event-selected) .fc-event-resizer {\n  top: 0;\n  bottom: 0;\n  width: 8px;\n  width: var(--fc-event-resizer-thickness, 8px);\n}\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end {\n  cursor: w-resize;\n  left: -4px;\n  left: calc(var(--fc-event-resizer-thickness, 8px) / -2);\n}\n.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,\n.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start {\n  cursor: e-resize;\n  right: -4px;\n  right: calc(var(--fc-event-resizer-thickness, 8px) / -2);\n}\n/* resizers for TOUCH */\n.fc-h-event.fc-event-selected .fc-event-resizer {\n  top: 50%;\n  margin-top: -4px;\n  margin-top: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\n}\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end {\n  left: -4px;\n  left: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\n}\n.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,\n.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start {\n  right: -4px;\n  right: calc(var(--fc-event-resizer-dot-total-width, 8px) / -2);\n}\n.fc .fc-popover {\n    position: absolute;\n    z-index: 9999;\n    box-shadow: 0 2px 6px rgba(0,0,0,.15);\n  }\n.fc .fc-popover-header {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    padding: 3px 4px;\n  }\n.fc .fc-popover-title {\n    margin: 0 2px;\n  }\n.fc .fc-popover-close {\n    cursor: pointer;\n    opacity: 0.65;\n    font-size: 1.1em;\n  }\n.fc-theme-standard .fc-popover {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n    background: #fff;\n    background: var(--fc-page-bg-color, #fff);\n  }\n.fc-theme-standard .fc-popover-header {\n    background: rgba(208, 208, 208, 0.3);\n    background: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n";

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.css":
/*!*****************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.css ***!
  \*****************************************************/
/***/ (function(module) {

module.exports = "\n:root {\n  --fc-daygrid-event-dot-width: 8px;\n}\n/* help things clear margins of inner content */\n.fc-daygrid-day-frame,\n.fc-daygrid-day-events,\n.fc-daygrid-event-harness { /* for event top/bottom margins */\n}\n.fc-daygrid-day-frame:before, .fc-daygrid-day-events:before, .fc-daygrid-event-harness:before {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc-daygrid-day-frame:after, .fc-daygrid-day-events:after, .fc-daygrid-event-harness:after {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc .fc-daygrid-body { /* a <div> that wraps the table */\n    position: relative;\n    z-index: 1; /* container inner z-index's because <tr>s can't do it */\n  }\n.fc .fc-daygrid-day.fc-day-today {\n      background-color: rgba(255, 220, 40, 0.15);\n      background-color: var(--fc-today-bg-color, rgba(255, 220, 40, 0.15));\n    }\n.fc .fc-daygrid-day-frame {\n    position: relative;\n    min-height: 100%; /* seems to work better than `height` because sets height after rows/cells naturally do it */\n  }\n.fc {\n\n  /* cell top */\n\n}\n.fc .fc-daygrid-day-top {\n    display: flex;\n    flex-direction: row-reverse;\n  }\n.fc .fc-day-other .fc-daygrid-day-top {\n    opacity: 0.3;\n  }\n.fc {\n\n  /* day number (within cell top) */\n\n}\n.fc .fc-daygrid-day-number {\n    position: relative;\n    z-index: 4;\n    padding: 4px;\n  }\n.fc {\n\n  /* event container */\n\n}\n.fc .fc-daygrid-day-events {\n    margin-top: 1px; /* needs to be margin, not padding, so that available cell height can be computed */\n  }\n.fc {\n\n  /* positioning for balanced vs natural */\n\n}\n.fc .fc-daygrid-body-balanced .fc-daygrid-day-events {\n      position: absolute;\n      left: 0;\n      right: 0;\n    }\n.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events {\n      position: relative; /* for containing abs positioned event harnesses */\n      min-height: 2em; /* in addition to being a min-height during natural height, equalizes the heights a little bit */\n    }\n.fc .fc-daygrid-body-natural { /* can coexist with -unbalanced */\n  }\n.fc .fc-daygrid-body-natural .fc-daygrid-day-events {\n      margin-bottom: 1em;\n    }\n.fc {\n\n  /* event harness */\n\n}\n.fc .fc-daygrid-event-harness {\n    position: relative;\n  }\n.fc .fc-daygrid-event-harness-abs {\n    position: absolute;\n    top: 0; /* fallback coords for when cannot yet be computed */\n    left: 0; /* */\n    right: 0; /* */\n  }\n.fc .fc-daygrid-bg-harness {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n  }\n.fc {\n\n  /* bg content */\n\n}\n.fc .fc-daygrid-day-bg .fc-non-business { z-index: 1 }\n.fc .fc-daygrid-day-bg .fc-bg-event { z-index: 2 }\n.fc .fc-daygrid-day-bg .fc-highlight { z-index: 3 }\n.fc {\n\n  /* events */\n\n}\n.fc .fc-daygrid-event {\n    z-index: 6;\n    margin-top: 1px;\n  }\n.fc .fc-daygrid-event.fc-event-mirror {\n    z-index: 7;\n  }\n.fc {\n\n  /* cell bottom (within day-events) */\n\n}\n.fc .fc-daygrid-day-bottom {\n    font-size: .85em;\n    padding: 2px 3px 0\n  }\n.fc .fc-daygrid-day-bottom:before {\n  content: \"\";\n  clear: both;\n  display: table; }\n.fc .fc-daygrid-more-link {\n    position: relative;\n    z-index: 4;\n    cursor: pointer;\n  }\n.fc {\n\n  /* week number (within frame) */\n\n}\n.fc .fc-daygrid-week-number {\n    position: absolute;\n    z-index: 5;\n    top: 0;\n    padding: 2px;\n    min-width: 1.5em;\n    text-align: center;\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n    color: #808080;\n    color: var(--fc-neutral-text-color, #808080);\n  }\n.fc {\n\n  /* popover */\n\n}\n.fc .fc-more-popover .fc-popover-body {\n    min-width: 220px;\n    padding: 10px;\n  }\n.fc-direction-ltr .fc-daygrid-event.fc-event-start,\n.fc-direction-rtl .fc-daygrid-event.fc-event-end {\n  margin-left: 2px;\n}\n.fc-direction-ltr .fc-daygrid-event.fc-event-end,\n.fc-direction-rtl .fc-daygrid-event.fc-event-start {\n  margin-right: 2px;\n}\n.fc-direction-ltr .fc-daygrid-week-number {\n    left: 0;\n    border-radius: 0 0 3px 0;\n  }\n.fc-direction-rtl .fc-daygrid-week-number {\n    right: 0;\n    border-radius: 0 0 0 3px;\n  }\n.fc-liquid-hack .fc-daygrid-day-frame {\n    position: static; /* will cause inner absolute stuff to expand to <td> */\n  }\n.fc-daygrid-event { /* make root-level, because will be dragged-and-dropped outside of a component root */\n  position: relative; /* for z-indexes assigned later */\n  white-space: nowrap;\n  border-radius: 3px; /* dot event needs this to when selected */\n  font-size: .85em;\n  font-size: var(--fc-small-font-size, .85em);\n}\n/* --- the rectangle (\"block\") style of event --- */\n.fc-daygrid-block-event .fc-event-time {\n    font-weight: bold;\n  }\n.fc-daygrid-block-event .fc-event-time,\n  .fc-daygrid-block-event .fc-event-title {\n    padding: 1px;\n  }\n/* --- the dot style of event --- */\n.fc-daygrid-dot-event {\n  display: flex;\n  align-items: center;\n  padding: 2px 0\n\n}\n.fc-daygrid-dot-event .fc-event-title {\n    flex-grow: 1;\n    flex-shrink: 1;\n    min-width: 0; /* important for allowing to shrink all the way */\n    overflow: hidden;\n    font-weight: bold;\n  }\n.fc-daygrid-dot-event:hover,\n  .fc-daygrid-dot-event.fc-event-mirror {\n    background: rgba(0, 0, 0, 0.1);\n  }\n.fc-daygrid-dot-event.fc-event-selected:before {\n    /* expand hit area */\n    top: -10px;\n    bottom: -10px;\n  }\n.fc-daygrid-event-dot { /* the actual dot */\n  margin: 0 4px;\n  box-sizing: content-box;\n  width: 0;\n  height: 0;\n  border: 4px solid #3788d8;\n  border: calc(var(--fc-daygrid-event-dot-width, 8px) / 2) solid var(--fc-event-border-color, #3788d8);\n  border-radius: 4px;\n  border-radius: calc(var(--fc-daygrid-event-dot-width, 8px) / 2);\n}\n/* --- spacing between time and title --- */\n.fc-direction-ltr .fc-daygrid-event .fc-event-time {\n    margin-right: 3px;\n  }\n.fc-direction-rtl .fc-daygrid-event .fc-event-time {\n    margin-left: 3px;\n  }\n";

/***/ }),

/***/ "./node_modules/@fullcalendar/list/main.css":
/*!**************************************************!*\
  !*** ./node_modules/@fullcalendar/list/main.css ***!
  \**************************************************/
/***/ (function(module) {

module.exports = "\n:root {\n  --fc-list-event-dot-width: 10px;\n  --fc-list-event-hover-bg-color: #f5f5f5;\n}\n.fc-theme-standard .fc-list {\n    border: 1px solid #ddd;\n    border: 1px solid var(--fc-border-color, #ddd);\n  }\n.fc {\n\n  /* message when no events */\n\n}\n.fc .fc-list-empty {\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center; /* vertically aligns fc-list-empty-inner */\n  }\n.fc .fc-list-empty-cushion {\n    margin: 5em 0;\n  }\n.fc {\n\n  /* table within the scroller */\n  /* ---------------------------------------------------------------------------------------------------- */\n\n}\n.fc .fc-list-table {\n    width: 100%;\n    border-style: hidden; /* kill outer border on theme */\n  }\n.fc .fc-list-table tr > * {\n    border-left: 0;\n    border-right: 0;\n  }\n.fc .fc-list-sticky .fc-list-day > * { /* the cells */\n      position: sticky;\n      top: 0;\n      background: #fff;\n      background: var(--fc-page-bg-color, #fff); /* for when headers are styled to be transparent and sticky */\n    }\n.fc .fc-list-table th {\n    padding: 0; /* uses an inner-wrapper instead... */\n  }\n.fc .fc-list-table td,\n  .fc .fc-list-day-cushion {\n    padding: 8px 14px;\n  }\n.fc {\n\n\n  /* date heading rows */\n  /* ---------------------------------------------------------------------------------------------------- */\n\n}\n.fc .fc-list-day-cushion:after {\n  content: \"\";\n  clear: both;\n  display: table; /* clear floating */\n    }\n.fc-theme-standard .fc-list-day-cushion {\n    background-color: rgba(208, 208, 208, 0.3);\n    background-color: var(--fc-neutral-bg-color, rgba(208, 208, 208, 0.3));\n  }\n.fc-direction-ltr .fc-list-day-text,\n.fc-direction-rtl .fc-list-day-side-text {\n  float: left;\n}\n.fc-direction-ltr .fc-list-day-side-text,\n.fc-direction-rtl .fc-list-day-text {\n  float: right;\n}\n/* make the dot closer to the event title */\n.fc-direction-ltr .fc-list-table .fc-list-event-graphic { padding-right: 0 }\n.fc-direction-rtl .fc-list-table .fc-list-event-graphic { padding-left: 0 }\n.fc .fc-list-event.fc-event-forced-url {\n    cursor: pointer; /* whole row will seem clickable */\n  }\n.fc .fc-list-event:hover td {\n    background-color: #f5f5f5;\n    background-color: var(--fc-list-event-hover-bg-color, #f5f5f5);\n  }\n.fc {\n\n  /* shrink certain cols */\n\n}\n.fc .fc-list-event-graphic,\n  .fc .fc-list-event-time {\n    white-space: nowrap;\n    width: 1px;\n  }\n.fc .fc-list-event-dot {\n    display: inline-block;\n    box-sizing: content-box;\n    width: 0;\n    height: 0;\n    border: 5px solid #3788d8;\n    border: calc(var(--fc-list-event-dot-width, 10px) / 2) solid var(--fc-event-border-color, #3788d8);\n    border-radius: 5px;\n    border-radius: calc(var(--fc-list-event-dot-width, 10px) / 2);\n  }\n.fc {\n\n  /* reset <a> styling */\n\n}\n.fc .fc-list-event-title a {\n    color: inherit;\n    text-decoration: none;\n  }\n.fc {\n\n  /* underline link when hovering over any part of row */\n\n}\n.fc .fc-list-event.fc-event-forced-url:hover a {\n    text-decoration: underline;\n  }\n";

/***/ })

}]);