"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_Virtualizer_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/ScrollerController.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/ScrollerController.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollerController: function() { return /* binding */ ScrollerController; },\n/* harmony export */   ScrollerShim: function() { return /* binding */ ScrollerShim; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_createSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createSuper */ \"./node_modules/@babel/runtime/helpers/esm/createSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar ScrollerShim = /*#__PURE__*/function () {\n  function ScrollerShim(element) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this, ScrollerShim);\n    this._node = null;\n    this._element = null;\n    var node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(ScrollerShim, [{\n    key: \"element\",\n    get: function get() {\n      return this._element || document.scrollingElement || document.documentElement;\n    }\n  }, {\n    key: \"scrollTop\",\n    get: function get() {\n      return this.element.scrollTop || window.scrollY;\n    }\n  }, {\n    key: \"scrollLeft\",\n    get: function get() {\n      return this.element.scrollLeft || window.scrollX;\n    }\n  }, {\n    key: \"scrollHeight\",\n    get: function get() {\n      return this.element.scrollHeight;\n    }\n  }, {\n    key: \"scrollWidth\",\n    get: function get() {\n      return this.element.scrollWidth;\n    }\n  }, {\n    key: \"viewportHeight\",\n    get: function get() {\n      return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n    }\n  }, {\n    key: \"viewportWidth\",\n    get: function get() {\n      return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n    }\n  }, {\n    key: \"maxScrollTop\",\n    get: function get() {\n      return this.scrollHeight - this.viewportHeight;\n    }\n  }, {\n    key: \"maxScrollLeft\",\n    get: function get() {\n      return this.scrollWidth - this.viewportWidth;\n    }\n  }]);\n  return ScrollerShim;\n}();\nvar ScrollerController = /*#__PURE__*/function (_ScrollerShim) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(ScrollerController, _ScrollerShim);\n  var _super = (0,_babel_runtime_helpers_createSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ScrollerController);\n  function ScrollerController(client, element) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(this, ScrollerController);\n    _this = _super.call(this, element);\n    _this._originalScrollTo = null;\n    _this._originalScrollBy = null;\n    _this._originalScroll = null;\n    _this._clients = [];\n    _this._retarget = null;\n    _this._end = null;\n    _this.__destination = null;\n    _this.correctingScrollError = false;\n    var node = _this._node;\n    var instance = ScrollerController._instanceMap.get(node);\n    if (instance) {\n      instance._attach(client);\n      return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(_this, instance);\n    } else {\n      _this._checkForArrival = _this._checkForArrival.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n      _this._updateManagedScrollTo = _this._updateManagedScrollTo.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n      _this.scrollTo = _this.scrollTo.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n      _this.scrollBy = _this.scrollBy.bind((0,_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_this));\n      _this._originalScrollTo = node.scrollTo;\n      _this._originalScrollBy = node.scrollBy;\n      _this._originalScroll = node.scroll;\n      _this._attach(client);\n    }\n    return _this;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(ScrollerController, [{\n    key: \"_destination\",\n    get: function get() {\n      return this.__destination;\n    }\n  }, {\n    key: \"scrolling\",\n    get: function get() {\n      return this._destination !== null;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(p1, p2) {\n      var options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n        left: p1,\n        top: p2\n      } : p1;\n      this._scrollTo(options);\n    }\n  }, {\n    key: \"scrollBy\",\n    value: function scrollBy(p1, p2) {\n      var options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n        left: p1,\n        top: p2\n      } : p1;\n      if (options.top !== undefined) {\n        options.top += this.scrollTop;\n      }\n      if (options.left !== undefined) {\n        options.left += this.scrollLeft;\n      }\n      this._scrollTo(options);\n    }\n  }, {\n    key: \"_nativeScrollTo\",\n    value: function _nativeScrollTo(options) {\n      this._originalScrollTo.bind(this._element || window)(options);\n    }\n  }, {\n    key: \"_scrollTo\",\n    value: function _scrollTo(options) {\n      var retarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (this._end !== null) {\n        this._end();\n      }\n      if (options.behavior === 'smooth') {\n        this._setDestination(options);\n        this._retarget = retarget;\n        this._end = end;\n      } else {\n        this._resetScrollState();\n      }\n      this._nativeScrollTo(options);\n    }\n  }, {\n    key: \"_setDestination\",\n    value: function _setDestination(options) {\n      var top = options.top,\n        left = options.left;\n      top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n      left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n      if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n        return false;\n      }\n      this.__destination = {\n        top: top,\n        left: left,\n        behavior: 'smooth'\n      };\n      return true;\n    }\n  }, {\n    key: \"_resetScrollState\",\n    value: function _resetScrollState() {\n      this.__destination = null;\n      this._retarget = null;\n      this._end = null;\n    }\n  }, {\n    key: \"_updateManagedScrollTo\",\n    value: function _updateManagedScrollTo(coordinates) {\n      if (this._destination) {\n        if (this._setDestination(coordinates)) {\n          this._nativeScrollTo(this._destination);\n        }\n      }\n    }\n  }, {\n    key: \"managedScrollTo\",\n    value: function managedScrollTo(options, retarget, end) {\n      this._scrollTo(options, retarget, end);\n      return this._updateManagedScrollTo;\n    }\n  }, {\n    key: \"correctScrollError\",\n    value: function correctScrollError(coordinates) {\n      var _this2 = this;\n      this.correctingScrollError = true;\n      requestAnimationFrame(function () {\n        return requestAnimationFrame(function () {\n          return _this2.correctingScrollError = false;\n        });\n      });\n      // Correct the error\n      this._nativeScrollTo(coordinates);\n      // Then, if we were headed for a specific destination, we continue scrolling:\n      // First, we update our target destination, if applicable...\n      if (this._retarget) {\n        this._setDestination(this._retarget());\n      }\n      // Then we go ahead and resume scrolling\n      if (this._destination) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }, {\n    key: \"_checkForArrival\",\n    value: function _checkForArrival() {\n      if (this._destination !== null) {\n        var scrollTop = this.scrollTop,\n          scrollLeft = this.scrollLeft;\n        var _this$_destination = this._destination,\n          top = _this$_destination.top,\n          left = _this$_destination.left;\n        top = Math.min(top || 0, this.maxScrollTop);\n        left = Math.min(left || 0, this.maxScrollLeft);\n        var topDiff = Math.abs(top - scrollTop);\n        var leftDiff = Math.abs(left - scrollLeft);\n        // We check to see if we've arrived at our destination.\n        if (topDiff < 1 && leftDiff < 1) {\n          if (this._end) {\n            this._end();\n          }\n          this._resetScrollState();\n        }\n      }\n    }\n  }, {\n    key: \"detach\",\n    value: function detach(client) {\n      this._clients = this._clients.splice(this._clients.indexOf(client), 1);\n      if (this._clients.length === 0) {\n        this._node.scrollTo = this._originalScrollTo;\n        this._node.scrollBy = this._originalScrollBy;\n        this._node.scroll = this._originalScroll;\n        this._node.removeEventListener('scroll', this._checkForArrival);\n      }\n      return null;\n    }\n  }, {\n    key: \"_attach\",\n    value: function _attach(client) {\n      this._clients.push(client);\n      if (this._clients.length === 1) {\n        this._node.scrollTo = this.scrollTo;\n        this._node.scrollBy = this.scrollBy;\n        this._node.scroll = this.scrollTo;\n        this._node.addEventListener('scroll', this._checkForArrival);\n      }\n    }\n  }]);\n  return ScrollerController;\n}(ScrollerShim);\nScrollerController._instanceMap = new WeakMap();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1Njcm9sbGVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztBQVdBO0FBSUE7QUFBQTtBQUhBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQW9CQTtBQUFBO0FBQUE7QUFDQTtBQWxCQTtBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFEQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBck1BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1Njcm9sbGVyQ29udHJvbGxlci50cz9mNjQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQge1Njcm9sbFRvQ29vcmRpbmF0ZXN9IGZyb20gJy4vbGF5b3V0cy9zaGFyZWQvTGF5b3V0LmpzJztcblxudHlwZSByZXRhcmdldFNjcm9sbENhbGxiYWNrID0gKCkgPT4gU2Nyb2xsVG9Db29yZGluYXRlcztcbnR5cGUgZW5kU2Nyb2xsQ2FsbGJhY2sgPSAoKSA9PiB2b2lkO1xuXG5leHBvcnQgY2xhc3MgU2Nyb2xsZXJTaGltIHtcbiAgcHJvdGVjdGVkIF9ub2RlOiBFbGVtZW50IHwgV2luZG93IHwgbnVsbCA9IG51bGw7XG4gIHByb3RlY3RlZCBfZWxlbWVudDogRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQ/OiBFbGVtZW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IGVsZW1lbnQgPz8gd2luZG93O1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX2VsZW1lbnQgfHwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBzY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgfHwgd2luZG93LnNjcm9sbFk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbExlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0IHx8IHdpbmRvdy5zY3JvbGxYO1xuICB9XG5cbiAgcHVibGljIGdldCBzY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHZpZXdwb3J0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50XG4gICAgICA/IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICA6IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmlld3BvcnRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFxuICAgICAgPyB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICA6IHdpbmRvdy5pbm5lcldpZHRoO1xuICB9XG5cbiAgcHVibGljIGdldCBtYXhTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0IC0gdGhpcy52aWV3cG9ydEhlaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbWF4U2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxXaWR0aCAtIHRoaXMudmlld3BvcnRXaWR0aDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2Nyb2xsZXJDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsZXJTaGltIHtcbiAgcHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlTWFwOiBXZWFrTWFwPEVsZW1lbnQgfCBXaW5kb3csIFNjcm9sbGVyQ29udHJvbGxlcj4gPVxuICAgIG5ldyBXZWFrTWFwKCk7XG4gIHByaXZhdGUgX29yaWdpbmFsU2Nyb2xsVG86XG4gICAgfCB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG9cbiAgICB8IHR5cGVvZiB3aW5kb3cuc2Nyb2xsVG9cbiAgICB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9vcmlnaW5hbFNjcm9sbEJ5OlxuICAgIHwgdHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgfCB0eXBlb2Ygd2luZG93LnNjcm9sbEJ5XG4gICAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfb3JpZ2luYWxTY3JvbGw6XG4gICAgfCB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsXG4gICAgfCB0eXBlb2Ygd2luZG93LnNjcm9sbFxuICAgIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2NsaWVudHM6IEFycmF5PHVua25vd24+ID0gW107XG4gIHByaXZhdGUgX3JldGFyZ2V0OiByZXRhcmdldFNjcm9sbENhbGxiYWNrIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2VuZDogZW5kU2Nyb2xsQ2FsbGJhY2sgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfX2Rlc3RpbmF0aW9uOiBTY3JvbGxUb09wdGlvbnMgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IHVua25vd24sIGVsZW1lbnQ/OiBFbGVtZW50KSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGUhO1xuICAgIGNvbnN0IGluc3RhbmNlID0gU2Nyb2xsZXJDb250cm9sbGVyLl9pbnN0YW5jZU1hcC5nZXQobm9kZSEpO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuX2F0dGFjaChjbGllbnQpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jaGVja0ZvckFycml2YWwgPSB0aGlzLl9jaGVja0ZvckFycml2YWwuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZU1hbmFnZWRTY3JvbGxUbyA9IHRoaXMuX3VwZGF0ZU1hbmFnZWRTY3JvbGxUby5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG8uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuc2Nyb2xsQnkgPSB0aGlzLnNjcm9sbEJ5LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbFRvID0gbm9kZS5zY3JvbGxUbztcbiAgICAgIHRoaXMuX29yaWdpbmFsU2Nyb2xsQnkgPSBub2RlLnNjcm9sbEJ5O1xuICAgICAgdGhpcy5fb3JpZ2luYWxTY3JvbGwgPSBub2RlLnNjcm9sbDtcbiAgICAgIHRoaXMuX2F0dGFjaChjbGllbnQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBjb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPSBmYWxzZTtcblxuICBwcml2YXRlIGdldCBfZGVzdGluYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kZXN0aW5hdGlvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXN0aW5hdGlvbiAhPT0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBzY3JvbGxUbyhvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMpOiB2b2lkO1xuICBwdWJsaWMgc2Nyb2xsVG8oeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkO1xuICBwdWJsaWMgc2Nyb2xsVG8ocDE6IFNjcm9sbFRvT3B0aW9ucyB8IG51bWJlciwgcDI/OiBudW1iZXIpOiB2b2lkO1xuICBwdWJsaWMgc2Nyb2xsVG8ocDE6IFNjcm9sbFRvT3B0aW9ucyB8IG51bWJlciwgcDI/OiBudW1iZXIpIHtcbiAgICBjb25zdCBvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMgPVxuICAgICAgdHlwZW9mIHAxID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcDIgPT09ICdudW1iZXInXG4gICAgICAgID8ge2xlZnQ6IHAxLCB0b3A6IHAyfVxuICAgICAgICA6IChwMSBhcyBTY3JvbGxUb09wdGlvbnMpO1xuICAgIHRoaXMuX3Njcm9sbFRvKG9wdGlvbnMpO1xuICB9XG5cbiAgcHVibGljIHNjcm9sbEJ5KG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyk6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxCeSh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxCeShwMTogU2Nyb2xsVG9PcHRpb25zIHwgbnVtYmVyLCBwMj86IG51bWJlcik6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxCeShwMTogU2Nyb2xsVG9PcHRpb25zIHwgbnVtYmVyLCBwMj86IG51bWJlcikge1xuICAgIGNvbnN0IG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyA9XG4gICAgICB0eXBlb2YgcDEgPT09ICdudW1iZXInICYmIHR5cGVvZiBwMiA9PT0gJ251bWJlcidcbiAgICAgICAgPyB7bGVmdDogcDEsIHRvcDogcDJ9XG4gICAgICAgIDogKHAxIGFzIFNjcm9sbFRvT3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMudG9wICs9IHRoaXMuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubGVmdCArPSB0aGlzLnNjcm9sbExlZnQ7XG4gICAgfVxuICAgIHRoaXMuX3Njcm9sbFRvKG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfbmF0aXZlU2Nyb2xsVG8ob3B0aW9uczogU2Nyb2xsVG9PcHRpb25zKSB7XG4gICAgdGhpcy5fb3JpZ2luYWxTY3JvbGxUbyEuYmluZCh0aGlzLl9lbGVtZW50IHx8IHdpbmRvdykob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIF9zY3JvbGxUbyhcbiAgICBvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMsXG4gICAgcmV0YXJnZXQ6IHJldGFyZ2V0U2Nyb2xsQ2FsbGJhY2sgfCBudWxsID0gbnVsbCxcbiAgICBlbmQ6IGVuZFNjcm9sbENhbGxiYWNrIHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgaWYgKHRoaXMuX2VuZCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW5kKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmJlaGF2aW9yID09PSAnc21vb3RoJykge1xuICAgICAgdGhpcy5fc2V0RGVzdGluYXRpb24ob3B0aW9ucyk7XG4gICAgICB0aGlzLl9yZXRhcmdldCA9IHJldGFyZ2V0O1xuICAgICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNldFNjcm9sbFN0YXRlKCk7XG4gICAgfVxuICAgIHRoaXMuX25hdGl2ZVNjcm9sbFRvKG9wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2V0RGVzdGluYXRpb24ob3B0aW9uczogU2Nyb2xsVG9PcHRpb25zKSB7XG4gICAgbGV0IHt0b3AsIGxlZnR9ID0gb3B0aW9ucztcbiAgICB0b3AgPVxuICAgICAgdG9wID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbih0b3AsIHRoaXMubWF4U2Nyb2xsVG9wKSk7XG4gICAgbGVmdCA9XG4gICAgICBsZWZ0ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBNYXRoLm1heCgwLCBNYXRoLm1pbihsZWZ0LCB0aGlzLm1heFNjcm9sbExlZnQpKTtcbiAgICBpZiAoXG4gICAgICB0aGlzLl9kZXN0aW5hdGlvbiAhPT0gbnVsbCAmJlxuICAgICAgbGVmdCA9PT0gdGhpcy5fZGVzdGluYXRpb24ubGVmdCAmJlxuICAgICAgdG9wID09PSB0aGlzLl9kZXN0aW5hdGlvbi50b3BcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fX2Rlc3RpbmF0aW9uID0ge3RvcCwgbGVmdCwgYmVoYXZpb3I6ICdzbW9vdGgnfTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX3Jlc2V0U2Nyb2xsU3RhdGUoKSB7XG4gICAgdGhpcy5fX2Rlc3RpbmF0aW9uID0gbnVsbDtcbiAgICB0aGlzLl9yZXRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fZW5kID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgX3VwZGF0ZU1hbmFnZWRTY3JvbGxUbyhjb29yZGluYXRlczogU2Nyb2xsVG9Db29yZGluYXRlcykge1xuICAgIGlmICh0aGlzLl9kZXN0aW5hdGlvbikge1xuICAgICAgaWYgKHRoaXMuX3NldERlc3RpbmF0aW9uKGNvb3JkaW5hdGVzKSkge1xuICAgICAgICB0aGlzLl9uYXRpdmVTY3JvbGxUbyh0aGlzLl9kZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG1hbmFnZWRTY3JvbGxUbyhcbiAgICBvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMsXG4gICAgcmV0YXJnZXQ6IHJldGFyZ2V0U2Nyb2xsQ2FsbGJhY2ssXG4gICAgZW5kOiBlbmRTY3JvbGxDYWxsYmFja1xuICApIHtcbiAgICB0aGlzLl9zY3JvbGxUbyhvcHRpb25zLCByZXRhcmdldCwgZW5kKTtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlTWFuYWdlZFNjcm9sbFRvO1xuICB9XG5cbiAgcHVibGljIGNvcnJlY3RTY3JvbGxFcnJvcihjb29yZGluYXRlczogU2Nyb2xsVG9Db29yZGluYXRlcykge1xuICAgIHRoaXMuY29ycmVjdGluZ1Njcm9sbEVycm9yID0gdHJ1ZTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiAodGhpcy5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPSBmYWxzZSkpXG4gICAgKTtcbiAgICAvLyBDb3JyZWN0IHRoZSBlcnJvclxuICAgIHRoaXMuX25hdGl2ZVNjcm9sbFRvKGNvb3JkaW5hdGVzKTtcbiAgICAvLyBUaGVuLCBpZiB3ZSB3ZXJlIGhlYWRlZCBmb3IgYSBzcGVjaWZpYyBkZXN0aW5hdGlvbiwgd2UgY29udGludWUgc2Nyb2xsaW5nOlxuICAgIC8vIEZpcnN0LCB3ZSB1cGRhdGUgb3VyIHRhcmdldCBkZXN0aW5hdGlvbiwgaWYgYXBwbGljYWJsZS4uLlxuICAgIGlmICh0aGlzLl9yZXRhcmdldCkge1xuICAgICAgdGhpcy5fc2V0RGVzdGluYXRpb24odGhpcy5fcmV0YXJnZXQoKSk7XG4gICAgfVxuICAgIC8vIFRoZW4gd2UgZ28gYWhlYWQgYW5kIHJlc3VtZSBzY3JvbGxpbmdcbiAgICBpZiAodGhpcy5fZGVzdGluYXRpb24pIHtcbiAgICAgIHRoaXMuX25hdGl2ZVNjcm9sbFRvKHRoaXMuX2Rlc3RpbmF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jaGVja0ZvckFycml2YWwoKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7c2Nyb2xsVG9wLCBzY3JvbGxMZWZ0fSA9IHRoaXM7XG4gICAgICBsZXQge3RvcCwgbGVmdH0gPSB0aGlzLl9kZXN0aW5hdGlvbjtcbiAgICAgIHRvcCA9IE1hdGgubWluKHRvcCB8fCAwLCB0aGlzLm1heFNjcm9sbFRvcCk7XG4gICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCB8fCAwLCB0aGlzLm1heFNjcm9sbExlZnQpO1xuICAgICAgY29uc3QgdG9wRGlmZiA9IE1hdGguYWJzKHRvcCAtIHNjcm9sbFRvcCk7XG4gICAgICBjb25zdCBsZWZ0RGlmZiA9IE1hdGguYWJzKGxlZnQgLSBzY3JvbGxMZWZ0KTtcbiAgICAgIC8vIFdlIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhcnJpdmVkIGF0IG91ciBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICh0b3BEaWZmIDwgMSAmJiBsZWZ0RGlmZiA8IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuZCkge1xuICAgICAgICAgIHRoaXMuX2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsU3RhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGV0YWNoKGNsaWVudDogdW5rbm93bikge1xuICAgIHRoaXMuX2NsaWVudHMgPSB0aGlzLl9jbGllbnRzLnNwbGljZSh0aGlzLl9jbGllbnRzLmluZGV4T2YoY2xpZW50KSwgMSk7XG4gICAgaWYgKHRoaXMuX2NsaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9ub2RlIS5zY3JvbGxUbyA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsVG8hO1xuICAgICAgdGhpcy5fbm9kZSEuc2Nyb2xsQnkgPSB0aGlzLl9vcmlnaW5hbFNjcm9sbEJ5ITtcbiAgICAgIHRoaXMuX25vZGUhLnNjcm9sbCA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsITtcbiAgICAgIHRoaXMuX25vZGUhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2NoZWNrRm9yQXJyaXZhbCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBfYXR0YWNoKGNsaWVudDogdW5rbm93bikge1xuICAgIHRoaXMuX2NsaWVudHMucHVzaChjbGllbnQpO1xuICAgIGlmICh0aGlzLl9jbGllbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5fbm9kZSEuc2Nyb2xsVG8gPSB0aGlzLnNjcm9sbFRvO1xuICAgICAgdGhpcy5fbm9kZSEuc2Nyb2xsQnkgPSB0aGlzLnNjcm9sbEJ5O1xuICAgICAgdGhpcy5fbm9kZSEuc2Nyb2xsID0gdGhpcy5zY3JvbGxUbztcbiAgICAgIHRoaXMuX25vZGUhLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2NoZWNrRm9yQXJyaXZhbCk7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/ScrollerController.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/Virtualizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/Virtualizer.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: function() { return /* binding */ Virtualizer; },\n/* harmony export */   provideResizeObserver: function() { return /* binding */ provideResizeObserver; },\n/* harmony export */   virtualizerRef: function() { return /* binding */ virtualizerRef; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createForOfIteratorHelper */ \"./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\");\n/* harmony import */ var _babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/regeneratorRuntime */ \"./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@lit-labs/virtualizer/events.js\");\n/* harmony import */ var _ScrollerController_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ScrollerController.js */ \"./node_modules/@lit-labs/virtualizer/ScrollerController.js\");\n\n\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nvar _ResizeObserver = window === null || window === void 0 ? void 0 : window.ResizeObserver;\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nfunction provideResizeObserver(Ctor) {\n  _ResizeObserver = Ctor;\n}\nvar virtualizerRef = Symbol('virtualizerRef');\nvar SIZER_ATTRIBUTE = 'virtualizer-sizer';\nvar DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nvar Virtualizer = /*#__PURE__*/function () {\n  function Virtualizer(config) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(this, Virtualizer);\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    /**\n     * Layout initialization is async because we dynamically load\n     * the default layout if none is specified. This state is to track\n     * whether init is complete.\n     */\n    this._layoutInitialized = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Virtualizer, [{\n    key: \"items\",\n    set: function set(items) {\n      if (Array.isArray(items) && items !== this._items) {\n        this._itemsChanged = true;\n        this._items = items;\n        this._schedule(this._updateLayout);\n      }\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(config) {\n      this._isScroller = !!config.scroller;\n      this._initHostElement(config);\n      // If no layout is specified, we make an empty\n      // layout config, which will result in the default\n      // layout with default parameters\n      var layoutConfig = config.layout || {};\n      // Save the promise returned by `_initLayout` as a state\n      // variable we can check before updating layout config\n      this._layoutInitialized = this._initLayout(layoutConfig);\n    }\n  }, {\n    key: \"_initObservers\",\n    value: function _initObservers() {\n      var _this = this;\n      this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n      this._hostElementRO = new _ResizeObserver(function () {\n        return _this._hostElementSizeChanged();\n      });\n      this._childrenRO = new _ResizeObserver(this._childrenSizeChanged.bind(this));\n    }\n  }, {\n    key: \"_initHostElement\",\n    value: function _initHostElement(config) {\n      var hostElement = this._hostElement = config.hostElement;\n      this._applyVirtualizerStyles();\n      hostElement[virtualizerRef] = this;\n    }\n  }, {\n    key: \"connected\",\n    value: function connected() {\n      this._initObservers();\n      var includeSelf = this._isScroller;\n      this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n      this._scrollerController = new _ScrollerController_js__WEBPACK_IMPORTED_MODULE_6__.ScrollerController(this, this._clippingAncestors[0]);\n      this._schedule(this._updateLayout);\n      this._observeAndListen();\n    }\n  }, {\n    key: \"_observeAndListen\",\n    value: function _observeAndListen() {\n      var _this2 = this;\n      this._mutationObserver.observe(this._hostElement, {\n        childList: true\n      });\n      this._hostElementRO.observe(this._hostElement);\n      this._scrollEventListeners.push(window);\n      window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._clippingAncestors.forEach(function (ancestor) {\n        ancestor.addEventListener('scroll', _this2, _this2._scrollEventListenerOptions);\n        _this2._scrollEventListeners.push(ancestor);\n        _this2._hostElementRO.observe(ancestor);\n      });\n      this._hostElementRO.observe(this._scrollerController.element);\n      this._children.forEach(function (child) {\n        return _this2._childrenRO.observe(child);\n      });\n      this._scrollEventListeners.forEach(function (target) {\n        return target.addEventListener('scroll', _this2, _this2._scrollEventListenerOptions);\n      });\n    }\n  }, {\n    key: \"disconnected\",\n    value: function disconnected() {\n      var _this3 = this;\n      this._scrollEventListeners.forEach(function (target) {\n        return target.removeEventListener('scroll', _this3, _this3._scrollEventListenerOptions);\n      });\n      this._scrollEventListeners = [];\n      this._clippingAncestors = [];\n      this._scrollerController = this._scrollerController.detach(this) || null;\n      this._mutationObserver.disconnect();\n      this._hostElementRO.disconnect();\n      this._childrenRO.disconnect();\n      this._rejectLayoutCompletePromise('disconnected');\n    }\n  }, {\n    key: \"_applyVirtualizerStyles\",\n    value: function _applyVirtualizerStyles() {\n      var hostElement = this._hostElement;\n      // Would rather set these CSS properties on the host using Shadow Root\n      // style scoping (and falling back to a global stylesheet where native\n      // Shadow DOM is not available), but this Mobile Safari bug is preventing\n      // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n      var style = hostElement.style;\n      style.display = style.display || 'block';\n      style.position = style.position || 'relative';\n      style.contain = style.contain || 'size layout';\n      if (this._isScroller) {\n        style.overflow = style.overflow || 'auto';\n        style.minHeight = style.minHeight || '150px';\n      }\n    }\n  }, {\n    key: \"_getSizer\",\n    value: function _getSizer() {\n      var hostElement = this._hostElement;\n      if (!this._sizer) {\n        // Use a preexisting sizer element if provided (for better integration\n        // with vDOM renderers)\n        var sizer = hostElement.querySelector(\"[\".concat(SIZER_ATTRIBUTE, \"]\"));\n        if (!sizer) {\n          sizer = document.createElement('div');\n          sizer.setAttribute(SIZER_ATTRIBUTE, '');\n          hostElement.appendChild(sizer);\n        }\n        // When the scrollHeight is large, the height of this element might be\n        // ignored. Setting content and font-size ensures the element has a size.\n        Object.assign(sizer.style, {\n          position: 'absolute',\n          margin: '-2px 0 0 0',\n          padding: 0,\n          visibility: 'hidden',\n          fontSize: '2px'\n        });\n        sizer.textContent = '&nbsp;';\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        this._sizer = sizer;\n      }\n      return this._sizer;\n    }\n  }, {\n    key: \"updateLayoutConfig\",\n    value: function () {\n      var _updateLayoutConfig = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/(0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().mark(function _callee(layoutConfig) {\n        var Ctor, config;\n        return (0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this._layoutInitialized;\n            case 2:\n              Ctor = layoutConfig.type ||\n              // The new config is compatible with the current layout,\n              // so we update the config and return true to indicate\n              // a successful update\n              DefaultLayoutConstructor;\n              if (!(typeof Ctor === 'function' && this._layout instanceof Ctor)) {\n                _context.next = 8;\n                break;\n              }\n              config = Object.assign({}, layoutConfig);\n              delete config.type;\n              this._layout.config = config;\n              // The new config requires a different layout altogether, but\n              // to limit implementation complexity we don't support dynamically\n              // changing the layout of an existing virtualizer instance.\n              // Returning false here lets the caller know that they should\n              // instead make a new virtualizer instance with the desired layout.\n              return _context.abrupt(\"return\", true);\n            case 8:\n              return _context.abrupt(\"return\", false);\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function updateLayoutConfig(_x) {\n        return _updateLayoutConfig.apply(this, arguments);\n      }\n      return updateLayoutConfig;\n    }()\n  }, {\n    key: \"_initLayout\",\n    value: function () {\n      var _initLayout2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/(0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().mark(function _callee2(layoutConfig) {\n        var _this4 = this;\n        var config, Ctor, copy;\n        return (0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              if (typeof layoutConfig.type === 'function') {\n                // If we have a full LayoutSpecifier, the `type` property\n                // gives us our constructor...\n                Ctor = layoutConfig.type;\n                // ...while the rest of the specifier is our layout config\n                copy = Object.assign({}, layoutConfig);\n                delete copy.type;\n                config = copy;\n              } else {\n                // If we don't have a full LayoutSpecifier, we just\n                // have a config for the default layout\n                config = layoutConfig;\n              }\n              if (!(Ctor === undefined)) {\n                _context2.next = 5;\n                break;\n              }\n              _context2.next = 4;\n              return Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js\"), __webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_flow_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./layouts/flow.js */ \"./node_modules/@lit-labs/virtualizer/layouts/flow.js\"));\n            case 4:\n              DefaultLayoutConstructor = Ctor = _context2.sent.FlowLayout;\n            case 5:\n              this._layout = new Ctor(function (message) {\n                return _this4._handleLayoutMessage(message);\n              }, config);\n              if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n                if (typeof this._layout.measureChildren === 'function') {\n                  this._measureChildOverride = this._layout.measureChildren;\n                }\n                this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n              }\n              if (this._layout.listenForChildLoadEvents) {\n                this._hostElement.addEventListener('load', this._loadListener, true);\n              }\n              this._schedule(this._updateLayout);\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _initLayout(_x2) {\n        return _initLayout2.apply(this, arguments);\n      }\n      return _initLayout;\n    }() // TODO (graynorton): Rework benchmarking so that it has no API and\n    // instead is always on except in production builds\n  }, {\n    key: \"startBenchmarking\",\n    value: function startBenchmarking() {\n      if (this._benchmarkStart === null) {\n        this._benchmarkStart = window.performance.now();\n      }\n    }\n  }, {\n    key: \"stopBenchmarking\",\n    value: function stopBenchmarking() {\n      var _this5 = this;\n      if (this._benchmarkStart !== null) {\n        var now = window.performance.now();\n        var timeElapsed = now - this._benchmarkStart;\n        var entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n        var virtualizationTime = entries.filter(function (e) {\n          return e.startTime >= _this5._benchmarkStart && e.startTime < now;\n        }).reduce(function (t, m) {\n          return t + m.duration;\n        }, 0);\n        this._benchmarkStart = null;\n        return {\n          timeElapsed: timeElapsed,\n          virtualizationTime: virtualizationTime\n        };\n      }\n      return null;\n    }\n  }, {\n    key: \"_measureChildren\",\n    value: function _measureChildren() {\n      var mm = {};\n      var children = this._children;\n      var fn = this._measureChildOverride || this._measureChild;\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        var idx = this._first + i;\n        if (this._itemsChanged || this._toBeMeasured.has(child)) {\n          mm[idx] = fn.call(this, child, this._items[idx]);\n        }\n      }\n      this._childMeasurements = mm;\n      this._schedule(this._updateLayout);\n      this._toBeMeasured.clear();\n    }\n    /**\n     * Returns the width, height, and margins of the given child.\n     */\n  }, {\n    key: \"_measureChild\",\n    value: function _measureChild(element) {\n      // offsetWidth doesn't take transforms in consideration, so we use\n      // getBoundingClientRect which does.\n      var _element$getBoundingC = element.getBoundingClientRect(),\n        width = _element$getBoundingC.width,\n        height = _element$getBoundingC.height;\n      return Object.assign({\n        width: width,\n        height: height\n      }, getMargins(element));\n    }\n  }, {\n    key: \"_schedule\",\n    value: function () {\n      var _schedule2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/(0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().mark(function _callee3(method) {\n        return (0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (this._scheduled.has(method)) {\n                _context3.next = 6;\n                break;\n              }\n              this._scheduled.add(method);\n              _context3.next = 4;\n              return Promise.resolve();\n            case 4:\n              this._scheduled.delete(method);\n              method.call(this);\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function _schedule(_x3) {\n        return _schedule2.apply(this, arguments);\n      }\n      return _schedule;\n    }()\n  }, {\n    key: \"_updateDOM\",\n    value: function () {\n      var _updateDOM2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/(0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().mark(function _callee4(state) {\n        var _rangeChanged, _itemsChanged;\n        return (0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              this._scrollSize = state.scrollSize;\n              this._adjustRange(state.range);\n              this._childrenPos = state.childPositions;\n              this._scrollError = state.scrollError || null;\n              _rangeChanged = this._rangeChanged, _itemsChanged = this._itemsChanged;\n              if (this._visibilityChanged) {\n                this._notifyVisibility();\n                this._visibilityChanged = false;\n              }\n              if (_rangeChanged || _itemsChanged) {\n                this._notifyRange();\n                this._rangeChanged = false;\n              } else {\n                this._finishDOMUpdate();\n              }\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function _updateDOM(_x4) {\n        return _updateDOM2.apply(this, arguments);\n      }\n      return _updateDOM;\n    }()\n  }, {\n    key: \"_finishDOMUpdate\",\n    value: function _finishDOMUpdate() {\n      var _this6 = this;\n      this._children.forEach(function (child) {\n        return _this6._childrenRO.observe(child);\n      });\n      this._checkScrollIntoViewTarget(this._childrenPos);\n      this._positionChildren(this._childrenPos);\n      this._sizeHostElement(this._scrollSize);\n      this._correctScrollError();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }, {\n    key: \"_updateLayout\",\n    value: function _updateLayout() {\n      if (this._layout) {\n        this._layout.items = this._items;\n        this._updateView();\n        if (this._childMeasurements !== null) {\n          // If the layout has been changed, we may have measurements but no callback\n          if (this._measureCallback) {\n            this._measureCallback(this._childMeasurements);\n          }\n          this._childMeasurements = null;\n        }\n        this._layout.reflowIfNeeded();\n        if (this._benchmarkStart && 'mark' in window.performance) {\n          window.performance.mark('uv-end');\n        }\n      }\n    }\n  }, {\n    key: \"_handleScrollEvent\",\n    value: function _handleScrollEvent() {\n      var _a;\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        try {\n          window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n        } catch (e) {\n          console.warn('Error measuring performance data: ', e);\n        }\n        window.performance.mark('uv-start');\n      }\n      if (this._scrollerController.correctingScrollError === false) {\n        // This is a user-initiated scroll, so we unpin the layout\n        (_a = this._layout) === null || _a === void 0 ? void 0 : _a.unpin();\n      }\n      this._schedule(this._updateLayout);\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      switch (event.type) {\n        case 'scroll':\n          if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n            this._handleScrollEvent();\n          }\n          break;\n        default:\n          console.warn('event not handled', event);\n      }\n    }\n  }, {\n    key: \"_handleLayoutMessage\",\n    value: function _handleLayoutMessage(message) {\n      if (message.type === 'stateChanged') {\n        this._updateDOM(message);\n      } else if (message.type === 'visibilityChanged') {\n        this._firstVisible = message.firstVisible;\n        this._lastVisible = message.lastVisible;\n        this._notifyVisibility();\n      } else if (message.type === 'unpinned') {\n        this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_5__.UnpinnedEvent());\n      }\n    }\n  }, {\n    key: \"_children\",\n    get: function get() {\n      var arr = [];\n      var next = this._hostElement.firstElementChild;\n      while (next) {\n        if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n          arr.push(next);\n        }\n        next = next.nextElementSibling;\n      }\n      return arr;\n    }\n  }, {\n    key: \"_updateView\",\n    value: function _updateView() {\n      var _a;\n      var hostElement = this._hostElement;\n      var scrollingElement = (_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.element;\n      var layout = this._layout;\n      if (hostElement && scrollingElement && layout) {\n        var top, left, bottom, right;\n        var hostElementBounds = hostElement.getBoundingClientRect();\n        top = 0;\n        left = 0;\n        bottom = window.innerHeight;\n        right = window.innerWidth;\n        var ancestorBounds = this._clippingAncestors.map(function (ancestor) {\n          return ancestor.getBoundingClientRect();\n        });\n        ancestorBounds.unshift(hostElementBounds);\n        var _iterator = (0,_babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(ancestorBounds),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var bounds = _step.value;\n            top = Math.max(top, bounds.top);\n            left = Math.max(left, bounds.left);\n            bottom = Math.min(bottom, bounds.bottom);\n            right = Math.min(right, bounds.right);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        var scrollingElementBounds = scrollingElement.getBoundingClientRect();\n        var offsetWithinScroller = {\n          left: hostElementBounds.left - scrollingElementBounds.left,\n          top: hostElementBounds.top - scrollingElementBounds.top\n        };\n        var totalScrollSize = {\n          width: scrollingElement.scrollWidth,\n          height: scrollingElement.scrollHeight\n        };\n        var scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n        var scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n        var height = Math.max(1, bottom - top);\n        var width = Math.max(1, right - left);\n        layout.viewportSize = {\n          width: width,\n          height: height\n        };\n        layout.viewportScroll = {\n          top: scrollTop,\n          left: scrollLeft\n        };\n        layout.totalScrollSize = totalScrollSize;\n        layout.offsetWithinScroller = offsetWithinScroller;\n      }\n    }\n    /**\n     * Styles the host element so that its size reflects the\n     * total size of all items.\n     */\n  }, {\n    key: \"_sizeHostElement\",\n    value: function _sizeHostElement(size) {\n      // Some browsers seem to crap out if the host element gets larger than\n      // a certain size, so we clamp it here (this value based on ad hoc\n      // testing in Chrome / Safari / Firefox Mac)\n      var max = 8200000;\n      var h = size && size.width !== null ? Math.min(max, size.width) : 0;\n      var v = size && size.height !== null ? Math.min(max, size.height) : 0;\n      if (this._isScroller) {\n        this._getSizer().style.transform = \"translate(\".concat(h, \"px, \").concat(v, \"px)\");\n      } else {\n        var style = this._hostElement.style;\n        style.minWidth = h ? \"\".concat(h, \"px\") : '100%';\n        style.minHeight = v ? \"\".concat(v, \"px\") : '100%';\n      }\n    }\n    /**\n     * Sets the top and left transform style of the children from the values in\n     * pos.\n     */\n  }, {\n    key: \"_positionChildren\",\n    value: function _positionChildren(pos) {\n      var _this7 = this;\n      if (pos) {\n        pos.forEach(function (_ref, index) {\n          var top = _ref.top,\n            left = _ref.left,\n            width = _ref.width,\n            height = _ref.height,\n            xOffset = _ref.xOffset,\n            yOffset = _ref.yOffset;\n          var child = _this7._children[index - _this7._first];\n          if (child) {\n            child.style.position = 'absolute';\n            child.style.boxSizing = 'border-box';\n            child.style.transform = \"translate(\".concat(left, \"px, \").concat(top, \"px)\");\n            if (width !== undefined) {\n              child.style.width = width + 'px';\n            }\n            if (height !== undefined) {\n              child.style.height = height + 'px';\n            }\n            child.style.left = xOffset === undefined ? null : xOffset + 'px';\n            child.style.top = yOffset === undefined ? null : yOffset + 'px';\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_adjustRange\",\n    value: function () {\n      var _adjustRange2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__[\"default\"])( /*#__PURE__*/(0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().mark(function _callee5(range) {\n        var _first, _last, _firstVisible, _lastVisible;\n        return (0,_babel_runtime_helpers_regeneratorRuntime__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _first = this._first, _last = this._last, _firstVisible = this._firstVisible, _lastVisible = this._lastVisible;\n              this._first = range.first;\n              this._last = range.last;\n              this._firstVisible = range.firstVisible;\n              this._lastVisible = range.lastVisible;\n              this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n              this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _adjustRange(_x5) {\n        return _adjustRange2.apply(this, arguments);\n      }\n      return _adjustRange;\n    }()\n  }, {\n    key: \"_correctScrollError\",\n    value: function _correctScrollError() {\n      if (this._scrollError) {\n        var _this$_scrollerContro = this._scrollerController,\n          scrollTop = _this$_scrollerContro.scrollTop,\n          scrollLeft = _this$_scrollerContro.scrollLeft;\n        var _this$_scrollError = this._scrollError,\n          top = _this$_scrollError.top,\n          left = _this$_scrollError.left;\n        this._scrollError = null;\n        this._scrollerController.correctScrollError({\n          top: scrollTop - top,\n          left: scrollLeft - left\n        });\n      }\n    }\n  }, {\n    key: \"element\",\n    value: function element(index) {\n      var _this8 = this;\n      var _a;\n      if (index === Infinity) {\n        index = this._items.length - 1;\n      }\n      return ((_a = this._items) === null || _a === void 0 ? void 0 : _a[index]) === undefined ? undefined : {\n        scrollIntoView: function scrollIntoView() {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          return _this8._scrollElementIntoView(Object.assign(Object.assign({}, options), {}, {\n            index: index\n          }));\n        }\n      };\n    }\n  }, {\n    key: \"_scrollElementIntoView\",\n    value: function _scrollElementIntoView(options) {\n      var _this9 = this;\n      if (options.index >= this._first && options.index <= this._last) {\n        this._children[options.index - this._first].scrollIntoView(options);\n      } else {\n        options.index = Math.min(options.index, this._items.length - 1);\n        if (options.behavior === 'smooth') {\n          var coordinates = this._layout.getScrollIntoViewCoordinates(options);\n          var behavior = options.behavior;\n          this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n            behavior: behavior\n          }), function () {\n            return _this9._layout.getScrollIntoViewCoordinates(options);\n          }, function () {\n            return _this9._scrollIntoViewTarget = null;\n          });\n          this._scrollIntoViewTarget = options;\n        } else {\n          this._layout.pin = options;\n        }\n      }\n    }\n    /**\n     * If we are smoothly scrolling to an element and the target element\n     * is in the DOM, we update our target coordinates as needed\n     */\n  }, {\n    key: \"_checkScrollIntoViewTarget\",\n    value: function _checkScrollIntoViewTarget(pos) {\n      var _ref2 = this._scrollIntoViewTarget || {},\n        index = _ref2.index;\n      if (index && (pos === null || pos === void 0 ? void 0 : pos.has(index))) {\n        this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n      }\n    }\n    /**\n     * Emits a rangechange event with the current first, last, firstVisible, and\n     * lastVisible.\n     */\n  }, {\n    key: \"_notifyRange\",\n    value: function _notifyRange() {\n      this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_5__.RangeChangedEvent({\n        first: this._first,\n        last: this._last\n      }));\n    }\n  }, {\n    key: \"_notifyVisibility\",\n    value: function _notifyVisibility() {\n      this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_5__.VisibilityChangedEvent({\n        first: this._firstVisible,\n        last: this._lastVisible\n      }));\n    }\n  }, {\n    key: \"layoutComplete\",\n    get: function get() {\n      var _this10 = this;\n      // Lazily create promise\n      if (!this._layoutCompletePromise) {\n        this._layoutCompletePromise = new Promise(function (resolve, reject) {\n          _this10._layoutCompleteResolver = resolve;\n          _this10._layoutCompleteRejecter = reject;\n        });\n      }\n      return this._layoutCompletePromise;\n    }\n  }, {\n    key: \"_rejectLayoutCompletePromise\",\n    value: function _rejectLayoutCompletePromise(reason) {\n      if (this._layoutCompleteRejecter !== null) {\n        this._layoutCompleteRejecter(reason);\n      }\n      this._resetLayoutCompleteState();\n    }\n  }, {\n    key: \"_scheduleLayoutComplete\",\n    value: function _scheduleLayoutComplete() {\n      var _this11 = this;\n      // Don't do anything unless we have a pending promise\n      // And only request a frame if we haven't already done so\n      if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n        // Wait one additional frame to be sure the layout is stable\n        this._pendingLayoutComplete = requestAnimationFrame(function () {\n          return requestAnimationFrame(function () {\n            return _this11._resolveLayoutCompletePromise();\n          });\n        });\n      }\n    }\n  }, {\n    key: \"_resolveLayoutCompletePromise\",\n    value: function _resolveLayoutCompletePromise() {\n      if (this._layoutCompleteResolver !== null) {\n        this._layoutCompleteResolver();\n      }\n      this._resetLayoutCompleteState();\n    }\n  }, {\n    key: \"_resetLayoutCompleteState\",\n    value: function _resetLayoutCompleteState() {\n      this._layoutCompletePromise = null;\n      this._layoutCompleteResolver = null;\n      this._layoutCompleteRejecter = null;\n      this._pendingLayoutComplete = null;\n    }\n    /**\n     * Render and update the view at the next opportunity with the given\n     * hostElement size.\n     */\n  }, {\n    key: \"_hostElementSizeChanged\",\n    value: function _hostElementSizeChanged() {\n      this._schedule(this._updateLayout);\n    }\n    // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n    // to have dedicated support for; might want some more generic lifecycle hooks for\n    // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n    // a first-class feature?\n  }, {\n    key: \"_childLoaded\",\n    value: function _childLoaded() {}\n    // This is the callback for the ResizeObserver that watches the\n    // virtualizer's children. We land here at the end of every virtualizer\n    // update cycle that results in changes to physical items, and we also\n    // end up here if one or more children change size independently of\n    // the virtualizer update cycle.\n  }, {\n    key: \"_childrenSizeChanged\",\n    value: function _childrenSizeChanged(changes) {\n      var _a;\n      // Only measure if the layout requires it\n      if ((_a = this._layout) === null || _a === void 0 ? void 0 : _a.measureChildren) {\n        var _iterator2 = (0,_babel_runtime_helpers_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(changes),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var change = _step2.value;\n            this._toBeMeasured.set(change.target, change.contentRect);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        this._measureChildren();\n      }\n      // If this is the end of an update cycle, we need to reset some\n      // internal state. This should be a harmless no-op if we're handling\n      // an out-of-cycle ResizeObserver callback, so we don't need to\n      // distinguish between the two cases.\n      this._scheduleLayoutComplete();\n      this._itemsChanged = false;\n      this._rangeChanged = false;\n    }\n  }]);\n  return Virtualizer;\n}();\nfunction getMargins(el) {\n  var style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  var float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  var parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var ancestors = [];\n  var parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el) {\n  var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return getElementAncestors(el, includeSelf).filter(function (a) {\n    return getComputedStyle(a).overflow !== 'visible';\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1ZpcnR1YWxpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztBQXVCQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUE0Q0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQW1JQTtBQUFBO0FBbElBO0FBRUE7QUFFQTtBQUVBOzs7O0FBSUE7QUFFQTs7OztBQUlBO0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBT0E7QUFFQTtBQUVBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7Ozs7QUFLQTtBQUVBO0FBSUE7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUlBO0FBSUE7QUFDQTs7QUFFQTs7QUFHQTtBQUNBOztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7Ozs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTs7QUFHQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFDQTtBQUNBOztBQUlBO0FBRUE7Ozs7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9WaXJ0dWFsaXplci50cz8yZjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQge1xuICBJdGVtQm94LFxuICBNYXJnaW5zLFxuICBMYXlvdXRDb25maWdWYWx1ZSxcbiAgQ2hpbGRQb3NpdGlvbnMsXG4gIENoaWxkTWVhc3VyZW1lbnRzLFxuICBMYXlvdXQsXG4gIExheW91dENvbnN0cnVjdG9yLFxuICBMYXlvdXRTcGVjaWZpZXIsXG4gIFN0YXRlQ2hhbmdlZE1lc3NhZ2UsXG4gIFNpemUsXG4gIEludGVybmFsUmFuZ2UsXG4gIE1lYXN1cmVDaGlsZEZ1bmN0aW9uLFxuICBTY3JvbGxUb0Nvb3JkaW5hdGVzLFxuICBCYXNlTGF5b3V0Q29uZmlnLFxuICBMYXlvdXRIb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi9sYXlvdXRzL3NoYXJlZC9MYXlvdXQuanMnO1xuaW1wb3J0IHtcbiAgUmFuZ2VDaGFuZ2VkRXZlbnQsXG4gIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQsXG4gIFVucGlubmVkRXZlbnQsXG59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7U2Nyb2xsZXJDb250cm9sbGVyfSBmcm9tICcuL1Njcm9sbGVyQ29udHJvbGxlci5qcyc7XG5cbi8vIFZpcnR1YWxpemVyIGRlcGVuZHMgb24gYFJlc2l6ZU9ic2VydmVyYCwgd2hpY2ggaXMgc3VwcG9ydGVkIGluXG4vLyBhbGwgbW9kZXJuIGJyb3dzZXJzLiBGb3IgZGV2ZWxvcGVycyB3aG9zZSBicm93c2VyIHN1cHBvcnRcbi8vIG1hdHJpeCBpbmNsdWRlcyBvbGRlciBicm93c2Vycywgd2UgaW5jbHVkZSBhIGNvbXBhdGlibGVcbi8vIHBvbHlmaWxsIGluIHRoZSBwYWNrYWdlOyB0aGlzIGJpdCBvZiBtb2R1bGUgc3RhdGUgZmFjaWxpdGF0ZXNcbi8vIGEgc2ltcGxlIG1lY2hhbmlzbSAoc2VlIC4vcG9seWZpbGxMb2FkZXJzL1Jlc2l6ZU9ic2VydmVyLmpzLilcbi8vIGZvciBsb2FkaW5nIHRoZSBwb2x5ZmlsbC5cbmxldCBfUmVzaXplT2JzZXJ2ZXI6IHR5cGVvZiBSZXNpemVPYnNlcnZlciB8IHVuZGVmaW5lZCA9IHdpbmRvdz8uUmVzaXplT2JzZXJ2ZXI7XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBgUmVzaXplT2JzZXJ2ZXJgIHBvbHlmaWxsIGZvciBWaXJ0dWFsaXplciB0byB1c2UuXG4gKiBAcGFyYW0gQ3RvciBDb25zdHJ1Y3RvciBmb3IgYSBgUmVzaXplT2JzZXJ2ZXJgIHBvbHlmaWxsIChyZWNvbW1lbmQgdXNpbmcgdGhlIG9uZSBwcm92aWRlZCB3aXRoIHRoZSBWaXJ0dWFsaXplciBwYWNrYWdlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZVJlc2l6ZU9ic2VydmVyKEN0b3I6IHR5cGVvZiBSZXNpemVPYnNlcnZlcikge1xuICBfUmVzaXplT2JzZXJ2ZXIgPSBDdG9yO1xufVxuXG5leHBvcnQgY29uc3QgdmlydHVhbGl6ZXJSZWYgPSBTeW1ib2woJ3ZpcnR1YWxpemVyUmVmJyk7XG5jb25zdCBTSVpFUl9BVFRSSUJVVEUgPSAndmlydHVhbGl6ZXItc2l6ZXInO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudEV2ZW50TWFwIHtcbiAgICByYW5nZUNoYW5nZWQ6IFJhbmdlQ2hhbmdlZEV2ZW50O1xuICAgIHZpc2liaWxpdHlDaGFuZ2VkOiBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50O1xuICAgIHVucGlubmVkOiBVbnBpbm5lZEV2ZW50O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlydHVhbGl6ZXJIb3N0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgW3ZpcnR1YWxpemVyUmVmXT86IFZpcnR1YWxpemVyO1xufVxuXG4vKipcbiAqIEEgdmVyeSBsaW1pdGVkIHByb3h5IG9iamVjdCBmb3IgYSB2aXJ0dWFsaXplciBjaGlsZCxcbiAqIHJldHVybmVkIGJ5IFZpcnR1YWxpemVyLmVsZW1lbnQoaWR4OiBudW1iZXIpLiBJbnRyb2R1Y2VkXG4gKiB0byBlbmFibGUgc2Nyb2xsaW5nIGEgdmlydHVhbCBlbGVtZW50IGludG8gdmlldyB1c2luZ1xuICogYSBjYWxsIHRoYXQgbG9va3MgYW5kIGJlaGF2ZXMgZXNzZW50aWFsbHkgdGhlIHNhbWUgYXMgZm9yXG4gKiBhIHJlYWwgRWxlbWVudC4gTWF5IGJlIHVzZWZ1bCBmb3Igb3RoZXIgdGhpbmdzIGxhdGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVyQ2hpbGRFbGVtZW50UHJveHkge1xuICBzY3JvbGxJbnRvVmlldzogKG9wdGlvbnM/OiBTY3JvbGxJbnRvVmlld09wdGlvbnMpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGxpbmcgYSAocG9zc2libHkgdmlydHVhbCkgZWxlbWVudFxuICogaW50byB2aWV3LCBnaXZlbiBpdHMgaW5kZXhcbiAqL1xuaW50ZXJmYWNlIFNjcm9sbEVsZW1lbnRJbnRvVmlld09wdGlvbnMgZXh0ZW5kcyBTY3JvbGxJbnRvVmlld09wdGlvbnMge1xuICBpbmRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVyQ29uZmlnIHtcbiAgbGF5b3V0PzogTGF5b3V0Q29uZmlnVmFsdWU7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJlbnQgb2YgYWxsIGNoaWxkIG5vZGVzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgaG9zdEVsZW1lbnQ6IFZpcnR1YWxpemVySG9zdEVsZW1lbnQ7XG5cbiAgc2Nyb2xsZXI/OiBib29sZWFuO1xufVxuXG5sZXQgRGVmYXVsdExheW91dENvbnN0cnVjdG9yOiBMYXlvdXRDb25zdHJ1Y3RvcjtcblxuLyoqXG4gKiBQcm92aWRlcyB2aXJ0dWFsIHNjcm9sbGluZyBib2lsZXJwbGF0ZS5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBzZXQgaG9zdEVsZW1lbnQgYW5kIGxheW91dC5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBhbHNvIG92ZXJyaWRlIFZpcnR1YWxSZXBlYXRlcidzIERPTVxuICogbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaXJ0dWFsaXplciB7XG4gIHByaXZhdGUgX2JlbmNobWFya1N0YXJ0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9sYXlvdXQ6IExheW91dCB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX2NsaXBwaW5nQW5jZXN0b3JzOiBIVE1MRWxlbWVudFtdID0gW107XG5cbiAgLyoqXG4gICAqIExheW91dCBwcm92aWRlcyB0aGVzZSB2YWx1ZXMsIHdlIHNldCB0aGVtIG9uIF9yZW5kZXIoKS5cbiAgICogVE9ETyBAc3RyYXZlcnNpOiBDYW4gd2UgZmluZCBhbiBYT1IgdHlwZSwgdXNhYmxlIGZvciB0aGUga2V5IGhlcmU/XG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxTaXplOiBTaXplIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIERpZmZlcmVuY2UgYmV0d2VlbiBzY3JvbGwgdGFyZ2V0J3MgY3VycmVudCBhbmQgcmVxdWlyZWQgc2Nyb2xsIG9mZnNldHMuXG4gICAqIFByb3ZpZGVkIGJ5IGxheW91dC5cbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbEVycm9yOiB7bGVmdDogbnVtYmVyOyB0b3A6IG51bWJlcn0gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBwb3NpdGlvbnMgKHRvcCwgbGVmdCkgb2YgdGhlIGNoaWxkcmVuIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgKi9cbiAgcHJpdmF0ZSBfY2hpbGRyZW5Qb3M6IENoaWxkUG9zaXRpb25zIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gVE9ETzogKGdyYXlub3J0b24pOiB0eXBlXG4gIHByaXZhdGUgX2NoaWxkTWVhc3VyZW1lbnRzOiBDaGlsZE1lYXN1cmVtZW50cyB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX3RvQmVNZWFzdXJlZDogTWFwPEhUTUxFbGVtZW50LCB1bmtub3duPiA9IG5ldyBNYXAoKTtcblxuICBwcml2YXRlIF9yYW5nZUNoYW5nZWQgPSB0cnVlO1xuXG4gIHByaXZhdGUgX2l0ZW1zQ2hhbmdlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgSFRNTEVsZW1lbnQgdGhhdCBob3N0cyB0aGUgdmlydHVhbGl6ZXIuIFNldCBieSBob3N0RWxlbWVudC5cbiAgICovXG4gIHByb3RlY3RlZCBfaG9zdEVsZW1lbnQ/OiBWaXJ0dWFsaXplckhvc3RFbGVtZW50O1xuXG4gIHByaXZhdGUgX3Njcm9sbGVyQ29udHJvbGxlcjogU2Nyb2xsZXJDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfaXNTY3JvbGxlciA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3NpemVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gaG9zdEVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIF9ob3N0RWxlbWVudFJPOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gY2hpbGRyZW4uXG4gICAqL1xuICBwcml2YXRlIF9jaGlsZHJlblJPOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX211dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9zY3JvbGxFdmVudExpc3RlbmVyczogKEVsZW1lbnQgfCBXaW5kb3cpW10gPSBbXTtcbiAgcHJpdmF0ZSBfc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xuICAgIHBhc3NpdmU6IHRydWUsXG4gIH07XG5cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFJldGhpbmssIHBlciBsb25nZXIgY29tbWVudCBiZWxvd1xuXG4gIHByaXZhdGUgX2xvYWRMaXN0ZW5lciA9IHRoaXMuX2NoaWxkTG9hZGVkLmJpbmQodGhpcyk7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIGVsZW1lbnQgdG8gc2Nyb2xsIGludG8gdmlldywgcGx1cyBzY3JvbGxcbiAgICogYmVoYXZpb3Igb3B0aW9ucywgYXMgaW1wZXJhdGl2ZWx5IHNwZWNpZmllZCB2aWFcbiAgICogYGVsZW1lbnQoaW5kZXgpLnNjcm9sbEludG9WaWV3KClgXG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxJbnRvVmlld1RhcmdldDogU2Nyb2xsRWxlbWVudEludG9WaWV3T3B0aW9ucyB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX3VwZGF0ZVNjcm9sbEludG9WaWV3Q29vcmRpbmF0ZXM6XG4gICAgfCAoKGNvb3JkaW5hdGVzOiBTY3JvbGxUb0Nvb3JkaW5hdGVzKSA9PiB2b2lkKVxuICAgIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEl0ZW1zIHRvIHJlbmRlci4gU2V0IGJ5IGl0ZW1zLlxuICAgKi9cbiAgcHJpdmF0ZSBfaXRlbXM6IEFycmF5PHVua25vd24+ID0gW107XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBjaGlsZCBpbiB0aGUgcmFuZ2UsIG5vdCBuZWNlc3NhcmlseSB0aGUgZmlyc3QgdmlzaWJsZSBjaGlsZC5cbiAgICogVE9ETyBAc3RyYXZlcnNpOiBDb25zaWRlciByZW5hbWluZyB0aGVzZS5cbiAgICovXG4gIHByb3RlY3RlZCBfZmlyc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIHJhbmdlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF9maXJzdFZpc2libGUgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgaXRlbSBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJpdmF0ZSBfbGFzdFZpc2libGUgPSAtMTtcblxuICBwcm90ZWN0ZWQgX3NjaGVkdWxlZCA9IG5ldyBXZWFrU2V0KCk7XG5cbiAgLyoqXG4gICAqIEludm9rZWQgYXQgdGhlIGVuZCBvZiBlYWNoIHJlbmRlciBjeWNsZTogY2hpbGRyZW4gaW4gdGhlIHJhbmdlIGFyZVxuICAgKiBtZWFzdXJlZCwgYW5kIHRoZWlyIGRpbWVuc2lvbnMgcGFzc2VkIHRvIHRoaXMgY2FsbGJhY2suIFVzZSBpdCB0byBsYXlvdXRcbiAgICogY2hpbGRyZW4gYXMgbmVlZGVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9tZWFzdXJlQ2FsbGJhY2s6ICgoc2l6ZXM6IENoaWxkTWVhc3VyZW1lbnRzKSA9PiB2b2lkKSB8IG51bGwgPVxuICAgIG51bGw7XG5cbiAgcHJvdGVjdGVkIF9tZWFzdXJlQ2hpbGRPdmVycmlkZTogTWVhc3VyZUNoaWxkRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogU3RhdGUgZm9yIGBsYXlvdXRDb21wbGV0ZWAgcHJvbWlzZVxuICAgKi9cbiAgcHJpdmF0ZSBfbGF5b3V0Q29tcGxldGVQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xheW91dENvbXBsZXRlUmVzb2x2ZXI6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xheW91dENvbXBsZXRlUmVqZWN0ZXI6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3BlbmRpbmdMYXlvdXRDb21wbGV0ZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIExheW91dCBpbml0aWFsaXphdGlvbiBpcyBhc3luYyBiZWNhdXNlIHdlIGR5bmFtaWNhbGx5IGxvYWRcbiAgICogdGhlIGRlZmF1bHQgbGF5b3V0IGlmIG5vbmUgaXMgc3BlY2lmaWVkLiBUaGlzIHN0YXRlIGlzIHRvIHRyYWNrXG4gICAqIHdoZXRoZXIgaW5pdCBpcyBjb21wbGV0ZS5cbiAgICovXG4gIHByaXZhdGUgX2xheW91dEluaXRpYWxpemVkOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdWaXJ0dWFsaXplciBjb25zdHJ1Y3RvciByZXF1aXJlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5ob3N0RWxlbWVudCkge1xuICAgICAgdGhpcy5faW5pdChjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdWaXJ0dWFsaXplciBjb25maWd1cmF0aW9uIHJlcXVpcmVzIHRoZSBcImhvc3RFbGVtZW50XCIgcHJvcGVydHknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNldCBpdGVtcyhpdGVtczogQXJyYXk8dW5rbm93bj4gfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMgIT09IHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgX2luaXQoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIHRoaXMuX2lzU2Nyb2xsZXIgPSAhIWNvbmZpZy5zY3JvbGxlcjtcbiAgICB0aGlzLl9pbml0SG9zdEVsZW1lbnQoY29uZmlnKTtcbiAgICAvLyBJZiBubyBsYXlvdXQgaXMgc3BlY2lmaWVkLCB3ZSBtYWtlIGFuIGVtcHR5XG4gICAgLy8gbGF5b3V0IGNvbmZpZywgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIGRlZmF1bHRcbiAgICAvLyBsYXlvdXQgd2l0aCBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBjb25zdCBsYXlvdXRDb25maWcgPSBjb25maWcubGF5b3V0IHx8ICh7fSBhcyBCYXNlTGF5b3V0Q29uZmlnKTtcbiAgICAvLyBTYXZlIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IGBfaW5pdExheW91dGAgYXMgYSBzdGF0ZVxuICAgIC8vIHZhcmlhYmxlIHdlIGNhbiBjaGVjayBiZWZvcmUgdXBkYXRpbmcgbGF5b3V0IGNvbmZpZ1xuICAgIHRoaXMuX2xheW91dEluaXRpYWxpemVkID0gdGhpcy5faW5pdExheW91dChsYXlvdXRDb25maWcpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdE9ic2VydmVycygpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLl9maW5pc2hET01VcGRhdGUuYmluZCh0aGlzKVxuICAgICk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyA9IG5ldyBfUmVzaXplT2JzZXJ2ZXIhKCgpID0+XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudFNpemVDaGFuZ2VkKClcbiAgICApO1xuICAgIHRoaXMuX2NoaWxkcmVuUk8gPSBuZXcgX1Jlc2l6ZU9ic2VydmVyIShcbiAgICAgIHRoaXMuX2NoaWxkcmVuU2l6ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgICk7XG4gIH1cblxuICBfaW5pdEhvc3RFbGVtZW50KGNvbmZpZzogVmlydHVhbGl6ZXJDb25maWcpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9ICh0aGlzLl9ob3N0RWxlbWVudCA9IGNvbmZpZy5ob3N0RWxlbWVudCk7XG4gICAgdGhpcy5fYXBwbHlWaXJ0dWFsaXplclN0eWxlcygpO1xuICAgIGhvc3RFbGVtZW50W3ZpcnR1YWxpemVyUmVmXSA9IHRoaXM7XG4gIH1cblxuICBjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5faW5pdE9ic2VydmVycygpO1xuICAgIGNvbnN0IGluY2x1ZGVTZWxmID0gdGhpcy5faXNTY3JvbGxlcjtcbiAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycyA9IGdldENsaXBwaW5nQW5jZXN0b3JzKFxuICAgICAgdGhpcy5faG9zdEVsZW1lbnQhLFxuICAgICAgaW5jbHVkZVNlbGZcbiAgICApO1xuXG4gICAgdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyID0gbmV3IFNjcm9sbGVyQ29udHJvbGxlcihcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9yc1swXVxuICAgICk7XG5cbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICAgIHRoaXMuX29ic2VydmVBbmRMaXN0ZW4oKTtcbiAgfVxuXG4gIF9vYnNlcnZlQW5kTGlzdGVuKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIhLm9ic2VydmUodGhpcy5faG9zdEVsZW1lbnQhLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyEub2JzZXJ2ZSh0aGlzLl9ob3N0RWxlbWVudCEpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLnB1c2god2luZG93KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICAgIHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgICAgICk7XG4gICAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUoYW5jZXN0b3IpO1xuICAgIH0pO1xuICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5lbGVtZW50KTtcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fY2hpbGRyZW5STyEub2JzZXJ2ZShjaGlsZCkpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMgPSBbXTtcbiAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIgPSB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLmRldGFjaCh0aGlzKSB8fCBudWxsO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIhLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9ob3N0RWxlbWVudFJPIS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5fY2hpbGRyZW5STyEuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX3JlamVjdExheW91dENvbXBsZXRlUHJvbWlzZSgnZGlzY29ubmVjdGVkJyk7XG4gIH1cblxuICBwcml2YXRlIF9hcHBseVZpcnR1YWxpemVyU3R5bGVzKCkge1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5faG9zdEVsZW1lbnQhO1xuICAgIC8vIFdvdWxkIHJhdGhlciBzZXQgdGhlc2UgQ1NTIHByb3BlcnRpZXMgb24gdGhlIGhvc3QgdXNpbmcgU2hhZG93IFJvb3RcbiAgICAvLyBzdHlsZSBzY29waW5nIChhbmQgZmFsbGluZyBiYWNrIHRvIGEgZ2xvYmFsIHN0eWxlc2hlZXQgd2hlcmUgbmF0aXZlXG4gICAgLy8gU2hhZG93IERPTSBpcyBub3QgYXZhaWxhYmxlKSwgYnV0IHRoaXMgTW9iaWxlIFNhZmFyaSBidWcgaXMgcHJldmVudGluZ1xuICAgIC8vIHRoYXQgZnJvbSB3b3JraW5nOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2MTk1XG4gICAgY29uc3Qgc3R5bGUgPSBob3N0RWxlbWVudC5zdHlsZSBhcyBDU1NTdHlsZURlY2xhcmF0aW9uICYge2NvbnRhaW46IHN0cmluZ307XG4gICAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgICBzdHlsZS5wb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uIHx8ICdyZWxhdGl2ZSc7XG4gICAgc3R5bGUuY29udGFpbiA9IHN0eWxlLmNvbnRhaW4gfHwgJ3NpemUgbGF5b3V0JztcblxuICAgIGlmICh0aGlzLl9pc1Njcm9sbGVyKSB7XG4gICAgICBzdHlsZS5vdmVyZmxvdyA9IHN0eWxlLm92ZXJmbG93IHx8ICdhdXRvJztcbiAgICAgIHN0eWxlLm1pbkhlaWdodCA9IHN0eWxlLm1pbkhlaWdodCB8fCAnMTUwcHgnO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTaXplcigpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50ITtcbiAgICBpZiAoIXRoaXMuX3NpemVyKSB7XG4gICAgICAvLyBVc2UgYSBwcmVleGlzdGluZyBzaXplciBlbGVtZW50IGlmIHByb3ZpZGVkIChmb3IgYmV0dGVyIGludGVncmF0aW9uXG4gICAgICAvLyB3aXRoIHZET00gcmVuZGVyZXJzKVxuICAgICAgbGV0IHNpemVyID0gaG9zdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYFske1NJWkVSX0FUVFJJQlVURX1dYFxuICAgICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmICghc2l6ZXIpIHtcbiAgICAgICAgc2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2l6ZXIuc2V0QXR0cmlidXRlKFNJWkVSX0FUVFJJQlVURSwgJycpO1xuICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZChzaXplcik7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIHRoZSBzY3JvbGxIZWlnaHQgaXMgbGFyZ2UsIHRoZSBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IG1pZ2h0IGJlXG4gICAgICAvLyBpZ25vcmVkLiBTZXR0aW5nIGNvbnRlbnQgYW5kIGZvbnQtc2l6ZSBlbnN1cmVzIHRoZSBlbGVtZW50IGhhcyBhIHNpemUuXG4gICAgICBPYmplY3QuYXNzaWduKHNpemVyLnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBtYXJnaW46ICctMnB4IDAgMCAwJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgIGZvbnRTaXplOiAnMnB4JyxcbiAgICAgIH0pO1xuICAgICAgc2l6ZXIudGV4dENvbnRlbnQgPSAnJm5ic3A7JztcbiAgICAgIHNpemVyLnNldEF0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUsICcnKTtcbiAgICAgIHRoaXMuX3NpemVyID0gc2l6ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaXplcjtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUxheW91dENvbmZpZyhsYXlvdXRDb25maWc6IExheW91dENvbmZpZ1ZhbHVlKSB7XG4gICAgLy8gSWYgbGF5b3V0IGluaXRpYWxpemF0aW9uIGhhc24ndCBmaW5pc2hlZCB5ZXQsIHdlIHdhaXRcbiAgICAvLyBmb3IgaXQgdG8gZmluaXNoIHNvIHdlIGNhbiBjaGVjayB3aGV0aGVyIHRoZSBuZXcgY29uZmlnXG4gICAgLy8gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBleGlzdGluZyBsYXlvdXQgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgYXdhaXQgdGhpcy5fbGF5b3V0SW5pdGlhbGl6ZWQ7XG4gICAgY29uc3QgQ3RvciA9XG4gICAgICAoKGxheW91dENvbmZpZyBhcyBMYXlvdXRTcGVjaWZpZXIpLnR5cGUgYXMgTGF5b3V0Q29uc3RydWN0b3IpIHx8XG4gICAgICAvLyBUaGUgbmV3IGNvbmZpZyBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgbGF5b3V0LFxuICAgICAgLy8gc28gd2UgdXBkYXRlIHRoZSBjb25maWcgYW5kIHJldHVybiB0cnVlIHRvIGluZGljYXRlXG4gICAgICAvLyBhIHN1Y2Nlc3NmdWwgdXBkYXRlXG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3I7XG4gICAgaWYgKHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIHRoaXMuX2xheW91dCBpbnN0YW5jZW9mIEN0b3IpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb25maWcudHlwZTtcbiAgICAgIHRoaXMuX2xheW91dC5jb25maWcgPSBjb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICAgIC8vIFRoZSBuZXcgY29uZmlnIHJlcXVpcmVzIGEgZGlmZmVyZW50IGxheW91dCBhbHRvZ2V0aGVyLCBidXRcbiAgICAgIC8vIHRvIGxpbWl0IGltcGxlbWVudGF0aW9uIGNvbXBsZXhpdHkgd2UgZG9uJ3Qgc3VwcG9ydCBkeW5hbWljYWxseVxuICAgICAgLy8gY2hhbmdpbmcgdGhlIGxheW91dCBvZiBhbiBleGlzdGluZyB2aXJ0dWFsaXplciBpbnN0YW5jZS5cbiAgICAgIC8vIFJldHVybmluZyBmYWxzZSBoZXJlIGxldHMgdGhlIGNhbGxlciBrbm93IHRoYXQgdGhleSBzaG91bGRcbiAgICAgIC8vIGluc3RlYWQgbWFrZSBhIG5ldyB2aXJ0dWFsaXplciBpbnN0YW5jZSB3aXRoIHRoZSBkZXNpcmVkIGxheW91dC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9pbml0TGF5b3V0KGxheW91dENvbmZpZzogTGF5b3V0Q29uZmlnVmFsdWUpIHtcbiAgICBsZXQgY29uZmlnOiBCYXNlTGF5b3V0Q29uZmlnIHwgdW5kZWZpbmVkO1xuICAgIGxldCBDdG9yOiBMYXlvdXRDb25zdHJ1Y3RvciB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZnVsbCBMYXlvdXRTcGVjaWZpZXIsIHRoZSBgdHlwZWAgcHJvcGVydHlcbiAgICAgIC8vIGdpdmVzIHVzIG91ciBjb25zdHJ1Y3Rvci4uLlxuICAgICAgQ3RvciA9IChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlIGFzIExheW91dENvbnN0cnVjdG9yO1xuICAgICAgLy8gLi4ud2hpbGUgdGhlIHJlc3Qgb2YgdGhlIHNwZWNpZmllciBpcyBvdXIgbGF5b3V0IGNvbmZpZ1xuICAgICAgY29uc3QgY29weSA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb3B5LnR5cGU7XG4gICAgICBjb25maWcgPSBjb3B5IGFzIEJhc2VMYXlvdXRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBmdWxsIExheW91dFNwZWNpZmllciwgd2UganVzdFxuICAgICAgLy8gaGF2ZSBhIGNvbmZpZyBmb3IgdGhlIGRlZmF1bHQgbGF5b3V0XG4gICAgICBjb25maWcgPSBsYXlvdXRDb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY29uc3RydWN0b3IgeWV0LCBsb2FkIHRoZSBkZWZhdWx0XG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3IgPSBDdG9yID0gKGF3YWl0IGltcG9ydCgnLi9sYXlvdXRzL2Zsb3cuanMnKSlcbiAgICAgICAgLkZsb3dMYXlvdXQgYXMgdW5rbm93biBhcyBMYXlvdXRDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXlvdXQgPSBuZXcgQ3RvcihcbiAgICAgIChtZXNzYWdlOiBMYXlvdXRIb3N0TWVzc2FnZSkgPT4gdGhpcy5faGFuZGxlTGF5b3V0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgIGNvbmZpZ1xuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuICYmXG4gICAgICB0eXBlb2YgdGhpcy5fbGF5b3V0LnVwZGF0ZUl0ZW1TaXplcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlID0gdGhpcy5fbGF5b3V0Lm1lYXN1cmVDaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayA9IHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMuYmluZCh0aGlzLl9sYXlvdXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9sYXlvdXQubGlzdGVuRm9yQ2hpbGRMb2FkRXZlbnRzKSB7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2xvYWRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgfVxuXG4gIC8vIFRPRE8gKGdyYXlub3J0b24pOiBSZXdvcmsgYmVuY2htYXJraW5nIHNvIHRoYXQgaXQgaGFzIG5vIEFQSSBhbmRcbiAgLy8gaW5zdGVhZCBpcyBhbHdheXMgb24gZXhjZXB0IGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIHN0YXJ0QmVuY2htYXJraW5nKCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcEJlbmNobWFya2luZygpIHtcbiAgICBpZiAodGhpcy5fYmVuY2htYXJrU3RhcnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gbm93IC0gdGhpcy5fYmVuY2htYXJrU3RhcnQ7XG4gICAgICBjb25zdCBlbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICAgICAgJ3V2LXZpcnR1YWxpemluZycsXG4gICAgICAgICdtZWFzdXJlJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpcnR1YWxpemF0aW9uVGltZSA9IGVudHJpZXNcbiAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAoZSkgPT4gZS5zdGFydFRpbWUgPj0gdGhpcy5fYmVuY2htYXJrU3RhcnQhICYmIGUuc3RhcnRUaW1lIDwgbm93XG4gICAgICAgIClcbiAgICAgICAgLnJlZHVjZSgodCwgbSkgPT4gdCArIG0uZHVyYXRpb24sIDApO1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSBudWxsO1xuICAgICAgcmV0dXJuIHt0aW1lRWxhcHNlZCwgdmlydHVhbGl6YXRpb25UaW1lfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9tZWFzdXJlQ2hpbGRyZW4oKTogdm9pZCB7XG4gICAgY29uc3QgbW06IENoaWxkTWVhc3VyZW1lbnRzID0ge307XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBjb25zdCBmbiA9IHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlIHx8IHRoaXMuX21lYXN1cmVDaGlsZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZmlyc3QgKyBpO1xuICAgICAgaWYgKHRoaXMuX2l0ZW1zQ2hhbmdlZCB8fCB0aGlzLl90b0JlTWVhc3VyZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICBtbVtpZHhdID0gZm4uY2FsbCh0aGlzLCBjaGlsZCwgdGhpcy5faXRlbXNbaWR4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkTWVhc3VyZW1lbnRzID0gbW07XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB0aGlzLl90b0JlTWVhc3VyZWQuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgbWFyZ2lucyBvZiB0aGUgZ2l2ZW4gY2hpbGQuXG4gICAqL1xuICBfbWVhc3VyZUNoaWxkKGVsZW1lbnQ6IEVsZW1lbnQpOiBJdGVtQm94IHtcbiAgICAvLyBvZmZzZXRXaWR0aCBkb2Vzbid0IHRha2UgdHJhbnNmb3JtcyBpbiBjb25zaWRlcmF0aW9uLCBzbyB3ZSB1c2VcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2hpY2ggZG9lcy5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0fSwgZ2V0TWFyZ2lucyhlbGVtZW50KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NjaGVkdWxlKG1ldGhvZDogRnVuY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZC5oYXMobWV0aG9kKSkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkLmFkZChtZXRob2QpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQuZGVsZXRlKG1ldGhvZCk7XG4gICAgICBtZXRob2QuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfdXBkYXRlRE9NKHN0YXRlOiBTdGF0ZUNoYW5nZWRNZXNzYWdlKSB7XG4gICAgdGhpcy5fc2Nyb2xsU2l6ZSA9IHN0YXRlLnNjcm9sbFNpemU7XG4gICAgdGhpcy5fYWRqdXN0UmFuZ2Uoc3RhdGUucmFuZ2UpO1xuICAgIHRoaXMuX2NoaWxkcmVuUG9zID0gc3RhdGUuY2hpbGRQb3NpdGlvbnM7XG4gICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSBzdGF0ZS5zY3JvbGxFcnJvciB8fCBudWxsO1xuICAgIGNvbnN0IHtfcmFuZ2VDaGFuZ2VkLCBfaXRlbXNDaGFuZ2VkfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlWaXNpYmlsaXR5KCk7XG4gICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3JhbmdlQ2hhbmdlZCB8fCBfaXRlbXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlSYW5nZSgpO1xuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpbmlzaERPTVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9maW5pc2hET01VcGRhdGUoKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2NoaWxkcmVuUk8hLm9ic2VydmUoY2hpbGQpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbEludG9WaWV3VGFyZ2V0KHRoaXMuX2NoaWxkcmVuUG9zKTtcbiAgICB0aGlzLl9wb3NpdGlvbkNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuUG9zKTtcbiAgICB0aGlzLl9zaXplSG9zdEVsZW1lbnQodGhpcy5fc2Nyb2xsU2l6ZSk7XG4gICAgdGhpcy5fY29ycmVjdFNjcm9sbEVycm9yKCk7XG4gICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1lbmQnKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgIHRoaXMuX2xheW91dCEuaXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQsIHdlIG1heSBoYXZlIG1lYXN1cmVtZW50cyBidXQgbm8gY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMuX21lYXN1cmVDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hpbGRNZWFzdXJlbWVudHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5b3V0IS5yZWZsb3dJZk5lZWRlZCgpO1xuICAgICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoJ3V2LWVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVNjcm9sbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCAmJiAnbWFyaycgaW4gd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWVhc3VyZSgndXYtdmlydHVhbGl6aW5nJywgJ3V2LXN0YXJ0JywgJ3V2LWVuZCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIG1lYXN1cmluZyBwZXJmb3JtYW5jZSBkYXRhOiAnLCBlKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdXNlci1pbml0aWF0ZWQgc2Nyb2xsLCBzbyB3ZSB1bnBpbiB0aGUgbGF5b3V0XG4gICAgICB0aGlzLl9sYXlvdXQ/LnVucGluKCk7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudDogQ3VzdG9tRXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID09PSB3aW5kb3cgfHxcbiAgICAgICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycy5pbmNsdWRlcyhldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdldmVudCBub3QgaGFuZGxlZCcsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlTGF5b3V0TWVzc2FnZShtZXNzYWdlOiBMYXlvdXRIb3N0TWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzdGF0ZUNoYW5nZWQnKSB7XG4gICAgICB0aGlzLl91cGRhdGVET00obWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd2aXNpYmlsaXR5Q2hhbmdlZCcpIHtcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IG1lc3NhZ2UuZmlyc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbGFzdFZpc2libGUgPSBtZXNzYWdlLmxhc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbm90aWZ5VmlzaWJpbGl0eSgpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAndW5waW5uZWQnKSB7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChuZXcgVW5waW5uZWRFdmVudCgpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2NoaWxkcmVuKCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgY29uc3QgYXJyOiBBcnJheTxIVE1MRWxlbWVudD4gPSBbXTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuX2hvc3RFbGVtZW50IS5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKCFuZXh0Lmhhc0F0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUpKSB7XG4gICAgICAgIGFyci5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nIGFzIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlVmlldygpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50O1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXI/LmVsZW1lbnQ7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuXG4gICAgaWYgKGhvc3RFbGVtZW50ICYmIHNjcm9sbGluZ0VsZW1lbnQgJiYgbGF5b3V0KSB7XG4gICAgICBsZXQgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0O1xuXG4gICAgICBjb25zdCBob3N0RWxlbWVudEJvdW5kcyA9IGhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB0b3AgPSAwO1xuICAgICAgbGVmdCA9IDA7XG4gICAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgICBjb25zdCBhbmNlc3RvckJvdW5kcyA9IHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLm1hcCgoYW5jZXN0b3IpID0+XG4gICAgICAgIGFuY2VzdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICApO1xuICAgICAgYW5jZXN0b3JCb3VuZHMudW5zaGlmdChob3N0RWxlbWVudEJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgYm91bmRzIG9mIGFuY2VzdG9yQm91bmRzKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgYm91bmRzLnRvcCk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBib3VuZHMubGVmdCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgYm91bmRzLmJvdHRvbSk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIGJvdW5kcy5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMgPSBzY3JvbGxpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBjb25zdCBvZmZzZXRXaXRoaW5TY3JvbGxlciA9IHtcbiAgICAgICAgbGVmdDogaG9zdEVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBob3N0RWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxpbmdFbGVtZW50Qm91bmRzLnRvcCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRvdGFsU2Nyb2xsU2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB0b3AgLSBob3N0RWxlbWVudEJvdW5kcy50b3AgKyBob3N0RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gbGVmdCAtIGhvc3RFbGVtZW50Qm91bmRzLmxlZnQgKyBob3N0RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCgxLCBib3R0b20gLSB0b3ApO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCByaWdodCAtIGxlZnQpO1xuXG4gICAgICBsYXlvdXQudmlld3BvcnRTaXplID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgICAgbGF5b3V0LnZpZXdwb3J0U2Nyb2xsID0ge3RvcDogc2Nyb2xsVG9wLCBsZWZ0OiBzY3JvbGxMZWZ0fTtcbiAgICAgIGxheW91dC50b3RhbFNjcm9sbFNpemUgPSB0b3RhbFNjcm9sbFNpemU7XG4gICAgICBsYXlvdXQub2Zmc2V0V2l0aGluU2Nyb2xsZXIgPSBvZmZzZXRXaXRoaW5TY3JvbGxlcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBob3N0IGVsZW1lbnQgc28gdGhhdCBpdHMgc2l6ZSByZWZsZWN0cyB0aGVcbiAgICogdG90YWwgc2l6ZSBvZiBhbGwgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9zaXplSG9zdEVsZW1lbnQoc2l6ZT86IFNpemUgfCBudWxsKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZWVtIHRvIGNyYXAgb3V0IGlmIHRoZSBob3N0IGVsZW1lbnQgZ2V0cyBsYXJnZXIgdGhhblxuICAgIC8vIGEgY2VydGFpbiBzaXplLCBzbyB3ZSBjbGFtcCBpdCBoZXJlICh0aGlzIHZhbHVlIGJhc2VkIG9uIGFkIGhvY1xuICAgIC8vIHRlc3RpbmcgaW4gQ2hyb21lIC8gU2FmYXJpIC8gRmlyZWZveCBNYWMpXG4gICAgY29uc3QgbWF4ID0gODIwMDAwMDtcbiAgICBjb25zdCBoID0gc2l6ZSAmJiBzaXplLndpZHRoICE9PSBudWxsID8gTWF0aC5taW4obWF4LCBzaXplLndpZHRoKSA6IDA7XG4gICAgY29uc3QgdiA9IHNpemUgJiYgc2l6ZS5oZWlnaHQgIT09IG51bGwgPyBNYXRoLm1pbihtYXgsIHNpemUuaGVpZ2h0KSA6IDA7XG5cbiAgICBpZiAodGhpcy5faXNTY3JvbGxlcikge1xuICAgICAgdGhpcy5fZ2V0U2l6ZXIoKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7aH1weCwgJHt2fXB4KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5faG9zdEVsZW1lbnQhLnN0eWxlO1xuICAgICAgKHN0eWxlLm1pbldpZHRoIGFzIHN0cmluZyB8IG51bGwpID0gaCA/IGAke2h9cHhgIDogJzEwMCUnO1xuICAgICAgKHN0eWxlLm1pbkhlaWdodCBhcyBzdHJpbmcgfCBudWxsKSA9IHYgPyBgJHt2fXB4YCA6ICcxMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdG9wIGFuZCBsZWZ0IHRyYW5zZm9ybSBzdHlsZSBvZiB0aGUgY2hpbGRyZW4gZnJvbSB0aGUgdmFsdWVzIGluXG4gICAqIHBvcy5cbiAgICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hpbGRyZW4ocG9zOiBDaGlsZFBvc2l0aW9ucyB8IG51bGwpIHtcbiAgICBpZiAocG9zKSB7XG4gICAgICBwb3MuZm9yRWFjaCgoe3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCwgeE9mZnNldCwgeU9mZnNldH0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baW5kZXggLSB0aGlzLl9maXJzdF07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBjaGlsZC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICAgICAgY2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsICR7dG9wfXB4KWA7XG4gICAgICAgICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChjaGlsZC5zdHlsZS5sZWZ0IGFzIHN0cmluZyB8IG51bGwpID1cbiAgICAgICAgICAgIHhPZmZzZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB4T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAoY2hpbGQuc3R5bGUudG9wIGFzIHN0cmluZyB8IG51bGwpID1cbiAgICAgICAgICAgIHlPZmZzZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB5T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYWRqdXN0UmFuZ2UocmFuZ2U6IEludGVybmFsUmFuZ2UpIHtcbiAgICBjb25zdCB7X2ZpcnN0LCBfbGFzdCwgX2ZpcnN0VmlzaWJsZSwgX2xhc3RWaXNpYmxlfSA9IHRoaXM7XG4gICAgdGhpcy5fZmlyc3QgPSByYW5nZS5maXJzdDtcbiAgICB0aGlzLl9sYXN0ID0gcmFuZ2UubGFzdDtcbiAgICB0aGlzLl9maXJzdFZpc2libGUgPSByYW5nZS5maXJzdFZpc2libGU7XG4gICAgdGhpcy5fbGFzdFZpc2libGUgPSByYW5nZS5sYXN0VmlzaWJsZTtcbiAgICB0aGlzLl9yYW5nZUNoYW5nZWQgPVxuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkIHx8IHRoaXMuX2ZpcnN0ICE9PSBfZmlyc3QgfHwgdGhpcy5fbGFzdCAhPT0gX2xhc3Q7XG4gICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPVxuICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgfHxcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSAhPT0gX2ZpcnN0VmlzaWJsZSB8fFxuICAgICAgdGhpcy5fbGFzdFZpc2libGUgIT09IF9sYXN0VmlzaWJsZTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvcnJlY3RTY3JvbGxFcnJvcigpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsRXJyb3IpIHtcbiAgICAgIGNvbnN0IHtzY3JvbGxUb3AsIHNjcm9sbExlZnR9ID0gdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyITtcbiAgICAgIGNvbnN0IHt0b3AsIGxlZnR9ID0gdGhpcy5fc2Nyb2xsRXJyb3I7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLmNvcnJlY3RTY3JvbGxFcnJvcih7XG4gICAgICAgIHRvcDogc2Nyb2xsVG9wIC0gdG9wLFxuICAgICAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gbGVmdCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBlbGVtZW50KGluZGV4OiBudW1iZXIpOiBWaXJ0dWFsaXplckNoaWxkRWxlbWVudFByb3h5IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICBpbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtcz8uW2luZGV4XSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB7XG4gICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IChvcHRpb25zOiBTY3JvbGxJbnRvVmlld09wdGlvbnMgPSB7fSkgPT5cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnRJbnRvVmlldyh7Li4ub3B0aW9ucywgaW5kZXh9KSxcbiAgICAgICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnRJbnRvVmlldyhvcHRpb25zOiBTY3JvbGxFbGVtZW50SW50b1ZpZXdPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXggPj0gdGhpcy5fZmlyc3QgJiYgb3B0aW9ucy5pbmRleCA8PSB0aGlzLl9sYXN0KSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbltvcHRpb25zLmluZGV4IC0gdGhpcy5fZmlyc3RdLnNjcm9sbEludG9WaWV3KG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmluZGV4ID0gTWF0aC5taW4ob3B0aW9ucy5pbmRleCwgdGhpcy5faXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAob3B0aW9ucy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLl9sYXlvdXQhLmdldFNjcm9sbEludG9WaWV3Q29vcmRpbmF0ZXMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHtiZWhhdmlvcn0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzID1cbiAgICAgICAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLm1hbmFnZWRTY3JvbGxUbyhcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29vcmRpbmF0ZXMsIHtiZWhhdmlvcn0pLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgKCkgPT4gKHRoaXMuX3Njcm9sbEludG9WaWV3VGFyZ2V0ID0gbnVsbClcbiAgICAgICAgICApO1xuICAgICAgICB0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCA9IG9wdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sYXlvdXQhLnBpbiA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGFyZSBzbW9vdGhseSBzY3JvbGxpbmcgdG8gYW4gZWxlbWVudCBhbmQgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIGlzIGluIHRoZSBET00sIHdlIHVwZGF0ZSBvdXIgdGFyZ2V0IGNvb3JkaW5hdGVzIGFzIG5lZWRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfY2hlY2tTY3JvbGxJbnRvVmlld1RhcmdldChwb3M6IENoaWxkUG9zaXRpb25zIHwgbnVsbCkge1xuICAgIGNvbnN0IHtpbmRleH0gPSB0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCB8fCB7fTtcbiAgICBpZiAoaW5kZXggJiYgcG9zPy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLl91cGRhdGVTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzIShcbiAgICAgICAgdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKHRoaXMuX3Njcm9sbEludG9WaWV3VGFyZ2V0ISlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgcmFuZ2VjaGFuZ2UgZXZlbnQgd2l0aCB0aGUgY3VycmVudCBmaXJzdCwgbGFzdCwgZmlyc3RWaXNpYmxlLCBhbmRcbiAgICogbGFzdFZpc2libGUuXG4gICAqL1xuICBwcml2YXRlIF9ub3RpZnlSYW5nZSgpIHtcbiAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBSYW5nZUNoYW5nZWRFdmVudCh7Zmlyc3Q6IHRoaXMuX2ZpcnN0LCBsYXN0OiB0aGlzLl9sYXN0fSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfbm90aWZ5VmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KHtcbiAgICAgICAgZmlyc3Q6IHRoaXMuX2ZpcnN0VmlzaWJsZSxcbiAgICAgICAgbGFzdDogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGxheW91dENvbXBsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIExhemlseSBjcmVhdGUgcHJvbWlzZVxuICAgIGlmICghdGhpcy5fbGF5b3V0Q29tcGxldGVQcm9taXNlKSB7XG4gICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlamVjdGVyID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UhO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVqZWN0TGF5b3V0Q29tcGxldGVQcm9taXNlKHJlYXNvbjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIhKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0Q29tcGxldGVTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2NoZWR1bGVMYXlvdXRDb21wbGV0ZSgpIHtcbiAgICAvLyBEb24ndCBkbyBhbnl0aGluZyB1bmxlc3Mgd2UgaGF2ZSBhIHBlbmRpbmcgcHJvbWlzZVxuICAgIC8vIEFuZCBvbmx5IHJlcXVlc3QgYSBmcmFtZSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSBzb1xuICAgIGlmICh0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UgJiYgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID09PSBudWxsKSB7XG4gICAgICAvLyBXYWl0IG9uZSBhZGRpdGlvbmFsIGZyYW1lIHRvIGJlIHN1cmUgdGhlIGxheW91dCBpcyBzdGFibGVcbiAgICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRDb21wbGV0ZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fcmVzb2x2ZUxheW91dENvbXBsZXRlUHJvbWlzZSgpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9yZXNvbHZlTGF5b3V0Q29tcGxldGVQcm9taXNlKCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0Q29tcGxldGVTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVzZXRMYXlvdXRDb21wbGV0ZVN0YXRlKCkge1xuICAgIHRoaXMuX2xheW91dENvbXBsZXRlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZXNvbHZlciA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZWplY3RlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYW5kIHVwZGF0ZSB0aGUgdmlldyBhdCB0aGUgbmV4dCBvcHBvcnR1bml0eSB3aXRoIHRoZSBnaXZlblxuICAgKiBob3N0RWxlbWVudCBzaXplLlxuICAgKi9cbiAgcHJpdmF0ZSBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICB9XG5cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFJldGhpbmsgaG93IHRoaXMgd29ya3MuIFByb2JhYmx5IGNoaWxkIGxvYWRpbmcgaXMgdG9vIHNwZWNpZmljXG4gIC8vIHRvIGhhdmUgZGVkaWNhdGVkIHN1cHBvcnQgZm9yOyBtaWdodCB3YW50IHNvbWUgbW9yZSBnZW5lcmljIGxpZmVjeWNsZSBob29rcyBmb3JcbiAgLy8gbGF5b3V0cyB0byB1c2UuIFBvc3NpYmx5IGhhbmRsZSBtZWFzdXJlbWVudCB0aGlzIHdheSwgdG9vLCBvciBtYXliZSB0aGF0IHJlbWFpbnNcbiAgLy8gYSBmaXJzdC1jbGFzcyBmZWF0dXJlP1xuXG4gIHByaXZhdGUgX2NoaWxkTG9hZGVkKCkge31cblxuICAvLyBUaGlzIGlzIHRoZSBjYWxsYmFjayBmb3IgdGhlIFJlc2l6ZU9ic2VydmVyIHRoYXQgd2F0Y2hlcyB0aGVcbiAgLy8gdmlydHVhbGl6ZXIncyBjaGlsZHJlbi4gV2UgbGFuZCBoZXJlIGF0IHRoZSBlbmQgb2YgZXZlcnkgdmlydHVhbGl6ZXJcbiAgLy8gdXBkYXRlIGN5Y2xlIHRoYXQgcmVzdWx0cyBpbiBjaGFuZ2VzIHRvIHBoeXNpY2FsIGl0ZW1zLCBhbmQgd2UgYWxzb1xuICAvLyBlbmQgdXAgaGVyZSBpZiBvbmUgb3IgbW9yZSBjaGlsZHJlbiBjaGFuZ2Ugc2l6ZSBpbmRlcGVuZGVudGx5IG9mXG4gIC8vIHRoZSB2aXJ0dWFsaXplciB1cGRhdGUgY3ljbGUuXG4gIHByaXZhdGUgX2NoaWxkcmVuU2l6ZUNoYW5nZWQoY2hhbmdlczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gICAgLy8gT25seSBtZWFzdXJlIGlmIHRoZSBsYXlvdXQgcmVxdWlyZXMgaXRcbiAgICBpZiAodGhpcy5fbGF5b3V0Py5tZWFzdXJlQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fdG9CZU1lYXN1cmVkLnNldChcbiAgICAgICAgICBjaGFuZ2UudGFyZ2V0IGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgIGNoYW5nZS5jb250ZW50UmVjdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGVuZCBvZiBhbiB1cGRhdGUgY3ljbGUsIHdlIG5lZWQgdG8gcmVzZXQgc29tZVxuICAgIC8vIGludGVybmFsIHN0YXRlLiBUaGlzIHNob3VsZCBiZSBhIGhhcm1sZXNzIG5vLW9wIGlmIHdlJ3JlIGhhbmRsaW5nXG4gICAgLy8gYW4gb3V0LW9mLWN5Y2xlIFJlc2l6ZU9ic2VydmVyIGNhbGxiYWNrLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvIGNhc2VzLlxuICAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0Q29tcGxldGUoKTtcbiAgICB0aGlzLl9pdGVtc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGVsOiBFbGVtZW50KTogTWFyZ2lucyB7XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICByZXR1cm4ge1xuICAgIG1hcmdpblRvcDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luVG9wKSxcbiAgICBtYXJnaW5SaWdodDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luUmlnaHQpLFxuICAgIG1hcmdpbkJvdHRvbTogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luQm90dG9tKSxcbiAgICBtYXJnaW5MZWZ0OiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5MZWZ0KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFyZ2luVmFsdWUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGZsb2F0ID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IE5hTjtcbiAgcmV0dXJuIE51bWJlci5pc05hTihmbG9hdCkgPyAwIDogZmxvYXQ7XG59XG5cbi8vIFRPRE8gKGdyYXlub3J0b24pOiBEZWFsIHdpdGggaWZyYW1lcz9cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQoZWw6IEVsZW1lbnQpIHtcbiAgaWYgKGVsLmFzc2lnbmVkU2xvdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBlbC5hc3NpZ25lZFNsb3Q7XG4gIH1cbiAgaWYgKGVsLnBhcmVudEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIChwYXJlbnROb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8vXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRBbmNlc3RvcnMoZWw6IEhUTUxFbGVtZW50LCBpbmNsdWRlU2VsZiA9IGZhbHNlKSB7XG4gIGNvbnN0IGFuY2VzdG9yczogQXJyYXk8SFRNTEVsZW1lbnQ+ID0gW107XG4gIGxldCBwYXJlbnQgPSBpbmNsdWRlU2VsZiA/IGVsIDogKGdldFBhcmVudEVsZW1lbnQoZWwpIGFzIEhUTUxFbGVtZW50KTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50RWxlbWVudChwYXJlbnQpIGFzIEhUTUxFbGVtZW50O1xuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nQW5jZXN0b3JzKGVsOiBIVE1MRWxlbWVudCwgaW5jbHVkZVNlbGYgPSBmYWxzZSkge1xuICByZXR1cm4gZ2V0RWxlbWVudEFuY2VzdG9ycyhlbCwgaW5jbHVkZVNlbGYpLmZpbHRlcihcbiAgICAoYSkgPT4gZ2V0Q29tcHV0ZWRTdHlsZShhKS5vdmVyZmxvdyAhPT0gJ3Zpc2libGUnXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/Virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/events.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/events.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeChangedEvent: function() { return /* binding */ RangeChangedEvent; },\n/* harmony export */   UnpinnedEvent: function() { return /* binding */ UnpinnedEvent; },\n/* harmony export */   VisibilityChangedEvent: function() { return /* binding */ VisibilityChangedEvent; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_createSuper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createSuper */ \"./node_modules/@babel/runtime/helpers/esm/createSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n\n\n\n\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar RangeChangedEvent = /*#__PURE__*/function (_Event) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(RangeChangedEvent, _Event);\n  var _super = (0,_babel_runtime_helpers_createSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(RangeChangedEvent);\n  function RangeChangedEvent(range) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, RangeChangedEvent);\n    _this = _super.call(this, RangeChangedEvent.eventName, {\n      bubbles: false\n    });\n    _this.first = range.first;\n    _this.last = range.last;\n    return _this;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(RangeChangedEvent);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Event));\nRangeChangedEvent.eventName = 'rangeChanged';\nvar VisibilityChangedEvent = /*#__PURE__*/function (_Event2) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(VisibilityChangedEvent, _Event2);\n  var _super2 = (0,_babel_runtime_helpers_createSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(VisibilityChangedEvent);\n  function VisibilityChangedEvent(range) {\n    var _this2;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, VisibilityChangedEvent);\n    _this2 = _super2.call(this, VisibilityChangedEvent.eventName, {\n      bubbles: false\n    });\n    _this2.first = range.first;\n    _this2.last = range.last;\n    return _this2;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(VisibilityChangedEvent);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Event));\nVisibilityChangedEvent.eventName = 'visibilityChanged';\nvar UnpinnedEvent = /*#__PURE__*/function (_Event3) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(UnpinnedEvent, _Event3);\n  var _super3 = (0,_babel_runtime_helpers_createSuper__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(UnpinnedEvent);\n  function UnpinnedEvent() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, UnpinnedEvent);\n    return _super3.call(this, UnpinnedEvent.eventName, {\n      bubbles: false\n    });\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(UnpinnedEvent);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Event));\nUnpinnedEvent.eventName = 'unpinned';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0FBTUE7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBVEE7QUFZQTtBQUFBO0FBQUE7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFUQTtBQVlBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFKQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudHMudHM/MzE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJhbmdlQ2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBzdGF0aWMgZXZlbnROYW1lID0gJ3JhbmdlQ2hhbmdlZCc7XG5cbiAgZmlyc3Q6IG51bWJlcjtcbiAgbGFzdDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJhbmdlOiBSYW5nZSkge1xuICAgIHN1cGVyKFJhbmdlQ2hhbmdlZEV2ZW50LmV2ZW50TmFtZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndmlzaWJpbGl0eUNoYW5nZWQnO1xuXG4gIGZpcnN0OiBudW1iZXI7XG4gIGxhc3Q6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihyYW5nZTogUmFuZ2UpIHtcbiAgICBzdXBlcihWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50LmV2ZW50TmFtZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVucGlubmVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndW5waW5uZWQnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFVucGlubmVkRXZlbnQuZXZlbnROYW1lLCB7YnViYmxlczogZmFsc2V9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmFuZ2Uge1xuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/events.js\n");

/***/ })

}]);