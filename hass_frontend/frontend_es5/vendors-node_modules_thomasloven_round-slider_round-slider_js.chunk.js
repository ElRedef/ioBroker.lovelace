"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_thomasloven_round-slider_round-slider_js"],{

/***/ "./node_modules/@thomasloven/round-slider/round-slider.js":
/*!****************************************************************!*\
  !*** ./node_modules/@thomasloven/round-slider/round-slider.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RoundSlider\": function() { return /* binding */ RoundSlider; }\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit/decorators.js */ \"./node_modules/lit/decorators.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6;\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\nvar RoundSlider = /*#__PURE__*/function (_LitElement) {\n  _inherits(RoundSlider, _LitElement);\n\n  var _super = _createSuper(RoundSlider);\n\n  function RoundSlider() {\n    var _this;\n\n    _classCallCheck(this, RoundSlider);\n\n    _this = _super.call(this);\n    _this.min = 0;\n    _this.max = 100;\n    _this.step = 1;\n    _this.startAngle = 135;\n    _this.arcLength = 270;\n    _this.handleSize = 6;\n    _this.handleZoom = 1.5;\n    _this.readonly = false;\n    _this.disabled = false;\n    _this.dragging = false;\n    _this.rtl = false;\n    _this._scale = 1;\n    _this.dragEnd = _this.dragEnd.bind(_assertThisInitialized(_this));\n    _this.drag = _this.drag.bind(_assertThisInitialized(_this));\n    _this._keyStep = _this._keyStep.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(RoundSlider, [{\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      _get(_getPrototypeOf(RoundSlider.prototype), \"connectedCallback\", this).call(this);\n\n      document.addEventListener(\"mouseup\", this.dragEnd);\n      document.addEventListener(\"touchend\", this.dragEnd, {\n        passive: false\n      });\n      document.addEventListener(\"mousemove\", this.drag);\n      document.addEventListener(\"touchmove\", this.drag, {\n        passive: false\n      });\n      document.addEventListener(\"keydown\", this._keyStep);\n    }\n  }, {\n    key: \"disconnectedCallback\",\n    value: function disconnectedCallback() {\n      _get(_getPrototypeOf(RoundSlider.prototype), \"disconnectedCallback\", this).call(this);\n\n      document.removeEventListener(\"mouseup\", this.dragEnd);\n      document.removeEventListener(\"touchend\", this.dragEnd);\n      document.removeEventListener(\"mousemove\", this.drag);\n      document.removeEventListener(\"touchmove\", this.drag);\n      document.removeEventListener(\"keydown\", this._keyStep);\n    }\n  }, {\n    key: \"_start\",\n    get: function get() {\n      return this.startAngle * Math.PI / 180;\n    }\n  }, {\n    key: \"_len\",\n    get: function get() {\n      // Things get weird if length is more than a complete turn\n      return Math.min(this.arcLength * Math.PI / 180, 2 * Math.PI - 0.01);\n    }\n  }, {\n    key: \"_end\",\n    get: function get() {\n      return this._start + this._len;\n    }\n  }, {\n    key: \"_showHandle\",\n    get: function get() {\n      // If handle is shown\n      if (this.readonly) return false;\n      if (this.value == null && (this.high == null || this.low == null)) return false;\n      return true;\n    }\n  }, {\n    key: \"_angleInside\",\n    value: function _angleInside(angle) {\n      // Check if an angle is on the arc\n      var a = (this.startAngle + this.arcLength / 2 - angle + 180 + 360) % 360 - 180;\n      return a < this.arcLength / 2 && a > -this.arcLength / 2;\n    }\n  }, {\n    key: \"_angle2xy\",\n    value: function _angle2xy(angle) {\n      if (this.rtl) return {\n        x: -Math.cos(angle),\n        y: Math.sin(angle)\n      };\n      return {\n        x: Math.cos(angle),\n        y: Math.sin(angle)\n      };\n    }\n  }, {\n    key: \"_xy2angle\",\n    value: function _xy2angle(x, y) {\n      if (this.rtl) x = -x;\n      return (Math.atan2(y, x) - this._start + 2 * Math.PI) % (2 * Math.PI);\n    }\n  }, {\n    key: \"_value2angle\",\n    value: function _value2angle(value) {\n      value = Math.min(this.max, Math.max(this.min, value));\n      var fraction = (value - this.min) / (this.max - this.min);\n      return this._start + fraction * this._len;\n    }\n  }, {\n    key: \"_angle2value\",\n    value: function _angle2value(angle) {\n      return Math.round((angle / this._len * (this.max - this.min) + this.min) / this.step) * this.step;\n    }\n  }, {\n    key: \"_boundaries\",\n    get: function get() {\n      // Get the maximum extents of the bar arc\n      var start = this._angle2xy(this._start);\n\n      var end = this._angle2xy(this._end);\n\n      var up = 1;\n      if (!this._angleInside(270)) up = Math.max(-start.y, -end.y);\n      var down = 1;\n      if (!this._angleInside(90)) down = Math.max(start.y, end.y);\n      var left = 1;\n      if (!this._angleInside(180)) left = Math.max(-start.x, -end.x);\n      var right = 1;\n      if (!this._angleInside(0)) right = Math.max(start.x, end.x);\n      return {\n        up: up,\n        down: down,\n        left: left,\n        right: right,\n        height: up + down,\n        width: left + right\n      };\n    }\n  }, {\n    key: \"_mouse2value\",\n    value: function _mouse2value(ev) {\n      var mouseX = ev.type.startsWith(\"touch\") ? ev.touches[0].clientX : ev.clientX;\n      var mouseY = ev.type.startsWith(\"touch\") ? ev.touches[0].clientY : ev.clientY;\n      var rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n      var boundaries = this._boundaries;\n      var x = mouseX - (rect.left + boundaries.left * rect.width / boundaries.width);\n      var y = mouseY - (rect.top + boundaries.up * rect.height / boundaries.height);\n\n      var angle = this._xy2angle(x, y);\n\n      var pos = this._angle2value(angle);\n\n      return pos;\n    }\n  }, {\n    key: \"dragStart\",\n    value: function dragStart(ev) {\n      var _this2 = this;\n\n      if (!this._showHandle || this.disabled) return;\n      var handle = ev.target;\n      var cooldown = undefined; // Avoid double events mouseDown->focus\n\n      if (this._rotation && this._rotation.type !== \"focus\") return; // If the bar was touched, find the nearest handle and drag from that\n\n      if (handle.classList.contains(\"shadowpath\")) {\n        if (ev.type === \"touchstart\") cooldown = window.setTimeout(function () {\n          if (_this2._rotation) _this2._rotation.cooldown = undefined;\n        }, 200);\n\n        if (this.low == null) {\n          handle = this.shadowRoot.querySelector(\"#value\");\n        } else {\n          var mouse = this._mouse2value(ev);\n\n          if (Math.abs(mouse - this.low) < Math.abs(mouse - this.high)) {\n            handle = this.shadowRoot.querySelector(\"#low\");\n          } else {\n            handle = this.shadowRoot.querySelector(\"#high\");\n          }\n        }\n      } // If an invisible handle was clicked, switch to the visible counterpart\n\n\n      if (handle.classList.contains(\"overflow\")) handle = handle.nextElementSibling;\n      if (!handle.classList.contains(\"handle\")) return;\n      handle.setAttribute(\"stroke-width\", String(2 * this.handleSize * this.handleZoom * this._scale));\n      var min = handle.id === \"high\" ? this.low : this.min;\n      var max = handle.id === \"low\" ? this.high : this.max;\n      this._rotation = {\n        handle: handle,\n        min: min,\n        max: max,\n        start: this[handle.id],\n        type: ev.type,\n        cooldown: cooldown\n      };\n      this.dragging = true;\n    }\n  }, {\n    key: \"_cleanupRotation\",\n    value: function _cleanupRotation() {\n      var handle = this._rotation.handle;\n      handle.setAttribute(\"stroke-width\", String(2 * this.handleSize * this._scale));\n      this._rotation = undefined;\n      this.dragging = false;\n      handle.blur();\n    }\n  }, {\n    key: \"dragEnd\",\n    value: function dragEnd(_ev) {\n      if (!this._showHandle || this.disabled) return;\n      if (!this._rotation) return;\n      var handle = this._rotation.handle;\n\n      this._cleanupRotation();\n\n      var event = new CustomEvent(\"value-changed\", {\n        detail: _defineProperty({}, handle.id, this[handle.id]),\n        bubbles: true,\n        composed: true\n      });\n      this.dispatchEvent(event); // This makes the low handle render over the high handle if they both are\n      // close to the top end.  Otherwise if would be unclickable, and the high\n      // handle locked by the low.  Calcualtion is done in the dragEnd handler to\n      // avoid \"z fighting\" while dragging.\n\n      if (this.low && this.low >= 0.99 * this.max) this._reverseOrder = true;else this._reverseOrder = false;\n    }\n  }, {\n    key: \"drag\",\n    value: function drag(ev) {\n      if (!this._showHandle || this.disabled) return;\n      if (!this._rotation) return;\n\n      if (this._rotation.cooldown) {\n        window.clearTimeout(this._rotation.cooldown);\n\n        this._cleanupRotation();\n\n        return;\n      }\n\n      if (this._rotation.type === \"focus\") return;\n      ev.preventDefault();\n\n      var pos = this._mouse2value(ev);\n\n      this._dragpos(pos);\n    }\n  }, {\n    key: \"_dragpos\",\n    value: function _dragpos(pos) {\n      if (pos < this._rotation.min || pos > this._rotation.max) return;\n      var handle = this._rotation.handle;\n      this[handle.id] = pos;\n      var event = new CustomEvent(\"value-changing\", {\n        detail: _defineProperty({}, handle.id, pos),\n        bubbles: true,\n        composed: true\n      });\n      this.dispatchEvent(event);\n    }\n  }, {\n    key: \"_keyStep\",\n    value: function _keyStep(ev) {\n      if (!this._showHandle || this.disabled) return;\n      if (!this._rotation) return;\n      var handle = this._rotation.handle;\n\n      if (ev.key === \"ArrowLeft\" || ev.key === \"ArrowDown\") {\n        ev.preventDefault();\n        if (this.rtl) this._dragpos(this[handle.id] + this.step);else this._dragpos(this[handle.id] - this.step);\n      }\n\n      if (ev.key === \"ArrowRight\" || ev.key === \"ArrowUp\") {\n        ev.preventDefault();\n        if (this.rtl) this._dragpos(this[handle.id] - this.step);else this._dragpos(this[handle.id] + this.step);\n      }\n\n      if (ev.key === \"Home\") {\n        ev.preventDefault();\n\n        this._dragpos(this.min);\n      }\n\n      if (ev.key === \"End\") {\n        ev.preventDefault();\n\n        this._dragpos(this.max);\n      }\n    }\n  }, {\n    key: \"updated\",\n    value: function updated(changedProperties) {\n      var _this3 = this;\n\n      // Adjust margin in the bar slider stroke width is greater than the handle size\n      if (this.shadowRoot.querySelector(\".slider\")) {\n        var styles = window.getComputedStyle(this.shadowRoot.querySelector(\".slider\"));\n\n        if (styles && styles[\"strokeWidth\"]) {\n          var stroke = parseFloat(styles[\"strokeWidth\"]);\n\n          if (stroke > this.handleSize * this.handleZoom) {\n            var view = this._boundaries;\n            var margin = \"\\n          \".concat(stroke / 2 * Math.abs(view.up), \"px\\n          \").concat(stroke / 2 * Math.abs(view.right), \"px\\n          \").concat(stroke / 2 * Math.abs(view.down), \"px\\n          \").concat(stroke / 2 * Math.abs(view.left), \"px\");\n            this.shadowRoot.querySelector(\"svg\").style.margin = margin;\n          }\n        }\n      } // Workaround for vector-effect not working in IE and pre-Chromium Edge\n      // That's also why the _scale property exists\n\n\n      if (this.shadowRoot.querySelector(\"svg\") && // @ts-expect-error\n      this.shadowRoot.querySelector(\"svg\").style.vectorEffect === undefined) {\n        if (changedProperties.has(\"_scale\") && this._scale != 1) {\n          this.shadowRoot.querySelector(\"svg\").querySelectorAll(\"path\").forEach(function (e) {\n            if (e.getAttribute(\"stroke-width\")) return;\n            var orig = parseFloat(getComputedStyle(e).getPropertyValue(\"stroke-width\"));\n            e.style.strokeWidth = \"\".concat(orig * _this3._scale, \"px\");\n          });\n        }\n\n        var rect = this.shadowRoot.querySelector(\"svg\").getBoundingClientRect();\n        var scale = Math.max(rect.width, rect.height);\n        this._scale = 2 / scale;\n      }\n    }\n  }, {\n    key: \"_renderArc\",\n    value: function _renderArc(start, end) {\n      var diff = end - start;\n\n      var startXY = this._angle2xy(start);\n\n      var endXY = this._angle2xy(end + 0.001); // Safari doesn't like arcs with no length\n\n\n      return \"\\n      M \".concat(startXY.x, \" \").concat(startXY.y, \"\\n      A 1 1,\\n        0,\\n        \").concat(diff > Math.PI ? \"1\" : \"0\", \" \").concat(this.rtl ? \"0\" : \"1\", \",\\n        \").concat(endXY.x, \" \").concat(endXY.y, \"\\n    \");\n    }\n  }, {\n    key: \"_renderHandle\",\n    value: function _renderHandle(id) {\n      var theta = this._value2angle(this[id]);\n\n      var pos = this._angle2xy(theta);\n\n      var label = {\n        value: this.valueLabel,\n        low: this.lowLabel,\n        high: this.highLabel\n      }[id] || \"\"; // Two handles are drawn. One visible, and one invisible that's twice as\n      // big. Makes it easier to click.\n\n      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.svg)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      <g class=\\\"\", \" handle\\\">\\n        <path\\n          id=\", \"\\n          class=\\\"overflow\\\"\\n          d=\\\"\\n          M \", \" \", \"\\n          L \", \" \", \"\\n          \\\"\\n          vector-effect=\\\"non-scaling-stroke\\\"\\n          stroke=\\\"rgba(0,0,0,0)\\\"\\n          stroke-width=\\\"\", \"\\\"\\n          />\\n        <path\\n          id=\", \"\\n          class=\\\"handle\\\"\\n          d=\\\"\\n          M \", \" \", \"\\n          L \", \" \", \"\\n          \\\"\\n          vector-effect=\\\"non-scaling-stroke\\\"\\n          stroke-width=\\\"\", \"\\\"\\n          tabindex=\\\"0\\\"\\n          @focus=\", \"\\n          @blur=\", \"\\n          role=\\\"slider\\\"\\n          aria-valuemin=\", \"\\n          aria-valuemax=\", \"\\n          aria-valuenow=\", \"\\n          aria-disabled=\", \"\\n          aria-label=\", \"\\n          />\\n        </g>\\n      \"])), id, id, pos.x, pos.y, pos.x + 0.001, pos.y + 0.001, 4 * this.handleSize * this._scale, id, pos.x, pos.y, pos.x + 0.001, pos.y + 0.001, 2 * this.handleSize * this._scale, this.dragStart, this.dragEnd, this.min, this.max, this[id], this.disabled, label || \"\");\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var view = this._boundaries;\n      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n      <svg\\n        @mousedown=\", \"\\n        @touchstart=\", \"\\n        xmln=\\\"http://www.w3.org/2000/svg\\\"\\n        viewBox=\\\"\", \" \", \" \", \" \", \"\\\"\\n        style=\\\"margin: \", \"px;\\\"\\n        ?disabled=\", \"\\n        focusable=\\\"false\\\"\\n      >\\n        <g class=\\\"slider\\\">\\n          <path\\n            class=\\\"path\\\"\\n            d=\", \"\\n            vector-effect=\\\"non-scaling-stroke\\\"\\n          />\\n          <path\\n            class=\\\"bar\\\"\\n            vector-effect=\\\"non-scaling-stroke\\\"\\n            d=\", \"\\n          />\\n          <path\\n            class=\\\"shadowpath\\\"\\n            d=\", \"\\n            vector-effect=\\\"non-scaling-stroke\\\"\\n            stroke=\\\"rgba(0,0,0,0)\\\"\\n            stroke-width=\\\"\", \"\\\"\\n            stroke-linecap=\\\"butt\\\"\\n          />\\n        </g>\\n\\n        <g class=\\\"handles\\\">\\n          \", \"\\n        </g>\\n      </svg>\\n    \"])), this.dragStart, this.dragStart, -view.left, -view.up, view.width, view.height, this.handleSize * this.handleZoom, this.disabled, this._renderArc(this._start, this._end), this._renderArc(this._value2angle(this.low != null ? this.low : this.min), this._value2angle(this.high != null ? this.high : this.value)), this._renderArc(this._start, this._end), 3 * this.handleSize * this._scale, this._showHandle ? this.low != null ? this._reverseOrder ? (0,lit__WEBPACK_IMPORTED_MODULE_0__.svg)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" \", \"\"])), this._renderHandle(\"high\"), this._renderHandle(\"low\")) : (0,lit__WEBPACK_IMPORTED_MODULE_0__.svg)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" \", \"\"])), this._renderHandle(\"low\"), this._renderHandle(\"high\")) : (0,lit__WEBPACK_IMPORTED_MODULE_0__.svg)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \"\"])), this._renderHandle(\"value\")) : \"\");\n    }\n  }], [{\n    key: \"styles\",\n    get: function get() {\n      return (0,lit__WEBPACK_IMPORTED_MODULE_0__.css)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\\n      :host {\\n        display: inline-block;\\n        width: 100%;\\n      }\\n      svg {\\n        overflow: visible;\\n        display: block;\\n      }\\n      path {\\n        transition: stroke 1s ease-out, stroke-width 200ms ease-out;\\n      }\\n      .slider {\\n        fill: none;\\n        stroke-width: var(--round-slider-path-width, 3);\\n        stroke-linecap: var(--round-slider-linecap, round);\\n      }\\n      .path {\\n        stroke: var(--round-slider-path-color, lightgray);\\n      }\\n      .bar {\\n        stroke: var(--round-slider-bar-color, deepskyblue);\\n      }\\n      svg[disabled] .bar {\\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\\n      }\\n      g.handles {\\n        stroke: var(\\n          --round-slider-handle-color,\\n          var(--round-slider-bar-color, deepskyblue)\\n        );\\n        stroke-linecap: round;\\n        cursor: var(--round-slider-handle-cursor, pointer);\\n      }\\n      g.low.handle {\\n        stroke: var(--round-slider-low-handle-color);\\n      }\\n      g.high.handle {\\n        stroke: var(--round-slider-high-handle-color);\\n      }\\n      svg[disabled] g.handles {\\n        stroke: var(--round-slider-disabled-bar-color, darkgray);\\n      }\\n      .handle:focus {\\n        outline: unset;\\n      }\\n    \"])));\n    }\n  }]);\n\n  return RoundSlider;\n}(lit__WEBPACK_IMPORTED_MODULE_0__.LitElement);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"value\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"high\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"low\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"min\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"max\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"step\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"startAngle\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"arcLength\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"handleSize\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Number\n})], RoundSlider.prototype, \"handleZoom\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean\n})], RoundSlider.prototype, \"readonly\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean\n})], RoundSlider.prototype, \"disabled\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean,\n  reflect: true\n})], RoundSlider.prototype, \"dragging\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)({\n  type: Boolean\n})], RoundSlider.prototype, \"rtl\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()], RoundSlider.prototype, \"valueLabel\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()], RoundSlider.prototype, \"lowLabel\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.property)()], RoundSlider.prototype, \"highLabel\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_2__.__decorate)([(0,lit_decorators_js__WEBPACK_IMPORTED_MODULE_1__.state)()], RoundSlider.prototype, \"_scale\", void 0);\n\ncustomElements.define(\"round-slider\", RoundSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRob21hc2xvdmVuL3JvdW5kLXNsaWRlci9yb3VuZC1zbGlkZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBaUJBOztBQWxCQTtBQUFBO0FBQUE7QUFvQkE7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUE5QkE7QUFBQTtBQUFBO0FBZ0NBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRDQTtBQUFBO0FBQUE7QUF3Q0E7QUFDQTtBQXpDQTtBQUFBO0FBQUE7QUEyQ0E7QUFDQTtBQUNBO0FBN0NBO0FBQUE7QUFBQTtBQStDQTtBQUNBO0FBaERBO0FBQUE7QUFBQTtBQWtEQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBeERBO0FBQUE7QUFBQTtBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQTdEQTtBQUFBO0FBQUE7QUErREE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBbEVBO0FBQUE7QUFBQTtBQW9FQTtBQUVBO0FBQ0E7QUF2RUE7QUFBQTtBQUFBO0FBeUVBO0FBQ0E7QUFDQTtBQUNBO0FBNUVBO0FBQUE7QUFBQTtBQThFQTtBQUNBO0FBL0VBO0FBQUE7QUFBQTtBQWlGQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUF4R0E7QUFBQTtBQUFBO0FBMEdBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBdkhBO0FBQUE7QUFBQTtBQXdIQTs7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQXJLQTtBQUFBO0FBQUE7QUF1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUtBO0FBQUE7QUFBQTtBQThLQTtBQUVBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBSUE7QUFwTUE7QUFBQTtBQUFBO0FBc01BO0FBRUE7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQXBOQTtBQUFBO0FBQUE7QUFzTkE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFsT0E7QUFBQTtBQUFBO0FBb09BO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUEvUEE7QUFBQTtBQUFBO0FBZ1FBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBclNBO0FBQUE7QUFBQTtBQXVTQTs7QUFDQTs7QUFDQTs7O0FBQ0E7QUFPQTtBQWpUQTtBQUFBO0FBQUE7QUFtVEE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BOztBQUNBO0FBa0NBO0FBOVZBO0FBQUE7QUFBQTtBQWdXQTtBQUNBO0FBMENBO0FBM1lBO0FBQUE7QUFBQTtBQTZZQTtBQStDQTtBQTViQTs7QUFBQTtBQUFBOztBQThiQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7QUFDQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQUE7O0FBRUE7O0FBR0E7O0FBR0E7O0FBR0E7O0FBR0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGhvbWFzbG92ZW4vcm91bmQtc2xpZGVyL3JvdW5kLXNsaWRlci5qcz9lOGI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fZGVjb3JhdGUgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwsIGNzcywgc3ZnLCB9IGZyb20gXCJsaXRcIjtcbmltcG9ydCB7IHByb3BlcnR5LCBzdGF0ZSB9IGZyb20gXCJsaXQvZGVjb3JhdG9ycy5qc1wiO1xuZXhwb3J0IGNsYXNzIFJvdW5kU2xpZGVyIGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWluID0gMDtcbiAgICAgICAgdGhpcy5tYXggPSAxMDA7XG4gICAgICAgIHRoaXMuc3RlcCA9IDE7XG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IDEzNTtcbiAgICAgICAgdGhpcy5hcmNMZW5ndGggPSAyNzA7XG4gICAgICAgIHRoaXMuaGFuZGxlU2l6ZSA9IDY7XG4gICAgICAgIHRoaXMuaGFuZGxlWm9vbSA9IDEuNTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ydGwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2NhbGUgPSAxO1xuICAgICAgICB0aGlzLmRyYWdFbmQgPSB0aGlzLmRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kcmFnID0gdGhpcy5kcmFnLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2tleVN0ZXAgPSB0aGlzLl9rZXlTdGVwLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmRyYWdFbmQpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5kcmFnRW5kLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5kcmFnKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmRyYWcsIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fa2V5U3RlcCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmRyYWdFbmQpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5kcmFnRW5kKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLmRyYWcpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuZHJhZyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuX2tleVN0ZXApO1xuICAgIH1cbiAgICBnZXQgX3N0YXJ0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc3RhcnRBbmdsZSAqIE1hdGguUEkpIC8gMTgwO1xuICAgIH1cbiAgICBnZXQgX2xlbigpIHtcbiAgICAgICAgLy8gVGhpbmdzIGdldCB3ZWlyZCBpZiBsZW5ndGggaXMgbW9yZSB0aGFuIGEgY29tcGxldGUgdHVyblxuICAgICAgICByZXR1cm4gTWF0aC5taW4oKHRoaXMuYXJjTGVuZ3RoICogTWF0aC5QSSkgLyAxODAsIDIgKiBNYXRoLlBJIC0gMC4wMSk7XG4gICAgfVxuICAgIGdldCBfZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyB0aGlzLl9sZW47XG4gICAgfVxuICAgIGdldCBfc2hvd0hhbmRsZSgpIHtcbiAgICAgICAgLy8gSWYgaGFuZGxlIGlzIHNob3duXG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PSBudWxsICYmICh0aGlzLmhpZ2ggPT0gbnVsbCB8fCB0aGlzLmxvdyA9PSBudWxsKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9hbmdsZUluc2lkZShhbmdsZSkge1xuICAgICAgICAvLyBDaGVjayBpZiBhbiBhbmdsZSBpcyBvbiB0aGUgYXJjXG4gICAgICAgIGxldCBhID0gKCh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmFyY0xlbmd0aCAvIDIgLSBhbmdsZSArIDE4MCArIDM2MCkgJSAzNjApIC0gMTgwO1xuICAgICAgICByZXR1cm4gYSA8IHRoaXMuYXJjTGVuZ3RoIC8gMiAmJiBhID4gLXRoaXMuYXJjTGVuZ3RoIC8gMjtcbiAgICB9XG4gICAgX2FuZ2xlMnh5KGFuZ2xlKSB7XG4gICAgICAgIGlmICh0aGlzLnJ0bClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IC1NYXRoLmNvcyhhbmdsZSksIHk6IE1hdGguc2luKGFuZ2xlKSB9O1xuICAgICAgICByZXR1cm4geyB4OiBNYXRoLmNvcyhhbmdsZSksIHk6IE1hdGguc2luKGFuZ2xlKSB9O1xuICAgIH1cbiAgICBfeHkyYW5nbGUoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5ydGwpXG4gICAgICAgICAgICB4ID0gLXg7XG4gICAgICAgIHJldHVybiAoTWF0aC5hdGFuMih5LCB4KSAtIHRoaXMuX3N0YXJ0ICsgMiAqIE1hdGguUEkpICUgKDIgKiBNYXRoLlBJKTtcbiAgICB9XG4gICAgX3ZhbHVlMmFuZ2xlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4odGhpcy5tYXgsIE1hdGgubWF4KHRoaXMubWluLCB2YWx1ZSkpO1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgZnJhY3Rpb24gKiB0aGlzLl9sZW47XG4gICAgfVxuICAgIF9hbmdsZTJ2YWx1ZShhbmdsZSkge1xuICAgICAgICByZXR1cm4gKE1hdGgucm91bmQoKChhbmdsZSAvIHRoaXMuX2xlbikgKiAodGhpcy5tYXggLSB0aGlzLm1pbikgKyB0aGlzLm1pbikgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwKTtcbiAgICB9XG4gICAgZ2V0IF9ib3VuZGFyaWVzKCkge1xuICAgICAgICAvLyBHZXQgdGhlIG1heGltdW0gZXh0ZW50cyBvZiB0aGUgYmFyIGFyY1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2FuZ2xlMnh5KHRoaXMuX3N0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fYW5nbGUyeHkodGhpcy5fZW5kKTtcbiAgICAgICAgbGV0IHVwID0gMTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmdsZUluc2lkZSgyNzApKVxuICAgICAgICAgICAgdXAgPSBNYXRoLm1heCgtc3RhcnQueSwgLWVuZC55KTtcbiAgICAgICAgbGV0IGRvd24gPSAxO1xuICAgICAgICBpZiAoIXRoaXMuX2FuZ2xlSW5zaWRlKDkwKSlcbiAgICAgICAgICAgIGRvd24gPSBNYXRoLm1heChzdGFydC55LCBlbmQueSk7XG4gICAgICAgIGxldCBsZWZ0ID0gMTtcbiAgICAgICAgaWYgKCF0aGlzLl9hbmdsZUluc2lkZSgxODApKVxuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KC1zdGFydC54LCAtZW5kLngpO1xuICAgICAgICBsZXQgcmlnaHQgPSAxO1xuICAgICAgICBpZiAoIXRoaXMuX2FuZ2xlSW5zaWRlKDApKVxuICAgICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChzdGFydC54LCBlbmQueCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cCxcbiAgICAgICAgICAgIGRvd24sXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICBoZWlnaHQ6IHVwICsgZG93bixcbiAgICAgICAgICAgIHdpZHRoOiBsZWZ0ICsgcmlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9tb3VzZTJ2YWx1ZShldikge1xuICAgICAgICBjb25zdCBtb3VzZVggPSBldi50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKVxuICAgICAgICAgICAgPyBldi50b3VjaGVzWzBdLmNsaWVudFhcbiAgICAgICAgICAgIDogZXYuY2xpZW50WDtcbiAgICAgICAgY29uc3QgbW91c2VZID0gZXYudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIilcbiAgICAgICAgICAgID8gZXYudG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICA6IGV2LmNsaWVudFk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgYm91bmRhcmllcyA9IHRoaXMuX2JvdW5kYXJpZXM7XG4gICAgICAgIGNvbnN0IHggPSBtb3VzZVggLSAocmVjdC5sZWZ0ICsgKGJvdW5kYXJpZXMubGVmdCAqIHJlY3Qud2lkdGgpIC8gYm91bmRhcmllcy53aWR0aCk7XG4gICAgICAgIGNvbnN0IHkgPSBtb3VzZVkgLSAocmVjdC50b3AgKyAoYm91bmRhcmllcy51cCAqIHJlY3QuaGVpZ2h0KSAvIGJvdW5kYXJpZXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLl94eTJhbmdsZSh4LCB5KTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fYW5nbGUydmFsdWUoYW5nbGUpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBkcmFnU3RhcnQoZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBoYW5kbGUgPSBldi50YXJnZXQ7XG4gICAgICAgIGxldCBjb29sZG93biA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQXZvaWQgZG91YmxlIGV2ZW50cyBtb3VzZURvd24tPmZvY3VzXG4gICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiAmJiB0aGlzLl9yb3RhdGlvbi50eXBlICE9PSBcImZvY3VzXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIElmIHRoZSBiYXIgd2FzIHRvdWNoZWQsIGZpbmQgdGhlIG5lYXJlc3QgaGFuZGxlIGFuZCBkcmFnIGZyb20gdGhhdFxuICAgICAgICBpZiAoaGFuZGxlLmNsYXNzTGlzdC5jb250YWlucyhcInNoYWRvd3BhdGhcIikpIHtcbiAgICAgICAgICAgIGlmIChldi50eXBlID09PSBcInRvdWNoc3RhcnRcIilcbiAgICAgICAgICAgICAgICBjb29sZG93biA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm90YXRpb24uY29vbGRvd24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZSA9IHRoaXMuX21vdXNlMnZhbHVlKGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobW91c2UgLSB0aGlzLmxvdykgPCBNYXRoLmFicyhtb3VzZSAtIHRoaXMuaGlnaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjbG93XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIjaGlnaFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gaW52aXNpYmxlIGhhbmRsZSB3YXMgY2xpY2tlZCwgc3dpdGNoIHRvIHRoZSB2aXNpYmxlIGNvdW50ZXJwYXJ0XG4gICAgICAgIGlmIChoYW5kbGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwib3ZlcmZsb3dcIikpXG4gICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICBpZiAoIWhhbmRsZS5jbGFzc0xpc3QuY29udGFpbnMoXCJoYW5kbGVcIikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgU3RyaW5nKDIgKiB0aGlzLmhhbmRsZVNpemUgKiB0aGlzLmhhbmRsZVpvb20gKiB0aGlzLl9zY2FsZSkpO1xuICAgICAgICBjb25zdCBtaW4gPSBoYW5kbGUuaWQgPT09IFwiaGlnaFwiID8gdGhpcy5sb3cgOiB0aGlzLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gaGFuZGxlLmlkID09PSBcImxvd1wiID8gdGhpcy5oaWdoIDogdGhpcy5tYXg7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0ge1xuICAgICAgICAgICAgaGFuZGxlLFxuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXNbaGFuZGxlLmlkXSxcbiAgICAgICAgICAgIHR5cGU6IGV2LnR5cGUsXG4gICAgICAgICAgICBjb29sZG93bixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgfVxuICAgIF9jbGVhbnVwUm90YXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX3JvdGF0aW9uLmhhbmRsZTtcbiAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBTdHJpbmcoMiAqIHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuX3NjYWxlKSk7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGhhbmRsZS5ibHVyKCk7XG4gICAgfVxuICAgIGRyYWdFbmQoX2V2KSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX3JvdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9yb3RhdGlvbi5oYW5kbGU7XG4gICAgICAgIHRoaXMuX2NsZWFudXBSb3RhdGlvbigpO1xuICAgICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoXCJ2YWx1ZS1jaGFuZ2VkXCIsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIFtoYW5kbGUuaWRdOiB0aGlzW2hhbmRsZS5pZF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgLy8gVGhpcyBtYWtlcyB0aGUgbG93IGhhbmRsZSByZW5kZXIgb3ZlciB0aGUgaGlnaCBoYW5kbGUgaWYgdGhleSBib3RoIGFyZVxuICAgICAgICAvLyBjbG9zZSB0byB0aGUgdG9wIGVuZC4gIE90aGVyd2lzZSBpZiB3b3VsZCBiZSB1bmNsaWNrYWJsZSwgYW5kIHRoZSBoaWdoXG4gICAgICAgIC8vIGhhbmRsZSBsb2NrZWQgYnkgdGhlIGxvdy4gIENhbGN1YWx0aW9uIGlzIGRvbmUgaW4gdGhlIGRyYWdFbmQgaGFuZGxlciB0b1xuICAgICAgICAvLyBhdm9pZCBcInogZmlnaHRpbmdcIiB3aGlsZSBkcmFnZ2luZy5cbiAgICAgICAgaWYgKHRoaXMubG93ICYmIHRoaXMubG93ID49IDAuOTkgKiB0aGlzLm1heClcbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VPcmRlciA9IHRydWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX3JldmVyc2VPcmRlciA9IGZhbHNlO1xuICAgIH1cbiAgICBkcmFnKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5fc2hvd0hhbmRsZSB8fCB0aGlzLmRpc2FibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMuX3JvdGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24uY29vbGRvd24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fcm90YXRpb24uY29vbGRvd24pO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cFJvdGF0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uLnR5cGUgPT09IFwiZm9jdXNcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fbW91c2UydmFsdWUoZXYpO1xuICAgICAgICB0aGlzLl9kcmFncG9zKHBvcyk7XG4gICAgfVxuICAgIF9kcmFncG9zKHBvcykge1xuICAgICAgICBpZiAocG9zIDwgdGhpcy5fcm90YXRpb24ubWluIHx8IHBvcyA+IHRoaXMuX3JvdGF0aW9uLm1heClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5fcm90YXRpb24uaGFuZGxlO1xuICAgICAgICB0aGlzW2hhbmRsZS5pZF0gPSBwb3M7XG4gICAgICAgIGxldCBldmVudCA9IG5ldyBDdXN0b21FdmVudChcInZhbHVlLWNoYW5naW5nXCIsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIFtoYW5kbGUuaWRdOiBwb3MsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX2tleVN0ZXAoZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93SGFuZGxlIHx8IHRoaXMuZGlzYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5fcm90YXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX3JvdGF0aW9uLmhhbmRsZTtcbiAgICAgICAgaWYgKGV2LmtleSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBldi5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ydGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhZ3Bvcyh0aGlzW2hhbmRsZS5pZF0gKyB0aGlzLnN0ZXApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdwb3ModGhpc1toYW5kbGUuaWRdIC0gdGhpcy5zdGVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYua2V5ID09PSBcIkFycm93UmlnaHRcIiB8fCBldi5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnRsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdwb3ModGhpc1toYW5kbGUuaWRdIC0gdGhpcy5zdGVwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXNbaGFuZGxlLmlkXSArIHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2LmtleSA9PT0gXCJIb21lXCIpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLl9kcmFncG9zKHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYua2V5ID09PSBcIkVuZFwiKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5fZHJhZ3Bvcyh0aGlzLm1heCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlZChjaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICAvLyBBZGp1c3QgbWFyZ2luIGluIHRoZSBiYXIgc2xpZGVyIHN0cm9rZSB3aWR0aCBpcyBncmVhdGVyIHRoYW4gdGhlIGhhbmRsZSBzaXplXG4gICAgICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcIi5zbGlkZXJcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwiLnNsaWRlclwiKSk7XG4gICAgICAgICAgICBpZiAoc3R5bGVzICYmIHN0eWxlc1tcInN0cm9rZVdpZHRoXCJdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Ryb2tlID0gcGFyc2VGbG9hdChzdHlsZXNbXCJzdHJva2VXaWR0aFwiXSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cm9rZSA+IHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuaGFuZGxlWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5fYm91bmRhcmllcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gYFxuICAgICAgICAgICR7KHN0cm9rZSAvIDIpICogTWF0aC5hYnModmlldy51cCl9cHhcbiAgICAgICAgICAkeyhzdHJva2UgLyAyKSAqIE1hdGguYWJzKHZpZXcucmlnaHQpfXB4XG4gICAgICAgICAgJHsoc3Ryb2tlIC8gMikgKiBNYXRoLmFicyh2aWV3LmRvd24pfXB4XG4gICAgICAgICAgJHsoc3Ryb2tlIC8gMikgKiBNYXRoLmFicyh2aWV3LmxlZnQpfXB4YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIikuc3R5bGUubWFyZ2luID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciB2ZWN0b3ItZWZmZWN0IG5vdCB3b3JraW5nIGluIElFIGFuZCBwcmUtQ2hyb21pdW0gRWRnZVxuICAgICAgICAvLyBUaGF0J3MgYWxzbyB3aHkgdGhlIF9zY2FsZSBwcm9wZXJ0eSBleGlzdHNcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpICYmXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInN2Z1wiKS5zdHlsZS52ZWN0b3JFZmZlY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRQcm9wZXJ0aWVzLmhhcyhcIl9zY2FsZVwiKSAmJiB0aGlzLl9zY2FsZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dSb290XG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpXG4gICAgICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5nZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWcgPSBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZSkuZ2V0UHJvcGVydHlWYWx1ZShcInN0cm9rZS13aWR0aFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3R5bGUuc3Ryb2tlV2lkdGggPSBgJHtvcmlnICogdGhpcy5fc2NhbGV9cHhgO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZSA9IDIgLyBzY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVuZGVyQXJjKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICBjb25zdCBzdGFydFhZID0gdGhpcy5fYW5nbGUyeHkoc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRYWSA9IHRoaXMuX2FuZ2xlMnh5KGVuZCArIDAuMDAxKTsgLy8gU2FmYXJpIGRvZXNuJ3QgbGlrZSBhcmNzIHdpdGggbm8gbGVuZ3RoXG4gICAgICAgIHJldHVybiBgXG4gICAgICBNICR7c3RhcnRYWS54fSAke3N0YXJ0WFkueX1cbiAgICAgIEEgMSAxLFxuICAgICAgICAwLFxuICAgICAgICAke2RpZmYgPiBNYXRoLlBJID8gXCIxXCIgOiBcIjBcIn0gJHt0aGlzLnJ0bCA/IFwiMFwiIDogXCIxXCJ9LFxuICAgICAgICAke2VuZFhZLnh9ICR7ZW5kWFkueX1cbiAgICBgO1xuICAgIH1cbiAgICBfcmVuZGVySGFuZGxlKGlkKSB7XG4gICAgICAgIGNvbnN0IHRoZXRhID0gdGhpcy5fdmFsdWUyYW5nbGUodGhpc1tpZF0pO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLl9hbmdsZTJ4eSh0aGV0YSk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVMYWJlbCxcbiAgICAgICAgICAgIGxvdzogdGhpcy5sb3dMYWJlbCxcbiAgICAgICAgICAgIGhpZ2g6IHRoaXMuaGlnaExhYmVsLFxuICAgICAgICB9W2lkXSB8fCBcIlwiO1xuICAgICAgICAvLyBUd28gaGFuZGxlcyBhcmUgZHJhd24uIE9uZSB2aXNpYmxlLCBhbmQgb25lIGludmlzaWJsZSB0aGF0J3MgdHdpY2UgYXNcbiAgICAgICAgLy8gYmlnLiBNYWtlcyBpdCBlYXNpZXIgdG8gY2xpY2suXG4gICAgICAgIHJldHVybiBzdmcgYFxuICAgICAgPGcgY2xhc3M9XCIke2lkfSBoYW5kbGVcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBpZD0ke2lkfVxuICAgICAgICAgIGNsYXNzPVwib3ZlcmZsb3dcIlxuICAgICAgICAgIGQ9XCJcbiAgICAgICAgICBNICR7cG9zLnh9ICR7cG9zLnl9XG4gICAgICAgICAgTCAke3Bvcy54ICsgMC4wMDF9ICR7cG9zLnkgKyAwLjAwMX1cbiAgICAgICAgICBcIlxuICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgIHN0cm9rZT1cInJnYmEoMCwwLDAsMClcIlxuICAgICAgICAgIHN0cm9rZS13aWR0aD1cIiR7NCAqIHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuX3NjYWxlfVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBpZD0ke2lkfVxuICAgICAgICAgIGNsYXNzPVwiaGFuZGxlXCJcbiAgICAgICAgICBkPVwiXG4gICAgICAgICAgTSAke3Bvcy54fSAke3Bvcy55fVxuICAgICAgICAgIEwgJHtwb3MueCArIDAuMDAxfSAke3Bvcy55ICsgMC4wMDF9XG4gICAgICAgICAgXCJcbiAgICAgICAgICB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCJcbiAgICAgICAgICBzdHJva2Utd2lkdGg9XCIkezIgKiB0aGlzLmhhbmRsZVNpemUgKiB0aGlzLl9zY2FsZX1cIlxuICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgQGZvY3VzPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgICAgQGJsdXI9JHt0aGlzLmRyYWdFbmR9XG4gICAgICAgICAgcm9sZT1cInNsaWRlclwiXG4gICAgICAgICAgYXJpYS12YWx1ZW1pbj0ke3RoaXMubWlufVxuICAgICAgICAgIGFyaWEtdmFsdWVtYXg9JHt0aGlzLm1heH1cbiAgICAgICAgICBhcmlhLXZhbHVlbm93PSR7dGhpc1tpZF19XG4gICAgICAgICAgYXJpYS1kaXNhYmxlZD0ke3RoaXMuZGlzYWJsZWR9XG4gICAgICAgICAgYXJpYS1sYWJlbD0ke2xhYmVsIHx8IFwiXCJ9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9nPlxuICAgICAgYDtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5fYm91bmRhcmllcztcbiAgICAgICAgcmV0dXJuIGh0bWwgYFxuICAgICAgPHN2Z1xuICAgICAgICBAbW91c2Vkb3duPSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIEB0b3VjaHN0YXJ0PSR7dGhpcy5kcmFnU3RhcnR9XG4gICAgICAgIHhtbG49XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgIHZpZXdCb3g9XCIkey12aWV3LmxlZnR9ICR7LXZpZXcudXB9ICR7dmlldy53aWR0aH0gJHt2aWV3LmhlaWdodH1cIlxuICAgICAgICBzdHlsZT1cIm1hcmdpbjogJHt0aGlzLmhhbmRsZVNpemUgKiB0aGlzLmhhbmRsZVpvb219cHg7XCJcbiAgICAgICAgP2Rpc2FibGVkPSR7dGhpcy5kaXNhYmxlZH1cbiAgICAgICAgZm9jdXNhYmxlPVwiZmFsc2VcIlxuICAgICAgPlxuICAgICAgICA8ZyBjbGFzcz1cInNsaWRlclwiPlxuICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICBjbGFzcz1cInBhdGhcIlxuICAgICAgICAgICAgZD0ke3RoaXMuX3JlbmRlckFyYyh0aGlzLl9zdGFydCwgdGhpcy5fZW5kKX1cbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwiYmFyXCJcbiAgICAgICAgICAgIHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIlxuICAgICAgICAgICAgZD0ke3RoaXMuX3JlbmRlckFyYyh0aGlzLl92YWx1ZTJhbmdsZSh0aGlzLmxvdyAhPSBudWxsID8gdGhpcy5sb3cgOiB0aGlzLm1pbiksIHRoaXMuX3ZhbHVlMmFuZ2xlKHRoaXMuaGlnaCAhPSBudWxsID8gdGhpcy5oaWdoIDogdGhpcy52YWx1ZSkpfVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwic2hhZG93cGF0aFwiXG4gICAgICAgICAgICBkPSR7dGhpcy5fcmVuZGVyQXJjKHRoaXMuX3N0YXJ0LCB0aGlzLl9lbmQpfVxuICAgICAgICAgICAgdmVjdG9yLWVmZmVjdD1cIm5vbi1zY2FsaW5nLXN0cm9rZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJyZ2JhKDAsMCwwLDApXCJcbiAgICAgICAgICAgIHN0cm9rZS13aWR0aD1cIiR7MyAqIHRoaXMuaGFuZGxlU2l6ZSAqIHRoaXMuX3NjYWxlfVwiXG4gICAgICAgICAgICBzdHJva2UtbGluZWNhcD1cImJ1dHRcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZz5cblxuICAgICAgICA8ZyBjbGFzcz1cImhhbmRsZXNcIj5cbiAgICAgICAgICAke3RoaXMuX3Nob3dIYW5kbGVcbiAgICAgICAgICAgID8gdGhpcy5sb3cgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gdGhpcy5fcmV2ZXJzZU9yZGVyXG4gICAgICAgICAgICAgICAgICAgID8gc3ZnIGAke3RoaXMuX3JlbmRlckhhbmRsZShcImhpZ2hcIil9ICR7dGhpcy5fcmVuZGVySGFuZGxlKFwibG93XCIpfWBcbiAgICAgICAgICAgICAgICAgICAgOiBzdmcgYCR7dGhpcy5fcmVuZGVySGFuZGxlKFwibG93XCIpfSAke3RoaXMuX3JlbmRlckhhbmRsZShcImhpZ2hcIil9YFxuICAgICAgICAgICAgICAgIDogc3ZnIGAke3RoaXMuX3JlbmRlckhhbmRsZShcInZhbHVlXCIpfWBcbiAgICAgICAgICAgIDogYGB9XG4gICAgICAgIDwvZz5cbiAgICAgIDwvc3ZnPlxuICAgIGA7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gY3NzIGBcbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgICAgIHN2ZyB7XG4gICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICAgIHBhdGgge1xuICAgICAgICB0cmFuc2l0aW9uOiBzdHJva2UgMXMgZWFzZS1vdXQsIHN0cm9rZS13aWR0aCAyMDBtcyBlYXNlLW91dDtcbiAgICAgIH1cbiAgICAgIC5zbGlkZXIge1xuICAgICAgICBmaWxsOiBub25lO1xuICAgICAgICBzdHJva2Utd2lkdGg6IHZhcigtLXJvdW5kLXNsaWRlci1wYXRoLXdpZHRoLCAzKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHZhcigtLXJvdW5kLXNsaWRlci1saW5lY2FwLCByb3VuZCk7XG4gICAgICB9XG4gICAgICAucGF0aCB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLXBhdGgtY29sb3IsIGxpZ2h0Z3JheSk7XG4gICAgICB9XG4gICAgICAuYmFyIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItYmFyLWNvbG9yLCBkZWVwc2t5Ymx1ZSk7XG4gICAgICB9XG4gICAgICBzdmdbZGlzYWJsZWRdIC5iYXIge1xuICAgICAgICBzdHJva2U6IHZhcigtLXJvdW5kLXNsaWRlci1kaXNhYmxlZC1iYXItY29sb3IsIGRhcmtncmF5KTtcbiAgICAgIH1cbiAgICAgIGcuaGFuZGxlcyB7XG4gICAgICAgIHN0cm9rZTogdmFyKFxuICAgICAgICAgIC0tcm91bmQtc2xpZGVyLWhhbmRsZS1jb2xvcixcbiAgICAgICAgICB2YXIoLS1yb3VuZC1zbGlkZXItYmFyLWNvbG9yLCBkZWVwc2t5Ymx1ZSlcbiAgICAgICAgKTtcbiAgICAgICAgc3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xuICAgICAgICBjdXJzb3I6IHZhcigtLXJvdW5kLXNsaWRlci1oYW5kbGUtY3Vyc29yLCBwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGcubG93LmhhbmRsZSB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLWxvdy1oYW5kbGUtY29sb3IpO1xuICAgICAgfVxuICAgICAgZy5oaWdoLmhhbmRsZSB7XG4gICAgICAgIHN0cm9rZTogdmFyKC0tcm91bmQtc2xpZGVyLWhpZ2gtaGFuZGxlLWNvbG9yKTtcbiAgICAgIH1cbiAgICAgIHN2Z1tkaXNhYmxlZF0gZy5oYW5kbGVzIHtcbiAgICAgICAgc3Ryb2tlOiB2YXIoLS1yb3VuZC1zbGlkZXItZGlzYWJsZWQtYmFyLWNvbG9yLCBkYXJrZ3JheSk7XG4gICAgICB9XG4gICAgICAuaGFuZGxlOmZvY3VzIHtcbiAgICAgICAgb3V0bGluZTogdW5zZXQ7XG4gICAgICB9XG4gICAgYDtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImhpZ2hcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyIH0pXG5dLCBSb3VuZFNsaWRlci5wcm90b3R5cGUsIFwibG93XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIgfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogTnVtYmVyIH0pXG5dLCBSb3VuZFNsaWRlci5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIgfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImFyY0xlbmd0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBOdW1iZXIgfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJoYW5kbGVTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IE51bWJlciB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImhhbmRsZVpvb21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4gfSlcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuLCByZWZsZWN0OiB0cnVlIH0pXG5dLCBSb3VuZFNsaWRlci5wcm90b3R5cGUsIFwiZHJhZ2dpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInJ0bFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoKVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcInZhbHVlTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHByb3BlcnR5KClcbl0sIFJvdW5kU2xpZGVyLnByb3RvdHlwZSwgXCJsb3dMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcHJvcGVydHkoKVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcImhpZ2hMYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgc3RhdGUoKVxuXSwgUm91bmRTbGlkZXIucHJvdG90eXBlLCBcIl9zY2FsZVwiLCB2b2lkIDApO1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwicm91bmQtc2xpZGVyXCIsIFJvdW5kU2xpZGVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@thomasloven/round-slider/round-slider.js\n");

/***/ })

}]);