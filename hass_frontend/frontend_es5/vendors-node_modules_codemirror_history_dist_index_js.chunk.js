"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_codemirror_history_dist_index_js"],{

/***/ "./node_modules/@codemirror/history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@codemirror/history/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"history\": function() { return /* binding */ history; },\n/* harmony export */   \"historyField\": function() { return /* binding */ historyField; },\n/* harmony export */   \"historyKeymap\": function() { return /* binding */ historyKeymap; },\n/* harmony export */   \"invertedEffects\": function() { return /* binding */ invertedEffects; },\n/* harmony export */   \"isolateHistory\": function() { return /* binding */ isolateHistory; },\n/* harmony export */   \"redo\": function() { return /* binding */ redo; },\n/* harmony export */   \"redoDepth\": function() { return /* binding */ redoDepth; },\n/* harmony export */   \"redoSelection\": function() { return /* binding */ redoSelection; },\n/* harmony export */   \"undo\": function() { return /* binding */ undo; },\n/* harmony export */   \"undoDepth\": function() { return /* binding */ undoDepth; },\n/* harmony export */   \"undoSelection\": function() { return /* binding */ undoSelection; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/view */ \"./node_modules/@codemirror/view/dist/index.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar fromHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Annotation.define();\n/**\nTransaction annotation that will prevent that transaction from\nbeing combined with other transactions in the undo history. Given\n`\"before\"`, it'll prevent merging with previous transactions. With\n`\"after\"`, subsequent transactions won't be combined with this\none. With `\"full\"`, the transaction is isolated on both sides.\n*/\n\nvar isolateHistory = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Annotation.define();\n/**\nThis facet provides a way to register functions that, given a\ntransaction, provide a set of effects that the history should\nstore when inverting the transaction. This can be used to\nintegrate some kinds of effects in the history, so that they can\nbe undone (and redone again).\n*/\n\nvar invertedEffects = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define();\nvar historyConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Facet.define({\n  combine: function combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.combineConfig)(configs, {\n      minDepth: 100,\n      newGroupDelay: 500\n    }, {\n      minDepth: Math.max,\n      newGroupDelay: Math.min\n    });\n  }\n});\n\nfunction changeEnd(changes) {\n  var end = 0;\n  changes.iterChangedRanges(function (_, to) {\n    return end = to;\n  });\n  return end;\n}\n\nvar historyField_ = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateField.define({\n  create: function create() {\n    return HistoryState.empty;\n  },\n  update: function update(state, tr) {\n    var config = tr.state.facet(historyConfig);\n    var fromHist = tr.annotation(fromHistory);\n\n    if (fromHist) {\n      var selection = tr.docChanged ? _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.single(changeEnd(tr.changes)) : undefined;\n      var item = HistEvent.fromTransaction(tr, selection),\n          from = fromHist.side;\n      var other = from == 0\n      /* Done */\n      ? state.undone : state.done;\n      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = _addSelection(other, tr.startState.selection);\n      return new HistoryState(from == 0\n      /* Done */\n      ? fromHist.rest : other, from == 0\n      /* Done */\n      ? other : fromHist.rest);\n    }\n\n    var isolate = tr.annotation(isolateHistory);\n    if (isolate == \"full\" || isolate == \"before\") state = state.isolate();\n    if (tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;\n    var event = HistEvent.fromTransaction(tr);\n    var time = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction.time),\n        userEvent = tr.annotation(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction.userEvent);\n    if (event) state = state.addChanges(event, time, userEvent, config.newGroupDelay, config.minDepth);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);\n    if (isolate == \"full\" || isolate == \"after\") state = state.isolate();\n    return state;\n  },\n  toJSON: function toJSON(value) {\n    return {\n      done: value.done.map(function (e) {\n        return e.toJSON();\n      }),\n      undone: value.undone.map(function (e) {\n        return e.toJSON();\n      })\n    };\n  },\n  fromJSON: function fromJSON(json) {\n    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));\n  }\n});\n/**\nCreate a history extension with the given configuration.\n*/\n\nfunction history() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [historyField_, historyConfig.of(config), _codemirror_view__WEBPACK_IMPORTED_MODULE_1__.EditorView.domEventHandlers({\n    beforeinput: function beforeinput(e, view) {\n      var command = e.inputType == \"historyUndo\" ? undo : e.inputType == \"historyRedo\" ? redo : null;\n      if (!command) return false;\n      e.preventDefault();\n      return command(view);\n    }\n  })];\n}\n/**\nThe state field used to store the history data. Should probably\nonly be used when you want to\n[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or\n[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way\nthat preserves history.\n*/\n\n\nvar historyField = historyField_;\n\nfunction cmd(side, selection) {\n  return function (_ref) {\n    var state = _ref.state,\n        dispatch = _ref.dispatch;\n    if (!selection && state.readOnly) return false;\n    var historyState = state.field(historyField_, false);\n    if (!historyState) return false;\n    var tr = historyState.pop(side, state, selection);\n    if (!tr) return false;\n    dispatch(tr);\n    return true;\n  };\n}\n/**\nUndo a single group of history events. Returns false if no group\nwas available.\n*/\n\n\nvar undo = /*@__PURE__*/cmd(0\n/* Done */\n, false);\n/**\nRedo a group of history events. Returns false if no group was\navailable.\n*/\n\nvar redo = /*@__PURE__*/cmd(1\n/* Undone */\n, false);\n/**\nUndo a selection change.\n*/\n\nvar undoSelection = /*@__PURE__*/cmd(0\n/* Done */\n, true);\n/**\nRedo a selection change.\n*/\n\nvar redoSelection = /*@__PURE__*/cmd(1\n/* Undone */\n, true);\n\nfunction depth(side) {\n  return function (state) {\n    var histState = state.field(historyField_, false);\n    if (!histState) return 0;\n    var branch = side == 0\n    /* Done */\n    ? histState.done : histState.undone;\n    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);\n  };\n}\n/**\nThe amount of undoable change events available in a given state.\n*/\n\n\nvar undoDepth = /*@__PURE__*/depth(0\n/* Done */\n);\n/**\nThe amount of redoable change events available in a given state.\n*/\n\nvar redoDepth = /*@__PURE__*/depth(1\n/* Undone */\n); // History events store groups of changes or effects that need to be\n// undone/redone together.\n\nvar HistEvent = /*#__PURE__*/function () {\n  function HistEvent( // The changes in this event. Normal events hold at least one\n  // change or effect. But it may be necessary to store selection\n  // events before the first change, in which case a special type of\n  // instance is created which doesn't hold any changes, with\n  // changes == startSelection == undefined\n  changes, // The effects associated with this event\n  effects, mapped, // The selection before this event\n  startSelection, // Stores selection changes after this event, to be used for\n  // selection undo/redo.\n  selectionsAfter) {\n    _classCallCheck(this, HistEvent);\n\n    this.changes = changes;\n    this.effects = effects;\n    this.mapped = mapped;\n    this.startSelection = startSelection;\n    this.selectionsAfter = selectionsAfter;\n  }\n\n  _createClass(HistEvent, [{\n    key: \"setSelAfter\",\n    value: function setSelAfter(after) {\n      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _a, _b, _c;\n\n      return {\n        changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),\n        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),\n        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),\n        selectionsAfter: this.selectionsAfter.map(function (s) {\n          return s.toJSON();\n        })\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return new HistEvent(json.changes && _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.ChangeSet.fromJSON(json.changes), [], json.mapped && _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.ChangeDesc.fromJSON(json.mapped), json.startSelection && _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(_codemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorSelection.fromJSON));\n    } // This does not check `addToHistory` and such, it assumes the\n    // transaction needs to be converted to an item. Returns null when\n    // there are no changes or effects in the transaction.\n\n  }, {\n    key: \"fromTransaction\",\n    value: function fromTransaction(tr, selection) {\n      var effects = none;\n\n      var _iterator = _createForOfIteratorHelper(tr.startState.facet(invertedEffects)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var invert = _step.value;\n          var result = invert(tr);\n          if (result.length) effects = effects.concat(result);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!effects.length && tr.changes.empty) return null;\n      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);\n    }\n  }, {\n    key: \"selection\",\n    value: function selection(selections) {\n      return new HistEvent(undefined, none, undefined, undefined, selections);\n    }\n  }]);\n\n  return HistEvent;\n}();\n\nfunction updateBranch(branch, to, maxLen, newEvent) {\n  var start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;\n  var newBranch = branch.slice(start, to);\n  newBranch.push(newEvent);\n  return newBranch;\n}\n\nfunction isAdjacent(a, b) {\n  var ranges = [],\n      isAdjacent = false;\n  a.iterChangedRanges(function (f, t) {\n    return ranges.push(f, t);\n  });\n  b.iterChangedRanges(function (_f, _t, f, t) {\n    for (var i = 0; i < ranges.length;) {\n      var from = ranges[i++],\n          to = ranges[i++];\n      if (t >= from && f <= to) isAdjacent = true;\n    }\n  });\n  return isAdjacent;\n}\n\nfunction eqSelectionShape(a, b) {\n  return a.ranges.length == b.ranges.length && a.ranges.filter(function (r, i) {\n    return r.empty != b.ranges[i].empty;\n  }).length === 0;\n}\n\nfunction conc(a, b) {\n  return !a.length ? b : !b.length ? a : a.concat(b);\n}\n\nvar none = [];\nvar MaxSelectionsPerEvent = 200;\n\nfunction _addSelection(branch, selection) {\n  if (!branch.length) {\n    return [HistEvent.selection([selection])];\n  } else {\n    var lastEvent = branch[branch.length - 1];\n    var sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));\n    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;\n    sels.push(selection);\n    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));\n  }\n} // Assumes the top item has one or more selectionAfter values\n\n\nfunction popSelection(branch) {\n  var last = branch[branch.length - 1];\n  var newBranch = branch.slice();\n  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));\n  return newBranch;\n} // Add a mapping to the top event in the given branch. If this maps\n// away all the changes and effects in that item, drop it and\n// propagate the mapping to the next item.\n\n\nfunction addMappingToBranch(branch, mapping) {\n  if (!branch.length) return branch;\n  var length = branch.length,\n      selections = none;\n\n  while (length) {\n    var event = mapEvent(branch[length - 1], mapping, selections);\n\n    if (event.changes && !event.changes.empty || event.effects.length) {\n      // Event survived mapping\n      var result = branch.slice(0, length);\n      result[length - 1] = event;\n      return result;\n    } else {\n      // Drop this event, since there's no changes or effects left\n      mapping = event.mapped;\n      length--;\n      selections = event.selectionsAfter;\n    }\n  }\n\n  return selections.length ? [HistEvent.selection(selections)] : none;\n}\n\nfunction mapEvent(event, mapping, extraSelections) {\n  var selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(function (s) {\n    return s.map(mapping);\n  }) : none, extraSelections); // Change-less events don't store mappings (they are always the last event in a branch)\n\n  if (!event.changes) return HistEvent.selection(selections);\n  var mappedChanges = event.changes.map(mapping),\n      before = mapping.mapDesc(event.changes, true);\n  var fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;\n  return new HistEvent(mappedChanges, _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);\n}\n\nvar joinableUserEvent = /^(input\\.type|delete)($|\\.)/;\n\nvar HistoryState = /*#__PURE__*/function () {\n  function HistoryState(done, undone) {\n    var prevTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var prevUserEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    _classCallCheck(this, HistoryState);\n\n    this.done = done;\n    this.undone = undone;\n    this.prevTime = prevTime;\n    this.prevUserEvent = prevUserEvent;\n  }\n\n  _createClass(HistoryState, [{\n    key: \"isolate\",\n    value: function isolate() {\n      return this.prevTime ? new HistoryState(this.done, this.undone) : this;\n    }\n  }, {\n    key: \"addChanges\",\n    value: function addChanges(event, time, userEvent, newGroupDelay, maxLen) {\n      var done = this.done,\n          lastEvent = done[done.length - 1];\n\n      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || // For compose (but not compose.start) events, always join with previous event\n      userEvent == \"input.type.compose\")) {\n        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));\n      } else {\n        done = updateBranch(done, done.length, maxLen, event);\n      }\n\n      return new HistoryState(done, none, time, userEvent);\n    }\n  }, {\n    key: \"addSelection\",\n    value: function addSelection(selection, time, userEvent, newGroupDelay) {\n      var last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;\n      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;\n      return new HistoryState(_addSelection(this.done, selection), this.undone, time, userEvent);\n    }\n  }, {\n    key: \"addMapping\",\n    value: function addMapping(mapping) {\n      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(side, state, selection) {\n      var branch = side == 0\n      /* Done */\n      ? this.done : this.undone;\n      if (branch.length == 0) return null;\n      var event = branch[branch.length - 1];\n\n      if (selection && event.selectionsAfter.length) {\n        return state.update({\n          selection: event.selectionsAfter[event.selectionsAfter.length - 1],\n          annotations: fromHistory.of({\n            side: side,\n            rest: popSelection(branch)\n          }),\n          userEvent: side == 0\n          /* Done */\n          ? \"select.undo\" : \"select.redo\",\n          scrollIntoView: true\n        });\n      } else if (!event.changes) {\n        return null;\n      } else {\n        var rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);\n        if (event.mapped) rest = addMappingToBranch(rest, event.mapped);\n        return state.update({\n          changes: event.changes,\n          selection: event.startSelection,\n          effects: event.effects,\n          annotations: fromHistory.of({\n            side: side,\n            rest: rest\n          }),\n          filter: false,\n          userEvent: side == 0\n          /* Done */\n          ? \"undo\" : \"redo\",\n          scrollIntoView: true\n        });\n      }\n    }\n  }]);\n\n  return HistoryState;\n}();\n\nHistoryState.empty = /*@__PURE__*/new HistoryState(none, none);\n/**\nDefault key bindings for the undo history.\n\n- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#history.undo).\n- Mod-y (Mod-Shift-z on macOS): [`redo`](https://codemirror.net/6/docs/ref/#history.redo).\n- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#history.undoSelection).\n- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#history.redoSelection).\n*/\n\nvar historyKeymap = [{\n  key: \"Mod-z\",\n  run: undo,\n  preventDefault: true\n}, {\n  key: \"Mod-y\",\n  mac: \"Mod-Shift-z\",\n  run: redo,\n  preventDefault: true\n}, {\n  key: \"Mod-u\",\n  run: undoSelection,\n  preventDefault: true\n}, {\n  key: \"Alt-u\",\n  mac: \"Mod-Shift-u\",\n  run: redoSelection,\n  preventDefault: true\n}];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvaGlzdG9yeS9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFOQTs7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQ0E7QUF1Q0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBSkE7QUFNQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFOQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2hpc3RvcnkvZGlzdC9pbmRleC5qcz85NjM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFubm90YXRpb24sIEZhY2V0LCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkLCBFZGl0b3JTZWxlY3Rpb24sIFRyYW5zYWN0aW9uLCBDaGFuZ2VTZXQsIENoYW5nZURlc2MsIFN0YXRlRWZmZWN0IH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgRWRpdG9yVmlldyB9IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuXG5jb25zdCBmcm9tSGlzdG9yeSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5UcmFuc2FjdGlvbiBhbm5vdGF0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IHRoYXQgdHJhbnNhY3Rpb24gZnJvbVxuYmVpbmcgY29tYmluZWQgd2l0aCBvdGhlciB0cmFuc2FjdGlvbnMgaW4gdGhlIHVuZG8gaGlzdG9yeS4gR2l2ZW5cbmBcImJlZm9yZVwiYCwgaXQnbGwgcHJldmVudCBtZXJnaW5nIHdpdGggcHJldmlvdXMgdHJhbnNhY3Rpb25zLiBXaXRoXG5gXCJhZnRlclwiYCwgc3Vic2VxdWVudCB0cmFuc2FjdGlvbnMgd29uJ3QgYmUgY29tYmluZWQgd2l0aCB0aGlzXG5vbmUuIFdpdGggYFwiZnVsbFwiYCwgdGhlIHRyYW5zYWN0aW9uIGlzIGlzb2xhdGVkIG9uIGJvdGggc2lkZXMuXG4qL1xuY29uc3QgaXNvbGF0ZUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovQW5ub3RhdGlvbi5kZWZpbmUoKTtcbi8qKlxuVGhpcyBmYWNldCBwcm92aWRlcyBhIHdheSB0byByZWdpc3RlciBmdW5jdGlvbnMgdGhhdCwgZ2l2ZW4gYVxudHJhbnNhY3Rpb24sIHByb3ZpZGUgYSBzZXQgb2YgZWZmZWN0cyB0aGF0IHRoZSBoaXN0b3J5IHNob3VsZFxuc3RvcmUgd2hlbiBpbnZlcnRpbmcgdGhlIHRyYW5zYWN0aW9uLiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5pbnRlZ3JhdGUgc29tZSBraW5kcyBvZiBlZmZlY3RzIGluIHRoZSBoaXN0b3J5LCBzbyB0aGF0IHRoZXkgY2FuXG5iZSB1bmRvbmUgKGFuZCByZWRvbmUgYWdhaW4pLlxuKi9cbmNvbnN0IGludmVydGVkRWZmZWN0cyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGhpc3RvcnlDb25maWcgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgbWluRGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMFxuICAgICAgICB9LCB7IG1pbkRlcHRoOiBNYXRoLm1heCwgbmV3R3JvdXBEZWxheTogTWF0aC5taW4gfSk7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBjaGFuZ2VFbmQoY2hhbmdlcykge1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKF8sIHRvKSA9PiBlbmQgPSB0byk7XG4gICAgcmV0dXJuIGVuZDtcbn1cbmNvbnN0IGhpc3RvcnlGaWVsZF8gPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIEhpc3RvcnlTdGF0ZS5lbXB0eTtcbiAgICB9LFxuICAgIHVwZGF0ZShzdGF0ZSwgdHIpIHtcbiAgICAgICAgbGV0IGNvbmZpZyA9IHRyLnN0YXRlLmZhY2V0KGhpc3RvcnlDb25maWcpO1xuICAgICAgICBsZXQgZnJvbUhpc3QgPSB0ci5hbm5vdGF0aW9uKGZyb21IaXN0b3J5KTtcbiAgICAgICAgaWYgKGZyb21IaXN0KSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gdHIuZG9jQ2hhbmdlZCA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoY2hhbmdlRW5kKHRyLmNoYW5nZXMpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSGlzdEV2ZW50LmZyb21UcmFuc2FjdGlvbih0ciwgc2VsZWN0aW9uKSwgZnJvbSA9IGZyb21IaXN0LnNpZGU7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBmcm9tID09IDAgLyogRG9uZSAqLyA/IHN0YXRlLnVuZG9uZSA6IHN0YXRlLmRvbmU7XG4gICAgICAgICAgICBpZiAoaXRlbSlcbiAgICAgICAgICAgICAgICBvdGhlciA9IHVwZGF0ZUJyYW5jaChvdGhlciwgb3RoZXIubGVuZ3RoLCBjb25maWcubWluRGVwdGgsIGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG90aGVyID0gYWRkU2VsZWN0aW9uKG90aGVyLCB0ci5zdGFydFN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShmcm9tID09IDAgLyogRG9uZSAqLyA/IGZyb21IaXN0LnJlc3QgOiBvdGhlciwgZnJvbSA9PSAwIC8qIERvbmUgKi8gPyBvdGhlciA6IGZyb21IaXN0LnJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc29sYXRlID0gdHIuYW5ub3RhdGlvbihpc29sYXRlSGlzdG9yeSk7XG4gICAgICAgIGlmIChpc29sYXRlID09IFwiZnVsbFwiIHx8IGlzb2xhdGUgPT0gXCJiZWZvcmVcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICBpZiAodHIuYW5ub3RhdGlvbihUcmFuc2FjdGlvbi5hZGRUb0hpc3RvcnkpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiAhdHIuY2hhbmdlcy5lbXB0eSA/IHN0YXRlLmFkZE1hcHBpbmcodHIuY2hhbmdlcy5kZXNjKSA6IHN0YXRlO1xuICAgICAgICBsZXQgZXZlbnQgPSBIaXN0RXZlbnQuZnJvbVRyYW5zYWN0aW9uKHRyKTtcbiAgICAgICAgbGV0IHRpbWUgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnRpbWUpLCB1c2VyRXZlbnQgPSB0ci5hbm5vdGF0aW9uKFRyYW5zYWN0aW9uLnVzZXJFdmVudCk7XG4gICAgICAgIGlmIChldmVudClcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkQ2hhbmdlcyhldmVudCwgdGltZSwgdXNlckV2ZW50LCBjb25maWcubmV3R3JvdXBEZWxheSwgY29uZmlnLm1pbkRlcHRoKTtcbiAgICAgICAgZWxzZSBpZiAodHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5hZGRTZWxlY3Rpb24odHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgY29uZmlnLm5ld0dyb3VwRGVsYXkpO1xuICAgICAgICBpZiAoaXNvbGF0ZSA9PSBcImZ1bGxcIiB8fCBpc29sYXRlID09IFwiYWZ0ZXJcIilcbiAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuaXNvbGF0ZSgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICB0b0pTT04odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdmFsdWUuZG9uZS5tYXAoZSA9PiBlLnRvSlNPTigpKSwgdW5kb25lOiB2YWx1ZS51bmRvbmUubWFwKGUgPT4gZS50b0pTT04oKSkgfTtcbiAgICB9LFxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoanNvbi5kb25lLm1hcChIaXN0RXZlbnQuZnJvbUpTT04pLCBqc29uLnVuZG9uZS5tYXAoSGlzdEV2ZW50LmZyb21KU09OKSk7XG4gICAgfVxufSk7XG4vKipcbkNyZWF0ZSBhIGhpc3RvcnkgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG4qL1xuZnVuY3Rpb24gaGlzdG9yeShjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGhpc3RvcnlGaWVsZF8sXG4gICAgICAgIGhpc3RvcnlDb25maWcub2YoY29uZmlnKSxcbiAgICAgICAgRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICAgICAgICAgIGJlZm9yZWlucHV0KGUsIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGUuaW5wdXRUeXBlID09IFwiaGlzdG9yeVVuZG9cIiA/IHVuZG8gOiBlLmlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgXTtcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHVzZWQgdG8gc3RvcmUgdGhlIGhpc3RvcnkgZGF0YS4gU2hvdWxkIHByb2JhYmx5XG5vbmx5IGJlIHVzZWQgd2hlbiB5b3Ugd2FudCB0b1xuW3NlcmlhbGl6ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIG9yXG5bZGVzZXJpYWxpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHN0YXRlIG9iamVjdHMgaW4gYSB3YXlcbnRoYXQgcHJlc2VydmVzIGhpc3RvcnkuXG4qL1xuY29uc3QgaGlzdG9yeUZpZWxkID0gaGlzdG9yeUZpZWxkXztcbmZ1bmN0aW9uIGNtZChzaWRlLCBzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHsgc3RhdGUsIGRpc3BhdGNoIH0pIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgc3RhdGUucmVhZE9ubHkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBoaXN0b3J5U3RhdGUgPSBzdGF0ZS5maWVsZChoaXN0b3J5RmllbGRfLCBmYWxzZSk7XG4gICAgICAgIGlmICghaGlzdG9yeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHIgPSBoaXN0b3J5U3RhdGUucG9wKHNpZGUsIHN0YXRlLCBzZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXRyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblVuZG8gYSBzaW5nbGUgZ3JvdXAgb2YgaGlzdG9yeSBldmVudHMuIFJldHVybnMgZmFsc2UgaWYgbm8gZ3JvdXBcbndhcyBhdmFpbGFibGUuXG4qL1xuY29uc3QgdW5kbyA9IC8qQF9fUFVSRV9fKi9jbWQoMCAvKiBEb25lICovLCBmYWxzZSk7XG4vKipcblJlZG8gYSBncm91cCBvZiBoaXN0b3J5IGV2ZW50cy4gUmV0dXJucyBmYWxzZSBpZiBubyBncm91cCB3YXNcbmF2YWlsYWJsZS5cbiovXG5jb25zdCByZWRvID0gLypAX19QVVJFX18qL2NtZCgxIC8qIFVuZG9uZSAqLywgZmFsc2UpO1xuLyoqXG5VbmRvIGEgc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCB1bmRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgwIC8qIERvbmUgKi8sIHRydWUpO1xuLyoqXG5SZWRvIGEgc2VsZWN0aW9uIGNoYW5nZS5cbiovXG5jb25zdCByZWRvU2VsZWN0aW9uID0gLypAX19QVVJFX18qL2NtZCgxIC8qIFVuZG9uZSAqLywgdHJ1ZSk7XG5mdW5jdGlvbiBkZXB0aChzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBsZXQgaGlzdFN0YXRlID0gc3RhdGUuZmllbGQoaGlzdG9yeUZpZWxkXywgZmFsc2UpO1xuICAgICAgICBpZiAoIWhpc3RTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgYnJhbmNoID0gc2lkZSA9PSAwIC8qIERvbmUgKi8gPyBoaXN0U3RhdGUuZG9uZSA6IGhpc3RTdGF0ZS51bmRvbmU7XG4gICAgICAgIHJldHVybiBicmFuY2gubGVuZ3RoIC0gKGJyYW5jaC5sZW5ndGggJiYgIWJyYW5jaFswXS5jaGFuZ2VzID8gMSA6IDApO1xuICAgIH07XG59XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgY2hhbmdlIGV2ZW50cyBhdmFpbGFibGUgaW4gYSBnaXZlbiBzdGF0ZS5cbiovXG5jb25zdCB1bmRvRGVwdGggPSAvKkBfX1BVUkVfXyovZGVwdGgoMCAvKiBEb25lICovKTtcbi8qKlxuVGhlIGFtb3VudCBvZiByZWRvYWJsZSBjaGFuZ2UgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmNvbnN0IHJlZG9EZXB0aCA9IC8qQF9fUFVSRV9fKi9kZXB0aCgxIC8qIFVuZG9uZSAqLyk7XG4vLyBIaXN0b3J5IGV2ZW50cyBzdG9yZSBncm91cHMgb2YgY2hhbmdlcyBvciBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZVxuLy8gdW5kb25lL3JlZG9uZSB0b2dldGhlci5cbmNsYXNzIEhpc3RFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGNoYW5nZXMgaW4gdGhpcyBldmVudC4gTm9ybWFsIGV2ZW50cyBob2xkIGF0IGxlYXN0IG9uZVxuICAgIC8vIGNoYW5nZSBvciBlZmZlY3QuIEJ1dCBpdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN0b3JlIHNlbGVjdGlvblxuICAgIC8vIGV2ZW50cyBiZWZvcmUgdGhlIGZpcnN0IGNoYW5nZSwgaW4gd2hpY2ggY2FzZSBhIHNwZWNpYWwgdHlwZSBvZlxuICAgIC8vIGluc3RhbmNlIGlzIGNyZWF0ZWQgd2hpY2ggZG9lc24ndCBob2xkIGFueSBjaGFuZ2VzLCB3aXRoXG4gICAgLy8gY2hhbmdlcyA9PSBzdGFydFNlbGVjdGlvbiA9PSB1bmRlZmluZWRcbiAgICBjaGFuZ2VzLCBcbiAgICAvLyBUaGUgZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudFxuICAgIGVmZmVjdHMsIG1hcHBlZCwgXG4gICAgLy8gVGhlIHNlbGVjdGlvbiBiZWZvcmUgdGhpcyBldmVudFxuICAgIHN0YXJ0U2VsZWN0aW9uLCBcbiAgICAvLyBTdG9yZXMgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIgdGhpcyBldmVudCwgdG8gYmUgdXNlZCBmb3JcbiAgICAvLyBzZWxlY3Rpb24gdW5kby9yZWRvLlxuICAgIHNlbGVjdGlvbnNBZnRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLm1hcHBlZCA9IG1hcHBlZDtcbiAgICAgICAgdGhpcy5zdGFydFNlbGVjdGlvbiA9IHN0YXJ0U2VsZWN0aW9uO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnNBZnRlciA9IHNlbGVjdGlvbnNBZnRlcjtcbiAgICB9XG4gICAgc2V0U2VsQWZ0ZXIoYWZ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodGhpcy5jaGFuZ2VzLCB0aGlzLmVmZmVjdHMsIHRoaXMubWFwcGVkLCB0aGlzLnN0YXJ0U2VsZWN0aW9uLCBhZnRlcik7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzOiAoX2EgPSB0aGlzLmNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0pTT04oKSxcbiAgICAgICAgICAgIG1hcHBlZDogKF9iID0gdGhpcy5tYXBwZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b0pTT04oKSxcbiAgICAgICAgICAgIHN0YXJ0U2VsZWN0aW9uOiAoX2MgPSB0aGlzLnN0YXJ0U2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9KU09OKCksXG4gICAgICAgICAgICBzZWxlY3Rpb25zQWZ0ZXI6IHRoaXMuc2VsZWN0aW9uc0FmdGVyLm1hcChzID0+IHMudG9KU09OKCkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KGpzb24uY2hhbmdlcyAmJiBDaGFuZ2VTZXQuZnJvbUpTT04oanNvbi5jaGFuZ2VzKSwgW10sIGpzb24ubWFwcGVkICYmIENoYW5nZURlc2MuZnJvbUpTT04oanNvbi5tYXBwZWQpLCBqc29uLnN0YXJ0U2VsZWN0aW9uICYmIEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTihqc29uLnN0YXJ0U2VsZWN0aW9uKSwganNvbi5zZWxlY3Rpb25zQWZ0ZXIubWFwKEVkaXRvclNlbGVjdGlvbi5mcm9tSlNPTikpO1xuICAgIH1cbiAgICAvLyBUaGlzIGRvZXMgbm90IGNoZWNrIGBhZGRUb0hpc3RvcnlgIGFuZCBzdWNoLCBpdCBhc3N1bWVzIHRoZVxuICAgIC8vIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhbiBpdGVtLiBSZXR1cm5zIG51bGwgd2hlblxuICAgIC8vIHRoZXJlIGFyZSBubyBjaGFuZ2VzIG9yIGVmZmVjdHMgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgIHN0YXRpYyBmcm9tVHJhbnNhY3Rpb24odHIsIHNlbGVjdGlvbikge1xuICAgICAgICBsZXQgZWZmZWN0cyA9IG5vbmU7XG4gICAgICAgIGZvciAobGV0IGludmVydCBvZiB0ci5zdGFydFN0YXRlLmZhY2V0KGludmVydGVkRWZmZWN0cykpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBpbnZlcnQodHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZWZmZWN0cyA9IGVmZmVjdHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aCAmJiB0ci5jaGFuZ2VzLmVtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KHRyLmNoYW5nZXMuaW52ZXJ0KHRyLnN0YXJ0U3RhdGUuZG9jKSwgZWZmZWN0cywgdW5kZWZpbmVkLCBzZWxlY3Rpb24gfHwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24sIG5vbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc2VsZWN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0RXZlbnQodW5kZWZpbmVkLCBub25lLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgc2VsZWN0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlQnJhbmNoKGJyYW5jaCwgdG8sIG1heExlbiwgbmV3RXZlbnQpIHtcbiAgICBsZXQgc3RhcnQgPSB0byArIDEgPiBtYXhMZW4gKyAyMCA/IHRvIC0gbWF4TGVuIC0gMSA6IDA7XG4gICAgbGV0IG5ld0JyYW5jaCA9IGJyYW5jaC5zbGljZShzdGFydCwgdG8pO1xuICAgIG5ld0JyYW5jaC5wdXNoKG5ld0V2ZW50KTtcbiAgICByZXR1cm4gbmV3QnJhbmNoO1xufVxuZnVuY3Rpb24gaXNBZGphY2VudChhLCBiKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBpc0FkamFjZW50ID0gZmFsc2U7XG4gICAgYS5pdGVyQ2hhbmdlZFJhbmdlcygoZiwgdCkgPT4gcmFuZ2VzLnB1c2goZiwgdCkpO1xuICAgIGIuaXRlckNoYW5nZWRSYW5nZXMoKF9mLCBfdCwgZiwgdCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpKytdLCB0byA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgaWYgKHQgPj0gZnJvbSAmJiBmIDw9IHRvKVxuICAgICAgICAgICAgICAgIGlzQWRqYWNlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQWRqYWNlbnQ7XG59XG5mdW5jdGlvbiBlcVNlbGVjdGlvblNoYXBlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5yYW5nZXMubGVuZ3RoID09IGIucmFuZ2VzLmxlbmd0aCAmJlxuICAgICAgICBhLnJhbmdlcy5maWx0ZXIoKHIsIGkpID0+IHIuZW1wdHkgIT0gYi5yYW5nZXNbaV0uZW1wdHkpLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIGNvbmMoYSwgYikge1xuICAgIHJldHVybiAhYS5sZW5ndGggPyBiIDogIWIubGVuZ3RoID8gYSA6IGEuY29uY2F0KGIpO1xufVxuY29uc3Qgbm9uZSA9IFtdO1xuY29uc3QgTWF4U2VsZWN0aW9uc1BlckV2ZW50ID0gMjAwO1xuZnVuY3Rpb24gYWRkU2VsZWN0aW9uKGJyYW5jaCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFicmFuY2gubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbSGlzdEV2ZW50LnNlbGVjdGlvbihbc2VsZWN0aW9uXSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxhc3RFdmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBzZWxzID0gbGFzdEV2ZW50LnNlbGVjdGlvbnNBZnRlci5zbGljZShNYXRoLm1heCgwLCBsYXN0RXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIE1heFNlbGVjdGlvbnNQZXJFdmVudCkpO1xuICAgICAgICBpZiAoc2Vscy5sZW5ndGggJiYgc2Vsc1tzZWxzLmxlbmd0aCAtIDFdLmVxKHNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoO1xuICAgICAgICBzZWxzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUJyYW5jaChicmFuY2gsIGJyYW5jaC5sZW5ndGggLSAxLCAxZTksIGxhc3RFdmVudC5zZXRTZWxBZnRlcihzZWxzKSk7XG4gICAgfVxufVxuLy8gQXNzdW1lcyB0aGUgdG9wIGl0ZW0gaGFzIG9uZSBvciBtb3JlIHNlbGVjdGlvbkFmdGVyIHZhbHVlc1xuZnVuY3Rpb24gcG9wU2VsZWN0aW9uKGJyYW5jaCkge1xuICAgIGxldCBsYXN0ID0gYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXTtcbiAgICBsZXQgbmV3QnJhbmNoID0gYnJhbmNoLnNsaWNlKCk7XG4gICAgbmV3QnJhbmNoW2JyYW5jaC5sZW5ndGggLSAxXSA9IGxhc3Quc2V0U2VsQWZ0ZXIobGFzdC5zZWxlY3Rpb25zQWZ0ZXIuc2xpY2UoMCwgbGFzdC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBuZXdCcmFuY2g7XG59XG4vLyBBZGQgYSBtYXBwaW5nIHRvIHRoZSB0b3AgZXZlbnQgaW4gdGhlIGdpdmVuIGJyYW5jaC4gSWYgdGhpcyBtYXBzXG4vLyBhd2F5IGFsbCB0aGUgY2hhbmdlcyBhbmQgZWZmZWN0cyBpbiB0aGF0IGl0ZW0sIGRyb3AgaXQgYW5kXG4vLyBwcm9wYWdhdGUgdGhlIG1hcHBpbmcgdG8gdGhlIG5leHQgaXRlbS5cbmZ1bmN0aW9uIGFkZE1hcHBpbmdUb0JyYW5jaChicmFuY2gsIG1hcHBpbmcpIHtcbiAgICBpZiAoIWJyYW5jaC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgbGV0IGxlbmd0aCA9IGJyYW5jaC5sZW5ndGgsIHNlbGVjdGlvbnMgPSBub25lO1xuICAgIHdoaWxlIChsZW5ndGgpIHtcbiAgICAgICAgbGV0IGV2ZW50ID0gbWFwRXZlbnQoYnJhbmNoW2xlbmd0aCAtIDFdLCBtYXBwaW5nLCBzZWxlY3Rpb25zKTtcbiAgICAgICAgaWYgKGV2ZW50LmNoYW5nZXMgJiYgIWV2ZW50LmNoYW5nZXMuZW1wdHkgfHwgZXZlbnQuZWZmZWN0cy5sZW5ndGgpIHsgLy8gRXZlbnQgc3Vydml2ZWQgbWFwcGluZ1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGJyYW5jaC5zbGljZSgwLCBsZW5ndGgpO1xuICAgICAgICAgICAgcmVzdWx0W2xlbmd0aCAtIDFdID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBEcm9wIHRoaXMgZXZlbnQsIHNpbmNlIHRoZXJlJ3Mgbm8gY2hhbmdlcyBvciBlZmZlY3RzIGxlZnRcbiAgICAgICAgICAgIG1hcHBpbmcgPSBldmVudC5tYXBwZWQ7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIHNlbGVjdGlvbnMgPSBldmVudC5zZWxlY3Rpb25zQWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gW0hpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyldIDogbm9uZTtcbn1cbmZ1bmN0aW9uIG1hcEV2ZW50KGV2ZW50LCBtYXBwaW5nLCBleHRyYVNlbGVjdGlvbnMpIHtcbiAgICBsZXQgc2VsZWN0aW9ucyA9IGNvbmMoZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCA/IGV2ZW50LnNlbGVjdGlvbnNBZnRlci5tYXAocyA9PiBzLm1hcChtYXBwaW5nKSkgOiBub25lLCBleHRyYVNlbGVjdGlvbnMpO1xuICAgIC8vIENoYW5nZS1sZXNzIGV2ZW50cyBkb24ndCBzdG9yZSBtYXBwaW5ncyAodGhleSBhcmUgYWx3YXlzIHRoZSBsYXN0IGV2ZW50IGluIGEgYnJhbmNoKVxuICAgIGlmICghZXZlbnQuY2hhbmdlcylcbiAgICAgICAgcmV0dXJuIEhpc3RFdmVudC5zZWxlY3Rpb24oc2VsZWN0aW9ucyk7XG4gICAgbGV0IG1hcHBlZENoYW5nZXMgPSBldmVudC5jaGFuZ2VzLm1hcChtYXBwaW5nKSwgYmVmb3JlID0gbWFwcGluZy5tYXBEZXNjKGV2ZW50LmNoYW5nZXMsIHRydWUpO1xuICAgIGxldCBmdWxsTWFwcGluZyA9IGV2ZW50Lm1hcHBlZCA/IGV2ZW50Lm1hcHBlZC5jb21wb3NlRGVzYyhiZWZvcmUpIDogYmVmb3JlO1xuICAgIHJldHVybiBuZXcgSGlzdEV2ZW50KG1hcHBlZENoYW5nZXMsIFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoZXZlbnQuZWZmZWN0cywgbWFwcGluZyksIGZ1bGxNYXBwaW5nLCBldmVudC5zdGFydFNlbGVjdGlvbi5tYXAoYmVmb3JlKSwgc2VsZWN0aW9ucyk7XG59XG5jb25zdCBqb2luYWJsZVVzZXJFdmVudCA9IC9eKGlucHV0XFwudHlwZXxkZWxldGUpKCR8XFwuKS87XG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlRpbWUgPSAwLCBwcmV2VXNlckV2ZW50ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIHRoaXMudW5kb25lID0gdW5kb25lO1xuICAgICAgICB0aGlzLnByZXZUaW1lID0gcHJldlRpbWU7XG4gICAgICAgIHRoaXMucHJldlVzZXJFdmVudCA9IHByZXZVc2VyRXZlbnQ7XG4gICAgfVxuICAgIGlzb2xhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZUaW1lID8gbmV3IEhpc3RvcnlTdGF0ZSh0aGlzLmRvbmUsIHRoaXMudW5kb25lKSA6IHRoaXM7XG4gICAgfVxuICAgIGFkZENoYW5nZXMoZXZlbnQsIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSwgbWF4TGVuKSB7XG4gICAgICAgIGxldCBkb25lID0gdGhpcy5kb25lLCBsYXN0RXZlbnQgPSBkb25lW2RvbmUubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0RXZlbnQgJiYgbGFzdEV2ZW50LmNoYW5nZXMgJiYgIWxhc3RFdmVudC5jaGFuZ2VzLmVtcHR5ICYmIGV2ZW50LmNoYW5nZXMgJiZcbiAgICAgICAgICAgICghdXNlckV2ZW50IHx8IGpvaW5hYmxlVXNlckV2ZW50LnRlc3QodXNlckV2ZW50KSkgJiZcbiAgICAgICAgICAgICgoIWxhc3RFdmVudC5zZWxlY3Rpb25zQWZ0ZXIubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgdGltZSAtIHRoaXMucHJldlRpbWUgPCBuZXdHcm91cERlbGF5ICYmXG4gICAgICAgICAgICAgICAgaXNBZGphY2VudChsYXN0RXZlbnQuY2hhbmdlcywgZXZlbnQuY2hhbmdlcykpIHx8XG4gICAgICAgICAgICAgICAgLy8gRm9yIGNvbXBvc2UgKGJ1dCBub3QgY29tcG9zZS5zdGFydCkgZXZlbnRzLCBhbHdheXMgam9pbiB3aXRoIHByZXZpb3VzIGV2ZW50XG4gICAgICAgICAgICAgICAgdXNlckV2ZW50ID09IFwiaW5wdXQudHlwZS5jb21wb3NlXCIpKSB7XG4gICAgICAgICAgICBkb25lID0gdXBkYXRlQnJhbmNoKGRvbmUsIGRvbmUubGVuZ3RoIC0gMSwgbWF4TGVuLCBuZXcgSGlzdEV2ZW50KGV2ZW50LmNoYW5nZXMuY29tcG9zZShsYXN0RXZlbnQuY2hhbmdlcyksIGNvbmMoZXZlbnQuZWZmZWN0cywgbGFzdEV2ZW50LmVmZmVjdHMpLCBsYXN0RXZlbnQubWFwcGVkLCBsYXN0RXZlbnQuc3RhcnRTZWxlY3Rpb24sIG5vbmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvbmUgPSB1cGRhdGVCcmFuY2goZG9uZSwgZG9uZS5sZW5ndGgsIG1heExlbiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGRvbmUsIG5vbmUsIHRpbWUsIHVzZXJFdmVudCk7XG4gICAgfVxuICAgIGFkZFNlbGVjdGlvbihzZWxlY3Rpb24sIHRpbWUsIHVzZXJFdmVudCwgbmV3R3JvdXBEZWxheSkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuZG9uZS5sZW5ndGggPyB0aGlzLmRvbmVbdGhpcy5kb25lLmxlbmd0aCAtIDFdLnNlbGVjdGlvbnNBZnRlciA6IG5vbmU7XG4gICAgICAgIGlmIChsYXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRpbWUgLSB0aGlzLnByZXZUaW1lIDwgbmV3R3JvdXBEZWxheSAmJlxuICAgICAgICAgICAgdXNlckV2ZW50ID09IHRoaXMucHJldlVzZXJFdmVudCAmJiB1c2VyRXZlbnQgJiYgL15zZWxlY3QoJHxcXC4pLy50ZXN0KHVzZXJFdmVudCkgJiZcbiAgICAgICAgICAgIGVxU2VsZWN0aW9uU2hhcGUobGFzdFtsYXN0Lmxlbmd0aCAtIDFdLCBzZWxlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGFkZFNlbGVjdGlvbih0aGlzLmRvbmUsIHNlbGVjdGlvbiksIHRoaXMudW5kb25lLCB0aW1lLCB1c2VyRXZlbnQpO1xuICAgIH1cbiAgICBhZGRNYXBwaW5nKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoYWRkTWFwcGluZ1RvQnJhbmNoKHRoaXMuZG9uZSwgbWFwcGluZyksIGFkZE1hcHBpbmdUb0JyYW5jaCh0aGlzLnVuZG9uZSwgbWFwcGluZyksIHRoaXMucHJldlRpbWUsIHRoaXMucHJldlVzZXJFdmVudCk7XG4gICAgfVxuICAgIHBvcChzaWRlLCBzdGF0ZSwgc2VsZWN0aW9uKSB7XG4gICAgICAgIGxldCBicmFuY2ggPSBzaWRlID09IDAgLyogRG9uZSAqLyA/IHRoaXMuZG9uZSA6IHRoaXMudW5kb25lO1xuICAgICAgICBpZiAoYnJhbmNoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBldmVudCA9IGJyYW5jaFticmFuY2gubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChzZWxlY3Rpb24gJiYgZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zZWxlY3Rpb25zQWZ0ZXJbZXZlbnQuc2VsZWN0aW9uc0FmdGVyLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3Q6IHBvcFNlbGVjdGlvbihicmFuY2gpIH0pLFxuICAgICAgICAgICAgICAgIHVzZXJFdmVudDogc2lkZSA9PSAwIC8qIERvbmUgKi8gPyBcInNlbGVjdC51bmRvXCIgOiBcInNlbGVjdC5yZWRvXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFldmVudC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN0ID0gYnJhbmNoLmxlbmd0aCA9PSAxID8gbm9uZSA6IGJyYW5jaC5zbGljZSgwLCBicmFuY2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBpZiAoZXZlbnQubWFwcGVkKVxuICAgICAgICAgICAgICAgIHJlc3QgPSBhZGRNYXBwaW5nVG9CcmFuY2gocmVzdCwgZXZlbnQubWFwcGVkKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IGV2ZW50LmNoYW5nZXMsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBldmVudC5zdGFydFNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBlZmZlY3RzOiBldmVudC5lZmZlY3RzLFxuICAgICAgICAgICAgICAgIGFubm90YXRpb25zOiBmcm9tSGlzdG9yeS5vZih7IHNpZGUsIHJlc3QgfSksXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQ6IHNpZGUgPT0gMCAvKiBEb25lICovID8gXCJ1bmRvXCIgOiBcInJlZG9cIixcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5IaXN0b3J5U3RhdGUuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IEhpc3RvcnlTdGF0ZShub25lLCBub25lKTtcbi8qKlxuRGVmYXVsdCBrZXkgYmluZGluZ3MgZm9yIHRoZSB1bmRvIGhpc3RvcnkuXG5cbi0gTW9kLXo6IFtgdW5kb2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKS5cbi0gTW9kLXkgKE1vZC1TaGlmdC16IG9uIG1hY09TKTogW2ByZWRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaXN0b3J5LnJlZG8pLlxuLSBNb2QtdTogW2B1bmRvU2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNoaXN0b3J5LnVuZG9TZWxlY3Rpb24pLlxuLSBBbHQtdSAoTW9kLVNoaWZ0LXUgb24gbWFjT1MpOiBbYHJlZG9TZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2hpc3RvcnkucmVkb1NlbGVjdGlvbikuXG4qL1xuY29uc3QgaGlzdG9yeUtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtelwiLCBydW46IHVuZG8sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiTW9kLXlcIiwgbWFjOiBcIk1vZC1TaGlmdC16XCIsIHJ1bjogcmVkbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJNb2QtdVwiLCBydW46IHVuZG9TZWxlY3Rpb24sIHByZXZlbnREZWZhdWx0OiB0cnVlIH0sXG4gICAgeyBrZXk6IFwiQWx0LXVcIiwgbWFjOiBcIk1vZC1TaGlmdC11XCIsIHJ1bjogcmVkb1NlbGVjdGlvbiwgcHJldmVudERlZmF1bHQ6IHRydWUgfVxuXTtcblxuZXhwb3J0IHsgaGlzdG9yeSwgaGlzdG9yeUZpZWxkLCBoaXN0b3J5S2V5bWFwLCBpbnZlcnRlZEVmZmVjdHMsIGlzb2xhdGVIaXN0b3J5LCByZWRvLCByZWRvRGVwdGgsIHJlZG9TZWxlY3Rpb24sIHVuZG8sIHVuZG9EZXB0aCwgdW5kb1NlbGVjdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/history/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/rangeset/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@codemirror/rangeset/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Range\": function() { return /* binding */ Range; },\n/* harmony export */   \"RangeSet\": function() { return /* binding */ RangeSet; },\n/* harmony export */   \"RangeSetBuilder\": function() { return /* binding */ RangeSetBuilder; },\n/* harmony export */   \"RangeValue\": function() { return /* binding */ RangeValue; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\n\nvar RangeValue = /*#__PURE__*/function () {\n  function RangeValue() {\n    _classCallCheck(this, RangeValue);\n  }\n\n  _createClass(RangeValue, [{\n    key: \"eq\",\n    value:\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    function eq(other) {\n      return this == other;\n    }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n\n  }, {\n    key: \"range\",\n    value: function range(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      return new Range(from, to, this);\n    }\n  }]);\n\n  return RangeValue;\n}();\n\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_0__.MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\n\nvar Range =\n/**\n@internal\n*/\nfunction Range(\n/**\nThe range's start position.\n*/\nfrom,\n/**\nIts end position.\n*/\nto,\n/**\nThe value associated with this range.\n*/\nvalue) {\n  _classCallCheck(this, Range);\n\n  this.from = from;\n  this.to = to;\n  this.value = value;\n};\n\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n\nvar Chunk = /*#__PURE__*/function () {\n  function Chunk(from, to, value, // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    _classCallCheck(this, Chunk);\n\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n\n  _createClass(Chunk, [{\n    key: \"length\",\n    get: function get() {\n      return this.to[this.to.length - 1];\n    } // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos, side, end) {\n      var startAt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var arr = end ? this.to : this.from;\n\n      for (var lo = startAt, hi = arr.length;;) {\n        if (lo == hi) return lo;\n        var mid = lo + hi >> 1;\n        var diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n        if (mid == lo) return diff >= 0 ? lo : hi;\n        if (diff >= 0) hi = mid;else lo = mid + 1;\n      }\n    }\n  }, {\n    key: \"between\",\n    value: function between(offset, from, to, f) {\n      for (var i = this.findIndex(from, -1000000000\n      /* Far */\n      , true), e = this.findIndex(to, 1000000000\n      /* Far */\n      , false, i); i < e; i++) {\n        if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(offset, changes) {\n      var value = [],\n          from = [],\n          to = [],\n          newPos = -1,\n          maxPoint = -1;\n\n      for (var i = 0; i < this.value.length; i++) {\n        var val = this.value[i],\n            curFrom = this.from[i] + offset,\n            curTo = this.to[i] + offset,\n            newFrom = void 0,\n            newTo = void 0;\n\n        if (curFrom == curTo) {\n          var mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n          if (mapped == null) continue;\n          newFrom = newTo = mapped;\n\n          if (val.startSide != val.endSide) {\n            newTo = changes.mapPos(curFrom, val.endSide);\n            if (newTo < newFrom) continue;\n          }\n        } else {\n          newFrom = changes.mapPos(curFrom, val.startSide);\n          newTo = changes.mapPos(curTo, val.endSide);\n          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n        }\n\n        if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n        if (newPos < 0) newPos = newFrom;\n        if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n        value.push(val);\n        from.push(newFrom - newPos);\n        to.push(newTo - newPos);\n      }\n\n      return {\n        mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n        pos: newPos\n      };\n    }\n  }]);\n\n  return Chunk;\n}();\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\n\n\nvar RangeSet = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function RangeSet(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk) {\n    var nextLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeSet.empty;\n    var\n    /**\n    @internal\n    */\n    maxPoint = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, RangeSet);\n\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n\n\n  _createClass(RangeSet, [{\n    key: \"length\",\n    get: function get() {\n      var last = this.chunk.length - 1;\n      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this.isEmpty) return 0;\n      var size = this.nextLayer.size;\n\n      var _iterator = _createForOfIteratorHelper(this.chunk),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chunk = _step.value;\n          size += chunk.value.length;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return size;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"chunkEnd\",\n    value: function chunkEnd(index) {\n      return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n\n  }, {\n    key: \"update\",\n    value: function update(updateSpec) {\n      var _updateSpec$add = updateSpec.add,\n          add = _updateSpec$add === void 0 ? [] : _updateSpec$add,\n          _updateSpec$sort = updateSpec.sort,\n          sort = _updateSpec$sort === void 0 ? false : _updateSpec$sort,\n          _updateSpec$filterFro = updateSpec.filterFrom,\n          filterFrom = _updateSpec$filterFro === void 0 ? 0 : _updateSpec$filterFro,\n          _updateSpec$filterTo = updateSpec.filterTo,\n          filterTo = _updateSpec$filterTo === void 0 ? this.length : _updateSpec$filterTo;\n      var filter = updateSpec.filter;\n      if (add.length == 0 && !filter) return this;\n      if (sort) add.slice().sort(cmpRange);\n      if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n      var cur = new LayerCursor(this, null, -1)[\"goto\"](0),\n          i = 0,\n          spill = [];\n      var builder = new RangeSetBuilder();\n\n      while (cur.value || i < add.length) {\n        if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n          var range = add[i++];\n          if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n        } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n          cur.nextChunk();\n        } else {\n          if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n            if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));\n          }\n\n          cur.next();\n        }\n      }\n\n      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n        add: spill,\n        filter: filter,\n        filterFrom: filterFrom,\n        filterTo: filterTo\n      }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n\n  }, {\n    key: \"map\",\n    value: function map(changes) {\n      if (changes.length == 0 || this.isEmpty) return this;\n      var chunks = [],\n          chunkPos = [],\n          maxPoint = -1;\n\n      for (var i = 0; i < this.chunk.length; i++) {\n        var start = this.chunkPos[i],\n            chunk = this.chunk[i];\n        var touch = changes.touchesRange(start, start + chunk.length);\n\n        if (touch === false) {\n          maxPoint = Math.max(maxPoint, chunk.maxPoint);\n          chunks.push(chunk);\n          chunkPos.push(changes.mapPos(start));\n        } else if (touch === true) {\n          var _chunk$map = chunk.map(start, changes),\n              mapped = _chunk$map.mapped,\n              pos = _chunk$map.pos;\n\n          if (mapped) {\n            maxPoint = Math.max(maxPoint, mapped.maxPoint);\n            chunks.push(mapped);\n            chunkPos.push(pos);\n          }\n        }\n      }\n\n      var next = this.nextLayer.map(changes);\n      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n\n  }, {\n    key: \"between\",\n    value: function between(from, to, f) {\n      if (this.isEmpty) return;\n\n      for (var i = 0; i < this.chunk.length; i++) {\n        var start = this.chunkPos[i],\n            chunk = this.chunk[i];\n        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n      }\n\n      this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n\n  }, {\n    key: \"iter\",\n    value: function iter() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return HeapCursor.from([this])[\"goto\"](from);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.nextLayer == this;\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n\n  }], [{\n    key: \"iter\",\n    value: function iter(sets) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return HeapCursor.from(sets)[\"goto\"](from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n\n  }, {\n    key: \"compare\",\n    value: function compare(oldSets, newSets,\n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator) {\n      var minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n      var a = oldSets.filter(function (set) {\n        return set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize;\n      });\n      var b = newSets.filter(function (set) {\n        return set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize;\n      });\n      var sharedChunks = findSharedChunks(a, b, textDiff);\n      var sideA = new SpanCursor(a, sharedChunks, minPointSize);\n      var sideB = new SpanCursor(b, sharedChunks, minPointSize);\n      textDiff.iterGaps(function (fromA, fromB, length) {\n        return _compare(sideA, fromA, sideB, fromB, length, comparator);\n      });\n      if (textDiff.empty && textDiff.length == 0) _compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n\n  }, {\n    key: \"eq\",\n    value: function eq(oldSets, newSets) {\n      var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var to = arguments.length > 3 ? arguments[3] : undefined;\n      if (to == null) to = 1000000000\n      /* Far */\n      ;\n      var a = oldSets.filter(function (set) {\n        return !set.isEmpty && newSets.indexOf(set) < 0;\n      });\n      var b = newSets.filter(function (set) {\n        return !set.isEmpty && oldSets.indexOf(set) < 0;\n      });\n      if (a.length != b.length) return false;\n      if (!a.length) return true;\n      var sharedChunks = findSharedChunks(a, b);\n      var sideA = new SpanCursor(a, sharedChunks, 0)[\"goto\"](from),\n          sideB = new SpanCursor(b, sharedChunks, 0)[\"goto\"](from);\n\n      for (;;) {\n        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n        if (sideA.to > to) return true;\n        sideA.next();\n        sideB.next();\n      }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n\n  }, {\n    key: \"spans\",\n    value: function spans(sets, from, to, iterator) {\n      var minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n      var _a;\n\n      var cursor = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator))[\"goto\"](from),\n          pos = from;\n      var open = cursor.openStart;\n\n      for (;;) {\n        var curTo = Math.min(cursor.to, to);\n\n        if (cursor.point) {\n          iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n          open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n        } else if (curTo > pos) {\n          iterator.span(pos, curTo, cursor.active, open);\n          open = cursor.openEnd(curTo);\n        }\n\n        if (cursor.to > to) break;\n        pos = cursor.to;\n        cursor.next();\n      }\n\n      return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n\n  }, {\n    key: \"of\",\n    value: function of(ranges) {\n      var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var build = new RangeSetBuilder();\n\n      var _iterator2 = _createForOfIteratorHelper(ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var range = _step2.value;\n          build.add(range.from, range.to, range.value);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return build.finish();\n    }\n  }]);\n\n  return RangeSet;\n}();\n/**\nThe empty set of ranges.\n*/\n\n\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\n\nfunction lazySort(ranges) {\n  if (ranges.length > 1) for (var prev = ranges[0], i = 1; i < ranges.length; i++) {\n    var cur = ranges[i];\n    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n    prev = cur;\n  }\n  return ranges;\n}\n\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\n\nvar RangeSetBuilder = /*#__PURE__*/function () {\n  /**\n  Create an empty builder.\n  */\n  function RangeSetBuilder() {\n    _classCallCheck(this, RangeSetBuilder);\n\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000\n    /* Far */\n    ;\n    this.lastTo = -1000000000\n    /* Far */\n    ;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n\n  _createClass(RangeSetBuilder, [{\n    key: \"finishChunk\",\n    value: function finishChunk(newArrays) {\n      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n      this.chunkPos.push(this.chunkStart);\n      this.chunkStart = -1;\n      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n      this.maxPoint = -1;\n\n      if (newArrays) {\n        this.from = [];\n        this.to = [];\n        this.value = [];\n      }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n\n  }, {\n    key: \"add\",\n    value: function add(from, to, value) {\n      if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"addInner\",\n    value: function addInner(from, to, value) {\n      var diff = from - this.lastTo || value.startSide - this.last.endSide;\n      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n      if (diff < 0) return false;\n      if (this.from.length == 250\n      /* ChunkSize */\n      ) this.finishChunk(true);\n      if (this.chunkStart < 0) this.chunkStart = from;\n      this.from.push(from - this.chunkStart);\n      this.to.push(to - this.chunkStart);\n      this.last = value;\n      this.lastFrom = from;\n      this.lastTo = to;\n      this.value.push(value);\n      if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n      return true;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"addChunk\",\n    value: function addChunk(from, chunk) {\n      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n      if (this.from.length) this.finishChunk(true);\n      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n      this.chunks.push(chunk);\n      this.chunkPos.push(from);\n      var last = chunk.value.length - 1;\n      this.last = chunk.value[last];\n      this.lastFrom = chunk.from[last] + from;\n      this.lastTo = chunk.to[last] + from;\n      return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return this.finishInner(RangeSet.empty);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"finishInner\",\n    value: function finishInner(next) {\n      if (this.from.length) this.finishChunk(false);\n      if (this.chunks.length == 0) return next;\n      var result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n      this.from = null; // Make sure further `add` calls produce errors\n\n      return result;\n    }\n  }]);\n\n  return RangeSetBuilder;\n}();\n\nfunction findSharedChunks(a, b, textDiff) {\n  var inA = new Map();\n\n  var _iterator3 = _createForOfIteratorHelper(a),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var set = _step3.value;\n\n      for (var i = 0; i < set.chunk.length; i++) {\n        if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var shared = new Set();\n\n  var _iterator4 = _createForOfIteratorHelper(b),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _set = _step4.value;\n\n      for (var _i = 0; _i < _set.chunk.length; _i++) {\n        var known = inA.get(_set.chunk[_i]);\n        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == _set.chunkPos[_i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + _set.chunk[_i].length))) shared.add(_set.chunk[_i]);\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return shared;\n}\n\nvar LayerCursor = /*#__PURE__*/function () {\n  function LayerCursor(layer, skip, minPoint) {\n    var rank = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, LayerCursor);\n\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n\n  _createClass(LayerCursor, [{\n    key: \"startSide\",\n    get: function get() {\n      return this.value ? this.value.startSide : 0;\n    }\n  }, {\n    key: \"endSide\",\n    get: function get() {\n      return this.value ? this.value.endSide : 0;\n    }\n  }, {\n    key: \"goto\",\n    value: function goto(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n      this.chunkIndex = this.rangeIndex = 0;\n      this.gotoInner(pos, side, false);\n      return this;\n    }\n  }, {\n    key: \"gotoInner\",\n    value: function gotoInner(pos, side, forward) {\n      while (this.chunkIndex < this.layer.chunk.length) {\n        var next = this.layer.chunk[this.chunkIndex];\n        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n        this.chunkIndex++;\n        forward = false;\n      }\n\n      if (this.chunkIndex < this.layer.chunk.length) {\n        var rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n        if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n      }\n\n      this.next();\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(pos, side) {\n      if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (;;) {\n        if (this.chunkIndex == this.layer.chunk.length) {\n          this.from = this.to = 1000000000\n          /* Far */\n          ;\n          this.value = null;\n          break;\n        } else {\n          var chunkPos = this.layer.chunkPos[this.chunkIndex],\n              chunk = this.layer.chunk[this.chunkIndex];\n          var from = chunkPos + chunk.from[this.rangeIndex];\n          this.from = from;\n          this.to = chunkPos + chunk.to[this.rangeIndex];\n          this.value = chunk.value[this.rangeIndex];\n          this.setRangeIndex(this.rangeIndex + 1);\n          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n        }\n      }\n    }\n  }, {\n    key: \"setRangeIndex\",\n    value: function setRangeIndex(index) {\n      if (index == this.layer.chunk[this.chunkIndex].value.length) {\n        this.chunkIndex++;\n\n        if (this.skip) {\n          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) {\n            this.chunkIndex++;\n          }\n        }\n\n        this.rangeIndex = 0;\n      } else {\n        this.rangeIndex = index;\n      }\n    }\n  }, {\n    key: \"nextChunk\",\n    value: function nextChunk() {\n      this.chunkIndex++;\n      this.rangeIndex = 0;\n      this.next();\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(other) {\n      return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n  }]);\n\n  return LayerCursor;\n}();\n\nvar HeapCursor = /*#__PURE__*/function () {\n  function HeapCursor(heap) {\n    _classCallCheck(this, HeapCursor);\n\n    this.heap = heap;\n  }\n\n  _createClass(HeapCursor, [{\n    key: \"startSide\",\n    get: function get() {\n      return this.value ? this.value.startSide : 0;\n    }\n  }, {\n    key: \"goto\",\n    value: function goto(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n\n      var _iterator5 = _createForOfIteratorHelper(this.heap),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var cur = _step5.value;\n          cur[\"goto\"](pos, side);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      for (var i = this.heap.length >> 1; i >= 0; i--) {\n        heapBubble(this.heap, i);\n      }\n\n      this.next();\n      return this;\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(pos, side) {\n      var _iterator6 = _createForOfIteratorHelper(this.heap),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var cur = _step6.value;\n          cur.forward(pos, side);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      for (var i = this.heap.length >> 1; i >= 0; i--) {\n        heapBubble(this.heap, i);\n      }\n\n      if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.heap.length == 0) {\n        this.from = this.to = 1000000000\n        /* Far */\n        ;\n        this.value = null;\n        this.rank = -1;\n      } else {\n        var top = this.heap[0];\n        this.from = top.from;\n        this.to = top.to;\n        this.value = top.value;\n        this.rank = top.rank;\n        if (top.value) top.next();\n        heapBubble(this.heap, 0);\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(sets) {\n      var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var minPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var heap = [];\n\n      for (var i = 0; i < sets.length; i++) {\n        for (var cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n          if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n        }\n      }\n\n      return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n  }]);\n\n  return HeapCursor;\n}();\n\nfunction heapBubble(heap, index) {\n  for (var cur = heap[index];;) {\n    var childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    var child = heap[childIndex];\n\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\n\nvar SpanCursor = /*#__PURE__*/function () {\n  function SpanCursor(sets, skip, minPoint) {\n    var filterPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function () {\n      return true;\n    };\n\n    _classCallCheck(this, SpanCursor);\n\n    this.minPoint = minPoint;\n    this.filterPoint = filterPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1; // A currently active point range, if any\n\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000\n    /* Far */\n    ;\n    this.endSide = 0;\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n\n  _createClass(SpanCursor, [{\n    key: \"goto\",\n    value: function goto(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n      this.cursor[\"goto\"](pos, side);\n      this.active.length = this.activeTo.length = this.activeRank.length = 0;\n      this.minActive = -1;\n      this.to = pos;\n      this.endSide = side;\n      this.openStart = -1;\n      this.next();\n      return this;\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(pos, side) {\n      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) {\n        this.removeActive(this.minActive);\n      }\n\n      this.cursor.forward(pos, side);\n    }\n  }, {\n    key: \"removeActive\",\n    value: function removeActive(index) {\n      remove(this.active, index);\n      remove(this.activeTo, index);\n      remove(this.activeRank, index);\n      this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n  }, {\n    key: \"addActive\",\n    value: function addActive(trackOpen) {\n      var i = 0,\n          _this$cursor = this.cursor,\n          value = _this$cursor.value,\n          to = _this$cursor.to,\n          rank = _this$cursor.rank;\n\n      while (i < this.activeRank.length && this.activeRank[i] <= rank) {\n        i++;\n      }\n\n      insert(this.active, i, value);\n      insert(this.activeTo, i, to);\n      insert(this.activeRank, i, rank);\n      if (trackOpen) insert(trackOpen, i, this.cursor.from);\n      this.minActive = findMinIndex(this.active, this.activeTo);\n    } // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      var from = this.to,\n          wasPoint = this.point;\n      this.point = null;\n      var trackOpen = this.openStart < 0 ? [] : null,\n          trackExtra = 0;\n\n      for (;;) {\n        var a = this.minActive;\n\n        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n          if (this.activeTo[a] > from) {\n            this.to = this.activeTo[a];\n            this.endSide = this.active[a].endSide;\n            break;\n          }\n\n          this.removeActive(a);\n          if (trackOpen) remove(trackOpen, a);\n        } else if (!this.cursor.value) {\n          this.to = this.endSide = 1000000000\n          /* Far */\n          ;\n          break;\n        } else if (this.cursor.from > from) {\n          this.to = this.cursor.from;\n          this.endSide = this.cursor.startSide;\n          break;\n        } else {\n          var nextVal = this.cursor.value;\n\n          if (!nextVal.point) {\n            // Opening a range\n            this.addActive(trackOpen);\n            this.cursor.next();\n          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n            // Ignore any non-empty points that end precisely at the end of the prev point\n            this.cursor.next();\n          } else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {\n            this.cursor.next();\n          } else {\n            // New point\n            this.point = nextVal;\n            this.pointFrom = this.cursor.from;\n            this.pointRank = this.cursor.rank;\n            this.to = this.cursor.to;\n            this.endSide = nextVal.endSide;\n            if (this.cursor.from < from) trackExtra = 1;\n            this.cursor.next();\n            if (this.to > from) this.forward(this.to, this.endSide);\n            break;\n          }\n        }\n      }\n\n      if (trackOpen) {\n        var openStart = 0;\n\n        while (openStart < trackOpen.length && trackOpen[openStart] < from) {\n          openStart++;\n        }\n\n        this.openStart = openStart + trackExtra;\n      }\n    }\n  }, {\n    key: \"activeForPoint\",\n    value: function activeForPoint(to) {\n      if (!this.active.length) return this.active;\n      var active = [];\n\n      for (var i = this.active.length - 1; i >= 0; i--) {\n        if (this.activeRank[i] < this.pointRank) break;\n        if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n      }\n\n      return active.reverse();\n    }\n  }, {\n    key: \"openEnd\",\n    value: function openEnd(to) {\n      var open = 0;\n\n      for (var i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) {\n        open++;\n      }\n\n      return open;\n    }\n  }]);\n\n  return SpanCursor;\n}();\n\nfunction _compare(a, startA, b, startB, length, comparator) {\n  a[\"goto\"](startA);\n  b[\"goto\"](startB);\n  var endB = startB + length;\n  var pos = startB,\n      dPos = startB - startA;\n\n  for (;;) {\n    var diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    var end = diff < 0 ? a.to + dPos : b.to,\n        clipEnd = Math.min(end, endB);\n\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\n\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction remove(array, index) {\n  for (var i = index, e = array.length - 1; i < e; i++) {\n    array[i] = array[i + 1];\n  }\n\n  array.pop();\n}\n\nfunction insert(array, index, value) {\n  for (var i = array.length - 1; i >= index; i--) {\n    array[i + 1] = array[i];\n  }\n\n  array[index] = value;\n}\n\nfunction findMinIndex(value, array) {\n  var found = -1,\n      foundPos = 1000000000\n  /* Far */\n  ;\n\n  for (var i = 0; i < array.length; i++) {\n    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n      found = i;\n      foundPos = array[i];\n    }\n  }\n\n  return found;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvcmFuZ2VzZXQvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUVBOzs7O0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFBQTtBQUhBO0FBQ0E7QUFDQTtBQUNBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBS0E7O0FBQ0E7O0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7OztBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFEQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFNQTs7QUFOQTtBQUFBOztBQUFBO0FBT0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQU5BO0FBUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFjQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOzs7O0FBV0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFEQTs7QUFFQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUEzQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBS0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3Jhbmdlc2V0L2Rpc3QvaW5kZXguanM/YzA2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXBNb2RlIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuXG4vKipcbkVhY2ggcmFuZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdmFsdWUsIHdoaWNoIG11c3QgaW5oZXJpdCBmcm9tXG50aGlzIGNsYXNzLlxuKi9cbmNsYXNzIFJhbmdlVmFsdWUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyB2YWx1ZSB3aXRoIGFub3RoZXIgdmFsdWUuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24gY29tcGFyZXMgYnkgaWRlbnRpdHkuXG4gICAgKi9cbiAgICBlcShvdGhlcikgeyByZXR1cm4gdGhpcyA9PSBvdGhlcjsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNyYW5nZXNldC5SYW5nZSkgd2l0aCB0aGlzIHZhbHVlLlxuICAgICovXG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7IHJldHVybiBuZXcgUmFuZ2UoZnJvbSwgdG8sIHRoaXMpOyB9XG59XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5zdGFydFNpZGUgPSBSYW5nZVZhbHVlLnByb3RvdHlwZS5lbmRTaWRlID0gMDtcblJhbmdlVmFsdWUucHJvdG90eXBlLnBvaW50ID0gZmFsc2U7XG5SYW5nZVZhbHVlLnByb3RvdHlwZS5tYXBNb2RlID0gTWFwTW9kZS5UcmFja0RlbDtcbi8qKlxuQSByYW5nZSBhc3NvY2lhdGVzIGEgdmFsdWUgd2l0aCBhIHJhbmdlIG9mIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSYW5nZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIEl0cyBlbmQgcG9zaXRpb24uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhbmdlLlxuICAgICovXG4gICAgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY21wUmFuZ2UoYSwgYikge1xuICAgIHJldHVybiBhLmZyb20gLSBiLmZyb20gfHwgYS52YWx1ZS5zdGFydFNpZGUgLSBiLnZhbHVlLnN0YXJ0U2lkZTtcbn1cbmNsYXNzIENodW5rIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bywgdmFsdWUsIFxuICAgIC8vIENodW5rcyBhcmUgbWFya2VkIHdpdGggdGhlIGxhcmdlc3QgcG9pbnQgdGhhdCBvY2N1cnNcbiAgICAvLyBpbiB0aGVtIChvciAtMSBmb3Igbm8gcG9pbnRzKSwgc28gdGhhdCBzY2FucyB0aGF0IGFyZVxuICAgIC8vIG9ubHkgaW50ZXJlc3RlZCBpbiBwb2ludHMgKHN1Y2ggYXMgdGhlXG4gICAgLy8gaGVpZ2h0bWFwLXJlbGF0ZWQgbG9naWMpIGNhbiBza2lwIHJhbmdlLW9ubHkgY2h1bmtzLlxuICAgIG1heFBvaW50KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLnRvW3RoaXMudG8ubGVuZ3RoIC0gMV07IH1cbiAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAgIC8vIGBmcm9tYCBwb3Mgd2hlbiBgZW5kID09IGZhbHNlYCwgYHRvYCB3aGVuIGBlbmQgPT0gdHJ1ZWAuXG4gICAgZmluZEluZGV4KHBvcywgc2lkZSwgZW5kLCBzdGFydEF0ID0gMCkge1xuICAgICAgICBsZXQgYXJyID0gZW5kID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbG8gPSBzdGFydEF0LCBoaSA9IGFyci5sZW5ndGg7Oykge1xuICAgICAgICAgICAgaWYgKGxvID09IGhpKVxuICAgICAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgICAgIGxldCBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYXJyW21pZF0gLSBwb3MgfHwgKGVuZCA/IHRoaXMudmFsdWVbbWlkXS5lbmRTaWRlIDogdGhpcy52YWx1ZVttaWRdLnN0YXJ0U2lkZSkgLSBzaWRlO1xuICAgICAgICAgICAgaWYgKG1pZCA9PSBsbylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiA+PSAwID8gbG8gOiBoaTtcbiAgICAgICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJldHdlZW4ob2Zmc2V0LCBmcm9tLCB0bywgZikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maW5kSW5kZXgoZnJvbSwgLTEwMDAwMDAwMDAgLyogRmFyICovLCB0cnVlKSwgZSA9IHRoaXMuZmluZEluZGV4KHRvLCAxMDAwMDAwMDAwIC8qIEZhciAqLywgZmFsc2UsIGkpOyBpIDwgZTsgaSsrKVxuICAgICAgICAgICAgaWYgKGYodGhpcy5mcm9tW2ldICsgb2Zmc2V0LCB0aGlzLnRvW2ldICsgb2Zmc2V0LCB0aGlzLnZhbHVlW2ldKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtYXAob2Zmc2V0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFtdLCBmcm9tID0gW10sIHRvID0gW10sIG5ld1BvcyA9IC0xLCBtYXhQb2ludCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLnZhbHVlW2ldLCBjdXJGcm9tID0gdGhpcy5mcm9tW2ldICsgb2Zmc2V0LCBjdXJUbyA9IHRoaXMudG9baV0gKyBvZmZzZXQsIG5ld0Zyb20sIG5ld1RvO1xuICAgICAgICAgICAgaWYgKGN1ckZyb20gPT0gY3VyVG8pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFwcGVkID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLnN0YXJ0U2lkZSwgdmFsLm1hcE1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IG5ld1RvID0gbWFwcGVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWwuc3RhcnRTaWRlICE9IHZhbC5lbmRTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyRnJvbSwgdmFsLmVuZFNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3VG8gPCBuZXdGcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3RnJvbSA9IGNoYW5nZXMubWFwUG9zKGN1ckZyb20sIHZhbC5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIG5ld1RvID0gY2hhbmdlcy5tYXBQb3MoY3VyVG8sIHZhbC5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RnJvbSA+IG5ld1RvIHx8IG5ld0Zyb20gPT0gbmV3VG8gJiYgdmFsLnN0YXJ0U2lkZSA+IDAgJiYgdmFsLmVuZFNpZGUgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5ld1RvIC0gbmV3RnJvbSB8fCB2YWwuZW5kU2lkZSAtIHZhbC5zdGFydFNpZGUpIDwgMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZXdQb3MgPCAwKVxuICAgICAgICAgICAgICAgIG5ld1BvcyA9IG5ld0Zyb207XG4gICAgICAgICAgICBpZiAodmFsLnBvaW50KVxuICAgICAgICAgICAgICAgIG1heFBvaW50ID0gTWF0aC5tYXgobWF4UG9pbnQsIG5ld1RvIC0gbmV3RnJvbSk7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICBmcm9tLnB1c2gobmV3RnJvbSAtIG5ld1Bvcyk7XG4gICAgICAgICAgICB0by5wdXNoKG5ld1RvIC0gbmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXBwZWQ6IHZhbHVlLmxlbmd0aCA/IG5ldyBDaHVuayhmcm9tLCB0bywgdmFsdWUsIG1heFBvaW50KSA6IG51bGwsIHBvczogbmV3UG9zIH07XG4gICAgfVxufVxuLyoqXG5BIHJhbmdlIHNldCBzdG9yZXMgYSBjb2xsZWN0aW9uIG9mIFtyYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jcmFuZ2VzZXQuUmFuZ2UpIGluIGFcbndheSB0aGF0IG1ha2VzIHRoZW0gZWZmaWNpZW50IHRvIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jcmFuZ2VzZXQuUmFuZ2VTZXQubWFwKSBhbmRcblt1cGRhdGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jcmFuZ2VzZXQuUmFuZ2VTZXQudXBkYXRlKS4gVGhpcyBpcyBhbiBpbW11dGFibGUgZGF0YVxuc3RydWN0dXJlLlxuKi9cbmNsYXNzIFJhbmdlU2V0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmtQb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2h1bmssIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dExheWVyID0gUmFuZ2VTZXQuZW1wdHksIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF4UG9pbnQpIHtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IGNodW5rUG9zO1xuICAgICAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gICAgICAgIHRoaXMubmV4dExheWVyID0gbmV4dExheWVyO1xuICAgICAgICB0aGlzLm1heFBvaW50ID0gbWF4UG9pbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmNodW5rLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBsYXN0IDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGxhc3QpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgICAgICBmb3IgKGxldCBjaHVuayBvZiB0aGlzLmNodW5rKVxuICAgICAgICAgICAgc2l6ZSArPSBjaHVuay52YWx1ZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNodW5rRW5kKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNodW5rUG9zW2luZGV4XSArIHRoaXMuY2h1bmtbaW5kZXhdLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gICAgb3V0IGV4aXN0aW5nIG9uZXMuXG4gICAgXG4gICAgKFRoZSBleHRyYSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgICBhcm91bmQgVHlwZVNjcmlwdCB2YXJpYW5jZSBpc3N1ZXMgdGhhdCBwcmV2ZW50ZWQgYFJhbmdlU2V0PFg+YFxuICAgIGZyb20gYmVpbmcgYSBzdWJ0eXBlIG9mIGBSYW5nZVNldDxZPmAgd2hlbiBgWGAgaXMgYSBzdWJ0eXBlIG9mXG4gICAgYFlgLilcbiAgICAqL1xuICAgIHVwZGF0ZSh1cGRhdGVTcGVjKSB7XG4gICAgICAgIGxldCB7IGFkZCA9IFtdLCBzb3J0ID0gZmFsc2UsIGZpbHRlckZyb20gPSAwLCBmaWx0ZXJUbyA9IHRoaXMubGVuZ3RoIH0gPSB1cGRhdGVTcGVjO1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBkYXRlU3BlYy5maWx0ZXI7XG4gICAgICAgIGlmIChhZGQubGVuZ3RoID09IDAgJiYgIWZpbHRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoc29ydClcbiAgICAgICAgICAgIGFkZC5zbGljZSgpLnNvcnQoY21wUmFuZ2UpO1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuIGFkZC5sZW5ndGggPyBSYW5nZVNldC5vZihhZGQpIDogdGhpcztcbiAgICAgICAgbGV0IGN1ciA9IG5ldyBMYXllckN1cnNvcih0aGlzLCBudWxsLCAtMSkuZ290bygwKSwgaSA9IDAsIHNwaWxsID0gW107XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAoY3VyLnZhbHVlIHx8IGkgPCBhZGQubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFkZC5sZW5ndGggJiYgKGN1ci5mcm9tIC0gYWRkW2ldLmZyb20gfHwgY3VyLnN0YXJ0U2lkZSAtIGFkZFtpXS52YWx1ZS5zdGFydFNpZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBhZGRbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAoIWJ1aWxkZXIuYWRkSW5uZXIocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXIucmFuZ2VJbmRleCA9PSAxICYmIGN1ci5jaHVua0luZGV4IDwgdGhpcy5jaHVuay5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAoaSA9PSBhZGQubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIDwgYWRkW2ldLmZyb20pICYmXG4gICAgICAgICAgICAgICAgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IHRoaXMuY2h1bmtFbmQoY3VyLmNodW5rSW5kZXgpIHx8IGZpbHRlclRvIDwgdGhpcy5jaHVua1Bvc1tjdXIuY2h1bmtJbmRleF0pICYmXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2N1ci5jaHVua0luZGV4XSwgdGhpcy5jaHVua1tjdXIuY2h1bmtJbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgY3VyLm5leHRDaHVuaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyRnJvbSA+IGN1ci50byB8fCBmaWx0ZXJUbyA8IGN1ci5mcm9tIHx8IGZpbHRlcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnVpbGRlci5hZGRJbm5lcihjdXIuZnJvbSwgY3VyLnRvLCBjdXIudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BpbGwucHVzaChuZXcgUmFuZ2UoY3VyLmZyb20sIGN1ci50bywgY3VyLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoSW5uZXIodGhpcy5uZXh0TGF5ZXIuaXNFbXB0eSAmJiAhc3BpbGwubGVuZ3RoID8gUmFuZ2VTZXQuZW1wdHlcbiAgICAgICAgICAgIDogdGhpcy5uZXh0TGF5ZXIudXBkYXRlKHsgYWRkOiBzcGlsbCwgZmlsdGVyLCBmaWx0ZXJGcm9tLCBmaWx0ZXJUbyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCB0aGlzIHJhbmdlIHNldCB0aHJvdWdoIGEgc2V0IG9mIGNoYW5nZXMsIHJldHVybiB0aGUgbmV3IHNldC5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IHRoaXMuaXNFbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY2h1bmtzID0gW10sIGNodW5rUG9zID0gW10sIG1heFBvaW50ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaHVuay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaHVua1Bvc1tpXSwgY2h1bmsgPSB0aGlzLmNodW5rW2ldO1xuICAgICAgICAgICAgbGV0IHRvdWNoID0gY2hhbmdlcy50b3VjaGVzUmFuZ2Uoc3RhcnQsIHN0YXJ0ICsgY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0b3VjaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBjaHVuay5tYXhQb2ludCk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGNodW5rUG9zLnB1c2goY2hhbmdlcy5tYXBQb3Moc3RhcnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWFwcGVkLCBwb3MgfSA9IGNodW5rLm1hcChzdGFydCwgY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXhQb2ludCA9IE1hdGgubWF4KG1heFBvaW50LCBtYXBwZWQubWF4UG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua1Bvcy5wdXNoKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5uZXh0TGF5ZXIubWFwKGNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA9PSAwID8gbmV4dCA6IG5ldyBSYW5nZVNldChjaHVua1BvcywgY2h1bmtzLCBuZXh0LCBtYXhQb2ludCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgICBjYWxsaW5nIGBmYCBmb3IgZWFjaC4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlcyB3aWxsXG4gICAgYmUgcmVwb3J0ZWQgaW4gYW55IHNwZWNpZmljIG9yZGVyLiBXaGVuIHRoZSBjYWxsYmFjayByZXR1cm5zXG4gICAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAgICovXG4gICAgYmV0d2Vlbihmcm9tLCB0bywgZikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuY2h1bmtQb3NbaV0sIGNodW5rID0gdGhpcy5jaHVua1tpXTtcbiAgICAgICAgICAgIGlmICh0byA+PSBzdGFydCAmJiBmcm9tIDw9IHN0YXJ0ICsgY2h1bmsubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY2h1bmsuYmV0d2VlbihzdGFydCwgZnJvbSAtIHN0YXJ0LCB0byAtIHN0YXJ0LCBmKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZnJvbSwgdG8sIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgICByYW5nZXMgdGhhdCBlbmQgYXQgb3IgYWZ0ZXIgYGZyb21gLlxuICAgICovXG4gICAgaXRlcihmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKFt0aGlzXSkuZ290byhmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHsgcmV0dXJuIHRoaXMubmV4dExheWVyID09IHRoaXM7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gICAgc3RhcnRpbmcgZnJvbSBgZnJvbWAuXG4gICAgKi9cbiAgICBzdGF0aWMgaXRlcihzZXRzLCBmcm9tID0gMCkge1xuICAgICAgICByZXR1cm4gSGVhcEN1cnNvci5mcm9tKHNldHMpLmdvdG8oZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgICB0byBub3RpZnkgaXQgb2YgcG9zc2libGUgZGlmZmVyZW5jZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZShvbGRTZXRzLCBuZXdTZXRzLCBcbiAgICAvKipcbiAgICBUaGlzIGluZGljYXRlcyBob3cgdGhlIHVuZGVybHlpbmcgZGF0YSBjaGFuZ2VkIGJldHdlZW4gdGhlc2VcbiAgICByYW5nZXMsIGFuZCBpcyBuZWVkZWQgdG8gc3luY2hyb25pemUgdGhlIGl0ZXJhdGlvbi4gYGZyb21gIGFuZFxuICAgIGB0b2AgYXJlIGNvb3JkaW5hdGVzIGluIHRoZSBfbmV3XyBzcGFjZSwgYWZ0ZXIgdGhlc2UgY2hhbmdlcy5cbiAgICAqL1xuICAgIHRleHREaWZmLCBjb21wYXJhdG9yLCBcbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBpZ25vcmUgYWxsIG5vbi1wb2ludCByYW5nZXMsIGFuZCBwb2ludHMgYmVsb3dcbiAgICB0aGUgZ2l2ZW4gc2l6ZS4gV2hlbiAtMSwgYWxsIHJhbmdlcyBhcmUgY29tcGFyZWQuXG4gICAgKi9cbiAgICBtaW5Qb2ludFNpemUgPSAtMSkge1xuICAgICAgICBsZXQgYSA9IG9sZFNldHMuZmlsdGVyKHNldCA9PiBzZXQubWF4UG9pbnQgPiAwIHx8ICFzZXQuaXNFbXB0eSAmJiBzZXQubWF4UG9pbnQgPj0gbWluUG9pbnRTaXplKTtcbiAgICAgICAgbGV0IGIgPSBuZXdTZXRzLmZpbHRlcihzZXQgPT4gc2V0Lm1heFBvaW50ID4gMCB8fCAhc2V0LmlzRW1wdHkgJiYgc2V0Lm1heFBvaW50ID49IG1pblBvaW50U2l6ZSk7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKTtcbiAgICAgICAgbGV0IHNpZGVBID0gbmV3IFNwYW5DdXJzb3IoYSwgc2hhcmVkQ2h1bmtzLCBtaW5Qb2ludFNpemUpO1xuICAgICAgICBsZXQgc2lkZUIgPSBuZXcgU3BhbkN1cnNvcihiLCBzaGFyZWRDaHVua3MsIG1pblBvaW50U2l6ZSk7XG4gICAgICAgIHRleHREaWZmLml0ZXJHYXBzKChmcm9tQSwgZnJvbUIsIGxlbmd0aCkgPT4gY29tcGFyZShzaWRlQSwgZnJvbUEsIHNpZGVCLCBmcm9tQiwgbGVuZ3RoLCBjb21wYXJhdG9yKSk7XG4gICAgICAgIGlmICh0ZXh0RGlmZi5lbXB0eSAmJiB0ZXh0RGlmZi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGNvbXBhcmUoc2lkZUEsIDAsIHNpZGVCLCAwLCAwLCBjb21wYXJhdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGUgY29udGVudHMgb2YgdHdvIGdyb3VwcyBvZiByYW5nZSBzZXRzLCByZXR1cm5pbmcgdHJ1ZVxuICAgIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQgaW4gdGhlIGdpdmVuIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIGVxKG9sZFNldHMsIG5ld1NldHMsIGZyb20gPSAwLCB0bykge1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gMTAwMDAwMDAwMCAvKiBGYXIgKi87XG4gICAgICAgIGxldCBhID0gb2xkU2V0cy5maWx0ZXIoc2V0ID0+ICFzZXQuaXNFbXB0eSAmJiBuZXdTZXRzLmluZGV4T2Yoc2V0KSA8IDApO1xuICAgICAgICBsZXQgYiA9IG5ld1NldHMuZmlsdGVyKHNldCA9PiAhc2V0LmlzRW1wdHkgJiYgb2xkU2V0cy5pbmRleE9mKHNldCkgPCAwKTtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzaGFyZWRDaHVua3MgPSBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIpO1xuICAgICAgICBsZXQgc2lkZUEgPSBuZXcgU3BhbkN1cnNvcihhLCBzaGFyZWRDaHVua3MsIDApLmdvdG8oZnJvbSksIHNpZGVCID0gbmV3IFNwYW5DdXJzb3IoYiwgc2hhcmVkQ2h1bmtzLCAwKS5nb3RvKGZyb20pO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoc2lkZUEudG8gIT0gc2lkZUIudG8gfHxcbiAgICAgICAgICAgICAgICAhc2FtZVZhbHVlcyhzaWRlQS5hY3RpdmUsIHNpZGVCLmFjdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICBzaWRlQS5wb2ludCAmJiAoIXNpZGVCLnBvaW50IHx8ICFzaWRlQS5wb2ludC5lcShzaWRlQi5wb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzaWRlQS50byA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc2lkZUEubmV4dCgpO1xuICAgICAgICAgICAgc2lkZUIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEl0ZXJhdGUgb3ZlciBhIGdyb3VwIG9mIHJhbmdlIHNldHMgYXQgdGhlIHNhbWUgdGltZSwgbm90aWZ5aW5nXG4gICAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgICBjb250ZW50LiBSZXR1cm5zIHRoZSBvcGVuIGNvdW50IChzZWVcbiAgICBbYFNwYW5JdGVyYXRvci5zcGFuYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNyYW5nZXNldC5TcGFuSXRlcmF0b3Iuc3BhbikpIGF0IHRoZSBlbmRcbiAgICBvZiB0aGUgaXRlcmF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHNwYW5zKHNldHMsIGZyb20sIHRvLCBpdGVyYXRvciwgXG4gICAgLyoqXG4gICAgV2hlbiBnaXZlbiBhbmQgZ3JlYXRlciB0aGFuIC0xLCBvbmx5IHBvaW50cyBvZiBhdCBsZWFzdCB0aGlzXG4gICAgc2l6ZSBhcmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICovXG4gICAgbWluUG9pbnRTaXplID0gLTEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY3Vyc29yID0gbmV3IFNwYW5DdXJzb3Ioc2V0cywgbnVsbCwgbWluUG9pbnRTaXplLCAoX2EgPSBpdGVyYXRvci5maWx0ZXJQb2ludCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaXRlcmF0b3IpKS5nb3RvKGZyb20pLCBwb3MgPSBmcm9tO1xuICAgICAgICBsZXQgb3BlbiA9IGN1cnNvci5vcGVuU3RhcnQ7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBjdXJUbyA9IE1hdGgubWluKGN1cnNvci50bywgdG8pO1xuICAgICAgICAgICAgaWYgKGN1cnNvci5wb2ludCkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnBvaW50KHBvcywgY3VyVG8sIGN1cnNvci5wb2ludCwgY3Vyc29yLmFjdGl2ZUZvclBvaW50KGN1cnNvci50byksIG9wZW4pO1xuICAgICAgICAgICAgICAgIG9wZW4gPSBjdXJzb3Iub3BlbkVuZChjdXJUbykgKyAoY3Vyc29yLnRvID4gY3VyVG8gPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJUbyA+IHBvcykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNwYW4ocG9zLCBjdXJUbywgY3Vyc29yLmFjdGl2ZSwgb3Blbik7XG4gICAgICAgICAgICAgICAgb3BlbiA9IGN1cnNvci5vcGVuRW5kKGN1clRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPiB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IGN1cnNvci50bztcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJhbmdlIHNldCBmb3IgdGhlIGdpdmVuIHJhbmdlIG9yIGFycmF5IG9mIHJhbmdlcy4gQnlcbiAgICBkZWZhdWx0LCB0aGlzIGV4cGVjdHMgdGhlIHJhbmdlcyB0byBiZSBfc29ydGVkXyAoYnkgc3RhcnRcbiAgICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgICBgdmFsdWUuc3RhcnRTaWRlYCkuIFlvdSBjYW4gcGFzcyBgdHJ1ZWAgYXMgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgY2F1c2UgdGhlIG1ldGhvZCB0byBzb3J0IHRoZW0uXG4gICAgKi9cbiAgICBzdGF0aWMgb2YocmFuZ2VzLCBzb3J0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGJ1aWxkID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCByYW5nZSBvZiByYW5nZXMgaW5zdGFuY2VvZiBSYW5nZSA/IFtyYW5nZXNdIDogc29ydCA/IGxhenlTb3J0KHJhbmdlcykgOiByYW5nZXMpXG4gICAgICAgICAgICBidWlsZC5hZGQocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkLmZpbmlzaCgpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiByYW5nZXMuXG4qL1xuUmFuZ2VTZXQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFJhbmdlU2V0KFtdLCBbXSwgbnVsbCwgLTEpO1xuZnVuY3Rpb24gbGF6eVNvcnQocmFuZ2VzKSB7XG4gICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICBmb3IgKGxldCBwcmV2ID0gcmFuZ2VzWzBdLCBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgIGlmIChjbXBSYW5nZShwcmV2LCBjdXIpID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2VzLnNsaWNlKCkuc29ydChjbXBSYW5nZSk7XG4gICAgICAgICAgICBwcmV2ID0gY3VyO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblJhbmdlU2V0LmVtcHR5Lm5leHRMYXllciA9IFJhbmdlU2V0LmVtcHR5O1xuLyoqXG5BIHJhbmdlIHNldCBidWlsZGVyIGlzIGEgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBoZWxwcyBidWlsZCB1cCBhXG5bcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3Jhbmdlc2V0LlJhbmdlU2V0KSBkaXJlY3RseSwgd2l0aG91dCBmaXJzdCBhbGxvY2F0aW5nXG5hbiBhcnJheSBvZiBbYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNyYW5nZXNldC5SYW5nZSkgb2JqZWN0cy5cbiovXG5jbGFzcyBSYW5nZVNldEJ1aWxkZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBlbXB0eSBidWlsZGVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtQb3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSAtMTAwMDAwMDAwMCAvKiBGYXIgKi87XG4gICAgICAgIHRoaXMubGFzdFRvID0gLTEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICB0aGlzLmZyb20gPSBbXTtcbiAgICAgICAgdGhpcy50byA9IFtdO1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRNYXhQb2ludCA9IC0xO1xuICAgICAgICB0aGlzLm5leHRMYXllciA9IG51bGw7XG4gICAgfVxuICAgIGZpbmlzaENodW5rKG5ld0FycmF5cykge1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBDaHVuayh0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMudmFsdWUsIHRoaXMubWF4UG9pbnQpKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKHRoaXMuY2h1bmtTdGFydCk7XG4gICAgICAgIHRoaXMuY2h1bmtTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgdGhpcy5tYXhQb2ludCk7XG4gICAgICAgIHRoaXMubWF4UG9pbnQgPSAtMTtcbiAgICAgICAgaWYgKG5ld0FycmF5cykge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gW107XG4gICAgICAgICAgICB0aGlzLnRvID0gW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgcmFuZ2UuIFJhbmdlcyBzaG91bGQgYmUgYWRkZWQgaW4gc29ydGVkIChieSBgZnJvbWAgYW5kXG4gICAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAgICovXG4gICAgYWRkKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSlcbiAgICAgICAgICAgICh0aGlzLm5leHRMYXllciB8fCAodGhpcy5uZXh0TGF5ZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKSkuYWRkKGZyb20sIHRvLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkSW5uZXIoZnJvbSwgdG8sIHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gZnJvbSAtIHRoaXMubGFzdFRvIHx8IHZhbHVlLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlO1xuICAgICAgICBpZiAoZGlmZiA8PSAwICYmIChmcm9tIC0gdGhpcy5sYXN0RnJvbSB8fCB2YWx1ZS5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICAgICAgaWYgKGRpZmYgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCA9PSAyNTAgLyogQ2h1bmtTaXplICovKVxuICAgICAgICAgICAgdGhpcy5maW5pc2hDaHVuayh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtTdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLmNodW5rU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmZyb20ucHVzaChmcm9tIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy50by5wdXNoKHRvIC0gdGhpcy5jaHVua1N0YXJ0KTtcbiAgICAgICAgdGhpcy5sYXN0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGFzdEZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxhc3RUbyA9IHRvO1xuICAgICAgICB0aGlzLnZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUucG9pbnQpXG4gICAgICAgICAgICB0aGlzLm1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5tYXhQb2ludCwgdG8gLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkQ2h1bmsoZnJvbSwgY2h1bmspIHtcbiAgICAgICAgaWYgKChmcm9tIC0gdGhpcy5sYXN0VG8gfHwgY2h1bmsudmFsdWVbMF0uc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGUpIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKHRydWUpO1xuICAgICAgICB0aGlzLnNldE1heFBvaW50ID0gTWF0aC5tYXgodGhpcy5zZXRNYXhQb2ludCwgY2h1bmsubWF4UG9pbnQpO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgdGhpcy5jaHVua1Bvcy5wdXNoKGZyb20pO1xuICAgICAgICBsZXQgbGFzdCA9IGNodW5rLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHRoaXMubGFzdCA9IGNodW5rLnZhbHVlW2xhc3RdO1xuICAgICAgICB0aGlzLmxhc3RGcm9tID0gY2h1bmsuZnJvbVtsYXN0XSArIGZyb207XG4gICAgICAgIHRoaXMubGFzdFRvID0gY2h1bmsudG9bbGFzdF0gKyBmcm9tO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gICAgdXNlZCBhbnltb3JlIGFmdGVyIHRoaXMgaGFzIGJlZW4gY2FsbGVkLlxuICAgICovXG4gICAgZmluaXNoKCkgeyByZXR1cm4gdGhpcy5maW5pc2hJbm5lcihSYW5nZVNldC5lbXB0eSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbmlzaElubmVyKG5leHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLmZpbmlzaENodW5rKGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgUmFuZ2VTZXQodGhpcy5jaHVua1BvcywgdGhpcy5jaHVua3MsIHRoaXMubmV4dExheWVyID8gdGhpcy5uZXh0TGF5ZXIuZmluaXNoSW5uZXIobmV4dCkgOiBuZXh0LCB0aGlzLnNldE1heFBvaW50KTtcbiAgICAgICAgdGhpcy5mcm9tID0gbnVsbDsgLy8gTWFrZSBzdXJlIGZ1cnRoZXIgYGFkZGAgY2FsbHMgcHJvZHVjZSBlcnJvcnNcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kU2hhcmVkQ2h1bmtzKGEsIGIsIHRleHREaWZmKSB7XG4gICAgbGV0IGluQSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0LmNodW5rW2ldLm1heFBvaW50IDw9IDApXG4gICAgICAgICAgICAgICAgaW5BLnNldChzZXQuY2h1bmtbaV0sIHNldC5jaHVua1Bvc1tpXSk7XG4gICAgbGV0IHNoYXJlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBzZXQgb2YgYilcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQuY2h1bmsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBrbm93biA9IGluQS5nZXQoc2V0LmNodW5rW2ldKTtcbiAgICAgICAgICAgIGlmIChrbm93biAhPSBudWxsICYmICh0ZXh0RGlmZiA/IHRleHREaWZmLm1hcFBvcyhrbm93bikgOiBrbm93bikgPT0gc2V0LmNodW5rUG9zW2ldICYmXG4gICAgICAgICAgICAgICAgISh0ZXh0RGlmZiA9PT0gbnVsbCB8fCB0ZXh0RGlmZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dERpZmYudG91Y2hlc1JhbmdlKGtub3duLCBrbm93biArIHNldC5jaHVua1tpXS5sZW5ndGgpKSlcbiAgICAgICAgICAgICAgICBzaGFyZWQuYWRkKHNldC5jaHVua1tpXSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gc2hhcmVkO1xufVxuY2xhc3MgTGF5ZXJDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGxheWVyLCBza2lwLCBtaW5Qb2ludCwgcmFuayA9IDApIHtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnNraXAgPSBza2lwO1xuICAgICAgICB0aGlzLm1pblBvaW50ID0gbWluUG9pbnQ7XG4gICAgICAgIHRoaXMucmFuayA9IHJhbms7XG4gICAgfVxuICAgIGdldCBzdGFydFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwOyB9XG4gICAgZ2V0IGVuZFNpZGUoKSB7IHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5lbmRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogRmFyICovKSB7XG4gICAgICAgIHRoaXMuY2h1bmtJbmRleCA9IHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZ290b0lubmVyKHBvcywgc2lkZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ290b0lubmVyKHBvcywgc2lkZSwgZm9yd2FyZCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5za2lwICYmIHRoaXMuc2tpcC5oYXMobmV4dCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyLmNodW5rRW5kKHRoaXMuY2h1bmtJbmRleCkgPCBwb3MgfHxcbiAgICAgICAgICAgICAgICBuZXh0Lm1heFBvaW50IDwgdGhpcy5taW5Qb2ludCkpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgICAgIGZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0luZGV4IDwgdGhpcy5sYXllci5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByYW5nZUluZGV4ID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLmZpbmRJbmRleChwb3MgLSB0aGlzLmxheWVyLmNodW5rUG9zW3RoaXMuY2h1bmtJbmRleF0sIHNpZGUsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFmb3J3YXJkIHx8IHRoaXMucmFuZ2VJbmRleCA8IHJhbmdlSW5kZXgpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHJhbmdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBpZiAoKHRoaXMudG8gLSBwb3MgfHwgdGhpcy5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5nb3RvSW5uZXIocG9zLCBzaWRlLCB0cnVlKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCA9PSB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxMDAwMDAwMDAwIC8qIEZhciAqLztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjaHVua1BvcyA9IHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgY2h1bmsgPSB0aGlzLmxheWVyLmNodW5rW3RoaXMuY2h1bmtJbmRleF07XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSBjaHVua1BvcyArIGNodW5rLmZyb21bdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICAgICAgICAgIHRoaXMudG8gPSBjaHVua1BvcyArIGNodW5rLnRvW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGNodW5rLnZhbHVlW3RoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSYW5nZUluZGV4KHRoaXMucmFuZ2VJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pblBvaW50IDwgMCB8fCB0aGlzLnZhbHVlLnBvaW50ICYmIHRoaXMudG8gLSB0aGlzLmZyb20gPj0gdGhpcy5taW5Qb2ludClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UmFuZ2VJbmRleChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoICYmIHRoaXMuc2tpcC5oYXModGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHVua0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dENodW5rKCkge1xuICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSAtIG90aGVyLmZyb20gfHwgdGhpcy5zdGFydFNpZGUgLSBvdGhlci5zdGFydFNpZGUgfHwgdGhpcy50byAtIG90aGVyLnRvIHx8IHRoaXMuZW5kU2lkZSAtIG90aGVyLmVuZFNpZGU7XG4gICAgfVxufVxuY2xhc3MgSGVhcEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaGVhcCkge1xuICAgICAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbShzZXRzLCBza2lwID0gbnVsbCwgbWluUG9pbnQgPSAtMSkge1xuICAgICAgICBsZXQgaGVhcCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGN1ciA9IHNldHNbaV07ICFjdXIuaXNFbXB0eTsgY3VyID0gY3VyLm5leHRMYXllcikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIubWF4UG9pbnQgPj0gbWluUG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIGhlYXAucHVzaChuZXcgTGF5ZXJDdXJzb3IoY3VyLCBza2lwLCBtaW5Qb2ludCwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFwLmxlbmd0aCA9PSAxID8gaGVhcFswXSA6IG5ldyBIZWFwQ3Vyc29yKGhlYXApO1xuICAgIH1cbiAgICBnZXQgc3RhcnRTaWRlKCkgeyByZXR1cm4gdGhpcy52YWx1ZSA/IHRoaXMudmFsdWUuc3RhcnRTaWRlIDogMDsgfVxuICAgIGdvdG8ocG9zLCBzaWRlID0gLTEwMDAwMDAwMDAgLyogRmFyICovKSB7XG4gICAgICAgIGZvciAobGV0IGN1ciBvZiB0aGlzLmhlYXApXG4gICAgICAgICAgICBjdXIuZ290byhwb3MsIHNpZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIGhlYXBCdWJibGUodGhpcy5oZWFwLCBpKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmb3J3YXJkKHBvcywgc2lkZSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgb2YgdGhpcy5oZWFwKVxuICAgICAgICAgICAgY3VyLmZvcndhcmQocG9zLCBzaWRlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhcC5sZW5ndGggPj4gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgaSk7XG4gICAgICAgIGlmICgodGhpcy50byAtIHBvcyB8fCB0aGlzLnZhbHVlLmVuZFNpZGUgLSBzaWRlKSA8IDApXG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJhbmsgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB0b3AuZnJvbTtcbiAgICAgICAgICAgIHRoaXMudG8gPSB0b3AudG87XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdG9wLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5yYW5rID0gdG9wLnJhbms7XG4gICAgICAgICAgICBpZiAodG9wLnZhbHVlKVxuICAgICAgICAgICAgICAgIHRvcC5uZXh0KCk7XG4gICAgICAgICAgICBoZWFwQnViYmxlKHRoaXMuaGVhcCwgMCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBoZWFwQnViYmxlKGhlYXAsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgY3VyID0gaGVhcFtpbmRleF07Oykge1xuICAgICAgICBsZXQgY2hpbGRJbmRleCA9IChpbmRleCA8PCAxKSArIDE7XG4gICAgICAgIGlmIChjaGlsZEluZGV4ID49IGhlYXAubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBjaGlsZCA9IGhlYXBbY2hpbGRJbmRleF07XG4gICAgICAgIGlmIChjaGlsZEluZGV4ICsgMSA8IGhlYXAubGVuZ3RoICYmIGNoaWxkLmNvbXBhcmUoaGVhcFtjaGlsZEluZGV4ICsgMV0pID49IDApIHtcbiAgICAgICAgICAgIGNoaWxkID0gaGVhcFtjaGlsZEluZGV4ICsgMV07XG4gICAgICAgICAgICBjaGlsZEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5jb21wYXJlKGNoaWxkKSA8IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaGVhcFtjaGlsZEluZGV4XSA9IGN1cjtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBjaGlsZDtcbiAgICAgICAgaW5kZXggPSBjaGlsZEluZGV4O1xuICAgIH1cbn1cbmNsYXNzIFNwYW5DdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNldHMsIHNraXAsIG1pblBvaW50LCBmaWx0ZXJQb2ludCA9ICgpID0+IHRydWUpIHtcbiAgICAgICAgdGhpcy5taW5Qb2ludCA9IG1pblBvaW50O1xuICAgICAgICB0aGlzLmZpbHRlclBvaW50ID0gZmlsdGVyUG9pbnQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlVG8gPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmVSYW5rID0gW107XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIC8vIEEgY3VycmVudGx5IGFjdGl2ZSBwb2ludCByYW5nZSwgaWYgYW55XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50RnJvbSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRSYW5rID0gMDtcbiAgICAgICAgdGhpcy50byA9IC0xMDAwMDAwMDAwIC8qIEZhciAqLztcbiAgICAgICAgdGhpcy5lbmRTaWRlID0gMDtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBIZWFwQ3Vyc29yLmZyb20oc2V0cywgc2tpcCwgbWluUG9pbnQpO1xuICAgIH1cbiAgICBnb3RvKHBvcywgc2lkZSA9IC0xMDAwMDAwMDAwIC8qIEZhciAqLykge1xuICAgICAgICB0aGlzLmN1cnNvci5nb3RvKHBvcywgc2lkZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlLmxlbmd0aCA9IHRoaXMuYWN0aXZlVG8ubGVuZ3RoID0gdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gLTE7XG4gICAgICAgIHRoaXMudG8gPSBwb3M7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IHNpZGU7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gLTE7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZm9yd2FyZChwb3MsIHNpZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMubWluQWN0aXZlID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bdGhpcy5taW5BY3RpdmVdIC0gcG9zIHx8IHRoaXMuYWN0aXZlW3RoaXMubWluQWN0aXZlXS5lbmRTaWRlIC0gc2lkZSkgPCAwKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmUodGhpcy5taW5BY3RpdmUpO1xuICAgICAgICB0aGlzLmN1cnNvci5mb3J3YXJkKHBvcywgc2lkZSk7XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZShpbmRleCkge1xuICAgICAgICByZW1vdmUodGhpcy5hY3RpdmUsIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlVG8sIGluZGV4KTtcbiAgICAgICAgcmVtb3ZlKHRoaXMuYWN0aXZlUmFuaywgaW5kZXgpO1xuICAgICAgICB0aGlzLm1pbkFjdGl2ZSA9IGZpbmRNaW5JbmRleCh0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gICAgfVxuICAgIGFkZEFjdGl2ZSh0cmFja09wZW4pIHtcbiAgICAgICAgbGV0IGkgPSAwLCB7IHZhbHVlLCB0bywgcmFuayB9ID0gdGhpcy5jdXJzb3I7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5hY3RpdmVSYW5rLmxlbmd0aCAmJiB0aGlzLmFjdGl2ZVJhbmtbaV0gPD0gcmFuaylcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgaW5zZXJ0KHRoaXMuYWN0aXZlLCBpLCB2YWx1ZSk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVRvLCBpLCB0byk7XG4gICAgICAgIGluc2VydCh0aGlzLmFjdGl2ZVJhbmssIGksIHJhbmspO1xuICAgICAgICBpZiAodHJhY2tPcGVuKVxuICAgICAgICAgICAgaW5zZXJ0KHRyYWNrT3BlbiwgaSwgdGhpcy5jdXJzb3IuZnJvbSk7XG4gICAgICAgIHRoaXMubWluQWN0aXZlID0gZmluZE1pbkluZGV4KHRoaXMuYWN0aXZlLCB0aGlzLmFjdGl2ZVRvKTtcbiAgICB9XG4gICAgLy8gQWZ0ZXIgY2FsbGluZyB0aGlzLCBpZiBgdGhpcy5wb2ludGAgIT0gbnVsbCwgdGhlIG5leHQgcmFuZ2UgaXMgYVxuICAgIC8vIHBvaW50LiBPdGhlcndpc2UsIGl0J3MgYSByZWd1bGFyIHJhbmdlLCBjb3ZlcmVkIGJ5IGB0aGlzLmFjdGl2ZWAuXG4gICAgbmV4dCgpIHtcbiAgICAgICAgbGV0IGZyb20gPSB0aGlzLnRvLCB3YXNQb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgdHJhY2tPcGVuID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsLCB0cmFja0V4dHJhID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IGEgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChhID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9bYV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2FdLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRvW2FdID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1thXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbYV0uZW5kU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKGEpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja09wZW4pXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZSh0cmFja09wZW4sIGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY3Vyc29yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IuZnJvbSA+IGZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdGhpcy5jdXJzb3IuZnJvbTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFZhbCA9IHRoaXMuY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFZhbC5wb2ludCkgeyAvLyBPcGVuaW5nIGEgcmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRBY3RpdmUodHJhY2tPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3YXNQb2ludCAmJiB0aGlzLmN1cnNvci50byA9PSB0aGlzLnRvICYmIHRoaXMuY3Vyc29yLmZyb20gPCB0aGlzLmN1cnNvci50bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYW55IG5vbi1lbXB0eSBwb2ludHMgdGhhdCBlbmQgcHJlY2lzZWx5IGF0IHRoZSBlbmQgb2YgdGhlIHByZXYgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5maWx0ZXJQb2ludCh0aGlzLmN1cnNvci5mcm9tLCB0aGlzLmN1cnNvci50bywgdGhpcy5jdXJzb3IudmFsdWUsIHRoaXMuY3Vyc29yLnJhbmspKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5ldyBwb2ludFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50ID0gbmV4dFZhbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbms7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRTaWRlID0gbmV4dFZhbC5lbmRTaWRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJzb3IuZnJvbSA8IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0V4dHJhID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmQodGhpcy50bywgdGhpcy5lbmRTaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFja09wZW4pIHtcbiAgICAgICAgICAgIGxldCBvcGVuU3RhcnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKG9wZW5TdGFydCA8IHRyYWNrT3Blbi5sZW5ndGggJiYgdHJhY2tPcGVuW29wZW5TdGFydF0gPCBmcm9tKVxuICAgICAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQgKyB0cmFja0V4dHJhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGl2ZUZvclBvaW50KHRvKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgICAgICBsZXQgYWN0aXZlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlUmFua1tpXSA8IHRoaXMucG9pbnRSYW5rKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVG9baV0gPiB0byB8fCB0aGlzLmFjdGl2ZVRvW2ldID09IHRvICYmIHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgPj0gdGhpcy5wb2ludC5lbmRTaWRlKVxuICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHRoaXMuYWN0aXZlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgb3BlbkVuZCh0bykge1xuICAgICAgICBsZXQgb3BlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW2ldID4gdG87IGktLSlcbiAgICAgICAgICAgIG9wZW4rKztcbiAgICAgICAgcmV0dXJuIG9wZW47XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZShhLCBzdGFydEEsIGIsIHN0YXJ0QiwgbGVuZ3RoLCBjb21wYXJhdG9yKSB7XG4gICAgYS5nb3RvKHN0YXJ0QSk7XG4gICAgYi5nb3RvKHN0YXJ0Qik7XG4gICAgbGV0IGVuZEIgPSBzdGFydEIgKyBsZW5ndGg7XG4gICAgbGV0IHBvcyA9IHN0YXJ0QiwgZFBvcyA9IHN0YXJ0QiAtIHN0YXJ0QTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBkaWZmID0gKGEudG8gKyBkUG9zKSAtIGIudG8gfHwgYS5lbmRTaWRlIC0gYi5lbmRTaWRlO1xuICAgICAgICBsZXQgZW5kID0gZGlmZiA8IDAgPyBhLnRvICsgZFBvcyA6IGIudG8sIGNsaXBFbmQgPSBNYXRoLm1pbihlbmQsIGVuZEIpO1xuICAgICAgICBpZiAoYS5wb2ludCB8fCBiLnBvaW50KSB7XG4gICAgICAgICAgICBpZiAoIShhLnBvaW50ICYmIGIucG9pbnQgJiYgKGEucG9pbnQgPT0gYi5wb2ludCB8fCBhLnBvaW50LmVxKGIucG9pbnQpKSAmJlxuICAgICAgICAgICAgICAgIHNhbWVWYWx1ZXMoYS5hY3RpdmVGb3JQb2ludChhLnRvICsgZFBvcyksIGIuYWN0aXZlRm9yUG9pbnQoYi50bykpKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVQb2ludChwb3MsIGNsaXBFbmQsIGEucG9pbnQsIGIucG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNsaXBFbmQgPiBwb3MgJiYgIXNhbWVWYWx1ZXMoYS5hY3RpdmUsIGIuYWN0aXZlKSlcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yLmNvbXBhcmVSYW5nZShwb3MsIGNsaXBFbmQsIGEuYWN0aXZlLCBiLmFjdGl2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA+IGVuZEIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICBpZiAoZGlmZiA8PSAwKVxuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIGlmIChkaWZmID49IDApXG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lVmFsdWVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhW2ldICE9IGJbaV0gJiYgIWFbaV0uZXEoYltpXSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBlID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA8IGU7IGkrKylcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpICsgMV07XG4gICAgYXJyYXkucG9wKCk7XG59XG5mdW5jdGlvbiBpbnNlcnQoYXJyYXksIGluZGV4LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IGluZGV4OyBpLS0pXG4gICAgICAgIGFycmF5W2kgKyAxXSA9IGFycmF5W2ldO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gZmluZE1pbkluZGV4KHZhbHVlLCBhcnJheSkge1xuICAgIGxldCBmb3VuZCA9IC0xLCBmb3VuZFBvcyA9IDEwMDAwMDAwMDAgLyogRmFyICovO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmICgoYXJyYXlbaV0gLSBmb3VuZFBvcyB8fCB2YWx1ZVtpXS5lbmRTaWRlIC0gdmFsdWVbZm91bmRdLmVuZFNpZGUpIDwgMCkge1xuICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgZm91bmRQb3MgPSBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZXhwb3J0IHsgUmFuZ2UsIFJhbmdlU2V0LCBSYW5nZVNldEJ1aWxkZXIsIFJhbmdlVmFsdWUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/rangeset/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@codemirror/state/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Text\": function() { return /* reexport safe */ _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text; },\n/* harmony export */   \"Annotation\": function() { return /* binding */ Annotation; },\n/* harmony export */   \"AnnotationType\": function() { return /* binding */ AnnotationType; },\n/* harmony export */   \"ChangeDesc\": function() { return /* binding */ ChangeDesc; },\n/* harmony export */   \"ChangeSet\": function() { return /* binding */ ChangeSet; },\n/* harmony export */   \"CharCategory\": function() { return /* binding */ CharCategory; },\n/* harmony export */   \"Compartment\": function() { return /* binding */ Compartment; },\n/* harmony export */   \"EditorSelection\": function() { return /* binding */ EditorSelection; },\n/* harmony export */   \"EditorState\": function() { return /* binding */ EditorState; },\n/* harmony export */   \"Facet\": function() { return /* binding */ Facet; },\n/* harmony export */   \"MapMode\": function() { return /* binding */ MapMode; },\n/* harmony export */   \"Prec\": function() { return /* binding */ Prec; },\n/* harmony export */   \"SelectionRange\": function() { return /* binding */ SelectionRange; },\n/* harmony export */   \"StateEffect\": function() { return /* binding */ StateEffect; },\n/* harmony export */   \"StateEffectType\": function() { return /* binding */ StateEffectType; },\n/* harmony export */   \"StateField\": function() { return /* binding */ StateField; },\n/* harmony export */   \"Transaction\": function() { return /* binding */ Transaction; },\n/* harmony export */   \"combineConfig\": function() { return /* binding */ combineConfig; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar DefaultSplit = /\\r\\n?|\\n/;\n/**\nDistinguishes different ways in which positions can be mapped.\n*/\n\nvar MapMode = /*@__PURE__*/function (MapMode) {\n  /**\n  Map a position to a valid new position, even when its context\n  was deleted.\n  */\n  MapMode[MapMode[\"Simple\"] = 0] = \"Simple\";\n  /**\n  Return null if deletion happens across the position.\n  */\n\n  MapMode[MapMode[\"TrackDel\"] = 1] = \"TrackDel\";\n  /**\n  Return null if the character _before_ the position is deleted.\n  */\n\n  MapMode[MapMode[\"TrackBefore\"] = 2] = \"TrackBefore\";\n  /**\n  Return null if the character _after_ the position is deleted.\n  */\n\n  MapMode[MapMode[\"TrackAfter\"] = 3] = \"TrackAfter\";\n  return MapMode;\n}(MapMode || (MapMode = {}));\n/**\nA change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)\nthat doesn't store the inserted text. As such, it can't be\napplied, but is cheaper to store and manipulate.\n*/\n\n\nvar ChangeDesc = /*#__PURE__*/function () {\n  // Sections are encoded as pairs of integers. The first is the\n  // length in the current document, and the second is -1 for\n  // unaffected sections, and the length of the replacement content\n  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n  // 0), and a replacement two positive numbers.\n\n  /**\n  @internal\n  */\n  function ChangeDesc(\n  /**\n  @internal\n  */\n  sections) {\n    _classCallCheck(this, ChangeDesc);\n\n    this.sections = sections;\n  }\n  /**\n  The length of the document before the change.\n  */\n\n\n  _createClass(ChangeDesc, [{\n    key: \"length\",\n    get: function get() {\n      var result = 0;\n\n      for (var i = 0; i < this.sections.length; i += 2) {\n        result += this.sections[i];\n      }\n\n      return result;\n    }\n    /**\n    The length of the document after the change.\n    */\n\n  }, {\n    key: \"newLength\",\n    get: function get() {\n      var result = 0;\n\n      for (var i = 0; i < this.sections.length; i += 2) {\n        var ins = this.sections[i + 1];\n        result += ins < 0 ? this.sections[i] : ins;\n      }\n\n      return result;\n    }\n    /**\n    False when there are actual changes in this set.\n    */\n\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n    }\n    /**\n    Iterate over the unchanged parts left by these changes.\n    */\n\n  }, {\n    key: \"iterGaps\",\n    value: function iterGaps(f) {\n      for (var i = 0, posA = 0, posB = 0; i < this.sections.length;) {\n        var len = this.sections[i++],\n            ins = this.sections[i++];\n\n        if (ins < 0) {\n          f(posA, posB, len);\n          posB += len;\n        } else {\n          posB += ins;\n        }\n\n        posA += len;\n      }\n    }\n    /**\n    Iterate over the ranges changed by these changes. (See\n    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n    variant that also provides you with the inserted text.)\n    \n    When `individual` is true, adjacent changes (which are kept\n    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n    reported separately.\n    */\n\n  }, {\n    key: \"iterChangedRanges\",\n    value: function iterChangedRanges(f) {\n      var individual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      _iterChanges(this, f, individual);\n    }\n    /**\n    Get a description of the inverted form of these changes.\n    */\n\n  }, {\n    key: \"invertedDesc\",\n    get: function get() {\n      var sections = [];\n\n      for (var i = 0; i < this.sections.length;) {\n        var len = this.sections[i++],\n            ins = this.sections[i++];\n        if (ins < 0) sections.push(len, ins);else sections.push(ins, len);\n      }\n\n      return new ChangeDesc(sections);\n    }\n    /**\n    Compute the combined effect of applying another set of changes\n    after this one. The length of the document after this set should\n    match the length before `other`.\n    */\n\n  }, {\n    key: \"composeDesc\",\n    value: function composeDesc(other) {\n      return this.empty ? other : other.empty ? this : composeSets(this, other);\n    }\n    /**\n    Map this description, which should start with the same document\n    as `other`, over another set of changes, so that it can be\n    applied after it. When `before` is true, map as if the changes\n    in `other` happened before the ones in `this`.\n    */\n\n  }, {\n    key: \"mapDesc\",\n    value: function mapDesc(other) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return other.empty ? this : mapSet(this, other, before);\n    }\n  }, {\n    key: \"mapPos\",\n    value: function mapPos(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : MapMode.Simple;\n      var posA = 0,\n          posB = 0;\n\n      for (var i = 0; i < this.sections.length;) {\n        var len = this.sections[i++],\n            ins = this.sections[i++],\n            endA = posA + len;\n\n        if (ins < 0) {\n          if (endA > pos) return posB + (pos - posA);\n          posB += len;\n        } else {\n          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;\n          if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;\n          posB += ins;\n        }\n\n        posA = endA;\n      }\n\n      if (pos > posA) throw new RangeError(\"Position \".concat(pos, \" is out of range for changeset of length \").concat(posA));\n      return posB;\n    }\n    /**\n    Check whether these changes touch a given range. When one of the\n    changes entirely covers the range, the string `\"cover\"` is\n    returned.\n    */\n\n  }, {\n    key: \"touchesRange\",\n    value: function touchesRange(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n\n      for (var i = 0, pos = 0; i < this.sections.length && pos <= to;) {\n        var len = this.sections[i++],\n            ins = this.sections[i++],\n            end = pos + len;\n        if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? \"cover\" : true;\n        pos = end;\n      }\n\n      return false;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var result = \"\";\n\n      for (var i = 0; i < this.sections.length;) {\n        var len = this.sections[i++],\n            ins = this.sections[i++];\n        result += (result ? \" \" : \"\") + len + (ins >= 0 ? \":\" + ins : \"\");\n      }\n\n      return result;\n    }\n    /**\n    Serialize this change desc to a JSON-representable value.\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.sections;\n    }\n    /**\n    Create a change desc from its JSON representation (as produced\n    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n    */\n\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      if (!Array.isArray(json) || json.length % 2 || json.some(function (a) {\n        return typeof a != \"number\";\n      })) throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n      return new ChangeDesc(json);\n    }\n  }]);\n\n  return ChangeDesc;\n}();\n/**\nA change set represents a group of modifications to a document. It\nstores the document length, and can only be applied to documents\nwith exactly that length.\n*/\n\n\nvar ChangeSet = /*#__PURE__*/function (_ChangeDesc) {\n  _inherits(ChangeSet, _ChangeDesc);\n\n  var _super = _createSuper(ChangeSet);\n\n  /**\n  @internal\n  */\n  function ChangeSet(sections,\n  /**\n  @internal\n  */\n  inserted) {\n    var _this;\n\n    _classCallCheck(this, ChangeSet);\n\n    _this = _super.call(this, sections);\n    _this.inserted = inserted;\n    return _this;\n  }\n  /**\n  Apply the changes to a document, returning the modified\n  document.\n  */\n\n\n  _createClass(ChangeSet, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.length != doc.length) throw new RangeError(\"Applying change set to a document with the wrong length\");\n\n      _iterChanges(this, function (fromA, toA, fromB, _toB, text) {\n        return doc = doc.replace(fromB, fromB + (toA - fromA), text);\n      }, false);\n\n      return doc;\n    }\n  }, {\n    key: \"mapDesc\",\n    value: function mapDesc(other) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return mapSet(this, other, before, true);\n    }\n    /**\n    Given the document as it existed _before_ the changes, return a\n    change set that represents the inverse of this set, which could\n    be used to go from the document created by the changes back to\n    the document as it existed before the changes.\n    */\n\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var sections = this.sections.slice(),\n          inserted = [];\n\n      for (var i = 0, pos = 0; i < sections.length; i += 2) {\n        var len = sections[i],\n            ins = sections[i + 1];\n\n        if (ins >= 0) {\n          sections[i] = ins;\n          sections[i + 1] = len;\n          var index = i >> 1;\n\n          while (inserted.length < index) {\n            inserted.push(_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n          }\n\n          inserted.push(len ? doc.slice(pos, pos + len) : _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n        }\n\n        pos += len;\n      }\n\n      return new ChangeSet(sections, inserted);\n    }\n    /**\n    Combine two subsequent change sets into a single set. `other`\n    must start in the document produced by `this`. If `this` goes\n    `docA` → `docB` and `other` represents `docB` → `docC`, the\n    returned value will represent the change `docA` → `docC`.\n    */\n\n  }, {\n    key: \"compose\",\n    value: function compose(other) {\n      return this.empty ? other : other.empty ? this : composeSets(this, other, true);\n    }\n    /**\n    Given another change set starting in the same document, maps this\n    change set over the other, producing a new change set that can be\n    applied to the document produced by applying `other`. When\n    `before` is `true`, order changes as if `this` comes before\n    `other`, otherwise (the default) treat `other` as coming first.\n    \n    Given two changes `A` and `B`, `A.compose(B.map(A))` and\n    `B.compose(A.map(B, true))` will produce the same document. This\n    provides a basic form of [operational\n    transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n    and can be used for collaborative editing.\n    */\n\n  }, {\n    key: \"map\",\n    value: function map(other) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return other.empty ? this : mapSet(this, other, before, true);\n    }\n    /**\n    Iterate over the changed ranges in the document, calling `f` for\n    each.\n    \n    When `individual` is true, adjacent changes are reported\n    separately.\n    */\n\n  }, {\n    key: \"iterChanges\",\n    value: function iterChanges(f) {\n      var individual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      _iterChanges(this, f, individual);\n    }\n    /**\n    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n    set.\n    */\n\n  }, {\n    key: \"desc\",\n    get: function get() {\n      return new ChangeDesc(this.sections);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"filter\",\n    value: function filter(ranges) {\n      var resultSections = [],\n          resultInserted = [],\n          filteredSections = [];\n      var iter = new SectionIter(this);\n\n      done: for (var i = 0, pos = 0;;) {\n        var next = i == ranges.length ? 1e9 : ranges[i++];\n\n        while (pos < next || pos == next && iter.len == 0) {\n          if (iter.done) break done;\n          var len = Math.min(iter.len, next - pos);\n          addSection(filteredSections, len, -1);\n          var ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;\n          addSection(resultSections, len, ins);\n          if (ins > 0) addInsert(resultInserted, resultSections, iter.text);\n          iter.forward(len);\n          pos += len;\n        }\n\n        var end = ranges[i++];\n\n        while (pos < end) {\n          if (iter.done) break done;\n\n          var _len = Math.min(iter.len, end - pos);\n\n          addSection(resultSections, _len, -1);\n          addSection(filteredSections, _len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);\n          iter.forward(_len);\n          pos += _len;\n        }\n      }\n\n      return {\n        changes: new ChangeSet(resultSections, resultInserted),\n        filtered: new ChangeDesc(filteredSections)\n      };\n    }\n    /**\n    Serialize this change set to a JSON-representable value.\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var parts = [];\n\n      for (var i = 0; i < this.sections.length; i += 2) {\n        var len = this.sections[i],\n            ins = this.sections[i + 1];\n        if (ins < 0) parts.push(len);else if (ins == 0) parts.push([len]);else parts.push([len].concat(this.inserted[i >> 1].toJSON()));\n      }\n\n      return parts;\n    }\n    /**\n    Create a change set for the given changes, for a document of the\n    given length, using `lineSep` as line separator.\n    */\n\n  }], [{\n    key: \"of\",\n    value: function of(changes, length, lineSep) {\n      var sections = [],\n          inserted = [],\n          pos = 0;\n      var total = null;\n\n      function flush() {\n        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        if (!force && !sections.length) return;\n        if (pos < length) addSection(sections, length - pos, -1);\n        var set = new ChangeSet(sections, inserted);\n        total = total ? total.compose(set.map(total)) : set;\n        sections = [];\n        inserted = [];\n        pos = 0;\n      }\n\n      function process(spec) {\n        if (Array.isArray(spec)) {\n          var _iterator = _createForOfIteratorHelper(spec),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var sub = _step.value;\n              process(sub);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else if (spec instanceof ChangeSet) {\n          if (spec.length != length) throw new RangeError(\"Mismatched change set length (got \".concat(spec.length, \", expected \").concat(length, \")\"));\n          flush();\n          total = total ? total.compose(spec.map(total)) : spec;\n        } else {\n          var from = spec.from,\n              _spec$to = spec.to,\n              to = _spec$to === void 0 ? from : _spec$to,\n              insert = spec.insert;\n          if (from > to || from < 0 || to > length) throw new RangeError(\"Invalid change range \".concat(from, \" to \").concat(to, \" (in doc of length \").concat(length, \")\"));\n          var insText = !insert ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty : typeof insert == \"string\" ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of(insert.split(lineSep || DefaultSplit)) : insert;\n          var insLen = insText.length;\n          if (from == to && insLen == 0) return;\n          if (from < pos) flush();\n          if (from > pos) addSection(sections, from - pos, -1);\n          addSection(sections, to - from, insLen);\n          addInsert(inserted, sections, insText);\n          pos = to;\n        }\n      }\n\n      process(changes);\n      flush(!total);\n      return total;\n    }\n    /**\n    Create an empty changeset of the given length.\n    */\n\n  }, {\n    key: \"empty\",\n    value: function empty(length) {\n      return new ChangeSet(length ? [length, -1] : [], []);\n    }\n    /**\n    Create a changeset from its JSON representation (as produced by\n    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n    */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      if (!Array.isArray(json)) throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n      var sections = [],\n          inserted = [];\n\n      for (var i = 0; i < json.length; i++) {\n        var part = json[i];\n\n        if (typeof part == \"number\") {\n          sections.push(part, -1);\n        } else if (!Array.isArray(part) || typeof part[0] != \"number\" || part.some(function (e, i) {\n          return i && typeof e != \"string\";\n        })) {\n          throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        } else if (part.length == 1) {\n          sections.push(part[0], 0);\n        } else {\n          while (inserted.length < i) {\n            inserted.push(_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n          }\n\n          inserted[i] = _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of(part.slice(1));\n          sections.push(part[0], inserted[i].length);\n        }\n      }\n\n      return new ChangeSet(sections, inserted);\n    }\n  }]);\n\n  return ChangeSet;\n}(ChangeDesc);\n\nfunction addSection(sections, len, ins) {\n  var forceJoin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (len == 0 && ins <= 0) return;\n  var last = sections.length - 2;\n  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;else if (len == 0 && sections[last] == 0) sections[last + 1] += ins;else if (forceJoin) {\n    sections[last] += len;\n    sections[last + 1] += ins;\n  } else sections.push(len, ins);\n}\n\nfunction addInsert(values, sections, value) {\n  if (value.length == 0) return;\n  var index = sections.length - 2 >> 1;\n\n  if (index < values.length) {\n    values[values.length - 1] = values[values.length - 1].append(value);\n  } else {\n    while (values.length < index) {\n      values.push(_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty);\n    }\n\n    values.push(value);\n  }\n}\n\nfunction _iterChanges(desc, f, individual) {\n  var inserted = desc.inserted;\n\n  for (var posA = 0, posB = 0, i = 0; i < desc.sections.length;) {\n    var len = desc.sections[i++],\n        ins = desc.sections[i++];\n\n    if (ins < 0) {\n      posA += len;\n      posB += len;\n    } else {\n      var endA = posA,\n          endB = posB,\n          text = _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty;\n\n      for (;;) {\n        endA += len;\n        endB += ins;\n        if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);\n        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;\n        len = desc.sections[i++];\n        ins = desc.sections[i++];\n      }\n\n      f(posA, endA, posB, endB, text);\n      posA = endA;\n      posB = endB;\n    }\n  }\n}\n\nfunction mapSet(setA, setB, before) {\n  var mkSet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var sections = [],\n      insert = mkSet ? [] : null;\n  var a = new SectionIter(setA),\n      b = new SectionIter(setB);\n\n  for (var posA = 0, posB = 0;;) {\n    if (a.ins == -1) {\n      posA += a.len;\n      a.next();\n    } else if (b.ins == -1 && posB < posA) {\n      var skip = Math.min(b.len, posA - posB);\n      b.forward(skip);\n      addSection(sections, skip, -1);\n      posB += skip;\n    } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {\n      addSection(sections, b.ins, -1);\n\n      while (posA > posB && !a.done && posA + a.len < posB + b.len) {\n        posA += a.len;\n        a.next();\n      }\n\n      posB += b.len;\n      b.next();\n    } else if (a.ins >= 0) {\n      var len = 0,\n          end = posA + a.len;\n\n      for (;;) {\n        if (b.ins >= 0 && posB > posA && posB + b.len < end) {\n          len += b.ins;\n          posB += b.len;\n          b.next();\n        } else if (b.ins == -1 && posB < end) {\n          var _skip = Math.min(b.len, end - posB);\n\n          len += _skip;\n          b.forward(_skip);\n          posB += _skip;\n        } else {\n          break;\n        }\n      }\n\n      addSection(sections, len, a.ins);\n      if (insert) addInsert(insert, sections, a.text);\n      posA = end;\n      a.next();\n    } else if (a.done && b.done) {\n      return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n    } else {\n      throw new Error(\"Mismatched change set lengths\");\n    }\n  }\n}\n\nfunction composeSets(setA, setB) {\n  var mkSet = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var sections = [];\n  var insert = mkSet ? [] : null;\n  var a = new SectionIter(setA),\n      b = new SectionIter(setB);\n\n  for (var open = false;;) {\n    if (a.done && b.done) {\n      return insert ? new ChangeSet(sections, insert) : new ChangeDesc(sections);\n    } else if (a.ins == 0) {\n      // Deletion in A\n      addSection(sections, a.len, 0, open);\n      a.next();\n    } else if (b.len == 0 && !b.done) {\n      // Insertion in B\n      addSection(sections, 0, b.ins, open);\n      if (insert) addInsert(insert, sections, b.text);\n      b.next();\n    } else if (a.done || b.done) {\n      throw new Error(\"Mismatched change set lengths\");\n    } else {\n      var len = Math.min(a.len2, b.len),\n          sectionLen = sections.length;\n\n      if (a.ins == -1) {\n        var insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;\n        addSection(sections, len, insB, open);\n        if (insert && insB) addInsert(insert, sections, b.text);\n      } else if (b.ins == -1) {\n        addSection(sections, a.off ? 0 : a.len, len, open);\n        if (insert) addInsert(insert, sections, a.textBit(len));\n      } else {\n        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);\n        if (insert && !b.off) addInsert(insert, sections, b.text);\n      }\n\n      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);\n      a.forward2(len);\n      b.forward(len);\n    }\n  }\n}\n\nvar SectionIter = /*#__PURE__*/function () {\n  function SectionIter(set) {\n    _classCallCheck(this, SectionIter);\n\n    this.set = set;\n    this.i = 0;\n    this.next();\n  }\n\n  _createClass(SectionIter, [{\n    key: \"next\",\n    value: function next() {\n      var sections = this.set.sections;\n\n      if (this.i < sections.length) {\n        this.len = sections[this.i++];\n        this.ins = sections[this.i++];\n      } else {\n        this.len = 0;\n        this.ins = -2;\n      }\n\n      this.off = 0;\n    }\n  }, {\n    key: \"done\",\n    get: function get() {\n      return this.ins == -2;\n    }\n  }, {\n    key: \"len2\",\n    get: function get() {\n      return this.ins < 0 ? this.len : this.ins;\n    }\n  }, {\n    key: \"text\",\n    get: function get() {\n      var inserted = this.set.inserted,\n          index = this.i - 2 >> 1;\n      return index >= inserted.length ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty : inserted[index];\n    }\n  }, {\n    key: \"textBit\",\n    value: function textBit(len) {\n      var inserted = this.set.inserted,\n          index = this.i - 2 >> 1;\n      return index >= inserted.length && !len ? _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);\n    }\n  }, {\n    key: \"forward\",\n    value: function forward(len) {\n      if (len == this.len) this.next();else {\n        this.len -= len;\n        this.off += len;\n      }\n    }\n  }, {\n    key: \"forward2\",\n    value: function forward2(len) {\n      if (this.ins == -1) this.forward(len);else if (len == this.ins) this.next();else {\n        this.ins -= len;\n        this.off += len;\n      }\n    }\n  }]);\n\n  return SectionIter;\n}();\n/**\nA single selection range. When\n[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\nis enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold\nmultiple ranges. By default, selections hold exactly one range.\n*/\n\n\nvar SelectionRange = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function SelectionRange(\n  /**\n  The lower boundary of the range.\n  */\n  from,\n  /**\n  The upper boundary of the range.\n  */\n  to, flags) {\n    _classCallCheck(this, SelectionRange);\n\n    this.from = from;\n    this.to = to;\n    this.flags = flags;\n  }\n  /**\n  The anchor of the range—the side that doesn't move when you\n  extend it.\n  */\n\n\n  _createClass(SelectionRange, [{\n    key: \"anchor\",\n    get: function get() {\n      return this.flags & 16\n      /* Inverted */\n      ? this.to : this.from;\n    }\n    /**\n    The head of the range, which is moved when the range is\n    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n    */\n\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.flags & 16\n      /* Inverted */\n      ? this.from : this.to;\n    }\n    /**\n    True when `anchor` and `head` are at the same position.\n    */\n\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.from == this.to;\n    }\n    /**\n    If this is a cursor that is explicitly associated with the\n    character on one of its sides, this returns the side. -1 means\n    the character before its position, 1 the character after, and 0\n    means no association.\n    */\n\n  }, {\n    key: \"assoc\",\n    get: function get() {\n      return this.flags & 4\n      /* AssocBefore */\n      ? -1 : this.flags & 8\n      /* AssocAfter */\n      ? 1 : 0;\n    }\n    /**\n    The bidirectional text level associated with this cursor, if\n    any.\n    */\n\n  }, {\n    key: \"bidiLevel\",\n    get: function get() {\n      var level = this.flags & 3\n      /* BidiLevelMask */\n      ;\n      return level == 3 ? null : level;\n    }\n    /**\n    The goal column (stored vertical offset) associated with a\n    cursor. This is used to preserve the vertical position when\n    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n    lines of different length.\n    */\n\n  }, {\n    key: \"goalColumn\",\n    get: function get() {\n      var value = this.flags >> 5\n      /* GoalColumnOffset */\n      ;\n      return value == 33554431\n      /* NoGoalColumn */\n      ? undefined : value;\n    }\n    /**\n    Map this range through a change, producing a valid range in the\n    updated document.\n    */\n\n  }, {\n    key: \"map\",\n    value: function map(change) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      var from = change.mapPos(this.from, assoc),\n          to = change.mapPos(this.to, assoc);\n      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);\n    }\n    /**\n    Extend this range to cover at least `from` to `to`.\n    */\n\n  }, {\n    key: \"extend\",\n    value: function extend(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);\n      var head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;\n      return EditorSelection.range(this.anchor, head);\n    }\n    /**\n    Compare this range to another range.\n    */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.anchor == other.anchor && this.head == other.head;\n    }\n    /**\n    Return a JSON-serializable object representing the range.\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        anchor: this.anchor,\n        head: this.head\n      };\n    }\n    /**\n    Convert a JSON representation of a range to a `SelectionRange`\n    instance.\n    */\n\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n      return EditorSelection.range(json.anchor, json.head);\n    }\n  }]);\n\n  return SelectionRange;\n}();\n/**\nAn editor selection holds one or more selection ranges.\n*/\n\n\nvar EditorSelection = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function EditorSelection(\n  /**\n  The ranges in the selection, sorted by position. Ranges cannot\n  overlap (but they may touch, if they aren't empty).\n  */\n  ranges) {\n    var mainIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, EditorSelection);\n\n    this.ranges = ranges;\n    this.mainIndex = mainIndex;\n  }\n  /**\n  Map a selection through a change. Used to adjust the selection\n  position for changes.\n  */\n\n\n  _createClass(EditorSelection, [{\n    key: \"map\",\n    value: function map(change) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      if (change.empty) return this;\n      return EditorSelection.create(this.ranges.map(function (r) {\n        return r.map(change, assoc);\n      }), this.mainIndex);\n    }\n    /**\n    Compare this selection to another selection.\n    */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (!this.ranges[i].eq(other.ranges[i])) return false;\n      }\n\n      return true;\n    }\n    /**\n    Get the primary selection range. Usually, you should make sure\n    your code applies to _all_ ranges, by using methods like\n    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n    */\n\n  }, {\n    key: \"main\",\n    get: function get() {\n      return this.ranges[this.mainIndex];\n    }\n    /**\n    Make sure the selection only has one range. Returns a selection\n    holding only the main range from this selection.\n    */\n\n  }, {\n    key: \"asSingle\",\n    value: function asSingle() {\n      return this.ranges.length == 1 ? this : new EditorSelection([this.main]);\n    }\n    /**\n    Extend this selection with an extra range.\n    */\n\n  }, {\n    key: \"addRange\",\n    value: function addRange(range) {\n      var main = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);\n    }\n    /**\n    Replace a given range with another range, and then normalize the\n    selection to merge and sort ranges if necessary.\n    */\n\n  }, {\n    key: \"replaceRange\",\n    value: function replaceRange(range) {\n      var which = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.mainIndex;\n      var ranges = this.ranges.slice();\n      ranges[which] = range;\n      return EditorSelection.create(ranges, this.mainIndex);\n    }\n    /**\n    Convert this selection to an object that can be serialized to\n    JSON.\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        ranges: this.ranges.map(function (r) {\n          return r.toJSON();\n        }),\n        main: this.mainIndex\n      };\n    }\n    /**\n    Create a selection from a JSON representation.\n    */\n\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      if (!json || !Array.isArray(json.ranges) || typeof json.main != \"number\" || json.main >= json.ranges.length) throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n      return new EditorSelection(json.ranges.map(function (r) {\n        return SelectionRange.fromJSON(r);\n      }), json.main);\n    }\n    /**\n    Create a selection holding a single range.\n    */\n\n  }, {\n    key: \"single\",\n    value: function single(anchor) {\n      var head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : anchor;\n      return new EditorSelection([EditorSelection.range(anchor, head)], 0);\n    }\n    /**\n    Sort and merge the given set of ranges, creating a valid\n    selection.\n    */\n\n  }, {\n    key: \"create\",\n    value: function create(ranges) {\n      var mainIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (ranges.length == 0) throw new RangeError(\"A selection needs at least one range\");\n\n      for (var pos = 0, i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty ? range.from <= pos : range.from < pos) return normalized(ranges.slice(), mainIndex);\n        pos = range.to;\n      }\n\n      return new EditorSelection(ranges, mainIndex);\n    }\n    /**\n    Create a cursor selection range at the given position. You can\n    safely ignore the optional arguments in most situations.\n    */\n\n  }, {\n    key: \"cursor\",\n    value: function cursor(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var bidiLevel = arguments.length > 2 ? arguments[2] : undefined;\n      var goalColumn = arguments.length > 3 ? arguments[3] : undefined;\n      return new SelectionRange(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4\n      /* AssocBefore */\n      : 8\n      /* AssocAfter */\n      ) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431\n      /* NoGoalColumn */\n      ) << 5\n      /* GoalColumnOffset */\n      );\n    }\n    /**\n    Create a selection range.\n    */\n\n  }, {\n    key: \"range\",\n    value: function range(anchor, head, goalColumn) {\n      var goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431\n      /* NoGoalColumn */\n      ) << 5\n      /* GoalColumnOffset */\n      ;\n      return head < anchor ? new SelectionRange(head, anchor, 16\n      /* Inverted */\n      | goal) : new SelectionRange(anchor, head, goal);\n    }\n  }]);\n\n  return EditorSelection;\n}();\n\nfunction normalized(ranges) {\n  var mainIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var main = ranges[mainIndex];\n  ranges.sort(function (a, b) {\n    return a.from - b.from;\n  });\n  mainIndex = ranges.indexOf(main);\n\n  for (var i = 1; i < ranges.length; i++) {\n    var range = ranges[i],\n        prev = ranges[i - 1];\n\n    if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n      var from = prev.from,\n          to = Math.max(range.to, prev.to);\n      if (i <= mainIndex) mainIndex--;\n      ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));\n    }\n  }\n\n  return new EditorSelection(ranges, mainIndex);\n}\n\nfunction checkSelection(selection, docLength) {\n  var _iterator2 = _createForOfIteratorHelper(selection.ranges),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var range = _step2.value;\n      if (range.to > docLength) throw new RangeError(\"Selection points outside of document\");\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nvar nextID = 0;\n/**\nA facet is a labeled value that is associated with an editor\nstate. It takes inputs from any number of extensions, and combines\nthose into a single output value.\n\nExamples of facets are the [theme](https://codemirror.net/6/docs/ref/#view.EditorView^theme) styles\nassociated with an editor or the [tab\nsize](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) (which is reduced to a single\nvalue, using the input with the hightest precedence).\n*/\n\nvar Facet = /*#__PURE__*/function () {\n  function Facet(\n  /**\n  @internal\n  */\n  combine,\n  /**\n  @internal\n  */\n  compareInput,\n  /**\n  @internal\n  */\n  compare, isStatic,\n  /**\n  @internal\n  */\n  extensions) {\n    _classCallCheck(this, Facet);\n\n    this.combine = combine;\n    this.compareInput = compareInput;\n    this.compare = compare;\n    this.isStatic = isStatic;\n    this.extensions = extensions;\n    /**\n    @internal\n    */\n\n    this.id = nextID++;\n    this[\"default\"] = combine([]);\n  }\n  /**\n  Define a new facet.\n  */\n\n\n  _createClass(Facet, [{\n    key: \"of\",\n    value:\n    /**\n    Returns an extension that adds the given value for this facet.\n    */\n    function of(value) {\n      return new FacetProvider([], this, 0\n      /* Static */\n      , value);\n    }\n    /**\n    Create an extension that computes a value for the facet from a\n    state. You must take care to declare the parts of the state that\n    this value depends on, since your function is only called again\n    for a new state when one of those parts changed.\n    \n    In most cases, you'll want to use the\n    [`provide`](https://codemirror.net/6/docs/ref/#state.StateField^define^config.provide) option when\n    defining a field instead.\n    */\n\n  }, {\n    key: \"compute\",\n    value: function compute(deps, get) {\n      if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n      return new FacetProvider(deps, this, 1\n      /* Single */\n      , get);\n    }\n    /**\n    Create an extension that computes zero or more values for this\n    facet from a state.\n    */\n\n  }, {\n    key: \"computeN\",\n    value: function computeN(deps, get) {\n      if (this.isStatic) throw new Error(\"Can't compute a static facet\");\n      return new FacetProvider(deps, this, 2\n      /* Multi */\n      , get);\n    }\n  }, {\n    key: \"from\",\n    value: function from(field, get) {\n      if (!get) get = function get(x) {\n        return x;\n      };\n      return this.compute([field], function (state) {\n        return get(state.field(field));\n      });\n    }\n  }], [{\n    key: \"define\",\n    value: function define() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Facet(config.combine || function (a) {\n        return a;\n      }, config.compareInput || function (a, b) {\n        return a === b;\n      }, config.compare || (!config.combine ? sameArray : function (a, b) {\n        return a === b;\n      }), !!config[\"static\"], config.enables);\n    }\n  }]);\n\n  return Facet;\n}();\n\nfunction sameArray(a, b) {\n  return a == b || a.length == b.length && a.every(function (e, i) {\n    return e === b[i];\n  });\n}\n\nvar FacetProvider = /*#__PURE__*/function () {\n  function FacetProvider(dependencies, facet, type, value) {\n    _classCallCheck(this, FacetProvider);\n\n    this.dependencies = dependencies;\n    this.facet = facet;\n    this.type = type;\n    this.value = value;\n    this.id = nextID++;\n  }\n\n  _createClass(FacetProvider, [{\n    key: \"dynamicSlot\",\n    value: function dynamicSlot(addresses) {\n      var _a;\n\n      var getter = this.value;\n      var compare = this.facet.compareInput;\n      var idx = addresses[this.id] >> 1,\n          multi = this.type == 2\n      /* Multi */\n      ;\n      var depDoc = false,\n          depSel = false,\n          depAddrs = [];\n\n      var _iterator3 = _createForOfIteratorHelper(this.dependencies),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var dep = _step3.value;\n          if (dep == \"doc\") depDoc = true;else if (dep == \"selection\") depSel = true;else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return function (state, tr) {\n        var oldVal = state.values[idx];\n\n        if (oldVal === Uninitialized) {\n          state.values[idx] = getter(state);\n          return 1\n          /* Changed */\n          ;\n        }\n\n        if (tr) {\n          var depChanged = depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || depAddrs.some(function (addr) {\n            return (ensureAddr(state, addr) & 1\n            /* Changed */\n            ) > 0;\n          });\n\n          if (depChanged) {\n            var newVal = getter(state);\n\n            if (multi ? !compareArray(newVal, oldVal, compare) : !compare(newVal, oldVal)) {\n              state.values[idx] = newVal;\n              return 1\n              /* Changed */\n              ;\n            }\n          }\n        }\n\n        return 0;\n      };\n    }\n  }]);\n\n  return FacetProvider;\n}();\n\nfunction compareArray(a, b, compare) {\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; i++) {\n    if (!compare(a[i], b[i])) return false;\n  }\n\n  return true;\n}\n\nfunction dynamicFacetSlot(addresses, facet, providers) {\n  var providerAddrs = providers.map(function (p) {\n    return addresses[p.id];\n  });\n  var providerTypes = providers.map(function (p) {\n    return p.type;\n  });\n  var dynamic = providerAddrs.filter(function (p) {\n    return !(p & 1);\n  });\n  var idx = addresses[facet.id] >> 1;\n  return function (state, tr) {\n    var oldVal = state.values[idx],\n        changed = oldVal === Uninitialized || !tr;\n\n    var _iterator4 = _createForOfIteratorHelper(dynamic),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var dynAddr = _step4.value;\n        if (ensureAddr(state, dynAddr) & 1\n        /* Changed */\n        ) changed = true;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    if (!changed) return 0;\n    var values = [];\n\n    for (var i = 0; i < providerAddrs.length; i++) {\n      var _value = getAddr(state, providerAddrs[i]);\n\n      if (providerTypes[i] == 2\n      /* Multi */\n      ) {\n        var _iterator5 = _createForOfIteratorHelper(_value),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var val = _step5.value;\n            values.push(val);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else values.push(_value);\n    }\n\n    var value = facet.combine(values);\n    if (oldVal !== Uninitialized && facet.compare(value, oldVal)) return 0;\n    state.values[idx] = value;\n    return 1\n    /* Changed */\n    ;\n  };\n}\n\nvar initField = /*@__PURE__*/Facet.define({\n  \"static\": true\n});\n/**\nFields can store additional information in an editor state, and\nkeep it in sync with the rest of the state.\n*/\n\nvar StateField = /*#__PURE__*/function () {\n  function StateField(\n  /**\n  @internal\n  */\n  id, createF, updateF, compareF,\n  /**\n  @internal\n  */\n  spec) {\n    _classCallCheck(this, StateField);\n\n    this.id = id;\n    this.createF = createF;\n    this.updateF = updateF;\n    this.compareF = compareF;\n    this.spec = spec;\n    /**\n    @internal\n    */\n\n    this.provides = undefined;\n  }\n  /**\n  Define a state field.\n  */\n\n\n  _createClass(StateField, [{\n    key: \"create\",\n    value: function create(state) {\n      var _this2 = this;\n\n      var init = state.facet(initField).find(function (i) {\n        return i.field == _this2;\n      });\n      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"slot\",\n    value: function slot(addresses) {\n      var _this3 = this;\n\n      var idx = addresses[this.id] >> 1;\n      return function (state, tr) {\n        var oldVal = state.values[idx];\n\n        if (oldVal === Uninitialized) {\n          state.values[idx] = _this3.create(state);\n          return 1\n          /* Changed */\n          ;\n        }\n\n        if (tr) {\n          var value = _this3.updateF(oldVal, tr);\n\n          if (!_this3.compareF(oldVal, value)) {\n            state.values[idx] = value;\n            return 1\n            /* Changed */\n            ;\n          }\n        }\n\n        return 0;\n      };\n    }\n    /**\n    Returns an extension that enables this field and overrides the\n    way it is initialized. Can be useful when you need to provide a\n    non-default starting value for the field.\n    */\n\n  }, {\n    key: \"init\",\n    value: function init(create) {\n      return [this, initField.of({\n        field: this,\n        create: create\n      })];\n    }\n    /**\n    State field instances can be used as\n    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n    given state.\n    */\n\n  }, {\n    key: \"extension\",\n    get: function get() {\n      return this;\n    }\n  }], [{\n    key: \"define\",\n    value: function define(config) {\n      var field = new StateField(nextID++, config.create, config.update, config.compare || function (a, b) {\n        return a === b;\n      }, config);\n      if (config.provide) field.provides = config.provide(field);\n      return field;\n    }\n  }]);\n\n  return StateField;\n}();\n\nvar Prec_ = {\n  lowest: 4,\n  low: 3,\n  \"default\": 2,\n  high: 1,\n  highest: 0\n};\n\nfunction prec(value) {\n  return function (ext) {\n    return new PrecExtension(ext, value);\n  };\n}\n/**\nBy default extensions are registered in the order they are found\nin the flattened form of nested array that was provided.\nIndividual extension values can be assigned a precedence to\noverride this. Extensions that do not have a precedence set get\nthe precedence of the nearest parent with a precedence, or\n[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The\nfinal ordering of extensions is determined by first sorting by\nprecedence and then by order within each precedence.\n*/\n\n\nvar Prec = {\n  /**\n  The lowest precedence level. Meant for things that should end up\n  near the end of the extension order.\n  */\n  lowest: /*@__PURE__*/prec(Prec_.lowest),\n\n  /**\n  A lower-than-default precedence, for extensions.\n  */\n  low: /*@__PURE__*/prec(Prec_.low),\n\n  /**\n  The default precedence, which is also used for extensions\n  without an explicit precedence.\n  */\n  \"default\": /*@__PURE__*/prec(Prec_[\"default\"]),\n\n  /**\n  A higher-than-default precedence, for extensions that should\n  come before those with default precedence.\n  */\n  high: /*@__PURE__*/prec(Prec_.high),\n\n  /**\n  The highest precedence level, for extensions that should end up\n  near the start of the precedence ordering.\n  */\n  highest: /*@__PURE__*/prec(Prec_.highest),\n  // FIXME Drop these in some future breaking version\n\n  /**\n  Backwards-compatible synonym for `Prec.lowest`.\n  */\n  fallback: /*@__PURE__*/prec(Prec_.lowest),\n\n  /**\n  Backwards-compatible synonym for `Prec.high`.\n  */\n  extend: /*@__PURE__*/prec(Prec_.high),\n\n  /**\n  Backwards-compatible synonym for `Prec.highest`.\n  */\n  override: /*@__PURE__*/prec(Prec_.highest)\n};\n\nvar PrecExtension = function PrecExtension(inner, prec) {\n  _classCallCheck(this, PrecExtension);\n\n  this.inner = inner;\n  this.prec = prec;\n};\n/**\nExtension compartments can be used to make a configuration\ndynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your\nconfiguration in a compartment, you can later\n[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a\ntransaction.\n*/\n\n\nvar Compartment = /*#__PURE__*/function () {\n  function Compartment() {\n    _classCallCheck(this, Compartment);\n  }\n\n  _createClass(Compartment, [{\n    key: \"of\",\n    value:\n    /**\n    Create an instance of this compartment to add to your [state\n    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n    */\n    function of(ext) {\n      return new CompartmentInstance(this, ext);\n    }\n    /**\n    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n    reconfigures this compartment.\n    */\n\n  }, {\n    key: \"reconfigure\",\n    value: function reconfigure(content) {\n      return Compartment.reconfigure.of({\n        compartment: this,\n        extension: content\n      });\n    }\n    /**\n    Get the current content of the compartment in the state, or\n    `undefined` if it isn't present.\n    */\n\n  }, {\n    key: \"get\",\n    value: function get(state) {\n      return state.config.compartments.get(this);\n    }\n  }]);\n\n  return Compartment;\n}();\n\nvar CompartmentInstance = function CompartmentInstance(compartment, inner) {\n  _classCallCheck(this, CompartmentInstance);\n\n  this.compartment = compartment;\n  this.inner = inner;\n};\n\nvar Configuration = /*#__PURE__*/function () {\n  function Configuration(base, compartments, dynamicSlots, address, staticValues) {\n    _classCallCheck(this, Configuration);\n\n    this.base = base;\n    this.compartments = compartments;\n    this.dynamicSlots = dynamicSlots;\n    this.address = address;\n    this.staticValues = staticValues;\n    this.statusTemplate = [];\n\n    while (this.statusTemplate.length < dynamicSlots.length) {\n      this.statusTemplate.push(0\n      /* Unresolved */\n      );\n    }\n  }\n\n  _createClass(Configuration, [{\n    key: \"staticFacet\",\n    value: function staticFacet(facet) {\n      var addr = this.address[facet.id];\n      return addr == null ? facet[\"default\"] : this.staticValues[addr >> 1];\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(base, compartments, oldState) {\n      var fields = [];\n      var facets = Object.create(null);\n      var newCompartments = new Map();\n\n      var _iterator6 = _createForOfIteratorHelper(flatten(base, compartments, newCompartments)),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var ext = _step6.value;\n          if (ext instanceof StateField) fields.push(ext);else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var address = Object.create(null);\n      var staticValues = [];\n      var dynamicSlots = [];\n      var dynamicDeps = [];\n\n      var _loop = function _loop() {\n        var field = _fields[_i];\n        address[field.id] = dynamicSlots.length << 1;\n        dynamicSlots.push(function (a) {\n          return field.slot(a);\n        });\n        dynamicDeps.push([]);\n      };\n\n      for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {\n        _loop();\n      }\n\n      var _loop2 = function _loop2(id) {\n        var providers = facets[id],\n            facet = providers[0].facet;\n\n        if (providers.every(function (p) {\n          return p.type == 0;\n        }\n        /* Static */\n        )) {\n          address[facet.id] = staticValues.length << 1 | 1;\n          var value = facet.combine(providers.map(function (p) {\n            return p.value;\n          }));\n          var oldAddr = oldState ? oldState.config.address[facet.id] : null;\n\n          if (oldAddr != null) {\n            var oldVal = getAddr(oldState, oldAddr);\n            if (facet.compare(value, oldVal)) value = oldVal;\n          }\n\n          staticValues.push(value);\n        } else {\n          var _iterator7 = _createForOfIteratorHelper(providers),\n              _step7;\n\n          try {\n            var _loop3 = function _loop3() {\n              var p = _step7.value;\n\n              if (p.type == 0\n              /* Static */\n              ) {\n                address[p.id] = staticValues.length << 1 | 1;\n                staticValues.push(p.value);\n              } else {\n                address[p.id] = dynamicSlots.length << 1;\n                dynamicSlots.push(function (a) {\n                  return p.dynamicSlot(a);\n                });\n                dynamicDeps.push(p.dependencies.filter(function (d) {\n                  return typeof d != \"string\";\n                }).map(function (d) {\n                  return d.id;\n                }));\n              }\n            };\n\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              _loop3();\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          address[facet.id] = dynamicSlots.length << 1;\n          dynamicSlots.push(function (a) {\n            return dynamicFacetSlot(a, facet, providers);\n          });\n          dynamicDeps.push(providers.filter(function (p) {\n            return p.type != 0;\n          }\n          /* Static */\n          ).map(function (d) {\n            return d.id;\n          }));\n        }\n      };\n\n      for (var id in facets) {\n        _loop2(id);\n      }\n\n      var dynamicValues = dynamicSlots.map(function (_) {\n        return Uninitialized;\n      });\n\n      if (oldState) {\n        var canReuse = function canReuse(id, depth) {\n          if (depth > 7) return false;\n          var addr = address[id];\n          if (!(addr & 1)) return dynamicDeps[addr >> 1].every(function (id) {\n            return canReuse(id, depth + 1);\n          });\n          var oldAddr = oldState.config.address[id];\n          return oldAddr != null && getAddr(oldState, oldAddr) == staticValues[addr >> 1];\n        }; // Copy over old values for shared facets/fields, if we can\n        // prove that they don't need to be recomputed.\n\n\n        for (var _id in address) {\n          var cur = address[_id],\n              prev = oldState.config.address[_id];\n          if (prev != null && (cur & 1) == 0 && canReuse(+_id, 0)) dynamicValues[cur >> 1] = getAddr(oldState, prev);\n        }\n      }\n\n      return {\n        configuration: new Configuration(base, newCompartments, dynamicSlots.map(function (f) {\n          return f(address);\n        }), address, staticValues),\n        values: dynamicValues\n      };\n    }\n  }]);\n\n  return Configuration;\n}();\n\nfunction flatten(extension, compartments, newCompartments) {\n  var result = [[], [], [], [], []];\n  var seen = new Map();\n\n  function inner(ext, prec) {\n    var known = seen.get(ext);\n\n    if (known != null) {\n      if (known >= prec) return;\n      var found = result[known].indexOf(ext);\n      if (found > -1) result[known].splice(found, 1);\n      if (ext instanceof CompartmentInstance) newCompartments[\"delete\"](ext.compartment);\n    }\n\n    seen.set(ext, prec);\n\n    if (Array.isArray(ext)) {\n      var _iterator8 = _createForOfIteratorHelper(ext),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var e = _step8.value;\n          inner(e, prec);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    } else if (ext instanceof CompartmentInstance) {\n      if (newCompartments.has(ext.compartment)) throw new RangeError(\"Duplicate use of compartment in extensions\");\n      var content = compartments.get(ext.compartment) || ext.inner;\n      newCompartments.set(ext.compartment, content);\n      inner(content, prec);\n    } else if (ext instanceof PrecExtension) {\n      inner(ext.inner, ext.prec);\n    } else if (ext instanceof StateField) {\n      result[prec].push(ext);\n      if (ext.provides) inner(ext.provides, prec);\n    } else if (ext instanceof FacetProvider) {\n      result[prec].push(ext);\n      if (ext.facet.extensions) inner(ext.facet.extensions, prec);\n    } else {\n      var _content = ext.extension;\n      if (!_content) throw new Error(\"Unrecognized extension value in extension set (\".concat(ext, \"). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.\"));\n      inner(_content, prec);\n    }\n  }\n\n  inner(extension, Prec_[\"default\"]);\n  return result.reduce(function (a, b) {\n    return a.concat(b);\n  });\n}\n\nvar Uninitialized = {};\n\nfunction ensureAddr(state, addr) {\n  if (addr & 1) return 2\n  /* Computed */\n  ;\n  var idx = addr >> 1;\n  var status = state.status[idx];\n  if (status == 4\n  /* Computing */\n  ) throw new Error(\"Cyclic dependency between fields and/or facets\");\n  if (status & 2\n  /* Computed */\n  ) return status;\n  state.status[idx] = 4\n  /* Computing */\n  ;\n  var changed = state.config.dynamicSlots[idx](state, state.applying);\n  return state.status[idx] = 2\n  /* Computed */\n  | changed;\n}\n\nfunction getAddr(state, addr) {\n  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];\n}\n\nvar languageData = /*@__PURE__*/Facet.define();\nvar allowMultipleSelections = /*@__PURE__*/Facet.define({\n  combine: function combine(values) {\n    return values.some(function (v) {\n      return v;\n    });\n  },\n  \"static\": true\n});\nvar lineSeparator = /*@__PURE__*/Facet.define({\n  combine: function combine(values) {\n    return values.length ? values[0] : undefined;\n  },\n  \"static\": true\n});\nvar changeFilter = /*@__PURE__*/Facet.define();\nvar transactionFilter = /*@__PURE__*/Facet.define();\nvar transactionExtender = /*@__PURE__*/Facet.define();\nvar readOnly = /*@__PURE__*/Facet.define({\n  combine: function combine(values) {\n    return values.length ? values[0] : false;\n  }\n});\n/**\nAnnotations are tagged values that are used to add metadata to\ntransactions in an extensible way. They should be used to model\nthings that effect the entire transaction (such as its [time\nstamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its\n[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen\n_alongside_ the other changes made by the transaction, [state\neffects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.\n*/\n\nvar Annotation = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Annotation(\n  /**\n  The annotation type.\n  */\n  type,\n  /**\n  The value of this annotation.\n  */\n  value) {\n    _classCallCheck(this, Annotation);\n\n    this.type = type;\n    this.value = value;\n  }\n  /**\n  Define a new type of annotation.\n  */\n\n\n  _createClass(Annotation, null, [{\n    key: \"define\",\n    value: function define() {\n      return new AnnotationType();\n    }\n  }]);\n\n  return Annotation;\n}();\n/**\nMarker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).\n*/\n\n\nvar AnnotationType = /*#__PURE__*/function () {\n  function AnnotationType() {\n    _classCallCheck(this, AnnotationType);\n  }\n\n  _createClass(AnnotationType, [{\n    key: \"of\",\n    value:\n    /**\n    Create an instance of this annotation.\n    */\n    function of(value) {\n      return new Annotation(this, value);\n    }\n  }]);\n\n  return AnnotationType;\n}();\n/**\nRepresentation of a type of state effect. Defined with\n[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).\n*/\n\n\nvar StateEffectType = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function StateEffectType( // The `any` types in these function types are there to work\n  // around TypeScript issue #37631, where the type guard on\n  // `StateEffect.is` mysteriously stops working when these properly\n  // have type `Value`.\n\n  /**\n  @internal\n  */\n  map) {\n    _classCallCheck(this, StateEffectType);\n\n    this.map = map;\n  }\n  /**\n  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n  type.\n  */\n\n\n  _createClass(StateEffectType, [{\n    key: \"of\",\n    value: function of(value) {\n      return new StateEffect(this, value);\n    }\n  }]);\n\n  return StateEffectType;\n}();\n/**\nState effects can be used to represent additional effects\nassociated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They\nare often useful to model changes to custom [state\nfields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in\ndocument or selection changes.\n*/\n\n\nvar StateEffect = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function StateEffect(\n  /**\n  @internal\n  */\n  type,\n  /**\n  The value of this effect.\n  */\n  value) {\n    _classCallCheck(this, StateEffect);\n\n    this.type = type;\n    this.value = value;\n  }\n  /**\n  Map this effect through a position mapping. Will return\n  `undefined` when that ends up deleting the effect.\n  */\n\n\n  _createClass(StateEffect, [{\n    key: \"map\",\n    value: function map(mapping) {\n      var mapped = this.type.map(this.value, mapping);\n      return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);\n    }\n    /**\n    Tells you whether this effect object is of a given\n    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n    */\n\n  }, {\n    key: \"is\",\n    value: function is(type) {\n      return this.type == type;\n    }\n    /**\n    Define a new effect type. The type parameter indicates the type\n    of values that his effect holds.\n    */\n\n  }], [{\n    key: \"define\",\n    value: function define() {\n      var spec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new StateEffectType(spec.map || function (v) {\n        return v;\n      });\n    }\n    /**\n    Map an array of effects through a change set.\n    */\n\n  }, {\n    key: \"mapEffects\",\n    value: function mapEffects(effects, mapping) {\n      if (!effects.length) return effects;\n      var result = [];\n\n      var _iterator9 = _createForOfIteratorHelper(effects),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var effect = _step9.value;\n          var mapped = effect.map(mapping);\n          if (mapped) result.push(mapped);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      return result;\n    }\n  }]);\n\n  return StateEffect;\n}();\n/**\nThis effect can be used to reconfigure the root extensions of\nthe editor. Doing this will discard any extensions\n[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset\nthe content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)\ncompartments.\n*/\n\n\nStateEffect.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nAppend extensions to the top-level configuration of the editor.\n*/\n\nStateEffect.appendConfig = /*@__PURE__*/StateEffect.define();\n/**\nChanges to the editor state are grouped into transactions.\nTypically, a user action creates a single transaction, which may\ncontain any number of document changes, may change the selection,\nor have other effects. Create a transaction by calling\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n*/\n\nvar Transaction = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Transaction(\n  /**\n  The state from which the transaction starts.\n  */\n  startState,\n  /**\n  The document changes made by this transaction.\n  */\n  changes,\n  /**\n  The selection set by this transaction, or undefined if it\n  doesn't explicitly set a selection.\n  */\n  selection,\n  /**\n  The effects added to the transaction.\n  */\n  effects,\n  /**\n  @internal\n  */\n  annotations,\n  /**\n  Whether the selection should be scrolled into view after this\n  transaction is dispatched.\n  */\n  scrollIntoView) {\n    _classCallCheck(this, Transaction);\n\n    this.startState = startState;\n    this.changes = changes;\n    this.selection = selection;\n    this.effects = effects;\n    this.annotations = annotations;\n    this.scrollIntoView = scrollIntoView;\n    /**\n    @internal\n    */\n\n    this._doc = null;\n    /**\n    @internal\n    */\n\n    this._state = null;\n    if (selection) checkSelection(selection, changes.newLength);\n    if (!annotations.some(function (a) {\n      return a.type == Transaction.time;\n    })) this.annotations = annotations.concat(Transaction.time.of(Date.now()));\n  }\n  /**\n  The new document produced by the transaction. Contrary to\n  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n  force the entire new state to be computed right away, so it is\n  recommended that [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n  when they need to look at the new document.\n  */\n\n\n  _createClass(Transaction, [{\n    key: \"newDoc\",\n    get: function get() {\n      return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n    }\n    /**\n    The new selection produced by the transaction. If\n    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n    current selection through the changes made by the transaction.\n    */\n\n  }, {\n    key: \"newSelection\",\n    get: function get() {\n      return this.selection || this.startState.selection.map(this.changes);\n    }\n    /**\n    The new state created by the transaction. Computed on demand\n    (but retained for subsequent access), so itis recommended not to\n    access it in [transaction\n    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n    */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      if (!this._state) this.startState.applyTransaction(this);\n      return this._state;\n    }\n    /**\n    Get the value of the given annotation type, if any.\n    */\n\n  }, {\n    key: \"annotation\",\n    value: function annotation(type) {\n      var _iterator10 = _createForOfIteratorHelper(this.annotations),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var ann = _step10.value;\n          if (ann.type == type) return ann.value;\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return undefined;\n    }\n    /**\n    Indicates whether the transaction changed the document.\n    */\n\n  }, {\n    key: \"docChanged\",\n    get: function get() {\n      return !this.changes.empty;\n    }\n    /**\n    Indicates whether this transaction reconfigures the state\n    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n    with a top-level configuration\n    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n    */\n\n  }, {\n    key: \"reconfigured\",\n    get: function get() {\n      return this.startState.config != this.state.config;\n    }\n    /**\n    Returns true if the transaction has a [user\n    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n    or more specific than `event`. For example, if the transaction\n    has `\"select.pointer\"` as user event, `\"select\"` and\n    `\"select.pointer\"` will match it.\n    */\n\n  }, {\n    key: \"isUserEvent\",\n    value: function isUserEvent(event) {\n      var e = this.annotation(Transaction.userEvent);\n      return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == \".\"));\n    }\n  }]);\n\n  return Transaction;\n}();\n/**\nAnnotation used to store transaction timestamps.\n*/\n\n\nTransaction.time = /*@__PURE__*/Annotation.define();\n/**\nAnnotation used to associate a transaction with a user interface\nevent. Holds a string identifying the event, using a\ndot-separated format to support attaching more specific\ninformation. The events used by the core libraries are:\n\n - `\"input\"` when content is entered\n   - `\"input.type\"` for typed input\n     - `\"input.type.compose\"` for composition\n   - `\"input.paste\"` for pasted input\n   - `\"input.drop\"` when adding content with drag-and-drop\n   - `\"input.complete\"` when autocompleting\n - `\"delete\"` when the user deletes content\n   - `\"delete.selection\"` when deleting the selection\n   - `\"delete.forward\"` when deleting forward from the selection\n   - `\"delete.backward\"` when deleting backward from the selection\n   - `\"delete.cut\"` when cutting to the clipboard\n - `\"move\"` when content is moved\n   - `\"move.drop\"` when content is moved within the editor through drag-and-drop\n - `\"select\"` when explicitly changing the selection\n   - `\"select.pointer\"` when selecting with a mouse or other pointing device\n - `\"undo\"` and `\"redo\"` for history actions\n\nUse [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check\nwhether the annotation matches a given event.\n*/\n\nTransaction.userEvent = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating whether a transaction should be added to\nthe undo history or not.\n*/\n\nTransaction.addToHistory = /*@__PURE__*/Annotation.define();\n/**\nAnnotation indicating (when present and true) that a transaction\nrepresents a change made by some other actor, not the user. This\nis used, for example, to tag other people's changes in\ncollaborative editing.\n*/\n\nTransaction.remote = /*@__PURE__*/Annotation.define();\n\nfunction joinRanges(a, b) {\n  var result = [];\n\n  for (var iA = 0, iB = 0;;) {\n    var from = void 0,\n        to = void 0;\n\n    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {\n      from = a[iA++];\n      to = a[iA++];\n    } else if (iB < b.length) {\n      from = b[iB++];\n      to = b[iB++];\n    } else return result;\n\n    if (!result.length || result[result.length - 1] < from) result.push(from, to);else if (result[result.length - 1] < to) result[result.length - 1] = to;\n  }\n}\n\nfunction mergeTransaction(a, b, sequential) {\n  var _a;\n\n  var mapForA, mapForB, changes;\n\n  if (sequential) {\n    mapForA = b.changes;\n    mapForB = ChangeSet.empty(b.changes.length);\n    changes = a.changes.compose(b.changes);\n  } else {\n    mapForA = b.changes.map(a.changes);\n    mapForB = a.changes.mapDesc(b.changes, true);\n    changes = a.changes.compose(mapForA);\n  }\n\n  return {\n    changes: changes,\n    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),\n    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),\n    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,\n    scrollIntoView: a.scrollIntoView || b.scrollIntoView\n  };\n}\n\nfunction resolveTransactionInner(state, spec, docSize) {\n  var sel = spec.selection,\n      annotations = asArray(spec.annotations);\n  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));\n  return {\n    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),\n    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),\n    effects: asArray(spec.effects),\n    annotations: annotations,\n    scrollIntoView: !!spec.scrollIntoView\n  };\n}\n\nfunction resolveTransaction(state, specs, filter) {\n  var s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);\n  if (specs.length && specs[0].filter === false) filter = false;\n\n  for (var i = 1; i < specs.length; i++) {\n    if (specs[i].filter === false) filter = false;\n    var seq = !!specs[i].sequential;\n    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);\n  }\n\n  var tr = new Transaction(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);\n  return extendTransaction(filter ? filterTransaction(tr) : tr);\n} // Finish a transaction by applying filters if necessary.\n\n\nfunction filterTransaction(tr) {\n  var state = tr.startState; // Change filters\n\n  var result = true;\n\n  var _iterator11 = _createForOfIteratorHelper(state.facet(changeFilter)),\n      _step11;\n\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var filter = _step11.value;\n      var value = filter(tr);\n\n      if (value === false) {\n        result = false;\n        break;\n      }\n\n      if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n\n  if (result !== true) {\n    var changes, back;\n\n    if (result === false) {\n      back = tr.changes.invertedDesc;\n      changes = ChangeSet.empty(state.doc.length);\n    } else {\n      var filtered = tr.changes.filter(result);\n      changes = filtered.changes;\n      back = filtered.filtered.invertedDesc;\n    }\n\n    tr = new Transaction(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);\n  } // Transaction filters\n\n\n  var filters = state.facet(transactionFilter);\n\n  for (var i = filters.length - 1; i >= 0; i--) {\n    var _filtered = filters[i](tr);\n\n    if (_filtered instanceof Transaction) tr = _filtered;else if (Array.isArray(_filtered) && _filtered.length == 1 && _filtered[0] instanceof Transaction) tr = _filtered[0];else tr = resolveTransaction(state, asArray(_filtered), false);\n  }\n\n  return tr;\n}\n\nfunction extendTransaction(tr) {\n  var state = tr.startState,\n      extenders = state.facet(transactionExtender),\n      spec = tr;\n\n  for (var i = extenders.length - 1; i >= 0; i--) {\n    var extension = extenders[i](tr);\n    if (extension && Object.keys(extension).length) spec = mergeTransaction(tr, resolveTransactionInner(state, extension, tr.changes.newLength), true);\n  }\n\n  return spec == tr ? tr : new Transaction(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);\n}\n\nvar none = [];\n\nfunction asArray(value) {\n  return value == null ? none : Array.isArray(value) ? value : [value];\n}\n/**\nThe categories produced by a [character\ncategorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used\ndo things like selecting by word.\n*/\n\n\nvar CharCategory = /*@__PURE__*/function (CharCategory) {\n  /**\n  Word characters.\n  */\n  CharCategory[CharCategory[\"Word\"] = 0] = \"Word\";\n  /**\n  Whitespace.\n  */\n\n  CharCategory[CharCategory[\"Space\"] = 1] = \"Space\";\n  /**\n  Anything else.\n  */\n\n  CharCategory[CharCategory[\"Other\"] = 2] = \"Other\";\n  return CharCategory;\n}(CharCategory || (CharCategory = {}));\n\nvar nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nvar wordChar;\n\ntry {\n  wordChar = /*@__PURE__*/new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch (_) {}\n\nfunction hasWordChar(str) {\n  if (wordChar) return wordChar.test(str);\n\n  for (var i = 0; i < str.length; i++) {\n    var ch = str[i];\n    if (/\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;\n  }\n\n  return false;\n}\n\nfunction makeCategorizer(wordChars) {\n  return function (_char) {\n    if (!/\\S/.test(_char)) return CharCategory.Space;\n    if (hasWordChar(_char)) return CharCategory.Word;\n\n    for (var i = 0; i < wordChars.length; i++) {\n      if (_char.indexOf(wordChars[i]) > -1) return CharCategory.Word;\n    }\n\n    return CharCategory.Other;\n  };\n}\n/**\nThe editor state class is a persistent (immutable) data structure.\nTo update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a\n[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state\ninstance, without modifying the original object.\n\nAs such, _never_ mutate properties of a state directly. That'll\njust break things.\n*/\n\n\nvar EditorState = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function EditorState(\n  /**\n  @internal\n  */\n  config,\n  /**\n  The current document.\n  */\n  doc,\n  /**\n  The current selection.\n  */\n  selection,\n  /**\n  @internal\n  */\n  values) {\n    var tr = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    _classCallCheck(this, EditorState);\n\n    this.config = config;\n    this.doc = doc;\n    this.selection = selection;\n    this.values = values;\n    /**\n    @internal\n    */\n\n    this.applying = null;\n    this.status = config.statusTemplate.slice();\n    this.applying = tr; // Fill in the computed state immediately, so that further queries\n    // for it made during the update return this state\n\n    if (tr) tr._state = this;\n\n    for (var i = 0; i < this.config.dynamicSlots.length; i++) {\n      ensureAddr(this, i << 1);\n    }\n\n    this.applying = null;\n  }\n\n  _createClass(EditorState, [{\n    key: \"field\",\n    value: function field(_field) {\n      var require = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var addr = this.config.address[_field.id];\n\n      if (addr == null) {\n        if (require) throw new RangeError(\"Field is not present in this state\");\n        return undefined;\n      }\n\n      ensureAddr(this, addr);\n      return getAddr(this, addr);\n    }\n    /**\n    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n    can be passed. Unless\n    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n    are assumed to start in the _current_ document (not the document\n    produced by previous specs), and its\n    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n    to the document created by its _own_ changes. The resulting\n    transaction contains the combined effect of all the different\n    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n    specs take precedence over earlier ones.\n    */\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      for (var _len2 = arguments.length, specs = new Array(_len2), _key = 0; _key < _len2; _key++) {\n        specs[_key] = arguments[_key];\n      }\n\n      return resolveTransaction(this, specs, true);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"applyTransaction\",\n    value: function applyTransaction(tr) {\n      var conf = this.config,\n          _conf = conf,\n          base = _conf.base,\n          compartments = _conf.compartments;\n\n      var _iterator12 = _createForOfIteratorHelper(tr.effects),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var effect = _step12.value;\n\n          if (effect.is(Compartment.reconfigure)) {\n            if (conf) {\n              compartments = new Map();\n              conf.compartments.forEach(function (val, key) {\n                return compartments.set(key, val);\n              });\n              conf = null;\n            }\n\n            compartments.set(effect.value.compartment, effect.value.extension);\n          } else if (effect.is(StateEffect.reconfigure)) {\n            conf = null;\n            base = effect.value;\n          } else if (effect.is(StateEffect.appendConfig)) {\n            conf = null;\n            base = asArray(base).concat(effect.value);\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      var startValues;\n\n      if (!conf) {\n        var resolved = Configuration.resolve(base, compartments, this);\n        conf = resolved.configuration;\n        var intermediateState = new EditorState(conf, this.doc, this.selection, resolved.values, null);\n        startValues = intermediateState.values;\n      } else {\n        startValues = tr.startState.values.slice();\n      }\n\n      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, tr);\n    }\n    /**\n    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n    replaces every selection range with the given content.\n    */\n\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(text) {\n      if (typeof text == \"string\") text = this.toText(text);\n      return this.changeByRange(function (range) {\n        return {\n          changes: {\n            from: range.from,\n            to: range.to,\n            insert: text\n          },\n          range: EditorSelection.cursor(range.from + text.length)\n        };\n      });\n    }\n    /**\n    Create a set of changes and a new selection by running the given\n    function for each range in the active selection. The function\n    can return an optional set of changes (in the coordinate space\n    of the start document), plus an updated range (in the coordinate\n    space of the document produced by the call's own changes). This\n    method will merge all the changes and ranges into a single\n    changeset and selection, and return it as a [transaction\n    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n    */\n\n  }, {\n    key: \"changeByRange\",\n    value: function changeByRange(f) {\n      var sel = this.selection;\n      var result1 = f(sel.ranges[0]);\n      var changes = this.changes(result1.changes),\n          ranges = [result1.range];\n      var effects = asArray(result1.effects);\n\n      for (var i = 1; i < sel.ranges.length; i++) {\n        var result = f(sel.ranges[i]);\n        var newChanges = this.changes(result.changes),\n            newMapped = newChanges.map(changes);\n\n        for (var j = 0; j < i; j++) {\n          ranges[j] = ranges[j].map(newMapped);\n        }\n\n        var mapBy = changes.mapDesc(newChanges, true);\n        ranges.push(result.range.map(mapBy));\n        changes = changes.compose(newMapped);\n        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));\n      }\n\n      return {\n        changes: changes,\n        selection: EditorSelection.create(ranges, sel.mainIndex),\n        effects: effects\n      };\n    }\n    /**\n    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n    description, taking the state's document length and line\n    separator into account.\n    */\n\n  }, {\n    key: \"changes\",\n    value: function changes() {\n      var spec = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      if (spec instanceof ChangeSet) return spec;\n      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));\n    }\n    /**\n    Using the state's [line\n    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n    [`Text`](https://codemirror.net/6/docs/ref/#text.Text) instance from the given string.\n    */\n\n  }, {\n    key: \"toText\",\n    value: function toText(string) {\n      return _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));\n    }\n    /**\n    Return the given range of the document as a string.\n    */\n\n  }, {\n    key: \"sliceDoc\",\n    value: function sliceDoc() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.doc.length;\n      return this.doc.sliceString(from, to, this.lineBreak);\n    }\n    /**\n    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n    */\n\n  }, {\n    key: \"facet\",\n    value: function facet(_facet) {\n      var addr = this.config.address[_facet.id];\n      if (addr == null) return _facet[\"default\"];\n      ensureAddr(this, addr);\n      return getAddr(this, addr);\n    }\n    /**\n    Convert this state to a JSON-serializable object. When custom\n    fields should be serialized, you can pass them in as an object\n    mapping property names (in the resulting object, which should\n    not use `doc` or `selection`) to fields.\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(fields) {\n      var result = {\n        doc: this.sliceDoc(),\n        selection: this.selection.toJSON()\n      };\n      if (fields) for (var prop in fields) {\n        var value = fields[prop];\n        if (value instanceof StateField) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);\n      }\n      return result;\n    }\n    /**\n    Deserialize a state from its JSON representation. When custom\n    fields should be deserialized, pass the same object you passed\n    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n    third argument.\n    */\n\n  }, {\n    key: \"tabSize\",\n    get:\n    /**\n    The size (in columns) of a tab in the document, determined by\n    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n    */\n    function get() {\n      return this.facet(EditorState.tabSize);\n    }\n    /**\n    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n    string for this state.\n    */\n\n  }, {\n    key: \"lineBreak\",\n    get: function get() {\n      return this.facet(EditorState.lineSeparator) || \"\\n\";\n    }\n    /**\n    Returns true when the editor is\n    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n    */\n\n  }, {\n    key: \"readOnly\",\n    get: function get() {\n      return this.facet(readOnly);\n    }\n    /**\n    Look up a translation for the given phrase (via the\n    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n    original string if no translation is found.\n    */\n\n  }, {\n    key: \"phrase\",\n    value: function phrase(_phrase) {\n      var _iterator13 = _createForOfIteratorHelper(this.facet(EditorState.phrases)),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var map = _step13.value;\n          if (Object.prototype.hasOwnProperty.call(map, _phrase)) return map[_phrase];\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      return _phrase;\n    }\n    /**\n    Find the values for a given language data field, provided by the\n    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n    */\n\n  }, {\n    key: \"languageDataAt\",\n    value: function languageDataAt(name, pos) {\n      var side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var values = [];\n\n      var _iterator14 = _createForOfIteratorHelper(this.facet(languageData)),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var provider = _step14.value;\n\n          var _iterator15 = _createForOfIteratorHelper(provider(this, pos, side)),\n              _step15;\n\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var result = _step15.value;\n              if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return values;\n    }\n    /**\n    Return a function that can categorize strings (expected to\n    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak))\n    into one of:\n    \n     - Word (contains an alphanumeric character or a character\n       explicitly listed in the local language's `\"wordChars\"`\n       language data, which should be a string)\n     - Space (contains only whitespace)\n     - Other (anything else)\n    */\n\n  }, {\n    key: \"charCategorizer\",\n    value: function charCategorizer(at) {\n      return makeCategorizer(this.languageDataAt(\"wordChars\", at).join(\"\"));\n    }\n    /**\n    Find the word at the given position, meaning the range\n    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n    around it. If no word characters are adjacent to the position,\n    this returns null.\n    */\n\n  }, {\n    key: \"wordAt\",\n    value: function wordAt(pos) {\n      var _this$doc$lineAt = this.doc.lineAt(pos),\n          text = _this$doc$lineAt.text,\n          from = _this$doc$lineAt.from,\n          length = _this$doc$lineAt.length;\n\n      var cat = this.charCategorizer(pos);\n      var start = pos - from,\n          end = pos - from;\n\n      while (start > 0) {\n        var prev = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(text, start, false);\n        if (cat(text.slice(prev, start)) != CharCategory.Word) break;\n        start = prev;\n      }\n\n      while (end < length) {\n        var next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_0__.findClusterBreak)(text, end);\n        if (cat(text.slice(end, next)) != CharCategory.Word) break;\n        end = next;\n      }\n\n      return start == end ? null : EditorSelection.range(start + from, end + from);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fields = arguments.length > 2 ? arguments[2] : undefined;\n      if (!json || typeof json.doc != \"string\") throw new RangeError(\"Invalid JSON representation for EditorState\");\n      var fieldInit = [];\n\n      if (fields) {\n        var _loop4 = function _loop4(prop) {\n          var field = fields[prop],\n              value = json[prop];\n          fieldInit.push(field.init(function (state) {\n            return field.spec.fromJSON(value, state);\n          }));\n        };\n\n        for (var prop in fields) {\n          _loop4(prop);\n        }\n      }\n\n      return EditorState.create({\n        doc: json.doc,\n        selection: EditorSelection.fromJSON(json.selection),\n        extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit\n      });\n    }\n    /**\n    Create a new state. You'll usually only need this when\n    initializing an editor—updated states are created by applying\n    transactions.\n    */\n\n  }, {\n    key: \"create\",\n    value: function create() {\n      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _Configuration$resolv = Configuration.resolve(config.extensions || [], new Map()),\n          configuration = _Configuration$resolv.configuration,\n          values = _Configuration$resolv.values;\n\n      var doc = config.doc instanceof _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text ? config.doc : _codemirror_text__WEBPACK_IMPORTED_MODULE_0__.Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));\n      var selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);\n      checkSelection(selection, doc.length);\n      if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();\n      return new EditorState(configuration, doc, selection, values);\n    }\n  }]);\n\n  return EditorState;\n}();\n/**\nA facet that, when enabled, causes the editor to allow multiple\nranges to be selected. Be careful though, because by default the\neditor relies on the native DOM selection, which cannot handle\nmultiple selections. An extension like\n[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make\nsecondary selections visible to the user.\n*/\n\n\nEditorState.allowMultipleSelections = allowMultipleSelections;\n/**\nConfigures the tab size to use in this state. The first\n(highest-precedence) value of the facet is used. If no value is\ngiven, this defaults to 4.\n*/\n\nEditorState.tabSize = /*@__PURE__*/Facet.define({\n  combine: function combine(values) {\n    return values.length ? values[0] : 4;\n  }\n});\n/**\nThe line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\nand `\"\\r\"` is treated as a separator when splitting lines, and\nlines are joined with `\"\\n\"`.\n\nWhen you configure a value here, only that precise separator\nwill be used, allowing you to round-trip documents through the\neditor without normalizing line separators.\n*/\n\nEditorState.lineSeparator = lineSeparator;\n/**\nThis facet controls the value of the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is\nconsulted by commands and extensions that implement editing\nfunctionality to determine whether they should apply. It\ndefaults to false, but when its highest-precedence value is\n`true`, such functionality disables itself.\n\nNot to be confused with\n[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which\ncontrols whether the editor's DOM is set to be editable (and\nthus focusable).\n*/\n\nEditorState.readOnly = readOnly;\n/**\nRegisters translation phrases. The\n[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through\nall objects registered with this facet to find translations for\nits argument.\n*/\n\nEditorState.phrases = /*@__PURE__*/Facet.define();\n/**\nA facet used to register [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.\n*/\n\nEditorState.languageData = languageData;\n/**\nFacet used to register change filters, which are called for each\ntransaction (unless explicitly\n[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress\npart of the transaction's changes.\n\nSuch a function can return `true` to indicate that it doesn't\nwant to do anything, `false` to completely stop the changes in\nthe transaction, or a set of ranges in which changes should be\nsuppressed. Such ranges are represented as an array of numbers,\nwith each pair of two number indicating the start and end of a\nrange. So for example `[10, 20, 100, 110]` suppresses changes\nbetween 10 and 20, and between 100 and 110.\n*/\n\nEditorState.changeFilter = changeFilter;\n/**\nFacet used to register a hook that gets a chance to update or\nreplace transaction specs before they are applied. This will\nonly be applied for transactions that don't have\n[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You\ncan either return a single transaction spec (possibly the input\ntransaction), or an array of specs (which will be combined in\nthe same way as the arguments to\n[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).\n\nWhen possible, it is recommended to avoid accessing\n[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,\nsince it will force creation of a state that will then be\ndiscarded again, if the transaction is actually filtered.\n\n(This functionality should be used with care. Indiscriminately\nmodifying transaction is likely to break something or degrade\nthe user experience.)\n*/\n\nEditorState.transactionFilter = transactionFilter;\n/**\nThis is a more limited form of\n[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),\nwhich can only add\n[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and\n[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type\nof filter runs even the transaction has disabled regular\n[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable\nfor effects that don't need to touch the changes or selection,\nbut do want to process every transaction.\n\nExtenders run _after_ filters, when both are applied.\n*/\n\nEditorState.transactionExtender = transactionExtender;\nCompartment.reconfigure = /*@__PURE__*/StateEffect.define();\n/**\nUtility function for combining behaviors to fill in a config\nobject from an array of provided configs. Will, by default, error\nwhen a field gets two values that aren't `===`-equal, but you can\nprovide combine functions per field to do something else.\n*/\n\nfunction combineConfig(configs, defaults) {\n  var combine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var result = {};\n\n  var _iterator16 = _createForOfIteratorHelper(configs),\n      _step16;\n\n  try {\n    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n      var config = _step16.value;\n\n      for (var _i2 = 0, _Object$keys = Object.keys(config); _i2 < _Object$keys.length; _i2++) {\n        var _key2 = _Object$keys[_i2];\n        var value = config[_key2],\n            current = result[_key2];\n        if (current === undefined) result[_key2] = value;else if (current === value || value === undefined) ; // No conflict\n        else if (Object.hasOwnProperty.call(combine, _key2)) result[_key2] = combine[_key2](current, value);else throw new Error(\"Config merge conflict for field \" + _key2);\n      }\n    }\n  } catch (err) {\n    _iterator16.e(err);\n  } finally {\n    _iterator16.f();\n  }\n\n  for (var key in defaults) {\n    if (result[key] === undefined) result[key] = defaults[key];\n  }\n\n  return result;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivc3RhdGUvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7O0FBdE5BOztBQXdOQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFEQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFGQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7OztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFyQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7Ozs7OztBQXFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFMQTtBQUFBOztBQUFBO0FBTUE7QUFBQTtBQUNBO0FBTUE7QUFiQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBTUE7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBT0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQTVDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTs7Ozs7O0FBeUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQ0E7O0FBdUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOzs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBRUE7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUlBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7QUFiQTtBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWpCQTs7QUFjQTtBQUFBO0FBSUE7O0FBbEJBO0FBb0JBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVkE7O0FBQ0E7QUFBQTtBQVVBO0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEvQ0E7O0FBbUJBO0FBQUE7QUE2QkE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRkE7QUFJQTs7Ozs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBOztBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUFBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTs7QUFIQTtBQUFBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFJQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTs7QUFFQTs7QUFIQTtBQUFBOztBQUFBO0FBSUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFaQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQWFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBTUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBREE7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7QUFDQTs7OztBQUNBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFvQkE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBaUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQVBBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBN0dBO0FBQUE7QUFBQTtBQUNBO0FBRUE7O0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFIQTs7QUFDQTtBQUFBO0FBR0E7QUFKQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUNBOzs7OztBQWdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFLQTtBQVZBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFhQTtBQUNBO0FBREE7O0FBR0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3N0YXRlL2Rpc3QvaW5kZXguanM/ZTFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0LCBmaW5kQ2x1c3RlckJyZWFrIH0gZnJvbSAnQGNvZGVtaXJyb3IvdGV4dCc7XG5leHBvcnQgeyBUZXh0IH0gZnJvbSAnQGNvZGVtaXJyb3IvdGV4dCc7XG5cbmNvbnN0IERlZmF1bHRTcGxpdCA9IC9cXHJcXG4/fFxcbi87XG4vKipcbkRpc3Rpbmd1aXNoZXMgZGlmZmVyZW50IHdheXMgaW4gd2hpY2ggcG9zaXRpb25zIGNhbiBiZSBtYXBwZWQuXG4qL1xudmFyIE1hcE1vZGUgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChNYXBNb2RlKSB7XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdG8gYSB2YWxpZCBuZXcgcG9zaXRpb24sIGV2ZW4gd2hlbiBpdHMgY29udGV4dFxuICAgIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiU2ltcGxlXCJdID0gMF0gPSBcIlNpbXBsZVwiO1xuICAgIC8qKlxuICAgIFJldHVybiBudWxsIGlmIGRlbGV0aW9uIGhhcHBlbnMgYWNyb3NzIHRoZSBwb3NpdGlvbi5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrRGVsXCJdID0gMV0gPSBcIlRyYWNrRGVsXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYmVmb3JlXyB0aGUgcG9zaXRpb24gaXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIE1hcE1vZGVbTWFwTW9kZVtcIlRyYWNrQmVmb3JlXCJdID0gMl0gPSBcIlRyYWNrQmVmb3JlXCI7XG4gICAgLyoqXG4gICAgUmV0dXJuIG51bGwgaWYgdGhlIGNoYXJhY3RlciBfYWZ0ZXJfIHRoZSBwb3NpdGlvbiBpcyBkZWxldGVkLlxuICAgICovXG4gICAgTWFwTW9kZVtNYXBNb2RlW1wiVHJhY2tBZnRlclwiXSA9IDNdID0gXCJUcmFja0FmdGVyXCI7XG5yZXR1cm4gTWFwTW9kZX0pKE1hcE1vZGUgfHwgKE1hcE1vZGUgPSB7fSkpO1xuLyoqXG5BIGNoYW5nZSBkZXNjcmlwdGlvbiBpcyBhIHZhcmlhbnQgb2YgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KVxudGhhdCBkb2Vzbid0IHN0b3JlIHRoZSBpbnNlcnRlZCB0ZXh0LiBBcyBzdWNoLCBpdCBjYW4ndCBiZVxuYXBwbGllZCwgYnV0IGlzIGNoZWFwZXIgdG8gc3RvcmUgYW5kIG1hbmlwdWxhdGUuXG4qL1xuY2xhc3MgQ2hhbmdlRGVzYyB7XG4gICAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgICAvLyBsZW5ndGggaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQsIGFuZCB0aGUgc2Vjb25kIGlzIC0xIGZvclxuICAgIC8vIHVuYWZmZWN0ZWQgc2VjdGlvbnMsIGFuZCB0aGUgbGVuZ3RoIG9mIHRoZSByZXBsYWNlbWVudCBjb250ZW50XG4gICAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgICAvLyAwKSwgYW5kIGEgcmVwbGFjZW1lbnQgdHdvIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc2VjdGlvbnNbaV07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoZSBjaGFuZ2UuXG4gICAgKi9cbiAgICBnZXQgbmV3TGVuZ3RoKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5zID0gdGhpcy5zZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5zIDwgMCA/IHRoaXMuc2VjdGlvbnNbaV0gOiBpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMuc2VjdGlvbnMubGVuZ3RoID09IDIgJiYgdGhpcy5zZWN0aW9uc1sxXSA8IDA7IH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpdGVyR2FwcyhmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3NBID0gMCwgcG9zQiA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgZihwb3NBLCBwb3NCLCBsZW4pO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zQiArPSBpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3NBICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBjaGFuZ2VkIGJ5IHRoZXNlIGNoYW5nZXMuIChTZWVcbiAgICBbYENoYW5nZVNldC5pdGVyQ2hhbmdlc2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzKSBmb3IgYVxuICAgIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgICBcbiAgICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzICh3aGljaCBhcmUga2VwdFxuICAgIHNlcGFyYXRlIGZvciBbcG9zaXRpb24gbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjLm1hcFBvcykpIGFyZVxuICAgIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICAgKi9cbiAgICBpdGVyQ2hhbmdlZFJhbmdlcyhmLCBpbmRpdmlkdWFsID0gZmFsc2UpIHtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgZiwgaW5kaXZpZHVhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnZlcnRlZCBmb3JtIG9mIHRoZXNlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gobGVuLCBpbnMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goaW5zLCBsZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXB1dGUgdGhlIGNvbWJpbmVkIGVmZmVjdCBvZiBhcHBseWluZyBhbm90aGVyIHNldCBvZiBjaGFuZ2VzXG4gICAgYWZ0ZXIgdGhpcyBvbmUuIFRoZSBsZW5ndGggb2YgdGhlIGRvY3VtZW50IGFmdGVyIHRoaXMgc2V0IHNob3VsZFxuICAgIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICAgKi9cbiAgICBjb21wb3NlRGVzYyhvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIpOyB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZGVzY3JpcHRpb24sIHdoaWNoIHNob3VsZCBzdGFydCB3aXRoIHRoZSBzYW1lIGRvY3VtZW50XG4gICAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgIGFwcGxpZWQgYWZ0ZXIgaXQuIFdoZW4gYGJlZm9yZWAgaXMgdHJ1ZSwgbWFwIGFzIGlmIHRoZSBjaGFuZ2VzXG4gICAgaW4gYG90aGVyYCBoYXBwZW5lZCBiZWZvcmUgdGhlIG9uZXMgaW4gYHRoaXNgLlxuICAgICovXG4gICAgbWFwRGVzYyhvdGhlciwgYmVmb3JlID0gZmFsc2UpIHsgcmV0dXJuIG90aGVyLmVtcHR5ID8gdGhpcyA6IG1hcFNldCh0aGlzLCBvdGhlciwgYmVmb3JlKTsgfVxuICAgIG1hcFBvcyhwb3MsIGFzc29jID0gLTEsIG1vZGUgPSBNYXBNb2RlLlNpbXBsZSkge1xuICAgICAgICBsZXQgcG9zQSA9IDAsIHBvc0IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgaW5zID0gdGhpcy5zZWN0aW9uc1tpKytdLCBlbmRBID0gcG9zQSArIGxlbjtcbiAgICAgICAgICAgIGlmIChpbnMgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NCICsgKHBvcyAtIHBvc0EpO1xuICAgICAgICAgICAgICAgIHBvc0IgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgIT0gTWFwTW9kZS5TaW1wbGUgJiYgZW5kQSA+PSBwb3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1vZGUgPT0gTWFwTW9kZS5UcmFja0RlbCAmJiBwb3NBIDwgcG9zICYmIGVuZEEgPiBwb3MgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGUgPT0gTWFwTW9kZS5UcmFja0JlZm9yZSAmJiBwb3NBIDwgcG9zIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID09IE1hcE1vZGUuVHJhY2tBZnRlciAmJiBlbmRBID4gcG9zKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGVuZEEgPiBwb3MgfHwgZW5kQSA9PSBwb3MgJiYgYXNzb2MgPCAwICYmICFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3MgPT0gcG9zQSB8fCBhc3NvYyA8IDAgPyBwb3NCIDogcG9zQiArIGlucztcbiAgICAgICAgICAgICAgICBwb3NCICs9IGlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0EgPSBlbmRBO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPiBwb3NBKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtwb3NBfWApO1xuICAgICAgICByZXR1cm4gcG9zQjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGVzZSBjaGFuZ2VzIHRvdWNoIGEgZ2l2ZW4gcmFuZ2UuIFdoZW4gb25lIG9mIHRoZVxuICAgIGNoYW5nZXMgZW50aXJlbHkgY292ZXJzIHRoZSByYW5nZSwgdGhlIHN0cmluZyBgXCJjb3ZlclwiYCBpc1xuICAgIHJldHVybmVkLlxuICAgICovXG4gICAgdG91Y2hlc1JhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoICYmIHBvcyA8PSB0bzspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXSwgZW5kID0gcG9zICsgbGVuO1xuICAgICAgICAgICAgaWYgKGlucyA+PSAwICYmIHBvcyA8PSB0byAmJiBlbmQgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zIDwgZnJvbSAmJiBlbmQgPiB0byA/IFwiY292ZXJcIiA6IHRydWU7XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLnNlY3Rpb25zW2krK10sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIgXCIgOiBcIlwiKSArIGxlbiArIChpbnMgPj0gMCA/IFwiOlwiICsgaW5zIDogXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIGRlc2MgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB0aGlzLnNlY3Rpb25zOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcbiAgICBieSBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlRGVzYy50b0pTT04pLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24pIHx8IGpzb24ubGVuZ3RoICUgMiB8fCBqc29uLnNvbWUoYSA9PiB0eXBlb2YgYSAhPSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZURlc2NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlRGVzYyhqc29uKTtcbiAgICB9XG59XG4vKipcbkEgY2hhbmdlIHNldCByZXByZXNlbnRzIGEgZ3JvdXAgb2YgbW9kaWZpY2F0aW9ucyB0byBhIGRvY3VtZW50LiBJdFxuc3RvcmVzIHRoZSBkb2N1bWVudCBsZW5ndGgsIGFuZCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGRvY3VtZW50c1xud2l0aCBleGFjdGx5IHRoYXQgbGVuZ3RoLlxuKi9cbmNsYXNzIENoYW5nZVNldCBleHRlbmRzIENoYW5nZURlc2Mge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VjdGlvbnMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW5zZXJ0ZWQpIHtcbiAgICAgICAgc3VwZXIoc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLmluc2VydGVkID0gaW5zZXJ0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFwcGx5IHRoZSBjaGFuZ2VzIHRvIGEgZG9jdW1lbnQsIHJldHVybmluZyB0aGUgbW9kaWZpZWRcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT0gZG9jLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcbiAgICAgICAgaXRlckNoYW5nZXModGhpcywgKGZyb21BLCB0b0EsIGZyb21CLCBfdG9CLCB0ZXh0KSA9PiBkb2MgPSBkb2MucmVwbGFjZShmcm9tQiwgZnJvbUIgKyAodG9BIC0gZnJvbUEpLCB0ZXh0KSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBtYXBEZXNjKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gdGhlIGRvY3VtZW50IGFzIGl0IGV4aXN0ZWQgX2JlZm9yZV8gdGhlIGNoYW5nZXMsIHJldHVybiBhXG4gICAgY2hhbmdlIHNldCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2Ugb2YgdGhpcyBzZXQsIHdoaWNoIGNvdWxkXG4gICAgYmUgdXNlZCB0byBnbyBmcm9tIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IHRoZSBjaGFuZ2VzIGJhY2sgdG9cbiAgICB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBiZWZvcmUgdGhlIGNoYW5nZXMuXG4gICAgKi9cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHNlY3Rpb25zW2ldLCBpbnMgPSBzZWN0aW9uc1tpICsgMV07XG4gICAgICAgICAgICBpZiAoaW5zID49IDApIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpXSA9IGlucztcbiAgICAgICAgICAgICAgICBzZWN0aW9uc1tpICsgMV0gPSBsZW47XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gaSA+PiAxO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpbnNlcnRlZC5sZW5ndGggPCBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZC5wdXNoKGxlbiA/IGRvYy5zbGljZShwb3MsIHBvcyArIGxlbikgOiBUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tYmluZSB0d28gc3Vic2VxdWVudCBjaGFuZ2Ugc2V0cyBpbnRvIGEgc2luZ2xlIHNldC4gYG90aGVyYFxuICAgIG11c3Qgc3RhcnQgaW4gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGB0aGlzYC4gSWYgYHRoaXNgIGdvZXNcbiAgICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcbiAgICByZXR1cm5lZCB2YWx1ZSB3aWxsIHJlcHJlc2VudCB0aGUgY2hhbmdlIGBkb2NBYCDihpIgYGRvY0NgLlxuICAgICovXG4gICAgY29tcG9zZShvdGhlcikgeyByZXR1cm4gdGhpcy5lbXB0eSA/IG90aGVyIDogb3RoZXIuZW1wdHkgPyB0aGlzIDogY29tcG9zZVNldHModGhpcywgb3RoZXIsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYW5vdGhlciBjaGFuZ2Ugc2V0IHN0YXJ0aW5nIGluIHRoZSBzYW1lIGRvY3VtZW50LCBtYXBzIHRoaXNcbiAgICBjaGFuZ2Ugc2V0IG92ZXIgdGhlIG90aGVyLCBwcm9kdWNpbmcgYSBuZXcgY2hhbmdlIHNldCB0aGF0IGNhbiBiZVxuICAgIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGFwcGx5aW5nIGBvdGhlcmAuIFdoZW5cbiAgICBgYmVmb3JlYCBpcyBgdHJ1ZWAsIG9yZGVyIGNoYW5nZXMgYXMgaWYgYHRoaXNgIGNvbWVzIGJlZm9yZVxuICAgIGBvdGhlcmAsIG90aGVyd2lzZSAodGhlIGRlZmF1bHQpIHRyZWF0IGBvdGhlcmAgYXMgY29taW5nIGZpcnN0LlxuICAgIFxuICAgIEdpdmVuIHR3byBjaGFuZ2VzIGBBYCBhbmQgYEJgLCBgQS5jb21wb3NlKEIubWFwKEEpKWAgYW5kXG4gICAgYEIuY29tcG9zZShBLm1hcChCLCB0cnVlKSlgIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBkb2N1bWVudC4gVGhpc1xuICAgIHByb3ZpZGVzIGEgYmFzaWMgZm9ybSBvZiBbb3BlcmF0aW9uYWxcbiAgICB0cmFuc2Zvcm1hdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlcmF0aW9uYWxfdHJhbnNmb3JtYXRpb24pLFxuICAgIGFuZCBjYW4gYmUgdXNlZCBmb3IgY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuICAgICovXG4gICAgbWFwKG90aGVyLCBiZWZvcmUgPSBmYWxzZSkgeyByZXR1cm4gb3RoZXIuZW1wdHkgPyB0aGlzIDogbWFwU2V0KHRoaXMsIG90aGVyLCBiZWZvcmUsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbiB0aGUgZG9jdW1lbnQsIGNhbGxpbmcgYGZgIGZvclxuICAgIGVhY2guXG4gICAgXG4gICAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyBhcmUgcmVwb3J0ZWRcbiAgICBzZXBhcmF0ZWx5LlxuICAgICovXG4gICAgaXRlckNoYW5nZXMoZiwgaW5kaXZpZHVhbCA9IGZhbHNlKSB7XG4gICAgICAgIGl0ZXJDaGFuZ2VzKHRoaXMsIGYsIGluZGl2aWR1YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbY2hhbmdlIGRlc2NyaXB0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MpIGZvciB0aGlzIGNoYW5nZVxuICAgIHNldC5cbiAgICAqL1xuICAgIGdldCBkZXNjKCkgeyByZXR1cm4gbmV3IENoYW5nZURlc2ModGhpcy5zZWN0aW9ucyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpbHRlcihyYW5nZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdFNlY3Rpb25zID0gW10sIHJlc3VsdEluc2VydGVkID0gW10sIGZpbHRlcmVkU2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IGl0ZXIgPSBuZXcgU2VjdGlvbkl0ZXIodGhpcyk7XG4gICAgICAgIGRvbmU6IGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOzspIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA9PSByYW5nZXMubGVuZ3RoID8gMWU5IDogcmFuZ2VzW2krK107XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgbmV4dCB8fCBwb3MgPT0gbmV4dCAmJiBpdGVyLmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZG9uZTtcbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oaXRlci5sZW4sIG5leHQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCAtMSk7XG4gICAgICAgICAgICAgICAgbGV0IGlucyA9IGl0ZXIuaW5zID09IC0xID8gLTEgOiBpdGVyLm9mZiA9PSAwID8gaXRlci5pbnMgOiAwO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgaW5zKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zID4gMClcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KHJlc3VsdEluc2VydGVkLCByZXN1bHRTZWN0aW9ucywgaXRlci50ZXh0KTtcbiAgICAgICAgICAgICAgICBpdGVyLmZvcndhcmQobGVuKTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlc1tpKytdO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyLmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGRvbmU7XG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IE1hdGgubWluKGl0ZXIubGVuLCBlbmQgLSBwb3MpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24ocmVzdWx0U2VjdGlvbnMsIGxlbiwgLTEpO1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oZmlsdGVyZWRTZWN0aW9ucywgbGVuLCBpdGVyLmlucyA9PSAtMSA/IC0xIDogaXRlci5vZmYgPT0gMCA/IGl0ZXIuaW5zIDogMCk7XG4gICAgICAgICAgICAgICAgaXRlci5mb3J3YXJkKGxlbik7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXcgQ2hhbmdlU2V0KHJlc3VsdFNlY3Rpb25zLCByZXN1bHRJbnNlcnRlZCksXG4gICAgICAgICAgICBmaWx0ZXJlZDogbmV3IENoYW5nZURlc2MoZmlsdGVyZWRTZWN0aW9ucykgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIHNldCB0byBhIEpTT04tcmVwcmVzZW50YWJsZSB2YWx1ZS5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuc2VjdGlvbnNbaV0sIGlucyA9IHRoaXMuc2VjdGlvbnNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGlucyA8IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChsZW4pO1xuICAgICAgICAgICAgZWxzZSBpZiAoaW5zID09IDApXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChbbGVuXS5jb25jYXQodGhpcy5pbnNlcnRlZFtpID4+IDFdLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjaGFuZ2Ugc2V0IGZvciB0aGUgZ2l2ZW4gY2hhbmdlcywgZm9yIGEgZG9jdW1lbnQgb2YgdGhlXG4gICAgZ2l2ZW4gbGVuZ3RoLCB1c2luZyBgbGluZVNlcGAgYXMgbGluZSBzZXBhcmF0b3IuXG4gICAgKi9cbiAgICBzdGF0aWMgb2YoY2hhbmdlcywgbGVuZ3RoLCBsaW5lU2VwKSB7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnRlZCA9IFtdLCBwb3MgPSAwO1xuICAgICAgICBsZXQgdG90YWwgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBmbHVzaChmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWZvcmNlICYmICFzZWN0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHBvcyA8IGxlbmd0aClcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW5ndGggLSBwb3MsIC0xKTtcbiAgICAgICAgICAgIGxldCBzZXQgPSBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsID8gdG90YWwuY29tcG9zZShzZXQubWFwKHRvdGFsKSkgOiBzZXQ7XG4gICAgICAgICAgICBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgaW5zZXJ0ZWQgPSBbXTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvY2VzcyhzcGVjKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHN1YiBvZiBzcGVjKVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKHN1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcGVjIGluc3RhbmNlb2YgQ2hhbmdlU2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMubGVuZ3RoICE9IGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE1pc21hdGNoZWQgY2hhbmdlIHNldCBsZW5ndGggKGdvdCAke3NwZWMubGVuZ3RofSwgZXhwZWN0ZWQgJHtsZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbCA/IHRvdGFsLmNvbXBvc2Uoc3BlYy5tYXAodG90YWwpKSA6IHNwZWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byA9IGZyb20sIGluc2VydCB9ID0gc3BlYztcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+IHRvIHx8IGZyb20gPCAwIHx8IHRvID4gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjaGFuZ2UgcmFuZ2UgJHtmcm9tfSB0byAke3RvfSAoaW4gZG9jIG9mIGxlbmd0aCAke2xlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgbGV0IGluc1RleHQgPSAhaW5zZXJ0ID8gVGV4dC5lbXB0eSA6IHR5cGVvZiBpbnNlcnQgPT0gXCJzdHJpbmdcIiA/IFRleHQub2YoaW5zZXJ0LnNwbGl0KGxpbmVTZXAgfHwgRGVmYXVsdFNwbGl0KSkgOiBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGluc0xlbiA9IGluc1RleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIGluc0xlbiA9PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGZyb20gLSBwb3MsIC0xKTtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCB0byAtIGZyb20sIGluc0xlbik7XG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydGVkLCBzZWN0aW9ucywgaW5zVGV4dCk7XG4gICAgICAgICAgICAgICAgcG9zID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2VzcyhjaGFuZ2VzKTtcbiAgICAgICAgZmx1c2goIXRvdGFsKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICAgKi9cbiAgICBzdGF0aWMgZW1wdHkobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KGxlbmd0aCA/IFtsZW5ndGgsIC0xXSA6IFtdLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICAgIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQudG9KU09OKS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIHJlcHJlc2VudGF0aW9uIG9mIENoYW5nZVNldFwiKTtcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW10sIGluc2VydGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSBqc29uW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHBhcnQsIC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHBhcnQpIHx8IHR5cGVvZiBwYXJ0WzBdICE9IFwibnVtYmVyXCIgfHwgcGFydC5zb21lKChlLCBpKSA9PiBpICYmIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydC5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIHNlY3Rpb25zLnB1c2gocGFydFswXSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5zZXJ0ZWQubGVuZ3RoIDwgaSlcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFtpXSA9IFRleHQub2YocGFydC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChwYXJ0WzBdLCBpbnNlcnRlZFtpXS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnRlZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkU2VjdGlvbihzZWN0aW9ucywgbGVuLCBpbnMsIGZvcmNlSm9pbiA9IGZhbHNlKSB7XG4gICAgaWYgKGxlbiA9PSAwICYmIGlucyA8PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxhc3QgPSBzZWN0aW9ucy5sZW5ndGggLSAyO1xuICAgIGlmIChsYXN0ID49IDAgJiYgaW5zIDw9IDAgJiYgaW5zID09IHNlY3Rpb25zW2xhc3QgKyAxXSlcbiAgICAgICAgc2VjdGlvbnNbbGFzdF0gKz0gbGVuO1xuICAgIGVsc2UgaWYgKGxlbiA9PSAwICYmIHNlY3Rpb25zW2xhc3RdID09IDApXG4gICAgICAgIHNlY3Rpb25zW2xhc3QgKyAxXSArPSBpbnM7XG4gICAgZWxzZSBpZiAoZm9yY2VKb2luKSB7XG4gICAgICAgIHNlY3Rpb25zW2xhc3RdICs9IGxlbjtcbiAgICAgICAgc2VjdGlvbnNbbGFzdCArIDFdICs9IGlucztcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBzZWN0aW9ucy5wdXNoKGxlbiwgaW5zKTtcbn1cbmZ1bmN0aW9uIGFkZEluc2VydCh2YWx1ZXMsIHNlY3Rpb25zLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBpbmRleCA9IChzZWN0aW9ucy5sZW5ndGggLSAyKSA+PiAxO1xuICAgIGlmIChpbmRleCA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0uYXBwZW5kKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoIDwgaW5kZXgpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChUZXh0LmVtcHR5KTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGl0ZXJDaGFuZ2VzKGRlc2MsIGYsIGluZGl2aWR1YWwpIHtcbiAgICBsZXQgaW5zZXJ0ZWQgPSBkZXNjLmluc2VydGVkO1xuICAgIGZvciAobGV0IHBvc0EgPSAwLCBwb3NCID0gMCwgaSA9IDA7IGkgPCBkZXNjLnNlY3Rpb25zLmxlbmd0aDspIHtcbiAgICAgICAgbGV0IGxlbiA9IGRlc2Muc2VjdGlvbnNbaSsrXSwgaW5zID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICBpZiAoaW5zIDwgMCkge1xuICAgICAgICAgICAgcG9zQSArPSBsZW47XG4gICAgICAgICAgICBwb3NCICs9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBlbmRBID0gcG9zQSwgZW5kQiA9IHBvc0IsIHRleHQgPSBUZXh0LmVtcHR5O1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGVuZEEgKz0gbGVuO1xuICAgICAgICAgICAgICAgIGVuZEIgKz0gaW5zO1xuICAgICAgICAgICAgICAgIGlmIChpbnMgJiYgaW5zZXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LmFwcGVuZChpbnNlcnRlZFsoaSAtIDIpID4+IDFdKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kaXZpZHVhbCB8fCBpID09IGRlc2Muc2VjdGlvbnMubGVuZ3RoIHx8IGRlc2Muc2VjdGlvbnNbaSArIDFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGVuID0gZGVzYy5zZWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgICAgIGlucyA9IGRlc2Muc2VjdGlvbnNbaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYocG9zQSwgZW5kQSwgcG9zQiwgZW5kQiwgdGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kQTtcbiAgICAgICAgICAgIHBvc0IgPSBlbmRCO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwU2V0KHNldEEsIHNldEIsIGJlZm9yZSwgbWtTZXQgPSBmYWxzZSkge1xuICAgIGxldCBzZWN0aW9ucyA9IFtdLCBpbnNlcnQgPSBta1NldCA/IFtdIDogbnVsbDtcbiAgICBsZXQgYSA9IG5ldyBTZWN0aW9uSXRlcihzZXRBKSwgYiA9IG5ldyBTZWN0aW9uSXRlcihzZXRCKTtcbiAgICBmb3IgKGxldCBwb3NBID0gMCwgcG9zQiA9IDA7Oykge1xuICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgIHBvc0EgKz0gYS5sZW47XG4gICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSAmJiBwb3NCIDwgcG9zQSkge1xuICAgICAgICAgICAgbGV0IHNraXAgPSBNYXRoLm1pbihiLmxlbiwgcG9zQSAtIHBvc0IpO1xuICAgICAgICAgICAgYi5mb3J3YXJkKHNraXApO1xuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgc2tpcCwgLTEpO1xuICAgICAgICAgICAgcG9zQiArPSBza2lwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuaW5zID49IDAgJiYgKGEuZG9uZSB8fCBwb3NCIDwgcG9zQSB8fCBwb3NCID09IHBvc0EgJiYgKGIubGVuIDwgYS5sZW4gfHwgYi5sZW4gPT0gYS5sZW4gJiYgIWJlZm9yZSkpKSB7XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBiLmlucywgLTEpO1xuICAgICAgICAgICAgd2hpbGUgKHBvc0EgPiBwb3NCICYmICFhLmRvbmUgJiYgcG9zQSArIGEubGVuIDwgcG9zQiArIGIubGVuKSB7XG4gICAgICAgICAgICAgICAgcG9zQSArPSBhLmxlbjtcbiAgICAgICAgICAgICAgICBhLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc0IgKz0gYi5sZW47XG4gICAgICAgICAgICBiLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmlucyA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gMCwgZW5kID0gcG9zQSArIGEubGVuO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChiLmlucyA+PSAwICYmIHBvc0IgPiBwb3NBICYmIHBvc0IgKyBiLmxlbiA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gYi5pbnM7XG4gICAgICAgICAgICAgICAgICAgIHBvc0IgKz0gYi5sZW47XG4gICAgICAgICAgICAgICAgICAgIGIubmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSAmJiBwb3NCIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBza2lwID0gTWF0aC5taW4oYi5sZW4sIGVuZCAtIHBvc0IpO1xuICAgICAgICAgICAgICAgICAgICBsZW4gKz0gc2tpcDtcbiAgICAgICAgICAgICAgICAgICAgYi5mb3J3YXJkKHNraXApO1xuICAgICAgICAgICAgICAgICAgICBwb3NCICs9IHNraXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGEuaW5zKTtcbiAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGEudGV4dCk7XG4gICAgICAgICAgICBwb3NBID0gZW5kO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lICYmIGIuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydCA/IG5ldyBDaGFuZ2VTZXQoc2VjdGlvbnMsIGluc2VydCkgOiBuZXcgQ2hhbmdlRGVzYyhzZWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTZXRzKHNldEEsIHNldEIsIG1rU2V0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICBsZXQgaW5zZXJ0ID0gbWtTZXQgPyBbXSA6IG51bGw7XG4gICAgbGV0IGEgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0QSksIGIgPSBuZXcgU2VjdGlvbkl0ZXIoc2V0Qik7XG4gICAgZm9yIChsZXQgb3BlbiA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGEuZG9uZSAmJiBiLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnQgPyBuZXcgQ2hhbmdlU2V0KHNlY3Rpb25zLCBpbnNlcnQpIDogbmV3IENoYW5nZURlc2Moc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5zID09IDApIHsgLy8gRGVsZXRpb24gaW4gQVxuICAgICAgICAgICAgYWRkU2VjdGlvbihzZWN0aW9ucywgYS5sZW4sIDAsIG9wZW4pO1xuICAgICAgICAgICAgYS5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYi5sZW4gPT0gMCAmJiAhYi5kb25lKSB7IC8vIEluc2VydGlvbiBpbiBCXG4gICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCAwLCBiLmlucywgb3Blbik7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0KVxuICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBiLnRleHQpO1xuICAgICAgICAgICAgYi5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kb25lIHx8IGIuZG9uZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbGVuID0gTWF0aC5taW4oYS5sZW4yLCBiLmxlbiksIHNlY3Rpb25MZW4gPSBzZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zQiA9IGIuaW5zID09IC0xID8gLTEgOiBiLm9mZiA/IDAgOiBiLmlucztcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBsZW4sIGluc0IsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgaW5zQilcbiAgICAgICAgICAgICAgICAgICAgYWRkSW5zZXJ0KGluc2VydCwgc2VjdGlvbnMsIGIudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiLmlucyA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFkZFNlY3Rpb24oc2VjdGlvbnMsIGEub2ZmID8gMCA6IGEubGVuLCBsZW4sIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQpXG4gICAgICAgICAgICAgICAgICAgIGFkZEluc2VydChpbnNlcnQsIHNlY3Rpb25zLCBhLnRleHRCaXQobGVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWN0aW9uKHNlY3Rpb25zLCBhLm9mZiA/IDAgOiBhLmxlbiwgYi5vZmYgPyAwIDogYi5pbnMsIG9wZW4pO1xuICAgICAgICAgICAgICAgIGlmIChpbnNlcnQgJiYgIWIub2ZmKVxuICAgICAgICAgICAgICAgICAgICBhZGRJbnNlcnQoaW5zZXJ0LCBzZWN0aW9ucywgYi50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wZW4gPSAoYS5pbnMgPiBsZW4gfHwgYi5pbnMgPj0gMCAmJiBiLmxlbiA+IGxlbikgJiYgKG9wZW4gfHwgc2VjdGlvbnMubGVuZ3RoID4gc2VjdGlvbkxlbik7XG4gICAgICAgICAgICBhLmZvcndhcmQyKGxlbik7XG4gICAgICAgICAgICBiLmZvcndhcmQobGVuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNlY3Rpb25JdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXQpIHtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBzZWN0aW9ucyB9ID0gdGhpcy5zZXQ7XG4gICAgICAgIGlmICh0aGlzLmkgPCBzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGVuID0gc2VjdGlvbnNbdGhpcy5pKytdO1xuICAgICAgICAgICAgdGhpcy5pbnMgPSBzZWN0aW9uc1t0aGlzLmkrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICAgICAgICB0aGlzLmlucyA9IC0yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2ZmID0gMDtcbiAgICB9XG4gICAgZ2V0IGRvbmUoKSB7IHJldHVybiB0aGlzLmlucyA9PSAtMjsgfVxuICAgIGdldCBsZW4yKCkgeyByZXR1cm4gdGhpcy5pbnMgPCAwID8gdGhpcy5sZW4gOiB0aGlzLmluczsgfVxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggPyBUZXh0LmVtcHR5IDogaW5zZXJ0ZWRbaW5kZXhdO1xuICAgIH1cbiAgICB0ZXh0Qml0KGxlbikge1xuICAgICAgICBsZXQgeyBpbnNlcnRlZCB9ID0gdGhpcy5zZXQsIGluZGV4ID0gKHRoaXMuaSAtIDIpID4+IDE7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSBpbnNlcnRlZC5sZW5ndGggJiYgIWxlbiA/IFRleHQuZW1wdHlcbiAgICAgICAgICAgIDogaW5zZXJ0ZWRbaW5kZXhdLnNsaWNlKHRoaXMub2ZmLCBsZW4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRoaXMub2ZmICsgbGVuKTtcbiAgICB9XG4gICAgZm9yd2FyZChsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGVuIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3J3YXJkMihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zID09IC0xKVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PSB0aGlzLmlucylcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5zIC09IGxlbjtcbiAgICAgICAgICAgIHRoaXMub2ZmICs9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG5BIHNpbmdsZSBzZWxlY3Rpb24gcmFuZ2UuIFdoZW5cbltgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKVxuaXMgZW5hYmxlZCwgYSBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbikgbWF5IGhvbGRcbm11bHRpcGxlIHJhbmdlcy4gQnkgZGVmYXVsdCwgc2VsZWN0aW9ucyBob2xkIGV4YWN0bHkgb25lIHJhbmdlLlxuKi9cbmNsYXNzIFNlbGVjdGlvblJhbmdlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgdG8sIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYW5jaG9yIG9mIHRoZSByYW5nZeKAlHRoZSBzaWRlIHRoYXQgZG9lc24ndCBtb3ZlIHdoZW4geW91XG4gICAgZXh0ZW5kIGl0LlxuICAgICovXG4gICAgZ2V0IGFuY2hvcigpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxNiAvKiBJbnZlcnRlZCAqLyA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gICAgW2V4dGVuZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmV4dGVuZCkuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxNiAvKiBJbnZlcnRlZCAqLyA/IHRoaXMuZnJvbSA6IHRoaXMudG87IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gYGFuY2hvcmAgYW5kIGBoZWFkYCBhcmUgYXQgdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZyb20gPT0gdGhpcy50bzsgfVxuICAgIC8qKlxuICAgIElmIHRoaXMgaXMgYSBjdXJzb3IgdGhhdCBpcyBleHBsaWNpdGx5IGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICBjaGFyYWN0ZXIgb24gb25lIG9mIGl0cyBzaWRlcywgdGhpcyByZXR1cm5zIHRoZSBzaWRlLiAtMSBtZWFuc1xuICAgIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICAgIG1lYW5zIG5vIGFzc29jaWF0aW9uLlxuICAgICovXG4gICAgZ2V0IGFzc29jKCkgeyByZXR1cm4gdGhpcy5mbGFncyAmIDQgLyogQXNzb2NCZWZvcmUgKi8gPyAtMSA6IHRoaXMuZmxhZ3MgJiA4IC8qIEFzc29jQWZ0ZXIgKi8gPyAxIDogMDsgfVxuICAgIC8qKlxuICAgIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICAgIGFueS5cbiAgICAqL1xuICAgIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgICAgIGxldCBsZXZlbCA9IHRoaXMuZmxhZ3MgJiAzIC8qIEJpZGlMZXZlbE1hc2sgKi87XG4gICAgICAgIHJldHVybiBsZXZlbCA9PSAzID8gbnVsbCA6IGxldmVsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZ29hbCBjb2x1bW4gKHN0b3JlZCB2ZXJ0aWNhbCBvZmZzZXQpIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgICBbbW92aW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5tb3ZlVmVydGljYWxseSkgYWNyb3NzXG4gICAgbGluZXMgb2YgZGlmZmVyZW50IGxlbmd0aC5cbiAgICAqL1xuICAgIGdldCBnb2FsQ29sdW1uKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmZsYWdzID4+IDUgLyogR29hbENvbHVtbk9mZnNldCAqLztcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IDMzNTU0NDMxIC8qIE5vR29hbENvbHVtbiAqLyA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhpcyByYW5nZSB0aHJvdWdoIGEgY2hhbmdlLCBwcm9kdWNpbmcgYSB2YWxpZCByYW5nZSBpbiB0aGVcbiAgICB1cGRhdGVkIGRvY3VtZW50LlxuICAgICovXG4gICAgbWFwKGNoYW5nZSwgYXNzb2MgPSAtMSkge1xuICAgICAgICBsZXQgZnJvbSA9IGNoYW5nZS5tYXBQb3ModGhpcy5mcm9tLCBhc3NvYyksIHRvID0gY2hhbmdlLm1hcFBvcyh0aGlzLnRvLCBhc3NvYyk7XG4gICAgICAgIHJldHVybiBmcm9tID09IHRoaXMuZnJvbSAmJiB0byA9PSB0aGlzLnRvID8gdGhpcyA6IG5ldyBTZWxlY3Rpb25SYW5nZShmcm9tLCB0bywgdGhpcy5mbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHJhbmdlIHRvIGNvdmVyIGF0IGxlYXN0IGBmcm9tYCB0byBgdG9gLlxuICAgICovXG4gICAgZXh0ZW5kKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA8PSB0aGlzLmFuY2hvciAmJiB0byA+PSB0aGlzLmFuY2hvcilcbiAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICBsZXQgaGVhZCA9IE1hdGguYWJzKGZyb20gLSB0aGlzLmFuY2hvcikgPiBNYXRoLmFicyh0byAtIHRoaXMuYW5jaG9yKSA/IGZyb20gOiB0bztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0aGlzLmFuY2hvciwgaGVhZCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyByYW5nZSB0byBhbm90aGVyIHJhbmdlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yID09IG90aGVyLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gb3RoZXIuaGVhZDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7IHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9OyB9XG4gICAgLyoqXG4gICAgQ29udmVydCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSByYW5nZSB0byBhIGBTZWxlY3Rpb25SYW5nZWBcbiAgICBpbnN0YW5jZS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCB0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgU2VsZWN0aW9uUmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoanNvbi5hbmNob3IsIGpzb24uaGVhZCk7XG4gICAgfVxufVxuLyoqXG5BbiBlZGl0b3Igc2VsZWN0aW9uIGhvbGRzIG9uZSBvciBtb3JlIHNlbGVjdGlvbiByYW5nZXMuXG4qL1xuY2xhc3MgRWRpdG9yU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSByYW5nZXMgaW4gdGhlIHNlbGVjdGlvbiwgc29ydGVkIGJ5IHBvc2l0aW9uLiBSYW5nZXMgY2Fubm90XG4gICAgb3ZlcmxhcCAoYnV0IHRoZXkgbWF5IHRvdWNoLCBpZiB0aGV5IGFyZW4ndCBlbXB0eSkuXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBvZiB0aGUgX21haW5fIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24gKHdoaWNoIGlzXG4gICAgdXN1YWxseSB0aGUgcmFuZ2UgdGhhdCB3YXMgYWRkZWQgbGFzdCkuXG4gICAgKi9cbiAgICBtYWluSW5kZXggPSAwKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLm1haW5JbmRleCA9IG1haW5JbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgc2VsZWN0aW9uIHRocm91Z2ggYSBjaGFuZ2UuIFVzZWQgdG8gYWRqdXN0IHRoZSBzZWxlY3Rpb25cbiAgICBwb3NpdGlvbiBmb3IgY2hhbmdlcy5cbiAgICAqL1xuICAgIG1hcChjaGFuZ2UsIGFzc29jID0gLTEpIHtcbiAgICAgICAgaWYgKGNoYW5nZS5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnJhbmdlcy5tYXAociA9PiByLm1hcChjaGFuZ2UsIGFzc29jKSksIHRoaXMubWFpbkluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHNlbGVjdGlvbiB0byBhbm90aGVyIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggIT0gb3RoZXIucmFuZ2VzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5tYWluSW5kZXggIT0gb3RoZXIubWFpbkluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJhbmdlc1tpXS5lcShvdGhlci5yYW5nZXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UuIFVzdWFsbHksIHlvdSBzaG91bGQgbWFrZSBzdXJlXG4gICAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgICBbYGNoYW5nZUJ5UmFuZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYW5nZUJ5UmFuZ2UpLlxuICAgICovXG4gICAgZ2V0IG1haW4oKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLm1haW5JbmRleF07IH1cbiAgICAvKipcbiAgICBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBvbmx5IGhhcyBvbmUgcmFuZ2UuIFJldHVybnMgYSBzZWxlY3Rpb25cbiAgICBob2xkaW5nIG9ubHkgdGhlIG1haW4gcmFuZ2UgZnJvbSB0aGlzIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGFzU2luZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IEVkaXRvclNlbGVjdGlvbihbdGhpcy5tYWluXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEV4dGVuZCB0aGlzIHNlbGVjdGlvbiB3aXRoIGFuIGV4dHJhIHJhbmdlLlxuICAgICovXG4gICAgYWRkUmFuZ2UocmFuZ2UsIG1haW4gPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0uY29uY2F0KHRoaXMucmFuZ2VzKSwgbWFpbiA/IDAgOiB0aGlzLm1haW5JbmRleCArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgZ2l2ZW4gcmFuZ2Ugd2l0aCBhbm90aGVyIHJhbmdlLCBhbmQgdGhlbiBub3JtYWxpemUgdGhlXG4gICAgc2VsZWN0aW9uIHRvIG1lcmdlIGFuZCBzb3J0IHJhbmdlcyBpZiBuZWNlc3NhcnkuXG4gICAgKi9cbiAgICByZXBsYWNlUmFuZ2UocmFuZ2UsIHdoaWNoID0gdGhpcy5tYWluSW5kZXgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgIHJhbmdlc1t3aGljaF0gPSByYW5nZTtcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCB0aGlzLm1haW5JbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgICBKU09OLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyByYW5nZXM6IHRoaXMucmFuZ2VzLm1hcChyID0+IHIudG9KU09OKCkpLCBtYWluOiB0aGlzLm1haW5JbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZWxlY3Rpb24gZnJvbSBhIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24gfHwgIUFycmF5LmlzQXJyYXkoanNvbi5yYW5nZXMpIHx8IHR5cGVvZiBqc29uLm1haW4gIT0gXCJudW1iZXJcIiB8fCBqc29uLm1haW4gPj0ganNvbi5yYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclNlbGVjdGlvblwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oanNvbi5yYW5nZXMubWFwKChyKSA9PiBTZWxlY3Rpb25SYW5nZS5mcm9tSlNPTihyKSksIGpzb24ubWFpbik7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHNpbmdsZShhbmNob3IsIGhlYWQgPSBhbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24oW0VkaXRvclNlbGVjdGlvbi5yYW5nZShhbmNob3IsIGhlYWQpXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNvcnQgYW5kIG1lcmdlIHRoZSBnaXZlbiBzZXQgb2YgcmFuZ2VzLCBjcmVhdGluZyBhIHZhbGlkXG4gICAgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQSBzZWxlY3Rpb24gbmVlZHMgYXQgbGVhc3Qgb25lIHJhbmdlXCIpO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHJhbmdlLmVtcHR5ID8gcmFuZ2UuZnJvbSA8PSBwb3MgOiByYW5nZS5mcm9tIDwgcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkKHJhbmdlcy5zbGljZSgpLCBtYWluSW5kZXgpO1xuICAgICAgICAgICAgcG9zID0gcmFuZ2UudG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFZGl0b3JTZWxlY3Rpb24ocmFuZ2VzLCBtYWluSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjdXJzb3Igc2VsZWN0aW9uIHJhbmdlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gWW91IGNhblxuICAgIHNhZmVseSBpZ25vcmUgdGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBpbiBtb3N0IHNpdHVhdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3Vyc29yKHBvcywgYXNzb2MgPSAwLCBiaWRpTGV2ZWwsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb25SYW5nZShwb3MsIHBvcywgKGFzc29jID09IDAgPyAwIDogYXNzb2MgPCAwID8gNCAvKiBBc3NvY0JlZm9yZSAqLyA6IDggLyogQXNzb2NBZnRlciAqLykgfFxuICAgICAgICAgICAgKGJpZGlMZXZlbCA9PSBudWxsID8gMyA6IE1hdGgubWluKDIsIGJpZGlMZXZlbCkpIHxcbiAgICAgICAgICAgICgoZ29hbENvbHVtbiAhPT0gbnVsbCAmJiBnb2FsQ29sdW1uICE9PSB2b2lkIDAgPyBnb2FsQ29sdW1uIDogMzM1NTQ0MzEgLyogTm9Hb2FsQ29sdW1uICovKSA8PCA1IC8qIEdvYWxDb2x1bW5PZmZzZXQgKi8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VsZWN0aW9uIHJhbmdlLlxuICAgICovXG4gICAgc3RhdGljIHJhbmdlKGFuY2hvciwgaGVhZCwgZ29hbENvbHVtbikge1xuICAgICAgICBsZXQgZ29hbCA9IChnb2FsQ29sdW1uICE9PSBudWxsICYmIGdvYWxDb2x1bW4gIT09IHZvaWQgMCA/IGdvYWxDb2x1bW4gOiAzMzU1NDQzMSAvKiBOb0dvYWxDb2x1bW4gKi8pIDw8IDUgLyogR29hbENvbHVtbk9mZnNldCAqLztcbiAgICAgICAgcmV0dXJuIGhlYWQgPCBhbmNob3IgPyBuZXcgU2VsZWN0aW9uUmFuZ2UoaGVhZCwgYW5jaG9yLCAxNiAvKiBJbnZlcnRlZCAqLyB8IGdvYWwpIDogbmV3IFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCwgZ29hbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplZChyYW5nZXMsIG1haW5JbmRleCA9IDApIHtcbiAgICBsZXQgbWFpbiA9IHJhbmdlc1ttYWluSW5kZXhdO1xuICAgIHJhbmdlcy5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuICAgIG1haW5JbmRleCA9IHJhbmdlcy5pbmRleE9mKG1haW4pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSA/IHJhbmdlLmZyb20gPD0gcHJldi50byA6IHJhbmdlLmZyb20gPCBwcmV2LnRvKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHByZXYuZnJvbSwgdG8gPSBNYXRoLm1heChyYW5nZS50bywgcHJldi50byk7XG4gICAgICAgICAgICBpZiAoaSA8PSBtYWluSW5kZXgpXG4gICAgICAgICAgICAgICAgbWFpbkluZGV4LS07XG4gICAgICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgcmFuZ2UuYW5jaG9yID4gcmFuZ2UuaGVhZCA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZSh0bywgZnJvbSkgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEVkaXRvclNlbGVjdGlvbihyYW5nZXMsIG1haW5JbmRleCk7XG59XG5mdW5jdGlvbiBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvY0xlbmd0aCkge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIHNlbGVjdGlvbi5yYW5nZXMpXG4gICAgICAgIGlmIChyYW5nZS50byA+IGRvY0xlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2VsZWN0aW9uIHBvaW50cyBvdXRzaWRlIG9mIGRvY3VtZW50XCIpO1xufVxuXG5sZXQgbmV4dElEID0gMDtcbi8qKlxuQSBmYWNldCBpcyBhIGxhYmVsZWQgdmFsdWUgdGhhdCBpcyBhc3NvY2lhdGVkIHdpdGggYW4gZWRpdG9yXG5zdGF0ZS4gSXQgdGFrZXMgaW5wdXRzIGZyb20gYW55IG51bWJlciBvZiBleHRlbnNpb25zLCBhbmQgY29tYmluZXNcbnRob3NlIGludG8gYSBzaW5nbGUgb3V0cHV0IHZhbHVlLlxuXG5FeGFtcGxlcyBvZiBmYWNldHMgYXJlIHRoZSBbdGhlbWVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSBzdHlsZXNcbmFzc29jaWF0ZWQgd2l0aCBhbiBlZGl0b3Igb3IgdGhlIFt0YWJcbnNpemVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgKHdoaWNoIGlzIHJlZHVjZWQgdG8gYSBzaW5nbGVcbnZhbHVlLCB1c2luZyB0aGUgaW5wdXQgd2l0aCB0aGUgaGlnaHRlc3QgcHJlY2VkZW5jZSkuXG4qL1xuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tYmluZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlSW5wdXQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcGFyZSwgaXNTdGF0aWMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZXh0ZW5zaW9ucykge1xuICAgICAgICB0aGlzLmNvbWJpbmUgPSBjb21iaW5lO1xuICAgICAgICB0aGlzLmNvbXBhcmVJbnB1dCA9IGNvbXBhcmVJbnB1dDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gY29tYmluZShbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIG5ldyBmYWNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldChjb25maWcuY29tYmluZSB8fCAoKGEpID0+IGEpLCBjb25maWcuY29tcGFyZUlucHV0IHx8ICgoYSwgYikgPT4gYSA9PT0gYiksIGNvbmZpZy5jb21wYXJlIHx8ICghY29uZmlnLmNvbWJpbmUgPyBzYW1lQXJyYXkgOiAoYSwgYikgPT4gYSA9PT0gYiksICEhY29uZmlnLnN0YXRpYywgY29uZmlnLmVuYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGlzIGZhY2V0LlxuICAgICovXG4gICAgb2YodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGYWNldFByb3ZpZGVyKFtdLCB0aGlzLCAwIC8qIFN0YXRpYyAqLywgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgYSB2YWx1ZSBmb3IgdGhlIGZhY2V0IGZyb20gYVxuICAgIHN0YXRlLiBZb3UgbXVzdCB0YWtlIGNhcmUgdG8gZGVjbGFyZSB0aGUgcGFydHMgb2YgdGhlIHN0YXRlIHRoYXRcbiAgICB0aGlzIHZhbHVlIGRlcGVuZHMgb24sIHNpbmNlIHlvdXIgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgYWdhaW5cbiAgICBmb3IgYSBuZXcgc3RhdGUgd2hlbiBvbmUgb2YgdGhvc2UgcGFydHMgY2hhbmdlZC5cbiAgICBcbiAgICBJbiBtb3N0IGNhc2VzLCB5b3UnbGwgd2FudCB0byB1c2UgdGhlXG4gICAgW2Bwcm92aWRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUZpZWxkXmRlZmluZV5jb25maWcucHJvdmlkZSkgb3B0aW9uIHdoZW5cbiAgICBkZWZpbmluZyBhIGZpZWxkIGluc3RlYWQuXG4gICAgKi9cbiAgICBjb21wdXRlKGRlcHMsIGdldCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgICAgIHJldHVybiBuZXcgRmFjZXRQcm92aWRlcihkZXBzLCB0aGlzLCAxIC8qIFNpbmdsZSAqLywgZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGNvbXB1dGVzIHplcm8gb3IgbW9yZSB2YWx1ZXMgZm9yIHRoaXNcbiAgICBmYWNldCBmcm9tIGEgc3RhdGUuXG4gICAgKi9cbiAgICBjb21wdXRlTihkZXBzLCBnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGF0aWMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb21wdXRlIGEgc3RhdGljIGZhY2V0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZhY2V0UHJvdmlkZXIoZGVwcywgdGhpcywgMiAvKiBNdWx0aSAqLywgZ2V0KTtcbiAgICB9XG4gICAgZnJvbShmaWVsZCwgZ2V0KSB7XG4gICAgICAgIGlmICghZ2V0KVxuICAgICAgICAgICAgZ2V0ID0geCA9PiB4O1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlKFtmaWVsZF0sIHN0YXRlID0+IGdldChzdGF0ZS5maWVsZChmaWVsZCkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhID09IGIgfHwgYS5sZW5ndGggPT0gYi5sZW5ndGggJiYgYS5ldmVyeSgoZSwgaSkgPT4gZSA9PT0gYltpXSk7XG59XG5jbGFzcyBGYWNldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkZXBlbmRlbmNpZXMsIGZhY2V0LCB0eXBlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICAgICAgdGhpcy5mYWNldCA9IGZhY2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaWQgPSBuZXh0SUQrKztcbiAgICB9XG4gICAgZHluYW1pY1Nsb3QoYWRkcmVzc2VzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGdldHRlciA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCBjb21wYXJlID0gdGhpcy5mYWNldC5jb21wYXJlSW5wdXQ7XG4gICAgICAgIGxldCBpZHggPSBhZGRyZXNzZXNbdGhpcy5pZF0gPj4gMSwgbXVsdGkgPSB0aGlzLnR5cGUgPT0gMiAvKiBNdWx0aSAqLztcbiAgICAgICAgbGV0IGRlcERvYyA9IGZhbHNlLCBkZXBTZWwgPSBmYWxzZSwgZGVwQWRkcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZGVwIG9mIHRoaXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBpZiAoZGVwID09IFwiZG9jXCIpXG4gICAgICAgICAgICAgICAgZGVwRG9jID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcCA9PSBcInNlbGVjdGlvblwiKVxuICAgICAgICAgICAgICAgIGRlcFNlbCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICgoKChfYSA9IGFkZHJlc3Nlc1tkZXAuaWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSAmIDEpID09IDApXG4gICAgICAgICAgICAgICAgZGVwQWRkcnMucHVzaChhZGRyZXNzZXNbZGVwLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgdHIpID0+IHtcbiAgICAgICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgIGlmIChvbGRWYWwgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgIGxldCBkZXBDaGFuZ2VkID0gKGRlcERvYyAmJiB0ci5kb2NDaGFuZ2VkKSB8fCAoZGVwU2VsICYmICh0ci5kb2NDaGFuZ2VkIHx8IHRyLnNlbGVjdGlvbikpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRlcEFkZHJzLnNvbWUoYWRkciA9PiAoZW5zdXJlQWRkcihzdGF0ZSwgYWRkcikgJiAxIC8qIENoYW5nZWQgKi8pID4gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlcENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbCA9IGdldHRlcihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtdWx0aSA/ICFjb21wYXJlQXJyYXkobmV3VmFsLCBvbGRWYWwsIGNvbXBhcmUpIDogIWNvbXBhcmUobmV3VmFsLCBvbGRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZXNbaWR4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIENoYW5nZWQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wYXJlQXJyYXkoYSwgYiwgY29tcGFyZSkge1xuICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFjb21wYXJlKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZHluYW1pY0ZhY2V0U2xvdChhZGRyZXNzZXMsIGZhY2V0LCBwcm92aWRlcnMpIHtcbiAgICBsZXQgcHJvdmlkZXJBZGRycyA9IHByb3ZpZGVycy5tYXAocCA9PiBhZGRyZXNzZXNbcC5pZF0pO1xuICAgIGxldCBwcm92aWRlclR5cGVzID0gcHJvdmlkZXJzLm1hcChwID0+IHAudHlwZSk7XG4gICAgbGV0IGR5bmFtaWMgPSBwcm92aWRlckFkZHJzLmZpbHRlcihwID0+ICEocCAmIDEpKTtcbiAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW2ZhY2V0LmlkXSA+PiAxO1xuICAgIHJldHVybiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgIGxldCBvbGRWYWwgPSBzdGF0ZS52YWx1ZXNbaWR4XSwgY2hhbmdlZCA9IG9sZFZhbCA9PT0gVW5pbml0aWFsaXplZCB8fCAhdHI7XG4gICAgICAgIGZvciAobGV0IGR5bkFkZHIgb2YgZHluYW1pYykge1xuICAgICAgICAgICAgaWYgKGVuc3VyZUFkZHIoc3RhdGUsIGR5bkFkZHIpICYgMSAvKiBDaGFuZ2VkICovKVxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hhbmdlZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvdmlkZXJBZGRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZ2V0QWRkcihzdGF0ZSwgcHJvdmlkZXJBZGRyc1tpXSk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJUeXBlc1tpXSA9PSAyIC8qIE11bHRpICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHZhbCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZSh2YWx1ZXMpO1xuICAgICAgICBpZiAob2xkVmFsICE9PSBVbmluaXRpYWxpemVkICYmIGZhY2V0LmNvbXBhcmUodmFsdWUsIG9sZFZhbCkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICB9O1xufVxuY29uc3QgaW5pdEZpZWxkID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7IHN0YXRpYzogdHJ1ZSB9KTtcbi8qKlxuRmllbGRzIGNhbiBzdG9yZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGluIGFuIGVkaXRvciBzdGF0ZSwgYW5kXG5rZWVwIGl0IGluIHN5bmMgd2l0aCB0aGUgcmVzdCBvZiB0aGUgc3RhdGUuXG4qL1xuY2xhc3MgU3RhdGVGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpZCwgY3JlYXRlRiwgdXBkYXRlRiwgY29tcGFyZUYsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlRiA9IGNyZWF0ZUY7XG4gICAgICAgIHRoaXMudXBkYXRlRiA9IHVwZGF0ZUY7XG4gICAgICAgIHRoaXMuY29tcGFyZUYgPSBjb21wYXJlRjtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3ZpZGVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBzdGF0ZSBmaWVsZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoY29uZmlnKSB7XG4gICAgICAgIGxldCBmaWVsZCA9IG5ldyBTdGF0ZUZpZWxkKG5leHRJRCsrLCBjb25maWcuY3JlYXRlLCBjb25maWcudXBkYXRlLCBjb25maWcuY29tcGFyZSB8fCAoKGEsIGIpID0+IGEgPT09IGIpLCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3ZpZGUpXG4gICAgICAgICAgICBmaWVsZC5wcm92aWRlcyA9IGNvbmZpZy5wcm92aWRlKGZpZWxkKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBjcmVhdGUoc3RhdGUpIHtcbiAgICAgICAgbGV0IGluaXQgPSBzdGF0ZS5mYWNldChpbml0RmllbGQpLmZpbmQoaSA9PiBpLmZpZWxkID09IHRoaXMpO1xuICAgICAgICByZXR1cm4gKChpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuY3JlYXRlKSB8fCB0aGlzLmNyZWF0ZUYpKHN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbG90KGFkZHJlc3Nlcykge1xuICAgICAgICBsZXQgaWR4ID0gYWRkcmVzc2VzW3RoaXMuaWRdID4+IDE7XG4gICAgICAgIHJldHVybiAoc3RhdGUsIHRyKSA9PiB7XG4gICAgICAgICAgICBsZXQgb2xkVmFsID0gc3RhdGUudmFsdWVzW2lkeF07XG4gICAgICAgICAgICBpZiAob2xkVmFsID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB0aGlzLmNyZWF0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudXBkYXRlRihvbGRWYWwsIHRyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcGFyZUYob2xkVmFsLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUudmFsdWVzW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEgLyogQ2hhbmdlZCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcbiAgICB3YXkgaXQgaXMgaW5pdGlhbGl6ZWQuIENhbiBiZSB1c2VmdWwgd2hlbiB5b3UgbmVlZCB0byBwcm92aWRlIGFcbiAgICBub24tZGVmYXVsdCBzdGFydGluZyB2YWx1ZSBmb3IgdGhlIGZpZWxkLlxuICAgICovXG4gICAgaW5pdChjcmVhdGUpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLCBpbml0RmllbGQub2YoeyBmaWVsZDogdGhpcywgY3JlYXRlIH0pXTtcbiAgICB9XG4gICAgLyoqXG4gICAgU3RhdGUgZmllbGQgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFzXG4gICAgW2BFeHRlbnNpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkV4dGVuc2lvbikgdmFsdWVzIHRvIGVuYWJsZSB0aGUgZmllbGQgaW4gYVxuICAgIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGV4dGVuc2lvbigpIHsgcmV0dXJuIHRoaXM7IH1cbn1cbmNvbnN0IFByZWNfID0geyBsb3dlc3Q6IDQsIGxvdzogMywgZGVmYXVsdDogMiwgaGlnaDogMSwgaGlnaGVzdDogMCB9O1xuZnVuY3Rpb24gcHJlYyh2YWx1ZSkge1xuICAgIHJldHVybiAoZXh0KSA9PiBuZXcgUHJlY0V4dGVuc2lvbihleHQsIHZhbHVlKTtcbn1cbi8qKlxuQnkgZGVmYXVsdCBleHRlbnNpb25zIGFyZSByZWdpc3RlcmVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBmb3VuZFxuaW4gdGhlIGZsYXR0ZW5lZCBmb3JtIG9mIG5lc3RlZCBhcnJheSB0aGF0IHdhcyBwcm92aWRlZC5cbkluZGl2aWR1YWwgZXh0ZW5zaW9uIHZhbHVlcyBjYW4gYmUgYXNzaWduZWQgYSBwcmVjZWRlbmNlIHRvXG5vdmVycmlkZSB0aGlzLiBFeHRlbnNpb25zIHRoYXQgZG8gbm90IGhhdmUgYSBwcmVjZWRlbmNlIHNldCBnZXRcbnRoZSBwcmVjZWRlbmNlIG9mIHRoZSBuZWFyZXN0IHBhcmVudCB3aXRoIGEgcHJlY2VkZW5jZSwgb3JcbltgZGVmYXVsdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuUHJlYy5kZWZhdWx0KSBpZiB0aGVyZSBpcyBubyBzdWNoIHBhcmVudC4gVGhlXG5maW5hbCBvcmRlcmluZyBvZiBleHRlbnNpb25zIGlzIGRldGVybWluZWQgYnkgZmlyc3Qgc29ydGluZyBieVxucHJlY2VkZW5jZSBhbmQgdGhlbiBieSBvcmRlciB3aXRoaW4gZWFjaCBwcmVjZWRlbmNlLlxuKi9cbmNvbnN0IFByZWMgPSB7XG4gICAgLyoqXG4gICAgVGhlIGxvd2VzdCBwcmVjZWRlbmNlIGxldmVsLiBNZWFudCBmb3IgdGhpbmdzIHRoYXQgc2hvdWxkIGVuZCB1cFxuICAgIG5lYXIgdGhlIGVuZCBvZiB0aGUgZXh0ZW5zaW9uIG9yZGVyLlxuICAgICovXG4gICAgbG93ZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3dlc3QpLFxuICAgIC8qKlxuICAgIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UsIGZvciBleHRlbnNpb25zLlxuICAgICovXG4gICAgbG93OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5sb3cpLFxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICAgIHdpdGhvdXQgYW4gZXhwbGljaXQgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIGRlZmF1bHQ6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmRlZmF1bHQpLFxuICAgIC8qKlxuICAgIEEgaGlnaGVyLXRoYW4tZGVmYXVsdCBwcmVjZWRlbmNlLCBmb3IgZXh0ZW5zaW9ucyB0aGF0IHNob3VsZFxuICAgIGNvbWUgYmVmb3JlIHRob3NlIHdpdGggZGVmYXVsdCBwcmVjZWRlbmNlLlxuICAgICovXG4gICAgaGlnaDogLypAX19QVVJFX18qL3ByZWMoUHJlY18uaGlnaCksXG4gICAgLyoqXG4gICAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXG4gICAgbmVhciB0aGUgc3RhcnQgb2YgdGhlIHByZWNlZGVuY2Ugb3JkZXJpbmcuXG4gICAgKi9cbiAgICBoaWdoZXN0OiAvKkBfX1BVUkVfXyovcHJlYyhQcmVjXy5oaWdoZXN0KSxcbiAgICAvLyBGSVhNRSBEcm9wIHRoZXNlIGluIHNvbWUgZnV0dXJlIGJyZWFraW5nIHZlcnNpb25cbiAgICAvKipcbiAgICBCYWNrd2FyZHMtY29tcGF0aWJsZSBzeW5vbnltIGZvciBgUHJlYy5sb3dlc3RgLlxuICAgICovXG4gICAgZmFsbGJhY2s6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmxvd2VzdCksXG4gICAgLyoqXG4gICAgQmFja3dhcmRzLWNvbXBhdGlibGUgc3lub255bSBmb3IgYFByZWMuaGlnaGAuXG4gICAgKi9cbiAgICBleHRlbmQ6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2gpLFxuICAgIC8qKlxuICAgIEJhY2t3YXJkcy1jb21wYXRpYmxlIHN5bm9ueW0gZm9yIGBQcmVjLmhpZ2hlc3RgLlxuICAgICovXG4gICAgb3ZlcnJpZGU6IC8qQF9fUFVSRV9fKi9wcmVjKFByZWNfLmhpZ2hlc3QpXG59O1xuY2xhc3MgUHJlY0V4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIsIHByZWMpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLnByZWMgPSBwcmVjO1xuICAgIH1cbn1cbi8qKlxuRXh0ZW5zaW9uIGNvbXBhcnRtZW50cyBjYW4gYmUgdXNlZCB0byBtYWtlIGEgY29uZmlndXJhdGlvblxuZHluYW1pYy4gQnkgW3dyYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNvbXBhcnRtZW50Lm9mKSBwYXJ0IG9mIHlvdXJcbmNvbmZpZ3VyYXRpb24gaW4gYSBjb21wYXJ0bWVudCwgeW91IGNhbiBsYXRlclxuW3JlcGxhY2VdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpIHRoYXQgcGFydCB0aHJvdWdoIGFcbnRyYW5zYWN0aW9uLlxuKi9cbmNsYXNzIENvbXBhcnRtZW50IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjb21wYXJ0bWVudCB0byBhZGQgdG8geW91ciBbc3RhdGVcbiAgICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAgICovXG4gICAgb2YoZXh0KSB7IHJldHVybiBuZXcgQ29tcGFydG1lbnRJbnN0YW5jZSh0aGlzLCBleHQpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgICByZWNvbmZpZ3VyZXMgdGhpcyBjb21wYXJ0bWVudC5cbiAgICAqL1xuICAgIHJlY29uZmlndXJlKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIENvbXBhcnRtZW50LnJlY29uZmlndXJlLm9mKHsgY29tcGFydG1lbnQ6IHRoaXMsIGV4dGVuc2lvbjogY29udGVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjdXJyZW50IGNvbnRlbnQgb2YgdGhlIGNvbXBhcnRtZW50IGluIHRoZSBzdGF0ZSwgb3JcbiAgICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25maWcuY29tcGFydG1lbnRzLmdldCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBDb21wYXJ0bWVudEluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJ0bWVudCwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJ0bWVudCA9IGNvbXBhcnRtZW50O1xuICAgICAgICB0aGlzLmlubmVyID0gaW5uZXI7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlndXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgY29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMsIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcykge1xuICAgICAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgICAgICB0aGlzLmNvbXBhcnRtZW50cyA9IGNvbXBhcnRtZW50cztcbiAgICAgICAgdGhpcy5keW5hbWljU2xvdHMgPSBkeW5hbWljU2xvdHM7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuc3RhdGljVmFsdWVzID0gc3RhdGljVmFsdWVzO1xuICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXR1c1RlbXBsYXRlLmxlbmd0aCA8IGR5bmFtaWNTbG90cy5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RlbXBsYXRlLnB1c2goMCAvKiBVbnJlc29sdmVkICovKTtcbiAgICB9XG4gICAgc3RhdGljRmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmFkZHJlc3NbZmFjZXQuaWRdO1xuICAgICAgICByZXR1cm4gYWRkciA9PSBudWxsID8gZmFjZXQuZGVmYXVsdCA6IHRoaXMuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV07XG4gICAgfVxuICAgIHN0YXRpYyByZXNvbHZlKGJhc2UsIGNvbXBhcnRtZW50cywgb2xkU3RhdGUpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgZmFjZXRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IG5ld0NvbXBhcnRtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgZXh0IG9mIGZsYXR0ZW4oYmFzZSwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZXh0IGluc3RhbmNlb2YgU3RhdGVGaWVsZClcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChleHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIChmYWNldHNbZXh0LmZhY2V0LmlkXSB8fCAoZmFjZXRzW2V4dC5mYWNldC5pZF0gPSBbXSkpLnB1c2goZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWRkcmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBzdGF0aWNWYWx1ZXMgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWNTbG90cyA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pY0RlcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBhZGRyZXNzW2ZpZWxkLmlkXSA9IGR5bmFtaWNTbG90cy5sZW5ndGggPDwgMTtcbiAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZmllbGQuc2xvdChhKSk7XG4gICAgICAgICAgICBkeW5hbWljRGVwcy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpZCBpbiBmYWNldHMpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcnMgPSBmYWNldHNbaWRdLCBmYWNldCA9IHByb3ZpZGVyc1swXS5mYWNldDtcbiAgICAgICAgICAgIGlmIChwcm92aWRlcnMuZXZlcnkocCA9PiBwLnR5cGUgPT0gMCAvKiBTdGF0aWMgKi8pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc1tmYWNldC5pZF0gPSAoc3RhdGljVmFsdWVzLmxlbmd0aCA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZmFjZXQuY29tYmluZShwcm92aWRlcnMubWFwKHAgPT4gcC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRBZGRyID0gb2xkU3RhdGUgPyBvbGRTdGF0ZS5jb25maWcuYWRkcmVzc1tmYWNldC5pZF0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChvbGRBZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9sZFZhbCA9IGdldEFkZHIob2xkU3RhdGUsIG9sZEFkZHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFjZXQuY29tcGFyZSh2YWx1ZSwgb2xkVmFsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0aWNWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwIG9mIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocC50eXBlID09IDAgLyogU3RhdGljICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gKHN0YXRpY1ZhbHVlcy5sZW5ndGggPDwgMSkgfCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljVmFsdWVzLnB1c2gocC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzW3AuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Nsb3RzLnB1c2goYSA9PiBwLmR5bmFtaWNTbG90KGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNEZXBzLnB1c2gocC5kZXBlbmRlbmNpZXMuZmlsdGVyKGQgPT4gdHlwZW9mIGQgIT0gXCJzdHJpbmdcIikubWFwKGQgPT4gZC5pZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZHJlc3NbZmFjZXQuaWRdID0gZHluYW1pY1Nsb3RzLmxlbmd0aCA8PCAxO1xuICAgICAgICAgICAgICAgIGR5bmFtaWNTbG90cy5wdXNoKGEgPT4gZHluYW1pY0ZhY2V0U2xvdChhLCBmYWNldCwgcHJvdmlkZXJzKSk7XG4gICAgICAgICAgICAgICAgZHluYW1pY0RlcHMucHVzaChwcm92aWRlcnMuZmlsdGVyKHAgPT4gcC50eXBlICE9IDAgLyogU3RhdGljICovKS5tYXAoZCA9PiBkLmlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR5bmFtaWNWYWx1ZXMgPSBkeW5hbWljU2xvdHMubWFwKF8gPT4gVW5pbml0aWFsaXplZCk7XG4gICAgICAgIGlmIChvbGRTdGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNhblJldXNlID0gKGlkLCBkZXB0aCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IDcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkciA9IGFkZHJlc3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghKGFkZHIgJiAxKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNEZXBzW2FkZHIgPj4gMV0uZXZlcnkoaWQgPT4gY2FuUmV1c2UoaWQsIGRlcHRoICsgMSkpO1xuICAgICAgICAgICAgICAgIGxldCBvbGRBZGRyID0gb2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbaWRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBvbGRBZGRyICE9IG51bGwgJiYgZ2V0QWRkcihvbGRTdGF0ZSwgb2xkQWRkcikgPT0gc3RhdGljVmFsdWVzW2FkZHIgPj4gMV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ29weSBvdmVyIG9sZCB2YWx1ZXMgZm9yIHNoYXJlZCBmYWNldHMvZmllbGRzLCBpZiB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHByb3ZlIHRoYXQgdGhleSBkb24ndCBuZWVkIHRvIGJlIHJlY29tcHV0ZWQuXG4gICAgICAgICAgICBmb3IgKGxldCBpZCBpbiBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IGFkZHJlc3NbaWRdLCBwcmV2ID0gb2xkU3RhdGUuY29uZmlnLmFkZHJlc3NbaWRdO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgKGN1ciAmIDEpID09IDAgJiYgY2FuUmV1c2UoK2lkLCAwKSlcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1ZhbHVlc1tjdXIgPj4gMV0gPSBnZXRBZGRyKG9sZFN0YXRlLCBwcmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbjogbmV3IENvbmZpZ3VyYXRpb24oYmFzZSwgbmV3Q29tcGFydG1lbnRzLCBkeW5hbWljU2xvdHMubWFwKGYgPT4gZihhZGRyZXNzKSksIGFkZHJlc3MsIHN0YXRpY1ZhbHVlcyksXG4gICAgICAgICAgICB2YWx1ZXM6IGR5bmFtaWNWYWx1ZXNcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuKGV4dGVuc2lvbiwgY29tcGFydG1lbnRzLCBuZXdDb21wYXJ0bWVudHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW1tdLCBbXSwgW10sIFtdLCBbXV07XG4gICAgbGV0IHNlZW4gPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gaW5uZXIoZXh0LCBwcmVjKSB7XG4gICAgICAgIGxldCBrbm93biA9IHNlZW4uZ2V0KGV4dCk7XG4gICAgICAgIGlmIChrbm93biAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa25vd24gPj0gcHJlYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgZm91bmQgPSByZXN1bHRba25vd25dLmluZGV4T2YoZXh0KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+IC0xKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrbm93bl0uc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKVxuICAgICAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5kZWxldGUoZXh0LmNvbXBhcnRtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLnNldChleHQsIHByZWMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleHQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIGV4dClcbiAgICAgICAgICAgICAgICBpbm5lcihlLCBwcmVjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHQgaW5zdGFuY2VvZiBDb21wYXJ0bWVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAobmV3Q29tcGFydG1lbnRzLmhhcyhleHQuY29tcGFydG1lbnQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBEdXBsaWNhdGUgdXNlIG9mIGNvbXBhcnRtZW50IGluIGV4dGVuc2lvbnNgKTtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gY29tcGFydG1lbnRzLmdldChleHQuY29tcGFydG1lbnQpIHx8IGV4dC5pbm5lcjtcbiAgICAgICAgICAgIG5ld0NvbXBhcnRtZW50cy5zZXQoZXh0LmNvbXBhcnRtZW50LCBjb250ZW50KTtcbiAgICAgICAgICAgIGlubmVyKGNvbnRlbnQsIHByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFByZWNFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIGlubmVyKGV4dC5pbm5lciwgZXh0LnByZWMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4dCBpbnN0YW5jZW9mIFN0YXRlRmllbGQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtwcmVjXS5wdXNoKGV4dCk7XG4gICAgICAgICAgICBpZiAoZXh0LnByb3ZpZGVzKVxuICAgICAgICAgICAgICAgIGlubmVyKGV4dC5wcm92aWRlcywgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXh0IGluc3RhbmNlb2YgRmFjZXRQcm92aWRlcikge1xuICAgICAgICAgICAgcmVzdWx0W3ByZWNdLnB1c2goZXh0KTtcbiAgICAgICAgICAgIGlmIChleHQuZmFjZXQuZXh0ZW5zaW9ucylcbiAgICAgICAgICAgICAgICBpbm5lcihleHQuZmFjZXQuZXh0ZW5zaW9ucywgcHJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IGV4dC5leHRlbnNpb247XG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZXh0ZW5zaW9uIHZhbHVlIGluIGV4dGVuc2lvbiBzZXQgKCR7ZXh0fSkuIFRoaXMgc29tZXRpbWVzIGhhcHBlbnMgYmVjYXVzZSBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgQGNvZGVtaXJyb3Ivc3RhdGUgYXJlIGxvYWRlZCwgYnJlYWtpbmcgaW5zdGFuY2VvZiBjaGVja3MuYCk7XG4gICAgICAgICAgICBpbm5lcihjb250ZW50LCBwcmVjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbm5lcihleHRlbnNpb24sIFByZWNfLmRlZmF1bHQpO1xuICAgIHJldHVybiByZXN1bHQucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSk7XG59XG5jb25zdCBVbmluaXRpYWxpemVkID0ge307XG5mdW5jdGlvbiBlbnN1cmVBZGRyKHN0YXRlLCBhZGRyKSB7XG4gICAgaWYgKGFkZHIgJiAxKVxuICAgICAgICByZXR1cm4gMiAvKiBDb21wdXRlZCAqLztcbiAgICBsZXQgaWR4ID0gYWRkciA+PiAxO1xuICAgIGxldCBzdGF0dXMgPSBzdGF0ZS5zdGF0dXNbaWR4XTtcbiAgICBpZiAoc3RhdHVzID09IDQgLyogQ29tcHV0aW5nICovKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICAgIGlmIChzdGF0dXMgJiAyIC8qIENvbXB1dGVkICovKVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIHN0YXRlLnN0YXR1c1tpZHhdID0gNCAvKiBDb21wdXRpbmcgKi87XG4gICAgbGV0IGNoYW5nZWQgPSBzdGF0ZS5jb25maWcuZHluYW1pY1Nsb3RzW2lkeF0oc3RhdGUsIHN0YXRlLmFwcGx5aW5nKTtcbiAgICByZXR1cm4gc3RhdGUuc3RhdHVzW2lkeF0gPSAyIC8qIENvbXB1dGVkICovIHwgY2hhbmdlZDtcbn1cbmZ1bmN0aW9uIGdldEFkZHIoc3RhdGUsIGFkZHIpIHtcbiAgICByZXR1cm4gYWRkciAmIDEgPyBzdGF0ZS5jb25maWcuc3RhdGljVmFsdWVzW2FkZHIgPj4gMV0gOiBzdGF0ZS52YWx1ZXNbYWRkciA+PiAxXTtcbn1cblxuY29uc3QgbGFuZ3VhZ2VEYXRhID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4gdmFsdWVzLnNvbWUodiA9PiB2KSxcbiAgICBzdGF0aWM6IHRydWVcbn0pO1xuY29uc3QgbGluZVNlcGFyYXRvciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogdW5kZWZpbmVkLFxuICAgIHN0YXRpYzogdHJ1ZVxufSk7XG5jb25zdCBjaGFuZ2VGaWx0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCB0cmFuc2FjdGlvbkZpbHRlciA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHRyYW5zYWN0aW9uRXh0ZW5kZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCByZWFkT25seSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmU6IHZhbHVlcyA9PiB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzWzBdIDogZmFsc2Vcbn0pO1xuXG4vKipcbkFubm90YXRpb25zIGFyZSB0YWdnZWQgdmFsdWVzIHRoYXQgYXJlIHVzZWQgdG8gYWRkIG1ldGFkYXRhIHRvXG50cmFuc2FjdGlvbnMgaW4gYW4gZXh0ZW5zaWJsZSB3YXkuIFRoZXkgc2hvdWxkIGJlIHVzZWQgdG8gbW9kZWxcbnRoaW5ncyB0aGF0IGVmZmVjdCB0aGUgZW50aXJlIHRyYW5zYWN0aW9uIChzdWNoIGFzIGl0cyBbdGltZVxuc3RhbXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25edGltZSkgb3IgaW5mb3JtYXRpb24gYWJvdXQgaXRzXG5bb3JpZ2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkpLiBGb3IgZWZmZWN0cyB0aGF0IGhhcHBlblxuX2Fsb25nc2lkZV8gdGhlIG90aGVyIGNoYW5nZXMgbWFkZSBieSB0aGUgdHJhbnNhY3Rpb24sIFtzdGF0ZVxuZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdCkgYXJlIG1vcmUgYXBwcm9wcmlhdGUuXG4qL1xuY2xhc3MgQW5ub3RhdGlvbiB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYW5ub3RhdGlvbiB0eXBlLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIHZhbHVlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IHR5cGUgb2YgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvblR5cGUoKTsgfVxufVxuLyoqXG5NYXJrZXIgdGhhdCBpZGVudGlmaWVzIGEgdHlwZSBvZiBbYW5ub3RhdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Bbm5vdGF0aW9uKS5cbiovXG5jbGFzcyBBbm5vdGF0aW9uVHlwZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgYW5ub3RhdGlvbi5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgQW5ub3RhdGlvbih0aGlzLCB2YWx1ZSk7IH1cbn1cbi8qKlxuUmVwcmVzZW50YXRpb24gb2YgYSB0eXBlIG9mIHN0YXRlIGVmZmVjdC4gRGVmaW5lZCB3aXRoXG5bYFN0YXRlRWZmZWN0LmRlZmluZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3ReZGVmaW5lKS5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdFR5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIGBhbnlgIHR5cGVzIGluIHRoZXNlIGZ1bmN0aW9uIHR5cGVzIGFyZSB0aGVyZSB0byB3b3JrXG4gICAgLy8gYXJvdW5kIFR5cGVTY3JpcHQgaXNzdWUgIzM3NjMxLCB3aGVyZSB0aGUgdHlwZSBndWFyZCBvblxuICAgIC8vIGBTdGF0ZUVmZmVjdC5pc2AgbXlzdGVyaW91c2x5IHN0b3BzIHdvcmtpbmcgd2hlbiB0aGVzZSBwcm9wZXJseVxuICAgIC8vIGhhdmUgdHlwZSBgVmFsdWVgLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbc3RhdGUgZWZmZWN0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0KSBpbnN0YW5jZSBvZiB0aGlzXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIG9mKHZhbHVlKSB7IHJldHVybiBuZXcgU3RhdGVFZmZlY3QodGhpcywgdmFsdWUpOyB9XG59XG4vKipcblN0YXRlIGVmZmVjdHMgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGFkZGl0aW9uYWwgZWZmZWN0c1xuYXNzb2NpYXRlZCB3aXRoIGEgW3RyYW5zYWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLmVmZmVjdHMpLiBUaGV5XG5hcmUgb2Z0ZW4gdXNlZnVsIHRvIG1vZGVsIGNoYW5nZXMgdG8gY3VzdG9tIFtzdGF0ZVxuZmllbGRzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQpLCB3aGVuIHRob3NlIGNoYW5nZXMgYXJlbid0IGltcGxpY2l0IGluXG5kb2N1bWVudCBvciBzZWxlY3Rpb24gY2hhbmdlcy5cbiovXG5jbGFzcyBTdGF0ZUVmZmVjdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSB2YWx1ZSBvZiB0aGlzIGVmZmVjdC5cbiAgICAqL1xuICAgIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIHRoaXMgZWZmZWN0IHRocm91Z2ggYSBwb3NpdGlvbiBtYXBwaW5nLiBXaWxsIHJldHVyblxuICAgIGB1bmRlZmluZWRgIHdoZW4gdGhhdCBlbmRzIHVwIGRlbGV0aW5nIHRoZSBlZmZlY3QuXG4gICAgKi9cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy50eXBlLm1hcCh0aGlzLnZhbHVlLCBtYXBwaW5nKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbWFwcGVkID09IHRoaXMudmFsdWUgPyB0aGlzIDogbmV3IFN0YXRlRWZmZWN0KHRoaXMudHlwZSwgbWFwcGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBlZmZlY3Qgb2JqZWN0IGlzIG9mIGEgZ2l2ZW5cbiAgICBbdHlwZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdFR5cGUpLlxuICAgICovXG4gICAgaXModHlwZSkgeyByZXR1cm4gdGhpcy50eXBlID09IHR5cGU7IH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgZWZmZWN0IHR5cGUuIFRoZSB0eXBlIHBhcmFtZXRlciBpbmRpY2F0ZXMgdGhlIHR5cGVcbiAgICBvZiB2YWx1ZXMgdGhhdCBoaXMgZWZmZWN0IGhvbGRzLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZShzcGVjID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGF0ZUVmZmVjdFR5cGUoc3BlYy5tYXAgfHwgKHYgPT4gdikpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYW4gYXJyYXkgb2YgZWZmZWN0cyB0aHJvdWdoIGEgY2hhbmdlIHNldC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXBFZmZlY3RzKGVmZmVjdHMsIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKCFlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiBlZmZlY3RzKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gZWZmZWN0Lm1hcChtYXBwaW5nKTtcbiAgICAgICAgICAgIGlmIChtYXBwZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWFwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuVGhpcyBlZmZlY3QgY2FuIGJlIHVzZWQgdG8gcmVjb25maWd1cmUgdGhlIHJvb3QgZXh0ZW5zaW9ucyBvZlxudGhlIGVkaXRvci4gRG9pbmcgdGhpcyB3aWxsIGRpc2NhcmQgYW55IGV4dGVuc2lvbnNcblthcHBlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5hcHBlbmRDb25maWcpLCBidXQgZG9lcyBub3QgcmVzZXRcbnRoZSBjb250ZW50IG9mIFtyZWNvbmZpZ3VyZWRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQucmVjb25maWd1cmUpXG5jb21wYXJ0bWVudHMuXG4qL1xuU3RhdGVFZmZlY3QucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vKipcbkFwcGVuZCBleHRlbnNpb25zIHRvIHRoZSB0b3AtbGV2ZWwgY29uZmlndXJhdGlvbiBvZiB0aGUgZWRpdG9yLlxuKi9cblN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbi8qKlxuQ2hhbmdlcyB0byB0aGUgZWRpdG9yIHN0YXRlIGFyZSBncm91cGVkIGludG8gdHJhbnNhY3Rpb25zLlxuVHlwaWNhbGx5LCBhIHVzZXIgYWN0aW9uIGNyZWF0ZXMgYSBzaW5nbGUgdHJhbnNhY3Rpb24sIHdoaWNoIG1heVxuY29udGFpbiBhbnkgbnVtYmVyIG9mIGRvY3VtZW50IGNoYW5nZXMsIG1heSBjaGFuZ2UgdGhlIHNlbGVjdGlvbixcbm9yIGhhdmUgb3RoZXIgZWZmZWN0cy4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gYnkgY2FsbGluZ1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkuXG4qL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXRlIGZyb20gd2hpY2ggdGhlIHRyYW5zYWN0aW9uIHN0YXJ0cy5cbiAgICAqL1xuICAgIHN0YXJ0U3RhdGUsIFxuICAgIC8qKlxuICAgIFRoZSBkb2N1bWVudCBjaGFuZ2VzIG1hZGUgYnkgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGNoYW5nZXMsIFxuICAgIC8qKlxuICAgIFRoZSBzZWxlY3Rpb24gc2V0IGJ5IHRoaXMgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiBpdFxuICAgIGRvZXNuJ3QgZXhwbGljaXRseSBzZXQgYSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBzZWxlY3Rpb24sIFxuICAgIC8qKlxuICAgIFRoZSBlZmZlY3RzIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGVmZmVjdHMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYW5ub3RhdGlvbnMsIFxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyIHRoaXNcbiAgICB0cmFuc2FjdGlvbiBpcyBkaXNwYXRjaGVkLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX2RvYyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgY2hlY2tTZWxlY3Rpb24oc2VsZWN0aW9uLCBjaGFuZ2VzLm5ld0xlbmd0aCk7XG4gICAgICAgIGlmICghYW5ub3RhdGlvbnMuc29tZSgoYSkgPT4gYS50eXBlID09IFRyYW5zYWN0aW9uLnRpbWUpKVxuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi50aW1lLm9mKERhdGUubm93KCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gICAgW2Auc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKWAuZG9jYCwgYWNjZXNzaW5nIHRoaXMgd29uJ3RcbiAgICBmb3JjZSB0aGUgZW50aXJlIG5ldyBzdGF0ZSB0byBiZSBjb21wdXRlZCByaWdodCBhd2F5LCBzbyBpdCBpc1xuICAgIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gICAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgdXNlIHRoaXMgZ2V0dGVyXG4gICAgd2hlbiB0aGV5IG5lZWQgdG8gbG9vayBhdCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IG5ld0RvYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICAgIFtgdGhpcy5zZWxlY3Rpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNlbGVjdGlvbikgaXMgdW5kZWZpbmVkLFxuICAgIHRoaXMgd2lsbCBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclNlbGVjdGlvbi5tYXApIHRoZSBzdGFydCBzdGF0ZSdzXG4gICAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgICAqL1xuICAgIGdldCBuZXdTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbiB8fCB0aGlzLnN0YXJ0U3RhdGUuc2VsZWN0aW9uLm1hcCh0aGlzLmNoYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbmV3IHN0YXRlIGNyZWF0ZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBDb21wdXRlZCBvbiBkZW1hbmRcbiAgICAoYnV0IHJldGFpbmVkIGZvciBzdWJzZXF1ZW50IGFjY2VzcyksIHNvIGl0aXMgcmVjb21tZW5kZWQgbm90IHRvXG4gICAgYWNjZXNzIGl0IGluIFt0cmFuc2FjdGlvblxuICAgIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHdoZW4gcG9zc2libGUuXG4gICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3RhdGUpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhbm5vdGF0aW9uIHR5cGUsIGlmIGFueS5cbiAgICAqL1xuICAgIGFubm90YXRpb24odHlwZSkge1xuICAgICAgICBmb3IgKGxldCBhbm4gb2YgdGhpcy5hbm5vdGF0aW9ucylcbiAgICAgICAgICAgIGlmIChhbm4udHlwZSA9PSB0eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBhbm4udmFsdWU7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBjaGFuZ2VkIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2NDaGFuZ2VkKCkgeyByZXR1cm4gIXRoaXMuY2hhbmdlcy5lbXB0eTsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgdHJhbnNhY3Rpb24gcmVjb25maWd1cmVzIHRoZSBzdGF0ZVxuICAgICh0aHJvdWdoIGEgW2NvbmZpZ3VyYXRpb24gY29tcGFydG1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ29tcGFydG1lbnQpIG9yXG4gICAgd2l0aCBhIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uXG4gICAgW2VmZmVjdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdF5yZWNvbmZpZ3VyZSkuXG4gICAgKi9cbiAgICBnZXQgcmVjb25maWd1cmVkKCkgeyByZXR1cm4gdGhpcy5zdGFydFN0YXRlLmNvbmZpZyAhPSB0aGlzLnN0YXRlLmNvbmZpZzsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgW3VzZXJcbiAgICBldmVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbl51c2VyRXZlbnQpIGFubm90YXRpb24gdGhhdCBpcyBlcXVhbCB0b1xuICAgIG9yIG1vcmUgc3BlY2lmaWMgdGhhbiBgZXZlbnRgLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRyYW5zYWN0aW9uXG4gICAgaGFzIGBcInNlbGVjdC5wb2ludGVyXCJgIGFzIHVzZXIgZXZlbnQsIGBcInNlbGVjdFwiYCBhbmRcbiAgICBgXCJzZWxlY3QucG9pbnRlclwiYCB3aWxsIG1hdGNoIGl0LlxuICAgICovXG4gICAgaXNVc2VyRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLmFubm90YXRpb24oVHJhbnNhY3Rpb24udXNlckV2ZW50KTtcbiAgICAgICAgcmV0dXJuICEhKGUgJiYgKGUgPT0gZXZlbnQgfHwgZS5sZW5ndGggPiBldmVudC5sZW5ndGggJiYgZS5zbGljZSgwLCBldmVudC5sZW5ndGgpID09IGV2ZW50ICYmIGVbZXZlbnQubGVuZ3RoXSA9PSBcIi5cIikpO1xuICAgIH1cbn1cbi8qKlxuQW5ub3RhdGlvbiB1c2VkIHRvIHN0b3JlIHRyYW5zYWN0aW9uIHRpbWVzdGFtcHMuXG4qL1xuVHJhbnNhY3Rpb24udGltZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHJhbnNhY3Rpb24gd2l0aCBhIHVzZXIgaW50ZXJmYWNlXG5ldmVudC4gSG9sZHMgYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGV2ZW50LCB1c2luZyBhXG5kb3Qtc2VwYXJhdGVkIGZvcm1hdCB0byBzdXBwb3J0IGF0dGFjaGluZyBtb3JlIHNwZWNpZmljXG5pbmZvcm1hdGlvbi4gVGhlIGV2ZW50cyB1c2VkIGJ5IHRoZSBjb3JlIGxpYnJhcmllcyBhcmU6XG5cbiAtIGBcImlucHV0XCJgIHdoZW4gY29udGVudCBpcyBlbnRlcmVkXG4gICAtIGBcImlucHV0LnR5cGVcImAgZm9yIHR5cGVkIGlucHV0XG4gICAgIC0gYFwiaW5wdXQudHlwZS5jb21wb3NlXCJgIGZvciBjb21wb3NpdGlvblxuICAgLSBgXCJpbnB1dC5wYXN0ZVwiYCBmb3IgcGFzdGVkIGlucHV0XG4gICAtIGBcImlucHV0LmRyb3BcImAgd2hlbiBhZGRpbmcgY29udGVudCB3aXRoIGRyYWctYW5kLWRyb3BcbiAgIC0gYFwiaW5wdXQuY29tcGxldGVcImAgd2hlbiBhdXRvY29tcGxldGluZ1xuIC0gYFwiZGVsZXRlXCJgIHdoZW4gdGhlIHVzZXIgZGVsZXRlcyBjb250ZW50XG4gICAtIGBcImRlbGV0ZS5zZWxlY3Rpb25cImAgd2hlbiBkZWxldGluZyB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5mb3J3YXJkXCJgIHdoZW4gZGVsZXRpbmcgZm9yd2FyZCBmcm9tIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwiZGVsZXRlLmJhY2t3YXJkXCJgIHdoZW4gZGVsZXRpbmcgYmFja3dhcmQgZnJvbSB0aGUgc2VsZWN0aW9uXG4gICAtIGBcImRlbGV0ZS5jdXRcImAgd2hlbiBjdXR0aW5nIHRvIHRoZSBjbGlwYm9hcmRcbiAtIGBcIm1vdmVcImAgd2hlbiBjb250ZW50IGlzIG1vdmVkXG4gICAtIGBcIm1vdmUuZHJvcFwiYCB3aGVuIGNvbnRlbnQgaXMgbW92ZWQgd2l0aGluIHRoZSBlZGl0b3IgdGhyb3VnaCBkcmFnLWFuZC1kcm9wXG4gLSBgXCJzZWxlY3RcImAgd2hlbiBleHBsaWNpdGx5IGNoYW5naW5nIHRoZSBzZWxlY3Rpb25cbiAgIC0gYFwic2VsZWN0LnBvaW50ZXJcImAgd2hlbiBzZWxlY3Rpbmcgd2l0aCBhIG1vdXNlIG9yIG90aGVyIHBvaW50aW5nIGRldmljZVxuIC0gYFwidW5kb1wiYCBhbmQgYFwicmVkb1wiYCBmb3IgaGlzdG9yeSBhY3Rpb25zXG5cblVzZSBbYGlzVXNlckV2ZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5pc1VzZXJFdmVudCkgdG8gY2hlY2tcbndoZXRoZXIgdGhlIGFubm90YXRpb24gbWF0Y2hlcyBhIGdpdmVuIGV2ZW50LlxuKi9cblRyYW5zYWN0aW9uLnVzZXJFdmVudCA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuLyoqXG5Bbm5vdGF0aW9uIGluZGljYXRpbmcgd2hldGhlciBhIHRyYW5zYWN0aW9uIHNob3VsZCBiZSBhZGRlZCB0b1xudGhlIHVuZG8gaGlzdG9yeSBvciBub3QuXG4qL1xuVHJhbnNhY3Rpb24uYWRkVG9IaXN0b3J5ID0gLypAX19QVVJFX18qL0Fubm90YXRpb24uZGVmaW5lKCk7XG4vKipcbkFubm90YXRpb24gaW5kaWNhdGluZyAod2hlbiBwcmVzZW50IGFuZCB0cnVlKSB0aGF0IGEgdHJhbnNhY3Rpb25cbnJlcHJlc2VudHMgYSBjaGFuZ2UgbWFkZSBieSBzb21lIG90aGVyIGFjdG9yLCBub3QgdGhlIHVzZXIuIFRoaXNcbmlzIHVzZWQsIGZvciBleGFtcGxlLCB0byB0YWcgb3RoZXIgcGVvcGxlJ3MgY2hhbmdlcyBpblxuY29sbGFib3JhdGl2ZSBlZGl0aW5nLlxuKi9cblRyYW5zYWN0aW9uLnJlbW90ZSA9IC8qQF9fUFVSRV9fKi9Bbm5vdGF0aW9uLmRlZmluZSgpO1xuZnVuY3Rpb24gam9pblJhbmdlcyhhLCBiKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGlBID0gMCwgaUIgPSAwOzspIHtcbiAgICAgICAgbGV0IGZyb20sIHRvO1xuICAgICAgICBpZiAoaUEgPCBhLmxlbmd0aCAmJiAoaUIgPT0gYi5sZW5ndGggfHwgYltpQl0gPj0gYVtpQV0pKSB7XG4gICAgICAgICAgICBmcm9tID0gYVtpQSsrXTtcbiAgICAgICAgICAgIHRvID0gYVtpQSsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpQiA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBmcm9tID0gYltpQisrXTtcbiAgICAgICAgICAgIHRvID0gYltpQisrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGggfHwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA8IGZyb20pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPCB0bylcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSB0bztcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zYWN0aW9uKGEsIGIsIHNlcXVlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IG1hcEZvckEsIG1hcEZvckIsIGNoYW5nZXM7XG4gICAgaWYgKHNlcXVlbnRpYWwpIHtcbiAgICAgICAgbWFwRm9yQSA9IGIuY2hhbmdlcztcbiAgICAgICAgbWFwRm9yQiA9IENoYW5nZVNldC5lbXB0eShiLmNoYW5nZXMubGVuZ3RoKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKGIuY2hhbmdlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXBGb3JBID0gYi5jaGFuZ2VzLm1hcChhLmNoYW5nZXMpO1xuICAgICAgICBtYXBGb3JCID0gYS5jaGFuZ2VzLm1hcERlc2MoYi5jaGFuZ2VzLCB0cnVlKTtcbiAgICAgICAgY2hhbmdlcyA9IGEuY2hhbmdlcy5jb21wb3NlKG1hcEZvckEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IGIuc2VsZWN0aW9uID8gYi5zZWxlY3Rpb24ubWFwKG1hcEZvckIpIDogKF9hID0gYS5zZWxlY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAobWFwRm9yQSksXG4gICAgICAgIGVmZmVjdHM6IFN0YXRlRWZmZWN0Lm1hcEVmZmVjdHMoYS5lZmZlY3RzLCBtYXBGb3JBKS5jb25jYXQoU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhiLmVmZmVjdHMsIG1hcEZvckIpKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IGEuYW5ub3RhdGlvbnMubGVuZ3RoID8gYS5hbm5vdGF0aW9ucy5jb25jYXQoYi5hbm5vdGF0aW9ucykgOiBiLmFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogYS5zY3JvbGxJbnRvVmlldyB8fCBiLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbklubmVyKHN0YXRlLCBzcGVjLCBkb2NTaXplKSB7XG4gICAgbGV0IHNlbCA9IHNwZWMuc2VsZWN0aW9uLCBhbm5vdGF0aW9ucyA9IGFzQXJyYXkoc3BlYy5hbm5vdGF0aW9ucyk7XG4gICAgaWYgKHNwZWMudXNlckV2ZW50KVxuICAgICAgICBhbm5vdGF0aW9ucyA9IGFubm90YXRpb25zLmNvbmNhdChUcmFuc2FjdGlvbi51c2VyRXZlbnQub2Yoc3BlYy51c2VyRXZlbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiBzcGVjLmNoYW5nZXMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQgPyBzcGVjLmNoYW5nZXNcbiAgICAgICAgICAgIDogQ2hhbmdlU2V0Lm9mKHNwZWMuY2hhbmdlcyB8fCBbXSwgZG9jU2l6ZSwgc3RhdGUuZmFjZXQobGluZVNlcGFyYXRvcikpLFxuICAgICAgICBzZWxlY3Rpb246IHNlbCAmJiAoc2VsIGluc3RhbmNlb2YgRWRpdG9yU2VsZWN0aW9uID8gc2VsIDogRWRpdG9yU2VsZWN0aW9uLnNpbmdsZShzZWwuYW5jaG9yLCBzZWwuaGVhZCkpLFxuICAgICAgICBlZmZlY3RzOiBhc0FycmF5KHNwZWMuZWZmZWN0cyksXG4gICAgICAgIGFubm90YXRpb25zLFxuICAgICAgICBzY3JvbGxJbnRvVmlldzogISFzcGVjLnNjcm9sbEludG9WaWV3XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2FjdGlvbihzdGF0ZSwgc3BlY3MsIGZpbHRlcikge1xuICAgIGxldCBzID0gcmVzb2x2ZVRyYW5zYWN0aW9uSW5uZXIoc3RhdGUsIHNwZWNzLmxlbmd0aCA/IHNwZWNzWzBdIDoge30sIHN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGlmIChzcGVjcy5sZW5ndGggJiYgc3BlY3NbMF0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgZmlsdGVyID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGVjcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3BlY3NbaV0uZmlsdGVyID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZpbHRlciA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VxID0gISFzcGVjc1tpXS5zZXF1ZW50aWFsO1xuICAgICAgICBzID0gbWVyZ2VUcmFuc2FjdGlvbihzLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgc3BlY3NbaV0sIHNlcSA/IHMuY2hhbmdlcy5uZXdMZW5ndGggOiBzdGF0ZS5kb2MubGVuZ3RoKSwgc2VxKTtcbiAgICB9XG4gICAgbGV0IHRyID0gbmV3IFRyYW5zYWN0aW9uKHN0YXRlLCBzLmNoYW5nZXMsIHMuc2VsZWN0aW9uLCBzLmVmZmVjdHMsIHMuYW5ub3RhdGlvbnMsIHMuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIHJldHVybiBleHRlbmRUcmFuc2FjdGlvbihmaWx0ZXIgPyBmaWx0ZXJUcmFuc2FjdGlvbih0cikgOiB0cik7XG59XG4vLyBGaW5pc2ggYSB0cmFuc2FjdGlvbiBieSBhcHBseWluZyBmaWx0ZXJzIGlmIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGZpbHRlclRyYW5zYWN0aW9uKHRyKSB7XG4gICAgbGV0IHN0YXRlID0gdHIuc3RhcnRTdGF0ZTtcbiAgICAvLyBDaGFuZ2UgZmlsdGVyc1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGZvciAobGV0IGZpbHRlciBvZiBzdGF0ZS5mYWNldChjaGFuZ2VGaWx0ZXIpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZpbHRlcih0cik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB0cnVlID8gdmFsdWUgOiBqb2luUmFuZ2VzKHJlc3VsdCwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0ICE9PSB0cnVlKSB7XG4gICAgICAgIGxldCBjaGFuZ2VzLCBiYWNrO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFjayA9IHRyLmNoYW5nZXMuaW52ZXJ0ZWREZXNjO1xuICAgICAgICAgICAgY2hhbmdlcyA9IENoYW5nZVNldC5lbXB0eShzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZCA9IHRyLmNoYW5nZXMuZmlsdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gZmlsdGVyZWQuY2hhbmdlcztcbiAgICAgICAgICAgIGJhY2sgPSBmaWx0ZXJlZC5maWx0ZXJlZC5pbnZlcnRlZERlc2M7XG4gICAgICAgIH1cbiAgICAgICAgdHIgPSBuZXcgVHJhbnNhY3Rpb24oc3RhdGUsIGNoYW5nZXMsIHRyLnNlbGVjdGlvbiAmJiB0ci5zZWxlY3Rpb24ubWFwKGJhY2spLCBTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKHRyLmVmZmVjdHMsIGJhY2spLCB0ci5hbm5vdGF0aW9ucywgdHIuc2Nyb2xsSW50b1ZpZXcpO1xuICAgIH1cbiAgICAvLyBUcmFuc2FjdGlvbiBmaWx0ZXJzXG4gICAgbGV0IGZpbHRlcnMgPSBzdGF0ZS5mYWNldCh0cmFuc2FjdGlvbkZpbHRlcik7XG4gICAgZm9yIChsZXQgaSA9IGZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gZmlsdGVyc1tpXSh0cik7XG4gICAgICAgIGlmIChmaWx0ZXJlZCBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgdHIgPSBmaWx0ZXJlZDtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJlZCkgJiYgZmlsdGVyZWQubGVuZ3RoID09IDEgJiYgZmlsdGVyZWRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbilcbiAgICAgICAgICAgIHRyID0gZmlsdGVyZWRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRyID0gcmVzb2x2ZVRyYW5zYWN0aW9uKHN0YXRlLCBhc0FycmF5KGZpbHRlcmVkKSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdHI7XG59XG5mdW5jdGlvbiBleHRlbmRUcmFuc2FjdGlvbih0cikge1xuICAgIGxldCBzdGF0ZSA9IHRyLnN0YXJ0U3RhdGUsIGV4dGVuZGVycyA9IHN0YXRlLmZhY2V0KHRyYW5zYWN0aW9uRXh0ZW5kZXIpLCBzcGVjID0gdHI7XG4gICAgZm9yIChsZXQgaSA9IGV4dGVuZGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5kZXJzW2ldKHRyKTtcbiAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiBPYmplY3Qua2V5cyhleHRlbnNpb24pLmxlbmd0aClcbiAgICAgICAgICAgIHNwZWMgPSBtZXJnZVRyYW5zYWN0aW9uKHRyLCByZXNvbHZlVHJhbnNhY3Rpb25Jbm5lcihzdGF0ZSwgZXh0ZW5zaW9uLCB0ci5jaGFuZ2VzLm5ld0xlbmd0aCksIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlYyA9PSB0ciA/IHRyIDogbmV3IFRyYW5zYWN0aW9uKHN0YXRlLCB0ci5jaGFuZ2VzLCB0ci5zZWxlY3Rpb24sIHNwZWMuZWZmZWN0cywgc3BlYy5hbm5vdGF0aW9ucywgc3BlYy5zY3JvbGxJbnRvVmlldyk7XG59XG5jb25zdCBub25lID0gW107XG5mdW5jdGlvbiBhc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBub25lIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8qKlxuVGhlIGNhdGVnb3JpZXMgcHJvZHVjZWQgYnkgYSBbY2hhcmFjdGVyXG5jYXRlZ29yaXplcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIpLiBUaGVzZSBhcmUgdXNlZFxuZG8gdGhpbmdzIGxpa2Ugc2VsZWN0aW5nIGJ5IHdvcmQuXG4qL1xudmFyIENoYXJDYXRlZ29yeSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENoYXJDYXRlZ29yeSkge1xuICAgIC8qKlxuICAgIFdvcmQgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJXb3JkXCJdID0gMF0gPSBcIldvcmRcIjtcbiAgICAvKipcbiAgICBXaGl0ZXNwYWNlLlxuICAgICovXG4gICAgQ2hhckNhdGVnb3J5W0NoYXJDYXRlZ29yeVtcIlNwYWNlXCJdID0gMV0gPSBcIlNwYWNlXCI7XG4gICAgLyoqXG4gICAgQW55dGhpbmcgZWxzZS5cbiAgICAqL1xuICAgIENoYXJDYXRlZ29yeVtDaGFyQ2F0ZWdvcnlbXCJPdGhlclwiXSA9IDJdID0gXCJPdGhlclwiO1xucmV0dXJuIENoYXJDYXRlZ29yeX0pKENoYXJDYXRlZ29yeSB8fCAoQ2hhckNhdGVnb3J5ID0ge30pKTtcbmNvbnN0IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyID0gL1tcXHUwMGRmXFx1MDU4N1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTMwNDAtXFx1MzA5ZlxcdTMwYTAtXFx1MzBmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWFjMDAtXFx1ZDdhZl0vO1xubGV0IHdvcmRDaGFyO1xudHJ5IHtcbiAgICB3b3JkQ2hhciA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcXFxwe0FscGhhYmV0aWN9XFxcXHB7TnVtYmVyfV9dXCIsIFwidVwiKTtcbn1cbmNhdGNoIChfKSB7IH1cbmZ1bmN0aW9uIGhhc1dvcmRDaGFyKHN0cikge1xuICAgIGlmICh3b3JkQ2hhcilcbiAgICAgICAgcmV0dXJuIHdvcmRDaGFyLnRlc3Qoc3RyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2ggPSBzdHJbaV07XG4gICAgICAgIGlmICgvXFx3Ly50ZXN0KGNoKSB8fCBjaCA+IFwiXFx4ODBcIiAmJiAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtYWtlQ2F0ZWdvcml6ZXIod29yZENoYXJzKSB7XG4gICAgcmV0dXJuIChjaGFyKSA9PiB7XG4gICAgICAgIGlmICghL1xcUy8udGVzdChjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuU3BhY2U7XG4gICAgICAgIGlmIChoYXNXb3JkQ2hhcihjaGFyKSlcbiAgICAgICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuV29yZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hhci5pbmRleE9mKHdvcmRDaGFyc1tpXSkgPiAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hhckNhdGVnb3J5LldvcmQ7XG4gICAgICAgIHJldHVybiBDaGFyQ2F0ZWdvcnkuT3RoZXI7XG4gICAgfTtcbn1cblxuLyoqXG5UaGUgZWRpdG9yIHN0YXRlIGNsYXNzIGlzIGEgcGVyc2lzdGVudCAoaW1tdXRhYmxlKSBkYXRhIHN0cnVjdHVyZS5cblRvIHVwZGF0ZSBhIHN0YXRlLCB5b3UgW2NyZWF0ZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS51cGRhdGUpIGFcblt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbiksIHdoaWNoIHByb2R1Y2VzIGEgX25ld18gc3RhdGVcbmluc3RhbmNlLCB3aXRob3V0IG1vZGlmeWluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuXG5BcyBzdWNoLCBfbmV2ZXJfIG11dGF0ZSBwcm9wZXJ0aWVzIG9mIGEgc3RhdGUgZGlyZWN0bHkuIFRoYXQnbGxcbmp1c3QgYnJlYWsgdGhpbmdzLlxuKi9cbmNsYXNzIEVkaXRvclN0YXRlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uZmlnLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvYywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICovXG4gICAgc2VsZWN0aW9uLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHZhbHVlcywgdHIgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwbHlpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IGNvbmZpZy5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpO1xuICAgICAgICB0aGlzLmFwcGx5aW5nID0gdHI7XG4gICAgICAgIC8vIEZpbGwgaW4gdGhlIGNvbXB1dGVkIHN0YXRlIGltbWVkaWF0ZWx5LCBzbyB0aGF0IGZ1cnRoZXIgcXVlcmllc1xuICAgICAgICAvLyBmb3IgaXQgbWFkZSBkdXJpbmcgdGhlIHVwZGF0ZSByZXR1cm4gdGhpcyBzdGF0ZVxuICAgICAgICBpZiAodHIpXG4gICAgICAgICAgICB0ci5fc3RhdGUgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGVuc3VyZUFkZHIodGhpcywgaSA8PCAxKTtcbiAgICAgICAgdGhpcy5hcHBseWluZyA9IG51bGw7XG4gICAgfVxuICAgIGZpZWxkKGZpZWxkLCByZXF1aXJlID0gdHJ1ZSkge1xuICAgICAgICBsZXQgYWRkciA9IHRoaXMuY29uZmlnLmFkZHJlc3NbZmllbGQuaWRdO1xuICAgICAgICBpZiAoYWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUFkZHIodGhpcywgYWRkcik7XG4gICAgICAgIHJldHVybiBnZXRBZGRyKHRoaXMsIGFkZHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24pIHRoYXQgdXBkYXRlcyB0aGlzXG4gICAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgICBjYW4gYmUgcGFzc2VkLiBVbmxlc3NcbiAgICBbYHNlcXVlbnRpYWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZXF1ZW50aWFsKSBpcyBzZXQsIHRoZVxuICAgIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgICBhcmUgYXNzdW1lZCB0byBzdGFydCBpbiB0aGUgX2N1cnJlbnRfIGRvY3VtZW50IChub3QgdGhlIGRvY3VtZW50XG4gICAgcHJvZHVjZWQgYnkgcHJldmlvdXMgc3BlY3MpLCBhbmQgaXRzXG4gICAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgICBbZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgYXJlIGFzc3VtZWQgdG8gcmVmZXJcbiAgICB0byB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSBpdHMgX293bl8gY2hhbmdlcy4gVGhlIHJlc3VsdGluZ1xuICAgIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgICBzcGVjcy4gRm9yIFtzZWxlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbiksIGxhdGVyXG4gICAgc3BlY3MgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZWFybGllciBvbmVzLlxuICAgICovXG4gICAgdXBkYXRlKC4uLnNwZWNzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlVHJhbnNhY3Rpb24odGhpcywgc3BlY3MsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFwcGx5VHJhbnNhY3Rpb24odHIpIHtcbiAgICAgICAgbGV0IGNvbmYgPSB0aGlzLmNvbmZpZywgeyBiYXNlLCBjb21wYXJ0bWVudHMgfSA9IGNvbmY7XG4gICAgICAgIGZvciAobGV0IGVmZmVjdCBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0LmlzKENvbXBhcnRtZW50LnJlY29uZmlndXJlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb25mKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcnRtZW50cyA9IG5ldyBNYXA7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYuY29tcGFydG1lbnRzLmZvckVhY2goKHZhbCwga2V5KSA9PiBjb21wYXJ0bWVudHMuc2V0KGtleSwgdmFsKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmYgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wYXJ0bWVudHMuc2V0KGVmZmVjdC52YWx1ZS5jb21wYXJ0bWVudCwgZWZmZWN0LnZhbHVlLmV4dGVuc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXMoU3RhdGVFZmZlY3QucmVjb25maWd1cmUpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVmZmVjdC5pcyhTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGFzQXJyYXkoYmFzZSkuY29uY2F0KGVmZmVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VmFsdWVzO1xuICAgICAgICBpZiAoIWNvbmYpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZCA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShiYXNlLCBjb21wYXJ0bWVudHMsIHRoaXMpO1xuICAgICAgICAgICAgY29uZiA9IHJlc29sdmVkLmNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICBsZXQgaW50ZXJtZWRpYXRlU3RhdGUgPSBuZXcgRWRpdG9yU3RhdGUoY29uZiwgdGhpcy5kb2MsIHRoaXMuc2VsZWN0aW9uLCByZXNvbHZlZC52YWx1ZXMsIG51bGwpO1xuICAgICAgICAgICAgc3RhcnRWYWx1ZXMgPSBpbnRlcm1lZGlhdGVTdGF0ZS52YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlcyA9IHRyLnN0YXJ0U3RhdGUudmFsdWVzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3IEVkaXRvclN0YXRlKGNvbmYsIHRyLm5ld0RvYywgdHIubmV3U2VsZWN0aW9uLCBzdGFydFZhbHVlcywgdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgICByZXBsYWNlcyBldmVyeSBzZWxlY3Rpb24gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudC5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24odGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnRvVGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiAoeyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiB0ZXh0IH0sXG4gICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgdGV4dC5sZW5ndGgpIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGNoYW5nZXMgYW5kIGEgbmV3IHNlbGVjdGlvbiBieSBydW5uaW5nIHRoZSBnaXZlblxuICAgIGZ1bmN0aW9uIGZvciBlYWNoIHJhbmdlIGluIHRoZSBhY3RpdmUgc2VsZWN0aW9uLiBUaGUgZnVuY3Rpb25cbiAgICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICAgIG9mIHRoZSBzdGFydCBkb2N1bWVudCksIHBsdXMgYW4gdXBkYXRlZCByYW5nZSAoaW4gdGhlIGNvb3JkaW5hdGVcbiAgICBzcGFjZSBvZiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgdGhlIGNhbGwncyBvd24gY2hhbmdlcykuIFRoaXNcbiAgICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gICAgY2hhbmdlc2V0IGFuZCBzZWxlY3Rpb24sIGFuZCByZXR1cm4gaXQgYXMgYSBbdHJhbnNhY3Rpb25cbiAgICBzcGVjXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYyksIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG9cbiAgICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgICAqL1xuICAgIGNoYW5nZUJ5UmFuZ2UoZikge1xuICAgICAgICBsZXQgc2VsID0gdGhpcy5zZWxlY3Rpb247XG4gICAgICAgIGxldCByZXN1bHQxID0gZihzZWwucmFuZ2VzWzBdKTtcbiAgICAgICAgbGV0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXMocmVzdWx0MS5jaGFuZ2VzKSwgcmFuZ2VzID0gW3Jlc3VsdDEucmFuZ2VdO1xuICAgICAgICBsZXQgZWZmZWN0cyA9IGFzQXJyYXkocmVzdWx0MS5lZmZlY3RzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZihzZWwucmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIGxldCBuZXdDaGFuZ2VzID0gdGhpcy5jaGFuZ2VzKHJlc3VsdC5jaGFuZ2VzKSwgbmV3TWFwcGVkID0gbmV3Q2hhbmdlcy5tYXAoY2hhbmdlcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGk7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSByYW5nZXNbal0ubWFwKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBsZXQgbWFwQnkgPSBjaGFuZ2VzLm1hcERlc2MobmV3Q2hhbmdlcywgdHJ1ZSk7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyZXN1bHQucmFuZ2UubWFwKG1hcEJ5KSk7XG4gICAgICAgICAgICBjaGFuZ2VzID0gY2hhbmdlcy5jb21wb3NlKG5ld01hcHBlZCk7XG4gICAgICAgICAgICBlZmZlY3RzID0gU3RhdGVFZmZlY3QubWFwRWZmZWN0cyhlZmZlY3RzLCBuZXdNYXBwZWQpLmNvbmNhdChTdGF0ZUVmZmVjdC5tYXBFZmZlY3RzKGFzQXJyYXkocmVzdWx0LmVmZmVjdHMpLCBtYXBCeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFuZ2VzLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKHJhbmdlcywgc2VsLm1haW5JbmRleCksXG4gICAgICAgICAgICBlZmZlY3RzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIFtjaGFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZVNldCkgZnJvbSB0aGUgZ2l2ZW4gY2hhbmdlXG4gICAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgICBzZXBhcmF0b3IgaW50byBhY2NvdW50LlxuICAgICovXG4gICAgY2hhbmdlcyhzcGVjID0gW10pIHtcbiAgICAgICAgaWYgKHNwZWMgaW5zdGFuY2VvZiBDaGFuZ2VTZXQpXG4gICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgcmV0dXJuIENoYW5nZVNldC5vZihzcGVjLCB0aGlzLmRvYy5sZW5ndGgsIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2luZyB0aGUgc3RhdGUncyBbbGluZVxuICAgIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgICBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3RleHQuVGV4dCkgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgdG9UZXh0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihzdHJpbmcuc3BsaXQodGhpcy5mYWNldChFZGl0b3JTdGF0ZS5saW5lU2VwYXJhdG9yKSB8fCBEZWZhdWx0U3BsaXQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBnaXZlbiByYW5nZSBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmcuXG4gICAgKi9cbiAgICBzbGljZURvYyhmcm9tID0gMCwgdG8gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvLCB0aGlzLmxpbmVCcmVhayk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQpLlxuICAgICovXG4gICAgZmFjZXQoZmFjZXQpIHtcbiAgICAgICAgbGV0IGFkZHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2ZhY2V0LmlkXTtcbiAgICAgICAgaWYgKGFkZHIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWNldC5kZWZhdWx0O1xuICAgICAgICBlbnN1cmVBZGRyKHRoaXMsIGFkZHIpO1xuICAgICAgICByZXR1cm4gZ2V0QWRkcih0aGlzLCBhZGRyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udmVydCB0aGlzIHN0YXRlIHRvIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgc2VyaWFsaXplZCwgeW91IGNhbiBwYXNzIHRoZW0gaW4gYXMgYW4gb2JqZWN0XG4gICAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICAgIG5vdCB1c2UgYGRvY2Agb3IgYHNlbGVjdGlvbmApIHRvIGZpZWxkcy5cbiAgICAqL1xuICAgIHRvSlNPTihmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGRvYzogdGhpcy5zbGljZURvYygpLFxuICAgICAgICAgICAgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZmllbGRzKVxuICAgICAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBmaWVsZHNbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RhdGVGaWVsZClcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUuc3BlYy50b0pTT04odGhpcy5maWVsZChmaWVsZHNbcHJvcF0pLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGF0ZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaGVuIGN1c3RvbVxuICAgIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gICAgdG8gW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnRvSlNPTikgd2hlbiBzZXJpYWxpemluZyBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbmZpZyA9IHt9LCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uIHx8IHR5cGVvZiBqc29uLmRvYyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIEVkaXRvclN0YXRlXCIpO1xuICAgICAgICBsZXQgZmllbGRJbml0ID0gW107XG4gICAgICAgIGlmIChmaWVsZHMpXG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1twcm9wXSwgdmFsdWUgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgICAgIGZpZWxkSW5pdC5wdXNoKGZpZWxkLmluaXQoc3RhdGUgPT4gZmllbGQuc3BlYy5mcm9tSlNPTih2YWx1ZSwgc3RhdGUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgZG9jOiBqc29uLmRvYyxcbiAgICAgICAgICAgIHNlbGVjdGlvbjogRWRpdG9yU2VsZWN0aW9uLmZyb21KU09OKGpzb24uc2VsZWN0aW9uKSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IGNvbmZpZy5leHRlbnNpb25zID8gZmllbGRJbml0LmNvbmNhdChbY29uZmlnLmV4dGVuc2lvbnNdKSA6IGZpZWxkSW5pdFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gICAgaW5pdGlhbGl6aW5nIGFuIGVkaXRvcuKAlHVwZGF0ZWQgc3RhdGVzIGFyZSBjcmVhdGVkIGJ5IGFwcGx5aW5nXG4gICAgdHJhbnNhY3Rpb25zLlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICBsZXQgeyBjb25maWd1cmF0aW9uLCB2YWx1ZXMgfSA9IENvbmZpZ3VyYXRpb24ucmVzb2x2ZShjb25maWcuZXh0ZW5zaW9ucyB8fCBbXSwgbmV3IE1hcCk7XG4gICAgICAgIGxldCBkb2MgPSBjb25maWcuZG9jIGluc3RhbmNlb2YgVGV4dCA/IGNvbmZpZy5kb2NcbiAgICAgICAgICAgIDogVGV4dC5vZigoY29uZmlnLmRvYyB8fCBcIlwiKS5zcGxpdChjb25maWd1cmF0aW9uLnN0YXRpY0ZhY2V0KEVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IpIHx8IERlZmF1bHRTcGxpdCkpO1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gIWNvbmZpZy5zZWxlY3Rpb24gPyBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKDApXG4gICAgICAgICAgICA6IGNvbmZpZy5zZWxlY3Rpb24gaW5zdGFuY2VvZiBFZGl0b3JTZWxlY3Rpb24gPyBjb25maWcuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgOiBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGNvbmZpZy5zZWxlY3Rpb24uYW5jaG9yLCBjb25maWcuc2VsZWN0aW9uLmhlYWQpO1xuICAgICAgICBjaGVja1NlbGVjdGlvbihzZWxlY3Rpb24sIGRvYy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uc3RhdGljRmFjZXQoYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpKVxuICAgICAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgICAgIHJldHVybiBuZXcgRWRpdG9yU3RhdGUoY29uZmlndXJhdGlvbiwgZG9jLCBzZWxlY3Rpb24sIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgICB0aGUgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSBmYWNldC5cbiAgICAqL1xuICAgIGdldCB0YWJTaXplKCkgeyByZXR1cm4gdGhpcy5mYWNldChFZGl0b3JTdGF0ZS50YWJTaXplKTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcHJvcGVyIFtsaW5lLWJyZWFrXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxpbmVTZXBhcmF0b3IpXG4gICAgc3RyaW5nIGZvciB0aGlzIHN0YXRlLlxuICAgICovXG4gICAgZ2V0IGxpbmVCcmVhaygpIHsgcmV0dXJuIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUubGluZVNlcGFyYXRvcikgfHwgXCJcXG5cIjsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAgICovXG4gICAgZ2V0IHJlYWRPbmx5KCkgeyByZXR1cm4gdGhpcy5mYWNldChyZWFkT25seSk7IH1cbiAgICAvKipcbiAgICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgICBbYHBocmFzZXNgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnBocmFzZXMpIGZhY2V0KSwgb3IgcmV0dXJuIHRoZVxuICAgIG9yaWdpbmFsIHN0cmluZyBpZiBubyB0cmFuc2xhdGlvbiBpcyBmb3VuZC5cbiAgICAqL1xuICAgIHBocmFzZShwaHJhc2UpIHtcbiAgICAgICAgZm9yIChsZXQgbWFwIG9mIHRoaXMuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcGhyYXNlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwW3BocmFzZV07XG4gICAgICAgIHJldHVybiBwaHJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgICB0aGUgW2BsYW5ndWFnZURhdGFgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXmxhbmd1YWdlRGF0YSkgZmFjZXQuXG4gICAgKi9cbiAgICBsYW5ndWFnZURhdGFBdChuYW1lLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIHRoaXMuZmFjZXQobGFuZ3VhZ2VEYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgcmVzdWx0IG9mIHByb3ZpZGVyKHRoaXMsIHBvcywgc2lkZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJlc3VsdFtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gY2F0ZWdvcml6ZSBzdHJpbmdzIChleHBlY3RlZCB0b1xuICAgIHJlcHJlc2VudCBhIHNpbmdsZSBbZ3JhcGhlbWUgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN0ZXh0LmZpbmRDbHVzdGVyQnJlYWspKVxuICAgIGludG8gb25lIG9mOlxuICAgIFxuICAgICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgICBleHBsaWNpdGx5IGxpc3RlZCBpbiB0aGUgbG9jYWwgbGFuZ3VhZ2UncyBgXCJ3b3JkQ2hhcnNcImBcbiAgICAgICBsYW5ndWFnZSBkYXRhLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcpXG4gICAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgICAgLSBPdGhlciAoYW55dGhpbmcgZWxzZSlcbiAgICAqL1xuICAgIGNoYXJDYXRlZ29yaXplcihhdCkge1xuICAgICAgICByZXR1cm4gbWFrZUNhdGVnb3JpemVyKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgYXQpLmpvaW4oXCJcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSB3b3JkIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgbWVhbmluZyB0aGUgcmFuZ2VcbiAgICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICAgIGFyb3VuZCBpdC4gSWYgbm8gd29yZCBjaGFyYWN0ZXJzIGFyZSBhZGphY2VudCB0byB0aGUgcG9zaXRpb24sXG4gICAgdGhpcyByZXR1cm5zIG51bGwuXG4gICAgKi9cbiAgICB3b3JkQXQocG9zKSB7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb20sIGxlbmd0aCB9ID0gdGhpcy5kb2MubGluZUF0KHBvcyk7XG4gICAgICAgIGxldCBjYXQgPSB0aGlzLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3MgLSBmcm9tLCBlbmQgPSBwb3MgLSBmcm9tO1xuICAgICAgICB3aGlsZSAoc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsodGV4dCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjYXQodGV4dC5zbGljZShwcmV2LCBzdGFydCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RhcnQgPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChlbmQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZmluZENsdXN0ZXJCcmVhayh0ZXh0LCBlbmQpO1xuICAgICAgICAgICAgaWYgKGNhdCh0ZXh0LnNsaWNlKGVuZCwgbmV4dCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZW5kID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcnQgPT0gZW5kID8gbnVsbCA6IEVkaXRvclNlbGVjdGlvbi5yYW5nZShzdGFydCArIGZyb20sIGVuZCArIGZyb20pO1xuICAgIH1cbn1cbi8qKlxuQSBmYWNldCB0aGF0LCB3aGVuIGVuYWJsZWQsIGNhdXNlcyB0aGUgZWRpdG9yIHRvIGFsbG93IG11bHRpcGxlXG5yYW5nZXMgdG8gYmUgc2VsZWN0ZWQuIEJlIGNhcmVmdWwgdGhvdWdoLCBiZWNhdXNlIGJ5IGRlZmF1bHQgdGhlXG5lZGl0b3IgcmVsaWVzIG9uIHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgd2hpY2ggY2Fubm90IGhhbmRsZVxubXVsdGlwbGUgc2VsZWN0aW9ucy4gQW4gZXh0ZW5zaW9uIGxpa2VcbltgZHJhd1NlbGVjdGlvbmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5kcmF3U2VsZWN0aW9uKSBjYW4gYmUgdXNlZCB0byBtYWtlXG5zZWNvbmRhcnkgc2VsZWN0aW9ucyB2aXNpYmxlIHRvIHRoZSB1c2VyLlxuKi9cbkVkaXRvclN0YXRlLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zID0gYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnM7XG4vKipcbkNvbmZpZ3VyZXMgdGhlIHRhYiBzaXplIHRvIHVzZSBpbiB0aGlzIHN0YXRlLiBUaGUgZmlyc3RcbihoaWdoZXN0LXByZWNlZGVuY2UpIHZhbHVlIG9mIHRoZSBmYWNldCBpcyB1c2VkLiBJZiBubyB2YWx1ZSBpc1xuZ2l2ZW4sIHRoaXMgZGVmYXVsdHMgdG8gNC5cbiovXG5FZGl0b3JTdGF0ZS50YWJTaXplID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiA0XG59KTtcbi8qKlxuVGhlIGxpbmUgc2VwYXJhdG9yIHRvIHVzZS4gQnkgZGVmYXVsdCwgYW55IG9mIGBcIlxcblwiYCwgYFwiXFxyXFxuXCJgXG5hbmQgYFwiXFxyXCJgIGlzIHRyZWF0ZWQgYXMgYSBzZXBhcmF0b3Igd2hlbiBzcGxpdHRpbmcgbGluZXMsIGFuZFxubGluZXMgYXJlIGpvaW5lZCB3aXRoIGBcIlxcblwiYC5cblxuV2hlbiB5b3UgY29uZmlndXJlIGEgdmFsdWUgaGVyZSwgb25seSB0aGF0IHByZWNpc2Ugc2VwYXJhdG9yXG53aWxsIGJlIHVzZWQsIGFsbG93aW5nIHlvdSB0byByb3VuZC10cmlwIGRvY3VtZW50cyB0aHJvdWdoIHRoZVxuZWRpdG9yIHdpdGhvdXQgbm9ybWFsaXppbmcgbGluZSBzZXBhcmF0b3JzLlxuKi9cbkVkaXRvclN0YXRlLmxpbmVTZXBhcmF0b3IgPSBsaW5lU2VwYXJhdG9yO1xuLyoqXG5UaGlzIGZhY2V0IGNvbnRyb2xzIHRoZSB2YWx1ZSBvZiB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBnZXR0ZXIsIHdoaWNoIGlzXG5jb25zdWx0ZWQgYnkgY29tbWFuZHMgYW5kIGV4dGVuc2lvbnMgdGhhdCBpbXBsZW1lbnQgZWRpdGluZ1xuZnVuY3Rpb25hbGl0eSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IHNob3VsZCBhcHBseS4gSXRcbmRlZmF1bHRzIHRvIGZhbHNlLCBidXQgd2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzXG5gdHJ1ZWAsIHN1Y2ggZnVuY3Rpb25hbGl0eSBkaXNhYmxlcyBpdHNlbGYuXG5cbk5vdCB0byBiZSBjb25mdXNlZCB3aXRoXG5bYEVkaXRvclZpZXcuZWRpdGFibGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15lZGl0YWJsZSksIHdoaWNoXG5jb250cm9scyB3aGV0aGVyIHRoZSBlZGl0b3IncyBET00gaXMgc2V0IHRvIGJlIGVkaXRhYmxlIChhbmRcbnRodXMgZm9jdXNhYmxlKS5cbiovXG5FZGl0b3JTdGF0ZS5yZWFkT25seSA9IHJlYWRPbmx5O1xuLyoqXG5SZWdpc3RlcnMgdHJhbnNsYXRpb24gcGhyYXNlcy4gVGhlXG5bYHBocmFzZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUucGhyYXNlKSBtZXRob2Qgd2lsbCBsb29rIHRocm91Z2hcbmFsbCBvYmplY3RzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGZhY2V0IHRvIGZpbmQgdHJhbnNsYXRpb25zIGZvclxuaXRzIGFyZ3VtZW50LlxuKi9cbkVkaXRvclN0YXRlLnBocmFzZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG4vKipcbkEgZmFjZXQgdXNlZCB0byByZWdpc3RlciBbbGFuZ3VhZ2VcbmRhdGFdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUubGFuZ3VhZ2VEYXRhQXQpIHByb3ZpZGVycy5cbiovXG5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEgPSBsYW5ndWFnZURhdGE7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgY2hhbmdlIGZpbHRlcnMsIHdoaWNoIGFyZSBjYWxsZWQgZm9yIGVhY2hcbnRyYW5zYWN0aW9uICh1bmxlc3MgZXhwbGljaXRseVxuW2Rpc2FibGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpKSwgYW5kIGNhbiBzdXBwcmVzc1xucGFydCBvZiB0aGUgdHJhbnNhY3Rpb24ncyBjaGFuZ2VzLlxuXG5TdWNoIGEgZnVuY3Rpb24gY2FuIHJldHVybiBgdHJ1ZWAgdG8gaW5kaWNhdGUgdGhhdCBpdCBkb2Vzbid0XG53YW50IHRvIGRvIGFueXRoaW5nLCBgZmFsc2VgIHRvIGNvbXBsZXRlbHkgc3RvcCB0aGUgY2hhbmdlcyBpblxudGhlIHRyYW5zYWN0aW9uLCBvciBhIHNldCBvZiByYW5nZXMgaW4gd2hpY2ggY2hhbmdlcyBzaG91bGQgYmVcbnN1cHByZXNzZWQuIFN1Y2ggcmFuZ2VzIGFyZSByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLFxud2l0aCBlYWNoIHBhaXIgb2YgdHdvIG51bWJlciBpbmRpY2F0aW5nIHRoZSBzdGFydCBhbmQgZW5kIG9mIGFcbnJhbmdlLiBTbyBmb3IgZXhhbXBsZSBgWzEwLCAyMCwgMTAwLCAxMTBdYCBzdXBwcmVzc2VzIGNoYW5nZXNcbmJldHdlZW4gMTAgYW5kIDIwLCBhbmQgYmV0d2VlbiAxMDAgYW5kIDExMC5cbiovXG5FZGl0b3JTdGF0ZS5jaGFuZ2VGaWx0ZXIgPSBjaGFuZ2VGaWx0ZXI7XG4vKipcbkZhY2V0IHVzZWQgdG8gcmVnaXN0ZXIgYSBob29rIHRoYXQgZ2V0cyBhIGNoYW5jZSB0byB1cGRhdGUgb3JcbnJlcGxhY2UgdHJhbnNhY3Rpb24gc3BlY3MgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQuIFRoaXMgd2lsbFxub25seSBiZSBhcHBsaWVkIGZvciB0cmFuc2FjdGlvbnMgdGhhdCBkb24ndCBoYXZlXG5bYGZpbHRlcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmZpbHRlcikgc2V0IHRvIGBmYWxzZWAuIFlvdVxuY2FuIGVpdGhlciByZXR1cm4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gc3BlYyAocG9zc2libHkgdGhlIGlucHV0XG50cmFuc2FjdGlvbiksIG9yIGFuIGFycmF5IG9mIHNwZWNzICh3aGljaCB3aWxsIGJlIGNvbWJpbmVkIGluXG50aGUgc2FtZSB3YXkgYXMgdGhlIGFyZ3VtZW50cyB0b1xuW2BFZGl0b3JTdGF0ZS51cGRhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnVwZGF0ZSkpLlxuXG5XaGVuIHBvc3NpYmxlLCBpdCBpcyByZWNvbW1lbmRlZCB0byBhdm9pZCBhY2Nlc3NpbmdcbltgVHJhbnNhY3Rpb24uc3RhdGVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnN0YXRlKSBpbiBhIGZpbHRlcixcbnNpbmNlIGl0IHdpbGwgZm9yY2UgY3JlYXRpb24gb2YgYSBzdGF0ZSB0aGF0IHdpbGwgdGhlbiBiZVxuZGlzY2FyZGVkIGFnYWluLCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYWN0dWFsbHkgZmlsdGVyZWQuXG5cbihUaGlzIGZ1bmN0aW9uYWxpdHkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjYXJlLiBJbmRpc2NyaW1pbmF0ZWx5XG5tb2RpZnlpbmcgdHJhbnNhY3Rpb24gaXMgbGlrZWx5IHRvIGJyZWFrIHNvbWV0aGluZyBvciBkZWdyYWRlXG50aGUgdXNlciBleHBlcmllbmNlLilcbiovXG5FZGl0b3JTdGF0ZS50cmFuc2FjdGlvbkZpbHRlciA9IHRyYW5zYWN0aW9uRmlsdGVyO1xuLyoqXG5UaGlzIGlzIGEgbW9yZSBsaW1pdGVkIGZvcm0gb2ZcbltgdHJhbnNhY3Rpb25GaWx0ZXJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlXnRyYW5zYWN0aW9uRmlsdGVyKSxcbndoaWNoIGNhbiBvbmx5IGFkZFxuW2Fubm90YXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5hbm5vdGF0aW9ucykgYW5kXG5bZWZmZWN0c10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykuIF9CdXRfLCB0aGlzIHR5cGVcbm9mIGZpbHRlciBydW5zIGV2ZW4gdGhlIHRyYW5zYWN0aW9uIGhhcyBkaXNhYmxlZCByZWd1bGFyXG5bZmlsdGVyaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5maWx0ZXIpLCBtYWtpbmcgaXQgc3VpdGFibGVcbmZvciBlZmZlY3RzIHRoYXQgZG9uJ3QgbmVlZCB0byB0b3VjaCB0aGUgY2hhbmdlcyBvciBzZWxlY3Rpb24sXG5idXQgZG8gd2FudCB0byBwcm9jZXNzIGV2ZXJ5IHRyYW5zYWN0aW9uLlxuXG5FeHRlbmRlcnMgcnVuIF9hZnRlcl8gZmlsdGVycywgd2hlbiBib3RoIGFyZSBhcHBsaWVkLlxuKi9cbkVkaXRvclN0YXRlLnRyYW5zYWN0aW9uRXh0ZW5kZXIgPSB0cmFuc2FjdGlvbkV4dGVuZGVyO1xuQ29tcGFydG1lbnQucmVjb25maWd1cmUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5cbi8qKlxuVXRpbGl0eSBmdW5jdGlvbiBmb3IgY29tYmluaW5nIGJlaGF2aW9ycyB0byBmaWxsIGluIGEgY29uZmlnXG5vYmplY3QgZnJvbSBhbiBhcnJheSBvZiBwcm92aWRlZCBjb25maWdzLiBXaWxsLCBieSBkZWZhdWx0LCBlcnJvclxud2hlbiBhIGZpZWxkIGdldHMgdHdvIHZhbHVlcyB0aGF0IGFyZW4ndCBgPT09YC1lcXVhbCwgYnV0IHlvdSBjYW5cbnByb3ZpZGUgY29tYmluZSBmdW5jdGlvbnMgcGVyIGZpZWxkIHRvIGRvIHNvbWV0aGluZyBlbHNlLlxuKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb25maWcoY29uZmlncywgZGVmYXVsdHMsIC8vIFNob3VsZCBob2xkIG9ubHkgdGhlIG9wdGlvbmFsIHByb3BlcnRpZXMgb2YgQ29uZmlnLCBidXQgSSBoYXZlbid0IG1hbmFnZWQgdG8gZXhwcmVzcyB0aGF0XG5jb21iaW5lID0ge30pIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ3MpXG4gICAgICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjb25maWdba2V5XSwgY3VycmVudCA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgOyAvLyBObyBjb25mbGljdFxuICAgICAgICAgICAgZWxzZSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY29tYmluZSwga2V5KSlcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGNvbWJpbmVba2V5XShjdXJyZW50LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZmlnIG1lcmdlIGNvbmZsaWN0IGZvciBmaWVsZCBcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdHMpXG4gICAgICAgIGlmIChyZXN1bHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IEFubm90YXRpb24sIEFubm90YXRpb25UeXBlLCBDaGFuZ2VEZXNjLCBDaGFuZ2VTZXQsIENoYXJDYXRlZ29yeSwgQ29tcGFydG1lbnQsIEVkaXRvclNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIEZhY2V0LCBNYXBNb2RlLCBQcmVjLCBTZWxlY3Rpb25SYW5nZSwgU3RhdGVFZmZlY3QsIFN0YXRlRWZmZWN0VHlwZSwgU3RhdGVGaWVsZCwgVHJhbnNhY3Rpb24sIGNvbWJpbmVDb25maWcgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/state/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/text/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/text/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line\": function() { return /* binding */ Line; },\n/* harmony export */   \"Text\": function() { return /* binding */ Text; },\n/* harmony export */   \"codePointAt\": function() { return /* binding */ codePointAt; },\n/* harmony export */   \"codePointSize\": function() { return /* binding */ codePointSize; },\n/* harmony export */   \"countColumn\": function() { return /* binding */ countColumn; },\n/* harmony export */   \"findClusterBreak\": function() { return /* binding */ findClusterBreak; },\n/* harmony export */   \"findColumn\": function() { return /* binding */ findColumn; },\n/* harmony export */   \"fromCodePoint\": function() { return /* binding */ fromCodePoint; }\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nvar extend = /*@__PURE__*/\"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(function (s) {\n  return s ? parseInt(s, 36) : 1;\n}); // Convert offsets into absolute values\n\nfor (var i = 1; i < extend.length; i++) {\n  extend[i] += extend[i - 1];\n}\n\nfunction isExtendingChar(code) {\n  for (var _i = 1; _i < extend.length; _i += 2) {\n    if (extend[_i] > code) return extend[_i - 1] <= code;\n  }\n\n  return false;\n}\n\nfunction isRegionalIndicator(code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\n\nvar ZWJ = 0x200d;\n/**\nReturns a next grapheme cluster break _after_ (not equal to)\n`pos`, if `forward` is true, or before otherwise. Returns `pos`\nitself if no further cluster break is available in the string.\nMoves across surrogate pairs, extending characters (when\n`includeExtending` is true), characters joined with zero-width\njoiners, and flag emoji.\n*/\n\nfunction findClusterBreak(str, pos) {\n  var forward = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var includeExtending = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);\n}\n\nfunction nextClusterBreak(str, pos, includeExtending) {\n  if (pos == str.length) return pos; // If pos is in the middle of a surrogate pair, move to its start\n\n  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n  var prev = codePointAt(str, pos);\n  pos += codePointSize(prev);\n\n  while (pos < str.length) {\n    var next = codePointAt(str, pos);\n\n    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {\n      pos += codePointSize(next);\n      prev = next;\n    } else if (isRegionalIndicator(next)) {\n      var countBefore = 0,\n          _i2 = pos - 2;\n\n      while (_i2 >= 0 && isRegionalIndicator(codePointAt(str, _i2))) {\n        countBefore++;\n        _i2 -= 2;\n      }\n\n      if (countBefore % 2 == 0) break;else pos += 2;\n    } else {\n      break;\n    }\n  }\n\n  return pos;\n}\n\nfunction prevClusterBreak(str, pos, includeExtending) {\n  while (pos > 0) {\n    var found = nextClusterBreak(str, pos - 2, includeExtending);\n    if (found < pos) return found;\n    pos--;\n  }\n\n  return 0;\n}\n\nfunction surrogateLow(ch) {\n  return ch >= 0xDC00 && ch < 0xE000;\n}\n\nfunction surrogateHigh(ch) {\n  return ch >= 0xD800 && ch < 0xDC00;\n}\n/**\nFind the code point at the given position in a string (like the\n[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\nstring method).\n*/\n\n\nfunction codePointAt(str, pos) {\n  var code0 = str.charCodeAt(pos);\n  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n  var code1 = str.charCodeAt(pos + 1);\n  if (!surrogateLow(code1)) return code0;\n  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/**\nGiven a Unicode codepoint, return the JavaScript string that\nrespresents it (like\n[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n*/\n\n\nfunction fromCodePoint(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/**\nThe first character that takes up two positions in a JavaScript\nstring. It is often useful to compare with this after calling\n`codePointAt`, to figure out whether your character takes up 1 or\n2 index positions.\n*/\n\n\nfunction codePointSize(code) {\n  return code < 0x10000 ? 1 : 2;\n}\n/**\nCount the column position at the given offset into the string,\ntaking extending characters and tab size into account.\n*/\n\n\nfunction countColumn(string, tabSize) {\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : string.length;\n  var n = 0;\n\n  for (var _i3 = 0; _i3 < to;) {\n    if (string.charCodeAt(_i3) == 9) {\n      n += tabSize - n % tabSize;\n      _i3++;\n    } else {\n      n++;\n      _i3 = findClusterBreak(string, _i3);\n    }\n  }\n\n  return n;\n}\n/**\nFind the offset that corresponds to the given column position in a\nstring, taking extending characters and tab size into account. By\ndefault, the string length is returned when it is too short to\nreach the column. Pass `strict` true to make it return -1 in that\nsituation.\n*/\n\n\nfunction findColumn(string, col, tabSize, strict) {\n  for (var _i4 = 0, n = 0;;) {\n    if (n >= col) return _i4;\n    if (_i4 == string.length) break;\n    n += string.charCodeAt(_i4) == 9 ? tabSize - n % tabSize : 1;\n    _i4 = findClusterBreak(string, _i4);\n  }\n\n  return strict === true ? -1 : string.length;\n}\n/**\nThe data structure for documents.\n*/\n\n\nvar Text = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Text() {\n    _classCallCheck(this, Text);\n  }\n  /**\n  Get the line description around the given position.\n  */\n\n\n  _createClass(Text, [{\n    key: \"lineAt\",\n    value: function lineAt(pos) {\n      if (pos < 0 || pos > this.length) throw new RangeError(\"Invalid position \".concat(pos, \" in document of length \").concat(this.length));\n      return this.lineInner(pos, false, 1, 0);\n    }\n    /**\n    Get the description for the given (1-based) line number.\n    */\n\n  }, {\n    key: \"line\",\n    value: function line(n) {\n      if (n < 1 || n > this.lines) throw new RangeError(\"Invalid line number \".concat(n, \" in \").concat(this.lines, \"-line document\"));\n      return this.lineInner(n, true, 1, 0);\n    }\n    /**\n    Replace a range of the text with the given content.\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, text) {\n      var parts = [];\n      this.decompose(0, from, parts, 2\n      /* To */\n      );\n      if (text.length) text.decompose(0, text.length, parts, 1\n      /* From */\n      | 2\n      /* To */\n      );\n      this.decompose(to, this.length, parts, 1\n      /* From */\n      );\n      return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /**\n    Append another document to this one.\n    */\n\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      return this.replace(this.length, this.length, other);\n    }\n    /**\n    Retrieve the text between the given points.\n    */\n\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      var parts = [];\n      this.decompose(from, to, parts, 0);\n      return TextNode.from(parts, to - from);\n    }\n    /**\n    Test whether this text is equal to another instance.\n    */\n\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (other == this) return true;\n      if (other.length != this.length || other.lines != this.lines) return false;\n      var start = this.scanIdentical(other, 1),\n          end = this.length - this.scanIdentical(other, -1);\n      var a = new RawTextCursor(this),\n          b = new RawTextCursor(other);\n\n      for (var skip = start, pos = start;;) {\n        a.next(skip);\n        b.next(skip);\n        skip = 0;\n        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n        pos += a.value.length;\n        if (a.done || pos >= end) return true;\n      }\n    }\n    /**\n    Iterate over the text. When `dir` is `-1`, iteration happens\n    from end to start. This will return lines and the breaks between\n    them as separate strings, and for long lines, might split lines\n    themselves into multiple chunks as well.\n    */\n\n  }, {\n    key: \"iter\",\n    value: function iter() {\n      var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      return new RawTextCursor(this, dir);\n    }\n    /**\n    Iterate over a range of the text. When `from` > `to`, the\n    iterator will run in reverse.\n    */\n\n  }, {\n    key: \"iterRange\",\n    value: function iterRange(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      return new PartialTextCursor(this, from, to);\n    }\n    /**\n    Return a cursor that iterates over the given range of lines,\n    _without_ returning the line breaks between, and yielding empty\n    strings for empty lines.\n    \n    When `from` and `to` are given, they should be 1-based line numbers.\n    */\n\n  }, {\n    key: \"iterLines\",\n    value: function iterLines(from, to) {\n      var inner;\n\n      if (from == null) {\n        inner = this.iter();\n      } else {\n        if (to == null) to = this.lines + 1;\n        var start = this.line(from).from;\n        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));\n      }\n\n      return new LineCursor(inner);\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.sliceString(0);\n    }\n    /**\n    Convert the document to an array of lines (which can be\n    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#text.Text^of)).\n    */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var lines = [];\n      this.flatten(lines);\n      return lines;\n    }\n    /**\n    Create a `Text` instance for the given array of lines.\n    */\n\n  }], [{\n    key: \"of\",\n    value: function of(text) {\n      if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n      if (text.length == 1 && !text[0]) return Text.empty;\n      return text.length <= 32\n      /* Branch */\n      ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n  }]);\n\n  return Text;\n}(); // Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\n\n\nvar TextLeaf = /*#__PURE__*/function (_Text) {\n  _inherits(TextLeaf, _Text);\n\n  var _super = _createSuper(TextLeaf);\n\n  function TextLeaf(text) {\n    var _this;\n\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : textLength(text);\n\n    _classCallCheck(this, TextLeaf);\n\n    _this = _super.call(this);\n    _this.text = text;\n    _this.length = length;\n    return _this;\n  }\n\n  _createClass(TextLeaf, [{\n    key: \"lines\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"lineInner\",\n    value: function lineInner(target, isLine, line, offset) {\n      for (var _i5 = 0;; _i5++) {\n        var string = this.text[_i5],\n            end = offset + string.length;\n        if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n        offset = end + 1;\n        line++;\n      }\n    }\n  }, {\n    key: \"decompose\",\n    value: function decompose(from, to, target, open) {\n      var text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n\n      if (open & 1\n      /* From */\n      ) {\n        var prev = target.pop();\n        var joined = appendText(text.text, prev.text.slice(), 0, text.length);\n\n        if (joined.length <= 32\n        /* Branch */\n        ) {\n          target.push(new TextLeaf(joined, prev.length + text.length));\n        } else {\n          var mid = joined.length >> 1;\n          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n        }\n      } else {\n        target.push(text);\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, text) {\n      if (!(text instanceof TextLeaf)) return _get(_getPrototypeOf(TextLeaf.prototype), \"replace\", this).call(this, from, to, text);\n      var lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n      var newLen = this.length + text.length - (to - from);\n      if (lines.length <= 32\n      /* Branch */\n      ) return new TextLeaf(lines, newLen);\n      return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n  }, {\n    key: \"sliceString\",\n    value: function sliceString(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      var lineSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\n\";\n      var result = \"\";\n\n      for (var pos = 0, _i6 = 0; pos <= to && _i6 < this.text.length; _i6++) {\n        var line = this.text[_i6],\n            end = pos + line.length;\n        if (pos > from && _i6) result += lineSep;\n        if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n        pos = end + 1;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten(target) {\n      var _iterator = _createForOfIteratorHelper(this.text),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          target.push(line);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"scanIdentical\",\n    value: function scanIdentical() {\n      return 0;\n    }\n  }], [{\n    key: \"split\",\n    value: function split(text, target) {\n      var part = [],\n          len = -1;\n\n      var _iterator2 = _createForOfIteratorHelper(text),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var line = _step2.value;\n          part.push(line);\n          len += line.length + 1;\n\n          if (part.length == 32\n          /* Branch */\n          ) {\n            target.push(new TextLeaf(part, len));\n            part = [];\n            len = -1;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (len > -1) target.push(new TextLeaf(part, len));\n      return target;\n    }\n  }]);\n\n  return TextLeaf;\n}(Text); // Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\n\n\nvar TextNode = /*#__PURE__*/function (_Text2) {\n  _inherits(TextNode, _Text2);\n\n  var _super2 = _createSuper(TextNode);\n\n  function TextNode(children, length) {\n    var _this2;\n\n    _classCallCheck(this, TextNode);\n\n    _this2 = _super2.call(this);\n    _this2.children = children;\n    _this2.length = length;\n    _this2.lines = 0;\n\n    var _iterator3 = _createForOfIteratorHelper(children),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var child = _step3.value;\n        _this2.lines += child.lines;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return _this2;\n  }\n\n  _createClass(TextNode, [{\n    key: \"lineInner\",\n    value: function lineInner(target, isLine, line, offset) {\n      for (var _i7 = 0;; _i7++) {\n        var child = this.children[_i7],\n            end = offset + child.length,\n            endLine = line + child.lines - 1;\n        if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n        offset = end + 1;\n        line = endLine + 1;\n      }\n    }\n  }, {\n    key: \"decompose\",\n    value: function decompose(from, to, target, open) {\n      for (var _i8 = 0, pos = 0; pos <= to && _i8 < this.children.length; _i8++) {\n        var child = this.children[_i8],\n            end = pos + child.length;\n\n        if (from <= end && to >= pos) {\n          var childOpen = open & ((pos <= from ? 1\n          /* From */\n          : 0) | (end >= to ? 2\n          /* To */\n          : 0));\n          if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);\n        }\n\n        pos = end + 1;\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, text) {\n      if (text.lines < this.lines) for (var _i9 = 0, pos = 0; _i9 < this.children.length; _i9++) {\n        var child = this.children[_i9],\n            end = pos + child.length; // Fast path: if the change only affects one child and the\n        // child's size remains in the acceptable range, only update\n        // that child\n\n        if (from >= pos && to <= end) {\n          var updated = child.replace(from - pos, to - pos, text);\n          var totalLines = this.lines - child.lines + updated.lines;\n\n          if (updated.lines < totalLines >> 5\n          /* BranchShift */\n          - 1 && updated.lines > totalLines >> 5\n          /* BranchShift */\n          + 1) {\n            var copy = this.children.slice();\n            copy[_i9] = updated;\n            return new TextNode(copy, this.length - (to - from) + text.length);\n          }\n\n          return _get(_getPrototypeOf(TextNode.prototype), \"replace\", this).call(this, pos, end, updated);\n        }\n\n        pos = end + 1;\n      }\n      return _get(_getPrototypeOf(TextNode.prototype), \"replace\", this).call(this, from, to, text);\n    }\n  }, {\n    key: \"sliceString\",\n    value: function sliceString(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;\n      var lineSep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\\n\";\n      var result = \"\";\n\n      for (var _i10 = 0, pos = 0; _i10 < this.children.length && pos <= to; _i10++) {\n        var child = this.children[_i10],\n            end = pos + child.length;\n        if (pos > from && _i10) result += lineSep;\n        if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n        pos = end + 1;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten(target) {\n      var _iterator4 = _createForOfIteratorHelper(this.children),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n          child.flatten(target);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"scanIdentical\",\n    value: function scanIdentical(other, dir) {\n      if (!(other instanceof TextNode)) return 0;\n      var length = 0;\n\n      var _ref = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1],\n          _ref2 = _slicedToArray(_ref, 4),\n          iA = _ref2[0],\n          iB = _ref2[1],\n          eA = _ref2[2],\n          eB = _ref2[3];\n\n      for (;; iA += dir, iB += dir) {\n        if (iA == eA || iB == eB) return length;\n        var chA = this.children[iA],\n            chB = other.children[iB];\n        if (chA != chB) return length + chA.scanIdentical(chB, dir);\n        length += chA.length + 1;\n      }\n    }\n  }], [{\n    key: \"from\",\n    value: function from(children) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : children.reduce(function (l, ch) {\n        return l + ch.length + 1;\n      }, -1);\n      var lines = 0;\n\n      var _iterator5 = _createForOfIteratorHelper(children),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _ch = _step5.value;\n          lines += _ch.lines;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      if (lines < 32\n      /* Branch */\n      ) {\n        var flat = [];\n\n        var _iterator6 = _createForOfIteratorHelper(children),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var ch = _step6.value;\n            ch.flatten(flat);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        return new TextLeaf(flat, length);\n      }\n\n      var chunk = Math.max(32\n      /* Branch */\n      , lines >> 5\n      /* BranchShift */\n      ),\n          maxChunk = chunk << 1,\n          minChunk = chunk >> 1;\n      var chunked = [],\n          currentLines = 0,\n          currentLen = -1,\n          currentChunk = [];\n\n      function add(child) {\n        var last;\n\n        if (child.lines > maxChunk && child instanceof TextNode) {\n          var _iterator7 = _createForOfIteratorHelper(child.children),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var node = _step7.value;\n              add(node);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n          flush();\n          chunked.push(child);\n        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32\n        /* Branch */\n        ) {\n          currentLines += child.lines;\n          currentLen += child.length + 1;\n          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n        } else {\n          if (currentLines + child.lines > chunk) flush();\n          currentLines += child.lines;\n          currentLen += child.length + 1;\n          currentChunk.push(child);\n        }\n      }\n\n      function flush() {\n        if (currentLines == 0) return;\n        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n        currentLen = -1;\n        currentLines = currentChunk.length = 0;\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(children),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var child = _step8.value;\n          add(child);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      flush();\n      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n  }]);\n\n  return TextNode;\n}(Text);\n\nText.empty = /*@__PURE__*/new TextLeaf([\"\"], 0);\n\nfunction textLength(text) {\n  var length = -1;\n\n  var _iterator9 = _createForOfIteratorHelper(text),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var line = _step9.value;\n      length += line.length + 1;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n\n  return length;\n}\n\nfunction appendText(text, target) {\n  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e9;\n\n  for (var pos = 0, _i11 = 0, first = true; _i11 < text.length && pos <= to; _i11++) {\n    var line = text[_i11],\n        end = pos + line.length;\n\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos);\n      if (pos < from) line = line.slice(from - pos);\n\n      if (first) {\n        target[target.length - 1] += line;\n        first = false;\n      } else target.push(line);\n    }\n\n    pos = end + 1;\n  }\n\n  return target;\n}\n\nfunction sliceText(text, from, to) {\n  return appendText(text, [\"\"], from, to);\n}\n\nvar RawTextCursor = /*#__PURE__*/function () {\n  function RawTextCursor(text) {\n    var dir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, RawTextCursor);\n\n    this.dir = dir;\n    this.done = false;\n    this.lineBreak = false;\n    this.value = \"\";\n    this.nodes = [text];\n    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];\n  }\n\n  _createClass(RawTextCursor, [{\n    key: \"nextInner\",\n    value: function nextInner(skip, dir) {\n      this.done = this.lineBreak = false;\n\n      for (;;) {\n        var last = this.nodes.length - 1;\n        var top = this.nodes[last],\n            offsetValue = this.offsets[last],\n            offset = offsetValue >> 1;\n        var size = top instanceof TextLeaf ? top.text.length : top.children.length;\n\n        if (offset == (dir > 0 ? size : 0)) {\n          if (last == 0) {\n            this.done = true;\n            this.value = \"\";\n            return this;\n          }\n\n          if (dir > 0) this.offsets[last - 1]++;\n          this.nodes.pop();\n          this.offsets.pop();\n        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {\n          this.offsets[last] += dir;\n\n          if (skip == 0) {\n            this.lineBreak = true;\n            this.value = \"\\n\";\n            return this;\n          }\n\n          skip--;\n        } else if (top instanceof TextLeaf) {\n          // Move to the next string\n          var next = top.text[offset + (dir < 0 ? -1 : 0)];\n          this.offsets[last] += dir;\n\n          if (next.length > Math.max(0, skip)) {\n            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n            return this;\n          }\n\n          skip -= next.length;\n        } else {\n          var _next = top.children[offset + (dir < 0 ? -1 : 0)];\n\n          if (skip > _next.length) {\n            skip -= _next.length;\n            this.offsets[last] += dir;\n          } else {\n            if (dir < 0) this.offsets[last]--;\n            this.nodes.push(_next);\n            this.offsets.push(dir > 0 ? 1 : (_next instanceof TextLeaf ? _next.text.length : _next.children.length) << 1);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (skip < 0) {\n        this.nextInner(-skip, -this.dir);\n        skip = this.value.length;\n      }\n\n      return this.nextInner(skip, this.dir);\n    }\n  }]);\n\n  return RawTextCursor;\n}();\n\nvar PartialTextCursor = /*#__PURE__*/function () {\n  function PartialTextCursor(text, start, end) {\n    _classCallCheck(this, PartialTextCursor);\n\n    this.value = \"\";\n    this.done = false;\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n    this.pos = start > end ? text.length : 0;\n    this.from = Math.min(start, end);\n    this.to = Math.max(start, end);\n  }\n\n  _createClass(PartialTextCursor, [{\n    key: \"nextInner\",\n    value: function nextInner(skip, dir) {\n      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {\n        this.value = \"\";\n        this.done = true;\n        return this;\n      }\n\n      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);\n      var limit = dir < 0 ? this.pos - this.from : this.to - this.pos;\n      if (skip > limit) skip = limit;\n      limit -= skip;\n\n      var _this$cursor$next = this.cursor.next(skip),\n          value = _this$cursor$next.value;\n\n      this.pos += (value.length + skip) * dir;\n      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);\n      this.done = !this.value;\n      return this;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (skip < 0) skip = Math.max(skip, this.from - this.pos);else if (skip > 0) skip = Math.min(skip, this.to - this.pos);\n      return this.nextInner(skip, this.cursor.dir);\n    }\n  }, {\n    key: \"lineBreak\",\n    get: function get() {\n      return this.cursor.lineBreak && this.value != \"\";\n    }\n  }]);\n\n  return PartialTextCursor;\n}();\n\nvar LineCursor = /*#__PURE__*/function () {\n  function LineCursor(inner) {\n    _classCallCheck(this, LineCursor);\n\n    this.inner = inner;\n    this.afterBreak = true;\n    this.value = \"\";\n    this.done = false;\n  }\n\n  _createClass(LineCursor, [{\n    key: \"next\",\n    value: function next() {\n      var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _this$inner$next = this.inner.next(skip),\n          done = _this$inner$next.done,\n          lineBreak = _this$inner$next.lineBreak,\n          value = _this$inner$next.value;\n\n      if (done) {\n        this.done = true;\n        this.value = \"\";\n      } else if (lineBreak) {\n        if (this.afterBreak) {\n          this.value = \"\";\n        } else {\n          this.afterBreak = true;\n          this.next();\n        }\n      } else {\n        this.value = value;\n        this.afterBreak = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"lineBreak\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return LineCursor;\n}();\n\nif (typeof Symbol != \"undefined\") {\n  Text.prototype[Symbol.iterator] = function () {\n    return this.iter();\n  };\n\n  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n/**\nThis type describes a line in the document. It is created\non-demand when lines are [queried](https://codemirror.net/6/docs/ref/#text.Text.lineAt).\n*/\n\n\nvar Line = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function Line(\n  /**\n  The position of the start of the line.\n  */\n  from,\n  /**\n  The position at the end of the line (_before_ the line break,\n  or at the end of document for the last line).\n  */\n  to,\n  /**\n  This line's line number (1-based).\n  */\n  number,\n  /**\n  The line's content.\n  */\n  text) {\n    _classCallCheck(this, Line);\n\n    this.from = from;\n    this.to = to;\n    this.number = number;\n    this.text = text;\n  }\n  /**\n  The length of the line (not including any line break after it).\n  */\n\n\n  _createClass(Line, [{\n    key: \"length\",\n    get: function get() {\n      return this.to - this.from;\n    }\n  }]);\n\n  return Line;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvdGV4dC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBREE7O0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7OztBQUNBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUFBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFXQTtBQUVBO0FBQ0E7Ozs7QUEzRUE7QUE4RUE7QUFDQTtBQUNBOzs7QUFDQTs7Ozs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBQUE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFEQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFPQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7OztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQUE7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUZBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQTNDQTtBQUFBOztBQUFBO0FBNENBO0FBQUE7QUFDQTtBQURBO0FBNUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBOENBO0FBQ0E7QUFDQTs7OztBQXBJQTs7QUFzSUE7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7OztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7Ozs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL3RleHQvZGlzdC9pbmRleC5qcz9iOTlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbXByZXNzZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIEdyYXBoZW1lX0NsdXN0ZXJfQnJlYWs9RXh0ZW5kXG4vLyBpbmZvcm1hdGlvbiBmcm9tXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy8xMy4wLjAvdWNkL2F1eGlsaWFyeS9HcmFwaGVtZUJyZWFrUHJvcGVydHkudHh0LlxuLy8gRWFjaCBwYWlyIG9mIGVsZW1lbnRzIHJlcHJlc2VudHMgYSByYW5nZSwgYXMgYW4gb2ZmZXQgZnJvbSB0aGVcbi8vIHByZXZpb3VzIHJhbmdlIGFuZCBhIGxlbmd0aC4gTnVtYmVycyBhcmUgaW4gYmFzZS0zNiwgd2l0aCB0aGUgZW1wdHlcbi8vIHN0cmluZyBiZWluZyBhIHNob3J0aGFuZCBmb3IgMS5cbmxldCBleHRlbmQgPSAvKkBfX1BVUkVfXyovXCJsYywzNCw3biw3LDdiLDE5LCwsLDIsLDIsLCwyMCxiLDFjLGwsZywsMnQsNywyLDYsMiwyLCw0LHosLHUsciwyaixiLDFtLDksOSwsbyw0LCw5LCwzLCw1LDE3LDMsM2IsZiwsdywxaiwsLCw0LDgsNCwsMyw3LGEsMix0LCwxbSwsLCwyLDQsOCwsOSwsYSwyLHEsLDIsMiwxbCwsNCwyLDQsMiwyLDMsMywsdSwyLDMsLGIsMiwxbCwsNCw1LCwyLDQsLGssMixtLDYsLCwxbSwsLDIsLDQsOCwsNywzLGEsMix1LCwxbiwsLCxjLCw5LCwxNCwsMywsMWwsMyw1LDMsLDQsNywyLGIsMix0LCwxbSwsMiwsMiwsMywsNSwyLDcsMixiLDIscywyLDFsLDIsLCwyLDQsOCwsOSwsYSwyLHQsLDIwLCw0LCwyLDMsLCw4LCwyOSwsMiw3LGMsOCwycSwsMiw5LGIsNiwyMiwyLHIsLCwsLCwxaixlLCw1LCwyLDUsYiwsMTAsOSwsMnUsNCwsNiwsMiwyLDIscCwyLDQsMyxnLDQsZCwsMiwyLDYsLGYsLGpqLDMscWEsMyx0LDMsdCwyLHUsMiwxcywyLCw3LDgsLDIsYiw5LCwxOSwzLDNiLDIseSwsM2EsMyw0LDIsOSwsNiwzLDYzLDIsMiwsMW0sLCw3LCwsLCwyLDgsNixhLDIsLDFjLGgsMXIsNCwxYyw3LCwsNSwsMTQsOSxjLDIsdyw0LDIsMiwsMywxaywsLDIsMywsLDMsMW0sOCwyLDIsNDgsMywsZCwsNyw0LCw2LCwzLDIsNWksMW0sLDUsZWssLDVmLHgsMmRhLDMsM3gsLDJvLHcsZmUsNiwyeCwyLG45dyw0LCxhLHcsMiwyOCwyLDdrLCwzLCw0LCxwLDIsNSwsNDcsMixxLGksZCwsMTIsOCxwLGIsMWEsMywxYywsMiw0LDIsMiwxMywsMXYsNiwyLDIsMiwyLGMsLDgsLDFiLCwxZiwsLDMsMiwyLDUsMiwsLDE2LDIsOCwsNm0sLDIsLDQsLGZuNCwsa2gsZyxnLGcsYTYsMixndCwsNmEsLDQ1LDUsMWFlLDMsLDIsNSw0LDE0LDMsNCwsNGwsMixmeCw0LGFyLDIsNDksYiw0dywsMWksZiwxaywzLDFkLDQsMiwyLDF4LDMsMTAsNSwsOCwxcSwsYywyLDFnLDksYSw0LDIsLDJuLDMsMiwsLDIsNiwsNGcsLDMsOCxsLDIsMWwsMiwsLCwsbSwsZSw3LDMsNSw1Ziw4LDIsMywsLG4sLDI5LCwyLDYsLCwyLCwsMiwsMiw2aiwsMiw0LDYsMiwsMixyLDIsMmQsOCwyLCwsMiwyeSwsLCwyLDYsLCwydCwzLDIsNCwsNSw3Nyw5LCwyLDZ0LCxhLDIsLCw0LCw0MCw0LDIsMiw0LCx3LGEsMTQsNiwyLDQsOCwsOSw2LDIsMywxYSxkLCwyLGJhLDcsLDYsLCwyYSxtLDIsNywsMiwsMiwzZSw2LDMsLCwyLCw3LCwsMjAsMiwzLCwsLDluLDIsZjBiLDUsMW4sNyx0NCwsMXIsNCwyOSwsZjVrLDIsNDNxLCwsMyw0LDUsOCw4LDIsNyx1LDQsNDQsMywxaXosMWosNCwxZSw4LCxlLCxtLDUsLGYsMTFzLDcsLGgsMiw3LCwyLCw1LDc5LDcsYzUsNCwxNXMsNywzMSw3LDI0MCw1LGd4N2ssMm8sM2ssNm9cIi5zcGxpdChcIixcIikubWFwKHMgPT4gcyA/IHBhcnNlSW50KHMsIDM2KSA6IDEpO1xuLy8gQ29udmVydCBvZmZzZXRzIGludG8gYWJzb2x1dGUgdmFsdWVzXG5mb3IgKGxldCBpID0gMTsgaSA8IGV4dGVuZC5sZW5ndGg7IGkrKylcbiAgICBleHRlbmRbaV0gKz0gZXh0ZW5kW2kgLSAxXTtcbmZ1bmN0aW9uIGlzRXh0ZW5kaW5nQ2hhcihjb2RlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHRlbmQubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIGlmIChleHRlbmRbaV0gPiBjb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuZFtpIC0gMV0gPD0gY29kZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1JlZ2lvbmFsSW5kaWNhdG9yKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweDFGMUU2ICYmIGNvZGUgPD0gMHgxRjFGRjtcbn1cbmNvbnN0IFpXSiA9IDB4MjAwZDtcbi8qKlxuUmV0dXJucyBhIG5leHQgZ3JhcGhlbWUgY2x1c3RlciBicmVhayBfYWZ0ZXJfIChub3QgZXF1YWwgdG8pXG5gcG9zYCwgaWYgYGZvcndhcmRgIGlzIHRydWUsIG9yIGJlZm9yZSBvdGhlcndpc2UuIFJldHVybnMgYHBvc2Bcbml0c2VsZiBpZiBubyBmdXJ0aGVyIGNsdXN0ZXIgYnJlYWsgaXMgYXZhaWxhYmxlIGluIHRoZSBzdHJpbmcuXG5Nb3ZlcyBhY3Jvc3Mgc3Vycm9nYXRlIHBhaXJzLCBleHRlbmRpbmcgY2hhcmFjdGVycyAod2hlblxuYGluY2x1ZGVFeHRlbmRpbmdgIGlzIHRydWUpLCBjaGFyYWN0ZXJzIGpvaW5lZCB3aXRoIHplcm8td2lkdGhcbmpvaW5lcnMsIGFuZCBmbGFnIGVtb2ppLlxuKi9cbmZ1bmN0aW9uIGZpbmRDbHVzdGVyQnJlYWsoc3RyLCBwb3MsIGZvcndhcmQgPSB0cnVlLCBpbmNsdWRlRXh0ZW5kaW5nID0gdHJ1ZSkge1xuICAgIHJldHVybiAoZm9yd2FyZCA/IG5leHRDbHVzdGVyQnJlYWsgOiBwcmV2Q2x1c3RlckJyZWFrKShzdHIsIHBvcywgaW5jbHVkZUV4dGVuZGluZyk7XG59XG5mdW5jdGlvbiBuZXh0Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgaWYgKHBvcyA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIC8vIElmIHBvcyBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgc3Vycm9nYXRlIHBhaXIsIG1vdmUgdG8gaXRzIHN0YXJ0XG4gICAgaWYgKHBvcyAmJiBzdXJyb2dhdGVMb3coc3RyLmNoYXJDb2RlQXQocG9zKSkgJiYgc3Vycm9nYXRlSGlnaChzdHIuY2hhckNvZGVBdChwb3MgLSAxKSkpXG4gICAgICAgIHBvcy0tO1xuICAgIGxldCBwcmV2ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKHByZXYpO1xuICAgIHdoaWxlIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBuZXh0ID0gY29kZVBvaW50QXQoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocHJldiA9PSBaV0ogfHwgbmV4dCA9PSBaV0ogfHwgaW5jbHVkZUV4dGVuZGluZyAmJiBpc0V4dGVuZGluZ0NoYXIobmV4dCkpIHtcbiAgICAgICAgICAgIHBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgcHJldiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdpb25hbEluZGljYXRvcihuZXh0KSkge1xuICAgICAgICAgICAgbGV0IGNvdW50QmVmb3JlID0gMCwgaSA9IHBvcyAtIDI7XG4gICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGlzUmVnaW9uYWxJbmRpY2F0b3IoY29kZVBvaW50QXQoc3RyLCBpKSkpIHtcbiAgICAgICAgICAgICAgICBjb3VudEJlZm9yZSsrO1xuICAgICAgICAgICAgICAgIGkgLT0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudEJlZm9yZSAlIDIgPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5mdW5jdGlvbiBwcmV2Q2x1c3RlckJyZWFrKHN0ciwgcG9zLCBpbmNsdWRlRXh0ZW5kaW5nKSB7XG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgICAgbGV0IGZvdW5kID0gbmV4dENsdXN0ZXJCcmVhayhzdHIsIHBvcyAtIDIsIGluY2x1ZGVFeHRlbmRpbmcpO1xuICAgICAgICBpZiAoZm91bmQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIHBvcy0tO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHN1cnJvZ2F0ZUxvdyhjaCkgeyByZXR1cm4gY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhFMDAwOyB9XG5mdW5jdGlvbiBzdXJyb2dhdGVIaWdoKGNoKSB7IHJldHVybiBjaCA+PSAweEQ4MDAgJiYgY2ggPCAweERDMDA7IH1cbi8qKlxuRmluZCB0aGUgY29kZSBwb2ludCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gYSBzdHJpbmcgKGxpa2UgdGhlXG5bYGNvZGVQb2ludEF0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2NvZGVQb2ludEF0KVxuc3RyaW5nIG1ldGhvZCkuXG4qL1xuZnVuY3Rpb24gY29kZVBvaW50QXQoc3RyLCBwb3MpIHtcbiAgICBsZXQgY29kZTAgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghc3Vycm9nYXRlSGlnaChjb2RlMCkgfHwgcG9zICsgMSA9PSBzdHIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgbGV0IGNvZGUxID0gc3RyLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKCFzdXJyb2dhdGVMb3coY29kZTEpKVxuICAgICAgICByZXR1cm4gY29kZTA7XG4gICAgcmV0dXJuICgoY29kZTAgLSAweGQ4MDApIDw8IDEwKSArIChjb2RlMSAtIDB4ZGMwMCkgKyAweDEwMDAwO1xufVxuLyoqXG5HaXZlbiBhIFVuaWNvZGUgY29kZXBvaW50LCByZXR1cm4gdGhlIEphdmFTY3JpcHQgc3RyaW5nIHRoYXRcbnJlc3ByZXNlbnRzIGl0IChsaWtlXG5bYFN0cmluZy5mcm9tQ29kZVBvaW50YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2Zyb21Db2RlUG9pbnQpKS5cbiovXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGNvZGUpIHtcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvZGUgLT0gMHgxMDAwMDtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweGQ4MDAsIChjb2RlICYgMTAyMykgKyAweGRjMDApO1xufVxuLyoqXG5UaGUgZmlyc3QgY2hhcmFjdGVyIHRoYXQgdGFrZXMgdXAgdHdvIHBvc2l0aW9ucyBpbiBhIEphdmFTY3JpcHRcbnN0cmluZy4gSXQgaXMgb2Z0ZW4gdXNlZnVsIHRvIGNvbXBhcmUgd2l0aCB0aGlzIGFmdGVyIGNhbGxpbmdcbmBjb2RlUG9pbnRBdGAsIHRvIGZpZ3VyZSBvdXQgd2hldGhlciB5b3VyIGNoYXJhY3RlciB0YWtlcyB1cCAxIG9yXG4yIGluZGV4IHBvc2l0aW9ucy5cbiovXG5mdW5jdGlvbiBjb2RlUG9pbnRTaXplKGNvZGUpIHsgcmV0dXJuIGNvZGUgPCAweDEwMDAwID8gMSA6IDI7IH1cblxuLyoqXG5Db3VudCB0aGUgY29sdW1uIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQgaW50byB0aGUgc3RyaW5nLFxudGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuXG4qL1xuZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCB0YWJTaXplLCB0byA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bzspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpIHtcbiAgICAgICAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgICAgICBpID0gZmluZENsdXN0ZXJCcmVhayhzdHJpbmcsIGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5GaW5kIHRoZSBvZmZzZXQgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gY29sdW1uIHBvc2l0aW9uIGluIGFcbnN0cmluZywgdGFraW5nIGV4dGVuZGluZyBjaGFyYWN0ZXJzIGFuZCB0YWIgc2l6ZSBpbnRvIGFjY291bnQuIEJ5XG5kZWZhdWx0LCB0aGUgc3RyaW5nIGxlbmd0aCBpcyByZXR1cm5lZCB3aGVuIGl0IGlzIHRvbyBzaG9ydCB0b1xucmVhY2ggdGhlIGNvbHVtbi4gUGFzcyBgc3RyaWN0YCB0cnVlIHRvIG1ha2UgaXQgcmV0dXJuIC0xIGluIHRoYXRcbnNpdHVhdGlvbi5cbiovXG5mdW5jdGlvbiBmaW5kQ29sdW1uKHN0cmluZywgY29sLCB0YWJTaXplLCBzdHJpY3QpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IDA7Oykge1xuICAgICAgICBpZiAobiA+PSBjb2wpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKGkgPT0gc3RyaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkgPyB0YWJTaXplIC0gKG4gJSB0YWJTaXplKSA6IDE7XG4gICAgICAgIGkgPSBmaW5kQ2x1c3RlckJyZWFrKHN0cmluZywgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpY3QgPT09IHRydWUgPyAtMSA6IHN0cmluZy5sZW5ndGg7XG59XG5cbi8qKlxuVGhlIGRhdGEgc3RydWN0dXJlIGZvciBkb2N1bWVudHMuXG4qL1xuY2xhc3MgVGV4dCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbGluZSBkZXNjcmlwdGlvbiBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbGluZUF0KHBvcykge1xuICAgICAgICBpZiAocG9zIDwgMCB8fCBwb3MgPiB0aGlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHBvc2l0aW9uICR7cG9zfSBpbiBkb2N1bWVudCBvZiBsZW5ndGggJHt0aGlzLmxlbmd0aH1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZUlubmVyKHBvcywgZmFsc2UsIDEsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gKDEtYmFzZWQpIGxpbmUgbnVtYmVyLlxuICAgICovXG4gICAgbGluZShuKSB7XG4gICAgICAgIGlmIChuIDwgMSB8fCBuID4gdGhpcy5saW5lcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGxpbmUgbnVtYmVyICR7bn0gaW4gJHt0aGlzLmxpbmVzfS1saW5lIGRvY3VtZW50YCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihuLCB0cnVlLCAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSB0ZXh0IHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZSgwLCBmcm9tLCBwYXJ0cywgMiAvKiBUbyAqLyk7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRleHQuZGVjb21wb3NlKDAsIHRleHQubGVuZ3RoLCBwYXJ0cywgMSAvKiBGcm9tICovIHwgMiAvKiBUbyAqLyk7XG4gICAgICAgIHRoaXMuZGVjb21wb3NlKHRvLCB0aGlzLmxlbmd0aCwgcGFydHMsIDEgLyogRnJvbSAqLyk7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKHBhcnRzLCB0aGlzLmxlbmd0aCAtICh0byAtIGZyb20pICsgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgYW5vdGhlciBkb2N1bWVudCB0byB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKHRoaXMubGVuZ3RoLCB0aGlzLmxlbmd0aCwgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXRyaWV2ZSB0aGUgdGV4dCBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludHMuXG4gICAgKi9cbiAgICBzbGljZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29tcG9zZShmcm9tLCB0bywgcGFydHMsIDApO1xuICAgICAgICByZXR1cm4gVGV4dE5vZGUuZnJvbShwYXJ0cywgdG8gLSBmcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgdGV4dCBpcyBlcXVhbCB0byBhbm90aGVyIGluc3RhbmNlLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCAhPSB0aGlzLmxlbmd0aCB8fCBvdGhlci5saW5lcyAhPSB0aGlzLmxpbmVzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnNjYW5JZGVudGljYWwob3RoZXIsIDEpLCBlbmQgPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2NhbklkZW50aWNhbChvdGhlciwgLTEpO1xuICAgICAgICBsZXQgYSA9IG5ldyBSYXdUZXh0Q3Vyc29yKHRoaXMpLCBiID0gbmV3IFJhd1RleHRDdXJzb3Iob3RoZXIpO1xuICAgICAgICBmb3IgKGxldCBza2lwID0gc3RhcnQsIHBvcyA9IHN0YXJ0OzspIHtcbiAgICAgICAgICAgIGEubmV4dChza2lwKTtcbiAgICAgICAgICAgIGIubmV4dChza2lwKTtcbiAgICAgICAgICAgIHNraXAgPSAwO1xuICAgICAgICAgICAgaWYgKGEubGluZUJyZWFrICE9IGIubGluZUJyZWFrIHx8IGEuZG9uZSAhPSBiLmRvbmUgfHwgYS52YWx1ZSAhPSBiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHBvcyArPSBhLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChhLmRvbmUgfHwgcG9zID49IGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIHRleHQuIFdoZW4gYGRpcmAgaXMgYC0xYCwgaXRlcmF0aW9uIGhhcHBlbnNcbiAgICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gICAgdGhlbSBhcyBzZXBhcmF0ZSBzdHJpbmdzLCBhbmQgZm9yIGxvbmcgbGluZXMsIG1pZ2h0IHNwbGl0IGxpbmVzXG4gICAgdGhlbXNlbHZlcyBpbnRvIG11bHRpcGxlIGNodW5rcyBhcyB3ZWxsLlxuICAgICovXG4gICAgaXRlcihkaXIgPSAxKSB7IHJldHVybiBuZXcgUmF3VGV4dEN1cnNvcih0aGlzLCBkaXIpOyB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2YgdGhlIHRleHQuIFdoZW4gYGZyb21gID4gYHRvYCwgdGhlXG4gICAgaXRlcmF0b3Igd2lsbCBydW4gaW4gcmV2ZXJzZS5cbiAgICAqL1xuICAgIGl0ZXJSYW5nZShmcm9tLCB0byA9IHRoaXMubGVuZ3RoKSB7IHJldHVybiBuZXcgUGFydGlhbFRleHRDdXJzb3IodGhpcywgZnJvbSwgdG8pOyB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gICAgX3dpdGhvdXRfIHJldHVybmluZyB0aGUgbGluZSBicmVha3MgYmV0d2VlbiwgYW5kIHlpZWxkaW5nIGVtcHR5XG4gICAgc3RyaW5ncyBmb3IgZW1wdHkgbGluZXMuXG4gICAgXG4gICAgV2hlbiBgZnJvbWAgYW5kIGB0b2AgYXJlIGdpdmVuLCB0aGV5IHNob3VsZCBiZSAxLWJhc2VkIGxpbmUgbnVtYmVycy5cbiAgICAqL1xuICAgIGl0ZXJMaW5lcyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgaW5uZXI7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIGlubmVyID0gdGhpcy5pdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IHRoaXMubGluZXMgKyAxO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5saW5lKGZyb20pLmZyb207XG4gICAgICAgICAgICBpbm5lciA9IHRoaXMuaXRlclJhbmdlKHN0YXJ0LCBNYXRoLm1heChzdGFydCwgdG8gPT0gdGhpcy5saW5lcyArIDEgPyB0aGlzLmxlbmd0aCA6IHRvIDw9IDEgPyAwIDogdGhpcy5saW5lKHRvIC0gMSkudG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVDdXJzb3IoaW5uZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTsgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhlIGRvY3VtZW50IHRvIGFuIGFycmF5IG9mIGxpbmVzICh3aGljaCBjYW4gYmVcbiAgICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdGV4dC5UZXh0Xm9mKSkuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmZsYXR0ZW4obGluZXMpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGBUZXh0YCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzLlxuICAgICovXG4gICAgc3RhdGljIG9mKHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgZG9jdW1lbnQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsaW5lXCIpO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPT0gMSAmJiAhdGV4dFswXSlcbiAgICAgICAgICAgIHJldHVybiBUZXh0LmVtcHR5O1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPD0gMzIgLyogQnJhbmNoICovID8gbmV3IFRleHRMZWFmKHRleHQpIDogVGV4dE5vZGUuZnJvbShUZXh0TGVhZi5zcGxpdCh0ZXh0LCBbXSkpO1xuICAgIH1cbn1cbi8vIExlYXZlcyBzdG9yZSBhbiBhcnJheSBvZiBsaW5lIHN0cmluZ3MuIFRoZXJlIGFyZSBhbHdheXMgbGluZSBicmVha3Ncbi8vIGJldHdlZW4gdGhlc2Ugc3RyaW5ncy4gTGVhdmVzIGFyZSBsaW1pdGVkIGluIHNpemUgYW5kIGhhdmUgdG8gYmVcbi8vIGNvbnRhaW5lZCBpbiBUZXh0Tm9kZSBpbnN0YW5jZXMgZm9yIGJpZ2dlciBkb2N1bWVudHMuXG5jbGFzcyBUZXh0TGVhZiBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIGxlbmd0aCA9IHRleHRMZW5ndGgodGV4dCkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgfVxuICAgIGdldCBsaW5lcygpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmcgPSB0aGlzLnRleHRbaV0sIGVuZCA9IG9mZnNldCArIHN0cmluZy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGxpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpbmUob2Zmc2V0LCBlbmQsIGxpbmUsIHN0cmluZyk7XG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQgKyAxO1xuICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29tcG9zZShmcm9tLCB0bywgdGFyZ2V0LCBvcGVuKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gZnJvbSA8PSAwICYmIHRvID49IHRoaXMubGVuZ3RoID8gdGhpc1xuICAgICAgICAgICAgOiBuZXcgVGV4dExlYWYoc2xpY2VUZXh0KHRoaXMudGV4dCwgZnJvbSwgdG8pLCBNYXRoLm1pbih0bywgdGhpcy5sZW5ndGgpIC0gTWF0aC5tYXgoMCwgZnJvbSkpO1xuICAgICAgICBpZiAob3BlbiAmIDEgLyogRnJvbSAqLykge1xuICAgICAgICAgICAgbGV0IHByZXYgPSB0YXJnZXQucG9wKCk7XG4gICAgICAgICAgICBsZXQgam9pbmVkID0gYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHByZXYudGV4dC5zbGljZSgpLCAwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoam9pbmVkLmxlbmd0aCA8PSAzMiAvKiBCcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYoam9pbmVkLCBwcmV2Lmxlbmd0aCArIHRleHQubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWlkID0gam9pbmVkLmxlbmd0aCA+PiAxO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihqb2luZWQuc2xpY2UoMCwgbWlkKSksIG5ldyBUZXh0TGVhZihqb2luZWQuc2xpY2UobWlkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2godGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICBpZiAoISh0ZXh0IGluc3RhbmNlb2YgVGV4dExlYWYpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZnJvbSwgdG8sIHRleHQpO1xuICAgICAgICBsZXQgbGluZXMgPSBhcHBlbmRUZXh0KHRoaXMudGV4dCwgYXBwZW5kVGV4dCh0ZXh0LnRleHQsIHNsaWNlVGV4dCh0aGlzLnRleHQsIDAsIGZyb20pKSwgdG8pO1xuICAgICAgICBsZXQgbmV3TGVuID0gdGhpcy5sZW5ndGggKyB0ZXh0Lmxlbmd0aCAtICh0byAtIGZyb20pO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IDMyIC8qIEJyYW5jaCAqLylcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYobGluZXMsIG5ld0xlbik7XG4gICAgICAgIHJldHVybiBUZXh0Tm9kZS5mcm9tKFRleHRMZWFmLnNwbGl0KGxpbmVzLCBbXSksIG5ld0xlbik7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLnRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGhpcy50ZXh0W2ldLCBlbmQgPSBwb3MgKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPiBmcm9tICYmIGkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmVTZXA7XG4gICAgICAgICAgICBpZiAoZnJvbSA8IGVuZCAmJiB0byA+IHBvcylcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZS5zbGljZShNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmbGF0dGVuKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudGV4dClcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKGxpbmUpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpY2FsKCkgeyByZXR1cm4gMDsgfVxuICAgIHN0YXRpYyBzcGxpdCh0ZXh0LCB0YXJnZXQpIHtcbiAgICAgICAgbGV0IHBhcnQgPSBbXSwgbGVuID0gLTE7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGV4dCkge1xuICAgICAgICAgICAgcGFydC5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgbGVuICs9IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PSAzMiAvKiBCcmFuY2ggKi8pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChuZXcgVGV4dExlYWYocGFydCwgbGVuKSk7XG4gICAgICAgICAgICAgICAgcGFydCA9IFtdO1xuICAgICAgICAgICAgICAgIGxlbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAtMSlcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5ldyBUZXh0TGVhZihwYXJ0LCBsZW4pKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG4vLyBOb2RlcyBwcm92aWRlIHRoZSB0cmVlIHN0cnVjdHVyZSBvZiB0aGUgYFRleHRgIHR5cGUuIFRoZXkgc3RvcmUgYVxuLy8gbnVtYmVyIG9mIG90aGVyIG5vZGVzIG9yIGxlYXZlcywgdGFraW5nIGNhcmUgdG8gYmFsYW5jZSB0aGVtc2VsdmVzXG4vLyBvbiBjaGFuZ2VzLiBUaGVyZSBhcmUgaW1wbGllZCBsaW5lIGJyZWFrcyBfYmV0d2Vlbl8gdGhlIGNoaWxkcmVuIG9mXG4vLyBhIG5vZGUgKGJ1dCBub3QgYmVmb3JlIHRoZSBmaXJzdCBvciBhZnRlciB0aGUgbGFzdCBjaGlsZCkuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRleHQge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuLCBsZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5saW5lcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuKVxuICAgICAgICAgICAgdGhpcy5saW5lcyArPSBjaGlsZC5saW5lcztcbiAgICB9XG4gICAgbGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLmxlbmd0aCwgZW5kTGluZSA9IGxpbmUgKyBjaGlsZC5saW5lcyAtIDE7XG4gICAgICAgICAgICBpZiAoKGlzTGluZSA/IGVuZExpbmUgOiBlbmQpID49IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubGluZUlubmVyKHRhcmdldCwgaXNMaW5lLCBsaW5lLCBvZmZzZXQpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kICsgMTtcbiAgICAgICAgICAgIGxpbmUgPSBlbmRMaW5lICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNvbXBvc2UoZnJvbSwgdG8sIHRhcmdldCwgb3Blbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDw9IHRvICYmIGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZnJvbSA8PSBlbmQgJiYgdG8gPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkT3BlbiA9IG9wZW4gJiAoKHBvcyA8PSBmcm9tID8gMSAvKiBGcm9tICovIDogMCkgfCAoZW5kID49IHRvID8gMiAvKiBUbyAqLyA6IDApKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGZyb20gJiYgZW5kIDw9IHRvICYmICFjaGlsZE9wZW4pXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlY29tcG9zZShmcm9tIC0gcG9zLCB0byAtIHBvcywgdGFyZ2V0LCBjaGlsZE9wZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0LmxpbmVzIDwgdGhpcy5saW5lcylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGg6IGlmIHRoZSBjaGFuZ2Ugb25seSBhZmZlY3RzIG9uZSBjaGlsZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQncyBzaXplIHJlbWFpbnMgaW4gdGhlIGFjY2VwdGFibGUgcmFuZ2UsIG9ubHkgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjaGlsZFxuICAgICAgICAgICAgICAgIGlmIChmcm9tID49IHBvcyAmJiB0byA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVwZGF0ZWQgPSBjaGlsZC5yZXBsYWNlKGZyb20gLSBwb3MsIHRvIC0gcG9zLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsTGluZXMgPSB0aGlzLmxpbmVzIC0gY2hpbGQubGluZXMgKyB1cGRhdGVkLmxpbmVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5saW5lcyA8ICh0b3RhbExpbmVzID4+ICg1IC8qIEJyYW5jaFNoaWZ0ICovIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmxpbmVzID4gKHRvdGFsTGluZXMgPj4gKDUgLyogQnJhbmNoU2hpZnQgKi8gKyAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb3B5ID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weVtpXSA9IHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKGNvcHksIHRoaXMubGVuZ3RoIC0gKHRvIC0gZnJvbSkgKyB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocG9zLCBlbmQsIHVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShmcm9tLCB0bywgdGV4dCk7XG4gICAgfVxuICAgIHNsaWNlU3RyaW5nKGZyb20sIHRvID0gdGhpcy5sZW5ndGgsIGxpbmVTZXAgPSBcIlxcblwiKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gZnJvbSAmJiBpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lU2VwO1xuICAgICAgICAgICAgaWYgKGZyb20gPCBlbmQgJiYgdG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoaWxkLnNsaWNlU3RyaW5nKGZyb20gLSBwb3MsIHRvIC0gcG9zLCBsaW5lU2VwKTtcbiAgICAgICAgICAgIHBvcyA9IGVuZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZmxhdHRlbih0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgICAgIGNoaWxkLmZsYXR0ZW4odGFyZ2V0KTtcbiAgICB9XG4gICAgc2NhbklkZW50aWNhbChvdGhlciwgZGlyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVGV4dE5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICBsZXQgW2lBLCBpQiwgZUEsIGVCXSA9IGRpciA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIG90aGVyLmNoaWxkcmVuLmxlbmd0aF1cbiAgICAgICAgICAgIDogW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgb3RoZXIuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICAgICAgZm9yICg7OyBpQSArPSBkaXIsIGlCICs9IGRpcikge1xuICAgICAgICAgICAgaWYgKGlBID09IGVBIHx8IGlCID09IGVCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hBID0gdGhpcy5jaGlsZHJlbltpQV0sIGNoQiA9IG90aGVyLmNoaWxkcmVuW2lCXTtcbiAgICAgICAgICAgIGlmIChjaEEgIT0gY2hCKVxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggKyBjaEEuc2NhbklkZW50aWNhbChjaEIsIGRpcik7XG4gICAgICAgICAgICBsZW5ndGggKz0gY2hBLmxlbmd0aCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb20oY2hpbGRyZW4sIGxlbmd0aCA9IGNoaWxkcmVuLnJlZHVjZSgobCwgY2gpID0+IGwgKyBjaC5sZW5ndGggKyAxLCAtMSkpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBsaW5lcyArPSBjaC5saW5lcztcbiAgICAgICAgaWYgKGxpbmVzIDwgMzIgLyogQnJhbmNoICovKSB7XG4gICAgICAgICAgICBsZXQgZmxhdCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2guZmxhdHRlbihmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dExlYWYoZmxhdCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2h1bmsgPSBNYXRoLm1heCgzMiAvKiBCcmFuY2ggKi8sIGxpbmVzID4+IDUgLyogQnJhbmNoU2hpZnQgKi8pLCBtYXhDaHVuayA9IGNodW5rIDw8IDEsIG1pbkNodW5rID0gY2h1bmsgPj4gMTtcbiAgICAgICAgbGV0IGNodW5rZWQgPSBbXSwgY3VycmVudExpbmVzID0gMCwgY3VycmVudExlbiA9IC0xLCBjdXJyZW50Q2h1bmsgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKGNoaWxkKSB7XG4gICAgICAgICAgICBsZXQgbGFzdDtcbiAgICAgICAgICAgIGlmIChjaGlsZC5saW5lcyA+IG1heENodW5rICYmIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlIG9mIGNoaWxkLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBhZGQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5saW5lcyA+IG1pbkNodW5rICYmIChjdXJyZW50TGluZXMgPiBtaW5DaHVuayB8fCAhY3VycmVudExpbmVzKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dExlYWYgJiYgY3VycmVudExpbmVzICYmXG4gICAgICAgICAgICAgICAgKGxhc3QgPSBjdXJyZW50Q2h1bmtbY3VycmVudENodW5rLmxlbmd0aCAtIDFdKSBpbnN0YW5jZW9mIFRleHRMZWFmICYmXG4gICAgICAgICAgICAgICAgY2hpbGQubGluZXMgKyBsYXN0LmxpbmVzIDw9IDMyIC8qIEJyYW5jaCAqLykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMaW5lcyArPSBjaGlsZC5saW5lcztcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuICs9IGNoaWxkLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rW2N1cnJlbnRDaHVuay5sZW5ndGggLSAxXSA9IG5ldyBUZXh0TGVhZihsYXN0LnRleHQuY29uY2F0KGNoaWxkLnRleHQpLCBsYXN0Lmxlbmd0aCArIDEgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lcyArIGNoaWxkLmxpbmVzID4gY2h1bmspXG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudExpbmVzICs9IGNoaWxkLmxpbmVzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW4gKz0gY2hpbGQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2h1bmsucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmVzID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2h1bmtlZC5wdXNoKGN1cnJlbnRDaHVuay5sZW5ndGggPT0gMSA/IGN1cnJlbnRDaHVua1swXSA6IFRleHROb2RlLmZyb20oY3VycmVudENodW5rLCBjdXJyZW50TGVuKSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuID0gLTE7XG4gICAgICAgICAgICBjdXJyZW50TGluZXMgPSBjdXJyZW50Q2h1bmsubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbilcbiAgICAgICAgICAgIGFkZChjaGlsZCk7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICAgIHJldHVybiBjaHVua2VkLmxlbmd0aCA9PSAxID8gY2h1bmtlZFswXSA6IG5ldyBUZXh0Tm9kZShjaHVua2VkLCBsZW5ndGgpO1xuICAgIH1cbn1cblRleHQuZW1wdHkgPSAvKkBfX1BVUkVfXyovbmV3IFRleHRMZWFmKFtcIlwiXSwgMCk7XG5mdW5jdGlvbiB0ZXh0TGVuZ3RoKHRleHQpIHtcbiAgICBsZXQgbGVuZ3RoID0gLTE7XG4gICAgZm9yIChsZXQgbGluZSBvZiB0ZXh0KVxuICAgICAgICBsZW5ndGggKz0gbGluZS5sZW5ndGggKyAxO1xuICAgIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRleHQsIHRhcmdldCwgZnJvbSA9IDAsIHRvID0gMWU5KSB7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDAsIGZpcnN0ID0gdHJ1ZTsgaSA8IHRleHQubGVuZ3RoICYmIHBvcyA8PSB0bzsgaSsrKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGV4dFtpXSwgZW5kID0gcG9zICsgbGluZS5sZW5ndGg7XG4gICAgICAgIGlmIChlbmQgPj0gZnJvbSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHRvIC0gcG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tKVxuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGZyb20gLSBwb3MpO1xuICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3RhcmdldC5sZW5ndGggLSAxXSArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHNsaWNlVGV4dCh0ZXh0LCBmcm9tLCB0bykge1xuICAgIHJldHVybiBhcHBlbmRUZXh0KHRleHQsIFtcIlwiXSwgZnJvbSwgdG8pO1xufVxuY2xhc3MgUmF3VGV4dEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgZGlyID0gMSkge1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5vZGVzID0gW3RleHRdO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBbZGlyID4gMCA/IDEgOiAodGV4dCBpbnN0YW5jZW9mIFRleHRMZWFmID8gdGV4dC50ZXh0Lmxlbmd0aCA6IHRleHQuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxXTtcbiAgICB9XG4gICAgbmV4dElubmVyKHNraXAsIGRpcikge1xuICAgICAgICB0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9IGZhbHNlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCB0b3AgPSB0aGlzLm5vZGVzW2xhc3RdLCBvZmZzZXRWYWx1ZSA9IHRoaXMub2Zmc2V0c1tsYXN0XSwgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgPj4gMTtcbiAgICAgICAgICAgIGxldCBzaXplID0gdG9wIGluc3RhbmNlb2YgVGV4dExlYWYgPyB0b3AudGV4dC5sZW5ndGggOiB0b3AuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSAoZGlyID4gMCA/IHNpemUgOiAwKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3QgLSAxXSsrO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKG9mZnNldFZhbHVlICYgMSkgPT0gKGRpciA+IDAgPyAwIDogMSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIGlmIChza2lwID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNraXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvcCBpbnN0YW5jZW9mIFRleHRMZWFmKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRvcC50ZXh0W29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRzW2xhc3RdICs9IGRpcjtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPiBNYXRoLm1heCgwLCBza2lwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gc2tpcCA9PSAwID8gbmV4dCA6IGRpciA+IDAgPyBuZXh0LnNsaWNlKHNraXApIDogbmV4dC5zbGljZSgwLCBuZXh0Lmxlbmd0aCAtIHNraXApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2tpcCAtPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW29mZnNldCArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICAgICAgaWYgKHNraXAgPiBuZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwIC09IG5leHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0gKz0gZGlyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHNbbGFzdF0tLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZnNldHMucHVzaChkaXIgPiAwID8gMSA6IChuZXh0IGluc3RhbmNlb2YgVGV4dExlYWYgPyBuZXh0LnRleHQubGVuZ3RoIDogbmV4dC5jaGlsZHJlbi5sZW5ndGgpIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5uZXIoLXNraXAsICgtdGhpcy5kaXIpKTtcbiAgICAgICAgICAgIHNraXAgPSB0aGlzLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW5uZXIoc2tpcCwgdGhpcy5kaXIpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnRpYWxUZXh0Q3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBuZXcgUmF3VGV4dEN1cnNvcih0ZXh0LCBzdGFydCA+IGVuZCA/IC0xIDogMSk7XG4gICAgICAgIHRoaXMucG9zID0gc3RhcnQgPiBlbmQgPyB0ZXh0Lmxlbmd0aCA6IDA7XG4gICAgICAgIHRoaXMuZnJvbSA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICAgICAgICB0aGlzLnRvID0gTWF0aC5tYXgoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIG5leHRJbm5lcihza2lwLCBkaXIpIHtcbiAgICAgICAgaWYgKGRpciA8IDAgPyB0aGlzLnBvcyA8PSB0aGlzLmZyb20gOiB0aGlzLnBvcyA+PSB0aGlzLnRvKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBza2lwICs9IE1hdGgubWF4KDAsIGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMudG8gOiB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGxldCBsaW1pdCA9IGRpciA8IDAgPyB0aGlzLnBvcyAtIHRoaXMuZnJvbSA6IHRoaXMudG8gLSB0aGlzLnBvcztcbiAgICAgICAgaWYgKHNraXAgPiBsaW1pdClcbiAgICAgICAgICAgIHNraXAgPSBsaW1pdDtcbiAgICAgICAgbGltaXQgLT0gc2tpcDtcbiAgICAgICAgbGV0IHsgdmFsdWUgfSA9IHRoaXMuY3Vyc29yLm5leHQoc2tpcCk7XG4gICAgICAgIHRoaXMucG9zICs9ICh2YWx1ZS5sZW5ndGggKyBza2lwKSAqIGRpcjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlLmxlbmd0aCA8PSBsaW1pdCA/IHZhbHVlIDogZGlyIDwgMCA/IHZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIGxpbWl0KSA6IHZhbHVlLnNsaWNlKDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5kb25lID0gIXRoaXMudmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXh0KHNraXAgPSAwKSB7XG4gICAgICAgIGlmIChza2lwIDwgMClcbiAgICAgICAgICAgIHNraXAgPSBNYXRoLm1heChza2lwLCB0aGlzLmZyb20gLSB0aGlzLnBvcyk7XG4gICAgICAgIGVsc2UgaWYgKHNraXAgPiAwKVxuICAgICAgICAgICAgc2tpcCA9IE1hdGgubWluKHNraXAsIHRoaXMudG8gLSB0aGlzLnBvcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbm5lcihza2lwLCB0aGlzLmN1cnNvci5kaXIpO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gdGhpcy5jdXJzb3IubGluZUJyZWFrICYmIHRoaXMudmFsdWUgIT0gXCJcIjsgfVxufVxuY2xhc3MgTGluZUN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoaW5uZXIpIHtcbiAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyO1xuICAgICAgICB0aGlzLmFmdGVyQnJlYWsgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgfVxuICAgIG5leHQoc2tpcCA9IDApIHtcbiAgICAgICAgbGV0IHsgZG9uZSwgbGluZUJyZWFrLCB2YWx1ZSB9ID0gdGhpcy5pbm5lci5uZXh0KHNraXApO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVCcmVhaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWZ0ZXJCcmVhaykge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZnRlckJyZWFrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCcmVhayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQgbGluZUJyZWFrKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBUZXh0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5pdGVyKCk7IH07XG4gICAgUmF3VGV4dEN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFBhcnRpYWxUZXh0Q3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgTGluZUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG59XG4vKipcblRoaXMgdHlwZSBkZXNjcmliZXMgYSBsaW5lIGluIHRoZSBkb2N1bWVudC4gSXQgaXMgY3JlYXRlZFxub24tZGVtYW5kIHdoZW4gbGluZXMgYXJlIFtxdWVyaWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3RleHQuVGV4dC5saW5lQXQpLlxuKi9cbmNsYXNzIExpbmUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIChfYmVmb3JlXyB0aGUgbGluZSBicmVhayxcbiAgICBvciBhdCB0aGUgZW5kIG9mIGRvY3VtZW50IGZvciB0aGUgbGFzdCBsaW5lKS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGlzIGxpbmUncyBsaW5lIG51bWJlciAoMS1iYXNlZCkuXG4gICAgKi9cbiAgICBudW1iZXIsIFxuICAgIC8qKlxuICAgIFRoZSBsaW5lJ3MgY29udGVudC5cbiAgICAqL1xuICAgIHRleHQpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGxlbmd0aCBvZiB0aGUgbGluZSAobm90IGluY2x1ZGluZyBhbnkgbGluZSBicmVhayBhZnRlciBpdCkuXG4gICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy50byAtIHRoaXMuZnJvbTsgfVxufVxuXG5leHBvcnQgeyBMaW5lLCBUZXh0LCBjb2RlUG9pbnRBdCwgY29kZVBvaW50U2l6ZSwgY291bnRDb2x1bW4sIGZpbmRDbHVzdGVyQnJlYWssIGZpbmRDb2x1bW4sIGZyb21Db2RlUG9pbnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/text/dist/index.js\n");

/***/ }),

/***/ "./node_modules/@codemirror/view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@codemirror/view/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Range\": function() { return /* reexport safe */ _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.Range; },\n/* harmony export */   \"BidiSpan\": function() { return /* binding */ BidiSpan; },\n/* harmony export */   \"BlockInfo\": function() { return /* binding */ BlockInfo; },\n/* harmony export */   \"BlockType\": function() { return /* binding */ BlockType; },\n/* harmony export */   \"Decoration\": function() { return /* binding */ Decoration; },\n/* harmony export */   \"Direction\": function() { return /* binding */ Direction; },\n/* harmony export */   \"EditorView\": function() { return /* binding */ EditorView; },\n/* harmony export */   \"MatchDecorator\": function() { return /* binding */ MatchDecorator; },\n/* harmony export */   \"PluginField\": function() { return /* binding */ PluginField; },\n/* harmony export */   \"PluginFieldProvider\": function() { return /* binding */ PluginFieldProvider; },\n/* harmony export */   \"ViewPlugin\": function() { return /* binding */ ViewPlugin; },\n/* harmony export */   \"ViewUpdate\": function() { return /* binding */ ViewUpdate; },\n/* harmony export */   \"WidgetType\": function() { return /* binding */ WidgetType; },\n/* harmony export */   \"__test\": function() { return /* binding */ __test; },\n/* harmony export */   \"drawSelection\": function() { return /* binding */ drawSelection; },\n/* harmony export */   \"dropCursor\": function() { return /* binding */ dropCursor; },\n/* harmony export */   \"highlightActiveLine\": function() { return /* binding */ highlightActiveLine; },\n/* harmony export */   \"highlightSpecialChars\": function() { return /* binding */ highlightSpecialChars; },\n/* harmony export */   \"keymap\": function() { return /* binding */ keymap; },\n/* harmony export */   \"logException\": function() { return /* binding */ logException; },\n/* harmony export */   \"placeholder\": function() { return /* binding */ placeholder; },\n/* harmony export */   \"runScopeHandlers\": function() { return /* binding */ runScopeHandlers; },\n/* harmony export */   \"scrollPastEnd\": function() { return /* binding */ scrollPastEnd; }\n/* harmony export */ });\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/state */ \"./node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/text */ \"./node_modules/@codemirror/text/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! style-mod */ \"./node_modules/style-mod/src/style-mod.js\");\n/* harmony import */ var _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/rangeset */ \"./node_modules/@codemirror/rangeset/dist/index.js\");\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\nfunction getSelection(root) {\n  var target; // Browsers differ on whether shadow roots have a getSelection\n  // method. If it exists, use that, otherwise, call it on the\n  // document.\n\n  if (root.nodeType == 11) {\n    // Shadow root\n    target = root.getSelection ? root : root.ownerDocument;\n  } else {\n    target = root;\n  }\n\n  return target.getSelection();\n}\n\nfunction contains(dom, node) {\n  return node ? dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;\n}\n\nfunction deepActiveElement() {\n  var elt = document.activeElement;\n\n  while (elt && elt.shadowRoot) {\n    elt = elt.shadowRoot.activeElement;\n  }\n\n  return elt;\n}\n\nfunction hasSelection(dom, selection) {\n  if (!selection.anchorNode) return false;\n\n  try {\n    // Firefox will raise 'permission denied' errors when accessing\n    // properties of `sel.anchorNode` when it's in a generated CSS\n    // element.\n    return contains(dom, selection.anchorNode);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction clientRectsFor(dom) {\n  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();else if (dom.nodeType == 1) return dom.getClientRects();else return [];\n} // Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\n\n\nfunction isEquivalentPosition(node, off, targetNode, targetOff) {\n  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;\n}\n\nfunction domIndex(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) return index;\n  }\n}\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true;\n\n    if (off == (dir < 0 ? 0 : maxOffset(node))) {\n      if (node.nodeName == \"DIV\") return false;\n      var parent = node.parentNode;\n      if (!parent || parent.nodeType != 1) return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.nodeType == 1 && node.contentEditable == \"false\") return false;\n      off = dir < 0 ? maxOffset(node) : 0;\n    } else {\n      return false;\n    }\n  }\n}\n\nfunction maxOffset(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\n\nvar Rect0 = {\n  left: 0,\n  right: 0,\n  top: 0,\n  bottom: 0\n};\n\nfunction flattenRect(rect, left) {\n  var x = left ? rect.left : rect.right;\n  return {\n    left: x,\n    right: x,\n    top: rect.top,\n    bottom: rect.bottom\n  };\n}\n\nfunction windowRect(win) {\n  return {\n    left: 0,\n    right: win.innerWidth,\n    top: 0,\n    bottom: win.innerHeight\n  };\n}\n\nfunction scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {\n  var doc = dom.ownerDocument,\n      win = doc.defaultView;\n\n  for (var cur = dom; cur;) {\n    if (cur.nodeType == 1) {\n      // Element\n      var bounding = void 0,\n          top = cur == doc.body;\n\n      if (top) {\n        bounding = windowRect(win);\n      } else {\n        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {\n          cur = cur.parentNode;\n          continue;\n        }\n\n        var _rect = cur.getBoundingClientRect(); // Make sure scrollbar width isn't included in the rectangle\n\n\n        bounding = {\n          left: _rect.left,\n          right: _rect.left + cur.clientWidth,\n          top: _rect.top,\n          bottom: _rect.top + cur.clientHeight\n        };\n      }\n\n      var moveX = 0,\n          moveY = 0;\n\n      if (y == \"nearest\") {\n        if (rect.top < bounding.top) {\n          moveY = -(bounding.top - rect.top + yMargin);\n          if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + moveY + yMargin;\n        } else if (rect.bottom > bounding.bottom) {\n          moveY = rect.bottom - bounding.bottom + yMargin;\n          if (side < 0 && rect.top - moveY < bounding.top) moveY = -(bounding.top + moveY - rect.top + yMargin);\n        }\n      } else {\n        var rectHeight = rect.bottom - rect.top,\n            boundingHeight = bounding.bottom - bounding.top;\n        var targetTop = y == \"center\" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == \"start\" || y == \"center\" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;\n        moveY = targetTop - bounding.top;\n      }\n\n      if (x == \"nearest\") {\n        if (rect.left < bounding.left) {\n          moveX = -(bounding.left - rect.left + xMargin);\n          if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + moveX + xMargin;\n        } else if (rect.right > bounding.right) {\n          moveX = rect.right - bounding.right + xMargin;\n          if (side < 0 && rect.left < bounding.left + moveX) moveX = -(bounding.left + moveX - rect.left + xMargin);\n        }\n      } else {\n        var targetLeft = x == \"center\" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == \"start\" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;\n        moveX = targetLeft - bounding.left;\n      }\n\n      if (moveX || moveY) {\n        if (top) {\n          win.scrollBy(moveX, moveY);\n        } else {\n          if (moveY) {\n            var start = cur.scrollTop;\n            cur.scrollTop += moveY;\n            moveY = cur.scrollTop - start;\n          }\n\n          if (moveX) {\n            var _start = cur.scrollLeft;\n            cur.scrollLeft += moveX;\n            moveX = cur.scrollLeft - _start;\n          }\n\n          rect = {\n            left: rect.left - moveX,\n            top: rect.top - moveY,\n            right: rect.right - moveX,\n            bottom: rect.bottom - moveY\n          };\n        }\n      }\n\n      if (top) break;\n      cur = cur.assignedSlot || cur.parentNode;\n      x = y = \"nearest\";\n    } else if (cur.nodeType == 11) {\n      // A shadow root\n      cur = cur.host;\n    } else {\n      break;\n    }\n  }\n}\n\nvar DOMSelectionState = /*#__PURE__*/function () {\n  function DOMSelectionState() {\n    _classCallCheck(this, DOMSelectionState);\n\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n\n  _createClass(DOMSelectionState, [{\n    key: \"eq\",\n    value: function eq(domSel) {\n      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;\n    }\n  }, {\n    key: \"setRange\",\n    value: function setRange(range) {\n      this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);\n    }\n  }, {\n    key: \"set\",\n    value: function set(anchorNode, anchorOffset, focusNode, focusOffset) {\n      this.anchorNode = anchorNode;\n      this.anchorOffset = anchorOffset;\n      this.focusNode = focusNode;\n      this.focusOffset = focusOffset;\n    }\n  }]);\n\n  return DOMSelectionState;\n}();\n\nvar preventScrollSupported = null; // Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\n\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive(); // in IE\n\n  if (preventScrollSupported) return dom.focus(preventScrollSupported);\n  var stack = [];\n\n  for (var cur = dom; cur; cur = cur.parentNode) {\n    stack.push(cur, cur.scrollTop, cur.scrollLeft);\n    if (cur == cur.ownerDocument) break;\n  }\n\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {\n        preventScroll: true\n      };\n      return true;\n    }\n\n  } : undefined);\n\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n\n    for (var i = 0; i < stack.length;) {\n      var elt = stack[i++],\n          top = stack[i++],\n          left = stack[i++];\n      if (elt.scrollTop != top) elt.scrollTop = top;\n      if (elt.scrollLeft != left) elt.scrollLeft = left;\n    }\n  }\n}\n\nvar scratchRange;\n\nfunction textRange(node, from) {\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;\n  var range = scratchRange || (scratchRange = document.createRange());\n  range.setEnd(node, to);\n  range.setStart(node, from);\n  return range;\n}\n\nfunction dispatchKey(elt, name, code) {\n  var options = {\n    key: name,\n    code: name,\n    keyCode: code,\n    which: code,\n    cancelable: true\n  };\n  var down = new KeyboardEvent(\"keydown\", options);\n  down.synthetic = true;\n  elt.dispatchEvent(down);\n  var up = new KeyboardEvent(\"keyup\", options);\n  up.synthetic = true;\n  elt.dispatchEvent(up);\n  return down.defaultPrevented || up.defaultPrevented;\n}\n\nfunction getRoot(node) {\n  while (node) {\n    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;\n    node = node.assignedSlot || node.parentNode;\n  }\n\n  return null;\n}\n\nfunction clearAttributes(node) {\n  while (node.attributes.length) {\n    node.removeAttributeNode(node.attributes[0]);\n  }\n}\n\nvar DOMPos = /*#__PURE__*/function () {\n  function DOMPos(node, offset) {\n    var precise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    _classCallCheck(this, DOMPos);\n\n    this.node = node;\n    this.offset = offset;\n    this.precise = precise;\n  }\n\n  _createClass(DOMPos, null, [{\n    key: \"before\",\n    value: function before(dom, precise) {\n      return new DOMPos(dom.parentNode, domIndex(dom), precise);\n    }\n  }, {\n    key: \"after\",\n    value: function after(dom, precise) {\n      return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);\n    }\n  }]);\n\n  return DOMPos;\n}();\n\nvar noChildren = [];\n\nvar ContentView = /*#__PURE__*/function () {\n  function ContentView() {\n    _classCallCheck(this, ContentView);\n\n    this.parent = null;\n    this.dom = null;\n    this.dirty = 2\n    /* Node */\n    ;\n  }\n\n  _createClass(ContentView, [{\n    key: \"editorView\",\n    get: function get() {\n      if (!this.parent) throw new Error(\"Accessing view in orphan content view\");\n      return this.parent.editorView;\n    }\n  }, {\n    key: \"overrideDOMText\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"posAtStart\",\n    get: function get() {\n      return this.parent ? this.parent.posBefore(this) : 0;\n    }\n  }, {\n    key: \"posAtEnd\",\n    get: function get() {\n      return this.posAtStart + this.length;\n    }\n  }, {\n    key: \"posBefore\",\n    value: function posBefore(view) {\n      var pos = this.posAtStart;\n\n      var _iterator = _createForOfIteratorHelper(this.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n          if (child == view) return pos;\n          pos += child.length + child.breakAfter;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      throw new RangeError(\"Invalid child in posBefore\");\n    }\n  }, {\n    key: \"posAfter\",\n    value: function posAfter(view) {\n      return this.posBefore(view) + view.length;\n    } // Will return a rectangle directly before (when side < 0), after\n    // (side > 0) or directly on (when the browser supports it) the\n    // given position.\n\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(_pos, _side) {\n      return null;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(track) {\n      if (this.dirty & 2\n      /* Node */\n      ) {\n        var parent = this.dom;\n        var pos = parent.firstChild;\n\n        var _iterator2 = _createForOfIteratorHelper(this.children),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n\n            if (child.dirty) {\n              if (!child.dom && pos) {\n                var contentView = ContentView.get(pos);\n                if (!contentView || !contentView.parent && contentView.constructor == child.constructor) child.reuseDOM(pos);\n              }\n\n              child.sync(track);\n              child.dirty = 0\n              /* Not */\n              ;\n            }\n\n            if (track && !track.written && track.node == parent && pos != child.dom) track.written = true;\n\n            if (child.dom.parentNode == parent) {\n              while (pos && pos != child.dom) {\n                pos = rm(pos);\n              }\n\n              pos = child.dom.nextSibling;\n            } else {\n              parent.insertBefore(child.dom, pos);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (pos && track && track.node == parent) track.written = true;\n\n        while (pos) {\n          pos = rm(pos);\n        }\n      } else if (this.dirty & 1\n      /* Child */\n      ) {\n        var _iterator3 = _createForOfIteratorHelper(this.children),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _child = _step3.value;\n\n            if (_child.dirty) {\n              _child.sync(track);\n\n              _child.dirty = 0\n              /* Not */\n              ;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  }, {\n    key: \"reuseDOM\",\n    value: function reuseDOM(_dom) {}\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM(node, offset) {\n      var after;\n\n      if (node == this.dom) {\n        after = this.dom.childNodes[offset];\n      } else {\n        var bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;\n\n        for (;;) {\n          var parent = node.parentNode;\n          if (parent == this.dom) break;\n\n          if (bias == 0 && parent.firstChild != parent.lastChild) {\n            if (node == parent.firstChild) bias = -1;else bias = 1;\n          }\n\n          node = parent;\n        }\n\n        if (bias < 0) after = node;else after = node.nextSibling;\n      }\n\n      if (after == this.dom.firstChild) return 0;\n\n      while (after && !ContentView.get(after)) {\n        after = after.nextSibling;\n      }\n\n      if (!after) return this.length;\n\n      for (var i = 0, pos = 0;; i++) {\n        var child = this.children[i];\n        if (child.dom == after) return pos;\n        pos += child.length + child.breakAfter;\n      }\n    }\n  }, {\n    key: \"domBoundsAround\",\n    value: function domBoundsAround(from, to) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var fromI = -1,\n          fromStart = -1,\n          toI = -1,\n          toEnd = -1;\n\n      for (var i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {\n        var child = this.children[i],\n            end = pos + child.length;\n        if (pos < from && end > to) return child.domBoundsAround(from, to, pos);\n\n        if (end >= from && fromI == -1) {\n          fromI = i;\n          fromStart = pos;\n        }\n\n        if (pos > to && child.dom.parentNode == this.dom) {\n          toI = i;\n          toEnd = prevEnd;\n          break;\n        }\n\n        prevEnd = end;\n        pos = end + child.breakAfter;\n      }\n\n      return {\n        from: fromStart,\n        to: toEnd < 0 ? offset + this.length : toEnd,\n        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,\n        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null\n      };\n    }\n  }, {\n    key: \"markDirty\",\n    value: function markDirty() {\n      var andParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.dirty |= 2\n      /* Node */\n      ;\n      this.markParentsDirty(andParent);\n    }\n  }, {\n    key: \"markParentsDirty\",\n    value: function markParentsDirty(childList) {\n      for (var parent = this.parent; parent; parent = parent.parent) {\n        if (childList) parent.dirty |= 2\n        /* Node */\n        ;\n        if (parent.dirty & 1\n        /* Child */\n        ) return;\n        parent.dirty |= 1\n        /* Child */\n        ;\n        childList = false;\n      }\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(parent) {\n      if (this.parent != parent) {\n        this.parent = parent;\n        if (this.dirty) this.markParentsDirty(true);\n      }\n    }\n  }, {\n    key: \"setDOM\",\n    value: function setDOM(dom) {\n      if (this.dom) this.dom.cmView = null;\n      this.dom = dom;\n      dom.cmView = this;\n    }\n  }, {\n    key: \"rootView\",\n    get: function get() {\n      for (var v = this;;) {\n        var parent = v.parent;\n        if (!parent) return v;\n        v = parent;\n      }\n    }\n  }, {\n    key: \"replaceChildren\",\n    value: function replaceChildren(from, to) {\n      var _this$children;\n\n      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noChildren;\n      this.markDirty();\n\n      for (var i = from; i < to; i++) {\n        var child = this.children[i];\n        if (child.parent == this) child.destroy();\n      }\n\n      (_this$children = this.children).splice.apply(_this$children, [from, to - from].concat(_toConsumableArray(children)));\n\n      for (var _i = 0; _i < children.length; _i++) {\n        children[_i].setParent(this);\n      }\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(_rec) {\n      return false;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(_event) {\n      return false;\n    }\n  }, {\n    key: \"childCursor\",\n    value: function childCursor() {\n      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.length;\n      return new ChildCursor(this.children, pos, this.children.length);\n    }\n  }, {\n    key: \"childPos\",\n    value: function childPos(pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.childCursor().findPos(pos, bias);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var name = this.constructor.name.replace(\"View\", \"\");\n      return name + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (name == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n    }\n  }, {\n    key: \"isEditable\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(from, to, source, hasStart, openStart, openEnd) {\n      return false;\n    }\n  }, {\n    key: \"become\",\n    value: function become(other) {\n      return false;\n    } // When this is a zero-length view with a side, this should return a\n    // number <= 0 to indicate it is before its position, or a\n    // number > 0 when after its position.\n\n  }, {\n    key: \"getSide\",\n    value: function getSide() {\n      return 0;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.parent = null;\n    }\n  }], [{\n    key: \"get\",\n    value: function get(node) {\n      return node.cmView;\n    }\n  }]);\n\n  return ContentView;\n}();\n\nContentView.prototype.breakAfter = 0; // Remove a DOM node and return its next sibling.\n\nfunction rm(dom) {\n  var next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\n\nvar ChildCursor = /*#__PURE__*/function () {\n  function ChildCursor(children, pos, i) {\n    _classCallCheck(this, ChildCursor);\n\n    this.children = children;\n    this.pos = pos;\n    this.i = i;\n    this.off = 0;\n  }\n\n  _createClass(ChildCursor, [{\n    key: \"findPos\",\n    value: function findPos(pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      for (;;) {\n        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {\n          this.off = pos - this.pos;\n          return this;\n        }\n\n        var next = this.children[--this.i];\n        this.pos -= next.length + next.breakAfter;\n      }\n    }\n  }]);\n\n  return ChildCursor;\n}();\n\nfunction replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {\n  var children = parent.children;\n  var before = children.length ? children[fromI] : null;\n  var last = insert.length ? insert[insert.length - 1] : null;\n  var breakAtEnd = last ? last.breakAfter : breakAtStart; // Change within a single child\n\n  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;\n\n  if (toI < children.length) {\n    var after = children[toI]; // Make sure the end of the child after the update is preserved in `after`\n\n    if (after && toOff < after.length) {\n      // If we're splitting a child, separate part of it to avoid that\n      // being mangled when updating the child before the update.\n      if (fromI == toI) {\n        after = after.split(toOff);\n        toOff = 0;\n      } // If the element after the replacement should be merged with\n      // the last replacing element, update `content`\n\n\n      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {\n        insert[insert.length - 1] = after;\n      } else {\n        // Remove the start of the after element, if necessary, and\n        // add it to `content`.\n        if (toOff) after.merge(0, toOff, null, false, 0, openEnd);\n        insert.push(after);\n      }\n    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {\n      // The element at `toI` is entirely covered by this range.\n      // Preserve its line break, if any.\n      if (last) last.breakAfter = 1;else breakAtStart = 1;\n    } // Since we've handled the next element from the current elements\n    // now, make sure `toI` points after that.\n\n\n    toI++;\n  }\n\n  if (before) {\n    before.breakAfter = breakAtStart;\n\n    if (fromOff > 0) {\n      if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {\n        before.breakAfter = insert.shift().breakAfter;\n      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {\n        before.merge(fromOff, before.length, null, false, openStart, 0);\n      }\n\n      fromI++;\n    }\n  } // Try to merge widgets on the boundaries of the replacement\n\n\n  while (fromI < toI && insert.length) {\n    if (children[toI - 1].become(insert[insert.length - 1])) {\n      toI--;\n      insert.pop();\n      openEnd = insert.length ? 0 : openStart;\n    } else if (children[fromI].become(insert[0])) {\n      fromI++;\n      insert.shift();\n      openStart = insert.length ? 0 : openEnd;\n    } else {\n      break;\n    }\n  }\n\n  if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;\n  if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);\n}\n\nfunction mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {\n  var cur = parent.childCursor();\n\n  var _cur$findPos = cur.findPos(to, 1),\n      toI = _cur$findPos.i,\n      toOff = _cur$findPos.off;\n\n  var _cur$findPos2 = cur.findPos(from, -1),\n      fromI = _cur$findPos2.i,\n      fromOff = _cur$findPos2.off;\n\n  var dLen = from - to;\n\n  var _iterator4 = _createForOfIteratorHelper(insert),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var view = _step4.value;\n      dLen += view.length;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  parent.length += dLen;\n  replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);\n}\n\nvar _ref = typeof navigator != \"undefined\" ? [navigator, document] : [{\n  userAgent: \"\",\n  vendor: \"\",\n  platform: \"\"\n}, {\n  documentElement: {\n    style: {}\n  }\n}],\n    _ref2 = _slicedToArray(_ref, 2),\n    nav = _ref2[0],\n    doc = _ref2[1];\n\nvar ie_edge = /*@__PURE__*/ /Edge\\/(\\d+)/.exec(nav.userAgent);\nvar ie_upto10 = /*@__PURE__*/ /MSIE \\d/.test(nav.userAgent);\nvar ie_11up = /*@__PURE__*/ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(nav.userAgent);\nvar ie = !!(ie_upto10 || ie_11up || ie_edge);\nvar gecko = !ie && /*@__PURE__*/ /gecko\\/(\\d+)/i.test(nav.userAgent);\nvar chrome = !ie && /*@__PURE__*/ /Chrome\\/(\\d+)/.exec(nav.userAgent);\nvar webkit = (\"webkitFontSmoothing\" in doc.documentElement.style);\nvar safari = !ie && /*@__PURE__*/ /Apple Computer/.test(nav.vendor);\nvar ios = safari && ( /*@__PURE__*/ /Mobile\\/\\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);\nvar browser = {\n  mac: ios || /*@__PURE__*/ /Mac/.test(nav.platform),\n  windows: /*@__PURE__*/ /Win/.test(nav.platform),\n  linux: /*@__PURE__*/ /Linux|X11/.test(nav.platform),\n  ie: ie,\n  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,\n  gecko: gecko,\n  gecko_version: gecko ? +( /*@__PURE__*/ /Firefox\\/(\\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,\n  chrome: !!chrome,\n  chrome_version: chrome ? +chrome[1] : 0,\n  ios: ios,\n  android: /*@__PURE__*/ /Android\\b/.test(nav.userAgent),\n  webkit: webkit,\n  safari: safari,\n  webkit_version: webkit ? +( /*@__PURE__*/ /\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n  tabSize: doc.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nvar MaxJoinLen = 256;\n\nvar TextView = /*#__PURE__*/function (_ContentView) {\n  _inherits(TextView, _ContentView);\n\n  var _super = _createSuper(TextView);\n\n  function TextView(text) {\n    var _this;\n\n    _classCallCheck(this, TextView);\n\n    _this = _super.call(this);\n    _this.text = text;\n    return _this;\n  }\n\n  _createClass(TextView, [{\n    key: \"length\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"createDOM\",\n    value: function createDOM(textDOM) {\n      this.setDOM(textDOM || document.createTextNode(this.text));\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(track) {\n      if (!this.dom) this.createDOM();\n\n      if (this.dom.nodeValue != this.text) {\n        if (track && track.node == this.dom) track.written = true;\n        this.dom.nodeValue = this.text;\n      }\n    }\n  }, {\n    key: \"reuseDOM\",\n    value: function reuseDOM(dom) {\n      if (dom.nodeType == 3) this.createDOM(dom);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(from, to, source) {\n      if (source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen)) return false;\n      this.text = this.text.slice(0, from) + (source ? source.text : \"\") + this.text.slice(to);\n      this.markDirty();\n      return true;\n    }\n  }, {\n    key: \"split\",\n    value: function split(from) {\n      var result = new TextView(this.text.slice(from));\n      this.text = this.text.slice(0, from);\n      this.markDirty();\n      return result;\n    }\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM(node, offset) {\n      return node == this.dom ? offset : offset ? this.text.length : 0;\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return new DOMPos(this.dom, pos);\n    }\n  }, {\n    key: \"domBoundsAround\",\n    value: function domBoundsAround(_from, _to, offset) {\n      return {\n        from: offset,\n        to: offset + this.length,\n        startDOM: this.dom,\n        endDOM: this.dom.nextSibling\n      };\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos, side) {\n      return textCoords(this.dom, pos, side);\n    }\n  }]);\n\n  return TextView;\n}(ContentView);\n\nvar MarkView = /*#__PURE__*/function (_ContentView2) {\n  _inherits(MarkView, _ContentView2);\n\n  var _super2 = _createSuper(MarkView);\n\n  function MarkView(mark) {\n    var _this2;\n\n    var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, MarkView);\n\n    _this2 = _super2.call(this);\n    _this2.mark = mark;\n    _this2.children = children;\n    _this2.length = length;\n\n    var _iterator5 = _createForOfIteratorHelper(children),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var ch = _step5.value;\n        ch.setParent(_assertThisInitialized(_this2));\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return _this2;\n  }\n\n  _createClass(MarkView, [{\n    key: \"setAttrs\",\n    value: function setAttrs(dom) {\n      clearAttributes(dom);\n      if (this.mark[\"class\"]) dom.className = this.mark[\"class\"];\n      if (this.mark.attrs) for (var name in this.mark.attrs) {\n        dom.setAttribute(name, this.mark.attrs[name]);\n      }\n      return dom;\n    }\n  }, {\n    key: \"reuseDOM\",\n    value: function reuseDOM(node) {\n      if (node.nodeName == this.mark.tagName.toUpperCase()) {\n        this.setDOM(node);\n        this.dirty |= 4\n        /* Attrs */\n        | 2\n        /* Node */\n        ;\n      }\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(track) {\n      if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));else if (this.dirty & 4\n      /* Attrs */\n      ) this.setAttrs(this.dom);\n\n      _get(_getPrototypeOf(MarkView.prototype), \"sync\", this).call(this, track);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(from, to, source, _hasStart, openStart, openEnd) {\n      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n      mergeChildrenInto(this, from, to, source ? source.children : [], openStart - 1, openEnd - 1);\n      this.markDirty();\n      return true;\n    }\n  }, {\n    key: \"split\",\n    value: function split(from) {\n      var result = [],\n          off = 0,\n          detachFrom = -1,\n          i = 0;\n\n      var _iterator6 = _createForOfIteratorHelper(this.children),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var elt = _step6.value;\n          var end = off + elt.length;\n          if (end > from) result.push(off < from ? elt.split(from - off) : elt);\n          if (detachFrom < 0 && off >= from) detachFrom = i;\n          off = end;\n          i++;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      var length = this.length - from;\n      this.length = from;\n\n      if (detachFrom > -1) {\n        this.children.length = detachFrom;\n        this.markDirty();\n      }\n\n      return new MarkView(this.mark, result, length);\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos, side) {\n      return coordsInChildren(this, pos, side);\n    }\n  }]);\n\n  return MarkView;\n}(ContentView);\n\nfunction textCoords(text, pos, side) {\n  var length = text.nodeValue.length;\n  if (pos > length) pos = length;\n  var from = pos,\n      to = pos,\n      flatten = 0;\n\n  if (pos == 0 && side < 0 || pos == length && side >= 0) {\n    if (!(browser.chrome || browser.gecko)) {\n      // These browsers reliably return valid rectangles for empty ranges\n      if (pos) {\n        from--;\n        flatten = 1;\n      } // FIXME this is wrong in RTL text\n      else {\n        to++;\n        flatten = -1;\n      }\n    }\n  } else {\n    if (side < 0) from--;else to++;\n  }\n\n  var rects = textRange(text, from, to).getClientRects();\n  if (!rects.length) return Rect0;\n  var rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];\n  if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, function (r) {\n    return r.width;\n  }) || rect;\n  return flatten ? flattenRect(rect, flatten < 0) : rect || null;\n} // Also used for collapsed ranges that don't have a placeholder widget!\n\n\nvar WidgetView = /*#__PURE__*/function (_ContentView3) {\n  _inherits(WidgetView, _ContentView3);\n\n  var _super3 = _createSuper(WidgetView);\n\n  function WidgetView(widget, length, side) {\n    var _this3;\n\n    _classCallCheck(this, WidgetView);\n\n    _this3 = _super3.call(this);\n    _this3.widget = widget;\n    _this3.length = length;\n    _this3.side = side;\n    return _this3;\n  }\n\n  _createClass(WidgetView, [{\n    key: \"split\",\n    value: function split(from) {\n      var result = WidgetView.create(this.widget, this.length - from, this.side);\n      this.length -= from;\n      return result;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (!this.dom || !this.widget.updateDOM(this.dom)) {\n        this.setDOM(this.widget.toDOM(this.editorView));\n        this.dom.contentEditable = \"false\";\n      }\n    }\n  }, {\n    key: \"getSide\",\n    value: function getSide() {\n      return this.side;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(from, to, source, hasStart, openStart, openEnd) {\n      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n      this.length = from + (source ? source.length : 0) + (this.length - to);\n      return true;\n    }\n  }, {\n    key: \"become\",\n    value: function become(other) {\n      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {\n        if (this.widget.constructor == other.widget.constructor) {\n          if (!this.widget.eq(other.widget)) this.markDirty(true);\n          this.widget = other.widget;\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation() {\n      return true;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(event) {\n      return this.widget.ignoreEvent(event);\n    }\n  }, {\n    key: \"overrideDOMText\",\n    get: function get() {\n      if (this.length == 0) return _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n      var top = this;\n\n      while (top.parent) {\n        top = top.parent;\n      }\n\n      var view = top.editorView,\n          text = view && view.state.doc,\n          start = this.posAtStart;\n      return text ? text.slice(start, start + this.length) : _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n  }, {\n    key: \"domBoundsAround\",\n    value: function domBoundsAround() {\n      return null;\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos, side) {\n      var rects = this.dom.getClientRects(),\n          rect = null;\n      if (!rects.length) return Rect0;\n\n      for (var i = pos > 0 ? rects.length - 1 : 0;; i += pos > 0 ? -1 : 1) {\n        rect = rects[i];\n        if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;\n      }\n\n      return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);\n    }\n  }, {\n    key: \"isEditable\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(WidgetView.prototype), \"destroy\", this).call(this);\n\n      if (this.dom) this.widget.destroy(this.dom);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(widget, length, side) {\n      return new (widget.customView || WidgetView)(widget, length, side);\n    }\n  }]);\n\n  return WidgetView;\n}(ContentView);\n\nvar CompositionView = /*#__PURE__*/function (_WidgetView) {\n  _inherits(CompositionView, _WidgetView);\n\n  var _super4 = _createSuper(CompositionView);\n\n  function CompositionView() {\n    _classCallCheck(this, CompositionView);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(CompositionView, [{\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return new DOMPos(this.widget.text, pos);\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      this.setDOM(this.widget.toDOM());\n    }\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM(node, offset) {\n      return !offset ? 0 : node.nodeType == 3 ? Math.min(offset, this.length) : this.length;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation() {\n      return false;\n    }\n  }, {\n    key: \"overrideDOMText\",\n    get: function get() {\n      return null;\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos, side) {\n      return textCoords(this.widget.text, pos, side);\n    }\n  }, {\n    key: \"isEditable\",\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return CompositionView;\n}(WidgetView); // Use two characters on Android, to prevent Chrome from closing the\n// virtual keyboard when backspacing after a widget (#602).\n\n\nvar ZeroWidthSpace = browser.android ? \"\\u200B\\u200B\" : \"\\u200B\"; // These are drawn around uneditable widgets to avoid a number of\n// browser bugs that show up when the cursor is directly next to\n// uneditable inline content.\n\nvar WidgetBufferView = /*#__PURE__*/function (_ContentView4) {\n  _inherits(WidgetBufferView, _ContentView4);\n\n  var _super5 = _createSuper(WidgetBufferView);\n\n  function WidgetBufferView(side) {\n    var _this4;\n\n    _classCallCheck(this, WidgetBufferView);\n\n    _this4 = _super5.call(this);\n    _this4.side = side;\n    return _this4;\n  }\n\n  _createClass(WidgetBufferView, [{\n    key: \"length\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge() {\n      return false;\n    }\n  }, {\n    key: \"become\",\n    value: function become(other) {\n      return other instanceof WidgetBufferView && other.side == this.side;\n    }\n  }, {\n    key: \"split\",\n    value: function split() {\n      return new WidgetBufferView(this.side);\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (!this.dom) this.setDOM(document.createTextNode(ZeroWidthSpace));else if (this.dirty && this.dom.nodeValue != ZeroWidthSpace) this.dom.nodeValue = ZeroWidthSpace;\n    }\n  }, {\n    key: \"getSide\",\n    value: function getSide() {\n      return this.side;\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return DOMPos.before(this.dom);\n    }\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM() {\n      return 0;\n    }\n  }, {\n    key: \"domBoundsAround\",\n    value: function domBoundsAround() {\n      return null;\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos) {\n      var rects = clientRectsFor(this.dom);\n      return rects[rects.length - 1] || null;\n    }\n  }, {\n    key: \"overrideDOMText\",\n    get: function get() {\n      return _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.of([this.dom.nodeValue.replace(/\\u200b/g, \"\")]);\n    }\n  }]);\n\n  return WidgetBufferView;\n}(ContentView);\n\nTextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;\n\nfunction inlineDOMAtPos(dom, children, pos) {\n  var i = 0;\n\n  for (var off = 0; i < children.length; i++) {\n    var child = children[i],\n        end = off + child.length;\n    if (end == off && child.getSide() <= 0) continue;\n    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);\n    if (pos <= off) break;\n    off = end;\n  }\n\n  for (; i > 0; i--) {\n    var before = children[i - 1].dom;\n    if (before.parentNode == dom) return DOMPos.after(before);\n  }\n\n  return new DOMPos(dom, 0);\n} // Assumes `view`, if a mark view, has precisely 1 child.\n\n\nfunction joinInlineInto(parent, view, open) {\n  var last,\n      children = parent.children;\n\n  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {\n    joinInlineInto(last, view.children[0], open - 1);\n  } else {\n    children.push(view);\n    view.setParent(parent);\n  }\n\n  parent.length += view.length;\n}\n\nfunction coordsInChildren(view, pos, side) {\n  for (var off = 0, i = 0; i < view.children.length; i++) {\n    var child = view.children[i],\n        end = off + child.length,\n        next = void 0;\n\n    if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i + 1 == view.children.length || (next = view.children[i + 1]).length || next.getSide() > 0)) {\n      var flatten = 0;\n\n      if (end == off) {\n        if (child.getSide() <= 0) continue;\n        flatten = side = -child.getSide();\n      }\n\n      var rect = child.coordsAt(pos - off, side);\n      return flatten && rect ? flattenRect(rect, side < 0) : rect;\n    }\n\n    off = end;\n  }\n\n  var last = view.dom.lastChild;\n  if (!last) return view.dom.getBoundingClientRect();\n  var rects = clientRectsFor(last);\n  return rects[rects.length - 1] || null;\n}\n\nfunction combineAttrs(source, target) {\n  for (var name in source) {\n    if (name == \"class\" && target[\"class\"]) target[\"class\"] += \" \" + source[\"class\"];else if (name == \"style\" && target.style) target.style += \";\" + source.style;else target[name] = source[name];\n  }\n\n  return target;\n}\n\nfunction attrsEq(a, b) {\n  if (a == b) return true;\n  if (!a || !b) return false;\n  var keysA = Object.keys(a),\n      keysB = Object.keys(b);\n  if (keysA.length != keysB.length) return false;\n\n  for (var _i2 = 0, _keysA = keysA; _i2 < _keysA.length; _i2++) {\n    var key = _keysA[_i2];\n    if (keysB.indexOf(key) == -1 || a[key] !== b[key]) return false;\n  }\n\n  return true;\n}\n\nfunction _updateAttrs(dom, prev, attrs) {\n  if (prev) for (var name in prev) {\n    if (!(attrs && name in attrs)) dom.removeAttribute(name);\n  }\n  if (attrs) for (var _name in attrs) {\n    if (!(prev && prev[_name] == attrs[_name])) dom.setAttribute(_name, attrs[_name]);\n  }\n}\n/**\nWidgets added to the content are described by subclasses of this\nclass. Using a description object like that makes it possible to\ndelay creating of the DOM structure for a widget until it is\nneeded, and to avoid redrawing widgets even when the decorations\nthat define them are recreated.\n*/\n\n\nvar WidgetType = /*#__PURE__*/function () {\n  function WidgetType() {\n    _classCallCheck(this, WidgetType);\n  }\n\n  _createClass(WidgetType, [{\n    key: \"eq\",\n    value:\n    /**\n    Compare this instance to another instance of the same type.\n    (TypeScript can't express this, but only instances of the same\n    specific class will be passed to this method.) This is used to\n    avoid redrawing widgets when they are replaced by a new\n    decoration of the same type. The default implementation just\n    returns `false`, which will cause new instances of the widget to\n    always be redrawn.\n    */\n    function eq(_widget) {\n      return false;\n    }\n    /**\n    Update a DOM element created by a widget of the same type (but\n    different, non-`eq` content) to reflect this widget. May return\n    true to indicate that it could update, false to indicate it\n    couldn't (in which case the widget will be redrawn). The default\n    implementation just returns false.\n    */\n\n  }, {\n    key: \"updateDOM\",\n    value: function updateDOM(_dom) {\n      return false;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"compare\",\n    value: function compare(other) {\n      return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    The estimated height this widget will have, to be used when\n    estimating the height of content that hasn't been drawn. May\n    return -1 to indicate you don't know. The default implementation\n    returns -1.\n    */\n\n  }, {\n    key: \"estimatedHeight\",\n    get: function get() {\n      return -1;\n    }\n    /**\n    Can be used to configure which kinds of events inside the widget\n    should be ignored by the editor. The default is to ignore all\n    events.\n    */\n\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(_event) {\n      return true;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"customView\",\n    get: function get() {\n      return null;\n    }\n    /**\n    This is called when the an instance of the widget is removed\n    from the editor view.\n    */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy(_dom) {}\n  }]);\n\n  return WidgetType;\n}();\n/**\nThe different types of blocks that can occur in an editor view.\n*/\n\n\nvar BlockType = /*@__PURE__*/function (BlockType) {\n  /**\n  A line of text.\n  */\n  BlockType[BlockType[\"Text\"] = 0] = \"Text\";\n  /**\n  A block widget associated with the position after it.\n  */\n\n  BlockType[BlockType[\"WidgetBefore\"] = 1] = \"WidgetBefore\";\n  /**\n  A block widget associated with the position before it.\n  */\n\n  BlockType[BlockType[\"WidgetAfter\"] = 2] = \"WidgetAfter\";\n  /**\n  A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.\n  */\n\n  BlockType[BlockType[\"WidgetRange\"] = 3] = \"WidgetRange\";\n  return BlockType;\n}(BlockType || (BlockType = {}));\n/**\nA decoration provides information on how to draw or style a piece\nof content. You'll usually use it wrapped in a\n[`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range), which adds a start and end position.\n*/\n\n\nvar Decoration = /*#__PURE__*/function (_RangeValue) {\n  _inherits(Decoration, _RangeValue);\n\n  var _super6 = _createSuper(Decoration);\n\n  /**\n  @internal\n  */\n  function Decoration(\n  /**\n  @internal\n  */\n  startSide,\n  /**\n  @internal\n  */\n  endSide,\n  /**\n  @internal\n  */\n  widget,\n  /**\n  The config object used to create this decoration. You can\n  include additional properties in there to store metadata about\n  your decoration.\n  */\n  spec) {\n    var _this5;\n\n    _classCallCheck(this, Decoration);\n\n    _this5 = _super6.call(this);\n    _this5.startSide = startSide;\n    _this5.endSide = endSide;\n    _this5.widget = widget;\n    _this5.spec = spec;\n    return _this5;\n  }\n  /**\n  @internal\n  */\n\n\n  _createClass(Decoration, [{\n    key: \"heightRelevant\",\n    get: function get() {\n      return false;\n    }\n    /**\n    Create a mark decoration, which influences the styling of the\n    content in its range. Nested mark decorations will cause nested\n    DOM elements to be created. Nesting order is determined by\n    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations) or\n    (below the facet-provided decorations) [view\n    plugin](https://codemirror.net/6/docs/ref/#view.PluginSpec.decorations). Such elements are split\n    on line boundaries and on the boundaries of higher-precedence\n    decorations.\n    */\n\n  }, {\n    key: \"hasHeight\",\n    value:\n    /**\n    @internal\n    */\n    function hasHeight() {\n      return this.widget ? this.widget.estimatedHeight > -1 : false;\n    }\n  }], [{\n    key: \"mark\",\n    value: function mark(spec) {\n      return new MarkDecoration(spec);\n    }\n    /**\n    Create a widget decoration, which adds an element at the given\n    position.\n    */\n\n  }, {\n    key: \"widget\",\n    value: function widget(spec) {\n      var side = spec.side || 0,\n          block = !!spec.block;\n      side += block ? side > 0 ? 300000000\n      /* BlockAfter */\n      : -400000000\n      /* BlockBefore */\n      : side > 0 ? 100000000\n      /* InlineAfter */\n      : -100000000\n      /* InlineBefore */\n      ;\n      return new PointDecoration(spec, side, side, block, spec.widget || null, false);\n    }\n    /**\n    Create a replace decoration which replaces the given range with\n    a widget, or simply hides it.\n    */\n\n  }, {\n    key: \"replace\",\n    value: function replace(spec) {\n      var block = !!spec.block;\n\n      var _getInclusive = getInclusive(spec, block),\n          start = _getInclusive.start,\n          end = _getInclusive.end;\n\n      var startSide = block ? start ? -300000000\n      /* BlockIncStart */\n      : -1\n      /* InlineIncStart */\n      : 400000000\n      /* NonIncStart */\n      ;\n      var endSide = block ? end ? 200000000\n      /* BlockIncEnd */\n      : 1\n      /* InlineIncEnd */\n      : -500000000\n      /* NonIncEnd */\n      ;\n      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);\n    }\n    /**\n    Create a line decoration, which can add DOM attributes to the\n    line starting at the given position.\n    */\n\n  }, {\n    key: \"line\",\n    value: function line(spec) {\n      return new LineDecoration(spec);\n    }\n    /**\n    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n    decorated range or ranges. If the ranges aren't already sorted,\n    pass `true` for `sort` to make the library sort them for you.\n    */\n\n  }, {\n    key: \"set\",\n    value: function set(of) {\n      var sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      return _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.of(of, sort);\n    }\n  }]);\n\n  return Decoration;\n}(_codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeValue);\n/**\nThe empty set of decorations.\n*/\n\n\nDecoration.none = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.empty;\n\nvar MarkDecoration = /*#__PURE__*/function (_Decoration) {\n  _inherits(MarkDecoration, _Decoration);\n\n  var _super7 = _createSuper(MarkDecoration);\n\n  function MarkDecoration(spec) {\n    var _this6;\n\n    _classCallCheck(this, MarkDecoration);\n\n    var _getInclusive2 = getInclusive(spec),\n        start = _getInclusive2.start,\n        end = _getInclusive2.end;\n\n    _this6 = _super7.call(this, start ? -1\n    /* InlineIncStart */\n    : 400000000\n    /* NonIncStart */\n    , end ? 1\n    /* InlineIncEnd */\n    : -500000000\n    /* NonIncEnd */\n    , null, spec);\n    _this6.tagName = spec.tagName || \"span\";\n    _this6[\"class\"] = spec[\"class\"] || \"\";\n    _this6.attrs = spec.attributes || null;\n    return _this6;\n  }\n\n  _createClass(MarkDecoration, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this[\"class\"] == other[\"class\"] && attrsEq(this.attrs, other.attrs);\n    }\n  }, {\n    key: \"range\",\n    value: function range(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      if (from >= to) throw new RangeError(\"Mark decorations may not be empty\");\n      return _get(_getPrototypeOf(MarkDecoration.prototype), \"range\", this).call(this, from, to);\n    }\n  }]);\n\n  return MarkDecoration;\n}(Decoration);\n\nMarkDecoration.prototype.point = false;\n\nvar LineDecoration = /*#__PURE__*/function (_Decoration2) {\n  _inherits(LineDecoration, _Decoration2);\n\n  var _super8 = _createSuper(LineDecoration);\n\n  function LineDecoration(spec) {\n    _classCallCheck(this, LineDecoration);\n\n    return _super8.call(this, -200000000\n    /* Line */\n    , -200000000\n    /* Line */\n    , null, spec);\n  }\n\n  _createClass(LineDecoration, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);\n    }\n  }, {\n    key: \"range\",\n    value: function range(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      if (to != from) throw new RangeError(\"Line decoration ranges must be zero-length\");\n      return _get(_getPrototypeOf(LineDecoration.prototype), \"range\", this).call(this, from, to);\n    }\n  }]);\n\n  return LineDecoration;\n}(Decoration);\n\nLineDecoration.prototype.mapMode = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackBefore;\nLineDecoration.prototype.point = true;\n\nvar PointDecoration = /*#__PURE__*/function (_Decoration3) {\n  _inherits(PointDecoration, _Decoration3);\n\n  var _super9 = _createSuper(PointDecoration);\n\n  function PointDecoration(spec, startSide, endSide, block, widget, isReplace) {\n    var _this7;\n\n    _classCallCheck(this, PointDecoration);\n\n    _this7 = _super9.call(this, startSide, endSide, widget, spec);\n    _this7.block = block;\n    _this7.isReplace = isReplace;\n    _this7.mapMode = !block ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackDel : startSide <= 0 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackBefore : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.MapMode.TrackAfter;\n    return _this7;\n  } // Only relevant when this.block == true\n\n\n  _createClass(PointDecoration, [{\n    key: \"type\",\n    get: function get() {\n      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;\n    }\n  }, {\n    key: \"heightRelevant\",\n    get: function get() {\n      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;\n    }\n  }, {\n    key: \"range\",\n    value: function range(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError(\"Invalid range for replacement decoration\");\n      if (!this.isReplace && to != from) throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n      return _get(_getPrototypeOf(PointDecoration.prototype), \"range\", this).call(this, from, to);\n    }\n  }]);\n\n  return PointDecoration;\n}(Decoration);\n\nPointDecoration.prototype.point = true;\n\nfunction getInclusive(spec) {\n  var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var start = spec.inclusiveStart,\n      end = spec.inclusiveEnd;\n  if (start == null) start = spec.inclusive;\n  if (end == null) end = spec.inclusive;\n  return {\n    start: start !== null && start !== void 0 ? start : block,\n    end: end !== null && end !== void 0 ? end : block\n  };\n}\n\nfunction widgetsEq(a, b) {\n  return a == b || !!(a && b && a.compare(b));\n}\n\nfunction addRange(from, to, ranges) {\n  var margin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var last = ranges.length - 1;\n  if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);else ranges.push(from, to);\n}\n\nvar LineView = /*#__PURE__*/function (_ContentView5) {\n  _inherits(LineView, _ContentView5);\n\n  var _super10 = _createSuper(LineView);\n\n  function LineView() {\n    var _this8;\n\n    _classCallCheck(this, LineView);\n\n    _this8 = _super10.apply(this, arguments);\n    _this8.children = [];\n    _this8.length = 0;\n    _this8.prevAttrs = undefined;\n    _this8.attrs = null;\n    _this8.breakAfter = 0;\n    return _this8;\n  } // Consumes source\n\n\n  _createClass(LineView, [{\n    key: \"merge\",\n    value: function merge(from, to, source, hasStart, openStart, openEnd) {\n      if (source) {\n        if (!(source instanceof LineView)) return false;\n        if (!this.dom) source.transferDOM(this); // Reuse source.dom when appropriate\n      }\n\n      if (hasStart) this.setDeco(source ? source.attrs : null);\n      mergeChildrenInto(this, from, to, source ? source.children : [], openStart, openEnd);\n      return true;\n    }\n  }, {\n    key: \"split\",\n    value: function split(at) {\n      var end = new LineView();\n      end.breakAfter = this.breakAfter;\n      if (this.length == 0) return end;\n\n      var _this$childPos = this.childPos(at),\n          i = _this$childPos.i,\n          off = _this$childPos.off;\n\n      if (off) {\n        end.append(this.children[i].split(off), 0);\n        this.children[i].merge(off, this.children[i].length, null, false, 0, 0);\n        i++;\n      }\n\n      for (var j = i; j < this.children.length; j++) {\n        end.append(this.children[j], 0);\n      }\n\n      while (i > 0 && this.children[i - 1].length == 0) {\n        this.children[--i].destroy();\n      }\n\n      this.children.length = i;\n      this.markDirty();\n      this.length = at;\n      return end;\n    }\n  }, {\n    key: \"transferDOM\",\n    value: function transferDOM(other) {\n      if (!this.dom) return;\n      other.setDOM(this.dom);\n      other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;\n      this.prevAttrs = undefined;\n      this.dom = null;\n    }\n  }, {\n    key: \"setDeco\",\n    value: function setDeco(attrs) {\n      if (!attrsEq(this.attrs, attrs)) {\n        if (this.dom) {\n          this.prevAttrs = this.attrs;\n          this.markDirty();\n        }\n\n        this.attrs = attrs;\n      }\n    }\n  }, {\n    key: \"append\",\n    value: function append(child, openStart) {\n      joinInlineInto(this, child, openStart);\n    } // Only called when building a line view in ContentBuilder\n\n  }, {\n    key: \"addLineDeco\",\n    value: function addLineDeco(deco) {\n      var attrs = deco.spec.attributes,\n          cls = deco.spec[\"class\"];\n      if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});\n      if (cls) this.attrs = combineAttrs({\n        \"class\": cls\n      }, this.attrs || {});\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return inlineDOMAtPos(this.dom, this.children, pos);\n    }\n  }, {\n    key: \"reuseDOM\",\n    value: function reuseDOM(node) {\n      if (node.nodeName == \"DIV\") {\n        this.setDOM(node);\n        this.dirty |= 4\n        /* Attrs */\n        | 2\n        /* Node */\n        ;\n      }\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(track) {\n      var _a;\n\n      if (!this.dom) {\n        this.setDOM(document.createElement(\"div\"));\n        this.dom.className = \"cm-line\";\n        this.prevAttrs = this.attrs ? null : undefined;\n      } else if (this.dirty & 4\n      /* Attrs */\n      ) {\n        clearAttributes(this.dom);\n        this.dom.className = \"cm-line\";\n        this.prevAttrs = this.attrs ? null : undefined;\n      }\n\n      if (this.prevAttrs !== undefined) {\n        _updateAttrs(this.dom, this.prevAttrs, this.attrs);\n\n        this.dom.classList.add(\"cm-line\");\n        this.prevAttrs = undefined;\n      }\n\n      _get(_getPrototypeOf(LineView.prototype), \"sync\", this).call(this, track);\n\n      var last = this.dom.lastChild;\n\n      while (last && ContentView.get(last) instanceof MarkView) {\n        last = last.lastChild;\n      }\n\n      if (!last || last.nodeName != \"BR\" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some(function (ch) {\n        return ch instanceof TextView;\n      }))) {\n        var hack = document.createElement(\"BR\");\n        hack.cmIgnore = true;\n        this.dom.appendChild(hack);\n      }\n    }\n  }, {\n    key: \"measureTextSize\",\n    value: function measureTextSize() {\n      if (this.children.length == 0 || this.length > 20) return null;\n      var totalWidth = 0;\n\n      var _iterator7 = _createForOfIteratorHelper(this.children),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var child = _step7.value;\n          if (!(child instanceof TextView)) return null;\n          var rects = clientRectsFor(child.dom);\n          if (rects.length != 1) return null;\n          totalWidth += rects[0].width;\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return {\n        lineHeight: this.dom.getBoundingClientRect().height,\n        charWidth: totalWidth / this.length\n      };\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos, side) {\n      return coordsInChildren(this, pos, side);\n    }\n  }, {\n    key: \"become\",\n    value: function become(_other) {\n      return false;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return BlockType.Text;\n    }\n  }], [{\n    key: \"find\",\n    value: function find(docView, pos) {\n      for (var i = 0, off = 0; i < docView.children.length; i++) {\n        var block = docView.children[i],\n            end = off + block.length;\n\n        if (end >= pos) {\n          if (block instanceof LineView) return block;\n          if (end > pos) break;\n        }\n\n        off = end + block.breakAfter;\n      }\n\n      return null;\n    }\n  }]);\n\n  return LineView;\n}(ContentView);\n\nvar BlockWidgetView = /*#__PURE__*/function (_ContentView6) {\n  _inherits(BlockWidgetView, _ContentView6);\n\n  var _super11 = _createSuper(BlockWidgetView);\n\n  function BlockWidgetView(widget, length, type) {\n    var _this9;\n\n    _classCallCheck(this, BlockWidgetView);\n\n    _this9 = _super11.call(this);\n    _this9.widget = widget;\n    _this9.length = length;\n    _this9.type = type;\n    _this9.breakAfter = 0;\n    return _this9;\n  }\n\n  _createClass(BlockWidgetView, [{\n    key: \"merge\",\n    value: function merge(from, to, source, _takeDeco, openStart, openEnd) {\n      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;\n      this.length = from + (source ? source.length : 0) + (this.length - to);\n      return true;\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);\n    }\n  }, {\n    key: \"split\",\n    value: function split(at) {\n      var len = this.length - at;\n      this.length = at;\n      var end = new BlockWidgetView(this.widget, len, this.type);\n      end.breakAfter = this.breakAfter;\n      return end;\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return noChildren;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (!this.dom || !this.widget.updateDOM(this.dom)) {\n        this.setDOM(this.widget.toDOM(this.editorView));\n        this.dom.contentEditable = \"false\";\n      }\n    }\n  }, {\n    key: \"overrideDOMText\",\n    get: function get() {\n      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    }\n  }, {\n    key: \"domBoundsAround\",\n    value: function domBoundsAround() {\n      return null;\n    }\n  }, {\n    key: \"become\",\n    value: function become(other) {\n      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {\n        if (!other.widget.eq(this.widget)) this.markDirty(true);\n        this.widget = other.widget;\n        this.length = other.length;\n        this.breakAfter = other.breakAfter;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation() {\n      return true;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent(event) {\n      return this.widget.ignoreEvent(event);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(BlockWidgetView.prototype), \"destroy\", this).call(this);\n\n      if (this.dom) this.widget.destroy(this.dom);\n    }\n  }]);\n\n  return BlockWidgetView;\n}(ContentView);\n\nvar ContentBuilder = /*#__PURE__*/function () {\n  function ContentBuilder(doc, pos, end, disallowBlockEffectsBelow) {\n    _classCallCheck(this, ContentBuilder);\n\n    this.doc = doc;\n    this.pos = pos;\n    this.end = end;\n    this.disallowBlockEffectsBelow = disallowBlockEffectsBelow;\n    this.content = [];\n    this.curLine = null;\n    this.breakAtStart = 0;\n    this.pendingBuffer = 0\n    /* No */\n    ; // Set to false directly after a widget that covers the position after it\n\n    this.atCursorPos = true;\n    this.openStart = -1;\n    this.openEnd = -1;\n    this.text = \"\";\n    this.textOff = 0;\n    this.cursor = doc.iter();\n    this.skip = pos;\n  }\n\n  _createClass(ContentBuilder, [{\n    key: \"posCovered\",\n    value: function posCovered() {\n      if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n      var last = this.content[this.content.length - 1];\n      return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);\n    }\n  }, {\n    key: \"getLine\",\n    value: function getLine() {\n      if (!this.curLine) {\n        this.content.push(this.curLine = new LineView());\n        this.atCursorPos = true;\n      }\n\n      return this.curLine;\n    }\n  }, {\n    key: \"flushBuffer\",\n    value: function flushBuffer(active) {\n      if (this.pendingBuffer) {\n        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);\n        this.pendingBuffer = 0\n        /* No */\n        ;\n      }\n    }\n  }, {\n    key: \"addBlockWidget\",\n    value: function addBlockWidget(view) {\n      this.flushBuffer([]);\n      this.curLine = null;\n      this.content.push(view);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(openEnd) {\n      if (!openEnd) this.flushBuffer([]);else this.pendingBuffer = 0\n      /* No */\n      ;\n      if (!this.posCovered()) this.getLine();\n    }\n  }, {\n    key: \"buildText\",\n    value: function buildText(length, active, openStart) {\n      while (length > 0) {\n        if (this.textOff == this.text.length) {\n          var _this$cursor$next = this.cursor.next(this.skip),\n              value = _this$cursor$next.value,\n              lineBreak = _this$cursor$next.lineBreak,\n              done = _this$cursor$next.done;\n\n          this.skip = 0;\n          if (done) throw new Error(\"Ran out of text content when drawing inline views\");\n\n          if (lineBreak) {\n            if (!this.posCovered()) this.getLine();\n            if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;else this.breakAtStart = 1;\n            this.flushBuffer([]);\n            this.curLine = null;\n            length--;\n            continue;\n          } else {\n            this.text = value;\n            this.textOff = 0;\n          }\n        }\n\n        var take = Math.min(this.text.length - this.textOff, length, 512\n        /* Chunk */\n        );\n        this.flushBuffer(active.slice(0, openStart));\n        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);\n        this.atCursorPos = true;\n        this.textOff += take;\n        length -= take;\n        openStart = 0;\n      }\n    }\n  }, {\n    key: \"span\",\n    value: function span(from, to, active, openStart) {\n      this.buildText(to - from, active, openStart);\n      this.pos = to;\n      if (this.openStart < 0) this.openStart = openStart;\n    }\n  }, {\n    key: \"point\",\n    value: function point(from, to, deco, active, openStart) {\n      var len = to - from;\n\n      if (deco instanceof PointDecoration) {\n        if (deco.block) {\n          var type = deco.type;\n          if (type == BlockType.WidgetAfter && !this.posCovered()) this.getLine();\n          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget(\"div\"), len, type));\n        } else {\n          var view = WidgetView.create(deco.widget || new NullWidget(\"span\"), len, deco.startSide);\n          var cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);\n          var cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);\n          var line = this.getLine();\n          if (this.pendingBuffer == 2\n          /* IfCursor */\n          && !cursorBefore) this.pendingBuffer = 0\n          /* No */\n          ;\n          this.flushBuffer(active);\n\n          if (cursorBefore) {\n            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);\n            openStart = active.length + Math.max(0, openStart - active.length);\n          }\n\n          line.append(wrapMarks(view, active), openStart);\n          this.atCursorPos = cursorAfter;\n          this.pendingBuffer = !cursorAfter ? 0\n          /* No */\n          : from < to ? 1\n          /* Yes */\n          : 2\n          /* IfCursor */\n          ;\n        }\n      } else if (this.doc.lineAt(this.pos).from == this.pos) {\n        // Line decoration\n        this.getLine().addLineDeco(deco);\n      }\n\n      if (len) {\n        // Advance the iterator past the replaced content\n        if (this.textOff + len <= this.text.length) {\n          this.textOff += len;\n        } else {\n          this.skip += len - (this.text.length - this.textOff);\n          this.text = \"\";\n          this.textOff = 0;\n        }\n\n        this.pos = to;\n      }\n\n      if (this.openStart < 0) this.openStart = openStart;\n    }\n  }, {\n    key: \"filterPoint\",\n    value: function filterPoint(from, to, value, index) {\n      if (index >= this.disallowBlockEffectsBelow || !(value instanceof PointDecoration)) return true;\n      if (value.block) throw new RangeError(\"Block decorations may not be specified via plugins\");\n      return to <= this.doc.lineAt(this.pos).to;\n    }\n  }], [{\n    key: \"build\",\n    value: function build(text, from, to, decorations, pluginDecorationLength) {\n      var builder = new ContentBuilder(text, from, to, pluginDecorationLength);\n      builder.openEnd = _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(decorations, from, to, builder);\n      if (builder.openStart < 0) builder.openStart = builder.openEnd;\n      builder.finish(builder.openEnd);\n      return builder;\n    }\n  }]);\n\n  return ContentBuilder;\n}();\n\nfunction wrapMarks(view, active) {\n  var _iterator8 = _createForOfIteratorHelper(active),\n      _step8;\n\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var mark = _step8.value;\n      view = new MarkView(mark, [view], view.length);\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n\n  return view;\n}\n\nvar NullWidget = /*#__PURE__*/function (_WidgetType) {\n  _inherits(NullWidget, _WidgetType);\n\n  var _super12 = _createSuper(NullWidget);\n\n  function NullWidget(tag) {\n    var _this10;\n\n    _classCallCheck(this, NullWidget);\n\n    _this10 = _super12.call(this);\n    _this10.tag = tag;\n    return _this10;\n  }\n\n  _createClass(NullWidget, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other.tag == this.tag;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM() {\n      return document.createElement(this.tag);\n    }\n  }, {\n    key: \"updateDOM\",\n    value: function updateDOM(elt) {\n      return elt.nodeName.toLowerCase() == this.tag;\n    }\n  }]);\n\n  return NullWidget;\n}(WidgetType);\n\nvar none = [];\nvar clickAddsSelectionRange = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar dragMovesSelection$1 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar mouseSelectionStyle = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar exceptionSink = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar updateListener = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar inputHandler = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define(); // FIXME remove\n\nvar scrollTo = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define({\n  map: function map(range, changes) {\n    return range.map(changes);\n  }\n}); // FIXME remove\n\nvar centerOn = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define({\n  map: function map(range, changes) {\n    return range.map(changes);\n  }\n});\n\nvar ScrollTarget = /*#__PURE__*/function () {\n  function ScrollTarget(range) {\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"nearest\";\n    var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"nearest\";\n    var yMargin = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n    var xMargin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 5;\n\n    _classCallCheck(this, ScrollTarget);\n\n    this.range = range;\n    this.y = y;\n    this.x = x;\n    this.yMargin = yMargin;\n    this.xMargin = xMargin;\n  }\n\n  _createClass(ScrollTarget, [{\n    key: \"map\",\n    value: function map(changes) {\n      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);\n    }\n  }]);\n\n  return ScrollTarget;\n}();\n\nvar _scrollIntoView2 = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define({\n  map: function map(t, ch) {\n    return t.map(ch);\n  }\n});\n/**\nLog or report an unhandled exception in client code. Should\nprobably only be used by extension code that allows client code to\nprovide functions, and calls those functions in a context where an\nexception can't be propagated to calling code in a reasonable way\n(for example when in an event handler).\n\nEither calls a handler registered with\n[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),\n`window.onerror`, if defined, or `console.error` (in which case\nit'll pass `context`, when given, as first argument).\n*/\n\n\nfunction logException(state, exception, context) {\n  var handler = state.facet(exceptionSink);\n  if (handler.length) handler[0](exception);else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);else if (context) console.error(context + \":\", exception);else console.error(exception);\n}\n\nvar editable = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n  combine: function combine(values) {\n    return values.length ? values[0] : true;\n  }\n});\n/**\nUsed to [declare](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide) which\n[fields](https://codemirror.net/6/docs/ref/#view.PluginValue) a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin)\nprovides.\n*/\n\nvar PluginFieldProvider =\n/**\n@internal\n*/\nfunction PluginFieldProvider(\n/**\n@internal\n*/\nfield,\n/**\n@internal\n*/\nget) {\n  _classCallCheck(this, PluginFieldProvider);\n\n  this.field = field;\n  this.get = get;\n};\n/**\nPlugin fields are a mechanism for allowing plugins to provide\nvalues that can be retrieved through the\n[`pluginField`](https://codemirror.net/6/docs/ref/#view.EditorView.pluginField) view method.\n*/\n\n\nvar PluginField = /*#__PURE__*/function () {\n  function PluginField() {\n    _classCallCheck(this, PluginField);\n  }\n\n  _createClass(PluginField, [{\n    key: \"from\",\n    value:\n    /**\n    Create a [provider](https://codemirror.net/6/docs/ref/#view.PluginFieldProvider) for this field,\n    to use with a plugin's [provide](https://codemirror.net/6/docs/ref/#view.PluginSpec.provide)\n    option.\n    */\n    function from(get) {\n      return new PluginFieldProvider(this, get);\n    }\n    /**\n    Define a new plugin field.\n    */\n\n  }], [{\n    key: \"define\",\n    value: function define() {\n      return new PluginField();\n    }\n  }]);\n\n  return PluginField;\n}();\n/**\nThis field can be used by plugins to provide\n[decorations](https://codemirror.net/6/docs/ref/#view.Decoration).\n\n**Note**: For reasons of data flow (plugins are only updated\nafter the viewport is computed), decorations produced by plugins\nare _not_ taken into account when predicting the vertical layout\nstructure of the editor. They **must not** introduce block\nwidgets (that will raise an error) or replacing decorations that\ncover line breaks (these will be ignored if they occur). Such\ndecorations, or others that cause a large amount of vertical\nsize shift compared to the undecorated content, should be\nprovided through the state-level [`decorations`\nfacet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations) instead.\n*/\n\n\nPluginField.decorations = /*@__PURE__*/PluginField.define();\n/**\nUsed to provide ranges that should be treated as atoms as far as\ncursor motion is concerned. This causes methods like\n[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and\n[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the\ncommands built on top of them) to skip across such regions when\na selection endpoint would enter them. This does _not_ prevent\ndirect programmatic [selection\nupdates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such\nregions.\n*/\n\nPluginField.atomicRanges = /*@__PURE__*/PluginField.define();\n/**\nPlugins can provide additional scroll margins (space around the\nsides of the scrolling element that should be considered\ninvisible) through this field. This can be useful when the\nplugin introduces elements that cover part of that element (for\nexample a horizontally fixed gutter).\n*/\n\nPluginField.scrollMargins = /*@__PURE__*/PluginField.define();\nvar nextPluginID = 0;\nvar viewPlugin = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\n/**\nView plugins associate stateful values with a view. They can\ninfluence the way the content is drawn, and are notified of things\nthat happen in the view.\n*/\n\nvar ViewPlugin = /*#__PURE__*/function () {\n  function ViewPlugin(\n  /**\n  @internal\n  */\n  id,\n  /**\n  @internal\n  */\n  create,\n  /**\n  @internal\n  */\n  fields) {\n    _classCallCheck(this, ViewPlugin);\n\n    this.id = id;\n    this.create = create;\n    this.fields = fields;\n    this.extension = viewPlugin.of(this);\n  }\n  /**\n  Define a plugin from a constructor function that creates the\n  plugin's value, given an editor view.\n  */\n\n\n  _createClass(ViewPlugin, null, [{\n    key: \"define\",\n    value: function define(create, spec) {\n      var _ref3 = spec || {},\n          eventHandlers = _ref3.eventHandlers,\n          provide = _ref3.provide,\n          decorations = _ref3.decorations;\n\n      var fields = [];\n\n      if (provide) {\n        var _iterator9 = _createForOfIteratorHelper(Array.isArray(provide) ? provide : [provide]),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var provider = _step9.value;\n            fields.push(provider);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      }\n\n      if (eventHandlers) fields.push(domEventHandlers.from(function (value) {\n        return {\n          plugin: value,\n          handlers: eventHandlers\n        };\n      }));\n      if (decorations) fields.push(PluginField.decorations.from(decorations));\n      return new ViewPlugin(nextPluginID++, create, fields);\n    }\n    /**\n    Create a plugin for a class whose constructor takes a single\n    editor view as argument.\n    */\n\n  }, {\n    key: \"fromClass\",\n    value: function fromClass(cls, spec) {\n      return ViewPlugin.define(function (view) {\n        return new cls(view);\n      }, spec);\n    }\n  }]);\n\n  return ViewPlugin;\n}();\n\nvar domEventHandlers = /*@__PURE__*/PluginField.define();\n\nvar PluginInstance = /*#__PURE__*/function () {\n  function PluginInstance(spec) {\n    _classCallCheck(this, PluginInstance);\n\n    this.spec = spec; // When starting an update, all plugins have this field set to the\n    // update object, indicating they need to be updated. When finished\n    // updating, it is set to `false`. Retrieving a plugin that needs to\n    // be updated with `view.plugin` forces an eager update.\n\n    this.mustUpdate = null; // This is null when the plugin is initially created, but\n    // initialized on the first update.\n\n    this.value = null;\n  }\n\n  _createClass(PluginInstance, [{\n    key: \"takeField\",\n    value: function takeField(type, target) {\n      if (this.spec) {\n        var _iterator10 = _createForOfIteratorHelper(this.spec.fields),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _step10$value = _step10.value,\n                field = _step10$value.field,\n                get = _step10$value.get;\n            if (field == type) target.push(get(this.value));\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(view) {\n      if (!this.value) {\n        if (this.spec) {\n          try {\n            this.value = this.spec.create(view);\n          } catch (e) {\n            logException(view.state, e, \"CodeMirror plugin crashed\");\n            this.deactivate();\n          }\n        }\n      } else if (this.mustUpdate) {\n        var update = this.mustUpdate;\n        this.mustUpdate = null;\n\n        if (this.value.update) {\n          try {\n            this.value.update(update);\n          } catch (e) {\n            logException(update.state, e, \"CodeMirror plugin crashed\");\n            if (this.value.destroy) try {\n              this.value.destroy();\n            } catch (_) {}\n            this.deactivate();\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(view) {\n      var _a;\n\n      if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {\n        try {\n          this.value.destroy();\n        } catch (e) {\n          logException(view.state, e, \"CodeMirror plugin crashed\");\n        }\n      }\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      this.spec = this.value = null;\n    }\n  }]);\n\n  return PluginInstance;\n}();\n\nvar editorAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar contentAttributes = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define(); // Provide decorations\n\nvar decorations = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\nvar styleModule = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define();\n\nvar ChangedRange = /*#__PURE__*/function () {\n  function ChangedRange(fromA, toA, fromB, toB) {\n    _classCallCheck(this, ChangedRange);\n\n    this.fromA = fromA;\n    this.toA = toA;\n    this.fromB = fromB;\n    this.toB = toB;\n  }\n\n  _createClass(ChangedRange, [{\n    key: \"join\",\n    value: function join(other) {\n      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));\n    }\n  }, {\n    key: \"addToSet\",\n    value: function addToSet(set) {\n      var i = set.length,\n          me = this;\n\n      for (; i > 0; i--) {\n        var range = set[i - 1];\n        if (range.fromA > me.toA) continue;\n        if (range.toA < me.fromA) break;\n        me = me.join(range);\n        set.splice(i - 1, 1);\n      }\n\n      set.splice(i, 0, me);\n      return set;\n    }\n  }], [{\n    key: \"extendWithRanges\",\n    value: function extendWithRanges(diff, ranges) {\n      if (ranges.length == 0) return diff;\n      var result = [];\n\n      for (var dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {\n        var next = dI == diff.length ? null : diff[dI],\n            off = posA - posB;\n        var end = next ? next.fromB : 1e9;\n\n        while (rI < ranges.length && ranges[rI] < end) {\n          var from = ranges[rI],\n              to = ranges[rI + 1];\n          var fromB = Math.max(posB, from),\n              toB = Math.min(end, to);\n          if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);\n          if (to > end) break;else rI += 2;\n        }\n\n        if (!next) return result;\n        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);\n        posA = next.toA;\n        posB = next.toB;\n      }\n    }\n  }]);\n\n  return ChangedRange;\n}();\n/**\nView [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this\nclass, which describe what happened, whenever the view is updated.\n*/\n\n\nvar ViewUpdate = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function ViewUpdate(\n  /**\n  The editor view that the update is associated with.\n  */\n  view,\n  /**\n  The new editor state.\n  */\n  state) {\n    var transactions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : none;\n\n    _classCallCheck(this, ViewUpdate);\n\n    this.view = view;\n    this.state = state;\n    this.transactions = transactions;\n    /**\n    @internal\n    */\n\n    this.flags = 0;\n    this.startState = view.state;\n    this.changes = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.ChangeSet.empty(this.startState.doc.length);\n\n    var _iterator11 = _createForOfIteratorHelper(transactions),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var tr = _step11.value;\n        this.changes = this.changes.compose(tr.changes);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n\n    var changedRanges = [];\n    this.changes.iterChangedRanges(function (fromA, toA, fromB, toB) {\n      return changedRanges.push(new ChangedRange(fromA, toA, fromB, toB));\n    });\n    this.changedRanges = changedRanges;\n    var focus = view.hasFocus;\n\n    if (focus != view.inputState.notifiedFocused) {\n      view.inputState.notifiedFocused = focus;\n      this.flags |= 1\n      /* Focus */\n      ;\n    }\n  }\n  /**\n  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n  update.\n  */\n\n\n  _createClass(ViewUpdate, [{\n    key: \"viewportChanged\",\n    get: function get() {\n      return (this.flags & 4\n      /* Viewport */\n      ) > 0;\n    }\n    /**\n    Indicates whether the height of an element in the editor changed\n    in this update.\n    */\n\n  }, {\n    key: \"heightChanged\",\n    get: function get() {\n      return (this.flags & 2\n      /* Height */\n      ) > 0;\n    }\n    /**\n    Returns true when the document was modified or the size of the\n    editor, or elements within the editor, changed.\n    */\n\n  }, {\n    key: \"geometryChanged\",\n    get: function get() {\n      return this.docChanged || (this.flags & (8\n      /* Geometry */\n      | 2\n      /* Height */\n      )) > 0;\n    }\n    /**\n    True when this update indicates a focus change.\n    */\n\n  }, {\n    key: \"focusChanged\",\n    get: function get() {\n      return (this.flags & 1\n      /* Focus */\n      ) > 0;\n    }\n    /**\n    Whether the document changed in this update.\n    */\n\n  }, {\n    key: \"docChanged\",\n    get: function get() {\n      return !this.changes.empty;\n    }\n    /**\n    Whether the selection was explicitly set in this update.\n    */\n\n  }, {\n    key: \"selectionSet\",\n    get: function get() {\n      return this.transactions.some(function (tr) {\n        return tr.selection;\n      });\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this.flags == 0 && this.transactions.length == 0;\n    }\n  }]);\n\n  return ViewUpdate;\n}();\n/**\nUsed to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n*/\n\n\nvar Direction = /*@__PURE__*/function (Direction) {\n  // (These are chosen to match the base levels, in bidi algorithm\n  // terms, of spans in that direction.)\n\n  /**\n  Left-to-right.\n  */\n  Direction[Direction[\"LTR\"] = 0] = \"LTR\";\n  /**\n  Right-to-left.\n  */\n\n  Direction[Direction[\"RTL\"] = 1] = \"RTL\";\n  return Direction;\n}(Direction || (Direction = {}));\n\nvar LTR = Direction.LTR,\n    RTL = Direction.RTL; // Decode a string with each type encoded as log2(type)\n\nfunction dec(str) {\n  var result = [];\n\n  for (var i = 0; i < str.length; i++) {\n    result.push(1 << +str[i]);\n  }\n\n  return result;\n} // Character types for codepoints 0 to 0xf8\n\n\nvar LowTypes = /*@__PURE__*/dec(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\"); // Character types for codepoints 0x600 to 0x6f9\n\nvar ArabicTypes = /*@__PURE__*/dec(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\");\nvar Brackets = /*@__PURE__*/Object.create(null),\n    BracketStack = []; // There's a lot more in\n// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,\n// which are left out to keep code size down.\n\nfor (var _i3 = 0, _arr2 = [\"()\", \"[]\", \"{}\"]; _i3 < _arr2.length; _i3++) {\n  var p = _arr2[_i3];\n  var l = /*@__PURE__*/p.charCodeAt(0),\n      r = /*@__PURE__*/p.charCodeAt(1);\n  Brackets[l] = r;\n  Brackets[r] = -l;\n}\n\nfunction charType(ch) {\n  return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2\n  /* R */\n  : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4\n  /* AL */\n  : 0x2000 <= ch && ch <= 0x200b ? 256\n  /* NI */\n  : ch == 0x200c ? 256\n  /* NI */\n  : 1\n  /* L */\n  ;\n}\n\nvar BidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n/**\nRepresents a contiguous range of text that has a single direction\n(as in left-to-right or right-to-left).\n*/\n\nvar BidiSpan = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function BidiSpan(\n  /**\n  The start of the span (relative to the start of the line).\n  */\n  from,\n  /**\n  The end of the span.\n  */\n  to,\n  /**\n  The [\"bidi\n  level\"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)\n  of the span (in this context, 0 means\n  left-to-right, 1 means right-to-left, 2 means left-to-right\n  number inside right-to-left text).\n  */\n  level) {\n    _classCallCheck(this, BidiSpan);\n\n    this.from = from;\n    this.to = to;\n    this.level = level;\n  }\n  /**\n  The direction of this span.\n  */\n\n\n  _createClass(BidiSpan, [{\n    key: \"dir\",\n    get: function get() {\n      return this.level % 2 ? RTL : LTR;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"side\",\n    value: function side(end, dir) {\n      return this.dir == dir == end ? this.to : this.from;\n    }\n    /**\n    @internal\n    */\n\n  }], [{\n    key: \"find\",\n    value: function find(order, index, level, assoc) {\n      var maybe = -1;\n\n      for (var i = 0; i < order.length; i++) {\n        var span = order[i];\n\n        if (span.from <= index && span.to >= index) {\n          if (span.level == level) return i; // When multiple spans match, if assoc != 0, take the one that\n          // covers that side, otherwise take the one with the minimum\n          // level.\n\n          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;\n        }\n      }\n\n      if (maybe < 0) throw new RangeError(\"Index out of range\");\n      return maybe;\n    }\n  }]);\n\n  return BidiSpan;\n}(); // Reused array of character types\n\n\nvar types = [];\n\nfunction computeOrder(line, direction) {\n  var len = line.length,\n      outerType = direction == LTR ? 1\n  /* L */\n  : 2\n  /* R */\n  ,\n      oppositeType = direction == LTR ? 2\n  /* R */\n  : 1\n  /* L */\n  ;\n  if (!line || outerType == 1\n  /* L */\n  && !BidiRE.test(line)) return trivialOrder(len); // W1. Examine each non-spacing mark (NSM) in the level run, and\n  // change the type of the NSM to the type of the previous\n  // character. If the NSM is at the start of the level run, it will\n  // get the type of sor.\n  // W2. Search backwards from each instance of a European number\n  // until the first strong type (R, L, AL, or sor) is found. If an\n  // AL is found, change the type of the European number to Arabic\n  // number.\n  // W3. Change all ALs to R.\n  // (Left after this: L, R, EN, AN, ET, CS, NI)\n\n  for (var i = 0, prev = outerType, prevStrong = outerType; i < len; i++) {\n    var type = charType(line.charCodeAt(i));\n    if (type == 512\n    /* NSM */\n    ) type = prev;else if (type == 8\n    /* EN */\n    && prevStrong == 4\n    /* AL */\n    ) type = 16\n    /* AN */\n    ;\n    types[i] = type == 4\n    /* AL */\n    ? 2\n    /* R */\n    : type;\n    if (type & 7\n    /* Strong */\n    ) prevStrong = type;\n    prev = type;\n  } // W5. A sequence of European terminators adjacent to European\n  // numbers changes to all European numbers.\n  // W6. Otherwise, separators and terminators change to Other\n  // Neutral.\n  // W7. Search backwards from each instance of a European number\n  // until the first strong type (R, L, or sor) is found. If an L is\n  // found, then change the type of the European number to L.\n  // (Left after this: L, R, EN+AN, NI)\n\n\n  for (var _i4 = 0, _prev = outerType, _prevStrong = outerType; _i4 < len; _i4++) {\n    var _type2 = types[_i4];\n\n    if (_type2 == 128\n    /* CS */\n    ) {\n      if (_i4 < len - 1 && _prev == types[_i4 + 1] && _prev & 24\n      /* Num */\n      ) _type2 = types[_i4] = _prev;else types[_i4] = 256\n      /* NI */\n      ;\n    } else if (_type2 == 64\n    /* ET */\n    ) {\n      var end = _i4 + 1;\n\n      while (end < len && types[end] == 64\n      /* ET */\n      ) {\n        end++;\n      }\n\n      var replace = _i4 && _prev == 8\n      /* EN */\n      || end < len && types[end] == 8\n      /* EN */\n      ? _prevStrong == 1\n      /* L */\n      ? 1\n      /* L */\n      : 8\n      /* EN */\n      : 256\n      /* NI */\n      ;\n\n      for (var j = _i4; j < end; j++) {\n        types[j] = replace;\n      }\n\n      _i4 = end - 1;\n    } else if (_type2 == 8\n    /* EN */\n    && _prevStrong == 1\n    /* L */\n    ) {\n      types[_i4] = 1\n      /* L */\n      ;\n    }\n\n    _prev = _type2;\n    if (_type2 & 7\n    /* Strong */\n    ) _prevStrong = _type2;\n  } // N0. Process bracket pairs in an isolating run sequence\n  // sequentially in the logical order of the text positions of the\n  // opening paired brackets using the logic given below. Within this\n  // scope, bidirectional types EN and AN are treated as R.\n\n\n  for (var _i5 = 0, sI = 0, context = 0, ch, br, _type3; _i5 < len; _i5++) {\n    // Keeps [startIndex, type, strongSeen] triples for each open\n    // bracket on BracketStack.\n    if (br = Brackets[ch = line.charCodeAt(_i5)]) {\n      if (br < 0) {\n        // Closing bracket\n        for (var sJ = sI - 3; sJ >= 0; sJ -= 3) {\n          if (BracketStack[sJ + 1] == -br) {\n            var flags = BracketStack[sJ + 2];\n\n            var _type4 = flags & 2\n            /* EmbedInside */\n            ? outerType : !(flags & 4\n            /* OppositeInside */\n            ) ? 0 : flags & 1\n            /* OppositeBefore */\n            ? oppositeType : outerType;\n\n            if (_type4) types[_i5] = types[BracketStack[sJ]] = _type4;\n            sI = sJ;\n            break;\n          }\n        }\n      } else if (BracketStack.length == 189\n      /* MaxDepth */\n      ) {\n        break;\n      } else {\n        BracketStack[sI++] = _i5;\n        BracketStack[sI++] = ch;\n        BracketStack[sI++] = context;\n      }\n    } else if ((_type3 = types[_i5]) == 2\n    /* R */\n    || _type3 == 1\n    /* L */\n    ) {\n      var embed = _type3 == outerType;\n      context = embed ? 0 : 1\n      /* OppositeBefore */\n      ;\n\n      for (var _sJ = sI - 3; _sJ >= 0; _sJ -= 3) {\n        var cur = BracketStack[_sJ + 2];\n        if (cur & 2\n        /* EmbedInside */\n        ) break;\n\n        if (embed) {\n          BracketStack[_sJ + 2] |= 2\n          /* EmbedInside */\n          ;\n        } else {\n          if (cur & 4\n          /* OppositeInside */\n          ) break;\n          BracketStack[_sJ + 2] |= 4\n          /* OppositeInside */\n          ;\n        }\n      }\n    }\n  } // N1. A sequence of neutrals takes the direction of the\n  // surrounding strong text if the text on both sides has the same\n  // direction. European and Arabic numbers act as if they were R in\n  // terms of their influence on neutrals. Start-of-level-run (sor)\n  // and end-of-level-run (eor) are used at level run boundaries.\n  // N2. Any remaining neutrals take the embedding direction.\n  // (Left after this: L, R, EN+AN)\n\n\n  for (var _i6 = 0; _i6 < len; _i6++) {\n    if (types[_i6] == 256\n    /* NI */\n    ) {\n      var _end = _i6 + 1;\n\n      while (_end < len && types[_end] == 256\n      /* NI */\n      ) {\n        _end++;\n      }\n\n      var beforeL = (_i6 ? types[_i6 - 1] : outerType) == 1\n      /* L */\n      ;\n      var afterL = (_end < len ? types[_end] : outerType) == 1\n      /* L */\n      ;\n\n      var _replace = beforeL == afterL ? beforeL ? 1\n      /* L */\n      : 2\n      /* R */\n      : outerType;\n\n      for (var _j = _i6; _j < _end; _j++) {\n        types[_j] = _replace;\n      }\n\n      _i6 = _end - 1;\n    }\n  } // Here we depart from the documented algorithm, in order to avoid\n  // building up an actual levels array. Since there are only three\n  // levels (0, 1, 2) in an implementation that doesn't take\n  // explicit embedding into account, we can build up the order on\n  // the fly, without following the level-based algorithm.\n\n\n  var order = [];\n\n  if (outerType == 1\n  /* L */\n  ) {\n    for (var _i7 = 0; _i7 < len;) {\n      var start = _i7,\n          rtl = types[_i7++] != 1\n      /* L */\n      ;\n\n      while (_i7 < len && rtl == (types[_i7] != 1\n      /* L */\n      )) {\n        _i7++;\n      }\n\n      if (rtl) {\n        for (var _j2 = _i7; _j2 > start;) {\n          var _end2 = _j2,\n              _l = types[--_j2] != 2\n          /* R */\n          ;\n\n          while (_j2 > start && _l == (types[_j2 - 1] != 2\n          /* R */\n          )) {\n            _j2--;\n          }\n\n          order.push(new BidiSpan(_j2, _end2, _l ? 2 : 1));\n        }\n      } else {\n        order.push(new BidiSpan(start, _i7, 0));\n      }\n    }\n  } else {\n    for (var _i8 = 0; _i8 < len;) {\n      var _start2 = _i8,\n          _rtl = types[_i8++] == 2\n      /* R */\n      ;\n\n      while (_i8 < len && _rtl == (types[_i8] == 2\n      /* R */\n      )) {\n        _i8++;\n      }\n\n      order.push(new BidiSpan(_start2, _i8, _rtl ? 1 : 2));\n    }\n  }\n\n  return order;\n}\n\nfunction trivialOrder(length) {\n  return [new BidiSpan(0, length, 0)];\n}\n\nvar movedOver = \"\";\n\nfunction moveVisually(line, order, dir, start, forward) {\n  var _a;\n\n  var startIndex = start.head - line.from,\n      spanI = -1;\n\n  if (startIndex == 0) {\n    if (!forward || !line.length) return null;\n\n    if (order[0].level != dir) {\n      startIndex = order[0].side(false, dir);\n      spanI = 0;\n    }\n  } else if (startIndex == line.length) {\n    if (forward) return null;\n    var last = order[order.length - 1];\n\n    if (last.level != dir) {\n      startIndex = last.side(true, dir);\n      spanI = order.length - 1;\n    }\n  }\n\n  if (spanI < 0) spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);\n  var span = order[spanI]; // End of span. (But not end of line--that was checked for above.)\n\n  if (startIndex == span.side(forward, dir)) {\n    span = order[spanI += forward ? 1 : -1];\n    startIndex = span.side(!forward, dir);\n  }\n\n  var indexForward = forward == (span.dir == dir);\n  var nextIndex = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, startIndex, indexForward);\n  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));\n  if (nextIndex != span.side(forward, dir)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);\n  var nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];\n  if (!nextSpan && span.level != dir) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);\n  if (nextSpan && nextSpan.level < span.level) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);\n}\n\nvar DOMReader = /*#__PURE__*/function () {\n  function DOMReader(points, view) {\n    _classCallCheck(this, DOMReader);\n\n    this.points = points;\n    this.view = view;\n    this.text = \"\";\n    this.lineBreak = view.state.lineBreak;\n  }\n\n  _createClass(DOMReader, [{\n    key: \"readRange\",\n    value: function readRange(start, end) {\n      if (!start) return this;\n      var parent = start.parentNode;\n\n      for (var cur = start;;) {\n        this.findPointBefore(parent, cur);\n        this.readNode(cur);\n        var next = cur.nextSibling;\n        if (next == end) break;\n        var view = ContentView.get(cur),\n            nextView = ContentView.get(next);\n        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != \"BR\" || cur.cmIgnore)) this.text += this.lineBreak;\n        cur = next;\n      }\n\n      this.findPointBefore(parent, end);\n      return this;\n    }\n  }, {\n    key: \"readTextNode\",\n    value: function readTextNode(node) {\n      var _a, _b;\n\n      var text = node.nodeValue;\n      if (/^\\u200b/.test(text) && ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.contentEditable) == \"false\") text = text.slice(1);\n      if (/\\u200b$/.test(text) && ((_b = node.nextSibling) === null || _b === void 0 ? void 0 : _b.contentEditable) == \"false\") text = text.slice(0, text.length - 1);\n      return text;\n    }\n  }, {\n    key: \"readNode\",\n    value: function readNode(node) {\n      if (node.cmIgnore) return;\n      var view = ContentView.get(node);\n      var fromView = view && view.overrideDOMText;\n      var text;\n      if (fromView != null) text = fromView.sliceString(0, undefined, this.lineBreak);else if (node.nodeType == 3) text = this.readTextNode(node);else if (node.nodeName == \"BR\") text = node.nextSibling ? this.lineBreak : \"\";else if (node.nodeType == 1) this.readRange(node.firstChild, null);\n\n      if (text != null) {\n        this.findPointIn(node, text.length);\n        this.text += text; // Chrome inserts two newlines when pressing shift-enter at the\n        // end of a line. This drops one of those.\n\n        if (browser.chrome && this.view.inputState.lastKeyCode == 13 && !node.nextSibling && /\\n\\n$/.test(this.text)) this.text = this.text.slice(0, -1);\n      }\n    }\n  }, {\n    key: \"findPointBefore\",\n    value: function findPointBefore(node, next) {\n      var _iterator12 = _createForOfIteratorHelper(this.points),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var point = _step12.value;\n          if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }, {\n    key: \"findPointIn\",\n    value: function findPointIn(node, maxLen) {\n      var _iterator13 = _createForOfIteratorHelper(this.points),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var point = _step13.value;\n          if (point.node == node) point.pos = this.text.length + Math.min(point.offset, maxLen);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n  }]);\n\n  return DOMReader;\n}();\n\nfunction isBlockElement(node) {\n  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(node.nodeName);\n}\n\nvar DOMPoint = function DOMPoint(node, offset) {\n  _classCallCheck(this, DOMPoint);\n\n  this.node = node;\n  this.offset = offset;\n  this.pos = -1;\n};\n\nvar DocView = /*#__PURE__*/function (_ContentView7) {\n  _inherits(DocView, _ContentView7);\n\n  var _super13 = _createSuper(DocView);\n\n  function DocView(view) {\n    var _this11;\n\n    _classCallCheck(this, DocView);\n\n    _this11 = _super13.call(this);\n    _this11.view = view;\n    _this11.compositionDeco = Decoration.none;\n    _this11.decorations = [];\n    _this11.pluginDecorationLength = 0; // Track a minimum width for the editor. When measuring sizes in\n    // measureVisibleLineHeights, this is updated to point at the width\n    // of a given element and its extent in the document. When a change\n    // happens in that range, these are reset. That way, once we've seen\n    // a line/element of a given length, we keep the editor wide enough\n    // to fit at least that element, until it is changed, at which point\n    // we forget it again.\n\n    _this11.minWidth = 0;\n    _this11.minWidthFrom = 0;\n    _this11.minWidthTo = 0; // Track whether the DOM selection was set in a lossy way, so that\n    // we don't mess it up when reading it back it\n\n    _this11.impreciseAnchor = null;\n    _this11.impreciseHead = null;\n    _this11.forceSelection = false; // Used by the resize observer to ignore resizes that we caused\n    // ourselves\n\n    _this11.lastUpdate = Date.now();\n\n    _this11.setDOM(view.contentDOM);\n\n    _this11.children = [new LineView()];\n\n    _this11.children[0].setParent(_assertThisInitialized(_this11));\n\n    _this11.updateDeco();\n\n    _this11.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);\n\n    return _this11;\n  }\n\n  _createClass(DocView, [{\n    key: \"root\",\n    get: function get() {\n      return this.view.root;\n    }\n  }, {\n    key: \"editorView\",\n    get: function get() {\n      return this.view;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.view.state.doc.length;\n    } // Update the document view to a given state. scrollIntoView can be\n    // used as a hint to compute a new viewport that includes that\n    // position, if we know the editor is going to scroll that position\n    // into view.\n\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      var _this12 = this;\n\n      var changedRanges = _update.changedRanges;\n\n      if (this.minWidth > 0 && changedRanges.length) {\n        if (!changedRanges.every(function (_ref4) {\n          var fromA = _ref4.fromA,\n              toA = _ref4.toA;\n          return toA < _this12.minWidthFrom || fromA > _this12.minWidthTo;\n        })) {\n          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;\n        } else {\n          this.minWidthFrom = _update.changes.mapPos(this.minWidthFrom, 1);\n          this.minWidthTo = _update.changes.mapPos(this.minWidthTo, 1);\n        }\n      }\n\n      if (this.view.inputState.composing < 0) this.compositionDeco = Decoration.none;else if (_update.transactions.length || this.dirty) this.compositionDeco = computeCompositionDeco(this.view, _update.changes); // When the DOM nodes around the selection are moved to another\n      // parent, Chrome sometimes reports a different selection through\n      // getSelection than the one that it actually shows to the user.\n      // This forces a selection update when lines are joined to work\n      // around that. Issue #54\n\n      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && _update && _update.state.doc.lines != _update.startState.doc.lines) this.forceSelection = true;\n      var prevDeco = this.decorations,\n          deco = this.updateDeco();\n      var decoDiff = findChangedDeco(prevDeco, deco, _update.changes);\n      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);\n\n      if (this.dirty == 0\n      /* Not */\n      && changedRanges.length == 0) {\n        return false;\n      } else {\n        this.updateInner(changedRanges, _update.startState.doc.length);\n        if (_update.transactions.length) this.lastUpdate = Date.now();\n        return true;\n      }\n    } // Used by update and the constructor do perform the actual DOM\n    // update\n\n  }, {\n    key: \"updateInner\",\n    value: function updateInner(changes, oldLength) {\n      var _this13 = this;\n\n      this.view.viewState.mustMeasureContent = true;\n      this.updateChildren(changes, oldLength);\n      var observer = this.view.observer;\n      observer.ignore(function () {\n        // Lock the height during redrawing, since Chrome sometimes\n        // messes with the scroll position during DOM mutation (though\n        // no relayout is triggered and I cannot imagine how it can\n        // recompute the scroll position without a layout)\n        _this13.dom.style.height = _this13.view.viewState.contentHeight + \"px\";\n        _this13.dom.style.minWidth = _this13.minWidth ? _this13.minWidth + \"px\" : \"\"; // Chrome will sometimes, when DOM mutations occur directly\n        // around the selection, get confused and report a different\n        // selection from the one it displays (issue #218). This tries\n        // to detect that situation.\n\n        var track = browser.chrome || browser.ios ? {\n          node: observer.selectionRange.focusNode,\n          written: false\n        } : undefined;\n\n        _this13.sync(track);\n\n        _this13.dirty = 0\n        /* Not */\n        ;\n        if (track && (track.written || observer.selectionRange.focusNode != track.node)) _this13.forceSelection = true;\n        _this13.dom.style.height = \"\";\n      });\n      var gaps = [];\n\n      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {\n        var _iterator14 = _createForOfIteratorHelper(this.children),\n            _step14;\n\n        try {\n          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n            var child = _step14.value;\n            if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);\n          }\n        } catch (err) {\n          _iterator14.e(err);\n        } finally {\n          _iterator14.f();\n        }\n      }\n\n      observer.updateGaps(gaps);\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren(changes, oldLength) {\n      var cursor = this.childCursor(oldLength);\n\n      for (var i = changes.length - 1;; i--) {\n        var next = i >= 0 ? changes[i] : null;\n        if (!next) break;\n        var fromA = next.fromA,\n            toA = next.toA,\n            fromB = next.fromB,\n            toB = next.toB;\n\n        var _ContentBuilder$build = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.pluginDecorationLength),\n            content = _ContentBuilder$build.content,\n            breakAtStart = _ContentBuilder$build.breakAtStart,\n            openStart = _ContentBuilder$build.openStart,\n            openEnd = _ContentBuilder$build.openEnd;\n\n        var _cursor$findPos = cursor.findPos(toA, 1),\n            toI = _cursor$findPos.i,\n            toOff = _cursor$findPos.off;\n\n        var _cursor$findPos2 = cursor.findPos(fromA, -1),\n            fromI = _cursor$findPos2.i,\n            fromOff = _cursor$findPos2.off;\n\n        replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);\n      }\n    } // Sync the DOM selection to this.state.selection\n\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      var _this14 = this;\n\n      var mustRead = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var fromPointer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (mustRead) this.view.observer.readSelectionRange();\n      if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart) return;\n      var force = this.forceSelection;\n      this.forceSelection = false;\n      var main = this.view.state.selection.main; // FIXME need to handle the case where the selection falls inside a block range\n\n      var anchor = this.domAtPos(main.anchor);\n      var head = main.empty ? anchor : this.domAtPos(main.head); // Always reset on Firefox when next to an uneditable node to\n      // avoid invisible cursor bugs (#111)\n\n      if (browser.gecko && main.empty && betweenUneditable(anchor)) {\n        var dummy = document.createTextNode(\"\");\n        this.view.observer.ignore(function () {\n          return anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null);\n        });\n        anchor = head = new DOMPos(dummy, 0);\n        force = true;\n      }\n\n      var domSel = this.view.observer.selectionRange; // If the selection is already here, or in an equivalent position, don't touch it\n\n      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {\n        this.view.observer.ignore(function () {\n          // Chrome Android will hide the virtual keyboard when tapping\n          // inside an uneditable node, and not bring it back when we\n          // move the cursor to its proper position. This tries to\n          // restore the keyboard by cycling focus.\n          if (browser.android && browser.chrome && _this14.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, _this14.dom)) {\n            _this14.dom.blur();\n\n            _this14.dom.focus({\n              preventScroll: true\n            });\n          }\n\n          var rawSel = getSelection(_this14.root);\n\n          if (main.empty) {\n            // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076\n            if (browser.gecko) {\n              var nextTo = nextToUneditable(anchor.node, anchor.offset);\n\n              if (nextTo && nextTo != (1\n              /* Before */\n              | 2\n              /* After */\n              )) {\n                var text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1\n                /* Before */\n                ? 1 : -1);\n                if (text) anchor = new DOMPos(text, nextTo == 1\n                /* Before */\n                ? 0 : text.nodeValue.length);\n              }\n            }\n\n            rawSel.collapse(anchor.node, anchor.offset);\n            if (main.bidiLevel != null && domSel.cursorBidiLevel != null) domSel.cursorBidiLevel = main.bidiLevel;\n          } else if (rawSel.extend) {\n            // Selection.extend can be used to create an 'inverted' selection\n            // (one where the focus is before the anchor), but not all\n            // browsers support it yet.\n            rawSel.collapse(anchor.node, anchor.offset);\n            rawSel.extend(head.node, head.offset);\n          } else {\n            // Primitive (IE) way\n            var range = document.createRange();\n\n            if (main.anchor > main.head) {\n              var _ref5 = [head, anchor];\n              anchor = _ref5[0];\n              head = _ref5[1];\n            }\n\n            range.setEnd(head.node, head.offset);\n            range.setStart(anchor.node, anchor.offset);\n            rawSel.removeAllRanges();\n            rawSel.addRange(range);\n          }\n        });\n        this.view.observer.setSelectionRange(anchor, head);\n      }\n\n      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);\n      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);\n    }\n  }, {\n    key: \"enforceCursorAssoc\",\n    value: function enforceCursorAssoc() {\n      if (this.compositionDeco.size) return;\n      var cursor = this.view.state.selection.main;\n      var sel = getSelection(this.root);\n      if (!cursor.empty || !cursor.assoc || !sel.modify) return;\n      var line = LineView.find(this, cursor.head);\n      if (!line) return;\n      var lineStart = line.posAtStart;\n      if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;\n      var before = this.coordsAt(cursor.head, -1),\n          after = this.coordsAt(cursor.head, 1);\n      if (!before || !after || before.bottom > after.top) return;\n      var dom = this.domAtPos(cursor.head + cursor.assoc);\n      sel.collapse(dom.node, dom.offset);\n      sel.modify(\"move\", cursor.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\");\n    }\n  }, {\n    key: \"mayControlSelection\",\n    value: function mayControlSelection() {\n      return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);\n    }\n  }, {\n    key: \"nearest\",\n    value: function nearest(dom) {\n      for (var cur = dom; cur;) {\n        var domView = ContentView.get(cur);\n        if (domView && domView.rootView == this) return domView;\n        cur = cur.parentNode;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"posFromDOM\",\n    value: function posFromDOM(node, offset) {\n      var view = this.nearest(node);\n      if (!view) throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n      return view.localPosFromDOM(node, offset) + view.posAtStart;\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      var _this$childCursor$fin = this.childCursor().findPos(pos, -1),\n          i = _this$childCursor$fin.i,\n          off = _this$childCursor$fin.off;\n\n      for (; i < this.children.length - 1;) {\n        var child = this.children[i];\n        if (off < child.length || child instanceof LineView) break;\n        i++;\n        off = 0;\n      }\n\n      return this.children[i].domAtPos(off);\n    }\n  }, {\n    key: \"coordsAt\",\n    value: function coordsAt(pos, side) {\n      for (var off = this.length, i = this.children.length - 1;; i--) {\n        var child = this.children[i],\n            start = off - child.breakAfter - child.length;\n        if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2)) return child.coordsAt(pos - start, side);\n        off = start;\n      }\n    }\n  }, {\n    key: \"measureVisibleLineHeights\",\n    value: function measureVisibleLineHeights() {\n      var result = [],\n          _this$view$viewState$ = this.view.viewState.viewport,\n          from = _this$view$viewState$.from,\n          to = _this$view$viewState$.to;\n      var contentWidth = this.view.contentDOM.clientWidth;\n      var isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;\n      var widest = -1;\n\n      for (var pos = 0, i = 0; i < this.children.length; i++) {\n        var child = this.children[i],\n            end = pos + child.length;\n        if (end > to) break;\n\n        if (pos >= from) {\n          var childRect = child.dom.getBoundingClientRect();\n          result.push(childRect.height);\n\n          if (isWider) {\n            var last = child.dom.lastChild;\n            var rects = last ? clientRectsFor(last) : [];\n\n            if (rects.length) {\n              var rect = rects[rects.length - 1];\n              var width = this.view.textDirection == Direction.LTR ? rect.right - childRect.left : childRect.right - rect.left;\n\n              if (width > widest) {\n                widest = width;\n                this.minWidth = contentWidth;\n                this.minWidthFrom = pos;\n                this.minWidthTo = end;\n              }\n            }\n          }\n        }\n\n        pos = end + child.breakAfter;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"measureTextSize\",\n    value: function measureTextSize() {\n      var _this15 = this;\n\n      var _iterator15 = _createForOfIteratorHelper(this.children),\n          _step15;\n\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var child = _step15.value;\n\n          if (child instanceof LineView) {\n            var measure = child.measureTextSize();\n            if (measure) return measure;\n          }\n        } // If no workable line exists, force a layout of a measurable element\n\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      var dummy = document.createElement(\"div\"),\n          lineHeight,\n          charWidth;\n      dummy.className = \"cm-line\";\n      dummy.textContent = \"abc def ghi jkl mno pqr stu\";\n      this.view.observer.ignore(function () {\n        _this15.dom.appendChild(dummy);\n\n        var rect = clientRectsFor(dummy.firstChild)[0];\n        lineHeight = dummy.getBoundingClientRect().height;\n        charWidth = rect ? rect.width / 27 : 7;\n        dummy.remove();\n      });\n      return {\n        lineHeight: lineHeight,\n        charWidth: charWidth\n      };\n    }\n  }, {\n    key: \"childCursor\",\n    value: function childCursor() {\n      var pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.length;\n      // Move back to start of last element when possible, so that\n      // `ChildCursor.findPos` doesn't have to deal with the edge case\n      // of being after the last element.\n      var i = this.children.length;\n      if (i) pos -= this.children[--i].length;\n      return new ChildCursor(this.children, pos, i);\n    }\n  }, {\n    key: \"computeBlockGapDeco\",\n    value: function computeBlockGapDeco() {\n      var deco = [],\n          vs = this.view.viewState;\n\n      for (var pos = 0, i = 0;; i++) {\n        var next = i == vs.viewports.length ? null : vs.viewports[i];\n        var end = next ? next.from - 1 : this.length;\n\n        if (end > pos) {\n          var height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;\n          deco.push(Decoration.replace({\n            widget: new BlockGapWidget(height),\n            block: true,\n            inclusive: true\n          }).range(pos, end));\n        }\n\n        if (!next) break;\n        pos = next.to + 1;\n      }\n\n      return Decoration.set(deco);\n    }\n  }, {\n    key: \"updateDeco\",\n    value: function updateDeco() {\n      var pluginDecorations = this.view.pluginField(PluginField.decorations);\n      this.pluginDecorationLength = pluginDecorations.length;\n      return this.decorations = [].concat(_toConsumableArray(pluginDecorations), _toConsumableArray(this.view.state.facet(decorations)), [this.compositionDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]);\n    }\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView(target) {\n      var range = target.range;\n      var rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),\n          other;\n      if (!rect) return;\n      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {\n        left: Math.min(rect.left, other.left),\n        top: Math.min(rect.top, other.top),\n        right: Math.max(rect.right, other.right),\n        bottom: Math.max(rect.bottom, other.bottom)\n      };\n      var mLeft = 0,\n          mRight = 0,\n          mTop = 0,\n          mBottom = 0;\n\n      var _iterator16 = _createForOfIteratorHelper(this.view.pluginField(PluginField.scrollMargins)),\n          _step16;\n\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var margins = _step16.value;\n\n          if (margins) {\n            var left = margins.left,\n                right = margins.right,\n                top = margins.top,\n                bottom = margins.bottom;\n            if (left != null) mLeft = Math.max(mLeft, left);\n            if (right != null) mRight = Math.max(mRight, right);\n            if (top != null) mTop = Math.max(mTop, top);\n            if (bottom != null) mBottom = Math.max(mBottom, bottom);\n          }\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n\n      var targetRect = {\n        left: rect.left - mLeft,\n        top: rect.top - mTop,\n        right: rect.right + mRight,\n        bottom: rect.bottom + mBottom\n      };\n      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);\n    }\n  }]);\n\n  return DocView;\n}(ContentView);\n\nfunction betweenUneditable(pos) {\n  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == \"false\") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == \"false\");\n}\n\nvar BlockGapWidget = /*#__PURE__*/function (_WidgetType2) {\n  _inherits(BlockGapWidget, _WidgetType2);\n\n  var _super14 = _createSuper(BlockGapWidget);\n\n  function BlockGapWidget(height) {\n    var _this16;\n\n    _classCallCheck(this, BlockGapWidget);\n\n    _this16 = _super14.call(this);\n    _this16.height = height;\n    return _this16;\n  }\n\n  _createClass(BlockGapWidget, [{\n    key: \"toDOM\",\n    value: function toDOM() {\n      var elt = document.createElement(\"div\");\n      this.updateDOM(elt);\n      return elt;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other.height == this.height;\n    }\n  }, {\n    key: \"updateDOM\",\n    value: function updateDOM(elt) {\n      elt.style.height = this.height + \"px\";\n      return true;\n    }\n  }, {\n    key: \"estimatedHeight\",\n    get: function get() {\n      return this.height;\n    }\n  }]);\n\n  return BlockGapWidget;\n}(WidgetType);\n\nfunction compositionSurroundingNode(view) {\n  var sel = view.observer.selectionRange;\n  var textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);\n  if (!textNode) return null;\n  var cView = view.docView.nearest(textNode);\n  if (!cView) return null;\n\n  if (cView instanceof LineView) {\n    var topNode = textNode;\n\n    while (topNode.parentNode != cView.dom) {\n      topNode = topNode.parentNode;\n    }\n\n    var prev = topNode.previousSibling;\n\n    while (prev && !ContentView.get(prev)) {\n      prev = prev.previousSibling;\n    }\n\n    var pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;\n    return {\n      from: pos,\n      to: pos,\n      node: topNode,\n      text: textNode\n    };\n  } else {\n    for (;;) {\n      var _cView = cView,\n          parent = _cView.parent;\n      if (!parent) return null;\n      if (parent instanceof LineView) break;\n      cView = parent;\n    }\n\n    var from = cView.posAtStart;\n    return {\n      from: from,\n      to: from + cView.length,\n      node: cView.dom,\n      text: textNode\n    };\n  }\n}\n\nfunction computeCompositionDeco(view, changes) {\n  var surrounding = compositionSurroundingNode(view);\n  if (!surrounding) return Decoration.none;\n  var from = surrounding.from,\n      to = surrounding.to,\n      node = surrounding.node,\n      textNode = surrounding.text;\n  var newFrom = changes.mapPos(from, 1),\n      newTo = Math.max(newFrom, changes.mapPos(to, -1));\n  var state = view.state,\n      text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], view).readRange(node.firstChild, null).text;\n\n  if (newTo - newFrom < text.length) {\n    if (state.sliceDoc(newFrom, Math.min(state.doc.length, newFrom + text.length)) == text) newTo = newFrom + text.length;else if (state.sliceDoc(Math.max(0, newTo - text.length), newTo) == text) newFrom = newTo - text.length;else return Decoration.none;\n  } else if (state.sliceDoc(newFrom, newTo) != text) {\n    return Decoration.none;\n  }\n\n  return Decoration.set(Decoration.replace({\n    widget: new CompositionWidget(node, textNode)\n  }).range(newFrom, newTo));\n}\n\nvar CompositionWidget = /*#__PURE__*/function (_WidgetType3) {\n  _inherits(CompositionWidget, _WidgetType3);\n\n  var _super15 = _createSuper(CompositionWidget);\n\n  function CompositionWidget(top, text) {\n    var _this17;\n\n    _classCallCheck(this, CompositionWidget);\n\n    _this17 = _super15.call(this);\n    _this17.top = top;\n    _this17.text = text;\n    return _this17;\n  }\n\n  _createClass(CompositionWidget, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return this.top == other.top && this.text == other.text;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM() {\n      return this.top;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent() {\n      return false;\n    }\n  }, {\n    key: \"customView\",\n    get: function get() {\n      return CompositionView;\n    }\n  }]);\n\n  return CompositionWidget;\n}(WidgetType);\n\nfunction nearbyTextNode(node, offset, side) {\n  for (;;) {\n    if (node.nodeType == 3) return node;\n\n    if (node.nodeType == 1 && offset > 0 && side <= 0) {\n      node = node.childNodes[offset - 1];\n      offset = maxOffset(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction nextToUneditable(node, offset) {\n  if (node.nodeType != 1) return 0;\n  return (offset && node.childNodes[offset - 1].contentEditable == \"false\" ? 1\n  /* Before */\n  : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == \"false\" ? 2\n  /* After */\n  : 0);\n}\n\nvar DecorationComparator$1 = /*#__PURE__*/function () {\n  function DecorationComparator$1() {\n    _classCallCheck(this, DecorationComparator$1);\n\n    this.changes = [];\n  }\n\n  _createClass(DecorationComparator$1, [{\n    key: \"compareRange\",\n    value: function compareRange(from, to) {\n      addRange(from, to, this.changes);\n    }\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(from, to) {\n      addRange(from, to, this.changes);\n    }\n  }]);\n\n  return DecorationComparator$1;\n}();\n\nfunction findChangedDeco(a, b, diff) {\n  var comp = new DecorationComparator$1();\n  _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.compare(a, b, diff, comp);\n  return comp.changes;\n}\n\nfunction inUneditable(node, inside) {\n  for (var cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {\n    if (cur.nodeType == 1 && cur.contentEditable == 'false') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction groupAt(state, pos) {\n  var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var categorize = state.charCategorizer(pos);\n  var line = state.doc.lineAt(pos),\n      linePos = pos - line.from;\n  if (line.length == 0) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos);\n  if (linePos == 0) bias = 1;else if (linePos == line.length) bias = -1;\n  var from = linePos,\n      to = linePos;\n  if (bias < 0) from = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos, false);else to = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, linePos);\n  var cat = categorize(line.text.slice(from, to));\n\n  while (from > 0) {\n    var prev = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, from, false);\n    if (categorize(line.text.slice(prev, from)) != cat) break;\n    from = prev;\n  }\n\n  while (to < line.length) {\n    var next = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findClusterBreak)(line.text, to);\n    if (categorize(line.text.slice(to, next)) != cat) break;\n    to = next;\n  }\n\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(from + line.from, to + line.from);\n} // Search the DOM for the {node, offset} position closest to the given\n// coordinates. Very inefficient and crude, but can usually be avoided\n// by calling caret(Position|Range)FromPoint instead.\n\n\nfunction getdx(x, rect) {\n  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);\n}\n\nfunction getdy(y, rect) {\n  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);\n}\n\nfunction yOverlap(a, b) {\n  return a.top < b.bottom - 1 && a.bottom > b.top + 1;\n}\n\nfunction upTop(rect, top) {\n  return top < rect.top ? {\n    top: top,\n    left: rect.left,\n    right: rect.right,\n    bottom: rect.bottom\n  } : rect;\n}\n\nfunction upBot(rect, bottom) {\n  return bottom > rect.bottom ? {\n    top: rect.top,\n    left: rect.left,\n    right: rect.right,\n    bottom: bottom\n  } : rect;\n}\n\nfunction domPosAtCoords(parent, x, y) {\n  var closest, closestRect, closestX, closestY;\n  var above, below, aboveRect, belowRect;\n\n  for (var child = parent.firstChild; child; child = child.nextSibling) {\n    var rects = clientRectsFor(child);\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);\n      var dx = getdx(x, rect),\n          dy = getdy(y, rect);\n      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);\n\n      if (!closest || closestY > dy || closestY == dy && closestX > dx) {\n        closest = child;\n        closestRect = rect;\n        closestX = dx;\n        closestY = dy;\n      }\n\n      if (dx == 0) {\n        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {\n          above = child;\n          aboveRect = rect;\n        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {\n          below = child;\n          belowRect = rect;\n        }\n      } else if (aboveRect && yOverlap(aboveRect, rect)) {\n        aboveRect = upBot(aboveRect, rect.bottom);\n      } else if (belowRect && yOverlap(belowRect, rect)) {\n        belowRect = upTop(belowRect, rect.top);\n      }\n    }\n  }\n\n  if (aboveRect && aboveRect.bottom >= y) {\n    closest = above;\n    closestRect = aboveRect;\n  } else if (belowRect && belowRect.top <= y) {\n    closest = below;\n    closestRect = belowRect;\n  }\n\n  if (!closest) return {\n    node: parent,\n    offset: 0\n  };\n  var clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));\n  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);\n  if (!closestX && closest.contentEditable == \"true\") return domPosAtCoords(closest, clipX, y);\n  var offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);\n  return {\n    node: parent,\n    offset: offset\n  };\n}\n\nfunction domPosInText(node, x, y) {\n  var len = node.nodeValue.length;\n  var closestOffset = -1,\n      closestDY = 1e9,\n      generalSide = 0;\n\n  for (var i = 0; i < len; i++) {\n    var rects = textRange(node, i, i + 1).getClientRects();\n\n    for (var j = 0; j < rects.length; j++) {\n      var rect = rects[j];\n      if (rect.top == rect.bottom) continue;\n      if (!generalSide) generalSide = x - rect.left;\n      var dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;\n\n      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {\n        var right = x >= (rect.left + rect.right) / 2,\n            after = right;\n\n        if (browser.chrome || browser.gecko) {\n          // Check for RTL on browsers that support getting client\n          // rects for empty ranges.\n          var rectBefore = textRange(node, i).getBoundingClientRect();\n          if (rectBefore.left == rect.right) after = !right;\n        }\n\n        if (dy <= 0) return {\n          node: node,\n          offset: i + (after ? 1 : 0)\n        };\n        closestOffset = i + (after ? 1 : 0);\n        closestDY = dy;\n      }\n    }\n  }\n\n  return {\n    node: node,\n    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0\n  };\n}\n\nfunction _posAtCoords(view, _ref6, precise) {\n  var x = _ref6.x,\n      y = _ref6.y;\n  var bias = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\n  var _a;\n\n  var content = view.contentDOM.getBoundingClientRect(),\n      docTop = content.top + view.viewState.paddingTop;\n  var block,\n      docHeight = view.viewState.docHeight;\n  var yOffset = y - docTop;\n  if (yOffset < 0) return 0;\n  if (yOffset > docHeight) return view.state.doc.length; // Scan for a text block near the queried y position\n\n  for (var halfLine = view.defaultLineHeight / 2, bounced = false;;) {\n    block = view.elementAtHeight(yOffset);\n    if (block.type == BlockType.Text) break;\n\n    for (;;) {\n      // Move the y position out of this block\n      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;\n      if (yOffset >= 0 && yOffset <= docHeight) break; // If the document consists entirely of replaced widgets, we\n      // won't find a text block, so return 0\n\n      if (bounced) return precise ? null : 0;\n      bounced = true;\n      bias = -bias;\n    }\n  }\n\n  y = docTop + yOffset;\n  var lineStart = block.from; // If this is outside of the rendered viewport, we can't determine a position\n\n  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);\n  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y); // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not\n\n  var doc = view.dom.ownerDocument;\n  var root = view.root.elementFromPoint ? view.root : doc;\n  var element = root.elementFromPoint(x, y);\n  if (element && !view.contentDOM.contains(element)) element = null; // If the element is unexpected, clip x at the sides of the content area and try again\n\n  if (!element) {\n    x = Math.max(content.left + 1, Math.min(content.right - 1, x));\n    element = root.elementFromPoint(x, y);\n    if (element && !view.contentDOM.contains(element)) element = null;\n  } // There's visible editor content under the point, so we can try\n  // using caret(Position|Range)FromPoint as a shortcut\n\n\n  var node,\n      offset = -1;\n\n  if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {\n    if (doc.caretPositionFromPoint) {\n      var pos = doc.caretPositionFromPoint(x, y);\n\n      if (pos) {\n        node = pos.offsetNode;\n        offset = pos.offset;\n      }\n    } else if (doc.caretRangeFromPoint) {\n      var range = doc.caretRangeFromPoint(x, y);\n\n      if (range) {\n        node = range.startContainer;\n        offset = range.startOffset;\n        if (browser.safari && isSuspiciousCaretResult(node, offset, x)) node = undefined;\n      }\n    }\n  } // No luck, do our own (potentially expensive) search\n\n\n  if (!node || !view.docView.dom.contains(node)) {\n    var line = LineView.find(view.docView, lineStart);\n    if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;\n\n    var _domPosAtCoords = domPosAtCoords(line.dom, x, y);\n\n    node = _domPosAtCoords.node;\n    offset = _domPosAtCoords.offset;\n  }\n\n  return view.docView.posFromDOM(node, offset);\n}\n\nfunction posAtCoordsImprecise(view, contentRect, block, x, y) {\n  var into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);\n\n  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {\n    var line = Math.floor((y - block.top) / view.defaultLineHeight);\n    into += line * view.viewState.heightOracle.lineLength;\n  }\n\n  var content = view.state.sliceDoc(block.from, block.to);\n  return block.from + (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.findColumn)(content, into, view.state.tabSize);\n} // In case of a high line height, Safari's caretRangeFromPoint treats\n// the space between lines as belonging to the last character of the\n// line before. This is used to detect such a result so that it can be\n// ignored (issue #401).\n\n\nfunction isSuspiciousCaretResult(node, offset, x) {\n  var len;\n  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;\n\n  for (var next = node.nextSibling; next; next = next.nextSibling) {\n    if (next.nodeType != 1 || next.nodeName != \"BR\") return false;\n  }\n\n  return textRange(node, len - 1, len).getBoundingClientRect().left > x;\n}\n\nfunction _moveToLineBoundary(view, start, forward, includeWrap) {\n  var line = view.state.doc.lineAt(start.head);\n  var coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);\n\n  if (coords) {\n    var editorRect = view.dom.getBoundingClientRect();\n    var pos = view.posAtCoords({\n      x: forward == (view.textDirection == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,\n      y: (coords.top + coords.bottom) / 2\n    });\n    if (pos != null) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos, forward ? -1 : 1);\n  }\n\n  var lineView = LineView.find(view.docView, start.head);\n  var end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(end, forward ? -1 : 1);\n}\n\nfunction _moveByChar(view, start, forward, by) {\n  var line = view.state.doc.lineAt(start.head),\n      spans = view.bidiSpans(line);\n\n  for (var cur = start, check = null;;) {\n    var next = moveVisually(line, spans, view.textDirection, cur, forward),\n        _char = movedOver;\n\n    if (!next) {\n      if (line.number == (forward ? view.state.doc.lines : 1)) return cur;\n      _char = \"\\n\";\n      line = view.state.doc.line(line.number + (forward ? 1 : -1));\n      spans = view.bidiSpans(line);\n      next = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(forward ? line.from : line.to);\n    }\n\n    if (!check) {\n      if (!by) return next;\n      check = by(_char);\n    } else if (!check(_char)) {\n      return cur;\n    }\n\n    cur = next;\n  }\n}\n\nfunction byGroup(view, pos, start) {\n  var categorize = view.state.charCategorizer(pos);\n  var cat = categorize(start);\n  return function (next) {\n    var nextCat = categorize(next);\n    if (cat == _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.CharCategory.Space) cat = nextCat;\n    return cat == nextCat;\n  };\n}\n\nfunction _moveVertically(view, start, forward, distance) {\n  var startPos = start.head,\n      dir = forward ? 1 : -1;\n  if (startPos == (forward ? view.state.doc.length : 0)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(startPos, start.assoc);\n  var goal = start.goalColumn,\n      startY;\n  var rect = view.contentDOM.getBoundingClientRect();\n  var startCoords = view.coordsAtPos(startPos),\n      docTop = view.documentTop;\n\n  if (startCoords) {\n    if (goal == null) goal = startCoords.left - rect.left;\n    startY = dir < 0 ? startCoords.top : startCoords.bottom;\n  } else {\n    var line = view.viewState.lineBlockAt(startPos - docTop);\n    if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));\n    startY = (dir < 0 ? line.top : line.bottom) + docTop;\n  }\n\n  var resolvedGoal = rect.left + goal;\n  var dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;\n\n  for (var extra = 0;; extra += 10) {\n    var curY = startY + (dist + extra) * dir;\n\n    var pos = _posAtCoords(view, {\n      x: resolvedGoal,\n      y: curY\n    }, false, dir);\n\n    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos, start.assoc, undefined, goal);\n  }\n}\n\nfunction skipAtoms(view, oldPos, pos) {\n  var atoms = view.pluginField(PluginField.atomicRanges);\n\n  for (;;) {\n    var moved = false;\n\n    var _iterator17 = _createForOfIteratorHelper(atoms),\n        _step17;\n\n    try {\n      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n        var set = _step17.value;\n        set.between(pos.from - 1, pos.from + 1, function (from, to, value) {\n          if (pos.from > from && pos.from < to) {\n            pos = oldPos.from > pos.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(from, 1) : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(to, -1);\n            moved = true;\n          }\n        });\n      }\n    } catch (err) {\n      _iterator17.e(err);\n    } finally {\n      _iterator17.f();\n    }\n\n    if (!moved) return pos;\n  }\n} // This will also be where dragging info and such goes\n\n\nvar InputState = /*#__PURE__*/function () {\n  function InputState(view) {\n    var _this18 = this;\n\n    _classCallCheck(this, InputState);\n\n    this.lastKeyCode = 0;\n    this.lastKeyTime = 0; // On iOS, some keys need to have their default behavior happen\n    // (after which we retroactively handle them and reset the DOM) to\n    // avoid messing up the virtual keyboard state.\n\n    this.pendingIOSKey = undefined;\n    this.lastSelectionOrigin = null;\n    this.lastSelectionTime = 0;\n    this.lastEscPress = 0;\n    this.lastContextMenu = 0;\n    this.scrollHandlers = [];\n    this.registeredEvents = [];\n    this.customHandlers = []; // -1 means not in a composition. Otherwise, this counts the number\n    // of changes made during the composition. The count is used to\n    // avoid treating the start state of the composition, before any\n    // changes have been made, as part of the composition.\n\n    this.composing = -1; // Tracks whether the next change should be marked as starting the\n    // composition (null means no composition, true means next is the\n    // first, false means first has already been marked for this\n    // composition)\n\n    this.compositionFirstChange = null;\n    this.compositionEndedAt = 0;\n    this.rapidCompositionStart = false;\n    this.mouseSelection = null;\n\n    var _loop = function _loop(type) {\n      var handler = handlers[type];\n      view.contentDOM.addEventListener(type, function (event) {\n        if (type == \"keydown\" && _this18.keydown(view, event)) return;\n        if (!eventBelongsToEditor(view, event) || _this18.ignoreDuringComposition(event)) return;\n        if (_this18.mustFlushObserver(event)) view.observer.forceFlush();\n        if (_this18.runCustomHandlers(type, view, event)) event.preventDefault();else handler(view, event);\n      });\n\n      _this18.registeredEvents.push(type);\n    };\n\n    for (var type in handlers) {\n      _loop(type);\n    }\n\n    this.notifiedFocused = view.hasFocus;\n    this.ensureHandlers(view); // On Safari adding an input event handler somehow prevents an\n    // issue where the composition vanishes when you press enter.\n\n    if (browser.safari) view.contentDOM.addEventListener(\"input\", function () {\n      return null;\n    });\n  }\n\n  _createClass(InputState, [{\n    key: \"setSelectionOrigin\",\n    value: function setSelectionOrigin(origin) {\n      this.lastSelectionOrigin = origin;\n      this.lastSelectionTime = Date.now();\n    }\n  }, {\n    key: \"ensureHandlers\",\n    value: function ensureHandlers(view) {\n      var _this19 = this;\n\n      var handlers = this.customHandlers = view.pluginField(domEventHandlers);\n\n      var _iterator18 = _createForOfIteratorHelper(handlers),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var set = _step18.value;\n\n          var _loop2 = function _loop2(type) {\n            if (_this19.registeredEvents.indexOf(type) < 0 && type != \"scroll\") {\n              _this19.registeredEvents.push(type);\n\n              view.contentDOM.addEventListener(type, function (event) {\n                if (!eventBelongsToEditor(view, event)) return;\n                if (_this19.runCustomHandlers(type, view, event)) event.preventDefault();\n              });\n            }\n          };\n\n          for (var type in set.handlers) {\n            _loop2(type);\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n  }, {\n    key: \"runCustomHandlers\",\n    value: function runCustomHandlers(type, view, event) {\n      var _iterator19 = _createForOfIteratorHelper(this.customHandlers),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var set = _step19.value;\n          var handler = set.handlers[type];\n\n          if (handler) {\n            try {\n              if (handler.call(set.plugin, event, view) || event.defaultPrevented) return true;\n            } catch (e) {\n              logException(view.state, e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"runScrollHandlers\",\n    value: function runScrollHandlers(view, event) {\n      var _iterator20 = _createForOfIteratorHelper(this.customHandlers),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var set = _step20.value;\n          var handler = set.handlers.scroll;\n\n          if (handler) {\n            try {\n              handler.call(set.plugin, event, view);\n            } catch (e) {\n              logException(view.state, e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n    }\n  }, {\n    key: \"keydown\",\n    value: function keydown(view, event) {\n      var _this20 = this;\n\n      // Must always run, even if a custom handler handled the event\n      this.lastKeyCode = event.keyCode;\n      this.lastKeyTime = Date.now();\n      if (this.screenKeyEvent(view, event)) return true; // Chrome for Android usually doesn't fire proper key events, but\n      // occasionally does, usually surrounded by a bunch of complicated\n      // composition changes. When an enter or backspace key event is\n      // seen, hold off on handling DOM events for a bit, and then\n      // dispatch it.\n\n      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {\n        view.observer.delayAndroidKey(event.key, event.keyCode);\n        return true;\n      } // Prevent the default behavior of Enter on iOS makes the\n      // virtual keyboard get stuck in the wrong (lowercase)\n      // state. So we let it go through, and then, in\n      // applyDOMChange, notify key handlers of it and reset to\n      // the state they produce.\n\n\n      var pending;\n\n      if (browser.ios && (pending = PendingKeys.find(function (key) {\n        return key.keyCode == event.keyCode;\n      })) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {\n        this.pendingIOSKey = pending;\n        setTimeout(function () {\n          return _this20.flushIOSKey(view);\n        }, 250);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"flushIOSKey\",\n    value: function flushIOSKey(view) {\n      var key = this.pendingIOSKey;\n      if (!key) return false;\n      this.pendingIOSKey = undefined;\n      return dispatchKey(view.contentDOM, key.key, key.keyCode);\n    }\n  }, {\n    key: \"ignoreDuringComposition\",\n    value: function ignoreDuringComposition(event) {\n      if (!/^key/.test(event.type)) return false;\n      if (this.composing > 0) return true; // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n      // On some input method editors (IMEs), the Enter key is used to\n      // confirm character selection. On Safari, when Enter is pressed,\n      // compositionend and keydown events are sometimes emitted in the\n      // wrong order. The key event should still be ignored, even when\n      // it happens after the compositionend event.\n\n      if (browser.safari && Date.now() - this.compositionEndedAt < 500) {\n        this.compositionEndedAt = 0;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"screenKeyEvent\",\n    value: function screenKeyEvent(view, event) {\n      var protectedTab = event.keyCode == 9 && Date.now() < this.lastEscPress + 2000;\n      if (event.keyCode == 27) this.lastEscPress = Date.now();else if (modifierCodes.indexOf(event.keyCode) < 0) this.lastEscPress = 0;\n      return protectedTab;\n    }\n  }, {\n    key: \"mustFlushObserver\",\n    value: function mustFlushObserver(event) {\n      return event.type == \"keydown\" && event.keyCode != 229 || event.type == \"compositionend\" && !browser.ios;\n    }\n  }, {\n    key: \"startMouseSelection\",\n    value: function startMouseSelection(mouseSelection) {\n      if (this.mouseSelection) this.mouseSelection.destroy();\n      this.mouseSelection = mouseSelection;\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update2) {\n      if (this.mouseSelection) this.mouseSelection.update(_update2);\n      if (_update2.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.mouseSelection) this.mouseSelection.destroy();\n    }\n  }]);\n\n  return InputState;\n}();\n\nvar PendingKeys = [{\n  key: \"Backspace\",\n  keyCode: 8,\n  inputType: \"deleteContentBackward\"\n}, {\n  key: \"Enter\",\n  keyCode: 13,\n  inputType: \"insertParagraph\"\n}, {\n  key: \"Delete\",\n  keyCode: 46,\n  inputType: \"deleteContentForward\"\n}]; // Key codes for modifier keys\n\nvar modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];\n\nvar MouseSelection = /*#__PURE__*/function () {\n  function MouseSelection(view, startEvent, style, mustSelect) {\n    _classCallCheck(this, MouseSelection);\n\n    this.view = view;\n    this.style = style;\n    this.mustSelect = mustSelect;\n    this.lastEvent = startEvent;\n    var doc = view.contentDOM.ownerDocument;\n    doc.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    doc.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    this.extend = startEvent.shiftKey;\n    this.multiple = view.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);\n    this.dragMove = dragMovesSelection(view, startEvent);\n    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false; // When clicking outside of the selection, immediately apply the\n    // effect of starting the selection\n\n    if (this.dragging === false) {\n      startEvent.preventDefault();\n      this.select(startEvent);\n    }\n  }\n\n  _createClass(MouseSelection, [{\n    key: \"move\",\n    value: function move(event) {\n      if (event.buttons == 0) return this.destroy();\n      if (this.dragging !== false) return;\n      this.select(this.lastEvent = event);\n    }\n  }, {\n    key: \"up\",\n    value: function up(event) {\n      if (this.dragging == null) this.select(this.lastEvent);\n      if (!this.dragging) event.preventDefault();\n      this.destroy();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var doc = this.view.contentDOM.ownerDocument;\n      doc.removeEventListener(\"mousemove\", this.move);\n      doc.removeEventListener(\"mouseup\", this.up);\n      this.view.inputState.mouseSelection = null;\n    }\n  }, {\n    key: \"select\",\n    value: function select(event) {\n      var selection = this.style.get(event, this.extend, this.multiple);\n      if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc) this.view.dispatch({\n        selection: selection,\n        userEvent: \"select.pointer\",\n        scrollIntoView: true\n      });\n      this.mustSelect = false;\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update3) {\n      var _this21 = this;\n\n      if (_update3.docChanged && this.dragging) this.dragging = this.dragging.map(_update3.changes);\n      if (this.style.update(_update3)) setTimeout(function () {\n        return _this21.select(_this21.lastEvent);\n      }, 20);\n    }\n  }]);\n\n  return MouseSelection;\n}();\n\nfunction addsSelectionRange(view, event) {\n  var facet = view.state.facet(clickAddsSelectionRange);\n  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;\n}\n\nfunction dragMovesSelection(view, event) {\n  var facet = view.state.facet(dragMovesSelection$1);\n  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;\n}\n\nfunction isInPrimarySelection(view, event) {\n  var main = view.state.selection.main;\n  if (main.empty) return false; // On boundary clicks, check whether the coordinates are inside the\n  // selection's client rectangles\n\n  var sel = getSelection(view.root);\n  if (sel.rangeCount == 0) return true;\n  var rects = sel.getRangeAt(0).getClientRects();\n\n  for (var i = 0; i < rects.length; i++) {\n    var rect = rects[i];\n    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;\n  }\n\n  return false;\n}\n\nfunction eventBelongsToEditor(view, event) {\n  if (!event.bubbles) return true;\n  if (event.defaultPrevented) return false;\n\n  for (var node = event.target, cView; node != view.contentDOM; node = node.parentNode) {\n    if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;\n  }\n\n  return true;\n}\n\nvar handlers = /*@__PURE__*/Object.create(null); // This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\n\nvar brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;\n\nfunction capturePaste(view) {\n  var parent = view.dom.parentNode;\n  if (!parent) return;\n  var target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(function () {\n    view.focus();\n    target.remove();\n    doPaste(view, target.value);\n  }, 50);\n}\n\nfunction doPaste(view, input) {\n  var state = view.state,\n      changes,\n      i = 1,\n      text = state.toText(input);\n  var byLine = text.lines == state.selection.ranges.length;\n  var linewise = lastLinewiseCopy != null && state.selection.ranges.every(function (r) {\n    return r.empty;\n  }) && lastLinewiseCopy == text.toString();\n\n  if (linewise) {\n    var lastLine = -1;\n    changes = state.changeByRange(function (range) {\n      var line = state.doc.lineAt(range.from);\n      if (line.from == lastLine) return {\n        range: range\n      };\n      lastLine = line.from;\n      var insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);\n      return {\n        changes: {\n          from: line.from,\n          insert: insert\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(range.from + insert.length)\n      };\n    });\n  } else if (byLine) {\n    changes = state.changeByRange(function (range) {\n      var line = text.line(i++);\n      return {\n        changes: {\n          from: range.from,\n          to: range.to,\n          insert: line.text\n        },\n        range: _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(range.from + line.length)\n      };\n    });\n  } else {\n    changes = state.replaceSelection(text);\n  }\n\n  view.dispatch(changes, {\n    userEvent: \"input.paste\",\n    scrollIntoView: true\n  });\n}\n\nhandlers.keydown = function (view, event) {\n  view.inputState.setSelectionOrigin(\"select\");\n};\n\nvar lastTouch = 0;\n\nhandlers.touchstart = function (view, e) {\n  lastTouch = Date.now();\n  view.inputState.setSelectionOrigin(\"select.pointer\");\n};\n\nhandlers.touchmove = function (view) {\n  view.inputState.setSelectionOrigin(\"select.pointer\");\n};\n\nhandlers.mousedown = function (view, event) {\n  view.observer.flush();\n  if (lastTouch > Date.now() - 2000 && getClickType(event) == 1) return; // Ignore touch interaction\n\n  var style = null;\n\n  var _iterator21 = _createForOfIteratorHelper(view.state.facet(mouseSelectionStyle)),\n      _step21;\n\n  try {\n    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n      var makeStyle = _step21.value;\n      style = makeStyle(view, event);\n      if (style) break;\n    }\n  } catch (err) {\n    _iterator21.e(err);\n  } finally {\n    _iterator21.f();\n  }\n\n  if (!style && event.button == 0) style = basicMouseSelection(view, event);\n\n  if (style) {\n    var mustFocus = view.root.activeElement != view.contentDOM;\n    if (mustFocus) view.observer.ignore(function () {\n      return focusPreventScroll(view.contentDOM);\n    });\n    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));\n  }\n};\n\nfunction rangeForClick(view, pos, bias, type) {\n  if (type == 1) {\n    // Single click\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos, bias);\n  } else if (type == 2) {\n    // Double click\n    return groupAt(view.state, pos, bias);\n  } else {\n    // Triple click\n    var visual = LineView.find(view.docView, pos),\n        line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);\n    var from = visual ? visual.posAtStart : line.from,\n        to = visual ? visual.posAtEnd : line.to;\n    if (to < view.state.doc.length && to == line.to) to++;\n    return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(from, to);\n  }\n}\n\nvar insideY = function insideY(y, rect) {\n  return y >= rect.top && y <= rect.bottom;\n};\n\nvar inside = function inside(x, y, rect) {\n  return insideY(y, rect) && x >= rect.left && x <= rect.right;\n}; // Try to determine, for the given coordinates, associated with the\n// given position, whether they are related to the element before or\n// the element after the position.\n\n\nfunction findPositionSide(view, pos, x, y) {\n  var line = LineView.find(view.docView, pos);\n  if (!line) return 1;\n  var off = pos - line.posAtStart; // Line boundaries point into the line\n\n  if (off == 0) return 1;\n  if (off == line.length) return -1; // Positions on top of an element point at that element\n\n  var before = line.coordsAt(off, -1);\n  if (before && inside(x, y, before)) return -1;\n  var after = line.coordsAt(off, 1);\n  if (after && inside(x, y, after)) return 1; // This is probably a line wrap point. Pick before if the point is\n  // beside it.\n\n  return before && insideY(y, before) ? -1 : 1;\n}\n\nfunction queryPos(view, event) {\n  var pos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  return {\n    pos: pos,\n    bias: findPositionSide(view, pos, event.clientX, event.clientY)\n  };\n}\n\nvar BadMouseDetail = browser.ie && browser.ie_version <= 11;\nvar lastMouseDown = null,\n    lastMouseDownCount = 0,\n    lastMouseDownTime = 0;\n\nfunction getClickType(event) {\n  if (!BadMouseDetail) return event.detail;\n  var last = lastMouseDown,\n      lastTime = lastMouseDownTime;\n  lastMouseDown = event;\n  lastMouseDownTime = Date.now();\n  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;\n}\n\nfunction basicMouseSelection(view, event) {\n  var start = queryPos(view, event),\n      type = getClickType(event);\n  var startSel = view.state.selection;\n  var last = start,\n      lastEvent = event;\n  return {\n    update: function update(_update4) {\n      if (_update4.docChanged) {\n        if (start) start.pos = _update4.changes.mapPos(start.pos);\n        startSel = startSel.map(_update4.changes);\n        lastEvent = null;\n      }\n    },\n    get: function get(event, extend, multiple) {\n      var cur;\n      if (lastEvent && event.clientX == lastEvent.clientX && event.clientY == lastEvent.clientY) cur = last;else {\n        cur = last = queryPos(view, event);\n        lastEvent = event;\n      }\n      if (!cur || !start) return startSel;\n      var range = rangeForClick(view, cur.pos, cur.bias, type);\n\n      if (start.pos != cur.pos && !extend) {\n        var startRange = rangeForClick(view, start.pos, start.bias, type);\n        var from = Math.min(startRange.from, range.from),\n            to = Math.max(startRange.to, range.to);\n        range = from < range.from ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(from, to) : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(to, from);\n      }\n\n      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));else if (multiple) return startSel.addRange(range);else return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.create([range]);\n    }\n  };\n}\n\nhandlers.dragstart = function (view, event) {\n  var main = view.state.selection.main;\n  var mouseSelection = view.inputState.mouseSelection;\n  if (mouseSelection) mouseSelection.dragging = main;\n\n  if (event.dataTransfer) {\n    event.dataTransfer.setData(\"Text\", view.state.sliceDoc(main.from, main.to));\n    event.dataTransfer.effectAllowed = \"copyMove\";\n  }\n};\n\nfunction dropText(view, event, text, direct) {\n  if (!text) return;\n  var dropPos = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  event.preventDefault();\n  var mouseSelection = view.inputState.mouseSelection;\n  var del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? {\n    from: mouseSelection.dragging.from,\n    to: mouseSelection.dragging.to\n  } : null;\n  var ins = {\n    from: dropPos,\n    insert: text\n  };\n  var changes = view.state.changes(del ? [del, ins] : ins);\n  view.focus();\n  view.dispatch({\n    changes: changes,\n    selection: {\n      anchor: changes.mapPos(dropPos, -1),\n      head: changes.mapPos(dropPos, 1)\n    },\n    userEvent: del ? \"move.drop\" : \"input.drop\"\n  });\n}\n\nhandlers.drop = function (view, event) {\n  if (!event.dataTransfer) return;\n  if (view.state.readOnly) return event.preventDefault();\n  var files = event.dataTransfer.files;\n\n  if (files && files.length) {\n    (function () {\n      // For a file drop, read the file's text.\n      event.preventDefault();\n      var text = Array(files.length),\n          read = 0;\n\n      var finishFile = function finishFile() {\n        if (++read == files.length) dropText(view, event, text.filter(function (s) {\n          return s != null;\n        }).join(view.state.lineBreak), false);\n      };\n\n      var _loop3 = function _loop3(i) {\n        var reader = new FileReader();\n        reader.onerror = finishFile;\n\n        reader.onload = function () {\n          if (!/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(reader.result)) text[i] = reader.result;\n          finishFile();\n        };\n\n        reader.readAsText(files[i]);\n      };\n\n      for (var i = 0; i < files.length; i++) {\n        _loop3(i);\n      }\n    })();\n  } else {\n    dropText(view, event, event.dataTransfer.getData(\"Text\"), true);\n  }\n};\n\nhandlers.paste = function (view, event) {\n  if (view.state.readOnly) return event.preventDefault();\n  view.observer.flush();\n  var data = brokenClipboardAPI ? null : event.clipboardData;\n\n  if (data) {\n    doPaste(view, data.getData(\"text/plain\"));\n    event.preventDefault();\n  } else {\n    capturePaste(view);\n  }\n};\n\nfunction captureCopy(view, text) {\n  // The extra wrapper is somehow necessary on IE/Edge to prevent the\n  // content from being mangled when it is put onto the clipboard\n  var parent = view.dom.parentNode;\n  if (!parent) return;\n  var target = parent.appendChild(document.createElement(\"textarea\"));\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.value = text;\n  target.focus();\n  target.selectionEnd = text.length;\n  target.selectionStart = 0;\n  setTimeout(function () {\n    target.remove();\n    view.focus();\n  }, 50);\n}\n\nfunction copiedRange(state) {\n  var content = [],\n      ranges = [],\n      linewise = false;\n\n  var _iterator22 = _createForOfIteratorHelper(state.selection.ranges),\n      _step22;\n\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var range = _step22.value;\n\n      if (!range.empty) {\n        content.push(state.sliceDoc(range.from, range.to));\n        ranges.push(range);\n      }\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n\n  if (!content.length) {\n    // Nothing selected, do a line-wise copy\n    var upto = -1;\n\n    var _iterator23 = _createForOfIteratorHelper(state.selection.ranges),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var from = _step23.value.from;\n        var line = state.doc.lineAt(from);\n\n        if (line.number > upto) {\n          content.push(line.text);\n          ranges.push({\n            from: line.from,\n            to: Math.min(state.doc.length, line.to + 1)\n          });\n        }\n\n        upto = line.number;\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n\n    linewise = true;\n  }\n\n  return {\n    text: content.join(state.lineBreak),\n    ranges: ranges,\n    linewise: linewise\n  };\n}\n\nvar lastLinewiseCopy = null;\n\nhandlers.copy = handlers.cut = function (view, event) {\n  var _copiedRange = copiedRange(view.state),\n      text = _copiedRange.text,\n      ranges = _copiedRange.ranges,\n      linewise = _copiedRange.linewise;\n\n  if (!text && !linewise) return;\n  lastLinewiseCopy = linewise ? text : null;\n  var data = brokenClipboardAPI ? null : event.clipboardData;\n\n  if (data) {\n    event.preventDefault();\n    data.clearData();\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, text);\n  }\n\n  if (event.type == \"cut\" && !view.state.readOnly) view.dispatch({\n    changes: ranges,\n    scrollIntoView: true,\n    userEvent: \"delete.cut\"\n  });\n};\n\nhandlers.focus = handlers.blur = function (view) {\n  setTimeout(function () {\n    if (view.hasFocus != view.inputState.notifiedFocused) view.update([]);\n  }, 10);\n};\n\nhandlers.beforeprint = function (view) {\n  view.viewState.printing = true;\n  view.requestMeasure();\n  setTimeout(function () {\n    view.viewState.printing = false;\n    view.requestMeasure();\n  }, 2000);\n};\n\nfunction forceClearComposition(view, rapid) {\n  if (view.docView.compositionDeco.size) {\n    view.inputState.rapidCompositionStart = rapid;\n\n    try {\n      view.update([]);\n    } finally {\n      view.inputState.rapidCompositionStart = false;\n    }\n  }\n}\n\nhandlers.compositionstart = handlers.compositionupdate = function (view) {\n  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;\n\n  if (view.inputState.composing < 0) {\n    // FIXME possibly set a timeout to clear it again on Android\n    view.inputState.composing = 0;\n\n    if (view.docView.compositionDeco.size) {\n      view.observer.flush();\n      forceClearComposition(view, true);\n    }\n  }\n};\n\nhandlers.compositionend = function (view) {\n  view.inputState.composing = -1;\n  view.inputState.compositionEndedAt = Date.now();\n  view.inputState.compositionFirstChange = null;\n  setTimeout(function () {\n    if (view.inputState.composing < 0) forceClearComposition(view, false);\n  }, 50);\n};\n\nhandlers.contextmenu = function (view) {\n  view.inputState.lastContextMenu = Date.now();\n};\n\nhandlers.beforeinput = function (view, event) {\n  var _a; // Because Chrome Android doesn't fire useful key events, use\n  // beforeinput to detect backspace (and possibly enter and delete,\n  // but those usually don't even seem to fire beforeinput events at\n  // the moment) and fake a key event for it.\n  //\n  // (preventDefault on beforeinput, though supported in the spec,\n  // seems to do nothing at all on Chrome).\n\n\n  var pending;\n\n  if (browser.chrome && browser.android && (pending = PendingKeys.find(function (key) {\n    return key.inputType == event.inputType;\n  }))) {\n    view.observer.delayAndroidKey(pending.key, pending.keyCode);\n\n    if (pending.key == \"Backspace\" || pending.key == \"Delete\") {\n      var startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;\n      setTimeout(function () {\n        var _a; // Backspacing near uneditable nodes on Chrome Android sometimes\n        // closes the virtual keyboard. This tries to crudely detect\n        // that and refocus to get it back.\n\n\n        if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {\n          view.contentDOM.blur();\n          view.focus();\n        }\n      }, 100);\n    }\n  }\n};\n\nvar wrappingWhiteSpace = [\"pre-wrap\", \"normal\", \"pre-line\", \"break-spaces\"];\n\nvar HeightOracle = /*#__PURE__*/function () {\n  function HeightOracle() {\n    _classCallCheck(this, HeightOracle);\n\n    this.doc = _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty;\n    this.lineWrapping = false;\n    this.direction = Direction.LTR;\n    this.heightSamples = {};\n    this.lineHeight = 14;\n    this.charWidth = 7;\n    this.lineLength = 30; // Used to track, during updateHeight, if any actual heights changed\n\n    this.heightChanged = false;\n  }\n\n  _createClass(HeightOracle, [{\n    key: \"heightForGap\",\n    value: function heightForGap(from, to) {\n      var lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;\n      if (this.lineWrapping) lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);\n      return this.lineHeight * lines;\n    }\n  }, {\n    key: \"heightForLine\",\n    value: function heightForLine(length) {\n      if (!this.lineWrapping) return this.lineHeight;\n      var lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));\n      return lines * this.lineHeight;\n    }\n  }, {\n    key: \"setDoc\",\n    value: function setDoc(doc) {\n      this.doc = doc;\n      return this;\n    }\n  }, {\n    key: \"mustRefreshForStyle\",\n    value: function mustRefreshForStyle(whiteSpace, direction) {\n      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping || this.direction != direction;\n    }\n  }, {\n    key: \"mustRefreshForHeights\",\n    value: function mustRefreshForHeights(lineHeights) {\n      var newHeight = false;\n\n      for (var i = 0; i < lineHeights.length; i++) {\n        var h = lineHeights[i];\n\n        if (h < 0) {\n          i++;\n        } else if (!this.heightSamples[Math.floor(h * 10)]) {\n          // Round to .1 pixels\n          newHeight = true;\n          this.heightSamples[Math.floor(h * 10)] = true;\n        }\n      }\n\n      return newHeight;\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh(whiteSpace, direction, lineHeight, charWidth, lineLength, knownHeights) {\n      var lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;\n      var changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping || this.direction != direction;\n      this.lineWrapping = lineWrapping;\n      this.direction = direction;\n      this.lineHeight = lineHeight;\n      this.charWidth = charWidth;\n      this.lineLength = lineLength;\n\n      if (changed) {\n        this.heightSamples = {};\n\n        for (var i = 0; i < knownHeights.length; i++) {\n          var h = knownHeights[i];\n          if (h < 0) i++;else this.heightSamples[Math.floor(h * 10)] = true;\n        }\n      }\n\n      return changed;\n    }\n  }]);\n\n  return HeightOracle;\n}(); // This object is used by `updateHeight` to make DOM measurements\n// arrive at the right nides. The `heights` array is a sequence of\n// block heights, starting from position `from`.\n\n\nvar MeasuredHeights = /*#__PURE__*/function () {\n  function MeasuredHeights(from, heights) {\n    _classCallCheck(this, MeasuredHeights);\n\n    this.from = from;\n    this.heights = heights;\n    this.index = 0;\n  }\n\n  _createClass(MeasuredHeights, [{\n    key: \"more\",\n    get: function get() {\n      return this.index < this.heights.length;\n    }\n  }]);\n\n  return MeasuredHeights;\n}();\n/**\nRecord used to represent information about a block-level element\nin the editor view.\n*/\n\n\nvar BlockInfo = /*#__PURE__*/function () {\n  /**\n  @internal\n  */\n  function BlockInfo(\n  /**\n  The start of the element in the document.\n  */\n  from,\n  /**\n  The length of the element.\n  */\n  length,\n  /**\n  The top position of the element (relative to the top of the\n  document).\n  */\n  top,\n  /**\n  Its height.\n  */\n  height,\n  /**\n  The type of element this is. When querying lines, this may be\n  an array of all the blocks that make up the line.\n  */\n  type) {\n    _classCallCheck(this, BlockInfo);\n\n    this.from = from;\n    this.length = length;\n    this.top = top;\n    this.height = height;\n    this.type = type;\n  }\n  /**\n  The end of the element as a document position.\n  */\n\n\n  _createClass(BlockInfo, [{\n    key: \"to\",\n    get: function get() {\n      return this.from + this.length;\n    }\n    /**\n    The bottom position of the element.\n    */\n\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.top + this.height;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"join\",\n    value: function join(other) {\n      var detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);\n      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);\n    }\n    /**\n    FIXME remove on next breaking release @internal\n    */\n\n  }, {\n    key: \"moveY\",\n    value: function moveY(offset) {\n      return !offset ? this : new BlockInfo(this.from, this.length, this.top + offset, this.height, Array.isArray(this.type) ? this.type.map(function (b) {\n        return b.moveY(offset);\n      }) : this.type);\n    }\n  }]);\n\n  return BlockInfo;\n}();\n\nvar QueryType = /*@__PURE__*/function (QueryType) {\n  QueryType[QueryType[\"ByPos\"] = 0] = \"ByPos\";\n  QueryType[QueryType[\"ByHeight\"] = 1] = \"ByHeight\";\n  QueryType[QueryType[\"ByPosNoHeight\"] = 2] = \"ByPosNoHeight\";\n  return QueryType;\n}(QueryType || (QueryType = {}));\n\nvar Epsilon = 1e-3;\n\nvar HeightMap = /*#__PURE__*/function () {\n  function HeightMap(length, // The number of characters covered\n  height) {\n    var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n\n    _classCallCheck(this, HeightMap);\n\n    this.length = length;\n    this.height = height;\n    this.flags = flags;\n  }\n\n  _createClass(HeightMap, [{\n    key: \"outdated\",\n    get: function get() {\n      return (this.flags & 2\n      /* Outdated */\n      ) > 0;\n    },\n    set: function set(value) {\n      this.flags = (value ? 2\n      /* Outdated */\n      : 0) | this.flags & ~2\n      /* Outdated */\n      ;\n    }\n  }, {\n    key: \"setHeight\",\n    value: function setHeight(oracle, height) {\n      if (this.height != height) {\n        if (Math.abs(this.height - height) > Epsilon) oracle.heightChanged = true;\n        this.height = height;\n      }\n    } // Base case is to replace a leaf node, which simply builds a tree\n    // from the new nodes and returns that (HeightMapBranch and\n    // HeightMapGap override this to actually use from/to)\n\n  }, {\n    key: \"replace\",\n    value: function replace(_from, _to, nodes) {\n      return HeightMap.of(nodes);\n    } // Again, these are base cases, and are overridden for branch and gap nodes.\n\n  }, {\n    key: \"decomposeLeft\",\n    value: function decomposeLeft(_to, result) {\n      result.push(this);\n    }\n  }, {\n    key: \"decomposeRight\",\n    value: function decomposeRight(_from, result) {\n      result.push(this);\n    }\n  }, {\n    key: \"applyChanges\",\n    value: function applyChanges(decorations, oldDoc, oracle, changes) {\n      var me = this;\n\n      for (var i = changes.length - 1; i >= 0; i--) {\n        var _changes$i = changes[i],\n            fromA = _changes$i.fromA,\n            toA = _changes$i.toA,\n            fromB = _changes$i.fromB,\n            toB = _changes$i.toB;\n        var start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n        var end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n        toB += end.to - toA;\n        toA = end.to;\n\n        while (i > 0 && start.from <= changes[i - 1].toA) {\n          fromA = changes[i - 1].fromA;\n          fromB = changes[i - 1].fromB;\n          i--;\n          if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);\n        }\n\n        fromB += start.from - fromA;\n        fromA = start.from;\n        var nodes = NodeBuilder.build(oracle, decorations, fromB, toB);\n        me = me.replace(fromA, toA, nodes);\n      }\n\n      return me.updateHeight(oracle, 0);\n    }\n  }], [{\n    key: \"empty\",\n    value: function empty() {\n      return new HeightMapText(0, 0);\n    } // nodes uses null values to indicate the position of line breaks.\n    // There are never line breaks at the start or end of the array, or\n    // two line breaks next to each other, and the array isn't allowed\n    // to be empty (same restrictions as return value from the builder).\n\n  }, {\n    key: \"of\",\n    value: function of(nodes) {\n      if (nodes.length == 1) return nodes[0];\n      var i = 0,\n          j = nodes.length,\n          before = 0,\n          after = 0;\n\n      for (;;) {\n        if (i == j) {\n          if (before > after * 2) {\n            var split = nodes[i - 1];\n            if (split[\"break\"]) nodes.splice(--i, 1, split.left, null, split.right);else nodes.splice(--i, 1, split.left, split.right);\n            j += 1 + split[\"break\"];\n            before -= split.size;\n          } else if (after > before * 2) {\n            var _split = nodes[j];\n            if (_split[\"break\"]) nodes.splice(j, 1, _split.left, null, _split.right);else nodes.splice(j, 1, _split.left, _split.right);\n            j += 2 + _split[\"break\"];\n            after -= _split.size;\n          } else {\n            break;\n          }\n        } else if (before < after) {\n          var next = nodes[i++];\n          if (next) before += next.size;\n        } else {\n          var _next = nodes[--j];\n          if (_next) after += _next.size;\n        }\n      }\n\n      var brk = 0;\n\n      if (nodes[i - 1] == null) {\n        brk = 1;\n        i--;\n      } else if (nodes[i] == null) {\n        brk = 1;\n        j++;\n      }\n\n      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));\n    }\n  }]);\n\n  return HeightMap;\n}();\n\nHeightMap.prototype.size = 1;\n\nvar HeightMapBlock = /*#__PURE__*/function (_HeightMap) {\n  _inherits(HeightMapBlock, _HeightMap);\n\n  var _super16 = _createSuper(HeightMapBlock);\n\n  function HeightMapBlock(length, height, type) {\n    var _this22;\n\n    _classCallCheck(this, HeightMapBlock);\n\n    _this22 = _super16.call(this, length, height);\n    _this22.type = type;\n    return _this22;\n  }\n\n  _createClass(HeightMapBlock, [{\n    key: \"blockAt\",\n    value: function blockAt(_height, _doc, top, offset) {\n      return new BlockInfo(offset, this.length, top, this.height, this.type);\n    }\n  }, {\n    key: \"lineAt\",\n    value: function lineAt(_value, _type, doc, top, offset) {\n      return this.blockAt(0, doc, top, offset);\n    }\n  }, {\n    key: \"forEachLine\",\n    value: function forEachLine(_from, _to, doc, top, offset, f) {\n      f(this.blockAt(0, doc, top, offset));\n    }\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight(oracle) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      var _force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var measured = arguments.length > 3 ? arguments[3] : undefined;\n      if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);\n      this.outdated = false;\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"block(\".concat(this.length, \")\");\n    }\n  }]);\n\n  return HeightMapBlock;\n}(HeightMap);\n\nvar HeightMapText = /*#__PURE__*/function (_HeightMapBlock) {\n  _inherits(HeightMapText, _HeightMapBlock);\n\n  var _super17 = _createSuper(HeightMapText);\n\n  function HeightMapText(length, height) {\n    var _this23;\n\n    _classCallCheck(this, HeightMapText);\n\n    _this23 = _super17.call(this, length, height, BlockType.Text);\n    _this23.collapsed = 0; // Amount of collapsed content in the line\n\n    _this23.widgetHeight = 0; // Maximum inline widget height\n\n    return _this23;\n  }\n\n  _createClass(HeightMapText, [{\n    key: \"replace\",\n    value: function replace(_from, _to, nodes) {\n      var node = nodes[0];\n\n      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4\n      /* SingleLine */\n      ) && Math.abs(this.length - node.length) < 10) {\n        if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);else node.height = this.height;\n        if (!this.outdated) node.outdated = false;\n        return node;\n      } else {\n        return HeightMap.of(nodes);\n      }\n    }\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight(oracle) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var measured = arguments.length > 3 ? arguments[3] : undefined;\n      if (measured && measured.from <= offset && measured.more) this.setHeight(oracle, measured.heights[measured.index++]);else if (force || this.outdated) this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));\n      this.outdated = false;\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"line(\".concat(this.length).concat(this.collapsed ? -this.collapsed : \"\").concat(this.widgetHeight ? \":\" + this.widgetHeight : \"\", \")\");\n    }\n  }]);\n\n  return HeightMapText;\n}(HeightMapBlock);\n\nvar HeightMapGap = /*#__PURE__*/function (_HeightMap2) {\n  _inherits(HeightMapGap, _HeightMap2);\n\n  var _super18 = _createSuper(HeightMapGap);\n\n  function HeightMapGap(length) {\n    _classCallCheck(this, HeightMapGap);\n\n    return _super18.call(this, length, 0);\n  }\n\n  _createClass(HeightMapGap, [{\n    key: \"lines\",\n    value: function lines(doc, offset) {\n      var firstLine = doc.lineAt(offset).number,\n          lastLine = doc.lineAt(offset + this.length).number;\n      return {\n        firstLine: firstLine,\n        lastLine: lastLine,\n        lineHeight: this.height / (lastLine - firstLine + 1)\n      };\n    }\n  }, {\n    key: \"blockAt\",\n    value: function blockAt(height, doc, top, offset) {\n      var _this$lines = this.lines(doc, offset),\n          firstLine = _this$lines.firstLine,\n          lastLine = _this$lines.lastLine,\n          lineHeight = _this$lines.lineHeight;\n\n      var line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / lineHeight)));\n\n      var _doc$line = doc.line(firstLine + line),\n          from = _doc$line.from,\n          length = _doc$line.length;\n\n      return new BlockInfo(from, length, top + lineHeight * line, lineHeight, BlockType.Text);\n    }\n  }, {\n    key: \"lineAt\",\n    value: function lineAt(value, type, doc, top, offset) {\n      if (type == QueryType.ByHeight) return this.blockAt(value, doc, top, offset);\n\n      if (type == QueryType.ByPosNoHeight) {\n        var _doc$lineAt = doc.lineAt(value),\n            _from2 = _doc$lineAt.from,\n            to = _doc$lineAt.to;\n\n        return new BlockInfo(_from2, to - _from2, 0, 0, BlockType.Text);\n      }\n\n      var _this$lines2 = this.lines(doc, offset),\n          firstLine = _this$lines2.firstLine,\n          lineHeight = _this$lines2.lineHeight;\n\n      var _doc$lineAt2 = doc.lineAt(value),\n          from = _doc$lineAt2.from,\n          length = _doc$lineAt2.length,\n          number = _doc$lineAt2.number;\n\n      return new BlockInfo(from, length, top + lineHeight * (number - firstLine), lineHeight, BlockType.Text);\n    }\n  }, {\n    key: \"forEachLine\",\n    value: function forEachLine(from, to, doc, top, offset, f) {\n      var _this$lines3 = this.lines(doc, offset),\n          firstLine = _this$lines3.firstLine,\n          lineHeight = _this$lines3.lineHeight;\n\n      for (var pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end;) {\n        var line = doc.lineAt(pos);\n        if (pos == from) top += lineHeight * (line.number - firstLine);\n        f(new BlockInfo(line.from, line.length, top, lineHeight, BlockType.Text));\n        top += lineHeight;\n        pos = line.to + 1;\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, nodes) {\n      var after = this.length - to;\n\n      if (after > 0) {\n        var last = nodes[nodes.length - 1];\n        if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);else nodes.push(null, new HeightMapGap(after - 1));\n      }\n\n      if (from > 0) {\n        var first = nodes[0];\n        if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);else nodes.unshift(new HeightMapGap(from - 1), null);\n      }\n\n      return HeightMap.of(nodes);\n    }\n  }, {\n    key: \"decomposeLeft\",\n    value: function decomposeLeft(to, result) {\n      result.push(new HeightMapGap(to - 1), null);\n    }\n  }, {\n    key: \"decomposeRight\",\n    value: function decomposeRight(from, result) {\n      result.push(null, new HeightMapGap(this.length - from - 1));\n    }\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight(oracle) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var measured = arguments.length > 3 ? arguments[3] : undefined;\n      var end = offset + this.length;\n\n      if (measured && measured.from <= offset + this.length && measured.more) {\n        // Fill in part of this gap with measured lines. We know there\n        // can't be widgets or collapsed ranges in those lines, because\n        // they would already have been added to the heightmap (gaps\n        // only contain plain text).\n        var nodes = [],\n            pos = Math.max(offset, measured.from),\n            singleHeight = -1;\n        var wasChanged = oracle.heightChanged;\n        if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));\n\n        while (pos <= end && measured.more) {\n          var len = oracle.doc.lineAt(pos).length;\n          if (nodes.length) nodes.push(null);\n          var height = measured.heights[measured.index++];\n          if (singleHeight == -1) singleHeight = height;else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;\n          var line = new HeightMapText(len, height);\n          line.outdated = false;\n          nodes.push(line);\n          pos += len + 1;\n        }\n\n        if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));\n        var result = HeightMap.of(nodes);\n        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;\n        return result;\n      } else if (force || this.outdated) {\n        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));\n        this.outdated = false;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"gap(\".concat(this.length, \")\");\n    }\n  }]);\n\n  return HeightMapGap;\n}(HeightMap);\n\nvar HeightMapBranch = /*#__PURE__*/function (_HeightMap3) {\n  _inherits(HeightMapBranch, _HeightMap3);\n\n  var _super19 = _createSuper(HeightMapBranch);\n\n  function HeightMapBranch(left, brk, right) {\n    var _this24;\n\n    _classCallCheck(this, HeightMapBranch);\n\n    _this24 = _super19.call(this, left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2\n    /* Outdated */\n    : 0));\n    _this24.left = left;\n    _this24.right = right;\n    _this24.size = left.size + right.size;\n    return _this24;\n  }\n\n  _createClass(HeightMapBranch, [{\n    key: \"break\",\n    get: function get() {\n      return this.flags & 1\n      /* Break */\n      ;\n    }\n  }, {\n    key: \"blockAt\",\n    value: function blockAt(height, doc, top, offset) {\n      var mid = top + this.left.height;\n      return height < mid ? this.left.blockAt(height, doc, top, offset) : this.right.blockAt(height, doc, mid, offset + this.left.length + this[\"break\"]);\n    }\n  }, {\n    key: \"lineAt\",\n    value: function lineAt(value, type, doc, top, offset) {\n      var rightTop = top + this.left.height,\n          rightOffset = offset + this.left.length + this[\"break\"];\n      var left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;\n      var base = left ? this.left.lineAt(value, type, doc, top, offset) : this.right.lineAt(value, type, doc, rightTop, rightOffset);\n      if (this[\"break\"] || (left ? base.to < rightOffset : base.from > rightOffset)) return base;\n      var subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;\n      if (left) return base.join(this.right.lineAt(rightOffset, subQuery, doc, rightTop, rightOffset));else return this.left.lineAt(rightOffset, subQuery, doc, top, offset).join(base);\n    }\n  }, {\n    key: \"forEachLine\",\n    value: function forEachLine(from, to, doc, top, offset, f) {\n      var rightTop = top + this.left.height,\n          rightOffset = offset + this.left.length + this[\"break\"];\n\n      if (this[\"break\"]) {\n        if (from < rightOffset) this.left.forEachLine(from, to, doc, top, offset, f);\n        if (to >= rightOffset) this.right.forEachLine(from, to, doc, rightTop, rightOffset, f);\n      } else {\n        var mid = this.lineAt(rightOffset, QueryType.ByPos, doc, top, offset);\n        if (from < mid.from) this.left.forEachLine(from, mid.from - 1, doc, top, offset, f);\n        if (mid.to >= from && mid.from <= to) f(mid);\n        if (to > mid.to) this.right.forEachLine(mid.to + 1, to, doc, rightTop, rightOffset, f);\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, nodes) {\n      var rightStart = this.left.length + this[\"break\"];\n      if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);\n      if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));\n      var result = [];\n      if (from > 0) this.decomposeLeft(from, result);\n      var left = result.length;\n\n      var _iterator24 = _createForOfIteratorHelper(nodes),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var node = _step24.value;\n          result.push(node);\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      if (from > 0) mergeGaps(result, left - 1);\n\n      if (to < this.length) {\n        var right = result.length;\n        this.decomposeRight(to, result);\n        mergeGaps(result, right);\n      }\n\n      return HeightMap.of(result);\n    }\n  }, {\n    key: \"decomposeLeft\",\n    value: function decomposeLeft(to, result) {\n      var left = this.left.length;\n      if (to <= left) return this.left.decomposeLeft(to, result);\n      result.push(this.left);\n\n      if (this[\"break\"]) {\n        left++;\n        if (to >= left) result.push(null);\n      }\n\n      if (to > left) this.right.decomposeLeft(to - left, result);\n    }\n  }, {\n    key: \"decomposeRight\",\n    value: function decomposeRight(from, result) {\n      var left = this.left.length,\n          right = left + this[\"break\"];\n      if (from >= right) return this.right.decomposeRight(from - right, result);\n      if (from < left) this.left.decomposeRight(from, result);\n      if (this[\"break\"] && from < right) result.push(null);\n      result.push(this.right);\n    }\n  }, {\n    key: \"balanced\",\n    value: function balanced(left, right) {\n      if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this[\"break\"] ? [left, null, right] : [left, right]);\n      this.left = left;\n      this.right = right;\n      this.height = left.height + right.height;\n      this.outdated = left.outdated || right.outdated;\n      this.size = left.size + right.size;\n      this.length = left.length + this[\"break\"] + right.length;\n      return this;\n    }\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight(oracle) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var measured = arguments.length > 3 ? arguments[3] : undefined;\n      var left = this.left,\n          right = this.right,\n          rightStart = offset + left.length + this[\"break\"],\n          rebalance = null;\n      if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);else left.updateHeight(oracle, offset, force);\n      if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);else right.updateHeight(oracle, rightStart, force);\n      if (rebalance) return this.balanced(left, right);\n      this.height = this.left.height + this.right.height;\n      this.outdated = false;\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.left + (this[\"break\"] ? \" \" : \"-\") + this.right;\n    }\n  }]);\n\n  return HeightMapBranch;\n}(HeightMap);\n\nfunction mergeGaps(nodes, around) {\n  var before, after;\n  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));\n}\n\nvar relevantWidgetHeight = 5;\n\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(pos, oracle) {\n    _classCallCheck(this, NodeBuilder);\n\n    this.pos = pos;\n    this.oracle = oracle;\n    this.nodes = [];\n    this.lineStart = -1;\n    this.lineEnd = -1;\n    this.covering = null;\n    this.writtenTo = pos;\n  }\n\n  _createClass(NodeBuilder, [{\n    key: \"isCovered\",\n    get: function get() {\n      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n    }\n  }, {\n    key: \"span\",\n    value: function span(_from, to) {\n      if (this.lineStart > -1) {\n        var end = Math.min(to, this.lineEnd),\n            last = this.nodes[this.nodes.length - 1];\n        if (last instanceof HeightMapText) last.length += end - this.pos;else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));\n        this.writtenTo = end;\n\n        if (to > end) {\n          this.nodes.push(null);\n          this.writtenTo++;\n          this.lineStart = -1;\n        }\n      }\n\n      this.pos = to;\n    }\n  }, {\n    key: \"point\",\n    value: function point(from, to, deco) {\n      if (from < to || deco.heightRelevant) {\n        var height = deco.widget ? deco.widget.estimatedHeight : 0;\n        if (height < 0) height = this.oracle.lineHeight;\n        var len = to - from;\n\n        if (deco.block) {\n          this.addBlock(new HeightMapBlock(len, height, deco.type));\n        } else if (len || height >= relevantWidgetHeight) {\n          this.addLineDeco(height, len);\n        }\n      } else if (to > from) {\n        this.span(from, to);\n      }\n\n      if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;\n    }\n  }, {\n    key: \"enterLine\",\n    value: function enterLine() {\n      if (this.lineStart > -1) return;\n\n      var _this$oracle$doc$line = this.oracle.doc.lineAt(this.pos),\n          from = _this$oracle$doc$line.from,\n          to = _this$oracle$doc$line.to;\n\n      this.lineStart = from;\n      this.lineEnd = to;\n\n      if (this.writtenTo < from) {\n        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));\n        this.nodes.push(null);\n      }\n\n      if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));\n      this.writtenTo = this.pos;\n    }\n  }, {\n    key: \"blankContent\",\n    value: function blankContent(from, to) {\n      var gap = new HeightMapGap(to - from);\n      if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4\n      /* SingleLine */\n      ;\n      return gap;\n    }\n  }, {\n    key: \"ensureLine\",\n    value: function ensureLine() {\n      this.enterLine();\n      var last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n      if (last instanceof HeightMapText) return last;\n      var line = new HeightMapText(0, -1);\n      this.nodes.push(line);\n      return line;\n    }\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(block) {\n      this.enterLine();\n      if (block.type == BlockType.WidgetAfter && !this.isCovered) this.ensureLine();\n      this.nodes.push(block);\n      this.writtenTo = this.pos = this.pos + block.length;\n      if (block.type != BlockType.WidgetBefore) this.covering = block;\n    }\n  }, {\n    key: \"addLineDeco\",\n    value: function addLineDeco(height, length) {\n      var line = this.ensureLine();\n      line.length += length;\n      line.collapsed += length;\n      line.widgetHeight = Math.max(line.widgetHeight, height);\n      this.writtenTo = this.pos = this.pos + length;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(from) {\n      var last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n      var pos = from;\n\n      var _iterator25 = _createForOfIteratorHelper(this.nodes),\n          _step25;\n\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var node = _step25.value;\n          if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);\n          pos += node ? node.length : 1;\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n\n      return this.nodes;\n    } // Always called with a region that on both sides either stretches\n    // to a line break or the end of the document.\n    // The returned array uses null to indicate line breaks, but never\n    // starts or ends in a line break, or has multiple line breaks next\n    // to each other.\n\n  }], [{\n    key: \"build\",\n    value: function build(oracle, decorations, from, to) {\n      var builder = new NodeBuilder(from, oracle);\n      _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(decorations, from, to, builder, 0);\n      return builder.finish(from);\n    }\n  }]);\n\n  return NodeBuilder;\n}();\n\nfunction heightRelevantDecoChanges(a, b, diff) {\n  var comp = new DecorationComparator();\n  _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.compare(a, b, diff, comp, 0);\n  return comp.changes;\n}\n\nvar DecorationComparator = /*#__PURE__*/function () {\n  function DecorationComparator() {\n    _classCallCheck(this, DecorationComparator);\n\n    this.changes = [];\n  }\n\n  _createClass(DecorationComparator, [{\n    key: \"compareRange\",\n    value: function compareRange() {}\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(from, to, a, b) {\n      if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);\n    }\n  }]);\n\n  return DecorationComparator;\n}();\n\nfunction visiblePixelRange(dom, paddingTop) {\n  var rect = dom.getBoundingClientRect();\n  var left = Math.max(0, rect.left),\n      right = Math.min(innerWidth, rect.right);\n  var top = Math.max(0, rect.top),\n      bottom = Math.min(innerHeight, rect.bottom);\n  var body = dom.ownerDocument.body;\n\n  for (var parent = dom.parentNode; parent && parent != body;) {\n    if (parent.nodeType == 1) {\n      var elt = parent;\n      var style = window.getComputedStyle(elt);\n\n      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != \"visible\") {\n        var parentRect = elt.getBoundingClientRect();\n        left = Math.max(left, parentRect.left);\n        right = Math.min(right, parentRect.right);\n        top = Math.max(top, parentRect.top);\n        bottom = Math.min(bottom, parentRect.bottom);\n      }\n\n      parent = style.position == \"absolute\" || style.position == \"fixed\" ? elt.offsetParent : elt.parentNode;\n    } else if (parent.nodeType == 11) {\n      // Shadow root\n      parent = parent.host;\n    } else {\n      break;\n    }\n  }\n\n  return {\n    left: left - rect.left,\n    right: Math.max(left, right) - rect.left,\n    top: top - (rect.top + paddingTop),\n    bottom: Math.max(top, bottom) - (rect.top + paddingTop)\n  };\n} // Line gaps are placeholder widgets used to hide pieces of overlong\n// lines within the viewport, as a kludge to keep the editor\n// responsive when a ridiculously long line is loaded into it.\n\n\nvar LineGap = /*#__PURE__*/function () {\n  function LineGap(from, to, size) {\n    _classCallCheck(this, LineGap);\n\n    this.from = from;\n    this.to = to;\n    this.size = size;\n  }\n\n  _createClass(LineGap, [{\n    key: \"draw\",\n    value: function draw(wrapping) {\n      return Decoration.replace({\n        widget: new LineGapWidget(this.size, wrapping)\n      }).range(this.from, this.to);\n    }\n  }], [{\n    key: \"same\",\n    value: function same(a, b) {\n      if (a.length != b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        var gA = a[i],\n            gB = b[i];\n        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;\n      }\n\n      return true;\n    }\n  }]);\n\n  return LineGap;\n}();\n\nvar LineGapWidget = /*#__PURE__*/function (_WidgetType4) {\n  _inherits(LineGapWidget, _WidgetType4);\n\n  var _super20 = _createSuper(LineGapWidget);\n\n  function LineGapWidget(size, vertical) {\n    var _this25;\n\n    _classCallCheck(this, LineGapWidget);\n\n    _this25 = _super20.call(this);\n    _this25.size = size;\n    _this25.vertical = vertical;\n    return _this25;\n  }\n\n  _createClass(LineGapWidget, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other.size == this.size && other.vertical == this.vertical;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM() {\n      var elt = document.createElement(\"div\");\n\n      if (this.vertical) {\n        elt.style.height = this.size + \"px\";\n      } else {\n        elt.style.width = this.size + \"px\";\n        elt.style.height = \"2px\";\n        elt.style.display = \"inline-block\";\n      }\n\n      return elt;\n    }\n  }, {\n    key: \"estimatedHeight\",\n    get: function get() {\n      return this.vertical ? this.size : -1;\n    }\n  }]);\n\n  return LineGapWidget;\n}(WidgetType);\n\nvar ViewState = /*#__PURE__*/function () {\n  function ViewState(state) {\n    _classCallCheck(this, ViewState);\n\n    this.state = state; // These are contentDOM-local coordinates\n\n    this.pixelViewport = {\n      left: 0,\n      right: window.innerWidth,\n      top: 0,\n      bottom: 0\n    };\n    this.inView = true;\n    this.paddingTop = 0;\n    this.paddingBottom = 0;\n    this.contentDOMWidth = 0;\n    this.contentDOMHeight = 0;\n    this.editorHeight = 0;\n    this.editorWidth = 0;\n    this.heightOracle = new HeightOracle(); // See VP.MaxDOMHeight\n\n    this.scaler = IdScaler;\n    this.scrollTarget = null; // Briefly set to true when printing, to disable viewport limiting\n\n    this.printing = false; // Flag set when editor content was redrawn, so that the next\n    // measure stage knows it must read DOM layout\n\n    this.mustMeasureContent = true;\n    this.visibleRanges = []; // Cursor 'assoc' is only significant when the cursor is on a line\n    // wrap point, where it must stick to the character that it is\n    // associated with. Since browsers don't provide a reasonable\n    // interface to set or query this, when a selection is set that\n    // might cause this to be significant, this flag is set. The next\n    // measure phase will check whether the cursor is on a line-wrapping\n    // boundary and, if so, reset it to make sure it is positioned in\n    // the right place.\n\n    this.mustEnforceCursorAssoc = false;\n    this.heightMap = HeightMap.empty().applyChanges(state.facet(decorations), _codemirror_text__WEBPACK_IMPORTED_MODULE_3__.Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);\n    this.viewport = this.getViewport(0, null);\n    this.updateViewportLines();\n    this.updateForViewport();\n    this.lineGaps = this.ensureLineGaps([]);\n    this.lineGapDeco = Decoration.set(this.lineGaps.map(function (gap) {\n      return gap.draw(false);\n    }));\n    this.computeVisibleRanges();\n  }\n\n  _createClass(ViewState, [{\n    key: \"updateForViewport\",\n    value: function updateForViewport() {\n      var _this26 = this;\n\n      var viewports = [this.viewport],\n          main = this.state.selection.main;\n\n      var _loop4 = function _loop4(i) {\n        var pos = i ? main.head : main.anchor;\n\n        if (!viewports.some(function (_ref7) {\n          var from = _ref7.from,\n              to = _ref7.to;\n          return pos >= from && pos <= to;\n        })) {\n          var _this26$lineBlockAt = _this26.lineBlockAt(pos),\n              from = _this26$lineBlockAt.from,\n              to = _this26$lineBlockAt.to;\n\n          viewports.push(new Viewport(from, to));\n        }\n      };\n\n      for (var i = 0; i <= 1; i++) {\n        _loop4(i);\n      }\n\n      this.viewports = viewports.sort(function (a, b) {\n        return a.from - b.from;\n      });\n      this.scaler = this.heightMap.height <= 7000000\n      /* MaxDOMHeight */\n      ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);\n    }\n  }, {\n    key: \"updateViewportLines\",\n    value: function updateViewportLines() {\n      var _this27 = this;\n\n      this.viewportLines = [];\n      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, function (block) {\n        _this27.viewportLines.push(_this27.scaler.scale == 1 ? block : scaleBlock(block, _this27.scaler));\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update5) {\n      var scrollTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var prev = this.state;\n      this.state = _update5.state;\n      var newDeco = this.state.facet(decorations);\n      var contentChanges = _update5.changedRanges;\n      var heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(_update5.startState.facet(decorations), newDeco, _update5 ? _update5.changes : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.ChangeSet.empty(this.state.doc.length)));\n      var prevHeight = this.heightMap.height;\n      this.heightMap = this.heightMap.applyChanges(newDeco, prev.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);\n      if (this.heightMap.height != prevHeight) _update5.flags |= 2\n      /* Height */\n      ;\n      var viewport = heightChanges.length ? this.mapViewport(this.viewport, _update5.changes) : this.viewport;\n      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);\n      var updateLines = !_update5.changes.empty || _update5.flags & 2\n      /* Height */\n      || viewport.from != this.viewport.from || viewport.to != this.viewport.to;\n      this.viewport = viewport;\n      this.updateForViewport();\n      if (updateLines) this.updateViewportLines();\n      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4000\n      /* DoubleMargin */\n      ) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, _update5.changes)));\n      _update5.flags |= this.computeVisibleRanges();\n      if (scrollTarget) this.scrollTarget = scrollTarget;\n      if (!this.mustEnforceCursorAssoc && _update5.selectionSet && _update5.view.lineWrapping && _update5.state.selection.main.empty && _update5.state.selection.main.assoc) this.mustEnforceCursorAssoc = true;\n    }\n  }, {\n    key: \"measure\",\n    value: function measure(view) {\n      var dom = view.contentDOM,\n          style = window.getComputedStyle(dom);\n      var oracle = this.heightOracle;\n      var whiteSpace = style.whiteSpace,\n          direction = style.direction == \"rtl\" ? Direction.RTL : Direction.LTR;\n      var refresh = this.heightOracle.mustRefreshForStyle(whiteSpace, direction);\n      var measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;\n      var result = 0,\n          bias = 0;\n\n      if (measureContent) {\n        this.mustMeasureContent = false;\n        this.contentDOMHeight = dom.clientHeight; // Vertical padding\n\n        var paddingTop = parseInt(style.paddingTop) || 0,\n            paddingBottom = parseInt(style.paddingBottom) || 0;\n\n        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {\n          result |= 8\n          /* Geometry */\n          ;\n          this.paddingTop = paddingTop;\n          this.paddingBottom = paddingBottom;\n        }\n      } // Pixel viewport\n\n\n      var pixelViewport = this.printing ? {\n        top: -1e8,\n        bottom: 1e8,\n        left: -1e8,\n        right: 1e8\n      } : visiblePixelRange(dom, this.paddingTop);\n      var dTop = pixelViewport.top - this.pixelViewport.top,\n          dBottom = pixelViewport.bottom - this.pixelViewport.bottom;\n      this.pixelViewport = pixelViewport;\n      var inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n\n      if (inView != this.inView) {\n        this.inView = inView;\n        if (inView) measureContent = true;\n      }\n\n      if (!this.inView) return 0;\n      var contentWidth = dom.clientWidth;\n\n      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight || this.editorWidth != view.scrollDOM.clientWidth) {\n        this.contentDOMWidth = contentWidth;\n        this.editorHeight = view.scrollDOM.clientHeight;\n        this.editorWidth = view.scrollDOM.clientWidth;\n        result |= 8\n        /* Geometry */\n        ;\n      }\n\n      if (measureContent) {\n        var lineHeights = view.docView.measureVisibleLineHeights();\n        if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;\n\n        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {\n          var _view$docView$measure = view.docView.measureTextSize(),\n              lineHeight = _view$docView$measure.lineHeight,\n              charWidth = _view$docView$measure.charWidth;\n\n          refresh = oracle.refresh(whiteSpace, direction, lineHeight, charWidth, contentWidth / charWidth, lineHeights);\n\n          if (refresh) {\n            view.docView.minWidth = 0;\n            result |= 8\n            /* Geometry */\n            ;\n          }\n        }\n\n        if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);\n        oracle.heightChanged = false;\n        this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(this.viewport.from, lineHeights));\n        if (oracle.heightChanged) result |= 2\n        /* Height */\n        ;\n      }\n\n      var viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n      if (viewportChange) this.viewport = this.getViewport(bias, this.scrollTarget);\n      this.updateForViewport();\n      if (result & 2\n      /* Height */\n      || viewportChange) this.updateViewportLines();\n      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4000\n      /* DoubleMargin */\n      ) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));\n      result |= this.computeVisibleRanges();\n\n      if (this.mustEnforceCursorAssoc) {\n        this.mustEnforceCursorAssoc = false; // This is done in the read stage, because moving the selection\n        // to a line end is going to trigger a layout anyway, so it\n        // can't be a pure write. It should be rare that it does any\n        // writing.\n\n        view.docView.enforceCursorAssoc();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"visibleTop\",\n    get: function get() {\n      return this.scaler.fromDOM(this.pixelViewport.top);\n    }\n  }, {\n    key: \"visibleBottom\",\n    get: function get() {\n      return this.scaler.fromDOM(this.pixelViewport.bottom);\n    }\n  }, {\n    key: \"getViewport\",\n    value: function getViewport(bias, scrollTarget) {\n      // This will divide VP.Margin between the top and the\n      // bottom, depending on the bias (the change in viewport position\n      // since the last update). It'll hold a number between 0 and 1\n      var marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000\n      /* Margin */\n      / 2));\n      var map = this.heightMap,\n          doc = this.state.doc,\n          visibleTop = this.visibleTop,\n          visibleBottom = this.visibleBottom;\n      var viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000\n      /* Margin */\n      , QueryType.ByHeight, doc, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000\n      /* Margin */\n      , QueryType.ByHeight, doc, 0, 0).to); // If scrollTarget is given, make sure the viewport includes that position\n\n      if (scrollTarget) {\n        var head = scrollTarget.range.head,\n            viewHeight = this.editorHeight;\n\n        if (head < viewport.from || head > viewport.to) {\n          var block = map.lineAt(head, QueryType.ByPos, doc, 0, 0),\n              topPos;\n          if (scrollTarget.y == \"center\") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;else if (scrollTarget.y == \"start\" || scrollTarget.y == \"nearest\" && head < viewport.from) topPos = block.top;else topPos = block.bottom - viewHeight;\n          viewport = new Viewport(map.lineAt(topPos - 1000\n          /* Margin */\n          / 2, QueryType.ByHeight, doc, 0, 0).from, map.lineAt(topPos + viewHeight + 1000\n          /* Margin */\n          / 2, QueryType.ByHeight, doc, 0, 0).to);\n        }\n      }\n\n      return viewport;\n    }\n  }, {\n    key: \"mapViewport\",\n    value: function mapViewport(viewport, changes) {\n      var from = changes.mapPos(viewport.from, -1),\n          to = changes.mapPos(viewport.to, 1);\n      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);\n    } // Checks if a given viewport covers the visible part of the\n    // document and not too much beyond that.\n\n  }, {\n    key: \"viewportIsAppropriate\",\n    value: function viewportIsAppropriate(_ref8) {\n      var from = _ref8.from,\n          to = _ref8.to;\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      if (!this.inView) return true;\n\n      var _this$heightMap$lineA = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0),\n          top = _this$heightMap$lineA.top;\n\n      var _this$heightMap$lineA2 = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0),\n          bottom = _this$heightMap$lineA2.bottom;\n\n      var visibleTop = this.visibleTop,\n          visibleBottom = this.visibleBottom;\n      return (from == 0 || top <= visibleTop - Math.max(10\n      /* MinCoverMargin */\n      , Math.min(-bias, 250\n      /* MaxCoverMargin */\n      ))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10\n      /* MinCoverMargin */\n      , Math.min(bias, 250\n      /* MaxCoverMargin */\n      ))) && top > visibleTop - 2 * 1000\n      /* Margin */\n      && bottom < visibleBottom + 2 * 1000\n      /* Margin */\n      ;\n    }\n  }, {\n    key: \"mapLineGaps\",\n    value: function mapLineGaps(gaps, changes) {\n      if (!gaps.length || changes.empty) return gaps;\n      var mapped = [];\n\n      var _iterator26 = _createForOfIteratorHelper(gaps),\n          _step26;\n\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var gap = _step26.value;\n          if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n\n      return mapped;\n    } // Computes positions in the viewport where the start or end of a\n    // line should be hidden, trying to reuse existing line gaps when\n    // appropriate to avoid unneccesary redraws.\n    // Uses crude character-counting for the positioning and sizing,\n    // since actual DOM coordinates aren't always available and\n    // predictable. Relies on generous margins (see LG.Margin) to hide\n    // the artifacts this might produce from the user.\n\n  }, {\n    key: \"ensureLineGaps\",\n    value: function ensureLineGaps(current) {\n      var _this28 = this;\n\n      var gaps = []; // This won't work at all in predominantly right-to-left text.\n\n      if (this.heightOracle.direction != Direction.LTR) return gaps;\n\n      var _iterator27 = _createForOfIteratorHelper(this.viewportLines),\n          _step27;\n\n      try {\n        var _loop5 = function _loop5() {\n          var line = _step27.value;\n          if (line.length < 4000\n          /* DoubleMargin */\n          ) return \"continue\";\n          var structure = lineStructure(line.from, line.to, _this28.state);\n          if (structure.total < 4000\n          /* DoubleMargin */\n          ) return \"continue\";\n          var viewFrom = void 0,\n              viewTo = void 0;\n\n          if (_this28.heightOracle.lineWrapping) {\n            var marginHeight = 2000\n            /* Margin */\n            / _this28.heightOracle.lineLength * _this28.heightOracle.lineHeight;\n            viewFrom = findPosition(structure, (_this28.visibleTop - line.top - marginHeight) / line.height);\n            viewTo = findPosition(structure, (_this28.visibleBottom - line.top + marginHeight) / line.height);\n          } else {\n            var totalWidth = structure.total * _this28.heightOracle.charWidth;\n            var marginWidth = 2000\n            /* Margin */\n            * _this28.heightOracle.charWidth;\n            viewFrom = findPosition(structure, (_this28.pixelViewport.left - marginWidth) / totalWidth);\n            viewTo = findPosition(structure, (_this28.pixelViewport.right + marginWidth) / totalWidth);\n          }\n\n          var outside = [];\n          if (viewFrom > line.from) outside.push({\n            from: line.from,\n            to: viewFrom\n          });\n          if (viewTo < line.to) outside.push({\n            from: viewTo,\n            to: line.to\n          });\n          var sel = _this28.state.selection.main; // Make sure the gaps don't cover a selection end\n\n          if (sel.from >= line.from && sel.from <= line.to) cutRange(outside, sel.from - 10\n          /* SelectionMargin */\n          , sel.from + 10\n          /* SelectionMargin */\n          );\n          if (!sel.empty && sel.to >= line.from && sel.to <= line.to) cutRange(outside, sel.to - 10\n          /* SelectionMargin */\n          , sel.to + 10\n          /* SelectionMargin */\n          );\n\n          var _loop6 = function _loop6() {\n            var _outside$_i = _outside[_i9],\n                from = _outside$_i.from,\n                to = _outside$_i.to;\n\n            if (to - from > 1000\n            /* HalfMargin */\n            ) {\n              gaps.push(find(current, function (gap) {\n                return gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < 1000\n                /* HalfMargin */\n                && Math.abs(gap.to - to) < 1000;\n              }\n              /* HalfMargin */\n              ) || new LineGap(from, to, _this28.gapSize(line, from, to, structure)));\n            }\n          };\n\n          for (var _i9 = 0, _outside = outside; _i9 < _outside.length; _i9++) {\n            _loop6();\n          }\n        };\n\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var _ret = _loop5();\n\n          if (_ret === \"continue\") continue;\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      return gaps;\n    }\n  }, {\n    key: \"gapSize\",\n    value: function gapSize(line, from, to, structure) {\n      var fraction = findFraction(structure, to) - findFraction(structure, from);\n\n      if (this.heightOracle.lineWrapping) {\n        return line.height * fraction;\n      } else {\n        return structure.total * this.heightOracle.charWidth * fraction;\n      }\n    }\n  }, {\n    key: \"updateLineGaps\",\n    value: function updateLineGaps(gaps) {\n      var _this29 = this;\n\n      if (!LineGap.same(gaps, this.lineGaps)) {\n        this.lineGaps = gaps;\n        this.lineGapDeco = Decoration.set(gaps.map(function (gap) {\n          return gap.draw(_this29.heightOracle.lineWrapping);\n        }));\n      }\n    }\n  }, {\n    key: \"computeVisibleRanges\",\n    value: function computeVisibleRanges() {\n      var deco = this.state.facet(decorations);\n      if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);\n      var ranges = [];\n      _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(deco, this.viewport.from, this.viewport.to, {\n        span: function span(from, to) {\n          ranges.push({\n            from: from,\n            to: to\n          });\n        },\n        point: function point() {}\n      }, 20);\n      var changed = ranges.length != this.visibleRanges.length || this.visibleRanges.some(function (r, i) {\n        return r.from != ranges[i].from || r.to != ranges[i].to;\n      });\n      this.visibleRanges = ranges;\n      return changed ? 4\n      /* Viewport */\n      : 0;\n    }\n  }, {\n    key: \"lineBlockAt\",\n    value: function lineBlockAt(pos) {\n      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(function (b) {\n        return b.from <= pos && b.to >= pos;\n      }) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);\n    }\n  }, {\n    key: \"lineBlockAtHeight\",\n    value: function lineBlockAtHeight(height) {\n      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);\n    }\n  }, {\n    key: \"elementAtHeight\",\n    value: function elementAtHeight(height) {\n      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);\n    }\n  }, {\n    key: \"docHeight\",\n    get: function get() {\n      return this.scaler.toDOM(this.heightMap.height);\n    }\n  }, {\n    key: \"contentHeight\",\n    get: function get() {\n      return this.docHeight + this.paddingTop + this.paddingBottom;\n    }\n  }]);\n\n  return ViewState;\n}();\n\nvar Viewport = function Viewport(from, to) {\n  _classCallCheck(this, Viewport);\n\n  this.from = from;\n  this.to = to;\n};\n\nfunction lineStructure(from, to, state) {\n  var ranges = [],\n      pos = from,\n      total = 0;\n  _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSet.spans(state.facet(decorations), from, to, {\n    span: function span() {},\n    point: function point(from, to) {\n      if (from > pos) {\n        ranges.push({\n          from: pos,\n          to: from\n        });\n        total += from - pos;\n      }\n\n      pos = to;\n    }\n  }, 20); // We're only interested in collapsed ranges of a significant size\n\n  if (pos < to) {\n    ranges.push({\n      from: pos,\n      to: to\n    });\n    total += to - pos;\n  }\n\n  return {\n    total: total,\n    ranges: ranges\n  };\n}\n\nfunction findPosition(_ref9, ratio) {\n  var total = _ref9.total,\n      ranges = _ref9.ranges;\n  if (ratio <= 0) return ranges[0].from;\n  if (ratio >= 1) return ranges[ranges.length - 1].to;\n  var dist = Math.floor(total * ratio);\n\n  for (var i = 0;; i++) {\n    var _ranges$i = ranges[i],\n        from = _ranges$i.from,\n        to = _ranges$i.to,\n        size = to - from;\n    if (dist <= size) return from + dist;\n    dist -= size;\n  }\n}\n\nfunction findFraction(structure, pos) {\n  var counted = 0;\n\n  var _iterator28 = _createForOfIteratorHelper(structure.ranges),\n      _step28;\n\n  try {\n    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n      var _step28$value = _step28.value,\n          from = _step28$value.from,\n          to = _step28$value.to;\n\n      if (pos <= to) {\n        counted += pos - from;\n        break;\n      }\n\n      counted += to - from;\n    }\n  } catch (err) {\n    _iterator28.e(err);\n  } finally {\n    _iterator28.f();\n  }\n\n  return counted / structure.total;\n}\n\nfunction cutRange(ranges, from, to) {\n  for (var i = 0; i < ranges.length; i++) {\n    var _r = ranges[i];\n\n    if (_r.from < to && _r.to > from) {\n      var pieces = [];\n      if (_r.from < from) pieces.push({\n        from: _r.from,\n        to: from\n      });\n      if (_r.to > to) pieces.push({\n        from: to,\n        to: _r.to\n      });\n      ranges.splice.apply(ranges, [i, 1].concat(pieces));\n      i += pieces.length - 1;\n    }\n  }\n}\n\nfunction find(array, f) {\n  var _iterator29 = _createForOfIteratorHelper(array),\n      _step29;\n\n  try {\n    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n      var val = _step29.value;\n      if (f(val)) return val;\n    }\n  } catch (err) {\n    _iterator29.e(err);\n  } finally {\n    _iterator29.f();\n  }\n\n  return undefined;\n} // Don't scale when the document height is within the range of what\n// the DOM can handle.\n\n\nvar IdScaler = {\n  toDOM: function toDOM(n) {\n    return n;\n  },\n  fromDOM: function fromDOM(n) {\n    return n;\n  },\n  scale: 1\n}; // When the height is too big (> VP.MaxDOMHeight), scale down the\n// regions outside the viewports so that the total height is\n// VP.MaxDOMHeight.\n\nvar BigScaler = /*#__PURE__*/function () {\n  function BigScaler(doc, heightMap, viewports) {\n    _classCallCheck(this, BigScaler);\n\n    var vpHeight = 0,\n        base = 0,\n        domBase = 0;\n    this.viewports = viewports.map(function (_ref10) {\n      var from = _ref10.from,\n          to = _ref10.to;\n      var top = heightMap.lineAt(from, QueryType.ByPos, doc, 0, 0).top;\n      var bottom = heightMap.lineAt(to, QueryType.ByPos, doc, 0, 0).bottom;\n      vpHeight += bottom - top;\n      return {\n        from: from,\n        to: to,\n        top: top,\n        bottom: bottom,\n        domTop: 0,\n        domBottom: 0\n      };\n    });\n    this.scale = (7000000\n    /* MaxDOMHeight */\n    - vpHeight) / (heightMap.height - vpHeight);\n\n    var _iterator30 = _createForOfIteratorHelper(this.viewports),\n        _step30;\n\n    try {\n      for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n        var obj = _step30.value;\n        obj.domTop = domBase + (obj.top - base) * this.scale;\n        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);\n        base = obj.bottom;\n      }\n    } catch (err) {\n      _iterator30.e(err);\n    } finally {\n      _iterator30.f();\n    }\n  }\n\n  _createClass(BigScaler, [{\n    key: \"toDOM\",\n    value: function toDOM(n) {\n      for (var i = 0, _base = 0, domBase = 0;; i++) {\n        var vp = i < this.viewports.length ? this.viewports[i] : null;\n        if (!vp || n < vp.top) return domBase + (n - _base) * this.scale;\n        if (n <= vp.bottom) return vp.domTop + (n - vp.top);\n        _base = vp.bottom;\n        domBase = vp.domBottom;\n      }\n    }\n  }, {\n    key: \"fromDOM\",\n    value: function fromDOM(n) {\n      for (var i = 0, _base2 = 0, domBase = 0;; i++) {\n        var vp = i < this.viewports.length ? this.viewports[i] : null;\n        if (!vp || n < vp.domTop) return _base2 + (n - domBase) / this.scale;\n        if (n <= vp.domBottom) return vp.top + (n - vp.domTop);\n        _base2 = vp.bottom;\n        domBase = vp.domBottom;\n      }\n    }\n  }]);\n\n  return BigScaler;\n}();\n\nfunction scaleBlock(block, scaler) {\n  if (scaler.scale == 1) return block;\n  var bTop = scaler.toDOM(block.top),\n      bBottom = scaler.toDOM(block.bottom);\n  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map(function (b) {\n    return scaleBlock(b, scaler);\n  }) : block.type);\n}\n\nvar _theme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n  combine: function combine(strs) {\n    return strs.join(\" \");\n  }\n});\n\nvar darkTheme = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n  combine: function combine(values) {\n    return values.indexOf(true) > -1;\n  }\n});\nvar baseThemeID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(),\n    baseLightID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName(),\n    baseDarkID = /*@__PURE__*/style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\nvar lightDarkIDs = {\n  \"&light\": \".\" + baseLightID,\n  \"&dark\": \".\" + baseDarkID\n};\n\nfunction buildTheme(main, spec, scopes) {\n  return new style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule(spec, {\n    finish: function finish(sel) {\n      return /&/.test(sel) ? sel.replace(/&\\w*/, function (m) {\n        if (m == \"&\") return main;\n        if (!scopes || !scopes[m]) throw new RangeError(\"Unsupported selector: \".concat(m));\n        return scopes[m];\n      }) : main + \" \" + sel;\n    }\n  });\n}\n\nvar baseTheme = /*@__PURE__*/buildTheme(\".\" + baseThemeID, {\n  \"&.cm-editor\": {\n    position: \"relative !important\",\n    boxSizing: \"border-box\",\n    \"&.cm-focused\": {\n      // Provide a simple default outline to make sure a focused\n      // editor is visually distinct. Can't leave the default behavior\n      // because that will apply to the content element, which is\n      // inside the scrollable container and doesn't include the\n      // gutters. We also can't use an 'auto' outline, since those\n      // are, for some reason, drawn behind the element content, which\n      // will cause things like the active line background to cover\n      // the outline (#297).\n      outline: \"1px dotted #212121\"\n    },\n    display: \"flex !important\",\n    flexDirection: \"column\"\n  },\n  \".cm-scroller\": {\n    display: \"flex !important\",\n    alignItems: \"flex-start !important\",\n    fontFamily: \"monospace\",\n    lineHeight: 1.4,\n    height: \"100%\",\n    overflowX: \"auto\",\n    position: \"relative\",\n    zIndex: 0\n  },\n  \".cm-content\": {\n    margin: 0,\n    flexGrow: 2,\n    minHeight: \"100%\",\n    display: \"block\",\n    whiteSpace: \"pre\",\n    wordWrap: \"normal\",\n    boxSizing: \"border-box\",\n    padding: \"4px 0\",\n    outline: \"none\",\n    \"&[contenteditable=true]\": {\n      WebkitUserModify: \"read-write-plaintext-only\"\n    }\n  },\n  \".cm-lineWrapping\": {\n    whiteSpace_fallback: \"pre-wrap\",\n    whiteSpace: \"break-spaces\",\n    wordBreak: \"break-word\",\n    overflowWrap: \"anywhere\"\n  },\n  \"&light .cm-content\": {\n    caretColor: \"black\"\n  },\n  \"&dark .cm-content\": {\n    caretColor: \"white\"\n  },\n  \".cm-line\": {\n    display: \"block\",\n    padding: \"0 2px 0 4px\"\n  },\n  \".cm-selectionLayer\": {\n    zIndex: -1,\n    contain: \"size style\"\n  },\n  \".cm-selectionBackground\": {\n    position: \"absolute\"\n  },\n  \"&light .cm-selectionBackground\": {\n    background: \"#d9d9d9\"\n  },\n  \"&dark .cm-selectionBackground\": {\n    background: \"#222\"\n  },\n  \"&light.cm-focused .cm-selectionBackground\": {\n    background: \"#d7d4f0\"\n  },\n  \"&dark.cm-focused .cm-selectionBackground\": {\n    background: \"#233\"\n  },\n  \".cm-cursorLayer\": {\n    zIndex: 100,\n    contain: \"size style\",\n    pointerEvents: \"none\"\n  },\n  \"&.cm-focused .cm-cursorLayer\": {\n    animation: \"steps(1) cm-blink 1.2s infinite\"\n  },\n  // Two animations defined so that we can switch between them to\n  // restart the animation without forcing another style\n  // recomputation.\n  \"@keyframes cm-blink\": {\n    \"0%\": {},\n    \"50%\": {\n      visibility: \"hidden\"\n    },\n    \"100%\": {}\n  },\n  \"@keyframes cm-blink2\": {\n    \"0%\": {},\n    \"50%\": {\n      visibility: \"hidden\"\n    },\n    \"100%\": {}\n  },\n  \".cm-cursor, .cm-dropCursor\": {\n    position: \"absolute\",\n    borderLeft: \"1.2px solid black\",\n    marginLeft: \"-0.6px\",\n    pointerEvents: \"none\"\n  },\n  \".cm-cursor\": {\n    display: \"none\"\n  },\n  \"&dark .cm-cursor\": {\n    borderLeftColor: \"#444\"\n  },\n  \"&.cm-focused .cm-cursor\": {\n    display: \"block\"\n  },\n  \"&light .cm-activeLine\": {\n    backgroundColor: \"#f3f9ff\"\n  },\n  \"&dark .cm-activeLine\": {\n    backgroundColor: \"#223039\"\n  },\n  \"&light .cm-specialChar\": {\n    color: \"red\"\n  },\n  \"&dark .cm-specialChar\": {\n    color: \"#f78\"\n  },\n  \".cm-tab\": {\n    display: \"inline-block\",\n    overflow: \"hidden\",\n    verticalAlign: \"bottom\"\n  },\n  \".cm-placeholder\": {\n    color: \"#888\",\n    display: \"inline-block\",\n    verticalAlign: \"top\"\n  },\n  \".cm-button\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    padding: \".2em 1em\",\n    borderRadius: \"1px\"\n  },\n  \"&light .cm-button\": {\n    backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n    }\n  },\n  \"&dark .cm-button\": {\n    backgroundImage: \"linear-gradient(#393939, #111)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#111, #333)\"\n    }\n  },\n  \".cm-textfield\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    border: \"1px solid silver\",\n    padding: \".2em .5em\"\n  },\n  \"&light .cm-textfield\": {\n    backgroundColor: \"white\"\n  },\n  \"&dark .cm-textfield\": {\n    border: \"1px solid #555\",\n    backgroundColor: \"inherit\"\n  }\n}, lightDarkIDs);\nvar observeOptions = {\n  childList: true,\n  characterData: true,\n  subtree: true,\n  attributes: true,\n  characterDataOldValue: true\n}; // IE11 has very broken mutation observers, so we also listen to\n// DOMCharacterDataModified there\n\nvar useCharData = browser.ie && browser.ie_version <= 11;\n\nvar DOMObserver = /*#__PURE__*/function () {\n  function DOMObserver(view, onChange, onScrollChanged) {\n    var _this30 = this;\n\n    _classCallCheck(this, DOMObserver);\n\n    this.view = view;\n    this.onChange = onChange;\n    this.onScrollChanged = onScrollChanged;\n    this.active = false; // The known selection. Kept in our own object, as opposed to just\n    // directly accessing the selection because:\n    //  - Safari doesn't report the right selection in shadow DOM\n    //  - Reading from the selection forces a DOM layout\n    //  - This way, we can ignore selectionchange events if we have\n    //    already seen the 'new' selection\n\n    this.selectionRange = new DOMSelectionState(); // Set when a selection change is detected, cleared on flush\n\n    this.selectionChanged = false;\n    this.delayedFlush = -1;\n    this.resizeTimeout = -1;\n    this.queue = [];\n    this.delayedAndroidKey = null;\n    this.scrollTargets = [];\n    this.intersection = null;\n    this.resize = null;\n    this.intersecting = false;\n    this.gapIntersection = null;\n    this.gaps = []; // Timeout for scheduling check of the parents that need scroll handlers\n\n    this.parentCheck = -1;\n    this.dom = view.contentDOM;\n    this.observer = new MutationObserver(function (mutations) {\n      var _iterator31 = _createForOfIteratorHelper(mutations),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var mut = _step31.value;\n\n          _this30.queue.push(mut);\n        } // IE11 will sometimes (on typing over a selection or\n        // backspacing out a single character text node) call the\n        // observer callback before actually updating the DOM.\n        //\n        // Unrelatedly, iOS Safari will, when ending a composition,\n        // sometimes first clear it, deliver the mutations, and then\n        // reinsert the finished text. CodeMirror's handling of the\n        // deletion will prevent the reinsertion from happening,\n        // breaking composition.\n\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(function (m) {\n        return m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length;\n      })) _this30.flushSoon();else _this30.flush();\n    });\n    if (useCharData) this.onCharData = function (event) {\n      _this30.queue.push({\n        target: event.target,\n        type: \"characterData\",\n        oldValue: event.prevValue\n      });\n\n      _this30.flushSoon();\n    };\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n\n    if (typeof ResizeObserver == \"function\") {\n      this.resize = new ResizeObserver(function () {\n        if (_this30.view.docView.lastUpdate < Date.now() - 75 && _this30.resizeTimeout < 0) _this30.resizeTimeout = setTimeout(function () {\n          _this30.resizeTimeout = -1;\n\n          _this30.view.requestMeasure();\n        }, 50);\n      });\n      this.resize.observe(view.scrollDOM);\n    }\n\n    this.start();\n    this.onScroll = this.onScroll.bind(this);\n    window.addEventListener(\"scroll\", this.onScroll);\n\n    if (typeof IntersectionObserver == \"function\") {\n      this.intersection = new IntersectionObserver(function (entries) {\n        if (_this30.parentCheck < 0) _this30.parentCheck = setTimeout(_this30.listenForScroll.bind(_this30), 1000);\n\n        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != _this30.intersecting) {\n          _this30.intersecting = !_this30.intersecting;\n          if (_this30.intersecting != _this30.view.inView) _this30.onScrollChanged(document.createEvent(\"Event\"));\n        }\n      }, {});\n      this.intersection.observe(this.dom);\n      this.gapIntersection = new IntersectionObserver(function (entries) {\n        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) _this30.onScrollChanged(document.createEvent(\"Event\"));\n      }, {});\n    }\n\n    this.listenForScroll();\n    this.readSelectionRange();\n    this.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n\n  _createClass(DOMObserver, [{\n    key: \"onScroll\",\n    value: function onScroll(e) {\n      if (this.intersecting) this.flush(false);\n      this.onScrollChanged(e);\n    }\n  }, {\n    key: \"updateGaps\",\n    value: function updateGaps(gaps) {\n      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some(function (g, i) {\n        return g != gaps[i];\n      }))) {\n        this.gapIntersection.disconnect();\n\n        var _iterator32 = _createForOfIteratorHelper(gaps),\n            _step32;\n\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var gap = _step32.value;\n            this.gapIntersection.observe(gap);\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n\n        this.gaps = gaps;\n      }\n    }\n  }, {\n    key: \"onSelectionChange\",\n    value: function onSelectionChange(event) {\n      if (!this.readSelectionRange() || this.delayedAndroidKey) return;\n      var view = this.view,\n          sel = this.selectionRange;\n      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel)) return;\n      var context = sel.anchorNode && view.docView.nearest(sel.anchorNode);\n      if (context && context.ignoreEvent(event)) return; // Deletions on IE11 fire their events in the wrong order, giving\n      // us a selection change event before the DOM changes are\n      // reported.\n      // Chrome Android has a similar issue when backspacing out a\n      // selection (#645).\n\n      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n      sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();else this.flush(false);\n    }\n  }, {\n    key: \"readSelectionRange\",\n    value: function readSelectionRange() {\n      var root = this.view.root,\n          domSel = getSelection(root); // The Selection object is broken in shadow roots in Safari. See\n      // https://github.com/codemirror/codemirror.next/issues/414\n\n      var range = browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM && safariSelectionRangeHack(this.view) || domSel;\n      if (this.selectionRange.eq(range)) return false;\n      this.selectionRange.setRange(range);\n      return this.selectionChanged = true;\n    }\n  }, {\n    key: \"setSelectionRange\",\n    value: function setSelectionRange(anchor, head) {\n      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);\n      this.selectionChanged = false;\n    }\n  }, {\n    key: \"listenForScroll\",\n    value: function listenForScroll() {\n      this.parentCheck = -1;\n      var i = 0,\n          changed = null;\n\n      for (var dom = this.dom; dom;) {\n        if (dom.nodeType == 1) {\n          if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;else if (!changed) changed = this.scrollTargets.slice(0, i);\n          if (changed) changed.push(dom);\n          dom = dom.assignedSlot || dom.parentNode;\n        } else if (dom.nodeType == 11) {\n          // Shadow root\n          dom = dom.host;\n        } else {\n          break;\n        }\n      }\n\n      if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);\n\n      if (changed) {\n        var _iterator33 = _createForOfIteratorHelper(this.scrollTargets),\n            _step33;\n\n        try {\n          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n            var _dom2 = _step33.value;\n\n            _dom2.removeEventListener(\"scroll\", this.onScroll);\n          }\n        } catch (err) {\n          _iterator33.e(err);\n        } finally {\n          _iterator33.f();\n        }\n\n        var _iterator34 = _createForOfIteratorHelper(this.scrollTargets = changed),\n            _step34;\n\n        try {\n          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n            var _dom3 = _step34.value;\n\n            _dom3.addEventListener(\"scroll\", this.onScroll);\n          }\n        } catch (err) {\n          _iterator34.e(err);\n        } finally {\n          _iterator34.f();\n        }\n      }\n    }\n  }, {\n    key: \"ignore\",\n    value: function ignore(f) {\n      if (!this.active) return f();\n\n      try {\n        this.stop();\n        return f();\n      } finally {\n        this.start();\n        this.clear();\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.active) return;\n      this.observer.observe(this.dom, observeOptions);\n      if (useCharData) this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.active = true;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.active) return;\n      this.active = false;\n      this.observer.disconnect();\n      if (useCharData) this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    } // Throw away any pending changes\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.observer.takeRecords();\n      this.queue.length = 0;\n      this.selectionChanged = false;\n    } // Chrome Android, especially in combination with GBoard, not only\n    // doesn't reliably fire regular key events, but also often\n    // surrounds the effect of enter or backspace with a bunch of\n    // composition events that, when interrupted, cause text duplication\n    // or other kinds of corruption. This hack makes the editor back off\n    // from handling DOM changes for a moment when such a key is\n    // detected (via beforeinput or keydown), and then dispatches the\n    // key event, throwing away the DOM changes if it gets handled.\n\n  }, {\n    key: \"delayAndroidKey\",\n    value: function delayAndroidKey(key, keyCode) {\n      var _this31 = this;\n\n      if (!this.delayedAndroidKey) requestAnimationFrame(function () {\n        var key = _this31.delayedAndroidKey;\n        _this31.delayedAndroidKey = null;\n        var startState = _this31.view.state;\n        if (dispatchKey(_this31.view.contentDOM, key.key, key.keyCode)) _this31.processRecords();else _this31.flush();\n        if (_this31.view.state == startState) _this31.view.update([]);\n      }); // Since backspace beforeinput is sometimes signalled spuriously,\n      // Enter always takes precedence.\n\n      if (!this.delayedAndroidKey || key == \"Enter\") this.delayedAndroidKey = {\n        key: key,\n        keyCode: keyCode\n      };\n    }\n  }, {\n    key: \"flushSoon\",\n    value: function flushSoon() {\n      var _this32 = this;\n\n      if (this.delayedFlush < 0) this.delayedFlush = window.setTimeout(function () {\n        _this32.delayedFlush = -1;\n\n        _this32.flush();\n      }, 20);\n    }\n  }, {\n    key: \"forceFlush\",\n    value: function forceFlush() {\n      if (this.delayedFlush >= 0) {\n        window.clearTimeout(this.delayedFlush);\n        this.delayedFlush = -1;\n        this.flush();\n      }\n    }\n  }, {\n    key: \"processRecords\",\n    value: function processRecords() {\n      var records = this.queue;\n\n      var _iterator35 = _createForOfIteratorHelper(this.observer.takeRecords()),\n          _step35;\n\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var mut = _step35.value;\n          records.push(mut);\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n\n      if (records.length) this.queue = [];\n      var from = -1,\n          to = -1,\n          typeOver = false;\n\n      var _iterator36 = _createForOfIteratorHelper(records),\n          _step36;\n\n      try {\n        for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n          var record = _step36.value;\n          var range = this.readMutation(record);\n          if (!range) continue;\n          if (range.typeOver) typeOver = true;\n\n          if (from == -1) {\n            from = range.from;\n            to = range.to;\n          } else {\n            from = Math.min(range.from, from);\n            to = Math.max(range.to, to);\n          }\n        }\n      } catch (err) {\n        _iterator36.e(err);\n      } finally {\n        _iterator36.f();\n      }\n\n      return {\n        from: from,\n        to: to,\n        typeOver: typeOver\n      };\n    } // Apply pending changes, if any\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var readSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // Completely hold off flushing when pending keys are set—the code\n      // managing those will make sure processRecords is called and the\n      // view is resynchronized after\n      if (this.delayedFlush >= 0 || this.delayedAndroidKey) return;\n      if (readSelection) this.readSelectionRange();\n\n      var _this$processRecords = this.processRecords(),\n          from = _this$processRecords.from,\n          to = _this$processRecords.to,\n          typeOver = _this$processRecords.typeOver;\n\n      var newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);\n      if (from < 0 && !newSel) return;\n      this.selectionChanged = false;\n      var startState = this.view.state;\n      this.onChange(from, to, typeOver); // The view wasn't updated\n\n      if (this.view.state == startState) this.view.update([]);\n    }\n  }, {\n    key: \"readMutation\",\n    value: function readMutation(rec) {\n      var cView = this.view.docView.nearest(rec.target);\n      if (!cView || cView.ignoreMutation(rec)) return null;\n      cView.markDirty(rec.type == \"attributes\");\n      if (rec.type == \"attributes\") cView.dirty |= 4\n      /* Attrs */\n      ;\n\n      if (rec.type == \"childList\") {\n        var childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);\n        var childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);\n        return {\n          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,\n          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,\n          typeOver: false\n        };\n      } else if (rec.type == \"characterData\") {\n        return {\n          from: cView.posAtStart,\n          to: cView.posAtEnd,\n          typeOver: rec.target.nodeValue == rec.oldValue\n        };\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _a, _b, _c;\n\n      this.stop();\n      (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();\n      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();\n      (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();\n\n      var _iterator37 = _createForOfIteratorHelper(this.scrollTargets),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var dom = _step37.value;\n          dom.removeEventListener(\"scroll\", this.onScroll);\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      window.removeEventListener(\"scroll\", this.onScroll);\n      this.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n      clearTimeout(this.parentCheck);\n      clearTimeout(this.resizeTimeout);\n    }\n  }]);\n\n  return DOMObserver;\n}();\n\nfunction findChild(cView, dom, dir) {\n  while (dom) {\n    var curView = ContentView.get(dom);\n    if (curView && curView.parent == cView) return curView;\n    var parent = dom.parentNode;\n    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;\n  }\n\n  return null;\n} // Used to work around a Safari Selection/shadow DOM bug (#414)\n\n\nfunction safariSelectionRangeHack(view) {\n  var found = null; // Because Safari (at least in 2018-2021) doesn't provide regular\n  // access to the selection inside a shadowroot, we have to perform a\n  // ridiculous hack to get at it—using `execCommand` to trigger a\n  // `beforeInput` event so that we can read the target range from the\n  // event.\n\n  function read(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    found = event.getTargetRanges()[0];\n  }\n\n  view.contentDOM.addEventListener(\"beforeinput\", read, true);\n  document.execCommand(\"indent\");\n  view.contentDOM.removeEventListener(\"beforeinput\", read, true);\n  if (!found) return null;\n  var anchorNode = found.startContainer,\n      anchorOffset = found.startOffset;\n  var focusNode = found.endContainer,\n      focusOffset = found.endOffset;\n  var curAnchor = view.docView.domAtPos(view.state.selection.main.anchor); // Since such a range doesn't distinguish between anchor and head,\n  // use a heuristic that flips it around if its end matches the\n  // current anchor.\n\n  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) {\n    var _ref11 = [focusNode, focusOffset, anchorNode, anchorOffset];\n    anchorNode = _ref11[0];\n    anchorOffset = _ref11[1];\n    focusNode = _ref11[2];\n    focusOffset = _ref11[3];\n  }\n\n  return {\n    anchorNode: anchorNode,\n    anchorOffset: anchorOffset,\n    focusNode: focusNode,\n    focusOffset: focusOffset\n  };\n}\n\nfunction applyDOMChange(view, start, end, typeOver) {\n  var change, newSel;\n  var sel = view.state.selection.main;\n\n  if (start > -1) {\n    var bounds = view.docView.domBoundsAround(start, end, 0);\n    if (!bounds || view.state.readOnly) return;\n    var from = bounds.from,\n        to = bounds.to;\n    var selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);\n    var reader = new DOMReader(selPoints, view);\n    reader.readRange(bounds.startDOM, bounds.endDOM);\n    newSel = selectionFromPoints(selPoints, from);\n    var preferredPos = sel.from,\n        preferredSide = null; // Prefer anchoring to end when Backspace is pressed (or, on\n    // Android, when something was deleted)\n\n    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {\n      preferredPos = sel.to;\n      preferredSide = \"end\";\n    }\n\n    var diff = findDiff(view.state.sliceDoc(from, to), reader.text, preferredPos - from, preferredSide);\n    if (diff) change = {\n      from: from + diff.from,\n      to: from + diff.toA,\n      insert: view.state.toText(reader.text.slice(diff.from, diff.toB))\n    };\n  } else if (view.hasFocus || !view.state.facet(editable)) {\n    var domSel = view.observer.selectionRange;\n    var _view$docView = view.docView,\n        iHead = _view$docView.impreciseHead,\n        iAnchor = _view$docView.impreciseAnchor;\n    var head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);\n    var anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);\n    if (head != sel.head || anchor != sel.anchor) newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.single(anchor, head);\n  }\n\n  if (!change && !newSel) return; // Heuristic to notice typing over a selected character\n\n  if (!change && typeOver && !sel.empty && newSel && newSel.main.empty) change = {\n    from: sel.from,\n    to: sel.to,\n    insert: view.state.doc.slice(sel.from, sel.to)\n  }; // If the change is inside the selection and covers most of it,\n  // assume it is a selection replace (with identical characters at\n  // the start/end not included in the diff)\n  else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) change = {\n    from: sel.from,\n    to: sel.to,\n    insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))\n  };\n\n  if (change) {\n    var startState = view.state;\n    if (browser.ios && view.inputState.flushIOSKey(view)) return; // Android browsers don't fire reasonable key events for enter,\n    // backspace, or delete. So this detects changes that look like\n    // they're caused by those keys, and reinterprets them as key\n    // events. (Some of these keys are also handled by beforeinput\n    // events and the pendingAndroidKey mechanism, but that's not\n    // reliable in all situations.)\n\n    if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, \"Enter\", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Backspace\", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, \"Delete\", 46))) return;\n    var text = change.insert.toString();\n    if (view.state.facet(inputHandler).some(function (h) {\n      return h(view, change.from, change.to, text);\n    })) return;\n    if (view.inputState.composing >= 0) view.inputState.composing++;\n    var tr;\n\n    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {\n      var before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : \"\";\n      var after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : \"\";\n      tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));\n    } else {\n      var changes = startState.changes(change);\n      var mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : undefined; // Try to apply a composition change to all cursors\n\n      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {\n        var replaced = view.state.sliceDoc(change.from, change.to);\n        var compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);\n        var offset = sel.to - change.to,\n            size = sel.to - sel.from;\n        tr = startState.changeByRange(function (range) {\n          if (range.from == sel.from && range.to == sel.to) return {\n            changes: changes,\n            range: mainSel || range.map(changes)\n          };\n          var to = range.to - offset,\n              from = to - replaced.length;\n          if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || // Unfortunately, there's no way to make multiple\n          // changes in the same node work without aborting\n          // composition, so cursors in the composition range are\n          // ignored.\n          compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to) return {\n            range: range\n          };\n          var rangeChanges = startState.changes({\n            from: from,\n            to: to,\n            insert: change.insert\n          }),\n              selOff = range.to - sel.to;\n          return {\n            changes: rangeChanges,\n            range: !mainSel ? range.map(rangeChanges) : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))\n          };\n        });\n      } else {\n        tr = {\n          changes: changes,\n          selection: mainSel && startState.selection.replaceRange(mainSel)\n        };\n      }\n    }\n\n    var userEvent = \"input.type\";\n\n    if (view.composing) {\n      userEvent += \".compose\";\n\n      if (view.inputState.compositionFirstChange) {\n        userEvent += \".start\";\n        view.inputState.compositionFirstChange = false;\n      }\n    }\n\n    view.dispatch(tr, {\n      scrollIntoView: true,\n      userEvent: userEvent\n    });\n  } else if (newSel && !newSel.main.eq(sel)) {\n    var _scrollIntoView = false,\n        _userEvent = \"select\";\n\n    if (view.inputState.lastSelectionTime > Date.now() - 50) {\n      if (view.inputState.lastSelectionOrigin == \"select\") _scrollIntoView = true;\n      _userEvent = view.inputState.lastSelectionOrigin;\n    }\n\n    view.dispatch({\n      selection: newSel,\n      scrollIntoView: _scrollIntoView,\n      userEvent: _userEvent\n    });\n  }\n}\n\nfunction findDiff(a, b, preferredPos, preferredSide) {\n  var minLen = Math.min(a.length, b.length);\n  var from = 0;\n\n  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) {\n    from++;\n  }\n\n  if (from == minLen && a.length == b.length) return null;\n  var toA = a.length,\n      toB = b.length;\n\n  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {\n    toA--;\n    toB--;\n  }\n\n  if (preferredSide == \"end\") {\n    var adjust = Math.max(0, from - Math.min(toA, toB));\n    preferredPos -= toA + adjust - from;\n  }\n\n  if (toA < from && a.length < b.length) {\n    var move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;\n    from -= move;\n    toB = from + (toB - toA);\n    toA = from;\n  } else if (toB < from) {\n    var _move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;\n\n    from -= _move;\n    toA = from + (toA - toB);\n    toB = from;\n  }\n\n  return {\n    from: from,\n    toA: toA,\n    toB: toB\n  };\n}\n\nfunction selectionPoints(view) {\n  var result = [];\n  if (view.root.activeElement != view.contentDOM) return result;\n  var _view$observer$select = view.observer.selectionRange,\n      anchorNode = _view$observer$select.anchorNode,\n      anchorOffset = _view$observer$select.anchorOffset,\n      focusNode = _view$observer$select.focusNode,\n      focusOffset = _view$observer$select.focusOffset;\n\n  if (anchorNode) {\n    result.push(new DOMPoint(anchorNode, anchorOffset));\n    if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));\n  }\n\n  return result;\n}\n\nfunction selectionFromPoints(points, base) {\n  if (points.length == 0) return null;\n  var anchor = points[0].pos,\n      head = points.length == 2 ? points[1].pos : anchor;\n  return anchor > -1 && head > -1 ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.single(anchor + base, head + base) : null;\n} // The editor's update state machine looks something like this:\n//\n//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle\n//                                         ↑      ↓\n//                                         Updating (measure)\n//\n// The difference between 'Idle' and 'Idle (unchecked)' lies in\n// whether a layout check has been scheduled. A regular update through\n// the `update` method updates the DOM in a write-only fashion, and\n// relies on a check (scheduled with `requestAnimationFrame`) to make\n// sure everything is where it should be and the viewport covers the\n// visible code. That check continues to measure and then optionally\n// update until it reaches a coherent state.\n\n/**\nAn editor view represents the editor's user interface. It holds\nthe editable DOM surface, and possibly other elements such as the\nline number gutter. It handles events and dispatches state\ntransactions for editing actions.\n*/\n\n\nvar EditorView = /*#__PURE__*/function () {\n  /**\n  Construct a new view. You'll usually want to put `view.dom` into\n  your document after creating a view, so that the user can see\n  it.\n  */\n  function EditorView() {\n    var _this33 = this;\n\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EditorView);\n\n    this.plugins = [];\n    this.pluginMap = new Map();\n    this.editorAttrs = {};\n    this.contentAttrs = {};\n    this.bidiCache = [];\n    this.destroyed = false;\n    /**\n    @internal\n    */\n\n    this.updateState = 2\n    /* Updating */\n    ;\n    /**\n    @internal\n    */\n\n    this.measureScheduled = -1;\n    /**\n    @internal\n    */\n\n    this.measureRequests = [];\n    this.contentDOM = document.createElement(\"div\");\n    this.scrollDOM = document.createElement(\"div\");\n    this.scrollDOM.tabIndex = -1;\n    this.scrollDOM.className = \"cm-scroller\";\n    this.scrollDOM.appendChild(this.contentDOM);\n    this.announceDOM = document.createElement(\"div\");\n    this.announceDOM.style.cssText = \"position: absolute; top: -10000px\";\n    this.announceDOM.setAttribute(\"aria-live\", \"polite\");\n    this.dom = document.createElement(\"div\");\n    this.dom.appendChild(this.announceDOM);\n    this.dom.appendChild(this.scrollDOM);\n\n    this._dispatch = config.dispatch || function (tr) {\n      return _this33.update([tr]);\n    };\n\n    this.dispatch = this.dispatch.bind(this);\n    this.root = config.root || getRoot(config.parent) || document;\n    this.viewState = new ViewState(config.state || _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.create());\n    this.plugins = this.state.facet(viewPlugin).map(function (spec) {\n      return new PluginInstance(spec);\n    });\n\n    var _iterator38 = _createForOfIteratorHelper(this.plugins),\n        _step38;\n\n    try {\n      for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n        var _plugin3 = _step38.value;\n\n        _plugin3.update(this);\n      }\n    } catch (err) {\n      _iterator38.e(err);\n    } finally {\n      _iterator38.f();\n    }\n\n    this.observer = new DOMObserver(this, function (from, to, typeOver) {\n      applyDOMChange(_this33, from, to, typeOver);\n    }, function (event) {\n      _this33.inputState.runScrollHandlers(_this33, event);\n\n      if (_this33.observer.intersecting) _this33.measure();\n    });\n    this.inputState = new InputState(this);\n    this.docView = new DocView(this);\n    this.mountStyles();\n    this.updateAttrs();\n    this.updateState = 0\n    /* Idle */\n    ;\n    ensureGlobalHandler();\n    this.requestMeasure();\n    if (config.parent) config.parent.appendChild(this.dom);\n  }\n  /**\n  The current editor state.\n  */\n\n\n  _createClass(EditorView, [{\n    key: \"state\",\n    get: function get() {\n      return this.viewState.state;\n    }\n    /**\n    To be able to display large documents without consuming too much\n    memory or overloading the browser, CodeMirror only draws the\n    code that is visible (plus a margin around it) to the DOM. This\n    property tells you the extent of the current drawn viewport, in\n    document positions.\n    */\n\n  }, {\n    key: \"viewport\",\n    get: function get() {\n      return this.viewState.viewport;\n    }\n    /**\n    When there are, for example, large collapsed ranges in the\n    viewport, its size can be a lot bigger than the actual visible\n    content. Thus, if you are doing something like styling the\n    content in the viewport, it is preferable to only do so for\n    these ranges, which are the subset of the viewport that is\n    actually drawn.\n    */\n\n  }, {\n    key: \"visibleRanges\",\n    get: function get() {\n      return this.viewState.visibleRanges;\n    }\n    /**\n    Returns false when the editor is entirely scrolled out of view\n    or otherwise hidden.\n    */\n\n  }, {\n    key: \"inView\",\n    get: function get() {\n      return this.viewState.inView;\n    }\n    /**\n    Indicates whether the user is currently composing text via\n    [IME](https://en.wikipedia.org/wiki/Input_method).\n    */\n\n  }, {\n    key: \"composing\",\n    get: function get() {\n      return this.inputState.composing > 0;\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch() {\n      var _this$state;\n\n      this._dispatch(arguments.length == 1 && (arguments.length <= 0 ? undefined : arguments[0]) instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Transaction ? arguments.length <= 0 ? undefined : arguments[0] : (_this$state = this.state).update.apply(_this$state, arguments));\n    }\n    /**\n    Update the view for the given array of transactions. This will\n    update the visible document and selection to match the state\n    produced by the transactions, and notify view plugins of the\n    change. You should usually call\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n    as a primitive.\n    */\n\n  }, {\n    key: \"update\",\n    value: function update(transactions) {\n      if (this.updateState != 0\n      /* Idle */\n      ) throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n      var redrawn = false,\n          update;\n      var state = this.state;\n\n      var _iterator39 = _createForOfIteratorHelper(transactions),\n          _step39;\n\n      try {\n        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n          var _tr = _step39.value;\n          if (_tr.startState != state) throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n          state = _tr.state;\n        }\n      } catch (err) {\n        _iterator39.e(err);\n      } finally {\n        _iterator39.f();\n      }\n\n      if (this.destroyed) {\n        this.viewState.state = state;\n        return;\n      } // When the phrases change, redraw the editor\n\n\n      if (state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.phrases) != this.state.facet(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorState.phrases)) return this.setState(state);\n      update = new ViewUpdate(this, state, transactions);\n      var scrollTarget = this.viewState.scrollTarget;\n\n      try {\n        this.updateState = 2\n        /* Updating */\n        ;\n\n        var _iterator40 = _createForOfIteratorHelper(transactions),\n            _step40;\n\n        try {\n          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n            var tr = _step40.value;\n            if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);\n\n            if (tr.scrollIntoView) {\n              var main = tr.state.selection.main;\n              scrollTarget = new ScrollTarget(main.empty ? main : _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));\n            }\n\n            var _iterator41 = _createForOfIteratorHelper(tr.effects),\n                _step41;\n\n            try {\n              for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n                var e = _step41.value;\n                if (e.is(scrollTo)) scrollTarget = new ScrollTarget(e.value);else if (e.is(centerOn)) scrollTarget = new ScrollTarget(e.value, \"center\");else if (e.is(_scrollIntoView2)) scrollTarget = e.value;\n              }\n            } catch (err) {\n              _iterator41.e(err);\n            } finally {\n              _iterator41.f();\n            }\n          }\n        } catch (err) {\n          _iterator40.e(err);\n        } finally {\n          _iterator40.f();\n        }\n\n        this.viewState.update(update, scrollTarget);\n        this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);\n\n        if (!update.empty) {\n          this.updatePlugins(update);\n          this.inputState.update(update);\n        }\n\n        redrawn = this.docView.update(update);\n        if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();\n        this.updateAttrs();\n        this.showAnnouncements(transactions);\n        this.docView.updateSelection(redrawn, transactions.some(function (tr) {\n          return tr.isUserEvent(\"select.pointer\");\n        }));\n      } finally {\n        this.updateState = 0\n        /* Idle */\n        ;\n      }\n\n      if (redrawn || scrollTarget || this.viewState.mustEnforceCursorAssoc) this.requestMeasure();\n\n      if (!update.empty) {\n        var _iterator42 = _createForOfIteratorHelper(this.state.facet(updateListener)),\n            _step42;\n\n        try {\n          for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n            var listener = _step42.value;\n            listener(update);\n          }\n        } catch (err) {\n          _iterator42.e(err);\n        } finally {\n          _iterator42.f();\n        }\n      }\n    }\n    /**\n    Reset the view to the given state. (This will cause the entire\n    document to be redrawn and all view plugins to be reinitialized,\n    so you should probably only use it when the new state isn't\n    derived from the old state. Otherwise, use\n    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n    */\n\n  }, {\n    key: \"setState\",\n    value: function setState(newState) {\n      if (this.updateState != 0\n      /* Idle */\n      ) throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n\n      if (this.destroyed) {\n        this.viewState.state = newState;\n        return;\n      }\n\n      this.updateState = 2\n      /* Updating */\n      ;\n      var hadFocus = this.hasFocus;\n\n      try {\n        var _iterator43 = _createForOfIteratorHelper(this.plugins),\n            _step43;\n\n        try {\n          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n            var _plugin4 = _step43.value;\n\n            _plugin4.destroy(this);\n          }\n        } catch (err) {\n          _iterator43.e(err);\n        } finally {\n          _iterator43.f();\n        }\n\n        this.viewState = new ViewState(newState);\n        this.plugins = newState.facet(viewPlugin).map(function (spec) {\n          return new PluginInstance(spec);\n        });\n        this.pluginMap.clear();\n\n        var _iterator44 = _createForOfIteratorHelper(this.plugins),\n            _step44;\n\n        try {\n          for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n            var _plugin5 = _step44.value;\n\n            _plugin5.update(this);\n          }\n        } catch (err) {\n          _iterator44.e(err);\n        } finally {\n          _iterator44.f();\n        }\n\n        this.docView = new DocView(this);\n        this.inputState.ensureHandlers(this);\n        this.mountStyles();\n        this.updateAttrs();\n        this.bidiCache = [];\n      } finally {\n        this.updateState = 0\n        /* Idle */\n        ;\n      }\n\n      if (hadFocus) this.focus();\n      this.requestMeasure();\n    }\n  }, {\n    key: \"updatePlugins\",\n    value: function updatePlugins(update) {\n      var prevSpecs = update.startState.facet(viewPlugin),\n          specs = update.state.facet(viewPlugin);\n\n      if (prevSpecs != specs) {\n        var newPlugins = [];\n\n        var _iterator45 = _createForOfIteratorHelper(specs),\n            _step45;\n\n        try {\n          for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n            var spec = _step45.value;\n            var found = prevSpecs.indexOf(spec);\n\n            if (found < 0) {\n              newPlugins.push(new PluginInstance(spec));\n            } else {\n              var _plugin6 = this.plugins[found];\n              _plugin6.mustUpdate = update;\n              newPlugins.push(_plugin6);\n            }\n          }\n        } catch (err) {\n          _iterator45.e(err);\n        } finally {\n          _iterator45.f();\n        }\n\n        var _iterator46 = _createForOfIteratorHelper(this.plugins),\n            _step46;\n\n        try {\n          for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n            var _plugin7 = _step46.value;\n            if (_plugin7.mustUpdate != update) _plugin7.destroy(this);\n          }\n        } catch (err) {\n          _iterator46.e(err);\n        } finally {\n          _iterator46.f();\n        }\n\n        this.plugins = newPlugins;\n        this.pluginMap.clear();\n        this.inputState.ensureHandlers(this);\n      } else {\n        var _iterator47 = _createForOfIteratorHelper(this.plugins),\n            _step47;\n\n        try {\n          for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n            var _p = _step47.value;\n            _p.mustUpdate = update;\n          }\n        } catch (err) {\n          _iterator47.e(err);\n        } finally {\n          _iterator47.f();\n        }\n      }\n\n      for (var i = 0; i < this.plugins.length; i++) {\n        this.plugins[i].update(this);\n      }\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"measure\",\n    value: function measure() {\n      var _this34 = this;\n\n      var flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (this.destroyed) return;\n      if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);\n      this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame\n\n      if (flush) this.observer.flush();\n      var updated = null;\n\n      try {\n        for (var i = 0;; i++) {\n          this.updateState = 1\n          /* Measuring */\n          ;\n          var oldViewport = this.viewport;\n          var changed = this.viewState.measure(this);\n          if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;\n\n          if (i > 5) {\n            console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n            break;\n          }\n\n          var measuring = []; // Only run measure requests in this cycle when the viewport didn't change\n\n          if (!(changed & 4\n          /* Viewport */\n          )) {\n            var _ref12 = [measuring, this.measureRequests];\n            this.measureRequests = _ref12[0];\n            measuring = _ref12[1];\n          }\n\n          var measured = measuring.map(function (m) {\n            try {\n              return m.read(_this34);\n            } catch (e) {\n              logException(_this34.state, e);\n              return BadMeasure;\n            }\n          });\n          var update = new ViewUpdate(this, this.state),\n              redrawn = false,\n              scrolled = false;\n          update.flags |= changed;\n          if (!updated) updated = update;else updated.flags |= changed;\n          this.updateState = 2\n          /* Updating */\n          ;\n\n          if (!update.empty) {\n            this.updatePlugins(update);\n            this.inputState.update(update);\n            this.updateAttrs();\n            redrawn = this.docView.update(update);\n          }\n\n          for (var _i10 = 0; _i10 < measuring.length; _i10++) {\n            if (measured[_i10] != BadMeasure) {\n              try {\n                var m = measuring[_i10];\n                if (m.write) m.write(measured[_i10], this);\n              } catch (e) {\n                logException(this.state, e);\n              }\n            }\n          }\n\n          if (this.viewState.scrollTarget) {\n            this.docView.scrollIntoView(this.viewState.scrollTarget);\n            this.viewState.scrollTarget = null;\n            scrolled = true;\n          }\n\n          if (redrawn) this.docView.updateSelection(true);\n          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0) break;\n        }\n      } finally {\n        this.updateState = 0\n        /* Idle */\n        ;\n        this.measureScheduled = -1;\n      }\n\n      if (updated && !updated.empty) {\n        var _iterator48 = _createForOfIteratorHelper(this.state.facet(updateListener)),\n            _step48;\n\n        try {\n          for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n            var listener = _step48.value;\n            listener(updated);\n          }\n        } catch (err) {\n          _iterator48.e(err);\n        } finally {\n          _iterator48.f();\n        }\n      }\n    }\n    /**\n    Get the CSS classes for the currently active editor themes.\n    */\n\n  }, {\n    key: \"themeClasses\",\n    get: function get() {\n      return baseThemeID + \" \" + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + \" \" + this.state.facet(_theme);\n    }\n  }, {\n    key: \"updateAttrs\",\n    value: function updateAttrs() {\n      var _this35 = this;\n\n      var editorAttrs = attrsFromFacet(this, editorAttributes, {\n        \"class\": \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n      });\n      var contentAttrs = {\n        spellcheck: \"false\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        translate: \"no\",\n        contenteditable: !this.state.facet(editable) ? \"false\" : \"true\",\n        \"class\": \"cm-content\",\n        style: \"\".concat(browser.tabSize, \": \").concat(this.state.tabSize),\n        role: \"textbox\",\n        \"aria-multiline\": \"true\"\n      };\n      if (this.state.readOnly) contentAttrs[\"aria-readonly\"] = \"true\";\n      attrsFromFacet(this, contentAttributes, contentAttrs);\n      this.observer.ignore(function () {\n        _updateAttrs(_this35.contentDOM, _this35.contentAttrs, contentAttrs);\n\n        _updateAttrs(_this35.dom, _this35.editorAttrs, editorAttrs);\n      });\n      this.editorAttrs = editorAttrs;\n      this.contentAttrs = contentAttrs;\n    }\n  }, {\n    key: \"showAnnouncements\",\n    value: function showAnnouncements(trs) {\n      var first = true;\n\n      var _iterator49 = _createForOfIteratorHelper(trs),\n          _step49;\n\n      try {\n        for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n          var tr = _step49.value;\n\n          var _iterator50 = _createForOfIteratorHelper(tr.effects),\n              _step50;\n\n          try {\n            for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {\n              var effect = _step50.value;\n\n              if (effect.is(EditorView.announce)) {\n                if (first) this.announceDOM.textContent = \"\";\n                first = false;\n                var div = this.announceDOM.appendChild(document.createElement(\"div\"));\n                div.textContent = effect.value;\n              }\n            }\n          } catch (err) {\n            _iterator50.e(err);\n          } finally {\n            _iterator50.f();\n          }\n        }\n      } catch (err) {\n        _iterator49.e(err);\n      } finally {\n        _iterator49.f();\n      }\n    }\n  }, {\n    key: \"mountStyles\",\n    value: function mountStyles() {\n      this.styleModules = this.state.facet(styleModule);\n      style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.mount(this.root, this.styleModules.concat(baseTheme).reverse());\n    }\n  }, {\n    key: \"readMeasured\",\n    value: function readMeasured() {\n      if (this.updateState == 2\n      /* Updating */\n      ) throw new Error(\"Reading the editor layout isn't allowed during an update\");\n      if (this.updateState == 0\n      /* Idle */\n      && this.measureScheduled > -1) this.measure(false);\n    }\n    /**\n    Schedule a layout measurement, optionally providing callbacks to\n    do custom DOM measuring followed by a DOM write phase. Using\n    this is preferable reading DOM layout directly from, for\n    example, an event handler, because it'll make sure measuring and\n    drawing done by other components is synchronized, avoiding\n    unnecessary DOM layout computations.\n    */\n\n  }, {\n    key: \"requestMeasure\",\n    value: function requestMeasure(request) {\n      var _this36 = this;\n\n      if (this.measureScheduled < 0) this.measureScheduled = requestAnimationFrame(function () {\n        return _this36.measure();\n      });\n\n      if (request) {\n        if (request.key != null) for (var i = 0; i < this.measureRequests.length; i++) {\n          if (this.measureRequests[i].key === request.key) {\n            this.measureRequests[i] = request;\n            return;\n          }\n        }\n        this.measureRequests.push(request);\n      }\n    }\n    /**\n    Collect all values provided by the active plugins for a given\n    field.\n    */\n\n  }, {\n    key: \"pluginField\",\n    value: function pluginField(field) {\n      var result = [];\n\n      var _iterator51 = _createForOfIteratorHelper(this.plugins),\n          _step51;\n\n      try {\n        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {\n          var _plugin8 = _step51.value;\n\n          _plugin8.update(this).takeField(field, result);\n        }\n      } catch (err) {\n        _iterator51.e(err);\n      } finally {\n        _iterator51.f();\n      }\n\n      return result;\n    }\n    /**\n    Get the value of a specific plugin, if present. Note that\n    plugins that crash can be dropped from a view, so even when you\n    know you registered a given plugin, it is recommended to check\n    the return value of this method.\n    */\n\n  }, {\n    key: \"plugin\",\n    value: function plugin(_plugin2) {\n      var known = this.pluginMap.get(_plugin2);\n      if (known === undefined || known && known.spec != _plugin2) this.pluginMap.set(_plugin2, known = this.plugins.find(function (p) {\n        return p.spec == _plugin2;\n      }) || null);\n      return known && known.update(this).value;\n    }\n    /**\n    The top position of the document, in screen coordinates. This\n    may be negative when the editor is scrolled down. Points\n    directly to the top of the first line, not above the padding.\n    */\n\n  }, {\n    key: \"documentTop\",\n    get: function get() {\n      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n    }\n    /**\n    Reports the padding above and below the document.\n    */\n\n  }, {\n    key: \"documentPadding\",\n    get: function get() {\n      return {\n        top: this.viewState.paddingTop,\n        bottom: this.viewState.paddingBottom\n      };\n    }\n    /**\n    Find the line or block widget at the given vertical position.\n    \n    By default, this position is interpreted as a screen position,\n    meaning `docTop` is set to the DOM top position of the editor\n    content (forcing a layout). You can pass a different `docTop`\n    value—for example 0 to interpret `height` as a document-relative\n    position, or a precomputed document top\n    (`view.contentDOM.getBoundingClientRect().top`) to limit layout\n    queries.\n    \n    *Deprecated: use `elementAtHeight` instead.*\n    */\n\n  }, {\n    key: \"blockAtHeight\",\n    value: function blockAtHeight(height, docTop) {\n      var top = ensureTop(docTop, this);\n      return this.elementAtHeight(height - top).moveY(top);\n    }\n    /**\n    Find the text line or block widget at the given vertical\n    position (which is interpreted as relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)\n    */\n\n  }, {\n    key: \"elementAtHeight\",\n    value: function elementAtHeight(height) {\n      this.readMeasured();\n      return this.viewState.elementAtHeight(height);\n    }\n    /**\n    Find information for the visual line (see\n    [`visualLineAt`](https://codemirror.net/6/docs/ref/#view.EditorView.visualLineAt)) at the given\n    vertical position. The resulting block info might hold another\n    array of block info structs in its `type` field if this line\n    consists of more than one block.\n    \n    Defaults to treating `height` as a screen position. See\n    [`blockAtHeight`](https://codemirror.net/6/docs/ref/#view.EditorView.blockAtHeight) for the\n    interpretation of the `docTop` parameter.\n    \n    *Deprecated: use `lineBlockAtHeight` instead.*\n    */\n\n  }, {\n    key: \"visualLineAtHeight\",\n    value: function visualLineAtHeight(height, docTop) {\n      var top = ensureTop(docTop, this);\n      return this.lineBlockAtHeight(height - top).moveY(top);\n    }\n    /**\n    Find the line block (see\n    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n    height.\n    */\n\n  }, {\n    key: \"lineBlockAtHeight\",\n    value: function lineBlockAtHeight(height) {\n      this.readMeasured();\n      return this.viewState.lineBlockAtHeight(height);\n    }\n    /**\n    Iterate over the height information of the visual lines in the\n    viewport. The heights of lines are reported relative to the\n    given document top, which defaults to the screen position of the\n    document (forcing a layout).\n    \n    *Deprecated: use `viewportLineBlocks` instead.*\n    */\n\n  }, {\n    key: \"viewportLines\",\n    value: function viewportLines(f, docTop) {\n      var top = ensureTop(docTop, this);\n\n      var _iterator52 = _createForOfIteratorHelper(this.viewportLineBlocks),\n          _step52;\n\n      try {\n        for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {\n          var line = _step52.value;\n          f(line.moveY(top));\n        }\n      } catch (err) {\n        _iterator52.e(err);\n      } finally {\n        _iterator52.f();\n      }\n    }\n    /**\n    Get the extent and vertical position of all [line\n    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n    are relative to the [top of the\n    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n    */\n\n  }, {\n    key: \"viewportLineBlocks\",\n    get: function get() {\n      return this.viewState.viewportLines;\n    }\n    /**\n    Find the extent and height of the visual line (a range delimited\n    on both sides by either non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^range)\n    line breaks, or the start/end of the document) at the given position.\n    \n    Vertical positions are computed relative to the `docTop`\n    argument, which defaults to 0 for this method. You can pass\n    `view.contentDOM.getBoundingClientRect().top` here to get screen\n    coordinates.\n    \n    *Deprecated: use `lineBlockAt` instead.*\n    */\n\n  }, {\n    key: \"visualLineAt\",\n    value: function visualLineAt(pos) {\n      var docTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.lineBlockAt(pos).moveY(docTop + this.viewState.paddingTop);\n    }\n    /**\n    Find the line block around the given document position. A line\n    block is a range delimited on both sides by either a\n    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^range) line breaks, or the\n    start/end of the document. It will usually just hold a line of\n    text, but may be broken into multiple textblocks by block\n    widgets.\n    */\n\n  }, {\n    key: \"lineBlockAt\",\n    value: function lineBlockAt(pos) {\n      return this.viewState.lineBlockAt(pos);\n    }\n    /**\n    The editor's total content height.\n    */\n\n  }, {\n    key: \"contentHeight\",\n    get: function get() {\n      return this.viewState.contentHeight;\n    }\n    /**\n    Move a cursor position by [grapheme\n    cluster](https://codemirror.net/6/docs/ref/#text.findClusterBreak). `forward` determines whether\n    the motion is away from the line start, or towards it. Motion in\n    bidirectional text is in visual order, in the editor's [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). When the start\n    position was the last one on the line, the returned position\n    will be across the line break. If there is no further line, the\n    original position is returned.\n    \n    By default, this method moves over a single cluster. The\n    optional `by` argument can be used to move across more. It will\n    be called with the first cluster as argument, and should return\n    a predicate that determines, for each subsequent cluster,\n    whether it should also be moved over.\n    */\n\n  }, {\n    key: \"moveByChar\",\n    value: function moveByChar(start, forward, by) {\n      return skipAtoms(this, start, _moveByChar(this, start, forward, by));\n    }\n    /**\n    Move a cursor position across the next group of either\n    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n    non-whitespace characters.\n    */\n\n  }, {\n    key: \"moveByGroup\",\n    value: function moveByGroup(start, forward) {\n      var _this37 = this;\n\n      return skipAtoms(this, start, _moveByChar(this, start, forward, function (initial) {\n        return byGroup(_this37, start.head, initial);\n      }));\n    }\n    /**\n    Move to the next line boundary in the given direction. If\n    `includeWrap` is true, line wrapping is on, and there is a\n    further wrap point on the current line, the wrap point will be\n    returned. Otherwise this function will return the start or end\n    of the line.\n    */\n\n  }, {\n    key: \"moveToLineBoundary\",\n    value: function moveToLineBoundary(start, forward) {\n      var includeWrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return _moveToLineBoundary(this, start, forward, includeWrap);\n    }\n    /**\n    Move a cursor position vertically. When `distance` isn't given,\n    it defaults to moving to the next line (including wrapped\n    lines). Otherwise, `distance` should provide a positive distance\n    in pixels.\n    \n    When `start` has a\n    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n    motion will use that as a target horizontal position. Otherwise,\n    the cursor's own horizontal position is used. The returned\n    cursor will have its goal column set to whichever column was\n    used.\n    */\n\n  }, {\n    key: \"moveVertically\",\n    value: function moveVertically(start, forward, distance) {\n      return skipAtoms(this, start, _moveVertically(this, start, forward, distance));\n    } // FIXME remove on next major version\n\n  }, {\n    key: \"scrollPosIntoView\",\n    value: function scrollPosIntoView(pos) {\n      this.dispatch({\n        effects: scrollTo.of(_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos))\n      });\n    }\n    /**\n    Find the DOM parent node and offset (child offset if `node` is\n    an element, character offset when it is a text node) at the\n    given document position.\n    \n    Note that for positions that aren't currently in\n    `visibleRanges`, the resulting DOM position isn't necessarily\n    meaningful (it may just point before or after a placeholder\n    element).\n    */\n\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      return this.docView.domAtPos(pos);\n    }\n    /**\n    Find the document position at the given DOM node. Can be useful\n    for associating positions with DOM events. Will raise an error\n    when `node` isn't part of the editor content.\n    */\n\n  }, {\n    key: \"posAtDOM\",\n    value: function posAtDOM(node) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.docView.posFromDOM(node, offset);\n    }\n  }, {\n    key: \"posAtCoords\",\n    value: function posAtCoords(coords) {\n      var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.readMeasured();\n      return _posAtCoords(this, coords, precise);\n    }\n    /**\n    Get the screen coordinates at the given document position.\n    `side` determines whether the coordinates are based on the\n    element before (-1) or after (1) the position (if no element is\n    available on the given side, the method will transparently use\n    another strategy to get reasonable coordinates).\n    */\n\n  }, {\n    key: \"coordsAtPos\",\n    value: function coordsAtPos(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.readMeasured();\n      var rect = this.docView.coordsAt(pos, side);\n      if (!rect || rect.left == rect.right) return rect;\n      var line = this.state.doc.lineAt(pos),\n          order = this.bidiSpans(line);\n      var span = order[BidiSpan.find(order, pos - line.from, -1, side)];\n      return flattenRect(rect, span.dir == Direction.LTR == side > 0);\n    }\n    /**\n    The default width of a character in the editor. May not\n    accurately reflect the width of all characters (given variable\n    width fonts or styling of invididual ranges).\n    */\n\n  }, {\n    key: \"defaultCharacterWidth\",\n    get: function get() {\n      return this.viewState.heightOracle.charWidth;\n    }\n    /**\n    The default height of a line in the editor. May not be accurate\n    for all lines.\n    */\n\n  }, {\n    key: \"defaultLineHeight\",\n    get: function get() {\n      return this.viewState.heightOracle.lineHeight;\n    }\n    /**\n    The text direction\n    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n    CSS property) of the editor.\n    */\n\n  }, {\n    key: \"textDirection\",\n    get: function get() {\n      return this.viewState.heightOracle.direction;\n    }\n    /**\n    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n    (as determined by the\n    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n    CSS property of its content element).\n    */\n\n  }, {\n    key: \"lineWrapping\",\n    get: function get() {\n      return this.viewState.heightOracle.lineWrapping;\n    }\n    /**\n    Returns the bidirectional text structure of the given line\n    (which should be in the current document) as an array of span\n    objects. The order of these spans matches the [text\n    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is\n    left-to-right, the leftmost spans come first, otherwise the\n    rightmost spans come first.\n    */\n\n  }, {\n    key: \"bidiSpans\",\n    value: function bidiSpans(line) {\n      if (line.length > MaxBidiLine) return trivialOrder(line.length);\n      var dir = this.textDirection;\n\n      var _iterator53 = _createForOfIteratorHelper(this.bidiCache),\n          _step53;\n\n      try {\n        for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {\n          var entry = _step53.value;\n          if (entry.from == line.from && entry.dir == dir) return entry.order;\n        }\n      } catch (err) {\n        _iterator53.e(err);\n      } finally {\n        _iterator53.f();\n      }\n\n      var order = computeOrder(line.text, this.textDirection);\n      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));\n      return order;\n    }\n    /**\n    Check whether the editor has focus.\n    */\n\n  }, {\n    key: \"hasFocus\",\n    get: function get() {\n      var _a; // Safari return false for hasFocus when the context menu is open\n      // or closing, which leads us to ignore selection changes from the\n      // context menu because it looks like the editor isn't focused.\n      // This kludges around that.\n\n\n      return (document.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n    }\n    /**\n    Put focus on the editor.\n    */\n\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      var _this38 = this;\n\n      this.observer.ignore(function () {\n        focusPreventScroll(_this38.contentDOM);\n\n        _this38.docView.updateSelection();\n      });\n    }\n    /**\n    Clean up this editor view, removing its element from the\n    document, unregistering event handlers, and notifying\n    plugins. The view instance can no longer be used after\n    calling this.\n    */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator54 = _createForOfIteratorHelper(this.plugins),\n          _step54;\n\n      try {\n        for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {\n          var _plugin9 = _step54.value;\n\n          _plugin9.destroy(this);\n        }\n      } catch (err) {\n        _iterator54.e(err);\n      } finally {\n        _iterator54.f();\n      }\n\n      this.plugins = [];\n      this.inputState.destroy();\n      this.dom.remove();\n      this.observer.destroy();\n      if (this.measureScheduled > -1) cancelAnimationFrame(this.measureScheduled);\n      this.destroyed = true;\n    }\n    /**\n    Returns an effect that can be\n    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n    cause it to scroll the given position or range into view.\n    */\n\n  }], [{\n    key: \"scrollIntoView\",\n    value: function scrollIntoView(pos) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _scrollIntoView2.of(new ScrollTarget(typeof pos == \"number\" ? _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));\n    }\n    /**\n    Facet that can be used to add DOM event handlers. The value\n    should be an object mapping event names to handler functions. The\n    first such function to return true will be assumed to have handled\n    that event, and no other handlers or built-in behavior will be\n    activated for it.\n    These are registered on the [content\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except for `scroll`\n    handlers, which will be called any time the editor's [scroll\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of its parent nodes\n    is scrolled.\n    */\n\n  }, {\n    key: \"domEventHandlers\",\n    value: function domEventHandlers(handlers) {\n      return ViewPlugin.define(function () {\n        return {};\n      }, {\n        eventHandlers: handlers\n      });\n    }\n    /**\n    Create a theme extension. The first argument can be a\n    [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n    style spec providing the styles for the theme. These will be\n    prefixed with a generated class for the style.\n    \n    Because the selectors will be prefixed with a scope class, rule\n    that directly match the editor's [wrapper\n    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be\n    added—need to be explicitly differentiated by adding an `&` to\n    the selector for that element—for example\n    `&.cm-focused`.\n    \n    When `dark` is set to true, the theme will be marked as dark,\n    which will cause the `&dark` rules from [base\n    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n    `&light` when a light theme is active).\n    */\n\n  }, {\n    key: \"theme\",\n    value: function theme(spec, options) {\n      var prefix = style_mod__WEBPACK_IMPORTED_MODULE_0__.StyleModule.newName();\n      var result = [_theme.of(prefix), styleModule.of(buildTheme(\".\".concat(prefix), spec))];\n      if (options && options.dark) result.push(darkTheme.of(true));\n      return result;\n    }\n    /**\n    Create an extension that adds styles to the base theme. Like\n    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n    place of the editor wrapper element when directly targeting\n    that. You can also use `&dark` or `&light` instead to only\n    target editors with a dark or light theme.\n    */\n\n  }, {\n    key: \"baseTheme\",\n    value: function baseTheme(spec) {\n      return _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Prec.lowest(styleModule.of(buildTheme(\".\" + baseThemeID, spec, lightDarkIDs)));\n    }\n  }]);\n\n  return EditorView;\n}();\n/**\nEffect that can be [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a\ntransaction to make it scroll the given range into view.\n\n*Deprecated*. Use [`scrollIntoView`](https://codemirror.net/6/docs/ref/#view.EditorView^scrollIntoView) instead.\n*/\n\n\nEditorView.scrollTo = scrollTo;\n/**\nEffect that makes the editor scroll the given range to the\ncenter of the visible view.\n\n*Deprecated*. Use [`scrollIntoView`](https://codemirror.net/6/docs/ref/#view.EditorView^scrollIntoView) instead.\n*/\n\nEditorView.centerOn = centerOn;\n/**\nFacet to add a [style\nmodule](https://github.com/marijnh/style-mod#documentation) to\nan editor view. The view will ensure that the module is\nmounted in its [document\nroot](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).\n*/\n\nEditorView.styleModule = styleModule;\n/**\nAn input handler can override the way changes to the editable\nDOM content are handled. Handlers are passed the document\npositions between which the change was found, and the new\ncontent. When one returns true, no further input handlers are\ncalled and the default behavior is prevented.\n*/\n\nEditorView.inputHandler = inputHandler;\n/**\nAllows you to provide a function that should be called when the\nlibrary catches an exception from an extension (mostly from view\nplugins, but may be used by other extensions to route exceptions\nfrom user-code-provided callbacks). This is mostly useful for\ndebugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).\n*/\n\nEditorView.exceptionSink = exceptionSink;\n/**\nA facet that can be used to register a function to be called\nevery time the view updates.\n*/\n\nEditorView.updateListener = updateListener;\n/**\nFacet that controls whether the editor content DOM is editable.\nWhen its highest-precedence value is `false`, the element will\nnot longer have its `contenteditable` attribute set. (Note that\nthis doesn't affect API calls that change the editor content,\neven when those are bound to keys or buttons. See the\n[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)\n*/\n\nEditorView.editable = editable;\n/**\nAllows you to influence the way mouse selection happens. The\nfunctions in this facet will be called for a `mousedown` event\non the editor, and can return an object that overrides the way a\nselection is computed from that mouse click or drag.\n*/\n\nEditorView.mouseSelectionStyle = mouseSelectionStyle;\n/**\nFacet used to configure whether a given selection drag event\nshould move or copy the selection. The given predicate will be\ncalled with the `mousedown` event, and can return `true` when\nthe drag should move the content.\n*/\n\nEditorView.dragMovesSelection = dragMovesSelection$1;\n/**\nFacet used to configure whether a given selecting click adds\na new range to the existing selection or replaces it entirely.\n*/\n\nEditorView.clickAddsSelectionRange = clickAddsSelectionRange;\n/**\nA facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)\nare shown in the view. See also [view\nplugins](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), which have a separate\nmechanism for providing decorations.\n*/\n\nEditorView.decorations = decorations;\n/**\nThis facet records whether a dark theme is active. The extension\nreturned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically\nincludes an instance of this when the `dark` option is set to\ntrue.\n*/\n\nEditorView.darkTheme = darkTheme;\n/**\nFacet that provides additional DOM attributes for the editor's\neditable DOM element.\n*/\n\nEditorView.contentAttributes = contentAttributes;\n/**\nFacet that provides DOM attributes for the editor's outer\nelement.\n*/\n\nEditorView.editorAttributes = editorAttributes;\n/**\nAn extension that enables line wrapping in the editor (by\nsetting CSS `white-space` to `pre-wrap` in the content).\n*/\n\nEditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({\n  \"class\": \"cm-lineWrapping\"\n});\n/**\nState effect used to include screen reader announcements in a\ntransaction. These will be added to the DOM in a visually hidden\nelement with `aria-live=\"polite\"` set, and should be used to\ndescribe effects that are visually obvious but may not be\nnoticed by screen reader users (such as moving to the next\nsearch match).\n*/\n\nEditorView.announce = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define(); // Maximum line length for which we compute accurate bidi info\n\nvar MaxBidiLine = 4096; // FIXME remove this and its callers on next breaking release\n\nfunction ensureTop(given, view) {\n  return (given == null ? view.contentDOM.getBoundingClientRect().top : given) + view.viewState.paddingTop;\n}\n\nvar resizeDebounce = -1;\n\nfunction ensureGlobalHandler() {\n  window.addEventListener(\"resize\", function () {\n    if (resizeDebounce == -1) resizeDebounce = setTimeout(handleResize, 50);\n  });\n}\n\nfunction handleResize() {\n  resizeDebounce = -1;\n  var found = document.querySelectorAll(\".cm-content\");\n\n  for (var i = 0; i < found.length; i++) {\n    var docView = ContentView.get(found[i]);\n    if (docView) docView.editorView.requestMeasure();\n  }\n}\n\nvar BadMeasure = {};\n\nvar CachedOrder = /*#__PURE__*/function () {\n  function CachedOrder(from, to, dir, order) {\n    _classCallCheck(this, CachedOrder);\n\n    this.from = from;\n    this.to = to;\n    this.dir = dir;\n    this.order = order;\n  }\n\n  _createClass(CachedOrder, null, [{\n    key: \"update\",\n    value: function update(cache, changes) {\n      if (changes.empty) return cache;\n      var result = [],\n          lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;\n\n      for (var i = Math.max(0, cache.length - 10); i < cache.length; i++) {\n        var entry = cache[i];\n        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));\n      }\n\n      return result;\n    }\n  }]);\n\n  return CachedOrder;\n}();\n\nfunction attrsFromFacet(view, facet, base) {\n  for (var sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {\n    var source = sources[i],\n        value = typeof source == \"function\" ? source(view) : source;\n    if (value) combineAttrs(value, base);\n  }\n\n  return base;\n}\n\nvar currentPlatform = browser.mac ? \"mac\" : browser.windows ? \"win\" : browser.linux ? \"linux\" : \"key\";\n\nfunction normalizeKeyName(name, platform) {\n  var parts = name.split(/-(?!$)/);\n  var result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  var alt, ctrl, shift, meta;\n\n  for (var i = 0; i < parts.length - 1; ++i) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {\n      if (platform == \"mac\") meta = true;else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\n\nvar handleKeyEvents = /*@__PURE__*/EditorView.domEventHandlers({\n  keydown: function keydown(event, view) {\n    return runHandlers(getKeymap(view.state), event, view, \"editor\");\n  }\n});\n/**\nFacet used for registering keymaps.\n\nYou can add multiple keymaps to an editor. Their priorities\ndetermine their precedence (the ones specified early or with high\npriority get checked first). When a handler has returned `true`\nfor a given key, no further handlers are called.\n*/\n\nvar keymap = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n  enables: handleKeyEvents\n});\nvar Keymaps = /*@__PURE__*/new WeakMap(); // This is hidden behind an indirection, rather than directly computed\n// by the facet, to keep internal types out of the facet's type.\n\nfunction getKeymap(state) {\n  var bindings = state.facet(keymap);\n  var map = Keymaps.get(bindings);\n  if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce(function (a, b) {\n    return a.concat(b);\n  }, [])));\n  return map;\n}\n/**\nRun the key handlers registered for a given scope. The event\nobject should be `\"keydown\"` event. Returns true if any of the\nhandlers handled it.\n*/\n\n\nfunction runScopeHandlers(view, event, scope) {\n  return runHandlers(getKeymap(view.state), event, view, scope);\n}\n\nvar storedPrefix = null;\nvar PrefixTimeout = 4000;\n\nfunction buildKeymap(bindings) {\n  var platform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : currentPlatform;\n  var bound = Object.create(null);\n  var isPrefix = Object.create(null);\n\n  var checkPrefix = function checkPrefix(name, is) {\n    var current = isPrefix[name];\n    if (current == null) isPrefix[name] = is;else if (current != is) throw new Error(\"Key binding \" + name + \" is used both as a regular binding and as a multi-stroke prefix\");\n  };\n\n  var add = function add(scope, key, command, preventDefault) {\n    var scopeObj = bound[scope] || (bound[scope] = Object.create(null));\n    var parts = key.split(/ (?!$)/).map(function (k) {\n      return normalizeKeyName(k, platform);\n    });\n\n    var _loop7 = function _loop7(i) {\n      var prefix = parts.slice(0, i).join(\" \");\n      checkPrefix(prefix, true);\n      if (!scopeObj[prefix]) scopeObj[prefix] = {\n        preventDefault: true,\n        commands: [function (view) {\n          var ourObj = storedPrefix = {\n            view: view,\n            prefix: prefix,\n            scope: scope\n          };\n          setTimeout(function () {\n            if (storedPrefix == ourObj) storedPrefix = null;\n          }, PrefixTimeout);\n          return true;\n        }]\n      };\n    };\n\n    for (var i = 1; i < parts.length; i++) {\n      _loop7(i);\n    }\n\n    var full = parts.join(\" \");\n    checkPrefix(full, false);\n    var binding = scopeObj[full] || (scopeObj[full] = {\n      preventDefault: false,\n      commands: []\n    });\n    binding.commands.push(command);\n    if (preventDefault) binding.preventDefault = true;\n  };\n\n  var _iterator55 = _createForOfIteratorHelper(bindings),\n      _step55;\n\n  try {\n    for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {\n      var b = _step55.value;\n      var name = b[platform] || b.key;\n      if (!name) continue;\n\n      var _iterator56 = _createForOfIteratorHelper(b.scope ? b.scope.split(\" \") : [\"editor\"]),\n          _step56;\n\n      try {\n        for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {\n          var scope = _step56.value;\n          add(scope, name, b.run, b.preventDefault);\n          if (b.shift) add(scope, \"Shift-\" + name, b.shift, b.preventDefault);\n        }\n      } catch (err) {\n        _iterator56.e(err);\n      } finally {\n        _iterator56.f();\n      }\n    }\n  } catch (err) {\n    _iterator55.e(err);\n  } finally {\n    _iterator55.f();\n  }\n\n  return bound;\n}\n\nfunction runHandlers(map, event, view, scope) {\n  var name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.keyName)(event),\n      isChar = name.length == 1 && name != \" \";\n  var prefix = \"\",\n      fallthrough = false;\n\n  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {\n    prefix = storedPrefix.prefix + \" \";\n    if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0) storedPrefix = null;\n  }\n\n  var runFor = function runFor(binding) {\n    if (binding) {\n      var _iterator57 = _createForOfIteratorHelper(binding.commands),\n          _step57;\n\n      try {\n        for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {\n          var cmd = _step57.value;\n          if (cmd(view)) return true;\n        }\n      } catch (err) {\n        _iterator57.e(err);\n      } finally {\n        _iterator57.f();\n      }\n\n      if (binding.preventDefault) fallthrough = true;\n    }\n\n    return false;\n  };\n\n  var scopeObj = map[scope],\n      baseName;\n\n  if (scopeObj) {\n    if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) return true;\n\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_2__.base[event.keyCode]) && baseName != name) {\n      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) return true;\n    } else if (isChar && event.shiftKey) {\n      if (runFor(scopeObj[prefix + modifiers(name, event, true)])) return true;\n    }\n  }\n\n  return fallthrough;\n}\n\nvar CanHidePrimary = !browser.ios; // FIXME test IE\n\nvar selectionConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n  combine: function combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.combineConfig)(configs, {\n      cursorBlinkRate: 1200,\n      drawRangeCursor: true\n    }, {\n      cursorBlinkRate: function cursorBlinkRate(a, b) {\n        return Math.min(a, b);\n      },\n      drawRangeCursor: function drawRangeCursor(a, b) {\n        return a || b;\n      }\n    });\n  }\n});\n/**\nReturns an extension that hides the browser's native selection and\ncursor, replacing the selection with a background behind the text\n(with the `cm-selectionBackground` class), and the\ncursors with elements overlaid over the code (using\n`cm-cursor-primary` and `cm-cursor-secondary`).\n\nThis allows the editor to display secondary selection ranges, and\ntends to produce a type of selection more in line with that users\nexpect in a text editor (the native selection styling will often\nleave gaps between lines and won't fill the horizontal space after\na line when the selection continues past it).\n\nIt does have a performance cost, in that it requires an extra DOM\nlayout cycle for many updates (the selection is drawn based on DOM\nlayout information that's only available after laying out the\ncontent).\n*/\n\nfunction drawSelection() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [selectionConfig.of(config), drawSelectionPlugin, hideNativeSelection];\n}\n\nvar Piece = /*#__PURE__*/function () {\n  function Piece(left, top, width, height, className) {\n    _classCallCheck(this, Piece);\n\n    this.left = left;\n    this.top = top;\n    this.width = width;\n    this.height = height;\n    this.className = className;\n  }\n\n  _createClass(Piece, [{\n    key: \"draw\",\n    value: function draw() {\n      var elt = document.createElement(\"div\");\n      elt.className = this.className;\n      this.adjust(elt);\n      return elt;\n    }\n  }, {\n    key: \"adjust\",\n    value: function adjust(elt) {\n      elt.style.left = this.left + \"px\";\n      elt.style.top = this.top + \"px\";\n      if (this.width >= 0) elt.style.width = this.width + \"px\";\n      elt.style.height = this.height + \"px\";\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(p) {\n      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;\n    }\n  }]);\n\n  return Piece;\n}();\n\nvar drawSelectionPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.rangePieces = [];\n    this.cursors = [];\n    this.measureReq = {\n      read: this.readPos.bind(this),\n      write: this.drawSel.bind(this)\n    };\n    this.selectionLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.selectionLayer.className = \"cm-selectionLayer\";\n    this.selectionLayer.setAttribute(\"aria-hidden\", \"true\");\n    this.cursorLayer = view.scrollDOM.appendChild(document.createElement(\"div\"));\n    this.cursorLayer.className = \"cm-cursorLayer\";\n    this.cursorLayer.setAttribute(\"aria-hidden\", \"true\");\n    view.requestMeasure(this.measureReq);\n    this.setBlinkRate();\n  }\n\n  _createClass(_class, [{\n    key: \"setBlinkRate\",\n    value: function setBlinkRate() {\n      this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + \"ms\";\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update6) {\n      var confChanged = _update6.startState.facet(selectionConfig) != _update6.state.facet(selectionConfig);\n\n      if (confChanged || _update6.selectionSet || _update6.geometryChanged || _update6.viewportChanged) this.view.requestMeasure(this.measureReq);\n      if (_update6.transactions.some(function (tr) {\n        return tr.scrollIntoView;\n      })) this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == \"cm-blink\" ? \"cm-blink2\" : \"cm-blink\";\n      if (confChanged) this.setBlinkRate();\n    }\n  }, {\n    key: \"readPos\",\n    value: function readPos() {\n      var _this39 = this;\n\n      var state = this.view.state,\n          conf = state.facet(selectionConfig);\n      var rangePieces = state.selection.ranges.map(function (r) {\n        return r.empty ? [] : measureRange(_this39.view, r);\n      }).reduce(function (a, b) {\n        return a.concat(b);\n      });\n      var cursors = [];\n\n      var _iterator58 = _createForOfIteratorHelper(state.selection.ranges),\n          _step58;\n\n      try {\n        for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {\n          var _r2 = _step58.value;\n          var prim = _r2 == state.selection.main;\n\n          if (_r2.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {\n            var piece = measureCursor(this.view, _r2, prim);\n            if (piece) cursors.push(piece);\n          }\n        }\n      } catch (err) {\n        _iterator58.e(err);\n      } finally {\n        _iterator58.f();\n      }\n\n      return {\n        rangePieces: rangePieces,\n        cursors: cursors\n      };\n    }\n  }, {\n    key: \"drawSel\",\n    value: function drawSel(_ref13) {\n      var _this40 = this;\n\n      var rangePieces = _ref13.rangePieces,\n          cursors = _ref13.cursors;\n\n      if (rangePieces.length != this.rangePieces.length || rangePieces.some(function (p, i) {\n        return !p.eq(_this40.rangePieces[i]);\n      })) {\n        this.selectionLayer.textContent = \"\";\n\n        var _iterator59 = _createForOfIteratorHelper(rangePieces),\n            _step59;\n\n        try {\n          for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {\n            var _p2 = _step59.value;\n            this.selectionLayer.appendChild(_p2.draw());\n          }\n        } catch (err) {\n          _iterator59.e(err);\n        } finally {\n          _iterator59.f();\n        }\n\n        this.rangePieces = rangePieces;\n      }\n\n      if (cursors.length != this.cursors.length || cursors.some(function (c, i) {\n        return !c.eq(_this40.cursors[i]);\n      })) {\n        var oldCursors = this.cursorLayer.children;\n\n        if (oldCursors.length !== cursors.length) {\n          this.cursorLayer.textContent = \"\";\n\n          var _iterator60 = _createForOfIteratorHelper(cursors),\n              _step60;\n\n          try {\n            for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {\n              var c = _step60.value;\n              this.cursorLayer.appendChild(c.draw());\n            }\n          } catch (err) {\n            _iterator60.e(err);\n          } finally {\n            _iterator60.f();\n          }\n        } else {\n          cursors.forEach(function (c, idx) {\n            return c.adjust(oldCursors[idx]);\n          });\n        }\n\n        this.cursors = cursors;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.selectionLayer.remove();\n      this.cursorLayer.remove();\n    }\n  }]);\n\n  return _class;\n}());\nvar themeSpec = {\n  \".cm-line\": {\n    \"& ::selection\": {\n      backgroundColor: \"transparent !important\"\n    },\n    \"&::selection\": {\n      backgroundColor: \"transparent !important\"\n    }\n  }\n};\nif (CanHidePrimary) themeSpec[\".cm-line\"].caretColor = \"transparent !important\";\nvar hideNativeSelection = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Prec.highest( /*@__PURE__*/EditorView.theme(themeSpec));\n\nfunction getBase(view) {\n  var rect = view.scrollDOM.getBoundingClientRect();\n  var left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;\n  return {\n    left: left - view.scrollDOM.scrollLeft,\n    top: rect.top - view.scrollDOM.scrollTop\n  };\n}\n\nfunction wrappedLine(view, pos, inside) {\n  var range = _codemirror_state__WEBPACK_IMPORTED_MODULE_4__.EditorSelection.cursor(pos);\n  return {\n    from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),\n    to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),\n    type: BlockType.Text\n  };\n}\n\nfunction blockAt(view, pos) {\n  var line = view.lineBlockAt(pos);\n\n  if (Array.isArray(line.type)) {\n    var _iterator61 = _createForOfIteratorHelper(line.type),\n        _step61;\n\n    try {\n      for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {\n        var _l2 = _step61.value;\n        if (_l2.to > pos || _l2.to == pos && (_l2.to == line.to || _l2.type == BlockType.Text)) return _l2;\n      }\n    } catch (err) {\n      _iterator61.e(err);\n    } finally {\n      _iterator61.f();\n    }\n  }\n\n  return line;\n}\n\nfunction measureRange(view, range) {\n  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];\n  var from = Math.max(range.from, view.viewport.from),\n      to = Math.min(range.to, view.viewport.to);\n  var ltr = view.textDirection == Direction.LTR;\n  var content = view.contentDOM,\n      contentRect = content.getBoundingClientRect(),\n      base = getBase(view);\n  var lineStyle = window.getComputedStyle(content.firstChild);\n  var leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));\n  var rightSide = contentRect.right - parseInt(lineStyle.paddingRight);\n  var startBlock = blockAt(view, from),\n      endBlock = blockAt(view, to);\n  var visualStart = startBlock.type == BlockType.Text ? startBlock : null;\n  var visualEnd = endBlock.type == BlockType.Text ? endBlock : null;\n\n  if (view.lineWrapping) {\n    if (visualStart) visualStart = wrappedLine(view, from, visualStart);\n    if (visualEnd) visualEnd = wrappedLine(view, to, visualEnd);\n  }\n\n  if (visualStart && visualEnd && visualStart.from == visualEnd.from) {\n    return pieces(drawForLine(range.from, range.to, visualStart));\n  } else {\n    var top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);\n    var bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);\n    var between = [];\n    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;\n    return pieces(top).concat(between).concat(pieces(bottom));\n  }\n\n  function piece(left, top, right, bottom) {\n    return new Piece(left - base.left, top - base.top - 0.01\n    /* Epsilon */\n    , right - left, bottom - top + 0.01\n    /* Epsilon */\n    , \"cm-selectionBackground\");\n  }\n\n  function pieces(_ref14) {\n    var top = _ref14.top,\n        bottom = _ref14.bottom,\n        horizontal = _ref14.horizontal;\n    var pieces = [];\n\n    for (var i = 0; i < horizontal.length; i += 2) {\n      pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));\n    }\n\n    return pieces;\n  } // Gets passed from/to in line-local positions\n\n\n  function drawForLine(from, to, line) {\n    var top = 1e9,\n        bottom = -1e9,\n        horizontal = [];\n\n    function addSpan(from, fromOpen, to, toOpen, dir) {\n      // Passing 2/-2 is a kludge to force the view to return\n      // coordinates on the proper side of block widgets, since\n      // normalizing the side there, though appropriate for most\n      // coordsAtPos queries, would break selection drawing.\n      var fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);\n      var toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);\n      top = Math.min(fromCoords.top, toCoords.top, top);\n      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);\n      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);\n    }\n\n    var start = from !== null && from !== void 0 ? from : line.from,\n        end = to !== null && to !== void 0 ? to : line.to; // Split the range by visible range and document line\n\n    var _iterator62 = _createForOfIteratorHelper(view.visibleRanges),\n        _step62;\n\n    try {\n      for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {\n        var _r3 = _step62.value;\n\n        if (_r3.to > start && _r3.from < end) {\n          for (var pos = Math.max(_r3.from, start), endPos = Math.min(_r3.to, end);;) {\n            var docLine = view.state.doc.lineAt(pos);\n\n            var _iterator63 = _createForOfIteratorHelper(view.bidiSpans(docLine)),\n                _step63;\n\n            try {\n              for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {\n                var span = _step63.value;\n                var spanFrom = span.from + docLine.from,\n                    spanTo = span.to + docLine.from;\n                if (spanFrom >= endPos) break;\n                if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);\n              }\n            } catch (err) {\n              _iterator63.e(err);\n            } finally {\n              _iterator63.f();\n            }\n\n            pos = docLine.to + 1;\n            if (pos >= endPos) break;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator62.e(err);\n    } finally {\n      _iterator62.f();\n    }\n\n    if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);\n    return {\n      top: top,\n      bottom: bottom,\n      horizontal: horizontal\n    };\n  }\n\n  function drawForWidget(block, top) {\n    var y = contentRect.top + (top ? block.top : block.bottom);\n    return {\n      top: y,\n      bottom: y,\n      horizontal: []\n    };\n  }\n}\n\nfunction measureCursor(view, cursor, primary) {\n  var pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);\n  if (!pos) return null;\n  var base = getBase(view);\n  return new Piece(pos.left - base.left, pos.top - base.top, -1, pos.bottom - pos.top, primary ? \"cm-cursor cm-cursor-primary\" : \"cm-cursor cm-cursor-secondary\");\n}\n\nvar setDropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateEffect.define({\n  map: function map(pos, mapping) {\n    return pos == null ? null : mapping.mapPos(pos);\n  }\n});\nvar dropCursorPos = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.StateField.define({\n  create: function create() {\n    return null;\n  },\n  update: function update(pos, tr) {\n    if (pos != null) pos = tr.changes.mapPos(pos);\n    return tr.effects.reduce(function (pos, e) {\n      return e.is(setDropCursorPos) ? e.value : pos;\n    }, pos);\n  }\n});\nvar drawDropCursor = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class2(view) {\n    _classCallCheck(this, _class2);\n\n    this.view = view;\n    this.cursor = null;\n    this.measureReq = {\n      read: this.readPos.bind(this),\n      write: this.drawCursor.bind(this)\n    };\n  }\n\n  _createClass(_class2, [{\n    key: \"update\",\n    value: function update(_update7) {\n      var _a;\n\n      var cursorPos = _update7.state.field(dropCursorPos);\n\n      if (cursorPos == null) {\n        if (this.cursor != null) {\n          (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();\n          this.cursor = null;\n        }\n      } else {\n        if (!this.cursor) {\n          this.cursor = this.view.scrollDOM.appendChild(document.createElement(\"div\"));\n          this.cursor.className = \"cm-dropCursor\";\n        }\n\n        if (_update7.startState.field(dropCursorPos) != cursorPos || _update7.docChanged || _update7.geometryChanged) this.view.requestMeasure(this.measureReq);\n      }\n    }\n  }, {\n    key: \"readPos\",\n    value: function readPos() {\n      var pos = this.view.state.field(dropCursorPos);\n      var rect = pos != null && this.view.coordsAtPos(pos);\n      if (!rect) return null;\n      var outer = this.view.scrollDOM.getBoundingClientRect();\n      return {\n        left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,\n        top: rect.top - outer.top + this.view.scrollDOM.scrollTop,\n        height: rect.bottom - rect.top\n      };\n    }\n  }, {\n    key: \"drawCursor\",\n    value: function drawCursor(pos) {\n      if (this.cursor) {\n        if (pos) {\n          this.cursor.style.left = pos.left + \"px\";\n          this.cursor.style.top = pos.top + \"px\";\n          this.cursor.style.height = pos.height + \"px\";\n        } else {\n          this.cursor.style.left = \"-100000px\";\n        }\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.cursor) this.cursor.remove();\n    }\n  }, {\n    key: \"setDropPos\",\n    value: function setDropPos(pos) {\n      if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({\n        effects: setDropCursorPos.of(pos)\n      });\n    }\n  }]);\n\n  return _class2;\n}(), {\n  eventHandlers: {\n    dragover: function dragover(event) {\n      this.setDropPos(this.view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n      }));\n    },\n    dragleave: function dragleave(event) {\n      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);\n    },\n    dragend: function dragend() {\n      this.setDropPos(null);\n    },\n    drop: function drop() {\n      this.setDropPos(null);\n    }\n  }\n});\n/**\nDraws a cursor at the current drop position when something is\ndragged over the editor.\n*/\n\nfunction dropCursor() {\n  return [dropCursorPos, drawDropCursor];\n}\n\nfunction iterMatches(doc, re, from, to, f) {\n  re.lastIndex = 0;\n\n  for (var cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {\n    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) {\n      f(pos + m.index, pos + m.index + m[0].length, m);\n    }\n  }\n}\n\nfunction matchRanges(view, maxLength) {\n  var visible = view.visibleRanges;\n  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;\n  var result = [];\n\n  var _iterator64 = _createForOfIteratorHelper(visible),\n      _step64;\n\n  try {\n    for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {\n      var _step64$value = _step64.value,\n          from = _step64$value.from,\n          to = _step64$value.to;\n      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);\n      to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);\n      if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;else result.push({\n        from: from,\n        to: to\n      });\n    }\n  } catch (err) {\n    _iterator64.e(err);\n  } finally {\n    _iterator64.f();\n  }\n\n  return result;\n}\n/**\nHelper class used to make it easier to maintain decorations on\nvisible code that matches a given regular expression. To be used\nin a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object\nrepresent a matching configuration.\n*/\n\n\nvar MatchDecorator = /*#__PURE__*/function () {\n  /**\n  Create a decorator.\n  */\n  function MatchDecorator(config) {\n    _classCallCheck(this, MatchDecorator);\n\n    var regexp = config.regexp,\n        decoration = config.decoration,\n        boundary = config.boundary,\n        _config$maxLength = config.maxLength,\n        maxLength = _config$maxLength === void 0 ? 1000 : _config$maxLength;\n    if (!regexp.global) throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n    this.regexp = regexp;\n    this.getDeco = typeof decoration == \"function\" ? decoration : function () {\n      return decoration;\n    };\n    this.boundary = boundary;\n    this.maxLength = maxLength;\n  }\n  /**\n  Compute the full set of decorations for matches in the given\n  view's viewport. You'll want to call this when initializing your\n  plugin.\n  */\n\n\n  _createClass(MatchDecorator, [{\n    key: \"createDeco\",\n    value: function createDeco(view) {\n      var _this41 = this;\n\n      var build = new _codemirror_rangeset__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();\n\n      var _iterator65 = _createForOfIteratorHelper(matchRanges(view, this.maxLength)),\n          _step65;\n\n      try {\n        for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {\n          var _step65$value = _step65.value,\n              from = _step65$value.from,\n              to = _step65$value.to;\n          iterMatches(view.state.doc, this.regexp, from, to, function (a, b, m) {\n            return build.add(a, b, _this41.getDeco(m, view, a));\n          });\n        }\n      } catch (err) {\n        _iterator65.e(err);\n      } finally {\n        _iterator65.f();\n      }\n\n      return build.finish();\n    }\n    /**\n    Update a set of decorations for a view update. `deco` _must_ be\n    the set of decorations produced by _this_ `MatchDecorator` for\n    the view state before the update.\n    */\n\n  }, {\n    key: \"updateDeco\",\n    value: function updateDeco(update, deco) {\n      var changeFrom = 1e9,\n          changeTo = -1;\n      if (update.docChanged) update.changes.iterChanges(function (_f, _t, from, to) {\n        if (to > update.view.viewport.from && from < update.view.viewport.to) {\n          changeFrom = Math.min(from, changeFrom);\n          changeTo = Math.max(to, changeTo);\n        }\n      });\n      if (update.viewportChanged || changeTo - changeFrom > 1000) return this.createDeco(update.view);\n      if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);\n      return deco;\n    }\n  }, {\n    key: \"updateRange\",\n    value: function updateRange(view, deco, updateFrom, updateTo) {\n      var _this42 = this;\n\n      var _iterator66 = _createForOfIteratorHelper(view.visibleRanges),\n          _step66;\n\n      try {\n        for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {\n          var _r4 = _step66.value;\n          var from = Math.max(_r4.from, updateFrom),\n              to = Math.min(_r4.to, updateTo);\n\n          if (to > from) {\n            (function () {\n              var fromLine = view.state.doc.lineAt(from),\n                  toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;\n              var start = Math.max(_r4.from, fromLine.from),\n                  end = Math.min(_r4.to, toLine.to);\n\n              if (_this42.boundary) {\n                for (; from > fromLine.from; from--) {\n                  if (_this42.boundary.test(fromLine.text[from - 1 - fromLine.from])) {\n                    start = from;\n                    break;\n                  }\n                }\n\n                for (; to < toLine.to; to++) {\n                  if (_this42.boundary.test(toLine.text[to - toLine.from])) {\n                    end = to;\n                    break;\n                  }\n                }\n              }\n\n              var ranges = [],\n                  m = void 0;\n\n              if (fromLine == toLine) {\n                _this42.regexp.lastIndex = start - fromLine.from;\n\n                while ((m = _this42.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {\n                  var pos = m.index + fromLine.from;\n                  ranges.push(_this42.getDeco(m, view, pos).range(pos, pos + m[0].length));\n                }\n              } else {\n                iterMatches(view.state.doc, _this42.regexp, start, end, function (from, to, m) {\n                  return ranges.push(_this42.getDeco(m, view, from).range(from, to));\n                });\n              }\n\n              deco = deco.update({\n                filterFrom: start,\n                filterTo: end,\n                filter: function filter(from, to) {\n                  return from < start || to > end;\n                },\n                add: ranges\n              });\n            })();\n          }\n        }\n      } catch (err) {\n        _iterator66.e(err);\n      } finally {\n        _iterator66.f();\n      }\n\n      return deco;\n    }\n  }]);\n\n  return MatchDecorator;\n}();\n\nvar UnicodeRegexpSupport = /x/.unicode != null ? \"gu\" : \"g\";\nvar Specials = /*@__PURE__*/new RegExp(\"[\\0-\\b\\n-\\x1F\\x7F-\\x9F\\xAD\\u061C\\u200B\\u200E\\u200F\\u2028\\u2029\\u202D\\u202E\\uFEFF\\uFFF9-\\uFFFC]\", UnicodeRegexpSupport);\nvar Names = {\n  0: \"null\",\n  7: \"bell\",\n  8: \"backspace\",\n  10: \"newline\",\n  11: \"vertical tab\",\n  13: \"carriage return\",\n  27: \"escape\",\n  8203: \"zero width space\",\n  8204: \"zero width non-joiner\",\n  8205: \"zero width joiner\",\n  8206: \"left-to-right mark\",\n  8207: \"right-to-left mark\",\n  8232: \"line separator\",\n  8237: \"left-to-right override\",\n  8238: \"right-to-left override\",\n  8233: \"paragraph separator\",\n  65279: \"zero width no-break space\",\n  65532: \"object replacement\"\n};\nvar _supportsTabSize = null;\n\nfunction supportsTabSize() {\n  var _a;\n\n  if (_supportsTabSize == null && typeof document != \"undefined\" && document.body) {\n    var styles = document.body.style;\n    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;\n  }\n\n  return _supportsTabSize || false;\n}\n\nvar specialCharConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.Facet.define({\n  combine: function combine(configs) {\n    var config = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_4__.combineConfig)(configs, {\n      render: null,\n      specialChars: Specials,\n      addSpecialChars: null\n    });\n    if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp(\"\\t|\" + config.specialChars.source, UnicodeRegexpSupport);\n    if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + \"|\" + config.addSpecialChars.source, UnicodeRegexpSupport);\n    return config;\n  }\n});\n/**\nReturns an extension that installs highlighting of special\ncharacters.\n*/\n\nfunction highlightSpecialChars() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [specialCharConfig.of(config), specialCharPlugin()];\n}\n\nvar _plugin = null;\n\nfunction specialCharPlugin() {\n  return _plugin || (_plugin = ViewPlugin.fromClass( /*#__PURE__*/function () {\n    function _class3(view) {\n      _classCallCheck(this, _class3);\n\n      this.view = view;\n      this.decorations = Decoration.none;\n      this.decorationCache = Object.create(null);\n      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));\n      this.decorations = this.decorator.createDeco(view);\n    }\n\n    _createClass(_class3, [{\n      key: \"makeDecorator\",\n      value: function makeDecorator(conf) {\n        var _this43 = this;\n\n        return new MatchDecorator({\n          regexp: conf.specialChars,\n          decoration: function decoration(m, view, pos) {\n            var doc = view.state.doc;\n            var code = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.codePointAt)(m[0], 0);\n\n            if (code == 9) {\n              var line = doc.lineAt(pos);\n              var size = view.state.tabSize,\n                  col = (0,_codemirror_text__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line.text, size, pos - line.from);\n              return Decoration.replace({\n                widget: new TabWidget((size - col % size) * _this43.view.defaultCharacterWidth)\n              });\n            }\n\n            return _this43.decorationCache[code] || (_this43.decorationCache[code] = Decoration.replace({\n              widget: new SpecialCharWidget(conf, code)\n            }));\n          },\n          boundary: conf.replaceTabs ? undefined : /[^]/\n        });\n      }\n    }, {\n      key: \"update\",\n      value: function update(_update8) {\n        var conf = _update8.state.facet(specialCharConfig);\n\n        if (_update8.startState.facet(specialCharConfig) != conf) {\n          this.decorator = this.makeDecorator(conf);\n          this.decorations = this.decorator.createDeco(_update8.view);\n        } else {\n          this.decorations = this.decorator.updateDeco(_update8, this.decorations);\n        }\n      }\n    }]);\n\n    return _class3;\n  }(), {\n    decorations: function decorations(v) {\n      return v.decorations;\n    }\n  }));\n}\n\nvar DefaultPlaceholder = \"\\u2022\"; // Assigns placeholder characters from the Control Pictures block to\n// ASCII control characters\n\nfunction placeholder$1(code) {\n  if (code >= 32) return DefaultPlaceholder;\n  if (code == 10) return \"\\u2424\";\n  return String.fromCharCode(9216 + code);\n}\n\nvar SpecialCharWidget = /*#__PURE__*/function (_WidgetType5) {\n  _inherits(SpecialCharWidget, _WidgetType5);\n\n  var _super21 = _createSuper(SpecialCharWidget);\n\n  function SpecialCharWidget(options, code) {\n    var _this44;\n\n    _classCallCheck(this, SpecialCharWidget);\n\n    _this44 = _super21.call(this);\n    _this44.options = options;\n    _this44.code = code;\n    return _this44;\n  }\n\n  _createClass(SpecialCharWidget, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other.code == this.code;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM(view) {\n      var ph = placeholder$1(this.code);\n      var desc = view.state.phrase(\"Control character\") + \" \" + (Names[this.code] || \"0x\" + this.code.toString(16));\n      var custom = this.options.render && this.options.render(this.code, desc, ph);\n      if (custom) return custom;\n      var span = document.createElement(\"span\");\n      span.textContent = ph;\n      span.title = desc;\n      span.setAttribute(\"aria-label\", desc);\n      span.className = \"cm-specialChar\";\n      return span;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent() {\n      return false;\n    }\n  }]);\n\n  return SpecialCharWidget;\n}(WidgetType);\n\nvar TabWidget = /*#__PURE__*/function (_WidgetType6) {\n  _inherits(TabWidget, _WidgetType6);\n\n  var _super22 = _createSuper(TabWidget);\n\n  function TabWidget(width) {\n    var _this45;\n\n    _classCallCheck(this, TabWidget);\n\n    _this45 = _super22.call(this);\n    _this45.width = width;\n    return _this45;\n  }\n\n  _createClass(TabWidget, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other.width == this.width;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM() {\n      var span = document.createElement(\"span\");\n      span.textContent = \"\\t\";\n      span.className = \"cm-tab\";\n      span.style.width = this.width + \"px\";\n      return span;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent() {\n      return false;\n    }\n  }]);\n\n  return TabWidget;\n}(WidgetType);\n\nvar plugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class4() {\n    _classCallCheck(this, _class4);\n\n    this.height = 1000;\n    this.attrs = {\n      style: \"padding-bottom: 1000px\"\n    };\n  }\n\n  _createClass(_class4, [{\n    key: \"update\",\n    value: function update(_update9) {\n      var height = _update9.view.viewState.editorHeight - _update9.view.defaultLineHeight;\n\n      if (height != this.height) {\n        this.height = height;\n        this.attrs = {\n          style: \"padding-bottom: \".concat(height, \"px\")\n        };\n      }\n    }\n  }]);\n\n  return _class4;\n}());\n/**\nReturns an extension that makes sure the content has a bottom\nmargin equivalent to the height of the editor, minus one line\nheight, so that every line in the document can be scrolled to the\ntop of the editor.\n\nThis is only meaningful when the editor is scrollable, and should\nnot be enabled in editors that take the size of their content.\n*/\n\nfunction scrollPastEnd() {\n  return [plugin, contentAttributes.of(function (view) {\n    var _a;\n\n    return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;\n  })];\n}\n/**\nMark lines that have a cursor on them with the `\"cm-activeLine\"`\nDOM class.\n*/\n\n\nfunction highlightActiveLine() {\n  return activeLineHighlighter;\n}\n\nvar lineDeco = /*@__PURE__*/Decoration.line({\n  \"class\": \"cm-activeLine\"\n});\nvar activeLineHighlighter = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class5(view) {\n    _classCallCheck(this, _class5);\n\n    this.decorations = this.getDeco(view);\n  }\n\n  _createClass(_class5, [{\n    key: \"update\",\n    value: function update(_update10) {\n      if (_update10.docChanged || _update10.selectionSet) this.decorations = this.getDeco(_update10.view);\n    }\n  }, {\n    key: \"getDeco\",\n    value: function getDeco(view) {\n      var lastLineStart = -1,\n          deco = [];\n\n      var _iterator67 = _createForOfIteratorHelper(view.state.selection.ranges),\n          _step67;\n\n      try {\n        for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {\n          var _r5 = _step67.value;\n          if (!_r5.empty) return Decoration.none;\n          var line = view.lineBlockAt(_r5.head);\n\n          if (line.from > lastLineStart) {\n            deco.push(lineDeco.range(line.from));\n            lastLineStart = line.from;\n          }\n        }\n      } catch (err) {\n        _iterator67.e(err);\n      } finally {\n        _iterator67.f();\n      }\n\n      return Decoration.set(deco);\n    }\n  }]);\n\n  return _class5;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\n\nvar Placeholder = /*#__PURE__*/function (_WidgetType7) {\n  _inherits(Placeholder, _WidgetType7);\n\n  var _super23 = _createSuper(Placeholder);\n\n  function Placeholder(content) {\n    var _this46;\n\n    _classCallCheck(this, Placeholder);\n\n    _this46 = _super23.call(this);\n    _this46.content = content;\n    return _this46;\n  }\n\n  _createClass(Placeholder, [{\n    key: \"toDOM\",\n    value: function toDOM() {\n      var wrap = document.createElement(\"span\");\n      wrap.className = \"cm-placeholder\";\n      wrap.style.pointerEvents = \"none\";\n      wrap.appendChild(typeof this.content == \"string\" ? document.createTextNode(this.content) : this.content);\n      if (typeof this.content == \"string\") wrap.setAttribute(\"aria-label\", \"placeholder \" + this.content);else wrap.setAttribute(\"aria-hidden\", \"true\");\n      return wrap;\n    }\n  }, {\n    key: \"ignoreEvent\",\n    value: function ignoreEvent() {\n      return false;\n    }\n  }]);\n\n  return Placeholder;\n}(WidgetType);\n/**\nExtension that enables a placeholder—a piece of example content\nto show when the editor is empty.\n*/\n\n\nfunction placeholder(content) {\n  return ViewPlugin.fromClass( /*#__PURE__*/function () {\n    function _class6(view) {\n      _classCallCheck(this, _class6);\n\n      this.view = view;\n      this.placeholder = Decoration.set([Decoration.widget({\n        widget: new Placeholder(content),\n        side: 1\n      }).range(0)]);\n    }\n\n    _createClass(_class6, [{\n      key: \"decorations\",\n      get: function get() {\n        return this.view.state.doc.length ? Decoration.none : this.placeholder;\n      }\n    }]);\n\n    return _class6;\n  }(), {\n    decorations: function decorations(v) {\n      return v.decorations;\n    }\n  });\n}\n/**\n@internal\n*/\n\n\nvar __test = {\n  HeightMap: HeightMap,\n  HeightOracle: HeightOracle,\n  MeasuredHeights: MeasuredHeights,\n  QueryType: QueryType,\n  ChangedRange: ChangedRange,\n  computeOrder: computeOrder,\n  moveVisually: moveVisually\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUVBOztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRUE7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBSkE7O0FBTUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7O0FBRUE7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7OztBQUVBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQU5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUZBO0FBQUE7O0FBQUE7QUFHQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBdkJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBd0JBOztBQUVBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBOzs7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7O0FBQ0E7QUFJQTs7QUFDQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUZBO0FBR0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUFBOztBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBRUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFaQTtBQUFBO0FBQUE7Ozs7OztBQWNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUVBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFHQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFKQTtBQUFBOztBQUFBO0FBS0E7QUFBQTtBQUNBO0FBREE7QUFMQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWtCQTs7QUFDQTs7Ozs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFGQTtBQUdBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7OztBQTVDQTs7QUE4Q0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBQUE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFEQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFPQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFEQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFBQTs7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFWQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVdBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEvREE7O0FBaUVBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBS0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBOztBQUNBO0FBRUE7OztBQWhFQTtBQUNBO0FBQ0E7Ozs7QUFUQTs7QUF5RUE7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7QUFUQTtBQVlBOzs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRkE7QUFHQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7Ozs7QUEzQkE7O0FBNkJBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBTUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFEQTtBQUdBO0FBRUE7QUFEQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOzs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7Ozs7O0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBdUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FBekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7OztBQWhGQTtBQXNGQTtBQUNBO0FBQ0E7OztBQUNBOztBQUNBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7Ozs7QUFDQTtBQUNBO0FBS0E7OztBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFuQkE7O0FBcUJBOztBQUNBOzs7OztBQUNBO0FBQUE7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFEQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBWEE7O0FBYUE7QUFDQTs7QUFDQTs7Ozs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTs7Ozs7QUFFQTtBQUNBO0FBRUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUlBOzs7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7Ozs7QUF6QkE7O0FBMkJBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7O0FBRUE7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQU9BOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBOztBQUhBO0FBQUE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUE7QUFBQTtBQUNBO0FBREE7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7O0FBNUlBOztBQThJQTs7Ozs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU1BOzs7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBOztBQUNBO0FBRUE7Ozs7QUF0REE7O0FBeURBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7O0FBQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRkE7QUFHQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7QUFQQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQURBOztBQUlBO0FBQ0E7QUFBQTtBQUFBO0FBREE7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBUUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7Ozs7QUFFQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBQUE7O0FBQUE7QUFVQTtBQUFBO0FBQ0E7QUFEQTtBQVZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7OztBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7OztBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUxBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUdBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBRUE7QUFDQTs7OztBQUVBOzs7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFRQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTs7Ozs7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQTVCQTtBQTZCQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFQQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUFBOztBQVJBO0FBQUE7O0FBQUE7QUFTQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBWEE7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXFCQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRkE7QUFJQTtBQUNBOzs7O0FBL1dBOztBQWlYQTtBQUNBO0FBR0E7O0FBQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRkE7QUFHQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7OztBQWZBOztBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBREE7O0FBRUE7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBTUE7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7OztBQVRBOztBQVdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFGQTs7QUFJQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFEQTs7QUFHQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBVUE7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUExQkE7QUE0QkE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBSUE7O0FBQ0E7QUF6Q0E7O0FBMkJBO0FBQUE7QUFlQTs7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTs7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFBQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQVZBOztBQUNBO0FBQUE7QUFBQTtBQVVBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBOzs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBYUE7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBWUE7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUdBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBOzs7QUFDQTtBQUFBOztBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUdBOztBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBREE7O0FBR0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBSkE7QUFBQTs7QUFBQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQVVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFNQTtBQS9CQTtBQWlDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFLQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFOQTtBQVFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFmQTs7QUFPQTtBQUFBO0FBU0E7QUFoQkE7QUFpQkE7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7QUFDQTtBQUNBOztBQUZBO0FBQUE7O0FBQUE7QUFHQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBV0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFIQTtBQUtBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBOztBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7Ozs7O0FBRUE7O0FBQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRkE7QUFHQTs7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7O0FBQUE7O0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7O0FBcEJBOztBQXNCQTs7Ozs7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBSEE7QUFJQTs7OztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7OztBQWhDQTs7QUFrQ0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTtBQUFBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7QUFoR0E7O0FBa0dBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFLQTs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBSUE7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBVEE7QUFBQTs7QUFBQTtBQVVBO0FBQUE7QUFDQTtBQURBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7OztBQW5IQTs7QUFxSEE7QUFDQTtBQUNBO0FBSUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBRUE7OztBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFOQTtBQUFBOztBQUFBO0FBT0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7OztBQUNBOzs7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRUE7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFXQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFaQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTs7Ozs7O0FBS0E7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBOzs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7OztBQW5CQTs7QUFxQkE7QUFDQTtBQUFBOztBQUNBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBOztBQURBO0FBR0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBUEE7O0FBRUE7QUFBQTtBQU1BOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUVBOzs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFHQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFFQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTs7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBOzs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU1BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTs7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFIQTtBQUlBOzs7QUFDQTtBQUNBO0FBRUE7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQURBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTs7QUFFQTs7QUFIQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQWpDQTtBQWtDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQXZDQTs7QUFrQ0E7QUFBQTtBQUFBO0FBbENBOztBQUtBO0FBQUE7O0FBQUE7QUFtQ0E7QUF4Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUF5Q0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFSQTs7QUFVQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBO0FBRUE7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFSQTtBQUFBOztBQUFBO0FBU0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBVEE7QUFXQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQVZBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUZBO0FBbEpBO0FBd0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBUUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUFBOztBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQVhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBWUE7QUFDQTtBQUFBO0FBS0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBRkE7O0FBR0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFJQTs7O0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFHQTtBQUFBOztBQUNBO0FBREE7QUFIQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUFBOztBQUNBO0FBQ0E7O0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTtBQUNBO0FBREE7QUFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBRUE7QUFBQTtBQUFBOztBQU5BO0FBQUE7O0FBQUE7QUFPQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFxQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTEE7QUFBQTs7QUFBQTtBQU1BO0FBQUE7QUFDQTtBQURBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQURBOztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBRUE7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFJQTtBQUVBOztBQUNBOztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBSkE7QUFTQTtBQUFBO0FBQ0E7QUFGQTs7QUFJQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBU0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBOztBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBRUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFsQ0E7QUFBQTs7QUFBQTtBQW1DQTtBQUFBOztBQUNBO0FBREE7QUFuQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFBQTs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBOztBQUpBO0FBQUE7O0FBQUE7QUFLQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBTkE7QUFBQTs7QUFBQTtBQU9BO0FBQUE7QUFDQTtBQU1BO0FBZEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWVBO0FBakJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa0JBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFEQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFMQTtBQUFBOztBQUFBO0FBTUE7QUFBQTs7QUFDQTtBQURBO0FBTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQWFBO0FBQUE7QUFDQTtBQURBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7O0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBOztBQUFBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBR0E7QUFDQTs7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBVkE7O0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTs7QUFEQTtBQUFBOztBQUFBO0FBRUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7O0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTs7QUFIQTtBQUFBOztBQUFBO0FBSUE7QUFBQTtBQUNBO0FBREE7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBOztBQUNBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFFQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFJQTtBQUdBOztBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFQQTs7QUFHQTtBQUFBO0FBYUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBOztBQWpDQTtBQUFBOztBQUFBO0FBa0NBO0FBQUE7QUFDQTtBQUNBOztBQUZBO0FBQUE7O0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVNBO0FBM0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBNENBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUVBOztBQUNBO0FBQ0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBSUE7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQ0E7QUFLQTs7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBRUE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWRBO0FBQUE7QUFBQTtBQWdCQTtBQUNBO0FBakJBO0FBQUE7QUFBQTtBQW1CQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUExQkE7QUFBQTtBQUFBO0FBMkJBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBSEE7QUFBQTs7QUFBQTtBQUlBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBeENBO0FBQUE7QUFBQTtBQXlDQTs7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQUFBO0FBQUE7QUE4REE7QUFDQTtBQUNBO0FBaEVBOztBQUFBO0FBQUE7QUFrRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUZBO0FBREE7QUFNQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFHQTs7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBSkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUtBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFEQTs7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQUE7O0FBaEJBO0FBQUE7O0FBQUE7QUFrQkE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7O0FBREE7QUFBQTs7QUFBQTtBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFTQTtBQUNBO0FBRUE7QUFDQTtBQWZBO0FBbEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBa0NBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFEQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBTEE7QUFBQTtBQUFBO0FBT0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTtBQUNBO0FBdkJBO0FBQUE7QUFBQTtBQXlCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQW5DQTtBQUFBO0FBQUE7QUFxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUEvQ0E7QUFBQTtBQUFBO0FBaURBO0FBRUE7QUFuREE7QUFBQTtBQUFBO0FBcURBO0FBQ0E7QUFBQTtBQUNBO0FBdkRBOztBQUFBO0FBQUE7QUF5REE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQURBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQURBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7QUFMQTtBQUFBOztBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFDQTtBQUFBOztBQUNBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOzs7QUFDQTtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBS0E7O0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMUJBO0FBMkJBO0FBQ0E7QUEvQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFnQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7QUFFQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBUEE7QUFBQTtBQUFBO0FBUUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBeEJBO0FBQUE7QUFBQTtBQTBCQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWxDQTs7QUFBQTtBQUFBO0FBb0NBO0FBQUE7QUFBQTtBQURBO0FBR0E7O0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBOztBQUNBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJQTs7OztBQUNBO0FBQUE7QUFBQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7QUFwQkE7O0FBc0JBOzs7OztBQUNBO0FBQUE7O0FBQUE7O0FBQ0E7QUFDQTtBQUZBO0FBR0E7Ozs7QUFDQTtBQUFBO0FBQUE7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQUE7Ozs7QUFiQTs7QUFnQkE7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBSkE7QUFBQTtBQUFBO0FBTUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFYQTs7QUFBQTtBQUFBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTs7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUhBO0FBQUE7QUFBQTtBQUtBO0FBRUE7QUFQQTtBQUFBO0FBQUE7QUFTQTtBQUFBOztBQURBO0FBQUE7O0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFXQTtBQUNBO0FBcEJBOztBQUFBO0FBQUE7QUFzQkE7QUFBQTtBQUFBO0FBREE7O0FBSUE7Ozs7O0FBQ0E7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBRkE7QUFHQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7OztBQUNBO0FBQUE7QUFBQTs7OztBQWhCQTtBQWtCQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUpBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFMQTs7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3Ivdmlldy9kaXN0L2luZGV4LmpzPzAyZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwTW9kZSwgVGV4dCBhcyBUZXh0JDEsIEZhY2V0LCBTdGF0ZUVmZmVjdCwgQ2hhbmdlU2V0LCBFZGl0b3JTZWxlY3Rpb24sIENoYXJDYXRlZ29yeSwgRWRpdG9yU3RhdGUsIFRyYW5zYWN0aW9uLCBQcmVjLCBjb21iaW5lQ29uZmlnLCBTdGF0ZUZpZWxkIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgU3R5bGVNb2R1bGUgfSBmcm9tICdzdHlsZS1tb2QnO1xuaW1wb3J0IHsgUmFuZ2VTZXQsIFJhbmdlVmFsdWUsIFJhbmdlU2V0QnVpbGRlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3Jhbmdlc2V0JztcbmV4cG9ydCB7IFJhbmdlIH0gZnJvbSAnQGNvZGVtaXJyb3IvcmFuZ2VzZXQnO1xuaW1wb3J0IHsgVGV4dCwgZmluZENsdXN0ZXJCcmVhaywgZmluZENvbHVtbiwgY29kZVBvaW50QXQsIGNvdW50Q29sdW1uIH0gZnJvbSAnQGNvZGVtaXJyb3IvdGV4dCc7XG5pbXBvcnQgeyBrZXlOYW1lLCBiYXNlIH0gZnJvbSAndzNjLWtleW5hbWUnO1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24ocm9vdCkge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgLy8gQnJvd3NlcnMgZGlmZmVyIG9uIHdoZXRoZXIgc2hhZG93IHJvb3RzIGhhdmUgYSBnZXRTZWxlY3Rpb25cbiAgICAvLyBtZXRob2QuIElmIGl0IGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZSwgY2FsbCBpdCBvbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICBpZiAocm9vdC5ub2RlVHlwZSA9PSAxMSkgeyAvLyBTaGFkb3cgcm9vdFxuICAgICAgICB0YXJnZXQgPSByb290LmdldFNlbGVjdGlvbiA/IHJvb3QgOiByb290Lm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSByb290O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldFNlbGVjdGlvbigpO1xufVxuZnVuY3Rpb24gY29udGFpbnMoZG9tLCBub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPyBkb20uY29udGFpbnMobm9kZS5ub2RlVHlwZSAhPSAxID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSkgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KCkge1xuICAgIGxldCBlbHQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIHdoaWxlIChlbHQgJiYgZWx0LnNoYWRvd1Jvb3QpXG4gICAgICAgIGVsdCA9IGVsdC5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbihkb20sIHNlbGVjdGlvbikge1xuICAgIGlmICghc2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGaXJlZm94IHdpbGwgcmFpc2UgJ3Blcm1pc3Npb24gZGVuaWVkJyBlcnJvcnMgd2hlbiBhY2Nlc3NpbmdcbiAgICAgICAgLy8gcHJvcGVydGllcyBvZiBgc2VsLmFuY2hvck5vZGVgIHdoZW4gaXQncyBpbiBhIGdlbmVyYXRlZCBDU1NcbiAgICAgICAgLy8gZWxlbWVudC5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zKGRvbSwgc2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xpZW50UmVjdHNGb3IoZG9tKSB7XG4gICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gdGV4dFJhbmdlKGRvbSwgMCwgZG9tLm5vZGVWYWx1ZS5sZW5ndGgpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgIHJldHVybiBkb20uZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBbXTtcbn1cbi8vIFNjYW5zIGZvcndhcmQgYW5kIGJhY2t3YXJkIHRocm91Z2ggRE9NIHBvc2l0aW9ucyBlcXVpdmFsZW50IHRvIHRoZVxuLy8gZ2l2ZW4gb25lIHRvIHNlZSBpZiB0aGUgdHdvIGFyZSBpbiB0aGUgc2FtZSBwbGFjZSAoaS5lLiBhZnRlciBhXG4vLyB0ZXh0IG5vZGUgdnMgYXQgdGhlIGVuZCBvZiB0aGF0IHRleHQgbm9kZSlcbmZ1bmN0aW9uIGlzRXF1aXZhbGVudFBvc2l0aW9uKG5vZGUsIG9mZiwgdGFyZ2V0Tm9kZSwgdGFyZ2V0T2ZmKSB7XG4gICAgcmV0dXJuIHRhcmdldE5vZGUgPyAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKSA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZG9tSW5kZXgobm9kZSkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDs7IGluZGV4KyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZSA9PSB0YXJnZXROb2RlICYmIG9mZiA9PSB0YXJnZXRPZmYpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9mZiA9PSAoZGlyIDwgMCA/IDAgOiBtYXhPZmZzZXQobm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PSBcIkRJVlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBvZmYgPSBkb21JbmRleChub2RlKSArIChkaXIgPCAwID8gMCA6IDEpO1xuICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkTm9kZXNbb2ZmICsgKGRpciA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRpciA8IDAgPyBtYXhPZmZzZXQobm9kZSkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbWF4T2Zmc2V0KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmNvbnN0IFJlY3QwID0geyBsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDAgfTtcbmZ1bmN0aW9uIGZsYXR0ZW5SZWN0KHJlY3QsIGxlZnQpIHtcbiAgICBsZXQgeCA9IGxlZnQgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0O1xuICAgIHJldHVybiB7IGxlZnQ6IHgsIHJpZ2h0OiB4LCB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tIH07XG59XG5mdW5jdGlvbiB3aW5kb3dSZWN0KHdpbikge1xuICAgIHJldHVybiB7IGxlZnQ6IDAsIHJpZ2h0OiB3aW4uaW5uZXJXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IHdpbi5pbm5lckhlaWdodCB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KGRvbSwgcmVjdCwgc2lkZSwgeCwgeSwgeE1hcmdpbiwgeU1hcmdpbiwgbHRyKSB7XG4gICAgbGV0IGRvYyA9IGRvbS5vd25lckRvY3VtZW50LCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7KSB7XG4gICAgICAgIGlmIChjdXIubm9kZVR5cGUgPT0gMSkgeyAvLyBFbGVtZW50XG4gICAgICAgICAgICBsZXQgYm91bmRpbmcsIHRvcCA9IGN1ciA9PSBkb2MuYm9keTtcbiAgICAgICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAgICAgICBib3VuZGluZyA9IHdpbmRvd1JlY3Qod2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXIuc2Nyb2xsSGVpZ2h0IDw9IGN1ci5jbGllbnRIZWlnaHQgJiYgY3VyLnNjcm9sbFdpZHRoIDw9IGN1ci5jbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZWN0ID0gY3VyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgIGJvdW5kaW5nID0geyBsZWZ0OiByZWN0LmxlZnQsIHJpZ2h0OiByZWN0LmxlZnQgKyBjdXIuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBjdXIuY2xpZW50SGVpZ2h0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgICAgICBpZiAoeSA9PSBcIm5lYXJlc3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IC0oYm91bmRpbmcudG9wIC0gcmVjdC50b3AgKyB5TWFyZ2luKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPiAwICYmIHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tICsgbW92ZVkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgbW92ZVkgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IHJlY3QuYm90dG9tIC0gYm91bmRpbmcuYm90dG9tICsgeU1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIChyZWN0LnRvcCAtIG1vdmVZKSA8IGJvdW5kaW5nLnRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgKyBtb3ZlWSAtIHJlY3QudG9wICsgeU1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlY3RIZWlnaHQgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wLCBib3VuZGluZ0hlaWdodCA9IGJvdW5kaW5nLmJvdHRvbSAtIGJvdW5kaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0VG9wID0geSA9PSBcImNlbnRlclwiICYmIHJlY3RIZWlnaHQgPD0gYm91bmRpbmdIZWlnaHQgPyByZWN0LnRvcCArIHJlY3RIZWlnaHQgLyAyIC0gYm91bmRpbmdIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgICAgICAgICAgeSA9PSBcInN0YXJ0XCIgfHwgeSA9PSBcImNlbnRlclwiICYmIHNpZGUgPCAwID8gcmVjdC50b3AgLSB5TWFyZ2luIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3QuYm90dG9tIC0gYm91bmRpbmdIZWlnaHQgKyB5TWFyZ2luO1xuICAgICAgICAgICAgICAgIG1vdmVZID0gdGFyZ2V0VG9wIC0gYm91bmRpbmcudG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHggPT0gXCJuZWFyZXN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgYm91bmRpbmcubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IC0oYm91bmRpbmcubGVmdCAtIHJlY3QubGVmdCArIHhNYXJnaW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZSA+IDAgJiYgcmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0ICsgbW92ZVgpXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IHJlY3QucmlnaHQgLSBib3VuZGluZy5yaWdodCArIG1vdmVYICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVYID0gcmVjdC5yaWdodCAtIGJvdW5kaW5nLnJpZ2h0ICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmIHJlY3QubGVmdCA8IGJvdW5kaW5nLmxlZnQgKyBtb3ZlWClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0ICsgbW92ZVggLSByZWN0LmxlZnQgKyB4TWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGVmdCA9IHggPT0gXCJjZW50ZXJcIiA/IHJlY3QubGVmdCArIChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDIgLSAoYm91bmRpbmcucmlnaHQgLSBib3VuZGluZy5sZWZ0KSAvIDIgOlxuICAgICAgICAgICAgICAgICAgICAoeCA9PSBcInN0YXJ0XCIpID09IGx0ciA/IHJlY3QubGVmdCAtIHhNYXJnaW4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5yaWdodCAtIChib3VuZGluZy5yaWdodCAtIGJvdW5kaW5nLmxlZnQpICsgeE1hcmdpbjtcbiAgICAgICAgICAgICAgICBtb3ZlWCA9IHRhcmdldExlZnQgLSBib3VuZGluZy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgICAgICAgICAgICB3aW4uc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3ZlWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gY3VyLnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWSA9IGN1ci5zY3JvbGxUb3AgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW92ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGN1ci5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnNjcm9sbExlZnQgKz0gbW92ZVg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlWCA9IGN1ci5zY3JvbGxMZWZ0IC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjdCA9IHsgbGVmdDogcmVjdC5sZWZ0IC0gbW92ZVgsIHRvcDogcmVjdC50b3AgLSBtb3ZlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gbW92ZVgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBtb3ZlWSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3ApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjdXIgPSBjdXIuYXNzaWduZWRTbG90IHx8IGN1ci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgeCA9IHkgPSBcIm5lYXJlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXIubm9kZVR5cGUgPT0gMTEpIHsgLy8gQSBzaGFkb3cgcm9vdFxuICAgICAgICAgICAgY3VyID0gY3VyLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIERPTVNlbGVjdGlvblN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBlcShkb21TZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBkb21TZWwuYW5jaG9yTm9kZSAmJiB0aGlzLmFuY2hvck9mZnNldCA9PSBkb21TZWwuYW5jaG9yT2Zmc2V0ICYmXG4gICAgICAgICAgICB0aGlzLmZvY3VzTm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIHRoaXMuZm9jdXNPZmZzZXQgPT0gZG9tU2VsLmZvY3VzT2Zmc2V0O1xuICAgIH1cbiAgICBzZXRSYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLnNldChyYW5nZS5hbmNob3JOb2RlLCByYW5nZS5hbmNob3JPZmZzZXQsIHJhbmdlLmZvY3VzTm9kZSwgcmFuZ2UuZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICBzZXQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgdGhpcy5mb2N1c09mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc3RhY2sucHVzaChjdXIsIGN1ci5zY3JvbGxUb3AsIGN1ci5zY3JvbGxMZWZ0KTtcbiAgICAgICAgaWYgKGN1ciA9PSBjdXIub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZWx0ID0gc3RhY2tbaSsrXSwgdG9wID0gc3RhY2tbaSsrXSwgbGVmdCA9IHN0YWNrW2krK107XG4gICAgICAgICAgICBpZiAoZWx0LnNjcm9sbFRvcCAhPSB0b3ApXG4gICAgICAgICAgICAgICAgZWx0LnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgICAgIGlmIChlbHQuc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBzY3JhdGNoUmFuZ2U7XG5mdW5jdGlvbiB0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgbGV0IHJhbmdlID0gc2NyYXRjaFJhbmdlIHx8IChzY3JhdGNoUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgICByYW5nZS5zZXRFbmQobm9kZSwgdG8pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIGZyb20pO1xuICAgIHJldHVybiByYW5nZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoS2V5KGVsdCwgbmFtZSwgY29kZSkge1xuICAgIGxldCBvcHRpb25zID0geyBrZXk6IG5hbWUsIGNvZGU6IG5hbWUsIGtleUNvZGU6IGNvZGUsIHdoaWNoOiBjb2RlLCBjYW5jZWxhYmxlOiB0cnVlIH07XG4gICAgbGV0IGRvd24gPSBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwgb3B0aW9ucyk7XG4gICAgZG93bi5zeW50aGV0aWMgPSB0cnVlO1xuICAgIGVsdC5kaXNwYXRjaEV2ZW50KGRvd24pO1xuICAgIGxldCB1cCA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgb3B0aW9ucyk7XG4gICAgdXAuc3ludGhldGljID0gdHJ1ZTtcbiAgICBlbHQuZGlzcGF0Y2hFdmVudCh1cCk7XG4gICAgcmV0dXJuIGRvd24uZGVmYXVsdFByZXZlbnRlZCB8fCB1cC5kZWZhdWx0UHJldmVudGVkO1xufVxuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT0gOSB8fCBub2RlLm5vZGVUeXBlID09IDExICYmIG5vZGUuaG9zdCkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbGVhckF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHdoaWxlIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKVxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5vZGUobm9kZS5hdHRyaWJ1dGVzWzBdKTtcbn1cblxuY2xhc3MgRE9NUG9zIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBvZmZzZXQsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnByZWNpc2UgPSBwcmVjaXNlO1xuICAgIH1cbiAgICBzdGF0aWMgYmVmb3JlKGRvbSwgcHJlY2lzZSkgeyByZXR1cm4gbmV3IERPTVBvcyhkb20ucGFyZW50Tm9kZSwgZG9tSW5kZXgoZG9tKSwgcHJlY2lzZSk7IH1cbiAgICBzdGF0aWMgYWZ0ZXIoZG9tLCBwcmVjaXNlKSB7IHJldHVybiBuZXcgRE9NUG9zKGRvbS5wYXJlbnROb2RlLCBkb21JbmRleChkb20pICsgMSwgcHJlY2lzZSk7IH1cbn1cbmNvbnN0IG5vQ2hpbGRyZW4gPSBbXTtcbmNsYXNzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmRvbSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlydHkgPSAyIC8qIE5vZGUgKi87XG4gICAgfVxuICAgIGdldCBlZGl0b3JWaWV3KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWNjZXNzaW5nIHZpZXcgaW4gb3JwaGFuIGNvbnRlbnQgdmlld1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmVkaXRvclZpZXc7XG4gICAgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgZ2V0IHBvc0F0U3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LnBvc0JlZm9yZSh0aGlzKSA6IDA7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3NCZWZvcmUodmlldykge1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3NBdFN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgPT0gdmlldylcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkLmxlbmd0aCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgICB9XG4gICAgcG9zQWZ0ZXIodmlldykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUodmlldykgKyB2aWV3Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gV2lsbCByZXR1cm4gYSByZWN0YW5nbGUgZGlyZWN0bHkgYmVmb3JlICh3aGVuIHNpZGUgPCAwKSwgYWZ0ZXJcbiAgICAvLyAoc2lkZSA+IDApIG9yIGRpcmVjdGx5IG9uICh3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIGl0KSB0aGVcbiAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICBjb29yZHNBdChfcG9zLCBfc2lkZSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHN5bmModHJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgJiAyIC8qIE5vZGUgKi8pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmRvbTtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5kb20gJiYgcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFZpZXcgPSBDb250ZW50Vmlldy5nZXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudFZpZXcgfHwgIWNvbnRlbnRWaWV3LnBhcmVudCAmJiBjb250ZW50Vmlldy5jb25zdHJ1Y3RvciA9PSBjaGlsZC5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZXVzZURPTShwb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN5bmModHJhY2spO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5kaXJ0eSA9IDAgLyogTm90ICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgIXRyYWNrLndyaXR0ZW4gJiYgdHJhY2subm9kZSA9PSBwYXJlbnQgJiYgcG9zICE9IGNoaWxkLmRvbSlcbiAgICAgICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zICYmIHBvcyAhPSBjaGlsZC5kb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBybShwb3MpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBjaGlsZC5kb20ubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLmRvbSwgcG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zICYmIHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gcGFyZW50KVxuICAgICAgICAgICAgICAgIHRyYWNrLndyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHBvcylcbiAgICAgICAgICAgICAgICBwb3MgPSBybShwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlydHkgJiAxIC8qIENoaWxkICovKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zeW5jKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZGlydHkgPSAwIC8qIE5vdCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oX2RvbSkgeyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBsZXQgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMuZG9tLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gbWF4T2Zmc2V0KG5vZGUpID09IDAgPyAwIDogb2Zmc2V0ID09IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoYmlhcyA9PSAwICYmIHBhcmVudC5maXJzdENoaWxkICE9IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgPT0gcGFyZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBiaWFzID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpYXMgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICAgICAgICAgIGFmdGVyID0gbm9kZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZnRlciA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgd2hpbGUgKGFmdGVyICYmICFDb250ZW50Vmlldy5nZXQoYWZ0ZXIpKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGQuZG9tID09IGFmdGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGQubGVuZ3RoICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGZyb21JID0gLTEsIGZyb21TdGFydCA9IC0xLCB0b0kgPSAtMSwgdG9FbmQgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IG9mZnNldCwgcHJldkVuZCA9IG9mZnNldDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IHBvcyArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIGVuZCA+IHRvKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5kb21Cb3VuZHNBcm91bmQoZnJvbSwgdG8sIHBvcyk7XG4gICAgICAgICAgICBpZiAoZW5kID49IGZyb20gJiYgZnJvbUkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBmcm9tSSA9IGk7XG4gICAgICAgICAgICAgICAgZnJvbVN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA+IHRvICYmIGNoaWxkLmRvbS5wYXJlbnROb2RlID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgdG9JID0gaTtcbiAgICAgICAgICAgICAgICB0b0VuZCA9IHByZXZFbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2RW5kID0gZW5kO1xuICAgICAgICAgICAgcG9zID0gZW5kICsgY2hpbGQuYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tOiBmcm9tU3RhcnQsIHRvOiB0b0VuZCA8IDAgPyBvZmZzZXQgKyB0aGlzLmxlbmd0aCA6IHRvRW5kLFxuICAgICAgICAgICAgc3RhcnRET006IChmcm9tSSA/IHRoaXMuY2hpbGRyZW5bZnJvbUkgLSAxXS5kb20ubmV4dFNpYmxpbmcgOiBudWxsKSB8fCB0aGlzLmRvbS5maXJzdENoaWxkLFxuICAgICAgICAgICAgZW5kRE9NOiB0b0kgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiB0b0kgPj0gMCA/IHRoaXMuY2hpbGRyZW5bdG9JXS5kb20gOiBudWxsIH07XG4gICAgfVxuICAgIG1hcmtEaXJ0eShhbmRQYXJlbnQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRpcnR5IHw9IDIgLyogTm9kZSAqLztcbiAgICAgICAgdGhpcy5tYXJrUGFyZW50c0RpcnR5KGFuZFBhcmVudCk7XG4gICAgfVxuICAgIG1hcmtQYXJlbnRzRGlydHkoY2hpbGRMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IHBhcmVudCA9IHRoaXMucGFyZW50OyBwYXJlbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZExpc3QpXG4gICAgICAgICAgICAgICAgcGFyZW50LmRpcnR5IHw9IDIgLyogTm9kZSAqLztcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgJiAxIC8qIENoaWxkICovKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBhcmVudC5kaXJ0eSB8PSAxIC8qIENoaWxkICovO1xuICAgICAgICAgICAgY2hpbGRMaXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT0gcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHRoaXMubWFya1BhcmVudHNEaXJ0eSh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRET00oZG9tKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMuZG9tLmNtVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICBkb20uY21WaWV3ID0gdGhpcztcbiAgICB9XG4gICAgZ2V0IHJvb3RWaWV3KCkge1xuICAgICAgICBmb3IgKGxldCB2ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIHYgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZUNoaWxkcmVuKGZyb20sIHRvLCBjaGlsZHJlbiA9IG5vQ2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIGNoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShmcm9tLCB0byAtIGZyb20sIC4uLmNoaWxkcmVuKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNoaWxkcmVuW2ldLnNldFBhcmVudCh0aGlzKTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oX3JlYykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZ25vcmVFdmVudChfZXZlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgY2hpbGRDdXJzb3IocG9zID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGlsZEN1cnNvcih0aGlzLmNoaWxkcmVuLCBwb3MsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICB9XG4gICAgY2hpbGRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gbmFtZSArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgdGhpcy5jaGlsZHJlbi5qb2luKCkgKyBcIilcIiA6XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA/IFwiW1wiICsgKG5hbWUgPT0gXCJUZXh0XCIgPyB0aGlzLnRleHQgOiB0aGlzLmxlbmd0aCkgKyBcIl1cIiA6IFwiXCIpICtcbiAgICAgICAgICAgICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0KG5vZGUpIHsgcmV0dXJuIG5vZGUuY21WaWV3OyB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGJlY29tZShvdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHRoaXMgaXMgYSB6ZXJvLWxlbmd0aCB2aWV3IHdpdGggYSBzaWRlLCB0aGlzIHNob3VsZCByZXR1cm4gYVxuICAgIC8vIG51bWJlciA8PSAwIHRvIGluZGljYXRlIGl0IGlzIGJlZm9yZSBpdHMgcG9zaXRpb24sIG9yIGFcbiAgICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICAgIGdldFNpZGUoKSB7IHJldHVybiAwOyB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbn1cbkNvbnRlbnRWaWV3LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbi8vIFJlbW92ZSBhIERPTSBub2RlIGFuZCByZXR1cm4gaXRzIG5leHQgc2libGluZy5cbmZ1bmN0aW9uIHJtKGRvbSkge1xuICAgIGxldCBuZXh0ID0gZG9tLm5leHRTaWJsaW5nO1xuICAgIGRvbS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgcmV0dXJuIG5leHQ7XG59XG5jbGFzcyBDaGlsZEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHBvcywgaSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICB0aGlzLm9mZiA9IDA7XG4gICAgfVxuICAgIGZpbmRQb3MocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAocG9zID4gdGhpcy5wb3MgfHwgcG9zID09IHRoaXMucG9zICYmXG4gICAgICAgICAgICAgICAgKGJpYXMgPiAwIHx8IHRoaXMuaSA9PSAwIHx8IHRoaXMuY2hpbGRyZW5bdGhpcy5pIC0gMV0uYnJlYWtBZnRlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZiA9IHBvcyAtIHRoaXMucG9zO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgICAgICAgIHRoaXMucG9zIC09IG5leHQubGVuZ3RoICsgbmV4dC5icmVha0FmdGVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHBhcmVudCwgZnJvbUksIGZyb21PZmYsIHRvSSwgdG9PZmYsIGluc2VydCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gcGFyZW50O1xuICAgIGxldCBiZWZvcmUgPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbltmcm9tSV0gOiBudWxsO1xuICAgIGxldCBsYXN0ID0gaW5zZXJ0Lmxlbmd0aCA/IGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGxldCBicmVha0F0RW5kID0gbGFzdCA/IGxhc3QuYnJlYWtBZnRlciA6IGJyZWFrQXRTdGFydDtcbiAgICAvLyBDaGFuZ2Ugd2l0aGluIGEgc2luZ2xlIGNoaWxkXG4gICAgaWYgKGZyb21JID09IHRvSSAmJiBiZWZvcmUgJiYgIWJyZWFrQXRTdGFydCAmJiAhYnJlYWtBdEVuZCAmJiBpbnNlcnQubGVuZ3RoIDwgMiAmJlxuICAgICAgICBiZWZvcmUubWVyZ2UoZnJvbU9mZiwgdG9PZmYsIGluc2VydC5sZW5ndGggPyBsYXN0IDogbnVsbCwgZnJvbU9mZiA9PSAwLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHRvSSA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSBjaGlsZHJlblt0b0ldO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGVuZCBvZiB0aGUgY2hpbGQgYWZ0ZXIgdGhlIHVwZGF0ZSBpcyBwcmVzZXJ2ZWQgaW4gYGFmdGVyYFxuICAgICAgICBpZiAoYWZ0ZXIgJiYgdG9PZmYgPCBhZnRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHNwbGl0dGluZyBhIGNoaWxkLCBzZXBhcmF0ZSBwYXJ0IG9mIGl0IHRvIGF2b2lkIHRoYXRcbiAgICAgICAgICAgIC8vIGJlaW5nIG1hbmdsZWQgd2hlbiB1cGRhdGluZyB0aGUgY2hpbGQgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICAgICAgICBpZiAoZnJvbUkgPT0gdG9JKSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5zcGxpdCh0b09mZik7XG4gICAgICAgICAgICAgICAgdG9PZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgYWZ0ZXIgdGhlIHJlcGxhY2VtZW50IHNob3VsZCBiZSBtZXJnZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgcmVwbGFjaW5nIGVsZW1lbnQsIHVwZGF0ZSBgY29udGVudGBcbiAgICAgICAgICAgIGlmICghYnJlYWtBdEVuZCAmJiBsYXN0ICYmIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBsYXN0LCB0cnVlLCAwLCBvcGVuRW5kKSkge1xuICAgICAgICAgICAgICAgIGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0gPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc3RhcnQgb2YgdGhlIGFmdGVyIGVsZW1lbnQsIGlmIG5lY2Vzc2FyeSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gYWRkIGl0IHRvIGBjb250ZW50YC5cbiAgICAgICAgICAgICAgICBpZiAodG9PZmYpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLm1lcmdlKDAsIHRvT2ZmLCBudWxsLCBmYWxzZSwgMCwgb3BlbkVuZCk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0LnB1c2goYWZ0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFmdGVyID09PSBudWxsIHx8IGFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhZnRlci5icmVha0FmdGVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWxlbWVudCBhdCBgdG9JYCBpcyBlbnRpcmVseSBjb3ZlcmVkIGJ5IHRoaXMgcmFuZ2UuXG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBpdHMgbGluZSBicmVhaywgaWYgYW55LlxuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgbGFzdC5icmVha0FmdGVyID0gMTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVha0F0U3RhcnQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3ZlIGhhbmRsZWQgdGhlIG5leHQgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnRzXG4gICAgICAgIC8vIG5vdywgbWFrZSBzdXJlIGB0b0lgIHBvaW50cyBhZnRlciB0aGF0LlxuICAgICAgICB0b0krKztcbiAgICB9XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBiZWZvcmUuYnJlYWtBZnRlciA9IGJyZWFrQXRTdGFydDtcbiAgICAgICAgaWYgKGZyb21PZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIWJyZWFrQXRTdGFydCAmJiBpbnNlcnQubGVuZ3RoICYmIGJlZm9yZS5tZXJnZShmcm9tT2ZmLCBiZWZvcmUubGVuZ3RoLCBpbnNlcnRbMF0sIGZhbHNlLCBvcGVuU3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLmJyZWFrQWZ0ZXIgPSBpbnNlcnQuc2hpZnQoKS5icmVha0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZnJvbU9mZiA8IGJlZm9yZS5sZW5ndGggfHwgYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAmJiBiZWZvcmUuY2hpbGRyZW5bYmVmb3JlLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlLm1lcmdlKGZyb21PZmYsIGJlZm9yZS5sZW5ndGgsIG51bGwsIGZhbHNlLCBvcGVuU3RhcnQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJvbUkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUcnkgdG8gbWVyZ2Ugd2lkZ2V0cyBvbiB0aGUgYm91bmRhcmllcyBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICB3aGlsZSAoZnJvbUkgPCB0b0kgJiYgaW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoY2hpbGRyZW5bdG9JIC0gMV0uYmVjb21lKGluc2VydFtpbnNlcnQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB0b0ktLTtcbiAgICAgICAgICAgIGluc2VydC5wb3AoKTtcbiAgICAgICAgICAgIG9wZW5FbmQgPSBpbnNlcnQubGVuZ3RoID8gMCA6IG9wZW5TdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltmcm9tSV0uYmVjb21lKGluc2VydFswXSkpIHtcbiAgICAgICAgICAgIGZyb21JKys7XG4gICAgICAgICAgICBpbnNlcnQuc2hpZnQoKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCA9IGluc2VydC5sZW5ndGggPyAwIDogb3BlbkVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaW5zZXJ0Lmxlbmd0aCAmJiBmcm9tSSAmJiB0b0kgPCBjaGlsZHJlbi5sZW5ndGggJiYgIWNoaWxkcmVuW2Zyb21JIC0gMV0uYnJlYWtBZnRlciAmJlxuICAgICAgICBjaGlsZHJlblt0b0ldLm1lcmdlKDAsIDAsIGNoaWxkcmVuW2Zyb21JIC0gMV0sIGZhbHNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpKVxuICAgICAgICBmcm9tSS0tO1xuICAgIGlmIChmcm9tSSA8IHRvSSB8fCBpbnNlcnQubGVuZ3RoKVxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkcmVuKGZyb21JLCB0b0ksIGluc2VydCk7XG59XG5mdW5jdGlvbiBtZXJnZUNoaWxkcmVuSW50byhwYXJlbnQsIGZyb20sIHRvLCBpbnNlcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGxldCBjdXIgPSBwYXJlbnQuY2hpbGRDdXJzb3IoKTtcbiAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1ci5maW5kUG9zKHRvLCAxKTtcbiAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXIuZmluZFBvcyhmcm9tLCAtMSk7XG4gICAgbGV0IGRMZW4gPSBmcm9tIC0gdG87XG4gICAgZm9yIChsZXQgdmlldyBvZiBpbnNlcnQpXG4gICAgICAgIGRMZW4gKz0gdmlldy5sZW5ndGg7XG4gICAgcGFyZW50Lmxlbmd0aCArPSBkTGVuO1xuICAgIHJlcGxhY2VSYW5nZShwYXJlbnQsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBpbnNlcnQsIDAsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbmxldCBbbmF2LCBkb2NdID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiXG4gICAgPyBbbmF2aWdhdG9yLCBkb2N1bWVudF1cbiAgICA6IFt7IHVzZXJBZ2VudDogXCJcIiwgdmVuZG9yOiBcIlwiLCBwbGF0Zm9ybTogXCJcIiB9LCB7IGRvY3VtZW50RWxlbWVudDogeyBzdHlsZToge30gfSB9XTtcbmNvbnN0IGllX2VkZ2UgPSAvKkBfX1BVUkVfXyovL0VkZ2VcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvKkBfX1BVUkVfXyovL01TSUUgXFxkLy50ZXN0KG5hdi51c2VyQWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC8qQF9fUFVSRV9fKi8vVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgZ2Vja28gPSAhaWUgJiYgLypAX19QVVJFX18qLy9nZWNrb1xcLyhcXGQrKS9pLnRlc3QobmF2LnVzZXJBZ2VudCk7XG5jb25zdCBjaHJvbWUgPSAhaWUgJiYgLypAX19QVVJFX18qLy9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCk7XG5jb25zdCB3ZWJraXQgPSBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgc2FmYXJpID0gIWllICYmIC8qQF9fUFVSRV9fKi8vQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2LnZlbmRvcik7XG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC8qQF9fUFVSRV9fKi8vTW9iaWxlXFwvXFx3Ky8udGVzdChuYXYudXNlckFnZW50KSB8fCBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbnZhciBicm93c2VyID0ge1xuICAgIG1hYzogaW9zIHx8IC8qQF9fUFVSRV9fKi8vTWFjLy50ZXN0KG5hdi5wbGF0Zm9ybSksXG4gICAgd2luZG93czogLypAX19QVVJFX18qLy9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBsaW51eDogLypAX19QVVJFX18qLy9MaW51eHxYMTEvLnRlc3QobmF2LnBsYXRmb3JtKSxcbiAgICBpZSxcbiAgICBpZV92ZXJzaW9uOiBpZV91cHRvMTAgPyBkb2MuZG9jdW1lbnRNb2RlIHx8IDYgOiBpZV8xMXVwID8gK2llXzExdXBbMV0gOiBpZV9lZGdlID8gK2llX2VkZ2VbMV0gOiAwLFxuICAgIGdlY2tvLFxuICAgIGdlY2tvX3ZlcnNpb246IGdlY2tvID8gKygvKkBfX1BVUkVfXyovL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMobmF2LnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgY2hyb21lOiAhIWNocm9tZSxcbiAgICBjaHJvbWVfdmVyc2lvbjogY2hyb21lID8gK2Nocm9tZVsxXSA6IDAsXG4gICAgaW9zLFxuICAgIGFuZHJvaWQ6IC8qQF9fUFVSRV9fKi8vQW5kcm9pZFxcYi8udGVzdChuYXYudXNlckFnZW50KSxcbiAgICB3ZWJraXQsXG4gICAgc2FmYXJpLFxuICAgIHdlYmtpdF92ZXJzaW9uOiB3ZWJraXQgPyArKC8qQF9fUFVSRV9fKi8vXFxiQXBwbGVXZWJLaXRcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsIDBdKVsxXSA6IDAsXG4gICAgdGFiU2l6ZTogZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZS50YWJTaXplICE9IG51bGwgPyBcInRhYi1zaXplXCIgOiBcIi1tb3otdGFiLXNpemVcIlxufTtcblxuY29uc3QgTWF4Sm9pbkxlbiA9IDI1NjtcbmNsYXNzIFRleHRWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBjcmVhdGVET00odGV4dERPTSkge1xuICAgICAgICB0aGlzLnNldERPTSh0ZXh0RE9NIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBzeW5jKHRyYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20pXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURPTSgpO1xuICAgICAgICBpZiAodGhpcy5kb20ubm9kZVZhbHVlICE9IHRoaXMudGV4dCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrICYmIHRyYWNrLm5vZGUgPT0gdGhpcy5kb20pXG4gICAgICAgICAgICAgICAgdHJhY2sud3JpdHRlbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRvbS5ub2RlVmFsdWUgPSB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV1c2VET00oZG9tKSB7XG4gICAgICAgIGlmIChkb20ubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRE9NKGRvbSk7XG4gICAgfVxuICAgIG1lcmdlKGZyb20sIHRvLCBzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBUZXh0VmlldykgfHwgdGhpcy5sZW5ndGggLSAodG8gLSBmcm9tKSArIHNvdXJjZS5sZW5ndGggPiBNYXhKb2luTGVuKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGhpcy50ZXh0LnNsaWNlKDAsIGZyb20pICsgKHNvdXJjZSA/IHNvdXJjZS50ZXh0IDogXCJcIikgKyB0aGlzLnRleHQuc2xpY2UodG8pO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoZnJvbSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFRleHRWaWV3KHRoaXMudGV4dC5zbGljZShmcm9tKSk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBmcm9tKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKG5vZGUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbm9kZSA9PSB0aGlzLmRvbSA/IG9mZnNldCA6IG9mZnNldCA/IHRoaXMudGV4dC5sZW5ndGggOiAwO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHsgcmV0dXJuIG5ldyBET01Qb3ModGhpcy5kb20sIHBvcyk7IH1cbiAgICBkb21Cb3VuZHNBcm91bmQoX2Zyb20sIF90bywgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IGZyb206IG9mZnNldCwgdG86IG9mZnNldCArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29vcmRzKHRoaXMuZG9tLCBwb3MsIHNpZGUpO1xuICAgIH1cbn1cbmNsYXNzIE1hcmtWaWV3IGV4dGVuZHMgQ29udGVudFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKG1hcmssIGNoaWxkcmVuID0gW10sIGxlbmd0aCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgY2ggb2YgY2hpbGRyZW4pXG4gICAgICAgICAgICBjaC5zZXRQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHNldEF0dHJzKGRvbSkge1xuICAgICAgICBjbGVhckF0dHJpYnV0ZXMoZG9tKTtcbiAgICAgICAgaWYgKHRoaXMubWFyay5jbGFzcylcbiAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3M7XG4gICAgICAgIGlmICh0aGlzLm1hcmsuYXR0cnMpXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlKG5hbWUsIHRoaXMubWFyay5hdHRyc1tuYW1lXSk7XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIHJldXNlRE9NKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT0gdGhpcy5tYXJrLnRhZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00obm9kZSk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5IHw9IDQgLyogQXR0cnMgKi8gfCAyIC8qIE5vZGUgKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3luYyh0cmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy5zZXRBdHRycyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubWFyay50YWdOYW1lKSkpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcnR5ICYgNCAvKiBBdHRycyAqLylcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cnModGhpcy5kb20pO1xuICAgICAgICBzdXBlci5zeW5jKHRyYWNrKTtcbiAgICB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgX2hhc1N0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiAoIShzb3VyY2UgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBzb3VyY2UubWFyay5lcSh0aGlzLm1hcmspKSB8fFxuICAgICAgICAgICAgKGZyb20gJiYgb3BlblN0YXJ0IDw9IDApIHx8ICh0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBtZXJnZUNoaWxkcmVuSW50byh0aGlzLCBmcm9tLCB0bywgc291cmNlID8gc291cmNlLmNoaWxkcmVuIDogW10sIG9wZW5TdGFydCAtIDEsIG9wZW5FbmQgLSAxKTtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNwbGl0KGZyb20pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBvZmYgPSAwLCBkZXRhY2hGcm9tID0gLTEsIGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBlbHQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgbGV0IGVuZCA9IG9mZiArIGVsdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvZmYgPCBmcm9tID8gZWx0LnNwbGl0KGZyb20gLSBvZmYpIDogZWx0KTtcbiAgICAgICAgICAgIGlmIChkZXRhY2hGcm9tIDwgMCAmJiBvZmYgPj0gZnJvbSlcbiAgICAgICAgICAgICAgICBkZXRhY2hGcm9tID0gaTtcbiAgICAgICAgICAgIG9mZiA9IGVuZDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5sZW5ndGggLSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGZyb207XG4gICAgICAgIGlmIChkZXRhY2hGcm9tID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gZGV0YWNoRnJvbTtcbiAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlldyh0aGlzLm1hcmssIHJlc3VsdCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBpbmxpbmVET01BdFBvcyh0aGlzLmRvbSwgdGhpcy5jaGlsZHJlbiwgcG9zKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIHJldHVybiBjb29yZHNJbkNoaWxkcmVuKHRoaXMsIHBvcywgc2lkZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dENvb3Jkcyh0ZXh0LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgbGVuZ3RoID0gdGV4dC5ub2RlVmFsdWUubGVuZ3RoO1xuICAgIGlmIChwb3MgPiBsZW5ndGgpXG4gICAgICAgIHBvcyA9IGxlbmd0aDtcbiAgICBsZXQgZnJvbSA9IHBvcywgdG8gPSBwb3MsIGZsYXR0ZW4gPSAwO1xuICAgIGlmIChwb3MgPT0gMCAmJiBzaWRlIDwgMCB8fCBwb3MgPT0gbGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICBpZiAoIShicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmdlY2tvKSkgeyAvLyBUaGVzZSBicm93c2VycyByZWxpYWJseSByZXR1cm4gdmFsaWQgcmVjdGFuZ2xlcyBmb3IgZW1wdHkgcmFuZ2VzXG4gICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAxO1xuICAgICAgICAgICAgfSAvLyBGSVhNRSB0aGlzIGlzIHdyb25nIGluIFJUTCB0ZXh0XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIGZsYXR0ZW4gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHNpZGUgPCAwKVxuICAgICAgICAgICAgZnJvbS0tO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0bysrO1xuICAgIH1cbiAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2UodGV4dCwgZnJvbSwgdG8pLmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBSZWN0MDtcbiAgICBsZXQgcmVjdCA9IHJlY3RzWyhmbGF0dGVuID8gZmxhdHRlbiA8IDAgOiBzaWRlID49IDApID8gMCA6IHJlY3RzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiAhZmxhdHRlbiAmJiByZWN0LndpZHRoID09IDApXG4gICAgICAgIHJlY3QgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKHJlY3RzLCByID0+IHIud2lkdGgpIHx8IHJlY3Q7XG4gICAgcmV0dXJuIGZsYXR0ZW4gPyBmbGF0dGVuUmVjdChyZWN0LCBmbGF0dGVuIDwgMCkgOiByZWN0IHx8IG51bGw7XG59XG4vLyBBbHNvIHVzZWQgZm9yIGNvbGxhcHNlZCByYW5nZXMgdGhhdCBkb24ndCBoYXZlIGEgcGxhY2Vob2xkZXIgd2lkZ2V0IVxuY2xhc3MgV2lkZ2V0VmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWRnZXQsIGxlbmd0aCwgc2lkZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUod2lkZ2V0LCBsZW5ndGgsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyAod2lkZ2V0LmN1c3RvbVZpZXcgfHwgV2lkZ2V0Vmlldykod2lkZ2V0LCBsZW5ndGgsIHNpZGUpO1xuICAgIH1cbiAgICBzcGxpdChmcm9tKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBXaWRnZXRWaWV3LmNyZWF0ZSh0aGlzLndpZGdldCwgdGhpcy5sZW5ndGggLSBmcm9tLCB0aGlzLnNpZGUpO1xuICAgICAgICB0aGlzLmxlbmd0aCAtPSBmcm9tO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20pKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSh0aGlzLmVkaXRvclZpZXcpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaWRlKCkgeyByZXR1cm4gdGhpcy5zaWRlOyB9XG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIFdpZGdldFZpZXcpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHNvdXJjZS53aWRnZXQpIHx8XG4gICAgICAgICAgICBmcm9tID4gMCAmJiBvcGVuU3RhcnQgPD0gMCB8fCB0byA8IHRoaXMubGVuZ3RoICYmIG9wZW5FbmQgPD0gMCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gZnJvbSArIChzb3VyY2UgPyBzb3VyY2UubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSB0byk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBiZWNvbWUob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyLmxlbmd0aCA9PSB0aGlzLmxlbmd0aCAmJiBvdGhlciBpbnN0YW5jZW9mIFdpZGdldFZpZXcgJiYgb3RoZXIuc2lkZSA9PSB0aGlzLnNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA9PSBvdGhlci53aWRnZXQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2lkZ2V0LmVxKG90aGVyLndpZGdldCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMud2lkZ2V0ID0gb3RoZXIud2lkZ2V0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgaWdub3JlRXZlbnQoZXZlbnQpIHsgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGV2ZW50KTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFRleHQuZW1wdHk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodG9wLnBhcmVudClcbiAgICAgICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICAgIGxldCB2aWV3ID0gdG9wLmVkaXRvclZpZXcsIHRleHQgPSB2aWV3ICYmIHZpZXcuc3RhdGUuZG9jLCBzdGFydCA9IHRoaXMucG9zQXRTdGFydDtcbiAgICAgICAgcmV0dXJuIHRleHQgPyB0ZXh0LnNsaWNlKHN0YXJ0LCBzdGFydCArIHRoaXMubGVuZ3RoKSA6IFRleHQuZW1wdHk7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcywgc2lkZSkge1xuICAgICAgICBsZXQgcmVjdHMgPSB0aGlzLmRvbS5nZXRDbGllbnRSZWN0cygpLCByZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFyZWN0cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUmVjdDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3MgPiAwID8gcmVjdHMubGVuZ3RoIC0gMSA6IDA7OyBpICs9IChwb3MgPiAwID8gLTEgOiAxKSkge1xuICAgICAgICAgICAgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICAgICAgaWYgKHBvcyA+IDAgPyBpID09IDAgOiBpID09IHJlY3RzLmxlbmd0aCAtIDEgfHwgcmVjdC50b3AgPCByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHBvcyA9PSAwICYmIHNpZGUgPiAwIHx8IHBvcyA9PSB0aGlzLmxlbmd0aCAmJiBzaWRlIDw9IDApID8gcmVjdCA6IGZsYXR0ZW5SZWN0KHJlY3QsIHBvcyA9PSAwKTtcbiAgICB9XG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy53aWRnZXQuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zaXRpb25WaWV3IGV4dGVuZHMgV2lkZ2V0VmlldyB7XG4gICAgZG9tQXRQb3MocG9zKSB7IHJldHVybiBuZXcgRE9NUG9zKHRoaXMud2lkZ2V0LnRleHQsIHBvcyk7IH1cbiAgICBzeW5jKCkgeyB0aGlzLnNldERPTSh0aGlzLndpZGdldC50b0RPTSgpKTsgfVxuICAgIGxvY2FsUG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICFvZmZzZXQgPyAwIDogbm9kZS5ub2RlVHlwZSA9PSAzID8gTWF0aC5taW4ob2Zmc2V0LCB0aGlzLmxlbmd0aCkgOiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGdldCBvdmVycmlkZURPTVRleHQoKSB7IHJldHVybiBudWxsOyB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7IHJldHVybiB0ZXh0Q29vcmRzKHRoaXMud2lkZ2V0LnRleHQsIHBvcywgc2lkZSk7IH1cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8vIFVzZSB0d28gY2hhcmFjdGVycyBvbiBBbmRyb2lkLCB0byBwcmV2ZW50IENocm9tZSBmcm9tIGNsb3NpbmcgdGhlXG4vLyB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gYmFja3NwYWNpbmcgYWZ0ZXIgYSB3aWRnZXQgKCM2MDIpLlxuY29uc3QgWmVyb1dpZHRoU3BhY2UgPSBicm93c2VyLmFuZHJvaWQgPyBcIlxcdTIwMGJcXHUyMDBiXCIgOiBcIlxcdTIwMGJcIjtcbi8vIFRoZXNlIGFyZSBkcmF3biBhcm91bmQgdW5lZGl0YWJsZSB3aWRnZXRzIHRvIGF2b2lkIGEgbnVtYmVyIG9mXG4vLyBicm93c2VyIGJ1Z3MgdGhhdCBzaG93IHVwIHdoZW4gdGhlIGN1cnNvciBpcyBkaXJlY3RseSBuZXh0IHRvXG4vLyB1bmVkaXRhYmxlIGlubGluZSBjb250ZW50LlxuY2xhc3MgV2lkZ2V0QnVmZmVyVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcihzaWRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiAwOyB9XG4gICAgbWVyZ2UoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBXaWRnZXRCdWZmZXJWaWV3ICYmIG90aGVyLnNpZGUgPT0gdGhpcy5zaWRlO1xuICAgIH1cbiAgICBzcGxpdCgpIHsgcmV0dXJuIG5ldyBXaWRnZXRCdWZmZXJWaWV3KHRoaXMuc2lkZSk7IH1cbiAgICBzeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgdGhpcy5zZXRET00oZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoWmVyb1dpZHRoU3BhY2UpKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXJ0eSAmJiB0aGlzLmRvbS5ub2RlVmFsdWUgIT0gWmVyb1dpZHRoU3BhY2UpXG4gICAgICAgICAgICB0aGlzLmRvbS5ub2RlVmFsdWUgPSBaZXJvV2lkdGhTcGFjZTtcbiAgICB9XG4gICAgZ2V0U2lkZSgpIHsgcmV0dXJuIHRoaXMuc2lkZTsgfVxuICAgIGRvbUF0UG9zKHBvcykgeyByZXR1cm4gRE9NUG9zLmJlZm9yZSh0aGlzLmRvbSk7IH1cbiAgICBsb2NhbFBvc0Zyb21ET00oKSB7IHJldHVybiAwOyB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGNvb3Jkc0F0KHBvcykge1xuICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0Zvcih0aGlzLmRvbSk7XG4gICAgICAgIHJldHVybiByZWN0c1tyZWN0cy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgICAgICByZXR1cm4gVGV4dC5vZihbdGhpcy5kb20ubm9kZVZhbHVlLnJlcGxhY2UoL1xcdTIwMGIvZywgXCJcIildKTtcbiAgICB9XG59XG5UZXh0Vmlldy5wcm90b3R5cGUuY2hpbGRyZW4gPSBXaWRnZXRWaWV3LnByb3RvdHlwZS5jaGlsZHJlbiA9IFdpZGdldEJ1ZmZlclZpZXcucHJvdG90eXBlLmNoaWxkcmVuID0gbm9DaGlsZHJlbjtcbmZ1bmN0aW9uIGlubGluZURPTUF0UG9zKGRvbSwgY2hpbGRyZW4sIHBvcykge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBvZmYgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV0sIGVuZCA9IG9mZiArIGNoaWxkLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZCA9PSBvZmYgJiYgY2hpbGQuZ2V0U2lkZSgpIDw9IDApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHBvcyA+IG9mZiAmJiBwb3MgPCBlbmQgJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gZG9tKVxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRvbUF0UG9zKHBvcyAtIG9mZik7XG4gICAgICAgIGlmIChwb3MgPD0gb2ZmKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG9mZiA9IGVuZDtcbiAgICB9XG4gICAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSA9IGNoaWxkcmVuW2kgLSAxXS5kb207XG4gICAgICAgIGlmIChiZWZvcmUucGFyZW50Tm9kZSA9PSBkb20pXG4gICAgICAgICAgICByZXR1cm4gRE9NUG9zLmFmdGVyKGJlZm9yZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRE9NUG9zKGRvbSwgMCk7XG59XG4vLyBBc3N1bWVzIGB2aWV3YCwgaWYgYSBtYXJrIHZpZXcsIGhhcyBwcmVjaXNlbHkgMSBjaGlsZC5cbmZ1bmN0aW9uIGpvaW5JbmxpbmVJbnRvKHBhcmVudCwgdmlldywgb3Blbikge1xuICAgIGxldCBsYXN0LCB7IGNoaWxkcmVuIH0gPSBwYXJlbnQ7XG4gICAgaWYgKG9wZW4gPiAwICYmIHZpZXcgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBjaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBNYXJrVmlldyAmJiBsYXN0Lm1hcmsuZXEodmlldy5tYXJrKSkge1xuICAgICAgICBqb2luSW5saW5lSW50byhsYXN0LCB2aWV3LmNoaWxkcmVuWzBdLCBvcGVuIC0gMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHZpZXcpO1xuICAgICAgICB2aWV3LnNldFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgICBwYXJlbnQubGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xufVxuZnVuY3Rpb24gY29vcmRzSW5DaGlsZHJlbih2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBmb3IgKGxldCBvZmYgPSAwLCBpID0gMDsgaSA8IHZpZXcuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgY2hpbGQubGVuZ3RoLCBuZXh0O1xuICAgICAgICBpZiAoKHNpZGUgPD0gMCB8fCBlbmQgPT0gdmlldy5sZW5ndGggfHwgY2hpbGQuZ2V0U2lkZSgpID4gMCA/IGVuZCA+PSBwb3MgOiBlbmQgPiBwb3MpICYmXG4gICAgICAgICAgICAocG9zIDwgZW5kIHx8IGkgKyAxID09IHZpZXcuY2hpbGRyZW4ubGVuZ3RoIHx8IChuZXh0ID0gdmlldy5jaGlsZHJlbltpICsgMV0pLmxlbmd0aCB8fCBuZXh0LmdldFNpZGUoKSA+IDApKSB7XG4gICAgICAgICAgICBsZXQgZmxhdHRlbiA9IDA7XG4gICAgICAgICAgICBpZiAoZW5kID09IG9mZikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5nZXRTaWRlKCkgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZmxhdHRlbiA9IHNpZGUgPSAtY2hpbGQuZ2V0U2lkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlY3QgPSBjaGlsZC5jb29yZHNBdChwb3MgLSBvZmYsIHNpZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW4gJiYgcmVjdCA/IGZsYXR0ZW5SZWN0KHJlY3QsIHNpZGUgPCAwKSA6IHJlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmID0gZW5kO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IHZpZXcuZG9tLmxhc3RDaGlsZDtcbiAgICBpZiAoIWxhc3QpXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihsYXN0KTtcbiAgICByZXR1cm4gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tYmluZUF0dHJzKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJjbGFzc1wiICYmIHRhcmdldC5jbGFzcylcbiAgICAgICAgICAgIHRhcmdldC5jbGFzcyArPSBcIiBcIiArIHNvdXJjZS5jbGFzcztcbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIgJiYgdGFyZ2V0LnN0eWxlKVxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlICs9IFwiO1wiICsgc291cmNlLnN0eWxlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBhdHRyc0VxKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWEgfHwgIWIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQga2V5c0EgPSBPYmplY3Qua2V5cyhhKSwga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICBpZiAoa2V5c0EubGVuZ3RoICE9IGtleXNCLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzQSkge1xuICAgICAgICBpZiAoa2V5c0IuaW5kZXhPZihrZXkpID09IC0xIHx8IGFba2V5XSAhPT0gYltrZXldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzKGRvbSwgcHJldiwgYXR0cnMpIHtcbiAgICBpZiAocHJldilcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBwcmV2KVxuICAgICAgICAgICAgaWYgKCEoYXR0cnMgJiYgbmFtZSBpbiBhdHRycykpXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICBpZiAoYXR0cnMpXG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpXG4gICAgICAgICAgICBpZiAoIShwcmV2ICYmIHByZXZbbmFtZV0gPT0gYXR0cnNbbmFtZV0pKVxuICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xufVxuXG4vKipcbldpZGdldHMgYWRkZWQgdG8gdGhlIGNvbnRlbnQgYXJlIGRlc2NyaWJlZCBieSBzdWJjbGFzc2VzIG9mIHRoaXNcbmNsYXNzLiBVc2luZyBhIGRlc2NyaXB0aW9uIG9iamVjdCBsaWtlIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG9cbmRlbGF5IGNyZWF0aW5nIG9mIHRoZSBET00gc3RydWN0dXJlIGZvciBhIHdpZGdldCB1bnRpbCBpdCBpc1xubmVlZGVkLCBhbmQgdG8gYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgZXZlbiB3aGVuIHRoZSBkZWNvcmF0aW9uc1xudGhhdCBkZWZpbmUgdGhlbSBhcmUgcmVjcmVhdGVkLlxuKi9cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIC8qKlxuICAgIENvbXBhcmUgdGhpcyBpbnN0YW5jZSB0byBhbm90aGVyIGluc3RhbmNlIG9mIHRoZSBzYW1lIHR5cGUuXG4gICAgKFR5cGVTY3JpcHQgY2FuJ3QgZXhwcmVzcyB0aGlzLCBidXQgb25seSBpbnN0YW5jZXMgb2YgdGhlIHNhbWVcbiAgICBzcGVjaWZpYyBjbGFzcyB3aWxsIGJlIHBhc3NlZCB0byB0aGlzIG1ldGhvZC4pIFRoaXMgaXMgdXNlZCB0b1xuICAgIGF2b2lkIHJlZHJhd2luZyB3aWRnZXRzIHdoZW4gdGhleSBhcmUgcmVwbGFjZWQgYnkgYSBuZXdcbiAgICBkZWNvcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3RcbiAgICByZXR1cm5zIGBmYWxzZWAsIHdoaWNoIHdpbGwgY2F1c2UgbmV3IGluc3RhbmNlcyBvZiB0aGUgd2lkZ2V0IHRvXG4gICAgYWx3YXlzIGJlIHJlZHJhd24uXG4gICAgKi9cbiAgICBlcShfd2lkZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSBhIERPTSBlbGVtZW50IGNyZWF0ZWQgYnkgYSB3aWRnZXQgb2YgdGhlIHNhbWUgdHlwZSAoYnV0XG4gICAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gICAgdHJ1ZSB0byBpbmRpY2F0ZSB0aGF0IGl0IGNvdWxkIHVwZGF0ZSwgZmFsc2UgdG8gaW5kaWNhdGUgaXRcbiAgICBjb3VsZG4ndCAoaW4gd2hpY2ggY2FzZSB0aGUgd2lkZ2V0IHdpbGwgYmUgcmVkcmF3bikuIFRoZSBkZWZhdWx0XG4gICAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAgICovXG4gICAgdXBkYXRlRE9NKF9kb20pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXJlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29uc3RydWN0b3IgPT0gb3RoZXIuY29uc3RydWN0b3IgJiYgdGhpcy5lcShvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gICAgZXN0aW1hdGluZyB0aGUgaGVpZ2h0IG9mIGNvbnRlbnQgdGhhdCBoYXNuJ3QgYmVlbiBkcmF3bi4gTWF5XG4gICAgcmV0dXJuIC0xIHRvIGluZGljYXRlIHlvdSBkb24ndCBrbm93LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgIHJldHVybnMgLTEuXG4gICAgKi9cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gLTE7IH1cbiAgICAvKipcbiAgICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gICAgc2hvdWxkIGJlIGlnbm9yZWQgYnkgdGhlIGVkaXRvci4gVGhlIGRlZmF1bHQgaXMgdG8gaWdub3JlIGFsbFxuICAgIGV2ZW50cy5cbiAgICAqL1xuICAgIGlnbm9yZUV2ZW50KF9ldmVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGN1c3RvbVZpZXcoKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHdpZGdldCBpcyByZW1vdmVkXG4gICAgZnJvbSB0aGUgZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBkZXN0cm95KF9kb20pIHsgfVxufVxuLyoqXG5UaGUgZGlmZmVyZW50IHR5cGVzIG9mIGJsb2NrcyB0aGF0IGNhbiBvY2N1ciBpbiBhbiBlZGl0b3Igdmlldy5cbiovXG52YXIgQmxvY2tUeXBlID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoQmxvY2tUeXBlKSB7XG4gICAgLyoqXG4gICAgQSBsaW5lIG9mIHRleHQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiVGV4dFwiXSA9IDBdID0gXCJUZXh0XCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBhZnRlciBpdC5cbiAgICAqL1xuICAgIEJsb2NrVHlwZVtCbG9ja1R5cGVbXCJXaWRnZXRCZWZvcmVcIl0gPSAxXSA9IFwiV2lkZ2V0QmVmb3JlXCI7XG4gICAgLyoqXG4gICAgQSBibG9jayB3aWRnZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBwb3NpdGlvbiBiZWZvcmUgaXQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0QWZ0ZXJcIl0gPSAyXSA9IFwiV2lkZ2V0QWZ0ZXJcIjtcbiAgICAvKipcbiAgICBBIGJsb2NrIHdpZGdldCBbcmVwbGFjaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbl5yZXBsYWNlKSBhIHJhbmdlIG9mIGNvbnRlbnQuXG4gICAgKi9cbiAgICBCbG9ja1R5cGVbQmxvY2tUeXBlW1wiV2lkZ2V0UmFuZ2VcIl0gPSAzXSA9IFwiV2lkZ2V0UmFuZ2VcIjtcbnJldHVybiBCbG9ja1R5cGV9KShCbG9ja1R5cGUgfHwgKEJsb2NrVHlwZSA9IHt9KSk7XG4vKipcbkEgZGVjb3JhdGlvbiBwcm92aWRlcyBpbmZvcm1hdGlvbiBvbiBob3cgdG8gZHJhdyBvciBzdHlsZSBhIHBpZWNlXG5vZiBjb250ZW50LiBZb3UnbGwgdXN1YWxseSB1c2UgaXQgd3JhcHBlZCBpbiBhXG5bYFJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNyYW5nZXNldC5SYW5nZSksIHdoaWNoIGFkZHMgYSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uLlxuKi9cbmNsYXNzIERlY29yYXRpb24gZXh0ZW5kcyBSYW5nZVZhbHVlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhcnRTaWRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVuZFNpZGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgd2lkZ2V0LCBcbiAgICAvKipcbiAgICBUaGUgY29uZmlnIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRlY29yYXRpb24uIFlvdSBjYW5cbiAgICBpbmNsdWRlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBpbiB0aGVyZSB0byBzdG9yZSBtZXRhZGF0YSBhYm91dFxuICAgIHlvdXIgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFNpZGUgPSBzdGFydFNpZGU7XG4gICAgICAgIHRoaXMuZW5kU2lkZSA9IGVuZFNpZGU7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBkZWNvcmF0aW9uLCB3aGljaCBpbmZsdWVuY2VzIHRoZSBzdHlsaW5nIG9mIHRoZVxuICAgIGNvbnRlbnQgaW4gaXRzIHJhbmdlLiBOZXN0ZWQgbWFyayBkZWNvcmF0aW9ucyB3aWxsIGNhdXNlIG5lc3RlZFxuICAgIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgICBwcmVjZWRlbmNlIG9mIHRoZSBbZmFjZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSBvclxuICAgIChiZWxvdyB0aGUgZmFjZXQtcHJvdmlkZWQgZGVjb3JhdGlvbnMpIFt2aWV3XG4gICAgcGx1Z2luXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGx1Z2luU3BlYy5kZWNvcmF0aW9ucykuIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0XG4gICAgb24gbGluZSBib3VuZGFyaWVzIGFuZCBvbiB0aGUgYm91bmRhcmllcyBvZiBoaWdoZXItcHJlY2VkZW5jZVxuICAgIGRlY29yYXRpb25zLlxuICAgICovXG4gICAgc3RhdGljIG1hcmsoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmtEZWNvcmF0aW9uKHNwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB3aWRnZXQgZGVjb3JhdGlvbiwgd2hpY2ggYWRkcyBhbiBlbGVtZW50IGF0IHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgc3RhdGljIHdpZGdldChzcGVjKSB7XG4gICAgICAgIGxldCBzaWRlID0gc3BlYy5zaWRlIHx8IDAsIGJsb2NrID0gISFzcGVjLmJsb2NrO1xuICAgICAgICBzaWRlICs9IGJsb2NrID8gKHNpZGUgPiAwID8gMzAwMDAwMDAwIC8qIEJsb2NrQWZ0ZXIgKi8gOiAtNDAwMDAwMDAwIC8qIEJsb2NrQmVmb3JlICovKSA6IChzaWRlID4gMCA/IDEwMDAwMDAwMCAvKiBJbmxpbmVBZnRlciAqLyA6IC0xMDAwMDAwMDAgLyogSW5saW5lQmVmb3JlICovKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludERlY29yYXRpb24oc3BlYywgc2lkZSwgc2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gICAgYSB3aWRnZXQsIG9yIHNpbXBseSBoaWRlcyBpdC5cbiAgICAqL1xuICAgIHN0YXRpYyByZXBsYWNlKHNwZWMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gISFzcGVjLmJsb2NrO1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2spO1xuICAgICAgICBsZXQgc3RhcnRTaWRlID0gYmxvY2sgPyAoc3RhcnQgPyAtMzAwMDAwMDAwIC8qIEJsb2NrSW5jU3RhcnQgKi8gOiAtMSAvKiBJbmxpbmVJbmNTdGFydCAqLykgOiA0MDAwMDAwMDAgLyogTm9uSW5jU3RhcnQgKi87XG4gICAgICAgIGxldCBlbmRTaWRlID0gYmxvY2sgPyAoZW5kID8gMjAwMDAwMDAwIC8qIEJsb2NrSW5jRW5kICovIDogMSAvKiBJbmxpbmVJbmNFbmQgKi8pIDogLTUwMDAwMDAwMCAvKiBOb25JbmNFbmQgKi87XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnREZWNvcmF0aW9uKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHNwZWMud2lkZ2V0IHx8IG51bGwsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gICAgbGluZSBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgbGluZShzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZURlY29yYXRpb24oc3BlYyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgW2BEZWNvcmF0aW9uU2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25TZXQpIGZyb20gdGhlIGdpdmVuXG4gICAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gICAgcGFzcyBgdHJ1ZWAgZm9yIGBzb3J0YCB0byBtYWtlIHRoZSBsaWJyYXJ5IHNvcnQgdGhlbSBmb3IgeW91LlxuICAgICovXG4gICAgc3RhdGljIHNldChvZiwgc29ydCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZVNldC5vZihvZiwgc29ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaGFzSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy53aWRnZXQgPyB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPiAtMSA6IGZhbHNlOyB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgZGVjb3JhdGlvbnMuXG4qL1xuRGVjb3JhdGlvbi5ub25lID0gUmFuZ2VTZXQuZW1wdHk7XG5jbGFzcyBNYXJrRGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gZ2V0SW5jbHVzaXZlKHNwZWMpO1xuICAgICAgICBzdXBlcihzdGFydCA/IC0xIC8qIElubGluZUluY1N0YXJ0ICovIDogNDAwMDAwMDAwIC8qIE5vbkluY1N0YXJ0ICovLCBlbmQgPyAxIC8qIElubGluZUluY0VuZCAqLyA6IC01MDAwMDAwMDAgLyogTm9uSW5jRW5kICovLCBudWxsLCBzcGVjKTtcbiAgICAgICAgdGhpcy50YWdOYW1lID0gc3BlYy50YWdOYW1lIHx8IFwic3BhblwiO1xuICAgICAgICB0aGlzLmNsYXNzID0gc3BlYy5jbGFzcyB8fCBcIlwiO1xuICAgICAgICB0aGlzLmF0dHJzID0gc3BlYy5hdHRyaWJ1dGVzIHx8IG51bGw7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICBvdGhlciBpbnN0YW5jZW9mIE1hcmtEZWNvcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgdGhpcy50YWdOYW1lID09IG90aGVyLnRhZ05hbWUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzID09IG90aGVyLmNsYXNzICYmXG4gICAgICAgICAgICAgICAgYXR0cnNFcSh0aGlzLmF0dHJzLCBvdGhlci5hdHRycyk7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAoZnJvbSA+PSB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTWFyayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIGVtcHR5XCIpO1xuICAgICAgICByZXR1cm4gc3VwZXIucmFuZ2UoZnJvbSwgdG8pO1xuICAgIH1cbn1cbk1hcmtEZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IGZhbHNlO1xuY2xhc3MgTGluZURlY29yYXRpb24gZXh0ZW5kcyBEZWNvcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKC0yMDAwMDAwMDAgLyogTGluZSAqLywgLTIwMDAwMDAwMCAvKiBMaW5lICovLCBudWxsLCBzcGVjKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZURlY29yYXRpb24gJiYgYXR0cnNFcSh0aGlzLnNwZWMuYXR0cmlidXRlcywgb3RoZXIuc3BlYy5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmFuZ2UoZnJvbSwgdG8gPSBmcm9tKSB7XG4gICAgICAgIGlmICh0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuTGluZURlY29yYXRpb24ucHJvdG90eXBlLm1hcE1vZGUgPSBNYXBNb2RlLlRyYWNrQmVmb3JlO1xuTGluZURlY29yYXRpb24ucHJvdG90eXBlLnBvaW50ID0gdHJ1ZTtcbmNsYXNzIFBvaW50RGVjb3JhdGlvbiBleHRlbmRzIERlY29yYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMsIHN0YXJ0U2lkZSwgZW5kU2lkZSwgYmxvY2ssIHdpZGdldCwgaXNSZXBsYWNlKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0U2lkZSwgZW5kU2lkZSwgd2lkZ2V0LCBzcGVjKTtcbiAgICAgICAgdGhpcy5ibG9jayA9IGJsb2NrO1xuICAgICAgICB0aGlzLmlzUmVwbGFjZSA9IGlzUmVwbGFjZTtcbiAgICAgICAgdGhpcy5tYXBNb2RlID0gIWJsb2NrID8gTWFwTW9kZS5UcmFja0RlbCA6IHN0YXJ0U2lkZSA8PSAwID8gTWFwTW9kZS5UcmFja0JlZm9yZSA6IE1hcE1vZGUuVHJhY2tBZnRlcjtcbiAgICB9XG4gICAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgPCB0aGlzLmVuZFNpZGUgPyBCbG9ja1R5cGUuV2lkZ2V0UmFuZ2VcbiAgICAgICAgICAgIDogdGhpcy5zdGFydFNpZGUgPD0gMCA/IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgOiBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXI7XG4gICAgfVxuICAgIGdldCBoZWlnaHRSZWxldmFudCgpIHsgcmV0dXJuIHRoaXMuYmxvY2sgfHwgISF0aGlzLndpZGdldCAmJiB0aGlzLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgPj0gNTsgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIFBvaW50RGVjb3JhdGlvbiAmJlxuICAgICAgICAgICAgd2lkZ2V0c0VxKHRoaXMud2lkZ2V0LCBvdGhlci53aWRnZXQpICYmXG4gICAgICAgICAgICB0aGlzLmJsb2NrID09IG90aGVyLmJsb2NrICYmXG4gICAgICAgICAgICB0aGlzLnN0YXJ0U2lkZSA9PSBvdGhlci5zdGFydFNpZGUgJiYgdGhpcy5lbmRTaWRlID09IG90aGVyLmVuZFNpZGU7XG4gICAgfVxuICAgIHJhbmdlKGZyb20sIHRvID0gZnJvbSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlcGxhY2UgJiYgKGZyb20gPiB0byB8fCAoZnJvbSA9PSB0byAmJiB0aGlzLnN0YXJ0U2lkZSA+IDAgJiYgdGhpcy5lbmRTaWRlIDw9IDApKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVwbGFjZSAmJiB0byAhPSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXaWRnZXQgZGVjb3JhdGlvbnMgY2FuIG9ubHkgaGF2ZSB6ZXJvLWxlbmd0aCByYW5nZXNcIik7XG4gICAgICAgIHJldHVybiBzdXBlci5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxuUG9pbnREZWNvcmF0aW9uLnByb3RvdHlwZS5wb2ludCA9IHRydWU7XG5mdW5jdGlvbiBnZXRJbmNsdXNpdmUoc3BlYywgYmxvY2sgPSBmYWxzZSkge1xuICAgIGxldCB7IGluY2x1c2l2ZVN0YXJ0OiBzdGFydCwgaW5jbHVzaXZlRW5kOiBlbmQgfSA9IHNwZWM7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpXG4gICAgICAgIHN0YXJ0ID0gc3BlYy5pbmNsdXNpdmU7XG4gICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBzcGVjLmluY2x1c2l2ZTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogYmxvY2ssIGVuZDogZW5kICE9PSBudWxsICYmIGVuZCAhPT0gdm9pZCAwID8gZW5kIDogYmxvY2sgfTtcbn1cbmZ1bmN0aW9uIHdpZGdldHNFcShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT0gYiB8fCAhIShhICYmIGIgJiYgYS5jb21wYXJlKGIpKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKGZyb20sIHRvLCByYW5nZXMsIG1hcmdpbiA9IDApIHtcbiAgICBsZXQgbGFzdCA9IHJhbmdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgcmFuZ2VzW2xhc3RdICsgbWFyZ2luID49IGZyb20pXG4gICAgICAgIHJhbmdlc1tsYXN0XSA9IE1hdGgubWF4KHJhbmdlc1tsYXN0XSwgdG8pO1xuICAgIGVsc2VcbiAgICAgICAgcmFuZ2VzLnB1c2goZnJvbSwgdG8pO1xufVxuXG5jbGFzcyBMaW5lVmlldyBleHRlbmRzIENvbnRlbnRWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucHJldkF0dHJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmF0dHJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgICB9XG4gICAgLy8gQ29uc3VtZXMgc291cmNlXG4gICAgbWVyZ2UoZnJvbSwgdG8sIHNvdXJjZSwgaGFzU3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBMaW5lVmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRvbSlcbiAgICAgICAgICAgICAgICBzb3VyY2UudHJhbnNmZXJET00odGhpcyk7IC8vIFJldXNlIHNvdXJjZS5kb20gd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdGFydClcbiAgICAgICAgICAgIHRoaXMuc2V0RGVjbyhzb3VyY2UgPyBzb3VyY2UuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgbWVyZ2VDaGlsZHJlbkludG8odGhpcywgZnJvbSwgdG8sIHNvdXJjZSA/IHNvdXJjZS5jaGlsZHJlbiA6IFtdLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG5ldyBMaW5lVmlldztcbiAgICAgICAgZW5kLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXI7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGVuZDtcbiAgICAgICAgbGV0IHsgaSwgb2ZmIH0gPSB0aGlzLmNoaWxkUG9zKGF0KTtcbiAgICAgICAgaWYgKG9mZikge1xuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2ldLnNwbGl0KG9mZiksIDApO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5tZXJnZShvZmYsIHRoaXMuY2hpbGRyZW5baV0ubGVuZ3RoLCBudWxsLCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgZW5kLmFwcGVuZCh0aGlzLmNoaWxkcmVuW2pdLCAwKTtcbiAgICAgICAgd2hpbGUgKGkgPiAwICYmIHRoaXMuY2hpbGRyZW5baSAtIDFdLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblstLWldLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggPSBpO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGF0O1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICB0cmFuc2ZlckRPTShvdGhlcikge1xuICAgICAgICBpZiAoIXRoaXMuZG9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdGhlci5zZXRET00odGhpcy5kb20pO1xuICAgICAgICBvdGhlci5wcmV2QXR0cnMgPSB0aGlzLnByZXZBdHRycyA9PT0gdW5kZWZpbmVkID8gdGhpcy5hdHRycyA6IHRoaXMucHJldkF0dHJzO1xuICAgICAgICB0aGlzLnByZXZBdHRycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kb20gPSBudWxsO1xuICAgIH1cbiAgICBzZXREZWNvKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnNFcSh0aGlzLmF0dHJzLCBhdHRycykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGVuZChjaGlsZCwgb3BlblN0YXJ0KSB7XG4gICAgICAgIGpvaW5JbmxpbmVJbnRvKHRoaXMsIGNoaWxkLCBvcGVuU3RhcnQpO1xuICAgIH1cbiAgICAvLyBPbmx5IGNhbGxlZCB3aGVuIGJ1aWxkaW5nIGEgbGluZSB2aWV3IGluIENvbnRlbnRCdWlsZGVyXG4gICAgYWRkTGluZURlY28oZGVjbykge1xuICAgICAgICBsZXQgYXR0cnMgPSBkZWNvLnNwZWMuYXR0cmlidXRlcywgY2xzID0gZGVjby5zcGVjLmNsYXNzO1xuICAgICAgICBpZiAoYXR0cnMpXG4gICAgICAgICAgICB0aGlzLmF0dHJzID0gY29tYmluZUF0dHJzKGF0dHJzLCB0aGlzLmF0dHJzIHx8IHt9KTtcbiAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSBjb21iaW5lQXR0cnMoeyBjbGFzczogY2xzIH0sIHRoaXMuYXR0cnMgfHwge30pO1xuICAgIH1cbiAgICBkb21BdFBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIGlubGluZURPTUF0UG9zKHRoaXMuZG9tLCB0aGlzLmNoaWxkcmVuLCBwb3MpO1xuICAgIH1cbiAgICByZXVzZURPTShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiRElWXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RE9NKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSB8PSA0IC8qIEF0dHJzICovIHwgMiAvKiBOb2RlICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN5bmModHJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICB0aGlzLnNldERPTShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRpcnR5ICYgNCAvKiBBdHRycyAqLykge1xuICAgICAgICAgICAgY2xlYXJBdHRyaWJ1dGVzKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2QXR0cnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5kb20sIHRoaXMucHJldkF0dHJzLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpO1xuICAgICAgICAgICAgdGhpcy5wcmV2QXR0cnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc3luYyh0cmFjayk7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5kb20ubGFzdENoaWxkO1xuICAgICAgICB3aGlsZSAobGFzdCAmJiBDb250ZW50Vmlldy5nZXQobGFzdCkgaW5zdGFuY2VvZiBNYXJrVmlldylcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFsYXN0IHx8XG4gICAgICAgICAgICBsYXN0Lm5vZGVOYW1lICE9IFwiQlJcIiAmJiAoKF9hID0gQ29udGVudFZpZXcuZ2V0KGxhc3QpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNFZGl0YWJsZSkgPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAoIWJyb3dzZXIuaW9zIHx8ICF0aGlzLmNoaWxkcmVuLnNvbWUoY2ggPT4gY2ggaW5zdGFuY2VvZiBUZXh0VmlldykpKSB7XG4gICAgICAgICAgICBsZXQgaGFjayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJCUlwiKTtcbiAgICAgICAgICAgIGhhY2suY21JZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoaGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCB0aGlzLmxlbmd0aCA+IDIwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gMDtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBUZXh0VmlldykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBsZXQgcmVjdHMgPSBjbGllbnRSZWN0c0ZvcihjaGlsZC5kb20pO1xuICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCAhPSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdG90YWxXaWR0aCArPSByZWN0c1swXS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaW5lSGVpZ2h0OiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXG4gICAgICAgICAgICBjaGFyV2lkdGg6IHRvdGFsV2lkdGggLyB0aGlzLmxlbmd0aCB9O1xuICAgIH1cbiAgICBjb29yZHNBdChwb3MsIHNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0luQ2hpbGRyZW4odGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgYmVjb21lKF9vdGhlcikgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIEJsb2NrVHlwZS5UZXh0OyB9XG4gICAgc3RhdGljIGZpbmQoZG9jVmlldywgcG9zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBvZmYgPSAwOyBpIDwgZG9jVmlldy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gZG9jVmlldy5jaGlsZHJlbltpXSwgZW5kID0gb2ZmICsgYmxvY2subGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2ZmID0gZW5kICsgYmxvY2suYnJlYWtBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCbG9ja1dpZGdldFZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iod2lkZ2V0LCBsZW5ndGgsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWRnZXQgPSB3aWRnZXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmJyZWFrQWZ0ZXIgPSAwO1xuICAgIH1cbiAgICBtZXJnZShmcm9tLCB0bywgc291cmNlLCBfdGFrZURlY28sIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgICAgICBpZiAoc291cmNlICYmICghKHNvdXJjZSBpbnN0YW5jZW9mIEJsb2NrV2lkZ2V0VmlldykgfHwgIXRoaXMud2lkZ2V0LmNvbXBhcmUoc291cmNlLndpZGdldCkgfHxcbiAgICAgICAgICAgIGZyb20gPiAwICYmIG9wZW5TdGFydCA8PSAwIHx8IHRvIDwgdGhpcy5sZW5ndGggJiYgb3BlbkVuZCA8PSAwKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBmcm9tICsgKHNvdXJjZSA/IHNvdXJjZS5sZW5ndGggOiAwKSArICh0aGlzLmxlbmd0aCAtIHRvKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gcG9zID09IDAgPyBET01Qb3MuYmVmb3JlKHRoaXMuZG9tKSA6IERPTVBvcy5hZnRlcih0aGlzLmRvbSwgcG9zID09IHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc3BsaXQoYXQpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRoaXMubGVuZ3RoIC0gYXQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXQ7XG4gICAgICAgIGxldCBlbmQgPSBuZXcgQmxvY2tXaWRnZXRWaWV3KHRoaXMud2lkZ2V0LCBsZW4sIHRoaXMudHlwZSk7XG4gICAgICAgIGVuZC5icmVha0FmdGVyID0gdGhpcy5icmVha0FmdGVyO1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiBub0NoaWxkcmVuOyB9XG4gICAgc3luYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy53aWRnZXQudXBkYXRlRE9NKHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00odGhpcy5lZGl0b3JWaWV3KSk7XG4gICAgICAgICAgICB0aGlzLmRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQudmlldy5zdGF0ZS5kb2Muc2xpY2UodGhpcy5wb3NBdFN0YXJ0LCB0aGlzLnBvc0F0RW5kKSA6IFRleHQkMS5lbXB0eTtcbiAgICB9XG4gICAgZG9tQm91bmRzQXJvdW5kKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGJlY29tZShvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBCbG9ja1dpZGdldFZpZXcgJiYgb3RoZXIudHlwZSA9PSB0aGlzLnR5cGUgJiZcbiAgICAgICAgICAgIG90aGVyLndpZGdldC5jb25zdHJ1Y3RvciA9PSB0aGlzLndpZGdldC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKCFvdGhlci53aWRnZXQuZXEodGhpcy53aWRnZXQpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya0RpcnR5KHRydWUpO1xuICAgICAgICAgICAgdGhpcy53aWRnZXQgPSBvdGhlci53aWRnZXQ7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG90aGVyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuYnJlYWtBZnRlciA9IG90aGVyLmJyZWFrQWZ0ZXI7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIGlnbm9yZUV2ZW50KGV2ZW50KSB7IHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChldmVudCk7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmRvbSlcbiAgICAgICAgICAgIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udGVudEJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvYywgcG9zLCBlbmQsIGRpc2FsbG93QmxvY2tFZmZlY3RzQmVsb3cpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0JlbG93ID0gZGlzYWxsb3dCbG9ja0VmZmVjdHNCZWxvdztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCAvKiBObyAqLztcbiAgICAgICAgLy8gU2V0IHRvIGZhbHNlIGRpcmVjdGx5IGFmdGVyIGEgd2lkZ2V0IHRoYXQgY292ZXJzIHRoZSBwb3NpdGlvbiBhZnRlciBpdFxuICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSAtMTtcbiAgICAgICAgdGhpcy5vcGVuRW5kID0gLTE7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jLml0ZXIoKTtcbiAgICAgICAgdGhpcy5za2lwID0gcG9zO1xuICAgIH1cbiAgICBwb3NDb3ZlcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmJyZWFrQXRTdGFydCAmJiB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gIT0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuICFsYXN0LmJyZWFrQWZ0ZXIgJiYgIShsYXN0IGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGxhc3QudHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QmVmb3JlKTtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1ckxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKHRoaXMuY3VyTGluZSA9IG5ldyBMaW5lVmlldyk7XG4gICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJMaW5lO1xuICAgIH1cbiAgICBmbHVzaEJ1ZmZlcihhY3RpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0J1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJMaW5lLmFwcGVuZCh3cmFwTWFya3MobmV3IFdpZGdldEJ1ZmZlclZpZXcoLTEpLCBhY3RpdmUpLCBhY3RpdmUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9IDAgLyogTm8gKi87XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQmxvY2tXaWRnZXQodmlldykge1xuICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKFtdKTtcbiAgICAgICAgdGhpcy5jdXJMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50LnB1c2godmlldyk7XG4gICAgfVxuICAgIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICAgIGlmICghb3BlbkVuZClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoW10pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIE5vICovO1xuICAgICAgICBpZiAoIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCk7XG4gICAgfVxuICAgIGJ1aWxkVGV4dChsZW5ndGgsIGFjdGl2ZSwgb3BlblN0YXJ0KSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmID09IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB2YWx1ZSwgbGluZUJyZWFrLCBkb25lIH0gPSB0aGlzLmN1cnNvci5uZXh0KHRoaXMuc2tpcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuIG91dCBvZiB0ZXh0IGNvbnRlbnQgd2hlbiBkcmF3aW5nIGlubGluZSB2aWV3c1wiKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3NDb3ZlcmVkKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdLmJyZWFrQWZ0ZXIgPSAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyZWFrQXRTdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoW10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0T2ZmID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFrZSA9IE1hdGgubWluKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYsIGxlbmd0aCwgNTEyIC8qIENodW5rICovKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlLnNsaWNlKDAsIG9wZW5TdGFydCkpO1xuICAgICAgICAgICAgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKHdyYXBNYXJrcyhuZXcgVGV4dFZpZXcodGhpcy50ZXh0LnNsaWNlKHRoaXMudGV4dE9mZiwgdGhpcy50ZXh0T2ZmICsgdGFrZSkpLCBhY3RpdmUpLCBvcGVuU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5hdEN1cnNvclBvcyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gdGFrZTtcbiAgICAgICAgICAgIGxlbmd0aCAtPSB0YWtlO1xuICAgICAgICAgICAgb3BlblN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGFuKGZyb20sIHRvLCBhY3RpdmUsIG9wZW5TdGFydCkge1xuICAgICAgICB0aGlzLmJ1aWxkVGV4dCh0byAtIGZyb20sIGFjdGl2ZSwgb3BlblN0YXJ0KTtcbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgIH1cbiAgICBwb2ludChmcm9tLCB0bywgZGVjbywgYWN0aXZlLCBvcGVuU3RhcnQpIHtcbiAgICAgICAgbGV0IGxlbiA9IHRvIC0gZnJvbTtcbiAgICAgICAgaWYgKGRlY28gaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChkZWNvLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gZGVjbztcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMucG9zQ292ZXJlZCgpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJsb2NrV2lkZ2V0KG5ldyBCbG9ja1dpZGdldFZpZXcoZGVjby53aWRnZXQgfHwgbmV3IE51bGxXaWRnZXQoXCJkaXZcIiksIGxlbiwgdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHZpZXcgPSBXaWRnZXRWaWV3LmNyZWF0ZShkZWNvLndpZGdldCB8fCBuZXcgTnVsbFdpZGdldChcInNwYW5cIiksIGxlbiwgZGVjby5zdGFydFNpZGUpO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JCZWZvcmUgPSB0aGlzLmF0Q3Vyc29yUG9zICYmICF2aWV3LmlzRWRpdGFibGUgJiYgb3BlblN0YXJ0IDw9IGFjdGl2ZS5sZW5ndGggJiYgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA+IDApO1xuICAgICAgICAgICAgICAgIGxldCBjdXJzb3JBZnRlciA9ICF2aWV3LmlzRWRpdGFibGUgJiYgKGZyb20gPCB0byB8fCBkZWNvLnN0YXJ0U2lkZSA8PSAwKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCdWZmZXIgPT0gMiAvKiBJZkN1cnNvciAqLyAmJiAhY3Vyc29yQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwIC8qIE5vICovO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hCdWZmZXIoYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuYXBwZW5kKHdyYXBNYXJrcyhuZXcgV2lkZ2V0QnVmZmVyVmlldygxKSwgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgb3BlblN0YXJ0ID0gYWN0aXZlLmxlbmd0aCArIE1hdGgubWF4KDAsIG9wZW5TdGFydCAtIGFjdGl2ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaW5lLmFwcGVuZCh3cmFwTWFya3ModmlldywgYWN0aXZlKSwgb3BlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0Q3Vyc29yUG9zID0gY3Vyc29yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQnVmZmVyID0gIWN1cnNvckFmdGVyID8gMCAvKiBObyAqLyA6IGZyb20gPCB0byA/IDEgLyogWWVzICovIDogMiAvKiBJZkN1cnNvciAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLmZyb20gPT0gdGhpcy5wb3MpIHsgLy8gTGluZSBkZWNvcmF0aW9uXG4gICAgICAgICAgICB0aGlzLmdldExpbmUoKS5hZGRMaW5lRGVjbyhkZWNvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBpdGVyYXRvciBwYXN0IHRoZSByZXBsYWNlZCBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0T2ZmICsgbGVuIDw9IHRoaXMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRPZmYgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwICs9IGxlbiAtICh0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA8IDApXG4gICAgICAgICAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB9XG4gICAgZmlsdGVyUG9pbnQoZnJvbSwgdG8sIHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kaXNhbGxvd0Jsb2NrRWZmZWN0c0JlbG93IHx8ICEodmFsdWUgaW5zdGFuY2VvZiBQb2ludERlY29yYXRpb24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICh2YWx1ZS5ibG9jaylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQmxvY2sgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgICAgIHJldHVybiB0byA8PSB0aGlzLmRvYy5saW5lQXQodGhpcy5wb3MpLnRvO1xuICAgIH1cbiAgICBzdGF0aWMgYnVpbGQodGV4dCwgZnJvbSwgdG8sIGRlY29yYXRpb25zLCBwbHVnaW5EZWNvcmF0aW9uTGVuZ3RoKSB7XG4gICAgICAgIGxldCBidWlsZGVyID0gbmV3IENvbnRlbnRCdWlsZGVyKHRleHQsIGZyb20sIHRvLCBwbHVnaW5EZWNvcmF0aW9uTGVuZ3RoKTtcbiAgICAgICAgYnVpbGRlci5vcGVuRW5kID0gUmFuZ2VTZXQuc3BhbnMoZGVjb3JhdGlvbnMsIGZyb20sIHRvLCBidWlsZGVyKTtcbiAgICAgICAgaWYgKGJ1aWxkZXIub3BlblN0YXJ0IDwgMClcbiAgICAgICAgICAgIGJ1aWxkZXIub3BlblN0YXJ0ID0gYnVpbGRlci5vcGVuRW5kO1xuICAgICAgICBidWlsZGVyLmZpbmlzaChidWlsZGVyLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3ModmlldywgYWN0aXZlKSB7XG4gICAgZm9yIChsZXQgbWFyayBvZiBhY3RpdmUpXG4gICAgICAgIHZpZXcgPSBuZXcgTWFya1ZpZXcobWFyaywgW3ZpZXddLCB2aWV3Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZpZXc7XG59XG5jbGFzcyBOdWxsV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIudGFnID09IHRoaXMudGFnOyB9XG4gICAgdG9ET00oKSB7IHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTsgfVxuICAgIHVwZGF0ZURPTShlbHQpIHsgcmV0dXJuIGVsdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09IHRoaXMudGFnOyB9XG59XG5cbmNvbnN0IG5vbmUgPSBbXTtcbmNvbnN0IGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZHJhZ01vdmVzU2VsZWN0aW9uJDEgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBtb3VzZVNlbGVjdGlvblN0eWxlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgZXhjZXB0aW9uU2luayA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IHVwZGF0ZUxpc3RlbmVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3QgaW5wdXRIYW5kbGVyID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLy8gRklYTUUgcmVtb3ZlXG5jb25zdCBzY3JvbGxUbyA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcDogKHJhbmdlLCBjaGFuZ2VzKSA9PiByYW5nZS5tYXAoY2hhbmdlcylcbn0pO1xuLy8gRklYTUUgcmVtb3ZlXG5jb25zdCBjZW50ZXJPbiA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoe1xuICAgIG1hcDogKHJhbmdlLCBjaGFuZ2VzKSA9PiByYW5nZS5tYXAoY2hhbmdlcylcbn0pO1xuY2xhc3MgU2Nyb2xsVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgeSA9IFwibmVhcmVzdFwiLCB4ID0gXCJuZWFyZXN0XCIsIHlNYXJnaW4gPSA1LCB4TWFyZ2luID0gNSkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueU1hcmdpbiA9IHlNYXJnaW47XG4gICAgICAgIHRoaXMueE1hcmdpbiA9IHhNYXJnaW47XG4gICAgfVxuICAgIG1hcChjaGFuZ2VzKSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmVtcHR5ID8gdGhpcyA6IG5ldyBTY3JvbGxUYXJnZXQodGhpcy5yYW5nZS5tYXAoY2hhbmdlcyksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbik7XG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHsgbWFwOiAodCwgY2gpID0+IHQubWFwKGNoKSB9KTtcbi8qKlxuTG9nIG9yIHJlcG9ydCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGluIGNsaWVudCBjb2RlLiBTaG91bGRcbnByb2JhYmx5IG9ubHkgYmUgdXNlZCBieSBleHRlbnNpb24gY29kZSB0aGF0IGFsbG93cyBjbGllbnQgY29kZSB0b1xucHJvdmlkZSBmdW5jdGlvbnMsIGFuZCBjYWxscyB0aG9zZSBmdW5jdGlvbnMgaW4gYSBjb250ZXh0IHdoZXJlIGFuXG5leGNlcHRpb24gY2FuJ3QgYmUgcHJvcGFnYXRlZCB0byBjYWxsaW5nIGNvZGUgaW4gYSByZWFzb25hYmxlIHdheVxuKGZvciBleGFtcGxlIHdoZW4gaW4gYW4gZXZlbnQgaGFuZGxlcikuXG5cbkVpdGhlciBjYWxscyBhIGhhbmRsZXIgcmVnaXN0ZXJlZCB3aXRoXG5bYEVkaXRvclZpZXcuZXhjZXB0aW9uU2lua2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmV4Y2VwdGlvblNpbmspLFxuYHdpbmRvdy5vbmVycm9yYCwgaWYgZGVmaW5lZCwgb3IgYGNvbnNvbGUuZXJyb3JgIChpbiB3aGljaCBjYXNlXG5pdCdsbCBwYXNzIGBjb250ZXh0YCwgd2hlbiBnaXZlbiwgYXMgZmlyc3QgYXJndW1lbnQpLlxuKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbihzdGF0ZSwgZXhjZXB0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhbmRsZXIgPSBzdGF0ZS5mYWNldChleGNlcHRpb25TaW5rKTtcbiAgICBpZiAoaGFuZGxlci5sZW5ndGgpXG4gICAgICAgIGhhbmRsZXJbMF0oZXhjZXB0aW9uKTtcbiAgICBlbHNlIGlmICh3aW5kb3cub25lcnJvcilcbiAgICAgICAgd2luZG93Lm9uZXJyb3IoU3RyaW5nKGV4Y2VwdGlvbiksIGNvbnRleHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBleGNlcHRpb24pO1xuICAgIGVsc2UgaWYgKGNvbnRleHQpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGV4dCArIFwiOlwiLCBleGNlcHRpb24pO1xuICAgIGVsc2VcbiAgICAgICAgY29uc29sZS5lcnJvcihleGNlcHRpb24pO1xufVxuY29uc3QgZWRpdGFibGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5sZW5ndGggPyB2YWx1ZXNbMF0gOiB0cnVlIH0pO1xuLyoqXG5Vc2VkIHRvIFtkZWNsYXJlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGx1Z2luU3BlYy5wcm92aWRlKSB3aGljaFxuW2ZpZWxkc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlBsdWdpblZhbHVlKSBhIFt2aWV3IHBsdWdpbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LlZpZXdQbHVnaW4pXG5wcm92aWRlcy5cbiovXG5jbGFzcyBQbHVnaW5GaWVsZFByb3ZpZGVyIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmllbGQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0KSB7XG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcbiAgICAgICAgdGhpcy5nZXQgPSBnZXQ7XG4gICAgfVxufVxuLyoqXG5QbHVnaW4gZmllbGRzIGFyZSBhIG1lY2hhbmlzbSBmb3IgYWxsb3dpbmcgcGx1Z2lucyB0byBwcm92aWRlXG52YWx1ZXMgdGhhdCBjYW4gYmUgcmV0cmlldmVkIHRocm91Z2ggdGhlXG5bYHBsdWdpbkZpZWxkYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcucGx1Z2luRmllbGQpIHZpZXcgbWV0aG9kLlxuKi9cbmNsYXNzIFBsdWdpbkZpZWxkIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBbcHJvdmlkZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5QbHVnaW5GaWVsZFByb3ZpZGVyKSBmb3IgdGhpcyBmaWVsZCxcbiAgICB0byB1c2Ugd2l0aCBhIHBsdWdpbidzIFtwcm92aWRlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuUGx1Z2luU3BlYy5wcm92aWRlKVxuICAgIG9wdGlvbi5cbiAgICAqL1xuICAgIGZyb20oZ2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGx1Z2luRmllbGRQcm92aWRlcih0aGlzLCBnZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBuZXcgcGx1Z2luIGZpZWxkLlxuICAgICovXG4gICAgc3RhdGljIGRlZmluZSgpIHsgcmV0dXJuIG5ldyBQbHVnaW5GaWVsZCgpOyB9XG59XG4vKipcblRoaXMgZmllbGQgY2FuIGJlIHVzZWQgYnkgcGx1Z2lucyB0byBwcm92aWRlXG5bZGVjb3JhdGlvbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uKS5cblxuKipOb3RlKio6IEZvciByZWFzb25zIG9mIGRhdGEgZmxvdyAocGx1Z2lucyBhcmUgb25seSB1cGRhdGVkXG5hZnRlciB0aGUgdmlld3BvcnQgaXMgY29tcHV0ZWQpLCBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBwbHVnaW5zXG5hcmUgX25vdF8gdGFrZW4gaW50byBhY2NvdW50IHdoZW4gcHJlZGljdGluZyB0aGUgdmVydGljYWwgbGF5b3V0XG5zdHJ1Y3R1cmUgb2YgdGhlIGVkaXRvci4gVGhleSAqKm11c3Qgbm90KiogaW50cm9kdWNlIGJsb2NrXG53aWRnZXRzICh0aGF0IHdpbGwgcmFpc2UgYW4gZXJyb3IpIG9yIHJlcGxhY2luZyBkZWNvcmF0aW9ucyB0aGF0XG5jb3ZlciBsaW5lIGJyZWFrcyAodGhlc2Ugd2lsbCBiZSBpZ25vcmVkIGlmIHRoZXkgb2NjdXIpLiBTdWNoXG5kZWNvcmF0aW9ucywgb3Igb3RoZXJzIHRoYXQgY2F1c2UgYSBsYXJnZSBhbW91bnQgb2YgdmVydGljYWxcbnNpemUgc2hpZnQgY29tcGFyZWQgdG8gdGhlIHVuZGVjb3JhdGVkIGNvbnRlbnQsIHNob3VsZCBiZVxucHJvdmlkZWQgdGhyb3VnaCB0aGUgc3RhdGUtbGV2ZWwgW2BkZWNvcmF0aW9uc2BcbmZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucykgaW5zdGVhZC5cbiovXG5QbHVnaW5GaWVsZC5kZWNvcmF0aW9ucyA9IC8qQF9fUFVSRV9fKi9QbHVnaW5GaWVsZC5kZWZpbmUoKTtcbi8qKlxuVXNlZCB0byBwcm92aWRlIHJhbmdlcyB0aGF0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGF0b21zIGFzIGZhciBhc1xuY3Vyc29yIG1vdGlvbiBpcyBjb25jZXJuZWQuIFRoaXMgY2F1c2VzIG1ldGhvZHMgbGlrZVxuW2Btb3ZlQnlDaGFyYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZUJ5Q2hhcikgYW5kXG5bYG1vdmVWZXJ0aWNhbGx5YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIChhbmQgdGhlXG5jb21tYW5kcyBidWlsdCBvbiB0b3Agb2YgdGhlbSkgdG8gc2tpcCBhY3Jvc3Mgc3VjaCByZWdpb25zIHdoZW5cbmEgc2VsZWN0aW9uIGVuZHBvaW50IHdvdWxkIGVudGVyIHRoZW0uIFRoaXMgZG9lcyBfbm90XyBwcmV2ZW50XG5kaXJlY3QgcHJvZ3JhbW1hdGljIFtzZWxlY3Rpb25cbnVwZGF0ZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlbGVjdGlvbikgZnJvbSBtb3ZpbmcgaW50byBzdWNoXG5yZWdpb25zLlxuKi9cblBsdWdpbkZpZWxkLmF0b21pY1JhbmdlcyA9IC8qQF9fUFVSRV9fKi9QbHVnaW5GaWVsZC5kZWZpbmUoKTtcbi8qKlxuUGx1Z2lucyBjYW4gcHJvdmlkZSBhZGRpdGlvbmFsIHNjcm9sbCBtYXJnaW5zIChzcGFjZSBhcm91bmQgdGhlXG5zaWRlcyBvZiB0aGUgc2Nyb2xsaW5nIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZFxuaW52aXNpYmxlKSB0aHJvdWdoIHRoaXMgZmllbGQuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIHRoZVxucGx1Z2luIGludHJvZHVjZXMgZWxlbWVudHMgdGhhdCBjb3ZlciBwYXJ0IG9mIHRoYXQgZWxlbWVudCAoZm9yXG5leGFtcGxlIGEgaG9yaXpvbnRhbGx5IGZpeGVkIGd1dHRlcikuXG4qL1xuUGx1Z2luRmllbGQuc2Nyb2xsTWFyZ2lucyA9IC8qQF9fUFVSRV9fKi9QbHVnaW5GaWVsZC5kZWZpbmUoKTtcbmxldCBuZXh0UGx1Z2luSUQgPSAwO1xuY29uc3Qgdmlld1BsdWdpbiA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8qKlxuVmlldyBwbHVnaW5zIGFzc29jaWF0ZSBzdGF0ZWZ1bCB2YWx1ZXMgd2l0aCBhIHZpZXcuIFRoZXkgY2FuXG5pbmZsdWVuY2UgdGhlIHdheSB0aGUgY29udGVudCBpcyBkcmF3biwgYW5kIGFyZSBub3RpZmllZCBvZiB0aGluZ3NcbnRoYXQgaGFwcGVuIGluIHRoZSB2aWV3LlxuKi9cbmNsYXNzIFZpZXdQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaWQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3JlYXRlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZpZWxkcykge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSB2aWV3UGx1Z2luLm9mKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBwbHVnaW4gZnJvbSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGVcbiAgICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKGNyZWF0ZSwgc3BlYykge1xuICAgICAgICBsZXQgeyBldmVudEhhbmRsZXJzLCBwcm92aWRlLCBkZWNvcmF0aW9ucyB9ID0gc3BlYyB8fCB7fTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZSlcbiAgICAgICAgICAgIGZvciAobGV0IHByb3ZpZGVyIG9mIEFycmF5LmlzQXJyYXkocHJvdmlkZSkgPyBwcm92aWRlIDogW3Byb3ZpZGVdKVxuICAgICAgICAgICAgICAgIGZpZWxkcy5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBmaWVsZHMucHVzaChkb21FdmVudEhhbmRsZXJzLmZyb20oKHZhbHVlKSA9PiAoeyBwbHVnaW46IHZhbHVlLCBoYW5kbGVyczogZXZlbnRIYW5kbGVycyB9KSkpO1xuICAgICAgICBpZiAoZGVjb3JhdGlvbnMpXG4gICAgICAgICAgICBmaWVsZHMucHVzaChQbHVnaW5GaWVsZC5kZWNvcmF0aW9ucy5mcm9tKGRlY29yYXRpb25zKSk7XG4gICAgICAgIHJldHVybiBuZXcgVmlld1BsdWdpbihuZXh0UGx1Z2luSUQrKywgY3JlYXRlLCBmaWVsZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4gZm9yIGEgY2xhc3Mgd2hvc2UgY29uc3RydWN0b3IgdGFrZXMgYSBzaW5nbGVcbiAgICBlZGl0b3IgdmlldyBhcyBhcmd1bWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tQ2xhc3MoY2xzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSh2aWV3ID0+IG5ldyBjbHModmlldyksIHNwZWMpO1xuICAgIH1cbn1cbmNvbnN0IGRvbUV2ZW50SGFuZGxlcnMgPSAvKkBfX1BVUkVfXyovUGx1Z2luRmllbGQuZGVmaW5lKCk7XG5jbGFzcyBQbHVnaW5JbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvLyBXaGVuIHN0YXJ0aW5nIGFuIHVwZGF0ZSwgYWxsIHBsdWdpbnMgaGF2ZSB0aGlzIGZpZWxkIHNldCB0byB0aGVcbiAgICAgICAgLy8gdXBkYXRlIG9iamVjdCwgaW5kaWNhdGluZyB0aGV5IG5lZWQgdG8gYmUgdXBkYXRlZC4gV2hlbiBmaW5pc2hlZFxuICAgICAgICAvLyB1cGRhdGluZywgaXQgaXMgc2V0IHRvIGBmYWxzZWAuIFJldHJpZXZpbmcgYSBwbHVnaW4gdGhhdCBuZWVkcyB0b1xuICAgICAgICAvLyBiZSB1cGRhdGVkIHdpdGggYHZpZXcucGx1Z2luYCBmb3JjZXMgYW4gZWFnZXIgdXBkYXRlLlxuICAgICAgICB0aGlzLm11c3RVcGRhdGUgPSBudWxsO1xuICAgICAgICAvLyBUaGlzIGlzIG51bGwgd2hlbiB0aGUgcGx1Z2luIGlzIGluaXRpYWxseSBjcmVhdGVkLCBidXRcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgb24gdGhlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHRha2VGaWVsZCh0eXBlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYylcbiAgICAgICAgICAgIGZvciAobGV0IHsgZmllbGQsIGdldCB9IG9mIHRoaXMuc3BlYy5maWVsZHMpXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkID09IHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGdldCh0aGlzLnZhbHVlKSk7XG4gICAgfVxuICAgIHVwZGF0ZSh2aWV3KSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3BlYykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNwZWMuY3JlYXRlKHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5tdXN0VXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgdXBkYXRlID0gdGhpcy5tdXN0VXBkYXRlO1xuICAgICAgICAgICAgdGhpcy5tdXN0VXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLnVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih1cGRhdGUuc3RhdGUsIGUsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuZGVzdHJveSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSh2aWV3KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMudmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSwgXCJDb2RlTWlycm9yIHBsdWdpbiBjcmFzaGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYyA9IHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNvbnN0IGVkaXRvckF0dHJpYnV0ZXMgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jb25zdCBjb250ZW50QXR0cmlidXRlcyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbi8vIFByb3ZpZGUgZGVjb3JhdGlvbnNcbmNvbnN0IGRlY29yYXRpb25zID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuY29uc3Qgc3R5bGVNb2R1bGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKCk7XG5jbGFzcyBDaGFuZ2VkUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGZyb21BLCB0b0EsIGZyb21CLCB0b0IpIHtcbiAgICAgICAgdGhpcy5mcm9tQSA9IGZyb21BO1xuICAgICAgICB0aGlzLnRvQSA9IHRvQTtcbiAgICAgICAgdGhpcy5mcm9tQiA9IGZyb21CO1xuICAgICAgICB0aGlzLnRvQiA9IHRvQjtcbiAgICB9XG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZWRSYW5nZShNYXRoLm1pbih0aGlzLmZyb21BLCBvdGhlci5mcm9tQSksIE1hdGgubWF4KHRoaXMudG9BLCBvdGhlci50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBvdGhlci5mcm9tQiksIE1hdGgubWF4KHRoaXMudG9CLCBvdGhlci50b0IpKTtcbiAgICB9XG4gICAgYWRkVG9TZXQoc2V0KSB7XG4gICAgICAgIGxldCBpID0gc2V0Lmxlbmd0aCwgbWUgPSB0aGlzO1xuICAgICAgICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gc2V0W2kgLSAxXTtcbiAgICAgICAgICAgIGlmIChyYW5nZS5mcm9tQSA+IG1lLnRvQSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChyYW5nZS50b0EgPCBtZS5mcm9tQSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG1lID0gbWUuam9pbihyYW5nZSk7XG4gICAgICAgICAgICBzZXQuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuc3BsaWNlKGksIDAsIG1lKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgc3RhdGljIGV4dGVuZFdpdGhSYW5nZXMoZGlmZiwgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBkSSA9IDAsIHJJID0gMCwgcG9zQSA9IDAsIHBvc0IgPSAwOzsgZEkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBkSSA9PSBkaWZmLmxlbmd0aCA/IG51bGwgOiBkaWZmW2RJXSwgb2ZmID0gcG9zQSAtIHBvc0I7XG4gICAgICAgICAgICBsZXQgZW5kID0gbmV4dCA/IG5leHQuZnJvbUIgOiAxZTk7XG4gICAgICAgICAgICB3aGlsZSAockkgPCByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1tySV0gPCBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tySV0sIHRvID0gcmFuZ2VzW3JJICsgMV07XG4gICAgICAgICAgICAgICAgbGV0IGZyb21CID0gTWF0aC5tYXgocG9zQiwgZnJvbSksIHRvQiA9IE1hdGgubWluKGVuZCwgdG8pO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tQiA8PSB0b0IpXG4gICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUIgKyBvZmYsIHRvQiArIG9mZiwgZnJvbUIsIHRvQikuYWRkVG9TZXQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgckkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgbmV3IENoYW5nZWRSYW5nZShuZXh0LmZyb21BLCBuZXh0LnRvQSwgbmV4dC5mcm9tQiwgbmV4dC50b0IpLmFkZFRvU2V0KHJlc3VsdCk7XG4gICAgICAgICAgICBwb3NBID0gbmV4dC50b0E7XG4gICAgICAgICAgICBwb3NCID0gbmV4dC50b0I7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblZpZXcgW3BsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKSBhcmUgZ2l2ZW4gaW5zdGFuY2VzIG9mIHRoaXNcbmNsYXNzLCB3aGljaCBkZXNjcmliZSB3aGF0IGhhcHBlbmVkLCB3aGVuZXZlciB0aGUgdmlldyBpcyB1cGRhdGVkLlxuKi9cbmNsYXNzIFZpZXdVcGRhdGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGVkaXRvciB2aWV3IHRoYXQgdGhlIHVwZGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgKi9cbiAgICB2aWV3LCBcbiAgICAvKipcbiAgICBUaGUgbmV3IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUaGUgdHJhbnNhY3Rpb25zIGludm9sdmVkIGluIHRoZSB1cGRhdGUuIE1heSBiZSBlbXB0eS5cbiAgICAqL1xuICAgIHRyYW5zYWN0aW9ucyA9IG5vbmUpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5zdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gQ2hhbmdlU2V0LmVtcHR5KHRoaXMuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbXBvc2UodHIuY2hhbmdlcyk7XG4gICAgICAgIGxldCBjaGFuZ2VkUmFuZ2VzID0gW107XG4gICAgICAgIHRoaXMuY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gY2hhbmdlZFJhbmdlcy5wdXNoKG5ldyBDaGFuZ2VkUmFuZ2UoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikpKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gY2hhbmdlZFJhbmdlcztcbiAgICAgICAgbGV0IGZvY3VzID0gdmlldy5oYXNGb2N1cztcbiAgICAgICAgaWYgKGZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MgfD0gMSAvKiBGb2N1cyAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgW3ZpZXdwb3J0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy52aWV3cG9ydCkgb3JcbiAgICBbdmlzaWJsZSByYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpc2libGVSYW5nZXMpIGNoYW5nZWQgaW4gdGhpc1xuICAgIHVwZGF0ZS5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogVmlld3BvcnQgKi8pID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGhlaWdodCBvZiBhbiBlbGVtZW50IGluIHRoZSBlZGl0b3IgY2hhbmdlZFxuICAgIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGhlaWdodENoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogSGVpZ2h0ICovKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCB3YXMgbW9kaWZpZWQgb3IgdGhlIHNpemUgb2YgdGhlXG4gICAgZWRpdG9yLCBvciBlbGVtZW50cyB3aXRoaW4gdGhlIGVkaXRvciwgY2hhbmdlZC5cbiAgICAqL1xuICAgIGdldCBnZW9tZXRyeUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0NoYW5nZWQgfHwgKHRoaXMuZmxhZ3MgJiAoOCAvKiBHZW9tZXRyeSAqLyB8IDIgLyogSGVpZ2h0ICovKSkgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyB1cGRhdGUgaW5kaWNhdGVzIGEgZm9jdXMgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMSAvKiBGb2N1cyAqLykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBkb2N1bWVudCBjaGFuZ2VkIGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAgICovXG4gICAgZ2V0IHNlbGVjdGlvblNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7IHJldHVybiB0aGlzLmZsYWdzID09IDAgJiYgdGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoID09IDA7IH1cbn1cblxuLyoqXG5Vc2VkIHRvIGluZGljYXRlIFt0ZXh0IGRpcmVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuXG4qL1xudmFyIERpcmVjdGlvbiA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICAgIC8vIChUaGVzZSBhcmUgY2hvc2VuIHRvIG1hdGNoIHRoZSBiYXNlIGxldmVscywgaW4gYmlkaSBhbGdvcml0aG1cbiAgICAvLyB0ZXJtcywgb2Ygc3BhbnMgaW4gdGhhdCBkaXJlY3Rpb24uKVxuICAgIC8qKlxuICAgIExlZnQtdG8tcmlnaHQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgIFJpZ2h0LXRvLWxlZnQuXG4gICAgKi9cbiAgICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiUlRMXCJdID0gMV0gPSBcIlJUTFwiO1xucmV0dXJuIERpcmVjdGlvbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcbmNvbnN0IExUUiA9IERpcmVjdGlvbi5MVFIsIFJUTCA9IERpcmVjdGlvbi5SVEw7XG4vLyBEZWNvZGUgYSBzdHJpbmcgd2l0aCBlYWNoIHR5cGUgZW5jb2RlZCBhcyBsb2cyKHR5cGUpXG5mdW5jdGlvbiBkZWMoc3RyKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICByZXN1bHQucHVzaCgxIDw8ICtzdHJbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGY4XG5jb25zdCBMb3dUeXBlcyA9IC8qQF9fUFVSRV9fKi9kZWMoXCI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODY2Njg4ODg4ODc4NzgzMzMzMzMzMzMzNzg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4Nzg2NjY2ODg4ODA4ODg4ODY2MzM4MDg4ODMwODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOFwiKTtcbi8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuY29uc3QgQXJhYmljVHlwZXMgPSAvKkBfX1BVUkVfXyovZGVjKFwiNDQ0NDQ0ODgyNjYyNzI4ODk5OTk5OTk5OTk5MjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTk5OTk5OTk5OTk5OTk5NDQ0NDQ0NDQ0NDY0NDIyMjgyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjk5OTk5OTk0OTk5OTk5OTIyOTk4OTk5OTIyMzMzMzMzMzMzM1wiKTtcbmNvbnN0IEJyYWNrZXRzID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCksIEJyYWNrZXRTdGFjayA9IFtdO1xuLy8gVGhlcmUncyBhIGxvdCBtb3JlIGluXG4vLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvQmlkaUJyYWNrZXRzLnR4dCxcbi8vIHdoaWNoIGFyZSBsZWZ0IG91dCB0byBrZWVwIGNvZGUgc2l6ZSBkb3duLlxuZm9yIChsZXQgcCBvZiBbXCIoKVwiLCBcIltdXCIsIFwie31cIl0pIHtcbiAgICBsZXQgbCA9IC8qQF9fUFVSRV9fKi9wLmNoYXJDb2RlQXQoMCksIHIgPSAvKkBfX1BVUkVfXyovcC5jaGFyQ29kZUF0KDEpO1xuICAgIEJyYWNrZXRzW2xdID0gcjtcbiAgICBCcmFja2V0c1tyXSA9IC1sO1xufVxuZnVuY3Rpb24gY2hhclR5cGUoY2gpIHtcbiAgICByZXR1cm4gY2ggPD0gMHhmNyA/IExvd1R5cGVzW2NoXSA6XG4gICAgICAgIDB4NTkwIDw9IGNoICYmIGNoIDw9IDB4NWY0ID8gMiAvKiBSICovIDpcbiAgICAgICAgICAgIDB4NjAwIDw9IGNoICYmIGNoIDw9IDB4NmY5ID8gQXJhYmljVHlwZXNbY2ggLSAweDYwMF0gOlxuICAgICAgICAgICAgICAgIDB4NmVlIDw9IGNoICYmIGNoIDw9IDB4OGFjID8gNCAvKiBBTCAqLyA6XG4gICAgICAgICAgICAgICAgICAgIDB4MjAwMCA8PSBjaCAmJiBjaCA8PSAweDIwMGIgPyAyNTYgLyogTkkgKi8gOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPT0gMHgyMDBjID8gMjU2IC8qIE5JICovIDogMSAvKiBMICovO1xufVxuY29uc3QgQmlkaVJFID0gL1tcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUwNzAwLVxcdTA4YWNdLztcbi8qKlxuUmVwcmVzZW50cyBhIGNvbnRpZ3VvdXMgcmFuZ2Ugb2YgdGV4dCB0aGF0IGhhcyBhIHNpbmdsZSBkaXJlY3Rpb25cbihhcyBpbiBsZWZ0LXRvLXJpZ2h0IG9yIHJpZ2h0LXRvLWxlZnQpLlxuKi9cbmNsYXNzIEJpZGlTcGFuIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgc3BhbiAocmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lKS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHNwYW4uXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIFtcImJpZGlcbiAgICBsZXZlbFwiXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI5LyNCYXNpY19EaXNwbGF5X0FsZ29yaXRobSlcbiAgICBvZiB0aGUgc3BhbiAoaW4gdGhpcyBjb250ZXh0LCAwIG1lYW5zXG4gICAgbGVmdC10by1yaWdodCwgMSBtZWFucyByaWdodC10by1sZWZ0LCAyIG1lYW5zIGxlZnQtdG8tcmlnaHRcbiAgICBudW1iZXIgaW5zaWRlIHJpZ2h0LXRvLWxlZnQgdGV4dCkuXG4gICAgKi9cbiAgICBsZXZlbCkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICAgKi9cbiAgICBnZXQgZGlyKCkgeyByZXR1cm4gdGhpcy5sZXZlbCAlIDIgPyBSVEwgOiBMVFI7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNpZGUoZW5kLCBkaXIpIHsgcmV0dXJuICh0aGlzLmRpciA9PSBkaXIpID09IGVuZCA/IHRoaXMudG8gOiB0aGlzLmZyb207IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kKG9yZGVyLCBpbmRleCwgbGV2ZWwsIGFzc29jKSB7XG4gICAgICAgIGxldCBtYXliZSA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBpbmRleCAmJiBzcGFuLnRvID49IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYW4ubGV2ZWwgPT0gbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gbXVsdGlwbGUgc3BhbnMgbWF0Y2gsIGlmIGFzc29jICE9IDAsIHRha2UgdGhlIG9uZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gY292ZXJzIHRoYXQgc2lkZSwgb3RoZXJ3aXNlIHRha2UgdGhlIG9uZSB3aXRoIHRoZSBtaW5pbXVtXG4gICAgICAgICAgICAgICAgLy8gbGV2ZWwuXG4gICAgICAgICAgICAgICAgaWYgKG1heWJlIDwgMCB8fCAoYXNzb2MgIT0gMCA/IChhc3NvYyA8IDAgPyBzcGFuLmZyb20gPCBpbmRleCA6IHNwYW4udG8gPiBpbmRleCkgOiBvcmRlclttYXliZV0ubGV2ZWwgPiBzcGFuLmxldmVsKSlcbiAgICAgICAgICAgICAgICAgICAgbWF5YmUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXliZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIG1heWJlO1xuICAgIH1cbn1cbi8vIFJldXNlZCBhcnJheSBvZiBjaGFyYWN0ZXIgdHlwZXNcbmNvbnN0IHR5cGVzID0gW107XG5mdW5jdGlvbiBjb21wdXRlT3JkZXIobGluZSwgZGlyZWN0aW9uKSB7XG4gICAgbGV0IGxlbiA9IGxpbmUubGVuZ3RoLCBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMSAvKiBMICovIDogMiAvKiBSICovLCBvcHBvc2l0ZVR5cGUgPSBkaXJlY3Rpb24gPT0gTFRSID8gMiAvKiBSICovIDogMSAvKiBMICovO1xuICAgIGlmICghbGluZSB8fCBvdXRlclR5cGUgPT0gMSAvKiBMICovICYmICFCaWRpUkUudGVzdChsaW5lKSlcbiAgICAgICAgcmV0dXJuIHRyaXZpYWxPcmRlcihsZW4pO1xuICAgIC8vIFcxLiBFeGFtaW5lIGVhY2ggbm9uLXNwYWNpbmcgbWFyayAoTlNNKSBpbiB0aGUgbGV2ZWwgcnVuLCBhbmRcbiAgICAvLyBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIE5TTSB0byB0aGUgdHlwZSBvZiB0aGUgcHJldmlvdXNcbiAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc29yLlxuICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgQUwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuXG4gICAgLy8gQUwgaXMgZm91bmQsIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEFyYWJpY1xuICAgIC8vIG51bWJlci5cbiAgICAvLyBXMy4gQ2hhbmdlIGFsbCBBTHMgdG8gUi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTiwgQU4sIEVULCBDUywgTkkpXG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSBvdXRlclR5cGUsIHByZXZTdHJvbmcgPSBvdXRlclR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgdHlwZSA9IGNoYXJUeXBlKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGlmICh0eXBlID09IDUxMiAvKiBOU00gKi8pXG4gICAgICAgICAgICB0eXBlID0gcHJldjtcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA4IC8qIEVOICovICYmIHByZXZTdHJvbmcgPT0gNCAvKiBBTCAqLylcbiAgICAgICAgICAgIHR5cGUgPSAxNiAvKiBBTiAqLztcbiAgICAgICAgdHlwZXNbaV0gPSB0eXBlID09IDQgLyogQUwgKi8gPyAyIC8qIFIgKi8gOiB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogU3Ryb25nICovKVxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgIH1cbiAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhblxuICAgIC8vIG51bWJlcnMgY2hhbmdlcyB0byBhbGwgRXVyb3BlYW4gbnVtYmVycy5cbiAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAvLyBOZXV0cmFsLlxuICAgIC8vIFc3LiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgIC8vIHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoUiwgTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW4gTCBpc1xuICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgLy8gKExlZnQgYWZ0ZXIgdGhpczogTCwgUiwgRU4rQU4sIE5JKVxuICAgIGZvciAobGV0IGkgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlLCBwcmV2U3Ryb25nID0gb3V0ZXJUeXBlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gMTI4IC8qIENTICovKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEgJiYgcHJldiA9PSB0eXBlc1tpICsgMV0gJiYgKHByZXYgJiAyNCAvKiBOdW0gKi8pKVxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlc1tpXSA9IHByZXY7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHlwZXNbaV0gPSAyNTYgLyogTkkgKi87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSA2NCAvKiBFVCAqLykge1xuICAgICAgICAgICAgbGV0IGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IDY0IC8qIEVUICovKVxuICAgICAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICAgICAgbGV0IHJlcGxhY2UgPSAoaSAmJiBwcmV2ID09IDggLyogRU4gKi8pIHx8IChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSA4IC8qIEVOICovKSA/IChwcmV2U3Ryb25nID09IDEgLyogTCAqLyA/IDEgLyogTCAqLyA6IDggLyogRU4gKi8pIDogMjU2IC8qIE5JICovO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPCBlbmQ7IGorKylcbiAgICAgICAgICAgICAgICB0eXBlc1tqXSA9IHJlcGxhY2U7XG4gICAgICAgICAgICBpID0gZW5kIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDggLyogRU4gKi8gJiYgcHJldlN0cm9uZyA9PSAxIC8qIEwgKi8pIHtcbiAgICAgICAgICAgIHR5cGVzW2ldID0gMSAvKiBMICovO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSB0eXBlO1xuICAgICAgICBpZiAodHlwZSAmIDcgLyogU3Ryb25nICovKVxuICAgICAgICAgICAgcHJldlN0cm9uZyA9IHR5cGU7XG4gICAgfVxuICAgIC8vIE4wLiBQcm9jZXNzIGJyYWNrZXQgcGFpcnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZVxuICAgIC8vIHNlcXVlbnRpYWxseSBpbiB0aGUgbG9naWNhbCBvcmRlciBvZiB0aGUgdGV4dCBwb3NpdGlvbnMgb2YgdGhlXG4gICAgLy8gb3BlbmluZyBwYWlyZWQgYnJhY2tldHMgdXNpbmcgdGhlIGxvZ2ljIGdpdmVuIGJlbG93LiBXaXRoaW4gdGhpc1xuICAgIC8vIHNjb3BlLCBiaWRpcmVjdGlvbmFsIHR5cGVzIEVOIGFuZCBBTiBhcmUgdHJlYXRlZCBhcyBSLlxuICAgIGZvciAobGV0IGkgPSAwLCBzSSA9IDAsIGNvbnRleHQgPSAwLCBjaCwgYnIsIHR5cGU7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBLZWVwcyBbc3RhcnRJbmRleCwgdHlwZSwgc3Ryb25nU2Vlbl0gdHJpcGxlcyBmb3IgZWFjaCBvcGVuXG4gICAgICAgIC8vIGJyYWNrZXQgb24gQnJhY2tldFN0YWNrLlxuICAgICAgICBpZiAoYnIgPSBCcmFja2V0c1tjaCA9IGxpbmUuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgICAgIGlmIChiciA8IDApIHsgLy8gQ2xvc2luZyBicmFja2V0XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEJyYWNrZXRTdGFja1tzSiArIDFdID09IC1icikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IChmbGFncyAmIDIgLyogRW1iZWRJbnNpZGUgKi8pID8gb3V0ZXJUeXBlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgNCAvKiBPcHBvc2l0ZUluc2lkZSAqLykgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzICYgMSAvKiBPcHBvc2l0ZUJlZm9yZSAqLykgPyBvcHBvc2l0ZVR5cGUgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1tpXSA9IHR5cGVzW0JyYWNrZXRTdGFja1tzSl1dID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNJID0gc0o7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEJyYWNrZXRTdGFjay5sZW5ndGggPT0gMTg5IC8qIE1heERlcHRoICovKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0krK10gPSBpO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNoO1xuICAgICAgICAgICAgICAgIEJyYWNrZXRTdGFja1tzSSsrXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKHR5cGUgPSB0eXBlc1tpXSkgPT0gMiAvKiBSICovIHx8IHR5cGUgPT0gMSAvKiBMICovKSB7XG4gICAgICAgICAgICBsZXQgZW1iZWQgPSB0eXBlID09IG91dGVyVHlwZTtcbiAgICAgICAgICAgIGNvbnRleHQgPSBlbWJlZCA/IDAgOiAxIC8qIE9wcG9zaXRlQmVmb3JlICovO1xuICAgICAgICAgICAgZm9yIChsZXQgc0ogPSBzSSAtIDM7IHNKID49IDA7IHNKIC09IDMpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gQnJhY2tldFN0YWNrW3NKICsgMl07XG4gICAgICAgICAgICAgICAgaWYgKGN1ciAmIDIgLyogRW1iZWRJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChlbWJlZCkge1xuICAgICAgICAgICAgICAgICAgICBCcmFja2V0U3RhY2tbc0ogKyAyXSB8PSAyIC8qIEVtYmVkSW5zaWRlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ciAmIDQgLyogT3Bwb3NpdGVJbnNpZGUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgQnJhY2tldFN0YWNrW3NKICsgMl0gfD0gNCAvKiBPcHBvc2l0ZUluc2lkZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTjEuIEEgc2VxdWVuY2Ugb2YgbmV1dHJhbHMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGVcbiAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgIC8vIGRpcmVjdGlvbi4gRXVyb3BlYW4gYW5kIEFyYWJpYyBudW1iZXJzIGFjdCBhcyBpZiB0aGV5IHdlcmUgUiBpblxuICAgIC8vIHRlcm1zIG9mIHRoZWlyIGluZmx1ZW5jZSBvbiBuZXV0cmFscy4gU3RhcnQtb2YtbGV2ZWwtcnVuIChzb3IpXG4gICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgLy8gTjIuIEFueSByZW1haW5pbmcgbmV1dHJhbHMgdGFrZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi5cbiAgICAvLyAoTGVmdCBhZnRlciB0aGlzOiBMLCBSLCBFTitBTilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlc1tpXSA9PSAyNTYgLyogTkkgKi8pIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSAyNTYgLyogTkkgKi8pXG4gICAgICAgICAgICAgICAgZW5kKys7XG4gICAgICAgICAgICBsZXQgYmVmb3JlTCA9IChpID8gdHlwZXNbaSAtIDFdIDogb3V0ZXJUeXBlKSA9PSAxIC8qIEwgKi87XG4gICAgICAgICAgICBsZXQgYWZ0ZXJMID0gKGVuZCA8IGxlbiA/IHR5cGVzW2VuZF0gOiBvdXRlclR5cGUpID09IDEgLyogTCAqLztcbiAgICAgICAgICAgIGxldCByZXBsYWNlID0gYmVmb3JlTCA9PSBhZnRlckwgPyAoYmVmb3JlTCA/IDEgLyogTCAqLyA6IDIgLyogUiAqLykgOiBvdXRlclR5cGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA8IGVuZDsgaisrKVxuICAgICAgICAgICAgICAgIHR5cGVzW2pdID0gcmVwbGFjZTtcbiAgICAgICAgICAgIGkgPSBlbmQgLSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhlcmUgd2UgZGVwYXJ0IGZyb20gdGhlIGRvY3VtZW50ZWQgYWxnb3JpdGhtLCBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGJ1aWxkaW5nIHVwIGFuIGFjdHVhbCBsZXZlbHMgYXJyYXkuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlXG4gICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgIC8vIGV4cGxpY2l0IGVtYmVkZGluZyBpbnRvIGFjY291bnQsIHdlIGNhbiBidWlsZCB1cCB0aGUgb3JkZXIgb25cbiAgICAvLyB0aGUgZmx5LCB3aXRob3V0IGZvbGxvd2luZyB0aGUgbGV2ZWwtYmFzZWQgYWxnb3JpdGhtLlxuICAgIGxldCBvcmRlciA9IFtdO1xuICAgIGlmIChvdXRlclR5cGUgPT0gMSAvKiBMICovKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gaSwgcnRsID0gdHlwZXNbaSsrXSAhPSAxIC8qIEwgKi87XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBydGwgPT0gKHR5cGVzW2ldICE9IDEgLyogTCAqLykpXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKHJ0bCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqID4gc3RhcnQ7KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBqLCBsID0gdHlwZXNbLS1qXSAhPSAyIC8qIFIgKi87XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqID4gc3RhcnQgJiYgbCA9PSAodHlwZXNbaiAtIDFdICE9IDIgLyogUiAqLykpXG4gICAgICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKGosIGVuZCwgbCA/IDIgOiAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaChuZXcgQmlkaVNwYW4oc3RhcnQsIGksIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBpLCBydGwgPSB0eXBlc1tpKytdID09IDIgLyogUiAqLztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIHJ0bCA9PSAodHlwZXNbaV0gPT0gMiAvKiBSICovKSlcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbihzdGFydCwgaSwgcnRsID8gMSA6IDIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3JkZXI7XG59XG5mdW5jdGlvbiB0cml2aWFsT3JkZXIobGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtuZXcgQmlkaVNwYW4oMCwgbGVuZ3RoLCAwKV07XG59XG5sZXQgbW92ZWRPdmVyID0gXCJcIjtcbmZ1bmN0aW9uIG1vdmVWaXN1YWxseShsaW5lLCBvcmRlciwgZGlyLCBzdGFydCwgZm9yd2FyZCkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmhlYWQgLSBsaW5lLmZyb20sIHNwYW5JID0gLTE7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gMCkge1xuICAgICAgICBpZiAoIWZvcndhcmQgfHwgIWxpbmUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvcmRlclswXS5sZXZlbCAhPSBkaXIpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBvcmRlclswXS5zaWRlKGZhbHNlLCBkaXIpO1xuICAgICAgICAgICAgc3BhbkkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0SW5kZXggPT0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGZvcndhcmQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxhc3QgPSBvcmRlcltvcmRlci5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGxhc3QubGV2ZWwgIT0gZGlyKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbGFzdC5zaWRlKHRydWUsIGRpcik7XG4gICAgICAgICAgICBzcGFuSSA9IG9yZGVyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYW5JIDwgMClcbiAgICAgICAgc3BhbkkgPSBCaWRpU3Bhbi5maW5kKG9yZGVyLCBzdGFydEluZGV4LCAoX2EgPSBzdGFydC5iaWRpTGV2ZWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xLCBzdGFydC5hc3NvYyk7XG4gICAgbGV0IHNwYW4gPSBvcmRlcltzcGFuSV07XG4gICAgLy8gRW5kIG9mIHNwYW4uIChCdXQgbm90IGVuZCBvZiBsaW5lLS10aGF0IHdhcyBjaGVja2VkIGZvciBhYm92ZS4pXG4gICAgaWYgKHN0YXJ0SW5kZXggPT0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcikpIHtcbiAgICAgICAgc3BhbiA9IG9yZGVyW3NwYW5JICs9IGZvcndhcmQgPyAxIDogLTFdO1xuICAgICAgICBzdGFydEluZGV4ID0gc3Bhbi5zaWRlKCFmb3J3YXJkLCBkaXIpO1xuICAgIH1cbiAgICBsZXQgaW5kZXhGb3J3YXJkID0gZm9yd2FyZCA9PSAoc3Bhbi5kaXIgPT0gZGlyKTtcbiAgICBsZXQgbmV4dEluZGV4ID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIHN0YXJ0SW5kZXgsIGluZGV4Rm9yd2FyZCk7XG4gICAgbW92ZWRPdmVyID0gbGluZS50ZXh0LnNsaWNlKE1hdGgubWluKHN0YXJ0SW5kZXgsIG5leHRJbmRleCksIE1hdGgubWF4KHN0YXJ0SW5kZXgsIG5leHRJbmRleCkpO1xuICAgIGlmIChuZXh0SW5kZXggIT0gc3Bhbi5zaWRlKGZvcndhcmQsIGRpcikpXG4gICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgaW5kZXhGb3J3YXJkID8gLTEgOiAxLCBzcGFuLmxldmVsKTtcbiAgICBsZXQgbmV4dFNwYW4gPSBzcGFuSSA9PSAoZm9yd2FyZCA/IG9yZGVyLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBvcmRlcltzcGFuSSArIChmb3J3YXJkID8gMSA6IC0xKV07XG4gICAgaWYgKCFuZXh0U3BhbiAmJiBzcGFuLmxldmVsICE9IGRpcilcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZm9yd2FyZCA/IGxpbmUudG8gOiBsaW5lLmZyb20sIGZvcndhcmQgPyAtMSA6IDEsIGRpcik7XG4gICAgaWYgKG5leHRTcGFuICYmIG5leHRTcGFuLmxldmVsIDwgc3Bhbi5sZXZlbClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IobmV4dFNwYW4uc2lkZSghZm9yd2FyZCwgZGlyKSArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IDEgOiAtMSwgbmV4dFNwYW4ubGV2ZWwpO1xuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG5leHRJbmRleCArIGxpbmUuZnJvbSwgZm9yd2FyZCA/IC0xIDogMSwgc3Bhbi5sZXZlbCk7XG59XG5cbmNsYXNzIERPTVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCB2aWV3KSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmxpbmVCcmVhayA9IHZpZXcuc3RhdGUubGluZUJyZWFrO1xuICAgIH1cbiAgICByZWFkUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIXN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCBwYXJlbnQgPSBzdGFydC5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBzdGFydDs7KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEJlZm9yZShwYXJlbnQsIGN1cik7XG4gICAgICAgICAgICB0aGlzLnJlYWROb2RlKGN1cik7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICAgICAgICAgIGlmIChuZXh0ID09IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCB2aWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1ciksIG5leHRWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5leHQpO1xuICAgICAgICAgICAgaWYgKHZpZXcgJiYgbmV4dFZpZXcgPyB2aWV3LmJyZWFrQWZ0ZXIgOlxuICAgICAgICAgICAgICAgICh2aWV3ID8gdmlldy5icmVha0FmdGVyIDogaXNCbG9ja0VsZW1lbnQoY3VyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGlzQmxvY2tFbGVtZW50KG5leHQpICYmIChjdXIubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGN1ci5jbUlnbm9yZSkpKVxuICAgICAgICAgICAgICAgIHRoaXMudGV4dCArPSB0aGlzLmxpbmVCcmVhaztcbiAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kUG9pbnRCZWZvcmUocGFyZW50LCBlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVhZFRleHROb2RlKG5vZGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHRleHQgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgaWYgKC9eXFx1MjAwYi8udGVzdCh0ZXh0KSAmJiAoKF9hID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50RWRpdGFibGUpID09IFwiZmFsc2VcIilcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICBpZiAoL1xcdTIwMGIkLy50ZXN0KHRleHQpICYmICgoX2IgPSBub2RlLm5leHRTaWJsaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudEVkaXRhYmxlKSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgcmVhZE5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jbUlnbm9yZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHZpZXcgPSBDb250ZW50Vmlldy5nZXQobm9kZSk7XG4gICAgICAgIGxldCBmcm9tVmlldyA9IHZpZXcgJiYgdmlldy5vdmVycmlkZURPTVRleHQ7XG4gICAgICAgIGxldCB0ZXh0O1xuICAgICAgICBpZiAoZnJvbVZpZXcgIT0gbnVsbClcbiAgICAgICAgICAgIHRleHQgPSBmcm9tVmlldy5zbGljZVN0cmluZygwLCB1bmRlZmluZWQsIHRoaXMubGluZUJyZWFrKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMucmVhZFRleHROb2RlKG5vZGUpO1xuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIilcbiAgICAgICAgICAgIHRleHQgPSBub2RlLm5leHRTaWJsaW5nID8gdGhpcy5saW5lQnJlYWsgOiBcIlwiO1xuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpO1xuICAgICAgICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRQb2ludEluKG5vZGUsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudGV4dCArPSB0ZXh0O1xuICAgICAgICAgICAgLy8gQ2hyb21lIGluc2VydHMgdHdvIG5ld2xpbmVzIHdoZW4gcHJlc3Npbmcgc2hpZnQtZW50ZXIgYXQgdGhlXG4gICAgICAgICAgICAvLyBlbmQgb2YgYSBsaW5lLiBUaGlzIGRyb3BzIG9uZSBvZiB0aG9zZS5cbiAgICAgICAgICAgIGlmIChicm93c2VyLmNocm9tZSAmJiB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PSAxMyAmJiAhbm9kZS5uZXh0U2libGluZyAmJiAvXFxuXFxuJC8udGVzdCh0aGlzLnRleHQpKVxuICAgICAgICAgICAgICAgIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZFBvaW50QmVmb3JlKG5vZGUsIG5leHQpIHtcbiAgICAgICAgZm9yIChsZXQgcG9pbnQgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgICBpZiAocG9pbnQubm9kZSA9PSBub2RlICYmIG5vZGUuY2hpbGROb2Rlc1twb2ludC5vZmZzZXRdID09IG5leHQpXG4gICAgICAgICAgICAgICAgcG9pbnQucG9zID0gdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgZmluZFBvaW50SW4obm9kZSwgbWF4TGVuKSB7XG4gICAgICAgIGZvciAobGV0IHBvaW50IG9mIHRoaXMucG9pbnRzKVxuICAgICAgICAgICAgaWYgKHBvaW50Lm5vZGUgPT0gbm9kZSlcbiAgICAgICAgICAgICAgICBwb2ludC5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgTWF0aC5taW4ocG9pbnQub2Zmc2V0LCBtYXhMZW4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KG5vZGUubm9kZU5hbWUpO1xufVxuY2xhc3MgRE9NUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9mZnNldCkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5wb3MgPSAtMTtcbiAgICB9XG59XG5cbmNsYXNzIERvY1ZpZXcgZXh0ZW5kcyBDb250ZW50VmlldyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbkRlY29yYXRpb25MZW5ndGggPSAwO1xuICAgICAgICAvLyBUcmFjayBhIG1pbmltdW0gd2lkdGggZm9yIHRoZSBlZGl0b3IuIFdoZW4gbWVhc3VyaW5nIHNpemVzIGluXG4gICAgICAgIC8vIG1lYXN1cmVWaXNpYmxlTGluZUhlaWdodHMsIHRoaXMgaXMgdXBkYXRlZCB0byBwb2ludCBhdCB0aGUgd2lkdGhcbiAgICAgICAgLy8gb2YgYSBnaXZlbiBlbGVtZW50IGFuZCBpdHMgZXh0ZW50IGluIHRoZSBkb2N1bWVudC4gV2hlbiBhIGNoYW5nZVxuICAgICAgICAvLyBoYXBwZW5zIGluIHRoYXQgcmFuZ2UsIHRoZXNlIGFyZSByZXNldC4gVGhhdCB3YXksIG9uY2Ugd2UndmUgc2VlblxuICAgICAgICAvLyBhIGxpbmUvZWxlbWVudCBvZiBhIGdpdmVuIGxlbmd0aCwgd2Uga2VlcCB0aGUgZWRpdG9yIHdpZGUgZW5vdWdoXG4gICAgICAgIC8vIHRvIGZpdCBhdCBsZWFzdCB0aGF0IGVsZW1lbnQsIHVudGlsIGl0IGlzIGNoYW5nZWQsIGF0IHdoaWNoIHBvaW50XG4gICAgICAgIC8vIHdlIGZvcmdldCBpdCBhZ2Fpbi5cbiAgICAgICAgdGhpcy5taW5XaWR0aCA9IDA7XG4gICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gMDtcbiAgICAgICAgdGhpcy5taW5XaWR0aFRvID0gMDtcbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGUgRE9NIHNlbGVjdGlvbiB3YXMgc2V0IGluIGEgbG9zc3kgd2F5LCBzbyB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IG1lc3MgaXQgdXAgd2hlbiByZWFkaW5nIGl0IGJhY2sgaXRcbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBudWxsO1xuICAgICAgICB0aGlzLmltcHJlY2lzZUhlYWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFVzZWQgYnkgdGhlIHJlc2l6ZSBvYnNlcnZlciB0byBpZ25vcmUgcmVzaXplcyB0aGF0IHdlIGNhdXNlZFxuICAgICAgICAvLyBvdXJzZWx2ZXNcbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5zZXRET00odmlldy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGluZVZpZXddO1xuICAgICAgICB0aGlzLmNoaWxkcmVuWzBdLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIoW25ldyBDaGFuZ2VkUmFuZ2UoMCwgMCwgMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoKV0sIDApO1xuICAgIH1cbiAgICBnZXQgcm9vdCgpIHsgcmV0dXJuIHRoaXMudmlldy5yb290OyB9XG4gICAgZ2V0IGVkaXRvclZpZXcoKSB7IHJldHVybiB0aGlzLnZpZXc7IH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy52aWV3LnN0YXRlLmRvYy5sZW5ndGg7IH1cbiAgICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS4gc2Nyb2xsSW50b1ZpZXcgY2FuIGJlXG4gICAgLy8gdXNlZCBhcyBhIGhpbnQgdG8gY29tcHV0ZSBhIG5ldyB2aWV3cG9ydCB0aGF0IGluY2x1ZGVzIHRoYXRcbiAgICAvLyBwb3NpdGlvbiwgaWYgd2Uga25vdyB0aGUgZWRpdG9yIGlzIGdvaW5nIHRvIHNjcm9sbCB0aGF0IHBvc2l0aW9uXG4gICAgLy8gaW50byB2aWV3LlxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNoYW5nZWRSYW5nZXMgPSB1cGRhdGUuY2hhbmdlZFJhbmdlcztcbiAgICAgICAgaWYgKHRoaXMubWluV2lkdGggPiAwICYmIGNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRSYW5nZXMuZXZlcnkoKHsgZnJvbUEsIHRvQSB9KSA9PiB0b0EgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBmcm9tQSA+IHRoaXMubWluV2lkdGhUbykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gdGhpcy5taW5XaWR0aEZyb20gPSB0aGlzLm1pbldpZHRoVG8gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW5XaWR0aEZyb20gPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IHVwZGF0ZS5jaGFuZ2VzLm1hcFBvcyh0aGlzLm1pbldpZHRoVG8sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKVxuICAgICAgICAgICAgdGhpcy5jb21wb3NpdGlvbkRlY28gPSBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgIGVsc2UgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoIHx8IHRoaXMuZGlydHkpXG4gICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRGVjbyA9IGNvbXB1dGVDb21wb3NpdGlvbkRlY28odGhpcy52aWV3LCB1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBub2RlcyBhcm91bmQgdGhlIHNlbGVjdGlvbiBhcmUgbW92ZWQgdG8gYW5vdGhlclxuICAgICAgICAvLyBwYXJlbnQsIENocm9tZSBzb21ldGltZXMgcmVwb3J0cyBhIGRpZmZlcmVudCBzZWxlY3Rpb24gdGhyb3VnaFxuICAgICAgICAvLyBnZXRTZWxlY3Rpb24gdGhhbiB0aGUgb25lIHRoYXQgaXQgYWN0dWFsbHkgc2hvd3MgdG8gdGhlIHVzZXIuXG4gICAgICAgIC8vIFRoaXMgZm9yY2VzIGEgc2VsZWN0aW9uIHVwZGF0ZSB3aGVuIGxpbmVzIGFyZSBqb2luZWQgdG8gd29ya1xuICAgICAgICAvLyBhcm91bmQgdGhhdC4gSXNzdWUgIzU0XG4gICAgICAgIGlmICgoYnJvd3Nlci5pZSB8fCBicm93c2VyLmNocm9tZSkgJiYgIXRoaXMuY29tcG9zaXRpb25EZWNvLnNpemUgJiYgdXBkYXRlICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuZG9jLmxpbmVzICE9IHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5saW5lcylcbiAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICBsZXQgcHJldkRlY28gPSB0aGlzLmRlY29yYXRpb25zLCBkZWNvID0gdGhpcy51cGRhdGVEZWNvKCk7XG4gICAgICAgIGxldCBkZWNvRGlmZiA9IGZpbmRDaGFuZ2VkRGVjbyhwcmV2RGVjbywgZGVjbywgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICBjaGFuZ2VkUmFuZ2VzID0gQ2hhbmdlZFJhbmdlLmV4dGVuZFdpdGhSYW5nZXMoY2hhbmdlZFJhbmdlcywgZGVjb0RpZmYpO1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSAwIC8qIE5vdCAqLyAmJiBjaGFuZ2VkUmFuZ2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKGNoYW5nZWRSYW5nZXMsIHVwZGF0ZS5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVc2VkIGJ5IHVwZGF0ZSBhbmQgdGhlIGNvbnN0cnVjdG9yIGRvIHBlcmZvcm0gdGhlIGFjdHVhbCBET01cbiAgICAvLyB1cGRhdGVcbiAgICB1cGRhdGVJbm5lcihjaGFuZ2VzLCBvbGRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKGNoYW5nZXMsIG9sZExlbmd0aCk7XG4gICAgICAgIGxldCB7IG9ic2VydmVyIH0gPSB0aGlzLnZpZXc7XG4gICAgICAgIG9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBMb2NrIHRoZSBoZWlnaHQgZHVyaW5nIHJlZHJhd2luZywgc2luY2UgQ2hyb21lIHNvbWV0aW1lc1xuICAgICAgICAgICAgLy8gbWVzc2VzIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBkdXJpbmcgRE9NIG11dGF0aW9uICh0aG91Z2hcbiAgICAgICAgICAgIC8vIG5vIHJlbGF5b3V0IGlzIHRyaWdnZXJlZCBhbmQgSSBjYW5ub3QgaW1hZ2luZSBob3cgaXQgY2FuXG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB3aXRob3V0IGEgbGF5b3V0KVxuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gdGhpcy52aWV3LnZpZXdTdGF0ZS5jb250ZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUubWluV2lkdGggPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICAgICAgICAvLyBDaHJvbWUgd2lsbCBzb21ldGltZXMsIHdoZW4gRE9NIG11dGF0aW9ucyBvY2N1ciBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYXJvdW5kIHRoZSBzZWxlY3Rpb24sIGdldCBjb25mdXNlZCBhbmQgcmVwb3J0IGEgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gZnJvbSB0aGUgb25lIGl0IGRpc3BsYXlzIChpc3N1ZSAjMjE4KS4gVGhpcyB0cmllc1xuICAgICAgICAgICAgLy8gdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgICAgICAgICAgbGV0IHRyYWNrID0gYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5pb3MgPyB7IG5vZGU6IG9ic2VydmVyLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSwgd3JpdHRlbjogZmFsc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3luYyh0cmFjayk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gMCAvKiBOb3QgKi87XG4gICAgICAgICAgICBpZiAodHJhY2sgJiYgKHRyYWNrLndyaXR0ZW4gfHwgb2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlICE9IHRyYWNrLm5vZGUpKVxuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBnYXBzID0gW107XG4gICAgICAgIGlmICh0aGlzLnZpZXcudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXcudmlld3BvcnQudG8gPCB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgQmxvY2tXaWRnZXRWaWV3ICYmIGNoaWxkLndpZGdldCBpbnN0YW5jZW9mIEJsb2NrR2FwV2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICBnYXBzLnB1c2goY2hpbGQuZG9tKTtcbiAgICAgICAgb2JzZXJ2ZXIudXBkYXRlR2FwcyhnYXBzKTtcbiAgICB9XG4gICAgdXBkYXRlQ2hpbGRyZW4oY2hhbmdlcywgb2xkTGVuZ3RoKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSB0aGlzLmNoaWxkQ3Vyc29yKG9sZExlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaSA+PSAwID8gY2hhbmdlc1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0gPSBuZXh0O1xuICAgICAgICAgICAgbGV0IHsgY29udGVudCwgYnJlYWtBdFN0YXJ0LCBvcGVuU3RhcnQsIG9wZW5FbmQgfSA9IENvbnRlbnRCdWlsZGVyLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIGZyb21CLCB0b0IsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMucGx1Z2luRGVjb3JhdGlvbkxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgeyBpOiB0b0ksIG9mZjogdG9PZmYgfSA9IGN1cnNvci5maW5kUG9zKHRvQSwgMSk7XG4gICAgICAgICAgICBsZXQgeyBpOiBmcm9tSSwgb2ZmOiBmcm9tT2ZmIH0gPSBjdXJzb3IuZmluZFBvcyhmcm9tQSwgLTEpO1xuICAgICAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb21JLCBmcm9tT2ZmLCB0b0ksIHRvT2ZmLCBjb250ZW50LCBicmVha0F0U3RhcnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3luYyB0aGUgRE9NIHNlbGVjdGlvbiB0byB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgIHVwZGF0ZVNlbGVjdGlvbihtdXN0UmVhZCA9IGZhbHNlLCBmcm9tUG9pbnRlciA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtdXN0UmVhZClcbiAgICAgICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgaWYgKCEoZnJvbVBvaW50ZXIgfHwgdGhpcy5tYXlDb250cm9sU2VsZWN0aW9uKCkpIHx8XG4gICAgICAgICAgICBicm93c2VyLmlvcyAmJiB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5yYXBpZENvbXBvc2l0aW9uU3RhcnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBmb3JjZSA9IHRoaXMuZm9yY2VTZWxlY3Rpb247XG4gICAgICAgIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IG1haW4gPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgIC8vIEZJWE1FIG5lZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBzZWxlY3Rpb24gZmFsbHMgaW5zaWRlIGEgYmxvY2sgcmFuZ2VcbiAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMuZG9tQXRQb3MobWFpbi5hbmNob3IpO1xuICAgICAgICBsZXQgaGVhZCA9IG1haW4uZW1wdHkgPyBhbmNob3IgOiB0aGlzLmRvbUF0UG9zKG1haW4uaGVhZCk7XG4gICAgICAgIC8vIEFsd2F5cyByZXNldCBvbiBGaXJlZm94IHdoZW4gbmV4dCB0byBhbiB1bmVkaXRhYmxlIG5vZGUgdG9cbiAgICAgICAgLy8gYXZvaWQgaW52aXNpYmxlIGN1cnNvciBidWdzICgjMTExKVxuICAgICAgICBpZiAoYnJvd3Nlci5nZWNrbyAmJiBtYWluLmVtcHR5ICYmIGJldHdlZW5VbmVkaXRhYmxlKGFuY2hvcikpIHtcbiAgICAgICAgICAgIGxldCBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiBhbmNob3Iubm9kZS5pbnNlcnRCZWZvcmUoZHVtbXksIGFuY2hvci5ub2RlLmNoaWxkTm9kZXNbYW5jaG9yLm9mZnNldF0gfHwgbnVsbCkpO1xuICAgICAgICAgICAgYW5jaG9yID0gaGVhZCA9IG5ldyBET01Qb3MoZHVtbXksIDApO1xuICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb21TZWwgPSB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSBoZXJlLCBvciBpbiBhbiBlcXVpdmFsZW50IHBvc2l0aW9uLCBkb24ndCB0b3VjaCBpdFxuICAgICAgICBpZiAoZm9yY2UgfHwgIWRvbVNlbC5mb2N1c05vZGUgfHxcbiAgICAgICAgICAgICFpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpIHx8XG4gICAgICAgICAgICAhaXNFcXVpdmFsZW50UG9zaXRpb24oaGVhZC5ub2RlLCBoZWFkLm9mZnNldCwgZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLmlnbm9yZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIEFuZHJvaWQgd2lsbCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkIHdoZW4gdGFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiB1bmVkaXRhYmxlIG5vZGUsIGFuZCBub3QgYnJpbmcgaXQgYmFjayB3aGVuIHdlXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIHRvIGl0cyBwcm9wZXIgcG9zaXRpb24uIFRoaXMgdHJpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBrZXlib2FyZCBieSBjeWNsaW5nIGZvY3VzLlxuICAgICAgICAgICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnMoZG9tU2VsLmZvY3VzTm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5VbmVkaXRhYmxlKGRvbVNlbC5mb2N1c05vZGUsIHRoaXMuZG9tKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJhd1NlbCA9IGdldFNlbGVjdGlvbih0aGlzLnJvb3QpO1xuICAgICAgICAgICAgICAgIGlmIChtYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MTIwNzZcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuZ2Vja28pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0VG8gPSBuZXh0VG9VbmVkaXRhYmxlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0VG8gJiYgbmV4dFRvICE9ICgxIC8qIEJlZm9yZSAqLyB8IDIgLyogQWZ0ZXIgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZWFyYnlUZXh0Tm9kZShhbmNob3Iubm9kZSwgYW5jaG9yLm9mZnNldCwgbmV4dFRvID09IDEgLyogQmVmb3JlICovID8gMSA6IC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gbmV3IERPTVBvcyh0ZXh0LCBuZXh0VG8gPT0gMSAvKiBCZWZvcmUgKi8gPyAwIDogdGV4dC5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYXdTZWwuY29sbGFwc2UoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5iaWRpTGV2ZWwgIT0gbnVsbCAmJiBkb21TZWwuY3Vyc29yQmlkaUxldmVsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21TZWwuY3Vyc29yQmlkaUxldmVsID0gbWFpbi5iaWRpTGV2ZWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhd1NlbC5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAgICAgICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmNvbGxhcHNlKGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLmV4dGVuZChoZWFkLm5vZGUsIGhlYWQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByaW1pdGl2ZSAoSUUpIHdheVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbi5hbmNob3IgPiBtYWluLmhlYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBbYW5jaG9yLCBoZWFkXSA9IFtoZWFkLCBhbmNob3JdO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmQoaGVhZC5ub2RlLCBoZWFkLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvci5ub2RlLCBhbmNob3Iub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmF3U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICByYXdTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy52aWV3Lm9ic2VydmVyLnNldFNlbGVjdGlvblJhbmdlKGFuY2hvciwgaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbXByZWNpc2VBbmNob3IgPSBhbmNob3IucHJlY2lzZSA/IG51bGwgOiBuZXcgRE9NUG9zKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5pbXByZWNpc2VIZWFkID0gaGVhZC5wcmVjaXNlID8gbnVsbCA6IG5ldyBET01Qb3MoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5mb3JjZUN1cnNvckFzc29jKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wb3NpdGlvbkRlY28uc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGN1cnNvciA9IHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgbGV0IHNlbCA9IGdldFNlbGVjdGlvbih0aGlzLnJvb3QpO1xuICAgICAgICBpZiAoIWN1cnNvci5lbXB0eSB8fCAhY3Vyc29yLmFzc29jIHx8ICFzZWwubW9kaWZ5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbGluZSA9IExpbmVWaWV3LmZpbmQodGhpcywgY3Vyc29yLmhlYWQpO1xuICAgICAgICBpZiAoIWxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBsaW5lLnBvc0F0U3RhcnQ7XG4gICAgICAgIGlmIChjdXJzb3IuaGVhZCA9PSBsaW5lU3RhcnQgfHwgY3Vyc29yLmhlYWQgPT0gbGluZVN0YXJ0ICsgbGluZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvb3Jkc0F0KGN1cnNvci5oZWFkLCAtMSksIGFmdGVyID0gdGhpcy5jb29yZHNBdChjdXJzb3IuaGVhZCwgMSk7XG4gICAgICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCBiZWZvcmUuYm90dG9tID4gYWZ0ZXIudG9wKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZG9tID0gdGhpcy5kb21BdFBvcyhjdXJzb3IuaGVhZCArIGN1cnNvci5hc3NvYyk7XG4gICAgICAgIHNlbC5jb2xsYXBzZShkb20ubm9kZSwgZG9tLm9mZnNldCk7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGN1cnNvci5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgfVxuICAgIG1heUNvbnRyb2xTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpID8gdGhpcy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb21cbiAgICAgICAgICAgIDogaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cbiAgICBuZWFyZXN0KGRvbSkge1xuICAgICAgICBmb3IgKGxldCBjdXIgPSBkb207IGN1cjspIHtcbiAgICAgICAgICAgIGxldCBkb21WaWV3ID0gQ29udGVudFZpZXcuZ2V0KGN1cik7XG4gICAgICAgICAgICBpZiAoZG9tVmlldyAmJiBkb21WaWV3LnJvb3RWaWV3ID09IHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbVZpZXc7XG4gICAgICAgICAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcG9zRnJvbURPTShub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5lYXJlc3Qobm9kZSk7XG4gICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGZpbmQgcG9zaXRpb24gZm9yIGEgRE9NIHBvc2l0aW9uIG91dHNpZGUgb2YgdGhlIGRvY3VtZW50XCIpO1xuICAgICAgICByZXR1cm4gdmlldy5sb2NhbFBvc0Zyb21ET00obm9kZSwgb2Zmc2V0KSArIHZpZXcucG9zQXRTdGFydDtcbiAgICB9XG4gICAgZG9tQXRQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IGksIG9mZiB9ID0gdGhpcy5jaGlsZEN1cnNvcigpLmZpbmRQb3MocG9zLCAtMSk7XG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChvZmYgPCBjaGlsZC5sZW5ndGggfHwgY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV0uZG9tQXRQb3Mob2ZmKTtcbiAgICB9XG4gICAgY29vcmRzQXQocG9zLCBzaWRlKSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRoaXMubGVuZ3RoLCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzdGFydCA9IG9mZiAtIGNoaWxkLmJyZWFrQWZ0ZXIgLSBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zID4gc3RhcnQgfHxcbiAgICAgICAgICAgICAgICAocG9zID09IHN0YXJ0ICYmIGNoaWxkLnR5cGUgIT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSAmJiBjaGlsZC50eXBlICE9IEJsb2NrVHlwZS5XaWRnZXRBZnRlciAmJlxuICAgICAgICAgICAgICAgICAgICAoIWkgfHwgc2lkZSA9PSAyIHx8IHRoaXMuY2hpbGRyZW5baSAtIDFdLmJyZWFrQWZ0ZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmNoaWxkcmVuW2kgLSAxXS50eXBlID09IEJsb2NrVHlwZS5XaWRnZXRCZWZvcmUgJiYgc2lkZSA+IC0yKSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5jb29yZHNBdChwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICBvZmYgPSBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlVmlzaWJsZUxpbmVIZWlnaHRzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHsgZnJvbSwgdG8gfSA9IHRoaXMudmlldy52aWV3U3RhdGUudmlld3BvcnQ7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSB0aGlzLnZpZXcuY29udGVudERPTS5jbGllbnRXaWR0aDtcbiAgICAgICAgbGV0IGlzV2lkZXIgPSBjb250ZW50V2lkdGggPiBNYXRoLm1heCh0aGlzLnZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCB0aGlzLm1pbldpZHRoKSArIDE7XG4gICAgICAgIGxldCB3aWRlc3QgPSAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRSZWN0ID0gY2hpbGQuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkUmVjdC5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc1dpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gY2hpbGQuZG9tLmxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3RzID0gbGFzdCA/IGNsaWVudFJlY3RzRm9yKGxhc3QpIDogW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbcmVjdHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSID8gcmVjdC5yaWdodCAtIGNoaWxkUmVjdC5sZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGlsZFJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPiB3aWRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRlc3QgPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbldpZHRoID0gY29udGVudFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhGcm9tID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWluV2lkdGhUbyA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZCArIGNoaWxkLmJyZWFrQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbWVhc3VyZVRleHRTaXplKCkge1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBMaW5lVmlldykge1xuICAgICAgICAgICAgICAgIGxldCBtZWFzdXJlID0gY2hpbGQubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lYXN1cmUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZWFzdXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIHdvcmthYmxlIGxpbmUgZXhpc3RzLCBmb3JjZSBhIGxheW91dCBvZiBhIG1lYXN1cmFibGUgZWxlbWVudFxuICAgICAgICBsZXQgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBsaW5lSGVpZ2h0LCBjaGFyV2lkdGg7XG4gICAgICAgIGR1bW15LmNsYXNzTmFtZSA9IFwiY20tbGluZVwiO1xuICAgICAgICBkdW1teS50ZXh0Q29udGVudCA9IFwiYWJjIGRlZiBnaGkgamtsIG1ubyBwcXIgc3R1XCI7XG4gICAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQoZHVtbXkpO1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBjbGllbnRSZWN0c0ZvcihkdW1teS5maXJzdENoaWxkKVswXTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBkdW1teS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgICBjaGFyV2lkdGggPSByZWN0ID8gcmVjdC53aWR0aCAvIDI3IDogNztcbiAgICAgICAgICAgIGR1bW15LnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgbGluZUhlaWdodCwgY2hhcldpZHRoIH07XG4gICAgfVxuICAgIGNoaWxkQ3Vyc29yKHBvcyA9IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIE1vdmUgYmFjayB0byBzdGFydCBvZiBsYXN0IGVsZW1lbnQgd2hlbiBwb3NzaWJsZSwgc28gdGhhdFxuICAgICAgICAvLyBgQ2hpbGRDdXJzb3IuZmluZFBvc2AgZG9lc24ndCBoYXZlIHRvIGRlYWwgd2l0aCB0aGUgZWRnZSBjYXNlXG4gICAgICAgIC8vIG9mIGJlaW5nIGFmdGVyIHRoZSBsYXN0IGVsZW1lbnQuXG4gICAgICAgIGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgICAgcG9zIC09IHRoaXMuY2hpbGRyZW5bLS1pXS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgQ2hpbGRDdXJzb3IodGhpcy5jaGlsZHJlbiwgcG9zLCBpKTtcbiAgICB9XG4gICAgY29tcHV0ZUJsb2NrR2FwRGVjbygpIHtcbiAgICAgICAgbGV0IGRlY28gPSBbXSwgdnMgPSB0aGlzLnZpZXcudmlld1N0YXRlO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBpID09IHZzLnZpZXdwb3J0cy5sZW5ndGggPyBudWxsIDogdnMudmlld3BvcnRzW2ldO1xuICAgICAgICAgICAgbGV0IGVuZCA9IG5leHQgPyBuZXh0LmZyb20gLSAxIDogdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZW5kID4gcG9zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IHZzLmxpbmVCbG9ja0F0KGVuZCkuYm90dG9tIC0gdnMubGluZUJsb2NrQXQocG9zKS50b3A7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKERlY29yYXRpb24ucmVwbGFjZSh7IHdpZGdldDogbmV3IEJsb2NrR2FwV2lkZ2V0KGhlaWdodCksIGJsb2NrOiB0cnVlLCBpbmNsdXNpdmU6IHRydWUgfSkucmFuZ2UocG9zLCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG4gICAgdXBkYXRlRGVjbygpIHtcbiAgICAgICAgbGV0IHBsdWdpbkRlY29yYXRpb25zID0gdGhpcy52aWV3LnBsdWdpbkZpZWxkKFBsdWdpbkZpZWxkLmRlY29yYXRpb25zKTtcbiAgICAgICAgdGhpcy5wbHVnaW5EZWNvcmF0aW9uTGVuZ3RoID0gcGx1Z2luRGVjb3JhdGlvbnMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvcmF0aW9ucyA9IFtcbiAgICAgICAgICAgIC4uLnBsdWdpbkRlY29yYXRpb25zLFxuICAgICAgICAgICAgLi4udGhpcy52aWV3LnN0YXRlLmZhY2V0KGRlY29yYXRpb25zKSxcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25EZWNvLFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlQmxvY2tHYXBEZWNvKCksXG4gICAgICAgICAgICB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVHYXBEZWNvXG4gICAgICAgIF07XG4gICAgfVxuICAgIHNjcm9sbEludG9WaWV3KHRhcmdldCkge1xuICAgICAgICBsZXQgeyByYW5nZSB9ID0gdGFyZ2V0O1xuICAgICAgICBsZXQgcmVjdCA9IHRoaXMuY29vcmRzQXQocmFuZ2UuaGVhZCwgcmFuZ2UuZW1wdHkgPyByYW5nZS5hc3NvYyA6IHJhbmdlLmhlYWQgPiByYW5nZS5hbmNob3IgPyAtMSA6IDEpLCBvdGhlcjtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5ICYmIChvdGhlciA9IHRoaXMuY29vcmRzQXQocmFuZ2UuYW5jaG9yLCByYW5nZS5hbmNob3IgPiByYW5nZS5oZWFkID8gLTEgOiAxKSkpXG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBNYXRoLm1pbihyZWN0LmxlZnQsIG90aGVyLmxlZnQpLCB0b3A6IE1hdGgubWluKHJlY3QudG9wLCBvdGhlci50b3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChyZWN0LnJpZ2h0LCBvdGhlci5yaWdodCksIGJvdHRvbTogTWF0aC5tYXgocmVjdC5ib3R0b20sIG90aGVyLmJvdHRvbSkgfTtcbiAgICAgICAgbGV0IG1MZWZ0ID0gMCwgbVJpZ2h0ID0gMCwgbVRvcCA9IDAsIG1Cb3R0b20gPSAwO1xuICAgICAgICBmb3IgKGxldCBtYXJnaW5zIG9mIHRoaXMudmlldy5wbHVnaW5GaWVsZChQbHVnaW5GaWVsZC5zY3JvbGxNYXJnaW5zKSlcbiAgICAgICAgICAgIGlmIChtYXJnaW5zKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tIH0gPSBtYXJnaW5zO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1MZWZ0ID0gTWF0aC5tYXgobUxlZnQsIGxlZnQpO1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtUmlnaHQgPSBNYXRoLm1heChtUmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAodG9wICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG1Ub3AgPSBNYXRoLm1heChtVG9wLCB0b3ApO1xuICAgICAgICAgICAgICAgIGlmIChib3R0b20gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgbUJvdHRvbSA9IE1hdGgubWF4KG1Cb3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0IC0gbUxlZnQsIHRvcDogcmVjdC50b3AgLSBtVG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBtUmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gKyBtQm90dG9tXG4gICAgICAgIH07XG4gICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLnZpZXcuc2Nyb2xsRE9NLCB0YXJnZXRSZWN0LCByYW5nZS5oZWFkIDwgcmFuZ2UuYW5jaG9yID8gLTEgOiAxLCB0YXJnZXQueCwgdGFyZ2V0LnksIHRhcmdldC54TWFyZ2luLCB0YXJnZXQueU1hcmdpbiwgdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gRGlyZWN0aW9uLkxUUik7XG4gICAgfVxufVxuZnVuY3Rpb24gYmV0d2VlblVuZWRpdGFibGUocG9zKSB7XG4gICAgcmV0dXJuIHBvcy5ub2RlLm5vZGVUeXBlID09IDEgJiYgcG9zLm5vZGUuZmlyc3RDaGlsZCAmJlxuICAgICAgICAocG9zLm9mZnNldCA9PSAwIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldCAtIDFdLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgIChwb3Mub2Zmc2V0ID09IHBvcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHBvcy5ub2RlLmNoaWxkTm9kZXNbcG9zLm9mZnNldF0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIik7XG59XG5jbGFzcyBCbG9ja0dhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdG9ET00oKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnVwZGF0ZURPTShlbHQpO1xuICAgICAgICByZXR1cm4gZWx0O1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0OyB9XG4gICAgdXBkYXRlRE9NKGVsdCkge1xuICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBnZXQgZXN0aW1hdGVkSGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5oZWlnaHQ7IH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2l0aW9uU3Vycm91bmRpbmdOb2RlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBsZXQgdGV4dE5vZGUgPSBzZWwuZm9jdXNOb2RlICYmIG5lYXJieVRleHROb2RlKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgMCk7XG4gICAgaWYgKCF0ZXh0Tm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGNWaWV3ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QodGV4dE5vZGUpO1xuICAgIGlmICghY1ZpZXcpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChjVmlldyBpbnN0YW5jZW9mIExpbmVWaWV3KSB7XG4gICAgICAgIGxldCB0b3BOb2RlID0gdGV4dE5vZGU7XG4gICAgICAgIHdoaWxlICh0b3BOb2RlLnBhcmVudE5vZGUgIT0gY1ZpZXcuZG9tKVxuICAgICAgICAgICAgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgbGV0IHByZXYgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgd2hpbGUgKHByZXYgJiYgIUNvbnRlbnRWaWV3LmdldChwcmV2KSlcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnByZXZpb3VzU2libGluZztcbiAgICAgICAgbGV0IHBvcyA9IHByZXYgPyBDb250ZW50Vmlldy5nZXQocHJldikucG9zQXRFbmQgOiBjVmlldy5wb3NBdFN0YXJ0O1xuICAgICAgICByZXR1cm4geyBmcm9tOiBwb3MsIHRvOiBwb3MsIG5vZGU6IHRvcE5vZGUsIHRleHQ6IHRleHROb2RlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgeyBwYXJlbnQgfSA9IGNWaWV3O1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgTGluZVZpZXcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjVmlldyA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbSA9IGNWaWV3LnBvc0F0U3RhcnQ7XG4gICAgICAgIHJldHVybiB7IGZyb20sIHRvOiBmcm9tICsgY1ZpZXcubGVuZ3RoLCBub2RlOiBjVmlldy5kb20sIHRleHQ6IHRleHROb2RlIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUNvbXBvc2l0aW9uRGVjbyh2aWV3LCBjaGFuZ2VzKSB7XG4gICAgbGV0IHN1cnJvdW5kaW5nID0gY29tcG9zaXRpb25TdXJyb3VuZGluZ05vZGUodmlldyk7XG4gICAgaWYgKCFzdXJyb3VuZGluZylcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICBsZXQgeyBmcm9tLCB0bywgbm9kZSwgdGV4dDogdGV4dE5vZGUgfSA9IHN1cnJvdW5kaW5nO1xuICAgIGxldCBuZXdGcm9tID0gY2hhbmdlcy5tYXBQb3MoZnJvbSwgMSksIG5ld1RvID0gTWF0aC5tYXgobmV3RnJvbSwgY2hhbmdlcy5tYXBQb3ModG8sIC0xKSk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHRleHQgPSBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZSA6XG4gICAgICAgIG5ldyBET01SZWFkZXIoW10sIHZpZXcpLnJlYWRSYW5nZShub2RlLmZpcnN0Q2hpbGQsIG51bGwpLnRleHQ7XG4gICAgaWYgKG5ld1RvIC0gbmV3RnJvbSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zbGljZURvYyhuZXdGcm9tLCBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBuZXdGcm9tICsgdGV4dC5sZW5ndGgpKSA9PSB0ZXh0KVxuICAgICAgICAgICAgbmV3VG8gPSBuZXdGcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnNsaWNlRG9jKE1hdGgubWF4KDAsIG5ld1RvIC0gdGV4dC5sZW5ndGgpLCBuZXdUbykgPT0gdGV4dClcbiAgICAgICAgICAgIG5ld0Zyb20gPSBuZXdUbyAtIHRleHQubGVuZ3RoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5zbGljZURvYyhuZXdGcm9tLCBuZXdUbykgIT0gdGV4dCkge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICByZXR1cm4gRGVjb3JhdGlvbi5zZXQoRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgQ29tcG9zaXRpb25XaWRnZXQobm9kZSwgdGV4dE5vZGUpIH0pLnJhbmdlKG5ld0Zyb20sIG5ld1RvKSk7XG59XG5jbGFzcyBDb21wb3NpdGlvbldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgdGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMudG9wID09IG90aGVyLnRvcCAmJiB0aGlzLnRleHQgPT0gb3RoZXIudGV4dDsgfVxuICAgIHRvRE9NKCkgeyByZXR1cm4gdGhpcy50b3A7IH1cbiAgICBpZ25vcmVFdmVudCgpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgZ2V0IGN1c3RvbVZpZXcoKSB7IHJldHVybiBDb21wb3NpdGlvblZpZXc7IH1cbn1cbmZ1bmN0aW9uIG5lYXJieVRleHROb2RlKG5vZGUsIG9mZnNldCwgc2lkZSkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDAgJiYgc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICYmIHNpZGUgPj0gMCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbmV4dFRvVW5lZGl0YWJsZShub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICByZXR1cm4gKG9mZnNldCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV0uY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IDEgLyogQmVmb3JlICovIDogMCkgfFxuICAgICAgICAob2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiAvKiBBZnRlciAqLyA6IDApO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBjb21wYXJlUmFuZ2UoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbiAgICBjb21wYXJlUG9pbnQoZnJvbSwgdG8pIHsgYWRkUmFuZ2UoZnJvbSwgdG8sIHRoaXMuY2hhbmdlcyk7IH1cbn1cbmZ1bmN0aW9uIGZpbmRDaGFuZ2VkRGVjbyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3IkMTtcbiAgICBSYW5nZVNldC5jb21wYXJlKGEsIGIsIGRpZmYsIGNvbXApO1xuICAgIHJldHVybiBjb21wLmNoYW5nZXM7XG59XG5mdW5jdGlvbiBpblVuZWRpdGFibGUobm9kZSwgaW5zaWRlKSB7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyICYmIGN1ciAhPSBpbnNpZGU7IGN1ciA9IGN1ci5hc3NpZ25lZFNsb3QgfHwgY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKGN1ci5ub2RlVHlwZSA9PSAxICYmIGN1ci5jb250ZW50RWRpdGFibGUgPT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBncm91cEF0KHN0YXRlLCBwb3MsIGJpYXMgPSAxKSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocG9zKTtcbiAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKSwgbGluZVBvcyA9IHBvcyAtIGxpbmUuZnJvbTtcbiAgICBpZiAobGluZS5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKTtcbiAgICBpZiAobGluZVBvcyA9PSAwKVxuICAgICAgICBiaWFzID0gMTtcbiAgICBlbHNlIGlmIChsaW5lUG9zID09IGxpbmUubGVuZ3RoKVxuICAgICAgICBiaWFzID0gLTE7XG4gICAgbGV0IGZyb20gPSBsaW5lUG9zLCB0byA9IGxpbmVQb3M7XG4gICAgaWYgKGJpYXMgPCAwKVxuICAgICAgICBmcm9tID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MsIGZhbHNlKTtcbiAgICBlbHNlXG4gICAgICAgIHRvID0gZmluZENsdXN0ZXJCcmVhayhsaW5lLnRleHQsIGxpbmVQb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShmcm9tLCB0bykpO1xuICAgIHdoaWxlIChmcm9tID4gMCkge1xuICAgICAgICBsZXQgcHJldiA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCBmcm9tLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZShwcmV2LCBmcm9tKSkgIT0gY2F0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZyb20gPSBwcmV2O1xuICAgIH1cbiAgICB3aGlsZSAodG8gPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IGZpbmRDbHVzdGVyQnJlYWsobGluZS50ZXh0LCB0byk7XG4gICAgICAgIGlmIChjYXRlZ29yaXplKGxpbmUudGV4dC5zbGljZSh0bywgbmV4dCkpICE9IGNhdClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0byA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoZnJvbSArIGxpbmUuZnJvbSwgdG8gKyBsaW5lLmZyb20pO1xufVxuLy8gU2VhcmNoIHRoZSBET00gZm9yIHRoZSB7bm9kZSwgb2Zmc2V0fSBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlblxuLy8gY29vcmRpbmF0ZXMuIFZlcnkgaW5lZmZpY2llbnQgYW5kIGNydWRlLCBidXQgY2FuIHVzdWFsbHkgYmUgYXZvaWRlZFxuLy8gYnkgY2FsbGluZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgaW5zdGVhZC5cbmZ1bmN0aW9uIGdldGR4KHgsIHJlY3QpIHtcbiAgICByZXR1cm4gcmVjdC5sZWZ0ID4geCA/IHJlY3QubGVmdCAtIHggOiBNYXRoLm1heCgwLCB4IC0gcmVjdC5yaWdodCk7XG59XG5mdW5jdGlvbiBnZXRkeSh5LCByZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wID4geSA/IHJlY3QudG9wIC0geSA6IE1hdGgubWF4KDAsIHkgLSByZWN0LmJvdHRvbSk7XG59XG5mdW5jdGlvbiB5T3ZlcmxhcChhLCBiKSB7XG4gICAgcmV0dXJuIGEudG9wIDwgYi5ib3R0b20gLSAxICYmIGEuYm90dG9tID4gYi50b3AgKyAxO1xufVxuZnVuY3Rpb24gdXBUb3AocmVjdCwgdG9wKSB7XG4gICAgcmV0dXJuIHRvcCA8IHJlY3QudG9wID8geyB0b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbTogcmVjdC5ib3R0b20gfSA6IHJlY3Q7XG59XG5mdW5jdGlvbiB1cEJvdChyZWN0LCBib3R0b20pIHtcbiAgICByZXR1cm4gYm90dG9tID4gcmVjdC5ib3R0b20gPyB7IHRvcDogcmVjdC50b3AsIGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QucmlnaHQsIGJvdHRvbSB9IDogcmVjdDtcbn1cbmZ1bmN0aW9uIGRvbVBvc0F0Q29vcmRzKHBhcmVudCwgeCwgeSkge1xuICAgIGxldCBjbG9zZXN0LCBjbG9zZXN0UmVjdCwgY2xvc2VzdFgsIGNsb3Nlc3RZO1xuICAgIGxldCBhYm92ZSwgYmVsb3csIGFib3ZlUmVjdCwgYmVsb3dSZWN0O1xuICAgIGZvciAobGV0IGNoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCByZWN0cyA9IGNsaWVudFJlY3RzRm9yKGNoaWxkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0UmVjdCAmJiB5T3ZlcmxhcChjbG9zZXN0UmVjdCwgcmVjdCkpXG4gICAgICAgICAgICAgICAgcmVjdCA9IHVwVG9wKHVwQm90KHJlY3QsIGNsb3Nlc3RSZWN0LmJvdHRvbSksIGNsb3Nlc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICBsZXQgZHggPSBnZXRkeCh4LCByZWN0KSwgZHkgPSBnZXRkeSh5LCByZWN0KTtcbiAgICAgICAgICAgIGlmIChkeCA9PSAwICYmIGR5ID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLm5vZGVUeXBlID09IDMgPyBkb21Qb3NJblRleHQoY2hpbGQsIHgsIHkpIDogZG9tUG9zQXRDb29yZHMoY2hpbGQsIHgsIHkpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0IHx8IGNsb3Nlc3RZID4gZHkgfHwgY2xvc2VzdFkgPT0gZHkgJiYgY2xvc2VzdFggPiBkeCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFggPSBkeDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0WSA9IGR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR4ID09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoeSA+IHJlY3QuYm90dG9tICYmICghYWJvdmVSZWN0IHx8IGFib3ZlUmVjdC5ib3R0b20gPCByZWN0LmJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYWJvdmVSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeSA8IHJlY3QudG9wICYmICghYmVsb3dSZWN0IHx8IGJlbG93UmVjdC50b3AgPiByZWN0LnRvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3cgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmVsb3dSZWN0ID0gcmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhYm92ZVJlY3QgJiYgeU92ZXJsYXAoYWJvdmVSZWN0LCByZWN0KSkge1xuICAgICAgICAgICAgICAgIGFib3ZlUmVjdCA9IHVwQm90KGFib3ZlUmVjdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmVsb3dSZWN0ICYmIHlPdmVybGFwKGJlbG93UmVjdCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICBiZWxvd1JlY3QgPSB1cFRvcChiZWxvd1JlY3QsIHJlY3QudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWJvdmVSZWN0ICYmIGFib3ZlUmVjdC5ib3R0b20gPj0geSkge1xuICAgICAgICBjbG9zZXN0ID0gYWJvdmU7XG4gICAgICAgIGNsb3Nlc3RSZWN0ID0gYWJvdmVSZWN0O1xuICAgIH1cbiAgICBlbHNlIGlmIChiZWxvd1JlY3QgJiYgYmVsb3dSZWN0LnRvcCA8PSB5KSB7XG4gICAgICAgIGNsb3Nlc3QgPSBiZWxvdztcbiAgICAgICAgY2xvc2VzdFJlY3QgPSBiZWxvd1JlY3Q7XG4gICAgfVxuICAgIGlmICghY2xvc2VzdClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogcGFyZW50LCBvZmZzZXQ6IDAgfTtcbiAgICBsZXQgY2xpcFggPSBNYXRoLm1heChjbG9zZXN0UmVjdC5sZWZ0LCBNYXRoLm1pbihjbG9zZXN0UmVjdC5yaWdodCwgeCkpO1xuICAgIGlmIChjbG9zZXN0Lm5vZGVUeXBlID09IDMpXG4gICAgICAgIHJldHVybiBkb21Qb3NJblRleHQoY2xvc2VzdCwgY2xpcFgsIHkpO1xuICAgIGlmICghY2xvc2VzdFggJiYgY2xvc2VzdC5jb250ZW50RWRpdGFibGUgPT0gXCJ0cnVlXCIpXG4gICAgICAgIHJldHVybiBkb21Qb3NBdENvb3JkcyhjbG9zZXN0LCBjbGlwWCwgeSk7XG4gICAgbGV0IG9mZnNldCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkTm9kZXMsIGNsb3Nlc3QpICtcbiAgICAgICAgKHggPj0gKGNsb3Nlc3RSZWN0LmxlZnQgKyBjbG9zZXN0UmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgIHJldHVybiB7IG5vZGU6IHBhcmVudCwgb2Zmc2V0IH07XG59XG5mdW5jdGlvbiBkb21Qb3NJblRleHQobm9kZSwgeCwgeSkge1xuICAgIGxldCBsZW4gPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgbGV0IGNsb3Nlc3RPZmZzZXQgPSAtMSwgY2xvc2VzdERZID0gMWU5LCBnZW5lcmFsU2lkZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcmVjdHMgPSB0ZXh0UmFuZ2Uobm9kZSwgaSwgaSArIDEpLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcmVjdHNbal07XG4gICAgICAgICAgICBpZiAocmVjdC50b3AgPT0gcmVjdC5ib3R0b20pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWdlbmVyYWxTaWRlKVxuICAgICAgICAgICAgICAgIGdlbmVyYWxTaWRlID0geCAtIHJlY3QubGVmdDtcbiAgICAgICAgICAgIGxldCBkeSA9IChyZWN0LnRvcCA+IHkgPyByZWN0LnRvcCAtIHkgOiB5IC0gcmVjdC5ib3R0b20pIC0gMTtcbiAgICAgICAgICAgIGlmIChyZWN0LmxlZnQgLSAxIDw9IHggJiYgcmVjdC5yaWdodCArIDEgPj0geCAmJiBkeSA8IGNsb3Nlc3REWSkge1xuICAgICAgICAgICAgICAgIGxldCByaWdodCA9IHggPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiwgYWZ0ZXIgPSByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUgfHwgYnJvd3Nlci5nZWNrbykge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgUlRMIG9uIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZXR0aW5nIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyByZWN0cyBmb3IgZW1wdHkgcmFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHRleHRSYW5nZShub2RlLCBpKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUubGVmdCA9PSByZWN0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSAhcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkeSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoYWZ0ZXIgPyAxIDogMCkgfTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0T2Zmc2V0ID0gaSArIChhZnRlciA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RFkgPSBkeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGNsb3Nlc3RPZmZzZXQgPiAtMSA/IGNsb3Nlc3RPZmZzZXQgOiBnZW5lcmFsU2lkZSA+IDAgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBwb3NBdENvb3Jkcyh2aWV3LCB7IHgsIHkgfSwgcHJlY2lzZSwgYmlhcyA9IC0xKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBjb250ZW50ID0gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBkb2NUb3AgPSBjb250ZW50LnRvcCArIHZpZXcudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgbGV0IGJsb2NrLCB7IGRvY0hlaWdodCB9ID0gdmlldy52aWV3U3RhdGU7XG4gICAgbGV0IHlPZmZzZXQgPSB5IC0gZG9jVG9wO1xuICAgIGlmICh5T2Zmc2V0IDwgMClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHlPZmZzZXQgPiBkb2NIZWlnaHQpXG4gICAgICAgIHJldHVybiB2aWV3LnN0YXRlLmRvYy5sZW5ndGg7XG4gICAgLy8gU2NhbiBmb3IgYSB0ZXh0IGJsb2NrIG5lYXIgdGhlIHF1ZXJpZWQgeSBwb3NpdGlvblxuICAgIGZvciAobGV0IGhhbGZMaW5lID0gdmlldy5kZWZhdWx0TGluZUhlaWdodCAvIDIsIGJvdW5jZWQgPSBmYWxzZTs7KSB7XG4gICAgICAgIGJsb2NrID0gdmlldy5lbGVtZW50QXRIZWlnaHQoeU9mZnNldCk7XG4gICAgICAgIGlmIChibG9jay50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIC8vIE1vdmUgdGhlIHkgcG9zaXRpb24gb3V0IG9mIHRoaXMgYmxvY2tcbiAgICAgICAgICAgIHlPZmZzZXQgPSBiaWFzID4gMCA/IGJsb2NrLmJvdHRvbSArIGhhbGZMaW5lIDogYmxvY2sudG9wIC0gaGFsZkxpbmU7XG4gICAgICAgICAgICBpZiAoeU9mZnNldCA+PSAwICYmIHlPZmZzZXQgPD0gZG9jSGVpZ2h0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRvY3VtZW50IGNvbnNpc3RzIGVudGlyZWx5IG9mIHJlcGxhY2VkIHdpZGdldHMsIHdlXG4gICAgICAgICAgICAvLyB3b24ndCBmaW5kIGEgdGV4dCBibG9jaywgc28gcmV0dXJuIDBcbiAgICAgICAgICAgIGlmIChib3VuY2VkKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjaXNlID8gbnVsbCA6IDA7XG4gICAgICAgICAgICBib3VuY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJpYXMgPSAtYmlhcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB5ID0gZG9jVG9wICsgeU9mZnNldDtcbiAgICBsZXQgbGluZVN0YXJ0ID0gYmxvY2suZnJvbTtcbiAgICAvLyBJZiB0aGlzIGlzIG91dHNpZGUgb2YgdGhlIHJlbmRlcmVkIHZpZXdwb3J0LCB3ZSBjYW4ndCBkZXRlcm1pbmUgYSBwb3NpdGlvblxuICAgIGlmIChsaW5lU3RhcnQgPCB2aWV3LnZpZXdwb3J0LmZyb20pXG4gICAgICAgIHJldHVybiB2aWV3LnZpZXdwb3J0LmZyb20gPT0gMCA/IDAgOiBwcmVjaXNlID8gbnVsbCA6IHBvc0F0Q29vcmRzSW1wcmVjaXNlKHZpZXcsIGNvbnRlbnQsIGJsb2NrLCB4LCB5KTtcbiAgICBpZiAobGluZVN0YXJ0ID4gdmlldy52aWV3cG9ydC50bylcbiAgICAgICAgcmV0dXJuIHZpZXcudmlld3BvcnQudG8gPT0gdmlldy5zdGF0ZS5kb2MubGVuZ3RoID8gdmlldy5zdGF0ZS5kb2MubGVuZ3RoIDpcbiAgICAgICAgICAgIHByZWNpc2UgPyBudWxsIDogcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudCwgYmxvY2ssIHgsIHkpO1xuICAgIC8vIFByZWZlciBTaGFkb3dSb290T3JEb2N1bWVudC5lbGVtZW50RnJvbVBvaW50IGlmIHByZXNlbnQsIGZhbGwgYmFjayB0byBkb2N1bWVudCBpZiBub3RcbiAgICBsZXQgZG9jID0gdmlldy5kb20ub3duZXJEb2N1bWVudDtcbiAgICBsZXQgcm9vdCA9IHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jO1xuICAgIGxldCBlbGVtZW50ID0gcm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGlmIChlbGVtZW50ICYmICF2aWV3LmNvbnRlbnRET00uY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIHVuZXhwZWN0ZWQsIGNsaXAgeCBhdCB0aGUgc2lkZXMgb2YgdGhlIGNvbnRlbnQgYXJlYSBhbmQgdHJ5IGFnYWluXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHggPSBNYXRoLm1heChjb250ZW50LmxlZnQgKyAxLCBNYXRoLm1pbihjb250ZW50LnJpZ2h0IC0gMSwgeCkpO1xuICAgICAgICBlbGVtZW50ID0gcm9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhdmlldy5jb250ZW50RE9NLmNvbnRhaW5zKGVsZW1lbnQpKVxuICAgICAgICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIFRoZXJlJ3MgdmlzaWJsZSBlZGl0b3IgY29udGVudCB1bmRlciB0aGUgcG9pbnQsIHNvIHdlIGNhbiB0cnlcbiAgICAvLyB1c2luZyBjYXJldChQb3NpdGlvbnxSYW5nZSlGcm9tUG9pbnQgYXMgYSBzaG9ydGN1dFxuICAgIGxldCBub2RlLCBvZmZzZXQgPSAtMTtcbiAgICBpZiAoZWxlbWVudCAmJiAoKF9hID0gdmlldy5kb2NWaWV3Lm5lYXJlc3QoZWxlbWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0VkaXRhYmxlKSAhPSBmYWxzZSkge1xuICAgICAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChwb3MpXG4gICAgICAgICAgICAgICAgKHsgb2Zmc2V0Tm9kZTogbm9kZSwgb2Zmc2V0IH0gPSBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvYy5jYXJldFJhbmdlRnJvbVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2MuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICh7IHN0YXJ0Q29udGFpbmVyOiBub2RlLCBzdGFydE9mZnNldDogb2Zmc2V0IH0gPSByYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpICYmIGlzU3VzcGljaW91c0NhcmV0UmVzdWx0KG5vZGUsIG9mZnNldCwgeCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTm8gbHVjaywgZG8gb3VyIG93biAocG90ZW50aWFsbHkgZXhwZW5zaXZlKSBzZWFyY2hcbiAgICBpZiAoIW5vZGUgfHwgIXZpZXcuZG9jVmlldy5kb20uY29udGFpbnMobm9kZSkpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgbGluZVN0YXJ0KTtcbiAgICAgICAgaWYgKCFsaW5lKVxuICAgICAgICAgICAgcmV0dXJuIHlPZmZzZXQgPiBibG9jay50b3AgKyBibG9jay5oZWlnaHQgLyAyID8gYmxvY2sudG8gOiBibG9jay5mcm9tO1xuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGRvbVBvc0F0Q29vcmRzKGxpbmUuZG9tLCB4LCB5KSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xufVxuZnVuY3Rpb24gcG9zQXRDb29yZHNJbXByZWNpc2UodmlldywgY29udGVudFJlY3QsIGJsb2NrLCB4LCB5KSB7XG4gICAgbGV0IGludG8gPSBNYXRoLnJvdW5kKCh4IC0gY29udGVudFJlY3QubGVmdCkgKiB2aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCk7XG4gICAgaWYgKHZpZXcubGluZVdyYXBwaW5nICYmIGJsb2NrLmhlaWdodCA+IHZpZXcuZGVmYXVsdExpbmVIZWlnaHQgKiAxLjUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSBNYXRoLmZsb29yKCh5IC0gYmxvY2sudG9wKSAvIHZpZXcuZGVmYXVsdExpbmVIZWlnaHQpO1xuICAgICAgICBpbnRvICs9IGxpbmUgKiB2aWV3LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUxlbmd0aDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGJsb2NrLmZyb20sIGJsb2NrLnRvKTtcbiAgICByZXR1cm4gYmxvY2suZnJvbSArIGZpbmRDb2x1bW4oY29udGVudCwgaW50bywgdmlldy5zdGF0ZS50YWJTaXplKTtcbn1cbi8vIEluIGNhc2Ugb2YgYSBoaWdoIGxpbmUgaGVpZ2h0LCBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHRyZWF0c1xuLy8gdGhlIHNwYWNlIGJldHdlZW4gbGluZXMgYXMgYmVsb25naW5nIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGVcbi8vIGxpbmUgYmVmb3JlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IHN1Y2ggYSByZXN1bHQgc28gdGhhdCBpdCBjYW4gYmVcbi8vIGlnbm9yZWQgKGlzc3VlICM0MDEpLlxuZnVuY3Rpb24gaXNTdXNwaWNpb3VzQ2FyZXRSZXN1bHQobm9kZSwgb2Zmc2V0LCB4KSB7XG4gICAgbGV0IGxlbjtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAzIHx8IG9mZnNldCAhPSAobGVuID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nOyBuZXh0OyBuZXh0ID0gbmV4dC5uZXh0U2libGluZylcbiAgICAgICAgaWYgKG5leHQubm9kZVR5cGUgIT0gMSB8fCBuZXh0Lm5vZGVOYW1lICE9IFwiQlJcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGV4dFJhbmdlKG5vZGUsIGxlbiAtIDEsIGxlbikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IHg7XG59XG5mdW5jdGlvbiBtb3ZlVG9MaW5lQm91bmRhcnkodmlldywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKSB7XG4gICAgbGV0IGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQoc3RhcnQuaGVhZCk7XG4gICAgbGV0IGNvb3JkcyA9ICFpbmNsdWRlV3JhcCB8fCAhdmlldy5saW5lV3JhcHBpbmcgPyBudWxsXG4gICAgICAgIDogdmlldy5jb29yZHNBdFBvcyhzdGFydC5hc3NvYyA8IDAgJiYgc3RhcnQuaGVhZCA+IGxpbmUuZnJvbSA/IHN0YXJ0LmhlYWQgLSAxIDogc3RhcnQuaGVhZCk7XG4gICAgaWYgKGNvb3Jkcykge1xuICAgICAgICBsZXQgZWRpdG9yUmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgcG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGZvcndhcmQgPT0gKHZpZXcudGV4dERpcmVjdGlvbiA9PSBEaXJlY3Rpb24uTFRSKSA/IGVkaXRvclJlY3QucmlnaHQgLSAxIDogZWRpdG9yUmVjdC5sZWZ0ICsgMSxcbiAgICAgICAgICAgIHk6IChjb29yZHMudG9wICsgY29vcmRzLmJvdHRvbSkgLyAyIH0pO1xuICAgICAgICBpZiAocG9zICE9IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIGZvcndhcmQgPyAtMSA6IDEpO1xuICAgIH1cbiAgICBsZXQgbGluZVZpZXcgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgc3RhcnQuaGVhZCk7XG4gICAgbGV0IGVuZCA9IGxpbmVWaWV3ID8gKGZvcndhcmQgPyBsaW5lVmlldy5wb3NBdEVuZCA6IGxpbmVWaWV3LnBvc0F0U3RhcnQpIDogKGZvcndhcmQgPyBsaW5lLnRvIDogbGluZS5mcm9tKTtcbiAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihlbmQsIGZvcndhcmQgPyAtMSA6IDEpO1xufVxuZnVuY3Rpb24gbW92ZUJ5Q2hhcih2aWV3LCBzdGFydCwgZm9yd2FyZCwgYnkpIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChzdGFydC5oZWFkKSwgc3BhbnMgPSB2aWV3LmJpZGlTcGFucyhsaW5lKTtcbiAgICBmb3IgKGxldCBjdXIgPSBzdGFydCwgY2hlY2sgPSBudWxsOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSBtb3ZlVmlzdWFsbHkobGluZSwgc3BhbnMsIHZpZXcudGV4dERpcmVjdGlvbiwgY3VyLCBmb3J3YXJkKSwgY2hhciA9IG1vdmVkT3ZlcjtcbiAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5saW5lcyA6IDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICBjaGFyID0gXCJcXG5cIjtcbiAgICAgICAgICAgIGxpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lKGxpbmUubnVtYmVyICsgKGZvcndhcmQgPyAxIDogLTEpKTtcbiAgICAgICAgICAgIHNwYW5zID0gdmlldy5iaWRpU3BhbnMobGluZSk7XG4gICAgICAgICAgICBuZXh0ID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihmb3J3YXJkID8gbGluZS5mcm9tIDogbGluZS50byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgaWYgKCFieSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIGNoZWNrID0gYnkoY2hhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWNoZWNrKGNoYXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VyO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IG5leHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYnlHcm91cCh2aWV3LCBwb3MsIHN0YXJ0KSB7XG4gICAgbGV0IGNhdGVnb3JpemUgPSB2aWV3LnN0YXRlLmNoYXJDYXRlZ29yaXplcihwb3MpO1xuICAgIGxldCBjYXQgPSBjYXRlZ29yaXplKHN0YXJ0KTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgICAgbGV0IG5leHRDYXQgPSBjYXRlZ29yaXplKG5leHQpO1xuICAgICAgICBpZiAoY2F0ID09IENoYXJDYXRlZ29yeS5TcGFjZSlcbiAgICAgICAgICAgIGNhdCA9IG5leHRDYXQ7XG4gICAgICAgIHJldHVybiBjYXQgPT0gbmV4dENhdDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbW92ZVZlcnRpY2FsbHkodmlldywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSB7XG4gICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQuaGVhZCwgZGlyID0gZm9yd2FyZCA/IDEgOiAtMTtcbiAgICBpZiAoc3RhcnRQb3MgPT0gKGZvcndhcmQgPyB2aWV3LnN0YXRlLmRvYy5sZW5ndGggOiAwKSlcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3Ioc3RhcnRQb3MsIHN0YXJ0LmFzc29jKTtcbiAgICBsZXQgZ29hbCA9IHN0YXJ0LmdvYWxDb2x1bW4sIHN0YXJ0WTtcbiAgICBsZXQgcmVjdCA9IHZpZXcuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBsZXQgc3RhcnRDb29yZHMgPSB2aWV3LmNvb3Jkc0F0UG9zKHN0YXJ0UG9zKSwgZG9jVG9wID0gdmlldy5kb2N1bWVudFRvcDtcbiAgICBpZiAoc3RhcnRDb29yZHMpIHtcbiAgICAgICAgaWYgKGdvYWwgPT0gbnVsbClcbiAgICAgICAgICAgIGdvYWwgPSBzdGFydENvb3Jkcy5sZWZ0IC0gcmVjdC5sZWZ0O1xuICAgICAgICBzdGFydFkgPSBkaXIgPCAwID8gc3RhcnRDb29yZHMudG9wIDogc3RhcnRDb29yZHMuYm90dG9tO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGxpbmUgPSB2aWV3LnZpZXdTdGF0ZS5saW5lQmxvY2tBdChzdGFydFBvcyAtIGRvY1RvcCk7XG4gICAgICAgIGlmIChnb2FsID09IG51bGwpXG4gICAgICAgICAgICBnb2FsID0gTWF0aC5taW4ocmVjdC5yaWdodCAtIHJlY3QubGVmdCwgdmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGggKiAoc3RhcnRQb3MgLSBsaW5lLmZyb20pKTtcbiAgICAgICAgc3RhcnRZID0gKGRpciA8IDAgPyBsaW5lLnRvcCA6IGxpbmUuYm90dG9tKSArIGRvY1RvcDtcbiAgICB9XG4gICAgbGV0IHJlc29sdmVkR29hbCA9IHJlY3QubGVmdCArIGdvYWw7XG4gICAgbGV0IGRpc3QgPSBkaXN0YW5jZSAhPT0gbnVsbCAmJiBkaXN0YW5jZSAhPT0gdm9pZCAwID8gZGlzdGFuY2UgOiAodmlldy5kZWZhdWx0TGluZUhlaWdodCA+PiAxKTtcbiAgICBmb3IgKGxldCBleHRyYSA9IDA7OyBleHRyYSArPSAxMCkge1xuICAgICAgICBsZXQgY3VyWSA9IHN0YXJ0WSArIChkaXN0ICsgZXh0cmEpICogZGlyO1xuICAgICAgICBsZXQgcG9zID0gcG9zQXRDb29yZHModmlldywgeyB4OiByZXNvbHZlZEdvYWwsIHk6IGN1clkgfSwgZmFsc2UsIGRpcik7XG4gICAgICAgIGlmIChjdXJZIDwgcmVjdC50b3AgfHwgY3VyWSA+IHJlY3QuYm90dG9tIHx8IChkaXIgPCAwID8gcG9zIDwgc3RhcnRQb3MgOiBwb3MgPiBzdGFydFBvcykpXG4gICAgICAgICAgICByZXR1cm4gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MsIHN0YXJ0LmFzc29jLCB1bmRlZmluZWQsIGdvYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNraXBBdG9tcyh2aWV3LCBvbGRQb3MsIHBvcykge1xuICAgIGxldCBhdG9tcyA9IHZpZXcucGx1Z2luRmllbGQoUGx1Z2luRmllbGQuYXRvbWljUmFuZ2VzKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGxldCBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgYXRvbXMpIHtcbiAgICAgICAgICAgIHNldC5iZXR3ZWVuKHBvcy5mcm9tIC0gMSwgcG9zLmZyb20gKyAxLCAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5mcm9tID4gZnJvbSAmJiBwb3MuZnJvbSA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG9sZFBvcy5mcm9tID4gcG9zLmZyb20gPyBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKGZyb20sIDEpIDogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcih0bywgLTEpO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb3ZlZClcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxufVxuXG4vLyBUaGlzIHdpbGwgYWxzbyBiZSB3aGVyZSBkcmFnZ2luZyBpbmZvIGFuZCBzdWNoIGdvZXNcbmNsYXNzIElucHV0U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSAwO1xuICAgICAgICAvLyBPbiBpT1MsIHNvbWUga2V5cyBuZWVkIHRvIGhhdmUgdGhlaXIgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgLy8gKGFmdGVyIHdoaWNoIHdlIHJldHJvYWN0aXZlbHkgaGFuZGxlIHRoZW0gYW5kIHJlc2V0IHRoZSBET00pIHRvXG4gICAgICAgIC8vIGF2b2lkIG1lc3NpbmcgdXAgdGhlIHZpcnR1YWwga2V5Ym9hcmQgc3RhdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ0lPU0tleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0Q29udGV4dE1lbnUgPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUhhbmRsZXJzID0gW107XG4gICAgICAgIC8vIC0xIG1lYW5zIG5vdCBpbiBhIGNvbXBvc2l0aW9uLiBPdGhlcndpc2UsIHRoaXMgY291bnRzIHRoZSBudW1iZXJcbiAgICAgICAgLy8gb2YgY2hhbmdlcyBtYWRlIGR1cmluZyB0aGUgY29tcG9zaXRpb24uIFRoZSBjb3VudCBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGF2b2lkIHRyZWF0aW5nIHRoZSBzdGFydCBzdGF0ZSBvZiB0aGUgY29tcG9zaXRpb24sIGJlZm9yZSBhbnlcbiAgICAgICAgLy8gY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSwgYXMgcGFydCBvZiB0aGUgY29tcG9zaXRpb24uXG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gLTE7XG4gICAgICAgIC8vIFRyYWNrcyB3aGV0aGVyIHRoZSBuZXh0IGNoYW5nZSBzaG91bGQgYmUgbWFya2VkIGFzIHN0YXJ0aW5nIHRoZVxuICAgICAgICAvLyBjb21wb3NpdGlvbiAobnVsbCBtZWFucyBubyBjb21wb3NpdGlvbiwgdHJ1ZSBtZWFucyBuZXh0IGlzIHRoZVxuICAgICAgICAvLyBmaXJzdCwgZmFsc2UgbWVhbnMgZmlyc3QgaGFzIGFscmVhZHkgYmVlbiBtYXJrZWQgZm9yIHRoaXNcbiAgICAgICAgLy8gY29tcG9zaXRpb24pXG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgdGhpcy5yYXBpZENvbXBvc2l0aW9uU3RhcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IHR5cGUgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV07XG4gICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBcImtleWRvd25cIiAmJiB0aGlzLmtleWRvd24odmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudEJlbG9uZ3NUb0VkaXRvcih2aWV3LCBldmVudCkgfHwgdGhpcy5pZ25vcmVEdXJpbmdDb21wb3NpdGlvbihldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tdXN0Rmx1c2hPYnNlcnZlcihldmVudCkpXG4gICAgICAgICAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ1bkN1c3RvbUhhbmRsZXJzKHR5cGUsIHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIodmlldywgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMucHVzaCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmaWVkRm9jdXNlZCA9IHZpZXcuaGFzRm9jdXM7XG4gICAgICAgIHRoaXMuZW5zdXJlSGFuZGxlcnModmlldyk7XG4gICAgICAgIC8vIE9uIFNhZmFyaSBhZGRpbmcgYW4gaW5wdXQgZXZlbnQgaGFuZGxlciBzb21laG93IHByZXZlbnRzIGFuXG4gICAgICAgIC8vIGlzc3VlIHdoZXJlIHRoZSBjb21wb3NpdGlvbiB2YW5pc2hlcyB3aGVuIHlvdSBwcmVzcyBlbnRlci5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2FmYXJpKVxuICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICB9XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKG9yaWdpbikge1xuICAgICAgICB0aGlzLmxhc3RTZWxlY3Rpb25PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICBlbnN1cmVIYW5kbGVycyh2aWV3KSB7XG4gICAgICAgIGxldCBoYW5kbGVycyA9IHRoaXMuY3VzdG9tSGFuZGxlcnMgPSB2aWV3LnBsdWdpbkZpZWxkKGRvbUV2ZW50SGFuZGxlcnMpO1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHR5cGUgaW4gc2V0LmhhbmRsZXJzKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRFdmVudHMuaW5kZXhPZih0eXBlKSA8IDAgJiYgdHlwZSAhPSBcInNjcm9sbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJ1bkN1c3RvbUhhbmRsZXJzKHR5cGUsIHZpZXcsIGV2ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuQ3VzdG9tSGFuZGxlcnModHlwZSwgdmlldywgZXZlbnQpIHtcbiAgICAgICAgZm9yIChsZXQgc2V0IG9mIHRoaXMuY3VzdG9tSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gc2V0LmhhbmRsZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlci5jYWxsKHNldC5wbHVnaW4sIGV2ZW50LCB2aWV3KSB8fCBldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0V4Y2VwdGlvbih2aWV3LnN0YXRlLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBydW5TY3JvbGxIYW5kbGVycyh2aWV3LCBldmVudCkge1xuICAgICAgICBmb3IgKGxldCBzZXQgb2YgdGhpcy5jdXN0b21IYW5kbGVycykge1xuICAgICAgICAgICAgbGV0IGhhbmRsZXIgPSBzZXQuaGFuZGxlcnMuc2Nyb2xsO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwoc2V0LnBsdWdpbiwgZXZlbnQsIHZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odmlldy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGtleWRvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgLy8gTXVzdCBhbHdheXMgcnVuLCBldmVuIGlmIGEgY3VzdG9tIGhhbmRsZXIgaGFuZGxlZCB0aGUgZXZlbnRcbiAgICAgICAgdGhpcy5sYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIHRoaXMubGFzdEtleVRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5zY3JlZW5LZXlFdmVudCh2aWV3LCBldmVudCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gQ2hyb21lIGZvciBBbmRyb2lkIHVzdWFsbHkgZG9lc24ndCBmaXJlIHByb3BlciBrZXkgZXZlbnRzLCBidXRcbiAgICAgICAgLy8gb2NjYXNpb25hbGx5IGRvZXMsIHVzdWFsbHkgc3Vycm91bmRlZCBieSBhIGJ1bmNoIG9mIGNvbXBsaWNhdGVkXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uIGNoYW5nZXMuIFdoZW4gYW4gZW50ZXIgb3IgYmFja3NwYWNlIGtleSBldmVudCBpc1xuICAgICAgICAvLyBzZWVuLCBob2xkIG9mZiBvbiBoYW5kbGluZyBET00gZXZlbnRzIGZvciBhIGJpdCwgYW5kIHRoZW5cbiAgICAgICAgLy8gZGlzcGF0Y2ggaXQuXG4gICAgICAgIGlmIChicm93c2VyLmFuZHJvaWQgJiYgYnJvd3Nlci5jaHJvbWUgJiYgIWV2ZW50LnN5bnRoZXRpYyAmJlxuICAgICAgICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTMgfHwgZXZlbnQua2V5Q29kZSA9PSA4KSkge1xuICAgICAgICAgICAgdmlldy5vYnNlcnZlci5kZWxheUFuZHJvaWRLZXkoZXZlbnQua2V5LCBldmVudC5rZXlDb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgRW50ZXIgb24gaU9TIG1ha2VzIHRoZVxuICAgICAgICAvLyB2aXJ0dWFsIGtleWJvYXJkIGdldCBzdHVjayBpbiB0aGUgd3JvbmcgKGxvd2VyY2FzZSlcbiAgICAgICAgLy8gc3RhdGUuIFNvIHdlIGxldCBpdCBnbyB0aHJvdWdoLCBhbmQgdGhlbiwgaW5cbiAgICAgICAgLy8gYXBwbHlET01DaGFuZ2UsIG5vdGlmeSBrZXkgaGFuZGxlcnMgb2YgaXQgYW5kIHJlc2V0IHRvXG4gICAgICAgIC8vIHRoZSBzdGF0ZSB0aGV5IHByb2R1Y2UuXG4gICAgICAgIGxldCBwZW5kaW5nO1xuICAgICAgICBpZiAoYnJvd3Nlci5pb3MgJiYgKHBlbmRpbmcgPSBQZW5kaW5nS2V5cy5maW5kKGtleSA9PiBrZXkua2V5Q29kZSA9PSBldmVudC5rZXlDb2RlKSkgJiZcbiAgICAgICAgICAgICEoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgJiYgIWV2ZW50LnN5bnRoZXRpYykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gcGVuZGluZztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaElPU0tleSh2aWV3KSwgMjUwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZmx1c2hJT1NLZXkodmlldykge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5wZW5kaW5nSU9TS2V5O1xuICAgICAgICBpZiAoIWtleSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSU9TS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBrZXkua2V5LCBrZXkua2V5Q29kZSk7XG4gICAgfVxuICAgIGlnbm9yZUR1cmluZ0NvbXBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmICghL15rZXkvLnRlc3QoZXZlbnQudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2luZyA+IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0dW0uZGUvMjAxNi8wNi8yNC9oYW5kbGluZy1pbWUtZXZlbnRzLWluLWphdmFzY3JpcHQvLlxuICAgICAgICAvLyBPbiBzb21lIGlucHV0IG1ldGhvZCBlZGl0b3JzIChJTUVzKSwgdGhlIEVudGVyIGtleSBpcyB1c2VkIHRvXG4gICAgICAgIC8vIGNvbmZpcm0gY2hhcmFjdGVyIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsXG4gICAgICAgIC8vIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmUgc29tZXRpbWVzIGVtaXR0ZWQgaW4gdGhlXG4gICAgICAgIC8vIHdyb25nIG9yZGVyLiBUaGUga2V5IGV2ZW50IHNob3VsZCBzdGlsbCBiZSBpZ25vcmVkLCBldmVuIHdoZW5cbiAgICAgICAgLy8gaXQgaGFwcGVucyBhZnRlciB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQuXG4gICAgICAgIGlmIChicm93c2VyLnNhZmFyaSAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb21wb3NpdGlvbkVuZGVkQXQgPCA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2NyZWVuS2V5RXZlbnQodmlldywgZXZlbnQpIHtcbiAgICAgICAgbGV0IHByb3RlY3RlZFRhYiA9IGV2ZW50LmtleUNvZGUgPT0gOSAmJiBEYXRlLm5vdygpIDwgdGhpcy5sYXN0RXNjUHJlc3MgKyAyMDAwO1xuICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAyNylcbiAgICAgICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxzZSBpZiAobW9kaWZpZXJDb2Rlcy5pbmRleE9mKGV2ZW50LmtleUNvZGUpIDwgMClcbiAgICAgICAgICAgIHRoaXMubGFzdEVzY1ByZXNzID0gMDtcbiAgICAgICAgcmV0dXJuIHByb3RlY3RlZFRhYjtcbiAgICB9XG4gICAgbXVzdEZsdXNoT2JzZXJ2ZXIoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIChldmVudC50eXBlID09IFwia2V5ZG93blwiICYmIGV2ZW50LmtleUNvZGUgIT0gMjI5KSB8fFxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PSBcImNvbXBvc2l0aW9uZW5kXCIgJiYgIWJyb3dzZXIuaW9zO1xuICAgIH1cbiAgICBzdGFydE1vdXNlU2VsZWN0aW9uKG1vdXNlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24gPSBtb3VzZVNlbGVjdGlvbjtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5tb3VzZVNlbGVjdGlvbilcbiAgICAgICAgICAgIHRoaXMubW91c2VTZWxlY3Rpb24udXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSB0aGlzLmxhc3RTZWxlY3Rpb25UaW1lID0gMDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMubW91c2VTZWxlY3Rpb24pXG4gICAgICAgICAgICB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgICB9XG59XG5jb25zdCBQZW5kaW5nS2V5cyA9IFtcbiAgICB7IGtleTogXCJCYWNrc3BhY2VcIiwga2V5Q29kZTogOCwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiIH0sXG4gICAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICAgIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXTtcbi8vIEtleSBjb2RlcyBmb3IgbW9kaWZpZXIga2V5c1xuY29uc3QgbW9kaWZpZXJDb2RlcyA9IFsxNiwgMTcsIDE4LCAyMCwgOTEsIDkyLCAyMjQsIDIyNV07XG5jbGFzcyBNb3VzZVNlbGVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iodmlldywgc3RhcnRFdmVudCwgc3R5bGUsIG11c3RTZWxlY3QpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBtdXN0U2VsZWN0O1xuICAgICAgICB0aGlzLmxhc3RFdmVudCA9IHN0YXJ0RXZlbnQ7XG4gICAgICAgIGxldCBkb2MgPSB2aWV3LmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpO1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gc3RhcnRFdmVudC5zaGlmdEtleTtcbiAgICAgICAgdGhpcy5tdWx0aXBsZSA9IHZpZXcuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMpICYmIGFkZHNTZWxlY3Rpb25SYW5nZSh2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgICAgdGhpcy5kcmFnTW92ZSA9IGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBzdGFydEV2ZW50KTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIHN0YXJ0RXZlbnQpICYmIGdldENsaWNrVHlwZShzdGFydEV2ZW50KSA9PSAxID8gbnVsbCA6IGZhbHNlO1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvbiwgaW1tZWRpYXRlbHkgYXBwbHkgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBzdGFydGluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RhcnRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Qoc3RhcnRFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9ucyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZXZlbnQpO1xuICAgIH1cbiAgICB1cChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgbGV0IGRvYyA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLnVwKTtcbiAgICAgICAgdGhpcy52aWV3LmlucHV0U3RhdGUubW91c2VTZWxlY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICBzZWxlY3QoZXZlbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuc3R5bGUuZ2V0KGV2ZW50LCB0aGlzLmV4dGVuZCwgdGhpcy5tdWx0aXBsZSk7XG4gICAgICAgIGlmICh0aGlzLm11c3RTZWxlY3QgfHwgIXNlbGVjdGlvbi5lcSh0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uKSB8fFxuICAgICAgICAgICAgc2VsZWN0aW9uLm1haW4uYXNzb2MgIT0gdGhpcy52aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCIsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11c3RTZWxlY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgJiYgdGhpcy5kcmFnZ2luZylcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLnVwZGF0ZSh1cGRhdGUpKVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdCh0aGlzLmxhc3RFdmVudCksIDIwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRzU2VsZWN0aW9uUmFuZ2UodmlldywgZXZlbnQpIHtcbiAgICBsZXQgZmFjZXQgPSB2aWV3LnN0YXRlLmZhY2V0KGNsaWNrQWRkc1NlbGVjdGlvblJhbmdlKTtcbiAgICByZXR1cm4gZmFjZXQubGVuZ3RoID8gZmFjZXRbMF0oZXZlbnQpIDogYnJvd3Nlci5tYWMgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGRyYWdNb3Zlc1NlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBmYWNldCA9IHZpZXcuc3RhdGUuZmFjZXQoZHJhZ01vdmVzU2VsZWN0aW9uJDEpO1xuICAgIHJldHVybiBmYWNldC5sZW5ndGggPyBmYWNldFswXShldmVudCkgOiBicm93c2VyLm1hYyA/ICFldmVudC5hbHRLZXkgOiAhZXZlbnQuY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzSW5QcmltYXJ5U2VsZWN0aW9uKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHsgbWFpbiB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKG1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBPbiBib3VuZGFyeSBjbGlja3MsIGNoZWNrIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBpbnNpZGUgdGhlXG4gICAgLy8gc2VsZWN0aW9uJ3MgY2xpZW50IHJlY3RhbmdsZXNcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKHZpZXcucm9vdCk7XG4gICAgaWYgKHNlbC5yYW5nZUNvdW50ID09IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCByZWN0cyA9IHNlbC5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgICBpZiAocmVjdC5sZWZ0IDw9IGV2ZW50LmNsaWVudFggJiYgcmVjdC5yaWdodCA+PSBldmVudC5jbGllbnRYICYmXG4gICAgICAgICAgICByZWN0LnRvcCA8PSBldmVudC5jbGllbnRZICYmIHJlY3QuYm90dG9tID49IGV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9FZGl0b3IodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmJ1YmJsZXMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgbm9kZSA9IGV2ZW50LnRhcmdldCwgY1ZpZXc7IG5vZGUgIT0gdmlldy5jb250ZW50RE9NOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS5ub2RlVHlwZSA9PSAxMSB8fCAoKGNWaWV3ID0gQ29udGVudFZpZXcuZ2V0KG5vZGUpKSAmJiBjVmlldy5pZ25vcmVFdmVudChldmVudCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgaGFuZGxlcnMgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8IDE1KSB8fFxuICAgIChicm93c2VyLmlvcyAmJiBicm93c2VyLndlYmtpdF92ZXJzaW9uIDwgNjA0KTtcbmZ1bmN0aW9uIGNhcHR1cmVQYXN0ZSh2aWV3KSB7XG4gICAgbGV0IHBhcmVudCA9IHZpZXcuZG9tLnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gcGFyZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgaW5wdXQpIHtcbiAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgY2hhbmdlcywgaSA9IDEsIHRleHQgPSBzdGF0ZS50b1RleHQoaW5wdXQpO1xuICAgIGxldCBieUxpbmUgPSB0ZXh0LmxpbmVzID09IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoO1xuICAgIGxldCBsaW5ld2lzZSA9IGxhc3RMaW5ld2lzZUNvcHkgIT0gbnVsbCAmJiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmV2ZXJ5KHIgPT4gci5lbXB0eSkgJiYgbGFzdExpbmV3aXNlQ29weSA9PSB0ZXh0LnRvU3RyaW5nKCk7XG4gICAgaWYgKGxpbmV3aXNlKSB7XG4gICAgICAgIGxldCBsYXN0TGluZSA9IC0xO1xuICAgICAgICBjaGFuZ2VzID0gc3RhdGUuY2hhbmdlQnlSYW5nZShyYW5nZSA9PiB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3RMaW5lKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJhbmdlIH07XG4gICAgICAgICAgICBsYXN0TGluZSA9IGxpbmUuZnJvbTtcbiAgICAgICAgICAgIGxldCBpbnNlcnQgPSBzdGF0ZS50b1RleHQoKGJ5TGluZSA/IHRleHQubGluZShpKyspLnRleHQgOiBpbnB1dCkgKyBzdGF0ZS5saW5lQnJlYWspO1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhbmdlczogeyBmcm9tOiBsaW5lLmZyb20sIGluc2VydCB9LFxuICAgICAgICAgICAgICAgIHJhbmdlOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKHJhbmdlLmZyb20gKyBpbnNlcnQubGVuZ3RoKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnlMaW5lKSB7XG4gICAgICAgIGNoYW5nZXMgPSBzdGF0ZS5jaGFuZ2VCeVJhbmdlKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gdGV4dC5saW5lKGkrKyk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiB7IGZyb206IHJhbmdlLmZyb20sIHRvOiByYW5nZS50bywgaW5zZXJ0OiBsaW5lLnRleHQgfSxcbiAgICAgICAgICAgICAgICByYW5nZTogRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihyYW5nZS5mcm9tICsgbGluZS5sZW5ndGgpIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbmdlcyA9IHN0YXRlLnJlcGxhY2VTZWxlY3Rpb24odGV4dCk7XG4gICAgfVxuICAgIHZpZXcuZGlzcGF0Y2goY2hhbmdlcywge1xuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWVcbiAgICB9KTtcbn1cbmhhbmRsZXJzLmtleWRvd24gPSAodmlldywgZXZlbnQpID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpO1xufTtcbmxldCBsYXN0VG91Y2ggPSAwO1xuaGFuZGxlcnMudG91Y2hzdGFydCA9ICh2aWV3LCBlKSA9PiB7XG4gICAgbGFzdFRvdWNoID0gRGF0ZS5ub3coKTtcbiAgICB2aWV3LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0LnBvaW50ZXJcIik7XG59O1xuaGFuZGxlcnMudG91Y2htb3ZlID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbmhhbmRsZXJzLm1vdXNlZG93biA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIHZpZXcub2JzZXJ2ZXIuZmx1c2goKTtcbiAgICBpZiAobGFzdFRvdWNoID4gRGF0ZS5ub3coKSAtIDIwMDAgJiYgZ2V0Q2xpY2tUeXBlKGV2ZW50KSA9PSAxKVxuICAgICAgICByZXR1cm47IC8vIElnbm9yZSB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGxldCBzdHlsZSA9IG51bGw7XG4gICAgZm9yIChsZXQgbWFrZVN0eWxlIG9mIHZpZXcuc3RhdGUuZmFjZXQobW91c2VTZWxlY3Rpb25TdHlsZSkpIHtcbiAgICAgICAgc3R5bGUgPSBtYWtlU3R5bGUodmlldywgZXZlbnQpO1xuICAgICAgICBpZiAoc3R5bGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFzdHlsZSAmJiBldmVudC5idXR0b24gPT0gMClcbiAgICAgICAgc3R5bGUgPSBiYXNpY01vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50KTtcbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgbGV0IG11c3RGb2N1cyA9IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHZpZXcuY29udGVudERPTTtcbiAgICAgICAgaWYgKG11c3RGb2N1cylcbiAgICAgICAgICAgIHZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IGZvY3VzUHJldmVudFNjcm9sbCh2aWV3LmNvbnRlbnRET00pKTtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnN0YXJ0TW91c2VTZWxlY3Rpb24obmV3IE1vdXNlU2VsZWN0aW9uKHZpZXcsIGV2ZW50LCBzdHlsZSwgbXVzdEZvY3VzKSk7XG4gICAgfVxufTtcbmZ1bmN0aW9uIHJhbmdlRm9yQ2xpY2sodmlldywgcG9zLCBiaWFzLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gMSkgeyAvLyBTaW5nbGUgY2xpY2tcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zLCBiaWFzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7IC8vIERvdWJsZSBjbGlja1xuICAgICAgICByZXR1cm4gZ3JvdXBBdCh2aWV3LnN0YXRlLCBwb3MsIGJpYXMpO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gVHJpcGxlIGNsaWNrXG4gICAgICAgIGxldCB2aXN1YWwgPSBMaW5lVmlldy5maW5kKHZpZXcuZG9jVmlldywgcG9zKSwgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh2aXN1YWwgPyB2aXN1YWwucG9zQXRFbmQgOiBwb3MpO1xuICAgICAgICBsZXQgZnJvbSA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdFN0YXJ0IDogbGluZS5mcm9tLCB0byA9IHZpc3VhbCA/IHZpc3VhbC5wb3NBdEVuZCA6IGxpbmUudG87XG4gICAgICAgIGlmICh0byA8IHZpZXcuc3RhdGUuZG9jLmxlbmd0aCAmJiB0byA9PSBsaW5lLnRvKVxuICAgICAgICAgICAgdG8rKztcbiAgICAgICAgcmV0dXJuIEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0byk7XG4gICAgfVxufVxubGV0IGluc2lkZVkgPSAoeSwgcmVjdCkgPT4geSA+PSByZWN0LnRvcCAmJiB5IDw9IHJlY3QuYm90dG9tO1xubGV0IGluc2lkZSA9ICh4LCB5LCByZWN0KSA9PiBpbnNpZGVZKHksIHJlY3QpICYmIHggPj0gcmVjdC5sZWZ0ICYmIHggPD0gcmVjdC5yaWdodDtcbi8vIFRyeSB0byBkZXRlcm1pbmUsIGZvciB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMsIGFzc29jaWF0ZWQgd2l0aCB0aGVcbi8vIGdpdmVuIHBvc2l0aW9uLCB3aGV0aGVyIHRoZXkgYXJlIHJlbGF0ZWQgdG8gdGhlIGVsZW1lbnQgYmVmb3JlIG9yXG4vLyB0aGUgZWxlbWVudCBhZnRlciB0aGUgcG9zaXRpb24uXG5mdW5jdGlvbiBmaW5kUG9zaXRpb25TaWRlKHZpZXcsIHBvcywgeCwgeSkge1xuICAgIGxldCBsaW5lID0gTGluZVZpZXcuZmluZCh2aWV3LmRvY1ZpZXcsIHBvcyk7XG4gICAgaWYgKCFsaW5lKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBsZXQgb2ZmID0gcG9zIC0gbGluZS5wb3NBdFN0YXJ0O1xuICAgIC8vIExpbmUgYm91bmRhcmllcyBwb2ludCBpbnRvIHRoZSBsaW5lXG4gICAgaWYgKG9mZiA9PSAwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAob2ZmID09IGxpbmUubGVuZ3RoKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgLy8gUG9zaXRpb25zIG9uIHRvcCBvZiBhbiBlbGVtZW50IHBvaW50IGF0IHRoYXQgZWxlbWVudFxuICAgIGxldCBiZWZvcmUgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgLTEpO1xuICAgIGlmIChiZWZvcmUgJiYgaW5zaWRlKHgsIHksIGJlZm9yZSkpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBsZXQgYWZ0ZXIgPSBsaW5lLmNvb3Jkc0F0KG9mZiwgMSk7XG4gICAgaWYgKGFmdGVyICYmIGluc2lkZSh4LCB5LCBhZnRlcikpXG4gICAgICAgIHJldHVybiAxO1xuICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYSBsaW5lIHdyYXAgcG9pbnQuIFBpY2sgYmVmb3JlIGlmIHRoZSBwb2ludCBpc1xuICAgIC8vIGJlc2lkZSBpdC5cbiAgICByZXR1cm4gYmVmb3JlICYmIGluc2lkZVkoeSwgYmVmb3JlKSA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0sIGZhbHNlKTtcbiAgICByZXR1cm4geyBwb3MsIGJpYXM6IGZpbmRQb3NpdGlvblNpZGUodmlldywgcG9zLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSB9O1xufVxuY29uc3QgQmFkTW91c2VEZXRhaWwgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmxldCBsYXN0TW91c2VEb3duID0gbnVsbCwgbGFzdE1vdXNlRG93bkNvdW50ID0gMCwgbGFzdE1vdXNlRG93blRpbWUgPSAwO1xuZnVuY3Rpb24gZ2V0Q2xpY2tUeXBlKGV2ZW50KSB7XG4gICAgaWYgKCFCYWRNb3VzZURldGFpbClcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbiAgICBsZXQgbGFzdCA9IGxhc3RNb3VzZURvd24sIGxhc3RUaW1lID0gbGFzdE1vdXNlRG93blRpbWU7XG4gICAgbGFzdE1vdXNlRG93biA9IGV2ZW50O1xuICAgIGxhc3RNb3VzZURvd25UaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gbGFzdE1vdXNlRG93bkNvdW50ID0gIWxhc3QgfHwgKGxhc3RUaW1lID4gRGF0ZS5ub3coKSAtIDQwMCAmJiBNYXRoLmFicyhsYXN0LmNsaWVudFggLSBldmVudC5jbGllbnRYKSA8IDIgJiZcbiAgICAgICAgTWF0aC5hYnMobGFzdC5jbGllbnRZIC0gZXZlbnQuY2xpZW50WSkgPCAyKSA/IChsYXN0TW91c2VEb3duQ291bnQgKyAxKSAlIDMgOiAxO1xufVxuZnVuY3Rpb24gYmFzaWNNb3VzZVNlbGVjdGlvbih2aWV3LCBldmVudCkge1xuICAgIGxldCBzdGFydCA9IHF1ZXJ5UG9zKHZpZXcsIGV2ZW50KSwgdHlwZSA9IGdldENsaWNrVHlwZShldmVudCk7XG4gICAgbGV0IHN0YXJ0U2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IGxhc3QgPSBzdGFydCwgbGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBzdGFydC5wb3MgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3Moc3RhcnQucG9zKTtcbiAgICAgICAgICAgICAgICBzdGFydFNlbCA9IHN0YXJ0U2VsLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KGV2ZW50LCBleHRlbmQsIG11bHRpcGxlKSB7XG4gICAgICAgICAgICBsZXQgY3VyO1xuICAgICAgICAgICAgaWYgKGxhc3RFdmVudCAmJiBldmVudC5jbGllbnRYID09IGxhc3RFdmVudC5jbGllbnRYICYmIGV2ZW50LmNsaWVudFkgPT0gbGFzdEV2ZW50LmNsaWVudFkpXG4gICAgICAgICAgICAgICAgY3VyID0gbGFzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1ciA9IGxhc3QgPSBxdWVyeVBvcyh2aWV3LCBldmVudCk7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1ciB8fCAhc3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0U2VsO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBjdXIucG9zLCBjdXIuYmlhcywgdHlwZSk7XG4gICAgICAgICAgICBpZiAoc3RhcnQucG9zICE9IGN1ci5wb3MgJiYgIWV4dGVuZCkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFJhbmdlID0gcmFuZ2VGb3JDbGljayh2aWV3LCBzdGFydC5wb3MsIHN0YXJ0LmJpYXMsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5taW4oc3RhcnRSYW5nZS5mcm9tLCByYW5nZS5mcm9tKSwgdG8gPSBNYXRoLm1heChzdGFydFJhbmdlLnRvLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBmcm9tIDwgcmFuZ2UuZnJvbSA/IEVkaXRvclNlbGVjdGlvbi5yYW5nZShmcm9tLCB0bykgOiBFZGl0b3JTZWxlY3Rpb24ucmFuZ2UodG8sIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4dGVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwucmVwbGFjZVJhbmdlKHN0YXJ0U2VsLm1haW4uZXh0ZW5kKHJhbmdlLmZyb20sIHJhbmdlLnRvKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChtdWx0aXBsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhcnRTZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBFZGl0b3JTZWxlY3Rpb24uY3JlYXRlKFtyYW5nZV0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmhhbmRsZXJzLmRyYWdzdGFydCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbjogeyBtYWluIH0gfSA9IHZpZXcuc3RhdGU7XG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBpZiAobW91c2VTZWxlY3Rpb24pXG4gICAgICAgIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nID0gbWFpbjtcbiAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCB2aWV3LnN0YXRlLnNsaWNlRG9jKG1haW4uZnJvbSwgbWFpbi50bykpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICB9XG59O1xuZnVuY3Rpb24gZHJvcFRleHQodmlldywgZXZlbnQsIHRleHQsIGRpcmVjdCkge1xuICAgIGlmICghdGV4dClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBkcm9wUG9zID0gdmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSwgZmFsc2UpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHsgbW91c2VTZWxlY3Rpb24gfSA9IHZpZXcuaW5wdXRTdGF0ZTtcbiAgICBsZXQgZGVsID0gZGlyZWN0ICYmIG1vdXNlU2VsZWN0aW9uICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdnaW5nICYmIG1vdXNlU2VsZWN0aW9uLmRyYWdNb3ZlID9cbiAgICAgICAgeyBmcm9tOiBtb3VzZVNlbGVjdGlvbi5kcmFnZ2luZy5mcm9tLCB0bzogbW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcudG8gfSA6IG51bGw7XG4gICAgbGV0IGlucyA9IHsgZnJvbTogZHJvcFBvcywgaW5zZXJ0OiB0ZXh0IH07XG4gICAgbGV0IGNoYW5nZXMgPSB2aWV3LnN0YXRlLmNoYW5nZXMoZGVsID8gW2RlbCwgaW5zXSA6IGlucyk7XG4gICAgdmlldy5mb2N1cygpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBjaGFuZ2VzLFxuICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjaGFuZ2VzLm1hcFBvcyhkcm9wUG9zLCAtMSksIGhlYWQ6IGNoYW5nZXMubWFwUG9zKGRyb3BQb3MsIDEpIH0sXG4gICAgICAgIHVzZXJFdmVudDogZGVsID8gXCJtb3ZlLmRyb3BcIiA6IFwiaW5wdXQuZHJvcFwiXG4gICAgfSk7XG59XG5oYW5kbGVycy5kcm9wID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IGZpbGVzID0gZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGgpIHsgLy8gRm9yIGEgZmlsZSBkcm9wLCByZWFkIHRoZSBmaWxlJ3MgdGV4dC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHRleHQgPSBBcnJheShmaWxlcy5sZW5ndGgpLCByZWFkID0gMDtcbiAgICAgICAgbGV0IGZpbmlzaEZpbGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoKytyZWFkID09IGZpbGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgdGV4dC5maWx0ZXIocyA9PiBzICE9IG51bGwpLmpvaW4odmlldy5zdGF0ZS5saW5lQnJlYWspLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZmluaXNoRmlsZTtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCEvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KHJlYWRlci5yZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICB0ZXh0W2ldID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBmaW5pc2hGaWxlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkcm9wVGV4dCh2aWV3LCBldmVudCwgZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpLCB0cnVlKTtcbiAgICB9XG59O1xuaGFuZGxlcnMucGFzdGUgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmlldy5vYnNlcnZlci5mbHVzaCgpO1xuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZG9QYXN0ZSh2aWV3LCBkYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3KTtcbiAgICB9XG59O1xuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgdGV4dCkge1xuICAgIC8vIFRoZSBleHRyYSB3cmFwcGVyIGlzIHNvbWVob3cgbmVjZXNzYXJ5IG9uIElFL0VkZ2UgdG8gcHJldmVudCB0aGVcbiAgICAvLyBjb250ZW50IGZyb20gYmVpbmcgbWFuZ2xlZCB3aGVuIGl0IGlzIHB1dCBvbnRvIHRoZSBjbGlwYm9hcmRcbiAgICBsZXQgcGFyZW50ID0gdmlldy5kb20ucGFyZW50Tm9kZTtcbiAgICBpZiAoIXBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB0YXJnZXQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpKTtcbiAgICB0YXJnZXQuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCI7XG4gICAgdGFyZ2V0LnZhbHVlID0gdGV4dDtcbiAgICB0YXJnZXQuZm9jdXMoKTtcbiAgICB0YXJnZXQuc2VsZWN0aW9uRW5kID0gdGV4dC5sZW5ndGg7XG4gICAgdGFyZ2V0LnNlbGVjdGlvblN0YXJ0ID0gMDtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfSwgNTApO1xufVxuZnVuY3Rpb24gY29waWVkUmFuZ2Uoc3RhdGUpIHtcbiAgICBsZXQgY29udGVudCA9IFtdLCByYW5nZXMgPSBbXSwgbGluZXdpc2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCByYW5nZSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgICAgICBpZiAoIXJhbmdlLmVtcHR5KSB7XG4gICAgICAgICAgICBjb250ZW50LnB1c2goc3RhdGUuc2xpY2VEb2MocmFuZ2UuZnJvbSwgcmFuZ2UudG8pKTtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIGlmICghY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZG8gYSBsaW5lLXdpc2UgY29weVxuICAgICAgICBsZXQgdXB0byA9IC0xO1xuICAgICAgICBmb3IgKGxldCB7IGZyb20gfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoZnJvbSk7XG4gICAgICAgICAgICBpZiAobGluZS5udW1iZXIgPiB1cHRvKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBsaW5lLmZyb20sIHRvOiBNYXRoLm1pbihzdGF0ZS5kb2MubGVuZ3RoLCBsaW5lLnRvICsgMSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cHRvID0gbGluZS5udW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXdpc2UgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geyB0ZXh0OiBjb250ZW50LmpvaW4oc3RhdGUubGluZUJyZWFrKSwgcmFuZ2VzLCBsaW5ld2lzZSB9O1xufVxubGV0IGxhc3RMaW5ld2lzZUNvcHkgPSBudWxsO1xuaGFuZGxlcnMuY29weSA9IGhhbmRsZXJzLmN1dCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGxldCB7IHRleHQsIHJhbmdlcywgbGluZXdpc2UgfSA9IGNvcGllZFJhbmdlKHZpZXcuc3RhdGUpO1xuICAgIGlmICghdGV4dCAmJiAhbGluZXdpc2UpXG4gICAgICAgIHJldHVybjtcbiAgICBsYXN0TGluZXdpc2VDb3B5ID0gbGluZXdpc2UgPyB0ZXh0IDogbnVsbDtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIGRhdGEuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjYXB0dXJlQ29weSh2aWV3LCB0ZXh0KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT0gXCJjdXRcIiAmJiAhdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgICAgICBjaGFuZ2VzOiByYW5nZXMsXG4gICAgICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXJFdmVudDogXCJkZWxldGUuY3V0XCJcbiAgICAgICAgfSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSBoYW5kbGVycy5ibHVyID0gdmlldyA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3Lmhhc0ZvY3VzICE9IHZpZXcuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZShbXSk7XG4gICAgfSwgMTApO1xufTtcbmhhbmRsZXJzLmJlZm9yZXByaW50ID0gdmlldyA9PiB7XG4gICAgdmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSB0cnVlO1xuICAgIHZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH0sIDIwMDApO1xufTtcbmZ1bmN0aW9uIGZvcmNlQ2xlYXJDb21wb3NpdGlvbih2aWV3LCByYXBpZCkge1xuICAgIGlmICh2aWV3LmRvY1ZpZXcuY29tcG9zaXRpb25EZWNvLnNpemUpIHtcbiAgICAgICAgdmlldy5pbnB1dFN0YXRlLnJhcGlkQ29tcG9zaXRpb25TdGFydCA9IHJhcGlkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmlldy51cGRhdGUoW10pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdmlldy5pbnB1dFN0YXRlLnJhcGlkQ29tcG9zaXRpb25TdGFydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuaGFuZGxlcnMuY29tcG9zaXRpb25zdGFydCA9IGhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID09IG51bGwpXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkZpcnN0Q2hhbmdlID0gdHJ1ZTtcbiAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApIHtcbiAgICAgICAgLy8gRklYTUUgcG9zc2libHkgc2V0IGEgdGltZW91dCB0byBjbGVhciBpdCBhZ2FpbiBvbiBBbmRyb2lkXG4gICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPSAwO1xuICAgICAgICBpZiAodmlldy5kb2NWaWV3LmNvbXBvc2l0aW9uRGVjby5zaXplKSB7XG4gICAgICAgICAgICB2aWV3Lm9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgICAgICBmb3JjZUNsZWFyQ29tcG9zaXRpb24odmlldywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuaGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTE7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRW5kZWRBdCA9IERhdGUubm93KCk7XG4gICAgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDApXG4gICAgICAgICAgICBmb3JjZUNsZWFyQ29tcG9zaXRpb24odmlldywgZmFsc2UpO1xuICAgIH0sIDUwKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4ge1xuICAgIHZpZXcuaW5wdXRTdGF0ZS5sYXN0Q29udGV4dE1lbnUgPSBEYXRlLm5vdygpO1xufTtcbmhhbmRsZXJzLmJlZm9yZWlucHV0ID0gKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIEJlY2F1c2UgQ2hyb21lIEFuZHJvaWQgZG9lc24ndCBmaXJlIHVzZWZ1bCBrZXkgZXZlbnRzLCB1c2VcbiAgICAvLyBiZWZvcmVpbnB1dCB0byBkZXRlY3QgYmFja3NwYWNlIChhbmQgcG9zc2libHkgZW50ZXIgYW5kIGRlbGV0ZSxcbiAgICAvLyBidXQgdGhvc2UgdXN1YWxseSBkb24ndCBldmVuIHNlZW0gdG8gZmlyZSBiZWZvcmVpbnB1dCBldmVudHMgYXRcbiAgICAvLyB0aGUgbW9tZW50KSBhbmQgZmFrZSBhIGtleSBldmVudCBmb3IgaXQuXG4gICAgLy9cbiAgICAvLyAocHJldmVudERlZmF1bHQgb24gYmVmb3JlaW5wdXQsIHRob3VnaCBzdXBwb3J0ZWQgaW4gdGhlIHNwZWMsXG4gICAgLy8gc2VlbXMgdG8gZG8gbm90aGluZyBhdCBhbGwgb24gQ2hyb21lKS5cbiAgICBsZXQgcGVuZGluZztcbiAgICBpZiAoYnJvd3Nlci5jaHJvbWUgJiYgYnJvd3Nlci5hbmRyb2lkICYmIChwZW5kaW5nID0gUGVuZGluZ0tleXMuZmluZChrZXkgPT4ga2V5LmlucHV0VHlwZSA9PSBldmVudC5pbnB1dFR5cGUpKSkge1xuICAgICAgICB2aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShwZW5kaW5nLmtleSwgcGVuZGluZy5rZXlDb2RlKTtcbiAgICAgICAgaWYgKHBlbmRpbmcua2V5ID09IFwiQmFja3NwYWNlXCIgfHwgcGVuZGluZy5rZXkgPT0gXCJEZWxldGVcIikge1xuICAgICAgICAgICAgbGV0IHN0YXJ0Vmlld0hlaWdodCA9ICgoX2EgPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oZWlnaHQpIHx8IDA7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gQmFja3NwYWNpbmcgbmVhciB1bmVkaXRhYmxlIG5vZGVzIG9uIENocm9tZSBBbmRyb2lkIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlcyB0aGUgdmlydHVhbCBrZXlib2FyZC4gVGhpcyB0cmllcyB0byBjcnVkZWx5IGRldGVjdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgYW5kIHJlZm9jdXMgdG8gZ2V0IGl0IGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKCgoKF9hID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVpZ2h0KSB8fCAwKSA+IHN0YXJ0Vmlld0hlaWdodCArIDEwICYmIHZpZXcuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5jb250ZW50RE9NLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jb25zdCB3cmFwcGluZ1doaXRlU3BhY2UgPSBbXCJwcmUtd3JhcFwiLCBcIm5vcm1hbFwiLCBcInByZS1saW5lXCIsIFwiYnJlYWstc3BhY2VzXCJdO1xuY2xhc3MgSGVpZ2h0T3JhY2xlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBUZXh0LmVtcHR5O1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSAxNDtcbiAgICAgICAgdGhpcy5jaGFyV2lkdGggPSA3O1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSAzMDtcbiAgICAgICAgLy8gVXNlZCB0byB0cmFjaywgZHVyaW5nIHVwZGF0ZUhlaWdodCwgaWYgYW55IGFjdHVhbCBoZWlnaHRzIGNoYW5nZWRcbiAgICAgICAgdGhpcy5oZWlnaHRDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuICAgIGhlaWdodEZvckdhcChmcm9tLCB0bykge1xuICAgICAgICBsZXQgbGluZXMgPSB0aGlzLmRvYy5saW5lQXQodG8pLm51bWJlciAtIHRoaXMuZG9jLmxpbmVBdChmcm9tKS5udW1iZXIgKyAxO1xuICAgICAgICBpZiAodGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICBsaW5lcyArPSBNYXRoLmNlaWwoKCh0byAtIGZyb20pIC0gKGxpbmVzICogdGhpcy5saW5lTGVuZ3RoICogMC41KSkgLyB0aGlzLmxpbmVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0ICogbGluZXM7XG4gICAgfVxuICAgIGhlaWdodEZvckxpbmUobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgbGluZXMgPSAxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZW5ndGggLSB0aGlzLmxpbmVMZW5ndGgpIC8gKHRoaXMubGluZUxlbmd0aCAtIDUpKSk7XG4gICAgICAgIHJldHVybiBsaW5lcyAqIHRoaXMubGluZUhlaWdodDtcbiAgICB9XG4gICAgc2V0RG9jKGRvYykgeyB0aGlzLmRvYyA9IGRvYzsgcmV0dXJuIHRoaXM7IH1cbiAgICBtdXN0UmVmcmVzaEZvclN0eWxlKHdoaXRlU3BhY2UsIGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gKHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTEpICE9IHRoaXMubGluZVdyYXBwaW5nIHx8IHRoaXMuZGlyZWN0aW9uICE9IGRpcmVjdGlvbjtcbiAgICB9XG4gICAgbXVzdFJlZnJlc2hGb3JIZWlnaHRzKGxpbmVIZWlnaHRzKSB7XG4gICAgICAgIGxldCBuZXdIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGggPSBsaW5lSGVpZ2h0c1tpXTtcbiAgICAgICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlaWdodFNhbXBsZXNbTWF0aC5mbG9vcihoICogMTApXSkgeyAvLyBSb3VuZCB0byAuMSBwaXhlbHNcbiAgICAgICAgICAgICAgICBuZXdIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGggKiAxMCldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3SGVpZ2h0O1xuICAgIH1cbiAgICByZWZyZXNoKHdoaXRlU3BhY2UsIGRpcmVjdGlvbiwgbGluZUhlaWdodCwgY2hhcldpZHRoLCBsaW5lTGVuZ3RoLCBrbm93bkhlaWdodHMpIHtcbiAgICAgICAgbGV0IGxpbmVXcmFwcGluZyA9IHdyYXBwaW5nV2hpdGVTcGFjZS5pbmRleE9mKHdoaXRlU3BhY2UpID4gLTE7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gTWF0aC5yb3VuZChsaW5lSGVpZ2h0KSAhPSBNYXRoLnJvdW5kKHRoaXMubGluZUhlaWdodCkgfHxcbiAgICAgICAgICAgIHRoaXMubGluZVdyYXBwaW5nICE9IGxpbmVXcmFwcGluZyB8fFxuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gIT0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLmxpbmVXcmFwcGluZyA9IGxpbmVXcmFwcGluZztcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHRoaXMuY2hhcldpZHRoID0gY2hhcldpZHRoO1xuICAgICAgICB0aGlzLmxpbmVMZW5ndGggPSBsaW5lTGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtub3duSGVpZ2h0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBoID0ga25vd25IZWlnaHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChoIDwgMClcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IoaCAqIDEwKV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbn1cbi8vIFRoaXMgb2JqZWN0IGlzIHVzZWQgYnkgYHVwZGF0ZUhlaWdodGAgdG8gbWFrZSBET00gbWVhc3VyZW1lbnRzXG4vLyBhcnJpdmUgYXQgdGhlIHJpZ2h0IG5pZGVzLiBUaGUgYGhlaWdodHNgIGFycmF5IGlzIGEgc2VxdWVuY2Ugb2Zcbi8vIGJsb2NrIGhlaWdodHMsIHN0YXJ0aW5nIGZyb20gcG9zaXRpb24gYGZyb21gLlxuY2xhc3MgTWVhc3VyZWRIZWlnaHRzIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCBoZWlnaHRzKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuaGVpZ2h0cyA9IGhlaWdodHM7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgbW9yZSgpIHsgcmV0dXJuIHRoaXMuaW5kZXggPCB0aGlzLmhlaWdodHMubGVuZ3RoOyB9XG59XG4vKipcblJlY29yZCB1c2VkIHRvIHJlcHJlc2VudCBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrLWxldmVsIGVsZW1lbnRcbmluIHRoZSBlZGl0b3Igdmlldy5cbiovXG5jbGFzcyBCbG9ja0luZm8ge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSB0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnQpLlxuICAgICovXG4gICAgdG9wLCBcbiAgICAvKipcbiAgICBJdHMgaGVpZ2h0LlxuICAgICovXG4gICAgaGVpZ2h0LCBcbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiBlbGVtZW50IHRoaXMgaXMuIFdoZW4gcXVlcnlpbmcgbGluZXMsIHRoaXMgbWF5IGJlXG4gICAgYW4gYXJyYXkgb2YgYWxsIHRoZSBibG9ja3MgdGhhdCBtYWtlIHVwIHRoZSBsaW5lLlxuICAgICovXG4gICAgdHlwZSkge1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgKi9cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYm90dG9tKCkgeyByZXR1cm4gdGhpcy50b3AgKyB0aGlzLmhlaWdodDsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgam9pbihvdGhlcikge1xuICAgICAgICBsZXQgZGV0YWlsID0gKEFycmF5LmlzQXJyYXkodGhpcy50eXBlKSA/IHRoaXMudHlwZSA6IFt0aGlzXSlcbiAgICAgICAgICAgIC5jb25jYXQoQXJyYXkuaXNBcnJheShvdGhlci50eXBlKSA/IG90aGVyLnR5cGUgOiBbb3RoZXJdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIG90aGVyLmxlbmd0aCwgdGhpcy50b3AsIHRoaXMuaGVpZ2h0ICsgb3RoZXIuaGVpZ2h0LCBkZXRhaWwpO1xuICAgIH1cbiAgICAvKipcbiAgICBGSVhNRSByZW1vdmUgb24gbmV4dCBicmVha2luZyByZWxlYXNlIEBpbnRlcm5hbFxuICAgICovXG4gICAgbW92ZVkob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAhb2Zmc2V0ID8gdGhpcyA6IG5ldyBCbG9ja0luZm8odGhpcy5mcm9tLCB0aGlzLmxlbmd0aCwgdGhpcy50b3AgKyBvZmZzZXQsIHRoaXMuaGVpZ2h0LCBBcnJheS5pc0FycmF5KHRoaXMudHlwZSkgPyB0aGlzLnR5cGUubWFwKGIgPT4gYi5tb3ZlWShvZmZzZXQpKSA6IHRoaXMudHlwZSk7XG4gICAgfVxufVxudmFyIFF1ZXJ5VHlwZSA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKFF1ZXJ5VHlwZSkge1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc1wiXSA9IDBdID0gXCJCeVBvc1wiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeUhlaWdodFwiXSA9IDFdID0gXCJCeUhlaWdodFwiO1xuICAgIFF1ZXJ5VHlwZVtRdWVyeVR5cGVbXCJCeVBvc05vSGVpZ2h0XCJdID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIjtcbnJldHVybiBRdWVyeVR5cGV9KShRdWVyeVR5cGUgfHwgKFF1ZXJ5VHlwZSA9IHt9KSk7XG5jb25zdCBFcHNpbG9uID0gMWUtMztcbmNsYXNzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCAvLyBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY292ZXJlZFxuICAgIGhlaWdodCwgLy8gSGVpZ2h0IG9mIHRoaXMgcGFydCBvZiB0aGUgZG9jdW1lbnRcbiAgICBmbGFncyA9IDIgLyogT3V0ZGF0ZWQgKi8pIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIGdldCBvdXRkYXRlZCgpIHsgcmV0dXJuICh0aGlzLmZsYWdzICYgMiAvKiBPdXRkYXRlZCAqLykgPiAwOyB9XG4gICAgc2V0IG91dGRhdGVkKHZhbHVlKSB7IHRoaXMuZmxhZ3MgPSAodmFsdWUgPyAyIC8qIE91dGRhdGVkICovIDogMCkgfCAodGhpcy5mbGFncyAmIH4yIC8qIE91dGRhdGVkICovKTsgfVxuICAgIHNldEhlaWdodChvcmFjbGUsIGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5oZWlnaHQgLSBoZWlnaHQpID4gRXBzaWxvbilcbiAgICAgICAgICAgICAgICBvcmFjbGUuaGVpZ2h0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCYXNlIGNhc2UgaXMgdG8gcmVwbGFjZSBhIGxlYWYgbm9kZSwgd2hpY2ggc2ltcGx5IGJ1aWxkcyBhIHRyZWVcbiAgICAvLyBmcm9tIHRoZSBuZXcgbm9kZXMgYW5kIHJldHVybnMgdGhhdCAoSGVpZ2h0TWFwQnJhbmNoIGFuZFxuICAgIC8vIEhlaWdodE1hcEdhcCBvdmVycmlkZSB0aGlzIHRvIGFjdHVhbGx5IHVzZSBmcm9tL3RvKVxuICAgIHJlcGxhY2UoX2Zyb20sIF90bywgbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgfVxuICAgIC8vIEFnYWluLCB0aGVzZSBhcmUgYmFzZSBjYXNlcywgYW5kIGFyZSBvdmVycmlkZGVuIGZvciBicmFuY2ggYW5kIGdhcCBub2Rlcy5cbiAgICBkZWNvbXBvc2VMZWZ0KF90bywgcmVzdWx0KSB7IHJlc3VsdC5wdXNoKHRoaXMpOyB9XG4gICAgZGVjb21wb3NlUmlnaHQoX2Zyb20sIHJlc3VsdCkgeyByZXN1bHQucHVzaCh0aGlzKTsgfVxuICAgIGFwcGx5Q2hhbmdlcyhkZWNvcmF0aW9ucywgb2xkRG9jLCBvcmFjbGUsIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IG1lID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB7IGZyb21BLCB0b0EsIGZyb21CLCB0b0IgfSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBtZS5saW5lQXQoZnJvbUEsIFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0LCBvbGREb2MsIDAsIDApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0LnRvID49IHRvQSA/IHN0YXJ0IDogbWUubGluZUF0KHRvQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9sZERvYywgMCwgMCk7XG4gICAgICAgICAgICB0b0IgKz0gZW5kLnRvIC0gdG9BO1xuICAgICAgICAgICAgdG9BID0gZW5kLnRvO1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwICYmIHN0YXJ0LmZyb20gPD0gY2hhbmdlc1tpIC0gMV0udG9BKSB7XG4gICAgICAgICAgICAgICAgZnJvbUEgPSBjaGFuZ2VzW2kgLSAxXS5mcm9tQTtcbiAgICAgICAgICAgICAgICBmcm9tQiA9IGNoYW5nZXNbaSAtIDFdLmZyb21CO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUEgPCBzdGFydC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IG1lLmxpbmVBdChmcm9tQSwgUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQsIG9sZERvYywgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tQiArPSBzdGFydC5mcm9tIC0gZnJvbUE7XG4gICAgICAgICAgICBmcm9tQSA9IHN0YXJ0LmZyb207XG4gICAgICAgICAgICBsZXQgbm9kZXMgPSBOb2RlQnVpbGRlci5idWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tQiwgdG9CKTtcbiAgICAgICAgICAgIG1lID0gbWUucmVwbGFjZShmcm9tQSwgdG9BLCBub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lLnVwZGF0ZUhlaWdodChvcmFjbGUsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZW1wdHkoKSB7IHJldHVybiBuZXcgSGVpZ2h0TWFwVGV4dCgwLCAwKTsgfVxuICAgIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAgIC8vIFRoZXJlIGFyZSBuZXZlciBsaW5lIGJyZWFrcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBhcnJheSwgb3JcbiAgICAvLyB0d28gbGluZSBicmVha3MgbmV4dCB0byBlYWNoIG90aGVyLCBhbmQgdGhlIGFycmF5IGlzbid0IGFsbG93ZWRcbiAgICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICAgIHN0YXRpYyBvZihub2Rlcykge1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXNbMF07XG4gICAgICAgIGxldCBpID0gMCwgaiA9IG5vZGVzLmxlbmd0aCwgYmVmb3JlID0gMCwgYWZ0ZXIgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA+IGFmdGVyICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5icmVhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZSgtLWksIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKC0taSwgMSwgc3BsaXQubGVmdCwgc3BsaXQucmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBqICs9IDEgKyBzcGxpdC5icmVhaztcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyID4gYmVmb3JlICogMikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3BsaXQgPSBub2Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGl0LmJyZWFrKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIG51bGwsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGosIDEsIHNwbGl0LmxlZnQsIHNwbGl0LnJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgaiArPSAyICsgc3BsaXQuYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFmdGVyIC09IHNwbGl0LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiZWZvcmUgPCBhZnRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbaSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IG5leHQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZXNbLS1qXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBicmsgPSAwO1xuICAgICAgICBpZiAobm9kZXNbaSAtIDFdID09IG51bGwpIHtcbiAgICAgICAgICAgIGJyayA9IDE7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJrID0gMTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEhlaWdodE1hcEJyYW5jaChIZWlnaHRNYXAub2Yobm9kZXMuc2xpY2UoMCwgaSkpLCBicmssIEhlaWdodE1hcC5vZihub2Rlcy5zbGljZShqKSkpO1xuICAgIH1cbn1cbkhlaWdodE1hcC5wcm90b3R5cGUuc2l6ZSA9IDE7XG5jbGFzcyBIZWlnaHRNYXBCbG9jayBleHRlbmRzIEhlaWdodE1hcCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBoZWlnaHQsIHR5cGUpIHtcbiAgICAgICAgc3VwZXIobGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBibG9ja0F0KF9oZWlnaHQsIF9kb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKG9mZnNldCwgdGhpcy5sZW5ndGgsIHRvcCwgdGhpcy5oZWlnaHQsIHRoaXMudHlwZSk7XG4gICAgfVxuICAgIGxpbmVBdChfdmFsdWUsIF90eXBlLCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQoMCwgZG9jLCB0b3AsIG9mZnNldCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKF9mcm9tLCBfdG8sIGRvYywgdG9wLCBvZmZzZXQsIGYpIHtcbiAgICAgICAgZih0aGlzLmJsb2NrQXQoMCwgZG9jLCB0b3AsIG9mZnNldCkpO1xuICAgIH1cbiAgICB1cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQgPSAwLCBfZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICB0aGlzLm91dGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBibG9jaygke3RoaXMubGVuZ3RofSlgOyB9XG59XG5jbGFzcyBIZWlnaHRNYXBUZXh0IGV4dGVuZHMgSGVpZ2h0TWFwQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlbmd0aCwgaGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkID0gMDsgLy8gQW1vdW50IG9mIGNvbGxhcHNlZCBjb250ZW50IGluIHRoZSBsaW5lXG4gICAgICAgIHRoaXMud2lkZ2V0SGVpZ2h0ID0gMDsgLy8gTWF4aW11bSBpbmxpbmUgd2lkZ2V0IGhlaWdodFxuICAgIH1cbiAgICByZXBsYWNlKF9mcm9tLCBfdG8sIG5vZGVzKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbMF07XG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMSAmJiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQgfHwgbm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcCAmJiAobm9kZS5mbGFncyAmIDQgLyogU2luZ2xlTGluZSAqLykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyh0aGlzLmxlbmd0aCAtIG5vZGUubGVuZ3RoKSA8IDEwKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcEdhcClcbiAgICAgICAgICAgICAgICBub2RlID0gbmV3IEhlaWdodE1hcFRleHQobm9kZS5sZW5ndGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgICAgIG5vZGUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEhlaWdodE1hcC5vZihub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKG1lYXN1cmVkICYmIG1lYXN1cmVkLmZyb20gPD0gb2Zmc2V0ICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG1lYXN1cmVkLmhlaWdodHNbbWVhc3VyZWQuaW5kZXgrK10pO1xuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKVxuICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQob3JhY2xlLCBNYXRoLm1heCh0aGlzLndpZGdldEhlaWdodCwgb3JhY2xlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpKTtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgbGluZSgke3RoaXMubGVuZ3RofSR7dGhpcy5jb2xsYXBzZWQgPyAtdGhpcy5jb2xsYXBzZWQgOiBcIlwifSR7dGhpcy53aWRnZXRIZWlnaHQgPyBcIjpcIiArIHRoaXMud2lkZ2V0SGVpZ2h0IDogXCJcIn0pYDtcbiAgICB9XG59XG5jbGFzcyBIZWlnaHRNYXBHYXAgZXh0ZW5kcyBIZWlnaHRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkgeyBzdXBlcihsZW5ndGgsIDApOyB9XG4gICAgbGluZXMoZG9jLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IGRvYy5saW5lQXQob2Zmc2V0KS5udW1iZXIsIGxhc3RMaW5lID0gZG9jLmxpbmVBdChvZmZzZXQgKyB0aGlzLmxlbmd0aCkubnVtYmVyO1xuICAgICAgICByZXR1cm4geyBmaXJzdExpbmUsIGxhc3RMaW5lLCBsaW5lSGVpZ2h0OiB0aGlzLmhlaWdodCAvIChsYXN0TGluZSAtIGZpcnN0TGluZSArIDEpIH07XG4gICAgfVxuICAgIGJsb2NrQXQoaGVpZ2h0LCBkb2MsIHRvcCwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGFzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBsZXQgbGluZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RMaW5lIC0gZmlyc3RMaW5lLCBNYXRoLmZsb29yKChoZWlnaHQgLSB0b3ApIC8gbGluZUhlaWdodCkpKTtcbiAgICAgICAgbGV0IHsgZnJvbSwgbGVuZ3RoIH0gPSBkb2MubGluZShmaXJzdExpbmUgKyBsaW5lKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oZnJvbSwgbGVuZ3RoLCB0b3AgKyBsaW5lSGVpZ2h0ICogbGluZSwgbGluZUhlaWdodCwgQmxvY2tUeXBlLlRleHQpO1xuICAgIH1cbiAgICBsaW5lQXQodmFsdWUsIHR5cGUsIGRvYywgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2tBdCh2YWx1ZSwgZG9jLCB0b3AsIG9mZnNldCk7XG4gICAgICAgIGlmICh0eXBlID09IFF1ZXJ5VHlwZS5CeVBvc05vSGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrSW5mbyhmcm9tLCB0byAtIGZyb20sIDAsIDAsIEJsb2NrVHlwZS5UZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmaXJzdExpbmUsIGxpbmVIZWlnaHQgfSA9IHRoaXMubGluZXMoZG9jLCBvZmZzZXQpO1xuICAgICAgICBsZXQgeyBmcm9tLCBsZW5ndGgsIG51bWJlciB9ID0gZG9jLmxpbmVBdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tJbmZvKGZyb20sIGxlbmd0aCwgdG9wICsgbGluZUhlaWdodCAqIChudW1iZXIgLSBmaXJzdExpbmUpLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCk7XG4gICAgfVxuICAgIGZvckVhY2hMaW5lKGZyb20sIHRvLCBkb2MsIHRvcCwgb2Zmc2V0LCBmKSB7XG4gICAgICAgIGxldCB7IGZpcnN0TGluZSwgbGluZUhlaWdodCB9ID0gdGhpcy5saW5lcyhkb2MsIG9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KGZyb20sIG9mZnNldCksIGVuZCA9IE1hdGgubWluKG9mZnNldCArIHRoaXMubGVuZ3RoLCB0byk7IHBvcyA8PSBlbmQ7KSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChwb3MgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodCAqIChsaW5lLm51bWJlciAtIGZpcnN0TGluZSk7XG4gICAgICAgICAgICBmKG5ldyBCbG9ja0luZm8obGluZS5mcm9tLCBsaW5lLmxlbmd0aCwgdG9wLCBsaW5lSGVpZ2h0LCBCbG9ja1R5cGUuVGV4dCkpO1xuICAgICAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBwb3MgPSBsaW5lLnRvICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxlbmd0aCAtIHRvO1xuICAgICAgICBpZiAoYWZ0ZXIgPiAwKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXApXG4gICAgICAgICAgICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0gPSBuZXcgSGVpZ2h0TWFwR2FwKGxhc3QubGVuZ3RoICsgYWZ0ZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobnVsbCwgbmV3IEhlaWdodE1hcEdhcChhZnRlciAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA+IDApIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICAgICAgICAgIG5vZGVzWzBdID0gbmV3IEhlaWdodE1hcEdhcChmcm9tICsgZmlyc3QubGVuZ3RoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBub2Rlcy51bnNoaWZ0KG5ldyBIZWlnaHRNYXBHYXAoZnJvbSAtIDEpLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICB9XG4gICAgZGVjb21wb3NlTGVmdCh0bywgcmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBIZWlnaHRNYXBHYXAodG8gLSAxKSwgbnVsbCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICByZXN1bHQucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKHRoaXMubGVuZ3RoIC0gZnJvbSAtIDEpKTtcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldCArIHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAobWVhc3VyZWQgJiYgbWVhc3VyZWQuZnJvbSA8PSBvZmZzZXQgKyB0aGlzLmxlbmd0aCAmJiBtZWFzdXJlZC5tb3JlKSB7XG4gICAgICAgICAgICAvLyBGaWxsIGluIHBhcnQgb2YgdGhpcyBnYXAgd2l0aCBtZWFzdXJlZCBsaW5lcy4gV2Uga25vdyB0aGVyZVxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgd2lkZ2V0cyBvciBjb2xsYXBzZWQgcmFuZ2VzIGluIHRob3NlIGxpbmVzLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGV5IHdvdWxkIGFscmVhZHkgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBoZWlnaHRtYXAgKGdhcHNcbiAgICAgICAgICAgIC8vIG9ubHkgY29udGFpbiBwbGFpbiB0ZXh0KS5cbiAgICAgICAgICAgIGxldCBub2RlcyA9IFtdLCBwb3MgPSBNYXRoLm1heChvZmZzZXQsIG1lYXN1cmVkLmZyb20pLCBzaW5nbGVIZWlnaHQgPSAtMTtcbiAgICAgICAgICAgIGxldCB3YXNDaGFuZ2VkID0gb3JhY2xlLmhlaWdodENoYW5nZWQ7XG4gICAgICAgICAgICBpZiAobWVhc3VyZWQuZnJvbSA+IG9mZnNldClcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBHYXAobWVhc3VyZWQuZnJvbSAtIG9mZnNldCAtIDEpLnVwZGF0ZUhlaWdodChvcmFjbGUsIG9mZnNldCkpO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8PSBlbmQgJiYgbWVhc3VyZWQubW9yZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZW4gPSBvcmFjbGUuZG9jLmxpbmVBdChwb3MpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHRzW21lYXN1cmVkLmluZGV4KytdO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVIZWlnaHQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhoZWlnaHQgLSBzaW5nbGVIZWlnaHQpID49IEVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUhlaWdodCA9IC0yO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQobGVuLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGxpbmUub3V0ZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW4gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChudWxsLCBuZXcgSGVpZ2h0TWFwR2FwKGVuZCAtIHBvcykudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcG9zKSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gSGVpZ2h0TWFwLm9mKG5vZGVzKTtcbiAgICAgICAgICAgIG9yYWNsZS5oZWlnaHRDaGFuZ2VkID0gd2FzQ2hhbmdlZCB8fCBzaW5nbGVIZWlnaHQgPCAwIHx8IE1hdGguYWJzKHJlc3VsdC5oZWlnaHQgLSB0aGlzLmhlaWdodCkgPj0gRXBzaWxvbiB8fFxuICAgICAgICAgICAgICAgIE1hdGguYWJzKHNpbmdsZUhlaWdodCAtIHRoaXMubGluZXMob3JhY2xlLmRvYywgb2Zmc2V0KS5saW5lSGVpZ2h0KSA+PSBFcHNpbG9uO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZSB8fCB0aGlzLm91dGRhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhlaWdodChvcmFjbGUsIG9yYWNsZS5oZWlnaHRGb3JHYXAob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIGBnYXAoJHt0aGlzLmxlbmd0aH0pYDsgfVxufVxuY2xhc3MgSGVpZ2h0TWFwQnJhbmNoIGV4dGVuZHMgSGVpZ2h0TWFwIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCBicmssIHJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGxlZnQubGVuZ3RoICsgYnJrICsgcmlnaHQubGVuZ3RoLCBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodCwgYnJrIHwgKGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQgPyAyIC8qIE91dGRhdGVkICovIDogMCkpO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgfVxuICAgIGdldCBicmVhaygpIHsgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxIC8qIEJyZWFrICovOyB9XG4gICAgYmxvY2tBdChoZWlnaHQsIGRvYywgdG9wLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IG1pZCA9IHRvcCArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBoZWlnaHQgPCBtaWQgPyB0aGlzLmxlZnQuYmxvY2tBdChoZWlnaHQsIGRvYywgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQuYmxvY2tBdChoZWlnaHQsIGRvYywgbWlkLCBvZmZzZXQgKyB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhayk7XG4gICAgfVxuICAgIGxpbmVBdCh2YWx1ZSwgdHlwZSwgZG9jLCB0b3AsIG9mZnNldCkge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBsZXQgbGVmdCA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5SGVpZ2h0ID8gdmFsdWUgPCByaWdodFRvcCA6IHZhbHVlIDwgcmlnaHRPZmZzZXQ7XG4gICAgICAgIGxldCBiYXNlID0gbGVmdCA/IHRoaXMubGVmdC5saW5lQXQodmFsdWUsIHR5cGUsIGRvYywgdG9wLCBvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMucmlnaHQubGluZUF0KHZhbHVlLCB0eXBlLCBkb2MsIHJpZ2h0VG9wLCByaWdodE9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmJyZWFrIHx8IChsZWZ0ID8gYmFzZS50byA8IHJpZ2h0T2Zmc2V0IDogYmFzZS5mcm9tID4gcmlnaHRPZmZzZXQpKVxuICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIGxldCBzdWJRdWVyeSA9IHR5cGUgPT0gUXVlcnlUeXBlLkJ5UG9zTm9IZWlnaHQgPyBRdWVyeVR5cGUuQnlQb3NOb0hlaWdodCA6IFF1ZXJ5VHlwZS5CeVBvcztcbiAgICAgICAgaWYgKGxlZnQpXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5qb2luKHRoaXMucmlnaHQubGluZUF0KHJpZ2h0T2Zmc2V0LCBzdWJRdWVyeSwgZG9jLCByaWdodFRvcCwgcmlnaHRPZmZzZXQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5saW5lQXQocmlnaHRPZmZzZXQsIHN1YlF1ZXJ5LCBkb2MsIHRvcCwgb2Zmc2V0KS5qb2luKGJhc2UpO1xuICAgIH1cbiAgICBmb3JFYWNoTGluZShmcm9tLCB0bywgZG9jLCB0b3AsIG9mZnNldCwgZikge1xuICAgICAgICBsZXQgcmlnaHRUb3AgPSB0b3AgKyB0aGlzLmxlZnQuaGVpZ2h0LCByaWdodE9mZnNldCA9IG9mZnNldCArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCByaWdodE9mZnNldClcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIGRvYywgdG9wLCBvZmZzZXQsIGYpO1xuICAgICAgICAgICAgaWYgKHRvID49IHJpZ2h0T2Zmc2V0KVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUoZnJvbSwgdG8sIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtaWQgPSB0aGlzLmxpbmVBdChyaWdodE9mZnNldCwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIHRvcCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgbWlkLmZyb20pXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGZyb20sIG1pZC5mcm9tIC0gMSwgZG9jLCB0b3AsIG9mZnNldCwgZik7XG4gICAgICAgICAgICBpZiAobWlkLnRvID49IGZyb20gJiYgbWlkLmZyb20gPD0gdG8pXG4gICAgICAgICAgICAgICAgZihtaWQpO1xuICAgICAgICAgICAgaWYgKHRvID4gbWlkLnRvKVxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaExpbmUobWlkLnRvICsgMSwgdG8sIGRvYywgcmlnaHRUb3AsIHJpZ2h0T2Zmc2V0LCBmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlKGZyb20sIHRvLCBub2Rlcykge1xuICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgICAgICBpZiAodG8gPCByaWdodFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LnJlcGxhY2UoZnJvbSwgdG8sIG5vZGVzKSwgdGhpcy5yaWdodCk7XG4gICAgICAgIGlmIChmcm9tID4gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhbGFuY2VkKHRoaXMubGVmdCwgdGhpcy5yaWdodC5yZXBsYWNlKGZyb20gLSByaWdodFN0YXJ0LCB0byAtIHJpZ2h0U3RhcnQsIG5vZGVzKSk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKGZyb20gPiAwKVxuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VMZWZ0KGZyb20sIHJlc3VsdCk7XG4gICAgICAgIGxldCBsZWZ0ID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2RlcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoZnJvbSA+IDApXG4gICAgICAgICAgICBtZXJnZUdhcHMocmVzdWx0LCBsZWZ0IC0gMSk7XG4gICAgICAgIGlmICh0byA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmlnaHQgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodCh0bywgcmVzdWx0KTtcbiAgICAgICAgICAgIG1lcmdlR2FwcyhyZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZUxlZnQodG8sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgICAgIGlmICh0byA8PSBsZWZ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5kZWNvbXBvc2VMZWZ0KHRvLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxlZnQpO1xuICAgICAgICBpZiAodGhpcy5icmVhaykge1xuICAgICAgICAgICAgbGVmdCsrO1xuICAgICAgICAgICAgaWYgKHRvID49IGxlZnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvID4gbGVmdClcbiAgICAgICAgICAgIHRoaXMucmlnaHQuZGVjb21wb3NlTGVmdCh0byAtIGxlZnQsIHJlc3VsdCk7XG4gICAgfVxuICAgIGRlY29tcG9zZVJpZ2h0KGZyb20sIHJlc3VsdCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdC5sZW5ndGgsIHJpZ2h0ID0gbGVmdCArIHRoaXMuYnJlYWs7XG4gICAgICAgIGlmIChmcm9tID49IHJpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuZGVjb21wb3NlUmlnaHQoZnJvbSAtIHJpZ2h0LCByZXN1bHQpO1xuICAgICAgICBpZiAoZnJvbSA8IGxlZnQpXG4gICAgICAgICAgICB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZnJvbSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuYnJlYWsgJiYgZnJvbSA8IHJpZ2h0KVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobnVsbCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucmlnaHQpO1xuICAgIH1cbiAgICBiYWxhbmNlZChsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAobGVmdC5zaXplID4gMiAqIHJpZ2h0LnNpemUgfHwgcmlnaHQuc2l6ZSA+IDIgKiBsZWZ0LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gSGVpZ2h0TWFwLm9mKHRoaXMuYnJlYWsgPyBbbGVmdCwgbnVsbCwgcmlnaHRdIDogW2xlZnQsIHJpZ2h0XSk7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBsZWZ0LmhlaWdodCArIHJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGxlZnQub3V0ZGF0ZWQgfHwgcmlnaHQub3V0ZGF0ZWQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGxlZnQuc2l6ZSArIHJpZ2h0LnNpemU7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrICsgcmlnaHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0ID0gMCwgZm9yY2UgPSBmYWxzZSwgbWVhc3VyZWQpIHtcbiAgICAgICAgbGV0IHsgbGVmdCwgcmlnaHQgfSA9IHRoaXMsIHJpZ2h0U3RhcnQgPSBvZmZzZXQgKyBsZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIHJlYmFsYW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IG9mZnNldCArIGxlZnQubGVuZ3RoICYmIG1lYXN1cmVkLm1vcmUpXG4gICAgICAgICAgICByZWJhbGFuY2UgPSBsZWZ0ID0gbGVmdC51cGRhdGVIZWlnaHQob3JhY2xlLCBvZmZzZXQsIGZvcmNlLCBtZWFzdXJlZCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlZnQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgb2Zmc2V0LCBmb3JjZSk7XG4gICAgICAgIGlmIChtZWFzdXJlZCAmJiBtZWFzdXJlZC5mcm9tIDw9IHJpZ2h0U3RhcnQgKyByaWdodC5sZW5ndGggJiYgbWVhc3VyZWQubW9yZSlcbiAgICAgICAgICAgIHJlYmFsYW5jZSA9IHJpZ2h0ID0gcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UsIG1lYXN1cmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmlnaHQudXBkYXRlSGVpZ2h0KG9yYWNsZSwgcmlnaHRTdGFydCwgZm9yY2UpO1xuICAgICAgICBpZiAocmViYWxhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQobGVmdCwgcmlnaHQpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubGVmdC5oZWlnaHQgKyB0aGlzLnJpZ2h0LmhlaWdodDtcbiAgICAgICAgdGhpcy5vdXRkYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLmxlZnQgKyAodGhpcy5icmVhayA/IFwiIFwiIDogXCItXCIpICsgdGhpcy5yaWdodDsgfVxufVxuZnVuY3Rpb24gbWVyZ2VHYXBzKG5vZGVzLCBhcm91bmQpIHtcbiAgICBsZXQgYmVmb3JlLCBhZnRlcjtcbiAgICBpZiAobm9kZXNbYXJvdW5kXSA9PSBudWxsICYmXG4gICAgICAgIChiZWZvcmUgPSBub2Rlc1thcm91bmQgLSAxXSkgaW5zdGFuY2VvZiBIZWlnaHRNYXBHYXAgJiZcbiAgICAgICAgKGFmdGVyID0gbm9kZXNbYXJvdW5kICsgMV0pIGluc3RhbmNlb2YgSGVpZ2h0TWFwR2FwKVxuICAgICAgICBub2Rlcy5zcGxpY2UoYXJvdW5kIC0gMSwgMywgbmV3IEhlaWdodE1hcEdhcChiZWZvcmUubGVuZ3RoICsgMSArIGFmdGVyLmxlbmd0aCkpO1xufVxuY29uc3QgcmVsZXZhbnRXaWRnZXRIZWlnaHQgPSA1O1xuY2xhc3MgTm9kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcywgb3JhY2xlKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLm9yYWNsZSA9IG9yYWNsZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSAtMTtcbiAgICAgICAgdGhpcy5jb3ZlcmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gcG9zO1xuICAgIH1cbiAgICBnZXQgaXNDb3ZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb3ZlcmluZyAmJiB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gPT0gdGhpcy5jb3ZlcmluZztcbiAgICB9XG4gICAgc3BhbihfZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbih0bywgdGhpcy5saW5lRW5kKSwgbGFzdCA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dClcbiAgICAgICAgICAgICAgICBsYXN0Lmxlbmd0aCArPSBlbmQgLSB0aGlzLnBvcztcbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA+IHRoaXMucG9zIHx8ICF0aGlzLmlzQ292ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQoZW5kIC0gdGhpcy5wb3MsIC0xKSk7XG4gICAgICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IGVuZDtcbiAgICAgICAgICAgIGlmICh0byA+IGVuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXR0ZW5UbysrO1xuICAgICAgICAgICAgICAgIHRoaXMubGluZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgPSB0bztcbiAgICB9XG4gICAgcG9pbnQoZnJvbSwgdG8sIGRlY28pIHtcbiAgICAgICAgaWYgKGZyb20gPCB0byB8fCBkZWNvLmhlaWdodFJlbGV2YW50KSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZGVjby53aWRnZXQgPyBkZWNvLndpZGdldC5lc3RpbWF0ZWRIZWlnaHQgOiAwO1xuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5vcmFjbGUubGluZUhlaWdodDtcbiAgICAgICAgICAgIGxldCBsZW4gPSB0byAtIGZyb207XG4gICAgICAgICAgICBpZiAoZGVjby5ibG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQmxvY2sobmV3IEhlaWdodE1hcEJsb2NrKGxlbiwgaGVpZ2h0LCBkZWNvLnR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiB8fCBoZWlnaHQgPj0gcmVsZXZhbnRXaWRnZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExpbmVEZWNvKGhlaWdodCwgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byA+IGZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuc3Bhbihmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zKVxuICAgICAgICAgICAgdGhpcy5saW5lRW5kID0gdGhpcy5vcmFjbGUuZG9jLmxpbmVBdCh0aGlzLnBvcykudG87XG4gICAgfVxuICAgIGVudGVyTGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5saW5lU3RhcnQgPSBmcm9tO1xuICAgICAgICB0aGlzLmxpbmVFbmQgPSB0bztcbiAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSkge1xuICAgICAgICAgICAgaWYgKHRoaXMud3JpdHRlblRvIDwgZnJvbSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCBmcm9tIC0gMSkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvcyA+IGZyb20pXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IEhlaWdodE1hcFRleHQodGhpcy5wb3MgLSBmcm9tLCAtMSkpO1xuICAgICAgICB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICAgIH1cbiAgICBibGFua0NvbnRlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG5ldyBIZWlnaHRNYXBHYXAodG8gLSBmcm9tKTtcbiAgICAgICAgaWYgKHRoaXMub3JhY2xlLmRvYy5saW5lQXQoZnJvbSkudG8gPT0gdG8pXG4gICAgICAgICAgICBnYXAuZmxhZ3MgfD0gNCAvKiBTaW5nbGVMaW5lICovO1xuICAgICAgICByZXR1cm4gZ2FwO1xuICAgIH1cbiAgICBlbnN1cmVMaW5lKCkge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubm9kZXMubGVuZ3RoID8gdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICAgICAgaWYgKGxhc3QgaW5zdGFuY2VvZiBIZWlnaHRNYXBUZXh0KVxuICAgICAgICAgICAgcmV0dXJuIGxhc3Q7XG4gICAgICAgIGxldCBsaW5lID0gbmV3IEhlaWdodE1hcFRleHQoMCwgLTEpO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobGluZSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICBhZGRCbG9jayhibG9jaykge1xuICAgICAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuV2lkZ2V0QWZ0ZXIgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5lbnN1cmVMaW5lKCk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChibG9jayk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGJsb2NrLmxlbmd0aDtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgIT0gQmxvY2tUeXBlLldpZGdldEJlZm9yZSlcbiAgICAgICAgICAgIHRoaXMuY292ZXJpbmcgPSBibG9jaztcbiAgICB9XG4gICAgYWRkTGluZURlY28oaGVpZ2h0LCBsZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmVuc3VyZUxpbmUoKTtcbiAgICAgICAgbGluZS5sZW5ndGggKz0gbGVuZ3RoO1xuICAgICAgICBsaW5lLmNvbGxhcHNlZCArPSBsZW5ndGg7XG4gICAgICAgIGxpbmUud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgobGluZS53aWRnZXRIZWlnaHQsIGhlaWdodCk7XG4gICAgICAgIHRoaXMud3JpdHRlblRvID0gdGhpcy5wb3MgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICB9XG4gICAgZmluaXNoKGZyb20pIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEgJiYgIShsYXN0IGluc3RhbmNlb2YgSGVpZ2h0TWFwVGV4dCkgJiYgIXRoaXMuaXNDb3ZlcmVkKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKG5ldyBIZWlnaHRNYXBUZXh0KDAsIC0xKSk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3JpdHRlblRvIDwgdGhpcy5wb3MgfHwgbGFzdCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuYmxhbmtDb250ZW50KHRoaXMud3JpdHRlblRvLCB0aGlzLnBvcykpO1xuICAgICAgICBsZXQgcG9zID0gZnJvbTtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhlaWdodE1hcFRleHQpXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVIZWlnaHQodGhpcy5vcmFjbGUsIHBvcyk7XG4gICAgICAgICAgICBwb3MgKz0gbm9kZSA/IG5vZGUubGVuZ3RoIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcbiAgICB9XG4gICAgLy8gQWx3YXlzIGNhbGxlZCB3aXRoIGEgcmVnaW9uIHRoYXQgb24gYm90aCBzaWRlcyBlaXRoZXIgc3RyZXRjaGVzXG4gICAgLy8gdG8gYSBsaW5lIGJyZWFrIG9yIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAgIC8vIHN0YXJ0cyBvciBlbmRzIGluIGEgbGluZSBicmVhaywgb3IgaGFzIG11bHRpcGxlIGxpbmUgYnJlYWtzIG5leHRcbiAgICAvLyB0byBlYWNoIG90aGVyLlxuICAgIHN0YXRpYyBidWlsZChvcmFjbGUsIGRlY29yYXRpb25zLCBmcm9tLCB0bykge1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBOb2RlQnVpbGRlcihmcm9tLCBvcmFjbGUpO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvcmF0aW9ucywgZnJvbSwgdG8sIGJ1aWxkZXIsIDApO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goZnJvbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGVpZ2h0UmVsZXZhbnREZWNvQ2hhbmdlcyhhLCBiLCBkaWZmKSB7XG4gICAgbGV0IGNvbXAgPSBuZXcgRGVjb3JhdGlvbkNvbXBhcmF0b3I7XG4gICAgUmFuZ2VTZXQuY29tcGFyZShhLCBiLCBkaWZmLCBjb21wLCAwKTtcbiAgICByZXR1cm4gY29tcC5jaGFuZ2VzO1xufVxuY2xhc3MgRGVjb3JhdGlvbkNvbXBhcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgICB9XG4gICAgY29tcGFyZVJhbmdlKCkgeyB9XG4gICAgY29tcGFyZVBvaW50KGZyb20sIHRvLCBhLCBiKSB7XG4gICAgICAgIGlmIChmcm9tIDwgdG8gfHwgYSAmJiBhLmhlaWdodFJlbGV2YW50IHx8IGIgJiYgYi5oZWlnaHRSZWxldmFudClcbiAgICAgICAgICAgIGFkZFJhbmdlKGZyb20sIHRvLCB0aGlzLmNoYW5nZXMsIDUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaWJsZVBpeGVsUmFuZ2UoZG9tLCBwYWRkaW5nVG9wKSB7XG4gICAgbGV0IHJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGxlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQpLCByaWdodCA9IE1hdGgubWluKGlubmVyV2lkdGgsIHJlY3QucmlnaHQpO1xuICAgIGxldCB0b3AgPSBNYXRoLm1heCgwLCByZWN0LnRvcCksIGJvdHRvbSA9IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgbGV0IGJvZHkgPSBkb20ub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGZvciAobGV0IHBhcmVudCA9IGRvbS5wYXJlbnROb2RlOyBwYXJlbnQgJiYgcGFyZW50ICE9IGJvZHk7KSB7XG4gICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGVsdCA9IHBhcmVudDtcbiAgICAgICAgICAgIGxldCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsdCk7XG4gICAgICAgICAgICBpZiAoKGVsdC5zY3JvbGxIZWlnaHQgPiBlbHQuY2xpZW50SGVpZ2h0IHx8IGVsdC5zY3JvbGxXaWR0aCA+IGVsdC5jbGllbnRXaWR0aCkgJiZcbiAgICAgICAgICAgICAgICBzdHlsZS5vdmVyZmxvdyAhPSBcInZpc2libGVcIikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRSZWN0ID0gZWx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBwYXJlbnRSZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIHBhcmVudFJlY3QucmlnaHQpO1xuICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgcGFyZW50UmVjdC50b3ApO1xuICAgICAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgcGFyZW50UmVjdC5ib3R0b20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gc3R5bGUucG9zaXRpb24gPT0gXCJhYnNvbHV0ZVwiIHx8IHN0eWxlLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IGVsdC5vZmZzZXRQYXJlbnQgOiBlbHQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJlbnQubm9kZVR5cGUgPT0gMTEpIHsgLy8gU2hhZG93IHJvb3RcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHJlY3QubGVmdCwgcmlnaHQ6IE1hdGgubWF4KGxlZnQsIHJpZ2h0KSAtIHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiB0b3AgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSwgYm90dG9tOiBNYXRoLm1heCh0b3AsIGJvdHRvbSkgLSAocmVjdC50b3AgKyBwYWRkaW5nVG9wKSB9O1xufVxuLy8gTGluZSBnYXBzIGFyZSBwbGFjZWhvbGRlciB3aWRnZXRzIHVzZWQgdG8gaGlkZSBwaWVjZXMgb2Ygb3Zlcmxvbmdcbi8vIGxpbmVzIHdpdGhpbiB0aGUgdmlld3BvcnQsIGFzIGEga2x1ZGdlIHRvIGtlZXAgdGhlIGVkaXRvclxuLy8gcmVzcG9uc2l2ZSB3aGVuIGEgcmlkaWN1bG91c2x5IGxvbmcgbGluZSBpcyBsb2FkZWQgaW50byBpdC5cbmNsYXNzIExpbmVHYXAge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBzaXplKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIHNhbWUoYSwgYikge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGdBID0gYVtpXSwgZ0IgPSBiW2ldO1xuICAgICAgICAgICAgaWYgKGdBLmZyb20gIT0gZ0IuZnJvbSB8fCBnQS50byAhPSBnQi50byB8fCBnQS5zaXplICE9IGdCLnNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcmF3KHdyYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBMaW5lR2FwV2lkZ2V0KHRoaXMuc2l6ZSwgd3JhcHBpbmcpIH0pLnJhbmdlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgfVxufVxuY2xhc3MgTGluZUdhcFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNpemUsIHZlcnRpY2FsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVydGljYWwgPSB2ZXJ0aWNhbDtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLnNpemUgPT0gdGhpcy5zaXplICYmIG90aGVyLnZlcnRpY2FsID09IHRoaXMudmVydGljYWw7IH1cbiAgICB0b0RPTSgpIHtcbiAgICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICBlbHQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWx0LnN0eWxlLndpZHRoID0gdGhpcy5zaXplICsgXCJweFwiO1xuICAgICAgICAgICAgZWx0LnN0eWxlLmhlaWdodCA9IFwiMnB4XCI7XG4gICAgICAgICAgICBlbHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG4gICAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHsgcmV0dXJuIHRoaXMudmVydGljYWwgPyB0aGlzLnNpemUgOiAtMTsgfVxufVxuY2xhc3MgVmlld1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFRoZXNlIGFyZSBjb250ZW50RE9NLWxvY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHsgbGVmdDogMCwgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLCB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICAgICAgICB0aGlzLmluVmlldyA9IHRydWU7XG4gICAgICAgIHRoaXMucGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICAgIHRoaXMuY29udGVudERPTVdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5lZGl0b3JIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmVkaXRvcldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWlnaHRPcmFjbGUgPSBuZXcgSGVpZ2h0T3JhY2xlO1xuICAgICAgICAvLyBTZWUgVlAuTWF4RE9NSGVpZ2h0XG4gICAgICAgIHRoaXMuc2NhbGVyID0gSWRTY2FsZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gQnJpZWZseSBzZXQgdG8gdHJ1ZSB3aGVuIHByaW50aW5nLCB0byBkaXNhYmxlIHZpZXdwb3J0IGxpbWl0aW5nXG4gICAgICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gRmxhZyBzZXQgd2hlbiBlZGl0b3IgY29udGVudCB3YXMgcmVkcmF3biwgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHN0YWdlIGtub3dzIGl0IG11c3QgcmVhZCBET00gbGF5b3V0XG4gICAgICAgIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy52aXNpYmxlUmFuZ2VzID0gW107XG4gICAgICAgIC8vIEN1cnNvciAnYXNzb2MnIGlzIG9ubHkgc2lnbmlmaWNhbnQgd2hlbiB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZVxuICAgICAgICAvLyB3cmFwIHBvaW50LCB3aGVyZSBpdCBtdXN0IHN0aWNrIHRvIHRoZSBjaGFyYWN0ZXIgdGhhdCBpdCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGguIFNpbmNlIGJyb3dzZXJzIGRvbid0IHByb3ZpZGUgYSByZWFzb25hYmxlXG4gICAgICAgIC8vIGludGVyZmFjZSB0byBzZXQgb3IgcXVlcnkgdGhpcywgd2hlbiBhIHNlbGVjdGlvbiBpcyBzZXQgdGhhdFxuICAgICAgICAvLyBtaWdodCBjYXVzZSB0aGlzIHRvIGJlIHNpZ25pZmljYW50LCB0aGlzIGZsYWcgaXMgc2V0LiBUaGUgbmV4dFxuICAgICAgICAvLyBtZWFzdXJlIHBoYXNlIHdpbGwgY2hlY2sgd2hldGhlciB0aGUgY3Vyc29yIGlzIG9uIGEgbGluZS13cmFwcGluZ1xuICAgICAgICAvLyBib3VuZGFyeSBhbmQsIGlmIHNvLCByZXNldCBpdCB0byBtYWtlIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBpblxuICAgICAgICAvLyB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlaWdodE1hcCA9IEhlaWdodE1hcC5lbXB0eSgpLmFwcGx5Q2hhbmdlcyhzdGF0ZS5mYWNldChkZWNvcmF0aW9ucyksIFRleHQuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhzdGF0ZS5kb2MpLCBbbmV3IENoYW5nZWRSYW5nZSgwLCAwLCAwLCBzdGF0ZS5kb2MubGVuZ3RoKV0pO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBudWxsKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pO1xuICAgICAgICB0aGlzLmxpbmVHYXBEZWNvID0gRGVjb3JhdGlvbi5zZXQodGhpcy5saW5lR2Fwcy5tYXAoZ2FwID0+IGdhcC5kcmF3KGZhbHNlKSkpO1xuICAgICAgICB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUZvclZpZXdwb3J0KCkge1xuICAgICAgICBsZXQgdmlld3BvcnRzID0gW3RoaXMudmlld3BvcnRdLCB7IG1haW4gfSA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBpID8gbWFpbi5oZWFkIDogbWFpbi5hbmNob3I7XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0cy5zb21lKCh7IGZyb20sIHRvIH0pID0+IHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5saW5lQmxvY2tBdChwb3MpO1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0cy5wdXNoKG5ldyBWaWV3cG9ydChmcm9tLCB0bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLnNvcnQoKGEsIGIpID0+IGEuZnJvbSAtIGIuZnJvbSk7XG4gICAgICAgIHRoaXMuc2NhbGVyID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0IDw9IDcwMDAwMDAgLyogTWF4RE9NSGVpZ2h0ICovID8gSWRTY2FsZXIgOlxuICAgICAgICAgICAgbmV3IEJpZ1NjYWxlcih0aGlzLmhlaWdodE9yYWNsZS5kb2MsIHRoaXMuaGVpZ2h0TWFwLCB0aGlzLnZpZXdwb3J0cyk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXdwb3J0TGluZXMoKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnRMaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmhlaWdodE1hcC5mb3JFYWNoTGluZSh0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHRoaXMuc3RhdGUuZG9jLCAwLCAwLCBibG9jayA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0TGluZXMucHVzaCh0aGlzLnNjYWxlci5zY2FsZSA9PSAxID8gYmxvY2sgOiBzY2FsZUJsb2NrKGJsb2NrLCB0aGlzLnNjYWxlcikpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSwgc2Nyb2xsVGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB1cGRhdGUuc3RhdGU7XG4gICAgICAgIGxldCBuZXdEZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucyk7XG4gICAgICAgIGxldCBjb250ZW50Q2hhbmdlcyA9IHVwZGF0ZS5jaGFuZ2VkUmFuZ2VzO1xuICAgICAgICBsZXQgaGVpZ2h0Q2hhbmdlcyA9IENoYW5nZWRSYW5nZS5leHRlbmRXaXRoUmFuZ2VzKGNvbnRlbnRDaGFuZ2VzLCBoZWlnaHRSZWxldmFudERlY29DaGFuZ2VzKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGRlY29yYXRpb25zKSwgbmV3RGVjbywgdXBkYXRlID8gdXBkYXRlLmNoYW5nZXMgOiBDaGFuZ2VTZXQuZW1wdHkodGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkpO1xuICAgICAgICBsZXQgcHJldkhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSB0aGlzLmhlaWdodE1hcC5hcHBseUNoYW5nZXMobmV3RGVjbywgcHJldi5kb2MsIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyh0aGlzLnN0YXRlLmRvYyksIGhlaWdodENoYW5nZXMpO1xuICAgICAgICBpZiAodGhpcy5oZWlnaHRNYXAuaGVpZ2h0ICE9IHByZXZIZWlnaHQpXG4gICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gMiAvKiBIZWlnaHQgKi87XG4gICAgICAgIGxldCB2aWV3cG9ydCA9IGhlaWdodENoYW5nZXMubGVuZ3RoID8gdGhpcy5tYXBWaWV3cG9ydCh0aGlzLnZpZXdwb3J0LCB1cGRhdGUuY2hhbmdlcykgOiB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0ICYmIChzY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA8IHZpZXdwb3J0LmZyb20gfHwgc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB2aWV3cG9ydC50bykgfHxcbiAgICAgICAgICAgICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh2aWV3cG9ydCkpXG4gICAgICAgICAgICB2aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQoMCwgc2Nyb2xsVGFyZ2V0KTtcbiAgICAgICAgbGV0IHVwZGF0ZUxpbmVzID0gIXVwZGF0ZS5jaGFuZ2VzLmVtcHR5IHx8ICh1cGRhdGUuZmxhZ3MgJiAyIC8qIEhlaWdodCAqLykgfHxcbiAgICAgICAgICAgIHZpZXdwb3J0LmZyb20gIT0gdGhpcy52aWV3cG9ydC5mcm9tIHx8IHZpZXdwb3J0LnRvICE9IHRoaXMudmlld3BvcnQudG87XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpO1xuICAgICAgICBpZiAodXBkYXRlTGluZXMpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiA0MDAwIC8qIERvdWJsZU1hcmdpbiAqLylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2Fwcyh0aGlzLm1hcExpbmVHYXBzKHRoaXMubGluZUdhcHMsIHVwZGF0ZS5jaGFuZ2VzKSkpO1xuICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpO1xuICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQ7XG4gICAgICAgIGlmICghdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmIHVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgdXBkYXRlLnZpZXcubGluZVdyYXBwaW5nICYmXG4gICAgICAgICAgICB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgdXBkYXRlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jKVxuICAgICAgICAgICAgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gdHJ1ZTtcbiAgICB9XG4gICAgbWVhc3VyZSh2aWV3KSB7XG4gICAgICAgIGxldCBkb20gPSB2aWV3LmNvbnRlbnRET00sIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tKTtcbiAgICAgICAgbGV0IG9yYWNsZSA9IHRoaXMuaGVpZ2h0T3JhY2xlO1xuICAgICAgICBsZXQgd2hpdGVTcGFjZSA9IHN0eWxlLndoaXRlU3BhY2UsIGRpcmVjdGlvbiA9IHN0eWxlLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gRGlyZWN0aW9uLlJUTCA6IERpcmVjdGlvbi5MVFI7XG4gICAgICAgIGxldCByZWZyZXNoID0gdGhpcy5oZWlnaHRPcmFjbGUubXVzdFJlZnJlc2hGb3JTdHlsZSh3aGl0ZVNwYWNlLCBkaXJlY3Rpb24pO1xuICAgICAgICBsZXQgbWVhc3VyZUNvbnRlbnQgPSByZWZyZXNoIHx8IHRoaXMubXVzdE1lYXN1cmVDb250ZW50IHx8IHRoaXMuY29udGVudERPTUhlaWdodCAhPSBkb20uY2xpZW50SGVpZ2h0O1xuICAgICAgICBsZXQgcmVzdWx0ID0gMCwgYmlhcyA9IDA7XG4gICAgICAgIGlmIChtZWFzdXJlQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5tdXN0TWVhc3VyZUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUhlaWdodCA9IGRvbS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAvLyBWZXJ0aWNhbCBwYWRkaW5nXG4gICAgICAgICAgICBsZXQgcGFkZGluZ1RvcCA9IHBhcnNlSW50KHN0eWxlLnBhZGRpbmdUb3ApIHx8IDAsIHBhZGRpbmdCb3R0b20gPSBwYXJzZUludChzdHlsZS5wYWRkaW5nQm90dG9tKSB8fCAwO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFkZGluZ1RvcCAhPSBwYWRkaW5nVG9wIHx8IHRoaXMucGFkZGluZ0JvdHRvbSAhPSBwYWRkaW5nQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogR2VvbWV0cnkgKi87XG4gICAgICAgICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBpeGVsIHZpZXdwb3J0XG4gICAgICAgIGxldCBwaXhlbFZpZXdwb3J0ID0gdGhpcy5wcmludGluZyA/IHsgdG9wOiAtMWU4LCBib3R0b206IDFlOCwgbGVmdDogLTFlOCwgcmlnaHQ6IDFlOCB9XG4gICAgICAgICAgICA6IHZpc2libGVQaXhlbFJhbmdlKGRvbSwgdGhpcy5wYWRkaW5nVG9wKTtcbiAgICAgICAgbGV0IGRUb3AgPSBwaXhlbFZpZXdwb3J0LnRvcCAtIHRoaXMucGl4ZWxWaWV3cG9ydC50b3AsIGRCb3R0b20gPSBwaXhlbFZpZXdwb3J0LmJvdHRvbSAtIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b207XG4gICAgICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHBpeGVsVmlld3BvcnQ7XG4gICAgICAgIGxldCBpblZpZXcgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICAgICAgaWYgKGluVmlldyAhPSB0aGlzLmluVmlldykge1xuICAgICAgICAgICAgdGhpcy5pblZpZXcgPSBpblZpZXc7XG4gICAgICAgICAgICBpZiAoaW5WaWV3KVxuICAgICAgICAgICAgICAgIG1lYXN1cmVDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBjb250ZW50V2lkdGggPSBkb20uY2xpZW50V2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET01XaWR0aCAhPSBjb250ZW50V2lkdGggfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0IHx8XG4gICAgICAgICAgICB0aGlzLmVkaXRvcldpZHRoICE9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01XaWR0aCA9IGNvbnRlbnRXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9ySGVpZ2h0ID0gdmlldy5zY3JvbGxET00uY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5lZGl0b3JXaWR0aCA9IHZpZXcuc2Nyb2xsRE9NLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0IHw9IDggLyogR2VvbWV0cnkgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lYXN1cmVDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbGluZUhlaWdodHMgPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cygpO1xuICAgICAgICAgICAgaWYgKG9yYWNsZS5tdXN0UmVmcmVzaEZvckhlaWdodHMobGluZUhlaWdodHMpKVxuICAgICAgICAgICAgICAgIHJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHJlZnJlc2ggfHwgb3JhY2xlLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhjb250ZW50V2lkdGggLSB0aGlzLmNvbnRlbnRET01XaWR0aCkgPiBvcmFjbGUuY2hhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbGluZUhlaWdodCwgY2hhcldpZHRoIH0gPSB2aWV3LmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgICAgICAgICAgcmVmcmVzaCA9IG9yYWNsZS5yZWZyZXNoKHdoaXRlU3BhY2UsIGRpcmVjdGlvbiwgbGluZUhlaWdodCwgY2hhcldpZHRoLCBjb250ZW50V2lkdGggLyBjaGFyV2lkdGgsIGxpbmVIZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVmcmVzaCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvY1ZpZXcubWluV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgfD0gOCAvKiBHZW9tZXRyeSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFRvcCA+IDAgJiYgZEJvdHRvbSA+IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWF4KGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgZWxzZSBpZiAoZFRvcCA8IDAgJiYgZEJvdHRvbSA8IDApXG4gICAgICAgICAgICAgICAgYmlhcyA9IE1hdGgubWluKGRUb3AsIGRCb3R0b20pO1xuICAgICAgICAgICAgb3JhY2xlLmhlaWdodENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0TWFwID0gdGhpcy5oZWlnaHRNYXAudXBkYXRlSGVpZ2h0KG9yYWNsZSwgMCwgcmVmcmVzaCwgbmV3IE1lYXN1cmVkSGVpZ2h0cyh0aGlzLnZpZXdwb3J0LmZyb20sIGxpbmVIZWlnaHRzKSk7XG4gICAgICAgICAgICBpZiAob3JhY2xlLmhlaWdodENoYW5nZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDIgLyogSGVpZ2h0ICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3cG9ydENoYW5nZSA9ICF0aGlzLnZpZXdwb3J0SXNBcHByb3ByaWF0ZSh0aGlzLnZpZXdwb3J0LCBiaWFzKSB8fFxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUYXJnZXQgJiYgKHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA+IHRoaXMudmlld3BvcnQudG8pO1xuICAgICAgICBpZiAodmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydChiaWFzLCB0aGlzLnNjcm9sbFRhcmdldCk7XG4gICAgICAgIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKTtcbiAgICAgICAgaWYgKChyZXN1bHQgJiAyIC8qIEhlaWdodCAqLykgfHwgdmlld3BvcnRDaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpZXdwb3J0TGluZXMoKTtcbiAgICAgICAgaWYgKHRoaXMubGluZUdhcHMubGVuZ3RoIHx8IHRoaXMudmlld3BvcnQudG8gLSB0aGlzLnZpZXdwb3J0LmZyb20gPiA0MDAwIC8qIERvdWJsZU1hcmdpbiAqLylcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGluZUdhcHModGhpcy5lbnN1cmVMaW5lR2FwcyhyZWZyZXNoID8gW10gOiB0aGlzLmxpbmVHYXBzKSk7XG4gICAgICAgIHJlc3VsdCB8PSB0aGlzLmNvbXB1dGVWaXNpYmxlUmFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MpIHtcbiAgICAgICAgICAgIHRoaXMubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBkb25lIGluIHRoZSByZWFkIHN0YWdlLCBiZWNhdXNlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyB0byBhIGxpbmUgZW5kIGlzIGdvaW5nIHRvIHRyaWdnZXIgYSBsYXlvdXQgYW55d2F5LCBzbyBpdFxuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgYSBwdXJlIHdyaXRlLiBJdCBzaG91bGQgYmUgcmFyZSB0aGF0IGl0IGRvZXMgYW55XG4gICAgICAgICAgICAvLyB3cml0aW5nLlxuICAgICAgICAgICAgdmlldy5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCB2aXNpYmxlVG9wKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTsgfVxuICAgIGdldCB2aXNpYmxlQm90dG9tKCkgeyByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTsgfVxuICAgIGdldFZpZXdwb3J0KGJpYXMsIHNjcm9sbFRhcmdldCkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgZGl2aWRlIFZQLk1hcmdpbiBiZXR3ZWVuIHRoZSB0b3AgYW5kIHRoZVxuICAgICAgICAvLyBib3R0b20sIGRlcGVuZGluZyBvbiB0aGUgYmlhcyAodGhlIGNoYW5nZSBpbiB2aWV3cG9ydCBwb3NpdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUpLiBJdCdsbCBob2xkIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAgICBsZXQgbWFyZ2luVG9wID0gMC41IC0gTWF0aC5tYXgoLTAuNSwgTWF0aC5taW4oMC41LCBiaWFzIC8gMTAwMCAvKiBNYXJnaW4gKi8gLyAyKSk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLmhlaWdodE1hcCwgZG9jID0gdGhpcy5zdGF0ZS5kb2MsIHsgdmlzaWJsZVRvcCwgdmlzaWJsZUJvdHRvbSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KG1hcC5saW5lQXQodmlzaWJsZVRvcCAtIG1hcmdpblRvcCAqIDEwMDAgLyogTWFyZ2luICovLCBRdWVyeVR5cGUuQnlIZWlnaHQsIGRvYywgMCwgMCkuZnJvbSwgbWFwLmxpbmVBdCh2aXNpYmxlQm90dG9tICsgKDEgLSBtYXJnaW5Ub3ApICogMTAwMCAvKiBNYXJnaW4gKi8sIFF1ZXJ5VHlwZS5CeUhlaWdodCwgZG9jLCAwLCAwKS50byk7XG4gICAgICAgIC8vIElmIHNjcm9sbFRhcmdldCBpcyBnaXZlbiwgbWFrZSBzdXJlIHRoZSB2aWV3cG9ydCBpbmNsdWRlcyB0aGF0IHBvc2l0aW9uXG4gICAgICAgIGlmIChzY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIGxldCB7IGhlYWQgfSA9IHNjcm9sbFRhcmdldC5yYW5nZSwgdmlld0hlaWdodCA9IHRoaXMuZWRpdG9ySGVpZ2h0O1xuICAgICAgICAgICAgaWYgKGhlYWQgPCB2aWV3cG9ydC5mcm9tIHx8IGhlYWQgPiB2aWV3cG9ydC50bykge1xuICAgICAgICAgICAgICAgIGxldCBibG9jayA9IG1hcC5saW5lQXQoaGVhZCwgUXVlcnlUeXBlLkJ5UG9zLCBkb2MsIDAsIDApLCB0b3BQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbFRhcmdldC55ID09IFwiY2VudGVyXCIpXG4gICAgICAgICAgICAgICAgICAgIHRvcFBvcyA9IChibG9jay50b3AgKyBibG9jay5ib3R0b20pIC8gMiAtIHZpZXdIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFRhcmdldC55ID09IFwic3RhcnRcIiB8fCBzY3JvbGxUYXJnZXQueSA9PSBcIm5lYXJlc3RcIiAmJiBoZWFkIDwgdmlld3BvcnQuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2sudG9wO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9wUG9zID0gYmxvY2suYm90dG9tIC0gdmlld0hlaWdodDtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IG5ldyBWaWV3cG9ydChtYXAubGluZUF0KHRvcFBvcyAtIDEwMDAgLyogTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLmZyb20sIG1hcC5saW5lQXQodG9wUG9zICsgdmlld0hlaWdodCArIDEwMDAgLyogTWFyZ2luICovIC8gMiwgUXVlcnlUeXBlLkJ5SGVpZ2h0LCBkb2MsIDAsIDApLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIG1hcFZpZXdwb3J0KHZpZXdwb3J0LCBjaGFuZ2VzKSB7XG4gICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Modmlld3BvcnQuZnJvbSwgLTEpLCB0byA9IGNoYW5nZXMubWFwUG9zKHZpZXdwb3J0LnRvLCAxKTtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3cG9ydCh0aGlzLmhlaWdodE1hcC5saW5lQXQoZnJvbSwgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCkuZnJvbSwgdGhpcy5oZWlnaHRNYXAubGluZUF0KHRvLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKS50byk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHZpZXdwb3J0IGNvdmVycyB0aGUgdmlzaWJsZSBwYXJ0IG9mIHRoZVxuICAgIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gICAgdmlld3BvcnRJc0FwcHJvcHJpYXRlKHsgZnJvbSwgdG8gfSwgYmlhcyA9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgeyB0b3AgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIHRoaXMuc3RhdGUuZG9jLCAwLCAwKTtcbiAgICAgICAgbGV0IHsgYm90dG9tIH0gPSB0aGlzLmhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgdGhpcy5zdGF0ZS5kb2MsIDAsIDApO1xuICAgICAgICBsZXQgeyB2aXNpYmxlVG9wLCB2aXNpYmxlQm90dG9tIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGZyb20gPT0gMCB8fCB0b3AgPD0gdmlzaWJsZVRvcCAtIE1hdGgubWF4KDEwIC8qIE1pbkNvdmVyTWFyZ2luICovLCBNYXRoLm1pbigtYmlhcywgMjUwIC8qIE1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG8gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgYm90dG9tID49IHZpc2libGVCb3R0b20gKyBNYXRoLm1heCgxMCAvKiBNaW5Db3Zlck1hcmdpbiAqLywgTWF0aC5taW4oYmlhcywgMjUwIC8qIE1heENvdmVyTWFyZ2luICovKSkpICYmXG4gICAgICAgICAgICAodG9wID4gdmlzaWJsZVRvcCAtIDIgKiAxMDAwIC8qIE1hcmdpbiAqLyAmJiBib3R0b20gPCB2aXNpYmxlQm90dG9tICsgMiAqIDEwMDAgLyogTWFyZ2luICovKTtcbiAgICB9XG4gICAgbWFwTGluZUdhcHMoZ2FwcywgY2hhbmdlcykge1xuICAgICAgICBpZiAoIWdhcHMubGVuZ3RoIHx8IGNoYW5nZXMuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gZ2FwcztcbiAgICAgICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBnYXAgb2YgZ2FwcylcbiAgICAgICAgICAgIGlmICghY2hhbmdlcy50b3VjaGVzUmFuZ2UoZ2FwLmZyb20sIGdhcC50bykpXG4gICAgICAgICAgICAgICAgbWFwcGVkLnB1c2gobmV3IExpbmVHYXAoY2hhbmdlcy5tYXBQb3MoZ2FwLmZyb20pLCBjaGFuZ2VzLm1hcFBvcyhnYXAudG8pLCBnYXAuc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwb3NpdGlvbnMgaW4gdGhlIHZpZXdwb3J0IHdoZXJlIHRoZSBzdGFydCBvciBlbmQgb2YgYVxuICAgIC8vIGxpbmUgc2hvdWxkIGJlIGhpZGRlbiwgdHJ5aW5nIHRvIHJldXNlIGV4aXN0aW5nIGxpbmUgZ2FwcyB3aGVuXG4gICAgLy8gYXBwcm9wcmlhdGUgdG8gYXZvaWQgdW5uZWNjZXNhcnkgcmVkcmF3cy5cbiAgICAvLyBVc2VzIGNydWRlIGNoYXJhY3Rlci1jb3VudGluZyBmb3IgdGhlIHBvc2l0aW9uaW5nIGFuZCBzaXppbmcsXG4gICAgLy8gc2luY2UgYWN0dWFsIERPTSBjb29yZGluYXRlcyBhcmVuJ3QgYWx3YXlzIGF2YWlsYWJsZSBhbmRcbiAgICAvLyBwcmVkaWN0YWJsZS4gUmVsaWVzIG9uIGdlbmVyb3VzIG1hcmdpbnMgKHNlZSBMRy5NYXJnaW4pIHRvIGhpZGVcbiAgICAvLyB0aGUgYXJ0aWZhY3RzIHRoaXMgbWlnaHQgcHJvZHVjZSBmcm9tIHRoZSB1c2VyLlxuICAgIGVuc3VyZUxpbmVHYXBzKGN1cnJlbnQpIHtcbiAgICAgICAgbGV0IGdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGhpcyB3b24ndCB3b3JrIGF0IGFsbCBpbiBwcmVkb21pbmFudGx5IHJpZ2h0LXRvLWxlZnQgdGV4dC5cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0T3JhY2xlLmRpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSKVxuICAgICAgICAgICAgcmV0dXJuIGdhcHM7XG4gICAgICAgIGZvciAobGV0IGxpbmUgb2YgdGhpcy52aWV3cG9ydExpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPCA0MDAwIC8qIERvdWJsZU1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBzdHJ1Y3R1cmUgPSBsaW5lU3RydWN0dXJlKGxpbmUuZnJvbSwgbGluZS50bywgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoc3RydWN0dXJlLnRvdGFsIDwgNDAwMCAvKiBEb3VibGVNYXJnaW4gKi8pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgdmlld0Zyb20sIHZpZXdUbztcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luSGVpZ2h0ID0gKDIwMDAgLyogTWFyZ2luICovIC8gdGhpcy5oZWlnaHRPcmFjbGUubGluZUxlbmd0aCkgKiB0aGlzLmhlaWdodE9yYWNsZS5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gZmluZFBvc2l0aW9uKHN0cnVjdHVyZSwgKHRoaXMudmlzaWJsZVRvcCAtIGxpbmUudG9wIC0gbWFyZ2luSGVpZ2h0KSAvIGxpbmUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCAodGhpcy52aXNpYmxlQm90dG9tIC0gbGluZS50b3AgKyBtYXJnaW5IZWlnaHQpIC8gbGluZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsV2lkdGggPSBzdHJ1Y3R1cmUudG90YWwgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbldpZHRoID0gMjAwMCAvKiBNYXJnaW4gKi8gKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCAodGhpcy5waXhlbFZpZXdwb3J0LmxlZnQgLSBtYXJnaW5XaWR0aCkgLyB0b3RhbFdpZHRoKTtcbiAgICAgICAgICAgICAgICB2aWV3VG8gPSBmaW5kUG9zaXRpb24oc3RydWN0dXJlLCAodGhpcy5waXhlbFZpZXdwb3J0LnJpZ2h0ICsgbWFyZ2luV2lkdGgpIC8gdG90YWxXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb3V0c2lkZSA9IFtdO1xuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID4gbGluZS5mcm9tKVxuICAgICAgICAgICAgICAgIG91dHNpZGUucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IHZpZXdGcm9tIH0pO1xuICAgICAgICAgICAgaWYgKHZpZXdUbyA8IGxpbmUudG8pXG4gICAgICAgICAgICAgICAgb3V0c2lkZS5wdXNoKHsgZnJvbTogdmlld1RvLCB0bzogbGluZS50byB9KTtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBnYXBzIGRvbid0IGNvdmVyIGEgc2VsZWN0aW9uIGVuZFxuICAgICAgICAgICAgaWYgKHNlbC5mcm9tID49IGxpbmUuZnJvbSAmJiBzZWwuZnJvbSA8PSBsaW5lLnRvKVxuICAgICAgICAgICAgICAgIGN1dFJhbmdlKG91dHNpZGUsIHNlbC5mcm9tIC0gMTAgLyogU2VsZWN0aW9uTWFyZ2luICovLCBzZWwuZnJvbSArIDEwIC8qIFNlbGVjdGlvbk1hcmdpbiAqLyk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiBzZWwudG8gPj0gbGluZS5mcm9tICYmIHNlbC50byA8PSBsaW5lLnRvKVxuICAgICAgICAgICAgICAgIGN1dFJhbmdlKG91dHNpZGUsIHNlbC50byAtIDEwIC8qIFNlbGVjdGlvbk1hcmdpbiAqLywgc2VsLnRvICsgMTAgLyogU2VsZWN0aW9uTWFyZ2luICovKTtcbiAgICAgICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBvdXRzaWRlKVxuICAgICAgICAgICAgICAgIGlmICh0byAtIGZyb20gPiAxMDAwIC8qIEhhbGZNYXJnaW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgZ2Fwcy5wdXNoKGZpbmQoY3VycmVudCwgZ2FwID0+IGdhcC5mcm9tID49IGxpbmUuZnJvbSAmJiBnYXAudG8gPD0gbGluZS50byAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZ2FwLmZyb20gLSBmcm9tKSA8IDEwMDAgLyogSGFsZk1hcmdpbiAqLyAmJiBNYXRoLmFicyhnYXAudG8gLSB0bykgPCAxMDAwIC8qIEhhbGZNYXJnaW4gKi8pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgTGluZUdhcChmcm9tLCB0bywgdGhpcy5nYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnYXBzO1xuICAgIH1cbiAgICBnYXBTaXplKGxpbmUsIGZyb20sIHRvLCBzdHJ1Y3R1cmUpIHtcbiAgICAgICAgbGV0IGZyYWN0aW9uID0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgdG8pIC0gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgZnJvbSk7XG4gICAgICAgIGlmICh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lLmhlaWdodCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdHVyZS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCAqIGZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUxpbmVHYXBzKGdhcHMpIHtcbiAgICAgICAgaWYgKCFMaW5lR2FwLnNhbWUoZ2FwcywgdGhpcy5saW5lR2FwcykpIHtcbiAgICAgICAgICAgIHRoaXMubGluZUdhcHMgPSBnYXBzO1xuICAgICAgICAgICAgdGhpcy5saW5lR2FwRGVjbyA9IERlY29yYXRpb24uc2V0KGdhcHMubWFwKGdhcCA9PiBnYXAuZHJhdyh0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZVZpc2libGVSYW5nZXMoKSB7XG4gICAgICAgIGxldCBkZWNvID0gdGhpcy5zdGF0ZS5mYWNldChkZWNvcmF0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVHYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlY28gPSBkZWNvLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKTtcbiAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICBSYW5nZVNldC5zcGFucyhkZWNvLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgICAgICAgIHNwYW4oZnJvbSwgdG8pIHsgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTsgfSxcbiAgICAgICAgICAgIHBvaW50KCkgeyB9XG4gICAgICAgIH0sIDIwKTtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSByYW5nZXMubGVuZ3RoICE9IHRoaXMudmlzaWJsZVJhbmdlcy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJhbmdlcy5zb21lKChyLCBpKSA9PiByLmZyb20gIT0gcmFuZ2VzW2ldLmZyb20gfHwgci50byAhPSByYW5nZXNbaV0udG8pO1xuICAgICAgICB0aGlzLnZpc2libGVSYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkID8gNCAvKiBWaWV3cG9ydCAqLyA6IDA7XG4gICAgfVxuICAgIGxpbmVCbG9ja0F0KHBvcykge1xuICAgICAgICByZXR1cm4gKHBvcyA+PSB0aGlzLnZpZXdwb3J0LmZyb20gJiYgcG9zIDw9IHRoaXMudmlld3BvcnQudG8gJiYgdGhpcy52aWV3cG9ydExpbmVzLmZpbmQoYiA9PiBiLmZyb20gPD0gcG9zICYmIGIudG8gPj0gcG9zKSkgfHxcbiAgICAgICAgICAgIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAubGluZUF0KHBvcywgUXVlcnlUeXBlLkJ5UG9zLCB0aGlzLnN0YXRlLmRvYywgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgICB9XG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBzY2FsZUJsb2NrKHRoaXMuaGVpZ2h0TWFwLmxpbmVBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIFF1ZXJ5VHlwZS5CeUhlaWdodCwgdGhpcy5zdGF0ZS5kb2MsIDAsIDApLCB0aGlzLnNjYWxlcik7XG4gICAgfVxuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxlQmxvY2sodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGhlaWdodCksIHRoaXMuc3RhdGUuZG9jLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICAgIH1cbiAgICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZXIudG9ET00odGhpcy5oZWlnaHRNYXAuaGVpZ2h0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgICB9XG59XG5jbGFzcyBWaWV3cG9ydCB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpbmVTdHJ1Y3R1cmUoZnJvbSwgdG8sIHN0YXRlKSB7XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBwb3MgPSBmcm9tLCB0b3RhbCA9IDA7XG4gICAgUmFuZ2VTZXQuc3BhbnMoc3RhdGUuZmFjZXQoZGVjb3JhdGlvbnMpLCBmcm9tLCB0bywge1xuICAgICAgICBzcGFuKCkgeyB9LFxuICAgICAgICBwb2ludChmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IGZyb20gfSk7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gZnJvbSAtIHBvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IHRvO1xuICAgICAgICB9XG4gICAgfSwgMjApOyAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gY29sbGFwc2VkIHJhbmdlcyBvZiBhIHNpZ25pZmljYW50IHNpemVcbiAgICBpZiAocG9zIDwgdG8pIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBwb3MsIHRvIH0pO1xuICAgICAgICB0b3RhbCArPSB0byAtIHBvcztcbiAgICB9XG4gICAgcmV0dXJuIHsgdG90YWwsIHJhbmdlcyB9O1xufVxuZnVuY3Rpb24gZmluZFBvc2l0aW9uKHsgdG90YWwsIHJhbmdlcyB9LCByYXRpbykge1xuICAgIGlmIChyYXRpbyA8PSAwKVxuICAgICAgICByZXR1cm4gcmFuZ2VzWzBdLmZyb207XG4gICAgaWYgKHJhdGlvID49IDEpXG4gICAgICAgIHJldHVybiByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgIGxldCBkaXN0ID0gTWF0aC5mbG9vcih0b3RhbCAqIHJhdGlvKTtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gcmFuZ2VzW2ldLCBzaXplID0gdG8gLSBmcm9tO1xuICAgICAgICBpZiAoZGlzdCA8PSBzaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZyb20gKyBkaXN0O1xuICAgICAgICBkaXN0IC09IHNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZEZyYWN0aW9uKHN0cnVjdHVyZSwgcG9zKSB7XG4gICAgbGV0IGNvdW50ZWQgPSAwO1xuICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiBzdHJ1Y3R1cmUucmFuZ2VzKSB7XG4gICAgICAgIGlmIChwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgIGNvdW50ZWQgKz0gcG9zIC0gZnJvbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ZWQgKz0gdG8gLSBmcm9tO1xuICAgIH1cbiAgICByZXR1cm4gY291bnRlZCAvIHN0cnVjdHVyZS50b3RhbDtcbn1cbmZ1bmN0aW9uIGN1dFJhbmdlKHJhbmdlcywgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgciA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSB7XG4gICAgICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBwaWVjZXMucHVzaCh7IGZyb206IHIuZnJvbSwgdG86IGZyb20gfSk7XG4gICAgICAgICAgICBpZiAoci50byA+IHRvKVxuICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKHsgZnJvbTogdG8sIHRvOiByLnRvIH0pO1xuICAgICAgICAgICAgcmFuZ2VzLnNwbGljZShpLCAxLCAuLi5waWVjZXMpO1xuICAgICAgICAgICAgaSArPSBwaWVjZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmQoYXJyYXksIGYpIHtcbiAgICBmb3IgKGxldCB2YWwgb2YgYXJyYXkpXG4gICAgICAgIGlmIChmKHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBEb24ndCBzY2FsZSB3aGVuIHRoZSBkb2N1bWVudCBoZWlnaHQgaXMgd2l0aGluIHRoZSByYW5nZSBvZiB3aGF0XG4vLyB0aGUgRE9NIGNhbiBoYW5kbGUuXG5jb25zdCBJZFNjYWxlciA9IHtcbiAgICB0b0RPTShuKSB7IHJldHVybiBuOyB9LFxuICAgIGZyb21ET00obikgeyByZXR1cm4gbjsgfSxcbiAgICBzY2FsZTogMVxufTtcbi8vIFdoZW4gdGhlIGhlaWdodCBpcyB0b28gYmlnICg+IFZQLk1heERPTUhlaWdodCksIHNjYWxlIGRvd24gdGhlXG4vLyByZWdpb25zIG91dHNpZGUgdGhlIHZpZXdwb3J0cyBzbyB0aGF0IHRoZSB0b3RhbCBoZWlnaHQgaXNcbi8vIFZQLk1heERPTUhlaWdodC5cbmNsYXNzIEJpZ1NjYWxlciB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBoZWlnaHRNYXAsIHZpZXdwb3J0cykge1xuICAgICAgICBsZXQgdnBIZWlnaHQgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7XG4gICAgICAgIHRoaXMudmlld3BvcnRzID0gdmlld3BvcnRzLm1hcCgoeyBmcm9tLCB0byB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9wID0gaGVpZ2h0TWFwLmxpbmVBdChmcm9tLCBRdWVyeVR5cGUuQnlQb3MsIGRvYywgMCwgMCkudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbSA9IGhlaWdodE1hcC5saW5lQXQodG8sIFF1ZXJ5VHlwZS5CeVBvcywgZG9jLCAwLCAwKS5ib3R0b207XG4gICAgICAgICAgICB2cEhlaWdodCArPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdG9wLCBib3R0b20sIGRvbVRvcDogMCwgZG9tQm90dG9tOiAwIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjYWxlID0gKDcwMDAwMDAgLyogTWF4RE9NSGVpZ2h0ICovIC0gdnBIZWlnaHQpIC8gKGhlaWdodE1hcC5oZWlnaHQgLSB2cEhlaWdodCk7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiB0aGlzLnZpZXdwb3J0cykge1xuICAgICAgICAgICAgb2JqLmRvbVRvcCA9IGRvbUJhc2UgKyAob2JqLnRvcCAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSBvYmouZG9tQm90dG9tID0gb2JqLmRvbVRvcCArIChvYmouYm90dG9tIC0gb2JqLnRvcCk7XG4gICAgICAgICAgICBiYXNlID0gb2JqLmJvdHRvbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC50b3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJhc2UgKyAobiAtIGJhc2UpICogdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAuZG9tVG9wICsgKG4gLSB2cC50b3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbURPTShuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBiYXNlID0gMCwgZG9tQmFzZSA9IDA7OyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2cCA9IGkgPCB0aGlzLnZpZXdwb3J0cy5sZW5ndGggPyB0aGlzLnZpZXdwb3J0c1tpXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIXZwIHx8IG4gPCB2cC5kb21Ub3ApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2UgKyAobiAtIGRvbUJhc2UpIC8gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgIGlmIChuIDw9IHZwLmRvbUJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdnAudG9wICsgKG4gLSB2cC5kb21Ub3ApO1xuICAgICAgICAgICAgYmFzZSA9IHZwLmJvdHRvbTtcbiAgICAgICAgICAgIGRvbUJhc2UgPSB2cC5kb21Cb3R0b207XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzY2FsZUJsb2NrKGJsb2NrLCBzY2FsZXIpIHtcbiAgICBpZiAoc2NhbGVyLnNjYWxlID09IDEpXG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICBsZXQgYlRvcCA9IHNjYWxlci50b0RPTShibG9jay50b3ApLCBiQm90dG9tID0gc2NhbGVyLnRvRE9NKGJsb2NrLmJvdHRvbSk7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0luZm8oYmxvY2suZnJvbSwgYmxvY2subGVuZ3RoLCBiVG9wLCBiQm90dG9tIC0gYlRvcCwgQXJyYXkuaXNBcnJheShibG9jay50eXBlKSA/IGJsb2NrLnR5cGUubWFwKGIgPT4gc2NhbGVCbG9jayhiLCBzY2FsZXIpKSA6IGJsb2NrLnR5cGUpO1xufVxuXG5jb25zdCB0aGVtZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoeyBjb21iaW5lOiBzdHJzID0+IHN0cnMuam9pbihcIiBcIikgfSk7XG5jb25zdCBkYXJrVGhlbWUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5pbmRleE9mKHRydWUpID4gLTEgfSk7XG5jb25zdCBiYXNlVGhlbWVJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCksIGJhc2VMaWdodElEID0gLypAX19QVVJFX18qL1N0eWxlTW9kdWxlLm5ld05hbWUoKSwgYmFzZURhcmtJRCA9IC8qQF9fUFVSRV9fKi9TdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG5jb25zdCBsaWdodERhcmtJRHMgPSB7IFwiJmxpZ2h0XCI6IFwiLlwiICsgYmFzZUxpZ2h0SUQsIFwiJmRhcmtcIjogXCIuXCIgKyBiYXNlRGFya0lEIH07XG5mdW5jdGlvbiBidWlsZFRoZW1lKG1haW4sIHNwZWMsIHNjb3Blcykge1xuICAgIHJldHVybiBuZXcgU3R5bGVNb2R1bGUoc3BlYywge1xuICAgICAgICBmaW5pc2goc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gLyYvLnRlc3Qoc2VsKSA/IHNlbC5yZXBsYWNlKC8mXFx3Ki8sIG0gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtID09IFwiJlwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFpbjtcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlcyB8fCAhc2NvcGVzW21dKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgc2VsZWN0b3I6ICR7bX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVzW21dO1xuICAgICAgICAgICAgfSkgOiBtYWluICsgXCIgXCIgKyBzZWw7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9idWlsZFRoZW1lKFwiLlwiICsgYmFzZVRoZW1lSUQsIHtcbiAgICBcIiYuY20tZWRpdG9yXCI6IHtcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmUgIWltcG9ydGFudFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBcIiYuY20tZm9jdXNlZFwiOiB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIGEgc2ltcGxlIGRlZmF1bHQgb3V0bGluZSB0byBtYWtlIHN1cmUgYSBmb2N1c2VkXG4gICAgICAgICAgICAvLyBlZGl0b3IgaXMgdmlzdWFsbHkgZGlzdGluY3QuIENhbid0IGxlYXZlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd2lsbCBhcHBseSB0byB0aGUgY29udGVudCBlbGVtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zaWRlIHRoZSBzY3JvbGxhYmxlIGNvbnRhaW5lciBhbmQgZG9lc24ndCBpbmNsdWRlIHRoZVxuICAgICAgICAgICAgLy8gZ3V0dGVycy4gV2UgYWxzbyBjYW4ndCB1c2UgYW4gJ2F1dG8nIG91dGxpbmUsIHNpbmNlIHRob3NlXG4gICAgICAgICAgICAvLyBhcmUsIGZvciBzb21lIHJlYXNvbiwgZHJhd24gYmVoaW5kIHRoZSBlbGVtZW50IGNvbnRlbnQsIHdoaWNoXG4gICAgICAgICAgICAvLyB3aWxsIGNhdXNlIHRoaW5ncyBsaWtlIHRoZSBhY3RpdmUgbGluZSBiYWNrZ3JvdW5kIHRvIGNvdmVyXG4gICAgICAgICAgICAvLyB0aGUgb3V0bGluZSAoIzI5NykuXG4gICAgICAgICAgICBvdXRsaW5lOiBcIjFweCBkb3R0ZWQgIzIxMjEyMVwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCJcbiAgICB9LFxuICAgIFwiLmNtLXNjcm9sbGVyXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJmbGV4LXN0YXJ0ICFpbXBvcnRhbnRcIixcbiAgICAgICAgZm9udEZhbWlseTogXCJtb25vc3BhY2VcIixcbiAgICAgICAgbGluZUhlaWdodDogMS40LFxuICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBvdmVyZmxvd1g6IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgICAgICB6SW5kZXg6IDBcbiAgICB9LFxuICAgIFwiLmNtLWNvbnRlbnRcIjoge1xuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIGZsZXhHcm93OiAyLFxuICAgICAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwicHJlXCIsXG4gICAgICAgIHdvcmRXcmFwOiBcIm5vcm1hbFwiLFxuICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgICAgIG91dGxpbmU6IFwibm9uZVwiLFxuICAgICAgICBcIiZbY29udGVudGVkaXRhYmxlPXRydWVdXCI6IHtcbiAgICAgICAgICAgIFdlYmtpdFVzZXJNb2RpZnk6IFwicmVhZC13cml0ZS1wbGFpbnRleHQtb25seVwiLFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS1saW5lV3JhcHBpbmdcIjoge1xuICAgICAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsXG4gICAgICAgIHdoaXRlU3BhY2U6IFwiYnJlYWstc3BhY2VzXCIsXG4gICAgICAgIHdvcmRCcmVhazogXCJicmVhay13b3JkXCIsXG4gICAgICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwiYmxhY2tcIiB9LFxuICAgIFwiJmRhcmsgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcIndoaXRlXCIgfSxcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMnB4IDAgNHB4XCJcbiAgICB9LFxuICAgIFwiLmNtLXNlbGVjdGlvbkxheWVyXCI6IHtcbiAgICAgICAgekluZGV4OiAtMSxcbiAgICAgICAgY29udGFpbjogXCJzaXplIHN0eWxlXCJcbiAgICB9LFxuICAgIFwiLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNkOWQ5ZDlcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gICAgfSxcbiAgICBcIiZsaWdodC5jbS1mb2N1c2VkIC5jbS1zZWxlY3Rpb25CYWNrZ3JvdW5kXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZDogXCIjZDdkNGYwXCJcbiAgICB9LFxuICAgIFwiJmRhcmsuY20tZm9jdXNlZCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzIzM1wiXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIHpJbmRleDogMTAwLFxuICAgICAgICBjb250YWluOiBcInNpemUgc3R5bGVcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1jdXJzb3JMYXllclwiOiB7XG4gICAgICAgIGFuaW1hdGlvbjogXCJzdGVwcygxKSBjbS1ibGluayAxLjJzIGluZmluaXRlXCJcbiAgICB9LFxuICAgIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAgIC8vIHJlc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRob3V0IGZvcmNpbmcgYW5vdGhlciBzdHlsZVxuICAgIC8vIHJlY29tcHV0YXRpb24uXG4gICAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyB2aXNpYmlsaXR5OiBcImhpZGRlblwiIH0sIFwiMTAwJVwiOiB7fSB9LFxuICAgIFwiQGtleWZyYW1lcyBjbS1ibGluazJcIjogeyBcIjAlXCI6IHt9LCBcIjUwJVwiOiB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSwgXCIxMDAlXCI6IHt9IH0sXG4gICAgXCIuY20tY3Vyc29yLCAuY20tZHJvcEN1cnNvclwiOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGJvcmRlckxlZnQ6IFwiMS4ycHggc29saWQgYmxhY2tcIixcbiAgICAgICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCIsXG4gICAgfSxcbiAgICBcIi5jbS1jdXJzb3JcIjoge1xuICAgICAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICAgIH0sXG4gICAgXCImZGFyayAuY20tY3Vyc29yXCI6IHtcbiAgICAgICAgYm9yZGVyTGVmdENvbG9yOiBcIiM0NDRcIlxuICAgIH0sXG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLWN1cnNvclwiOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH0sXG4gICAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2YzZjlmZlwiIH0sXG4gICAgXCImZGFyayAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMjIzMDM5XCIgfSxcbiAgICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNwZWNpYWxDaGFyXCI6IHsgY29sb3I6IFwiI2Y3OFwiIH0sXG4gICAgXCIuY20tdGFiXCI6IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ246IFwiYm90dG9tXCJcbiAgICB9LFxuICAgIFwiLmNtLXBsYWNlaG9sZGVyXCI6IHtcbiAgICAgICAgY29sb3I6IFwiIzg4OFwiLFxuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiLFxuICAgIH0sXG4gICAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICAgICAgY29sb3I6IFwiaW5oZXJpdFwiLFxuICAgICAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICAgICAgcGFkZGluZzogXCIuMmVtIDFlbVwiLFxuICAgICAgICBib3JkZXJSYWRpdXM6IFwiMXB4XCJcbiAgICB9LFxuICAgIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCNlZmYxZjUsICNkOWQ5ZGYpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZkYXJrIC5jbS1idXR0b25cIjoge1xuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzg4OFwiLFxuICAgICAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoIzExMSwgIzMzMylcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIi5jbS10ZXh0ZmllbGRcIjoge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgICAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgICAgIGZvbnRTaXplOiBcIjcwJVwiLFxuICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tdGV4dGZpZWxkXCI6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCJcbiAgICB9LFxuICAgIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgIzU1NVwiLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiaW5oZXJpdFwiXG4gICAgfVxufSwgbGlnaHREYXJrSURzKTtcblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZSxcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG9cbi8vIERPTUNoYXJhY3RlckRhdGFNb2RpZmllZCB0aGVyZVxuY29uc3QgdXNlQ2hhckRhdGEgPSBicm93c2VyLmllICYmIGJyb3dzZXIuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIERPTU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBvbkNoYW5nZSwgb25TY3JvbGxDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQgPSBvblNjcm9sbENoYW5nZWQ7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRoZSBrbm93biBzZWxlY3Rpb24uIEtlcHQgaW4gb3VyIG93biBvYmplY3QsIGFzIG9wcG9zZWQgdG8ganVzdFxuICAgICAgICAvLyBkaXJlY3RseSBhY2Nlc3NpbmcgdGhlIHNlbGVjdGlvbiBiZWNhdXNlOlxuICAgICAgICAvLyAgLSBTYWZhcmkgZG9lc24ndCByZXBvcnQgdGhlIHJpZ2h0IHNlbGVjdGlvbiBpbiBzaGFkb3cgRE9NXG4gICAgICAgIC8vICAtIFJlYWRpbmcgZnJvbSB0aGUgc2VsZWN0aW9uIGZvcmNlcyBhIERPTSBsYXlvdXRcbiAgICAgICAgLy8gIC0gVGhpcyB3YXksIHdlIGNhbiBpZ25vcmUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50cyBpZiB3ZSBoYXZlXG4gICAgICAgIC8vICAgIGFscmVhZHkgc2VlbiB0aGUgJ25ldycgc2VsZWN0aW9uXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgRE9NU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIC8vIFNldCB3aGVuIGEgc2VsZWN0aW9uIGNoYW5nZSBpcyBkZXRlY3RlZCwgY2xlYXJlZCBvbiBmbHVzaFxuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSAtMTtcbiAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZWxheWVkQW5kcm9pZEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGFyZ2V0cyA9IFtdO1xuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcnNlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nYXBJbnRlcnNlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhcHMgPSBbXTtcbiAgICAgICAgLy8gVGltZW91dCBmb3Igc2NoZWR1bGluZyBjaGVjayBvZiB0aGUgcGFyZW50cyB0aGF0IG5lZWQgc2Nyb2xsIGhhbmRsZXJzXG4gICAgICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICAgICAgdGhpcy5kb20gPSB2aWV3LmNvbnRlbnRET007XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgbXV0IG9mIG11dGF0aW9ucylcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0KTtcbiAgICAgICAgICAgIC8vIElFMTEgd2lsbCBzb21ldGltZXMgKG9uIHR5cGluZyBvdmVyIGEgc2VsZWN0aW9uIG9yXG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyIHRleHQgbm9kZSkgY2FsbCB0aGVcbiAgICAgICAgICAgIC8vIG9ic2VydmVyIGNhbGxiYWNrIGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZyB0aGUgRE9NLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFVucmVsYXRlZGx5LCBpT1MgU2FmYXJpIHdpbGwsIHdoZW4gZW5kaW5nIGEgY29tcG9zaXRpb24sXG4gICAgICAgICAgICAvLyBzb21ldGltZXMgZmlyc3QgY2xlYXIgaXQsIGRlbGl2ZXIgdGhlIG11dGF0aW9ucywgYW5kIHRoZW5cbiAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBmaW5pc2hlZCB0ZXh0LiBDb2RlTWlycm9yJ3MgaGFuZGxpbmcgb2YgdGhlXG4gICAgICAgICAgICAvLyBkZWxldGlvbiB3aWxsIHByZXZlbnQgdGhlIHJlaW5zZXJ0aW9uIGZyb20gaGFwcGVuaW5nLFxuICAgICAgICAgICAgLy8gYnJlYWtpbmcgY29tcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuaW9zICYmIHZpZXcuY29tcG9zaW5nKSAmJlxuICAgICAgICAgICAgICAgIG11dGF0aW9ucy5zb21lKG0gPT4gbS50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbS5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIG0udHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtLm9sZFZhbHVlLmxlbmd0aCA+IG0udGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy5vbkNoYXJEYXRhID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHsgdGFyZ2V0OiBldmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlID0gdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuZG9jVmlldy5sYXN0VXBkYXRlIDwgRGF0ZS5ub3coKSAtIDc1ICYmIHRoaXMucmVzaXplVGltZW91dCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVUaW1lb3V0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZS5vYnNlcnZlKHZpZXcuc2Nyb2xsRE9NKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICBpZiAodHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50Q2hlY2sgPCAwKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gc2V0VGltZW91dCh0aGlzLmxpc3RlbkZvclNjcm9sbC5iaW5kKHRoaXMpLCAxMDAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwICYmIChlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwKSAhPSB0aGlzLmludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0aW5nICE9IHRoaXMudmlldy5pblZpZXcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvbi5vYnNlcnZlKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbnRyaWVzLmxlbmd0aCA+IDAgJiYgZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblNjcm9sbENoYW5nZWQoZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5Gb3JTY3JvbGwoKTtcbiAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgdGhpcy5kb20ub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH1cbiAgICBvblNjcm9sbChlKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVyc2VjdGluZylcbiAgICAgICAgICAgIHRoaXMuZmx1c2goZmFsc2UpO1xuICAgICAgICB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgICB9XG4gICAgdXBkYXRlR2FwcyhnYXBzKSB7XG4gICAgICAgIGlmICh0aGlzLmdhcEludGVyc2VjdGlvbiAmJiAoZ2Fwcy5sZW5ndGggIT0gdGhpcy5nYXBzLmxlbmd0aCB8fCB0aGlzLmdhcHMuc29tZSgoZywgaSkgPT4gZyAhPSBnYXBzW2ldKSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGdhcCBvZiBnYXBzKVxuICAgICAgICAgICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUoZ2FwKTtcbiAgICAgICAgICAgIHRoaXMuZ2FwcyA9IGdhcHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXMsIHNlbCA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZhY2V0KGVkaXRhYmxlKSA/IHZpZXcucm9vdC5hY3RpdmVFbGVtZW50ICE9IHRoaXMuZG9tIDogIWhhc1NlbGVjdGlvbih2aWV3LmRvbSwgc2VsKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBzZWwuYW5jaG9yTm9kZSAmJiB2aWV3LmRvY1ZpZXcubmVhcmVzdChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuaWdub3JlRXZlbnQoZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBEZWxldGlvbnMgb24gSUUxMSBmaXJlIHRoZWlyIGV2ZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIsIGdpdmluZ1xuICAgICAgICAvLyB1cyBhIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnQgYmVmb3JlIHRoZSBET00gY2hhbmdlcyBhcmVcbiAgICAgICAgLy8gcmVwb3J0ZWQuXG4gICAgICAgIC8vIENocm9tZSBBbmRyb2lkIGhhcyBhIHNpbWlsYXIgaXNzdWUgd2hlbiBiYWNrc3BhY2luZyBvdXQgYVxuICAgICAgICAvLyBzZWxlY3Rpb24gKCM2NDUpLlxuICAgICAgICBpZiAoKGJyb3dzZXIuaWUgJiYgYnJvd3Nlci5pZV92ZXJzaW9uIDw9IDExIHx8IGJyb3dzZXIuYW5kcm9pZCAmJiBicm93c2VyLmNocm9tZSkgJiYgIXZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiZcbiAgICAgICAgICAgIC8vIChTZWxlY3Rpb24uaXNDb2xsYXBzZWQgaXNuJ3QgcmVsaWFibGUgb24gSUUpXG4gICAgICAgICAgICBzZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpKVxuICAgICAgICAgICAgdGhpcy5mbHVzaFNvb24oKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5mbHVzaChmYWxzZSk7XG4gICAgfVxuICAgIHJlYWRTZWxlY3Rpb25SYW5nZSgpIHtcbiAgICAgICAgbGV0IHsgcm9vdCB9ID0gdGhpcy52aWV3LCBkb21TZWwgPSBnZXRTZWxlY3Rpb24ocm9vdCk7XG4gICAgICAgIC8vIFRoZSBTZWxlY3Rpb24gb2JqZWN0IGlzIGJyb2tlbiBpbiBzaGFkb3cgcm9vdHMgaW4gU2FmYXJpLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvZGVtaXJyb3IvY29kZW1pcnJvci5uZXh0L2lzc3Vlcy80MTRcbiAgICAgICAgbGV0IHJhbmdlID0gYnJvd3Nlci5zYWZhcmkgJiYgcm9vdC5ub2RlVHlwZSA9PSAxMSAmJiBkZWVwQWN0aXZlRWxlbWVudCgpID09IHRoaXMudmlldy5jb250ZW50RE9NICYmXG4gICAgICAgICAgICBzYWZhcmlTZWxlY3Rpb25SYW5nZUhhY2sodGhpcy52aWV3KSB8fCBkb21TZWw7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblJhbmdlLmVxKHJhbmdlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXRSYW5nZShyYW5nZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBzZXRTZWxlY3Rpb25SYW5nZShhbmNob3IsIGhlYWQpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoYW5jaG9yLm5vZGUsIGFuY2hvci5vZmZzZXQsIGhlYWQubm9kZSwgaGVhZC5vZmZzZXQpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGlzdGVuRm9yU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLnBhcmVudENoZWNrID0gLTE7XG4gICAgICAgIGxldCBpID0gMCwgY2hhbmdlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHRoaXMuZG9tOyBkb207KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoYW5nZWQgJiYgaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2ldID09IGRvbSlcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkLnB1c2goZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSBkb20uYXNzaWduZWRTbG90IHx8IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDExKSB7IC8vIFNoYWRvdyByb290XG4gICAgICAgICAgICAgICAgZG9tID0gZG9tLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIWNoYW5nZWQpXG4gICAgICAgICAgICBjaGFuZ2VkID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGkpO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgZG9tIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMgPSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlnbm9yZShmKSB7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZigpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgb2JzZXJ2ZU9wdGlvbnMpO1xuICAgICAgICBpZiAodXNlQ2hhckRhdGEpXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIGlmICh1c2VDaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIiwgdGhpcy5vbkNoYXJEYXRhKTtcbiAgICB9XG4gICAgLy8gVGhyb3cgYXdheSBhbnkgcGVuZGluZyBjaGFuZ2VzXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hyb21lIEFuZHJvaWQsIGVzcGVjaWFsbHkgaW4gY29tYmluYXRpb24gd2l0aCBHQm9hcmQsIG5vdCBvbmx5XG4gICAgLy8gZG9lc24ndCByZWxpYWJseSBmaXJlIHJlZ3VsYXIga2V5IGV2ZW50cywgYnV0IGFsc28gb2Z0ZW5cbiAgICAvLyBzdXJyb3VuZHMgdGhlIGVmZmVjdCBvZiBlbnRlciBvciBiYWNrc3BhY2Ugd2l0aCBhIGJ1bmNoIG9mXG4gICAgLy8gY29tcG9zaXRpb24gZXZlbnRzIHRoYXQsIHdoZW4gaW50ZXJydXB0ZWQsIGNhdXNlIHRleHQgZHVwbGljYXRpb25cbiAgICAvLyBvciBvdGhlciBraW5kcyBvZiBjb3JydXB0aW9uLiBUaGlzIGhhY2sgbWFrZXMgdGhlIGVkaXRvciBiYWNrIG9mZlxuICAgIC8vIGZyb20gaGFuZGxpbmcgRE9NIGNoYW5nZXMgZm9yIGEgbW9tZW50IHdoZW4gc3VjaCBhIGtleSBpc1xuICAgIC8vIGRldGVjdGVkICh2aWEgYmVmb3JlaW5wdXQgb3Iga2V5ZG93biksIGFuZCB0aGVuIGRpc3BhdGNoZXMgdGhlXG4gICAgLy8ga2V5IGV2ZW50LCB0aHJvd2luZyBhd2F5IHRoZSBET00gY2hhbmdlcyBpZiBpdCBnZXRzIGhhbmRsZWQuXG4gICAgZGVsYXlBbmRyb2lkS2V5KGtleSwga2V5Q29kZSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFN0YXRlID0gdGhpcy52aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaEtleSh0aGlzLnZpZXcuY29udGVudERPTSwga2V5LmtleSwga2V5LmtleUNvZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZSA9PSBzdGFydFN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyBTaW5jZSBiYWNrc3BhY2UgYmVmb3JlaW5wdXQgaXMgc29tZXRpbWVzIHNpZ25hbGxlZCBzcHVyaW91c2x5LFxuICAgICAgICAvLyBFbnRlciBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICAgICAgaWYgKCF0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5IHx8IGtleSA9PSBcIkVudGVyXCIpXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0geyBrZXksIGtleUNvZGUgfTtcbiAgICB9XG4gICAgZmx1c2hTb29uKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPCAwKVxuICAgICAgICAgICAgdGhpcy5kZWxheWVkRmx1c2ggPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuZGVsYXllZEZsdXNoID0gLTE7IHRoaXMuZmx1c2goKTsgfSwgMjApO1xuICAgIH1cbiAgICBmb3JjZUZsdXNoKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLmRlbGF5ZWRGbHVzaCk7XG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRGbHVzaCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NSZWNvcmRzKCkge1xuICAgICAgICBsZXQgcmVjb3JkcyA9IHRoaXMucXVldWU7XG4gICAgICAgIGZvciAobGV0IG11dCBvZiB0aGlzLm9ic2VydmVyLnRha2VSZWNvcmRzKCkpXG4gICAgICAgICAgICByZWNvcmRzLnB1c2gobXV0KTtcbiAgICAgICAgaWYgKHJlY29yZHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgZnJvbSA9IC0xLCB0byA9IC0xLCB0eXBlT3ZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gdGhpcy5yZWFkTXV0YXRpb24ocmVjb3JkKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmFuZ2UudHlwZU92ZXIpXG4gICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAoeyBmcm9tLCB0byB9ID0gcmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJvbSA9IE1hdGgubWluKHJhbmdlLmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgIHRvID0gTWF0aC5tYXgocmFuZ2UudG8sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmcm9tLCB0bywgdHlwZU92ZXIgfTtcbiAgICB9XG4gICAgLy8gQXBwbHkgcGVuZGluZyBjaGFuZ2VzLCBpZiBhbnlcbiAgICBmbHVzaChyZWFkU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgICAgICAvLyBDb21wbGV0ZWx5IGhvbGQgb2ZmIGZsdXNoaW5nIHdoZW4gcGVuZGluZyBrZXlzIGFyZSBzZXTigJR0aGUgY29kZVxuICAgICAgICAvLyBtYW5hZ2luZyB0aG9zZSB3aWxsIG1ha2Ugc3VyZSBwcm9jZXNzUmVjb3JkcyBpcyBjYWxsZWQgYW5kIHRoZVxuICAgICAgICAvLyB2aWV3IGlzIHJlc3luY2hyb25pemVkIGFmdGVyXG4gICAgICAgIGlmICh0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChyZWFkU2VsZWN0aW9uKVxuICAgICAgICAgICAgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8sIHR5cGVPdmVyIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCk7XG4gICAgICAgIGxldCBuZXdTZWwgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgaGFzU2VsZWN0aW9uKHRoaXMuZG9tLCB0aGlzLnNlbGVjdGlvblJhbmdlKTtcbiAgICAgICAgaWYgKGZyb20gPCAwICYmICFuZXdTZWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRTdGF0ZSA9IHRoaXMudmlldy5zdGF0ZTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICAvLyBUaGUgdmlldyB3YXNuJ3QgdXBkYXRlZFxuICAgICAgICBpZiAodGhpcy52aWV3LnN0YXRlID09IHN0YXJ0U3RhdGUpXG4gICAgICAgICAgICB0aGlzLnZpZXcudXBkYXRlKFtdKTtcbiAgICB9XG4gICAgcmVhZE11dGF0aW9uKHJlYykge1xuICAgICAgICBsZXQgY1ZpZXcgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0KHJlYy50YXJnZXQpO1xuICAgICAgICBpZiAoIWNWaWV3IHx8IGNWaWV3Lmlnbm9yZU11dGF0aW9uKHJlYykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY1ZpZXcubWFya0RpcnR5KHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKTtcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiYXR0cmlidXRlc1wiKVxuICAgICAgICAgICAgY1ZpZXcuZGlydHkgfD0gNCAvKiBBdHRycyAqLztcbiAgICAgICAgaWYgKHJlYy50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEJlZm9yZSA9IGZpbmRDaGlsZChjVmlldywgcmVjLnByZXZpb3VzU2libGluZyB8fCByZWMudGFyZ2V0LnByZXZpb3VzU2libGluZywgLTEpO1xuICAgICAgICAgICAgbGV0IGNoaWxkQWZ0ZXIgPSBmaW5kQ2hpbGQoY1ZpZXcsIHJlYy5uZXh0U2libGluZyB8fCByZWMudGFyZ2V0Lm5leHRTaWJsaW5nLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB7IGZyb206IGNoaWxkQmVmb3JlID8gY1ZpZXcucG9zQWZ0ZXIoY2hpbGRCZWZvcmUpIDogY1ZpZXcucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogY2hpbGRBZnRlciA/IGNWaWV3LnBvc0JlZm9yZShjaGlsZEFmdGVyKSA6IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWMudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogY1ZpZXcucG9zQXRTdGFydCwgdG86IGNWaWV3LnBvc0F0RW5kLCB0eXBlT3ZlcjogcmVjLnRhcmdldC5ub2RlVmFsdWUgPT0gcmVjLm9sZFZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW50ZXJzZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAoX2IgPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKF9jID0gdGhpcy5yZXNpemUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kaXNjb25uZWN0KCk7XG4gICAgICAgIGZvciAobGV0IGRvbSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICAgICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgICAgIHRoaXMuZG9tLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGFyZW50Q2hlY2spO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kQ2hpbGQoY1ZpZXcsIGRvbSwgZGlyKSB7XG4gICAgd2hpbGUgKGRvbSkge1xuICAgICAgICBsZXQgY3VyVmlldyA9IENvbnRlbnRWaWV3LmdldChkb20pO1xuICAgICAgICBpZiAoY3VyVmlldyAmJiBjdXJWaWV3LnBhcmVudCA9PSBjVmlldylcbiAgICAgICAgICAgIHJldHVybiBjdXJWaWV3O1xuICAgICAgICBsZXQgcGFyZW50ID0gZG9tLnBhcmVudE5vZGU7XG4gICAgICAgIGRvbSA9IHBhcmVudCAhPSBjVmlldy5kb20gPyBwYXJlbnQgOiBkaXIgPiAwID8gZG9tLm5leHRTaWJsaW5nIDogZG9tLnByZXZpb3VzU2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBVc2VkIHRvIHdvcmsgYXJvdW5kIGEgU2FmYXJpIFNlbGVjdGlvbi9zaGFkb3cgRE9NIGJ1ZyAoIzQxNClcbmZ1bmN0aW9uIHNhZmFyaVNlbGVjdGlvblJhbmdlSGFjayh2aWV3KSB7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIxKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd3Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICB2aWV3LmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpO1xuICAgIHZpZXcuY29udGVudERPTS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGFuY2hvck5vZGUgPSBmb3VuZC5zdGFydENvbnRhaW5lciwgYW5jaG9yT2Zmc2V0ID0gZm91bmQuc3RhcnRPZmZzZXQ7XG4gICAgbGV0IGZvY3VzTm9kZSA9IGZvdW5kLmVuZENvbnRhaW5lciwgZm9jdXNPZmZzZXQgPSBmb3VuZC5lbmRPZmZzZXQ7XG4gICAgbGV0IGN1ckFuY2hvciA9IHZpZXcuZG9jVmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvcik7XG4gICAgLy8gU2luY2Ugc3VjaCBhIHJhbmdlIGRvZXNuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbmNob3IgYW5kIGhlYWQsXG4gICAgLy8gdXNlIGEgaGV1cmlzdGljIHRoYXQgZmxpcHMgaXQgYXJvdW5kIGlmIGl0cyBlbmQgbWF0Y2hlcyB0aGVcbiAgICAvLyBjdXJyZW50IGFuY2hvci5cbiAgICBpZiAoaXNFcXVpdmFsZW50UG9zaXRpb24oY3VyQW5jaG9yLm5vZGUsIGN1ckFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuXG5mdW5jdGlvbiBhcHBseURPTUNoYW5nZSh2aWV3LCBzdGFydCwgZW5kLCB0eXBlT3Zlcikge1xuICAgIGxldCBjaGFuZ2UsIG5ld1NlbDtcbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoc3RhcnQgPiAtMSkge1xuICAgICAgICBsZXQgYm91bmRzID0gdmlldy5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChzdGFydCwgZW5kLCAwKTtcbiAgICAgICAgaWYgKCFib3VuZHMgfHwgdmlldy5zdGF0ZS5yZWFkT25seSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGJvdW5kcztcbiAgICAgICAgbGV0IHNlbFBvaW50cyA9IHZpZXcuZG9jVmlldy5pbXByZWNpc2VIZWFkIHx8IHZpZXcuZG9jVmlldy5pbXByZWNpc2VBbmNob3IgPyBbXSA6IHNlbGVjdGlvblBvaW50cyh2aWV3KTtcbiAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBET01SZWFkZXIoc2VsUG9pbnRzLCB2aWV3KTtcbiAgICAgICAgcmVhZGVyLnJlYWRSYW5nZShib3VuZHMuc3RhcnRET00sIGJvdW5kcy5lbmRET00pO1xuICAgICAgICBuZXdTZWwgPSBzZWxlY3Rpb25Gcm9tUG9pbnRzKHNlbFBvaW50cywgZnJvbSk7XG4gICAgICAgIGxldCBwcmVmZXJyZWRQb3MgPSBzZWwuZnJvbSwgcHJlZmVycmVkU2lkZSA9IG51bGw7XG4gICAgICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWQgKG9yLCBvblxuICAgICAgICAvLyBBbmRyb2lkLCB3aGVuIHNvbWV0aGluZyB3YXMgZGVsZXRlZClcbiAgICAgICAgaWYgKHZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA9PT0gOCAmJiB2aWV3LmlucHV0U3RhdGUubGFzdEtleVRpbWUgPiBEYXRlLm5vdygpIC0gMTAwIHx8XG4gICAgICAgICAgICBicm93c2VyLmFuZHJvaWQgJiYgcmVhZGVyLnRleHQubGVuZ3RoIDwgdG8gLSBmcm9tKSB7XG4gICAgICAgICAgICBwcmVmZXJyZWRQb3MgPSBzZWwudG87XG4gICAgICAgICAgICBwcmVmZXJyZWRTaWRlID0gXCJlbmRcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlmZiA9IGZpbmREaWZmKHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pLCByZWFkZXIudGV4dCwgcHJlZmVycmVkUG9zIC0gZnJvbSwgcHJlZmVycmVkU2lkZSk7XG4gICAgICAgIGlmIChkaWZmKVxuICAgICAgICAgICAgY2hhbmdlID0geyBmcm9tOiBmcm9tICsgZGlmZi5mcm9tLCB0bzogZnJvbSArIGRpZmYudG9BLFxuICAgICAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS50b1RleHQocmVhZGVyLnRleHQuc2xpY2UoZGlmZi5mcm9tLCBkaWZmLnRvQikpIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHZpZXcuaGFzRm9jdXMgfHwgIXZpZXcuc3RhdGUuZmFjZXQoZWRpdGFibGUpKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3Lm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgICAgICBsZXQgeyBpbXByZWNpc2VIZWFkOiBpSGVhZCwgaW1wcmVjaXNlQW5jaG9yOiBpQW5jaG9yIH0gPSB2aWV3LmRvY1ZpZXc7XG4gICAgICAgIGxldCBoZWFkID0gaUhlYWQgJiYgaUhlYWQubm9kZSA9PSBkb21TZWwuZm9jdXNOb2RlICYmIGlIZWFkLm9mZnNldCA9PSBkb21TZWwuZm9jdXNPZmZzZXQgfHxcbiAgICAgICAgICAgICFjb250YWlucyh2aWV3LmNvbnRlbnRET00sIGRvbVNlbC5mb2N1c05vZGUpXG4gICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZFxuICAgICAgICAgICAgOiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShkb21TZWwuZm9jdXNOb2RlLCBkb21TZWwuZm9jdXNPZmZzZXQpO1xuICAgICAgICBsZXQgYW5jaG9yID0gaUFuY2hvciAmJiBpQW5jaG9yLm5vZGUgPT0gZG9tU2VsLmFuY2hvck5vZGUgJiYgaUFuY2hvci5vZmZzZXQgPT0gZG9tU2VsLmFuY2hvck9mZnNldCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5zKHZpZXcuY29udGVudERPTSwgZG9tU2VsLmFuY2hvck5vZGUpXG4gICAgICAgICAgICA/IHZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yXG4gICAgICAgICAgICA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgaWYgKGhlYWQgIT0gc2VsLmhlYWQgfHwgYW5jaG9yICE9IHNlbC5hbmNob3IpXG4gICAgICAgICAgICBuZXdTZWwgPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKGFuY2hvciwgaGVhZCk7XG4gICAgfVxuICAgIGlmICghY2hhbmdlICYmICFuZXdTZWwpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBIZXVyaXN0aWMgdG8gbm90aWNlIHR5cGluZyBvdmVyIGEgc2VsZWN0ZWQgY2hhcmFjdGVyXG4gICAgaWYgKCFjaGFuZ2UgJiYgdHlwZU92ZXIgJiYgIXNlbC5lbXB0eSAmJiBuZXdTZWwgJiYgbmV3U2VsLm1haW4uZW1wdHkpXG4gICAgICAgIGNoYW5nZSA9IHsgZnJvbTogc2VsLmZyb20sIHRvOiBzZWwudG8sIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIHNlbC50bykgfTtcbiAgICAvLyBJZiB0aGUgY2hhbmdlIGlzIGluc2lkZSB0aGUgc2VsZWN0aW9uIGFuZCBjb3ZlcnMgbW9zdCBvZiBpdCxcbiAgICAvLyBhc3N1bWUgaXQgaXMgYSBzZWxlY3Rpb24gcmVwbGFjZSAod2l0aCBpZGVudGljYWwgY2hhcmFjdGVycyBhdFxuICAgIC8vIHRoZSBzdGFydC9lbmQgbm90IGluY2x1ZGVkIGluIHRoZSBkaWZmKVxuICAgIGVsc2UgaWYgKGNoYW5nZSAmJiBjaGFuZ2UuZnJvbSA+PSBzZWwuZnJvbSAmJiBjaGFuZ2UudG8gPD0gc2VsLnRvICYmXG4gICAgICAgIChjaGFuZ2UuZnJvbSAhPSBzZWwuZnJvbSB8fCBjaGFuZ2UudG8gIT0gc2VsLnRvKSAmJlxuICAgICAgICAoc2VsLnRvIC0gc2VsLmZyb20pIC0gKGNoYW5nZS50byAtIGNoYW5nZS5mcm9tKSA8PSA0KVxuICAgICAgICBjaGFuZ2UgPSB7XG4gICAgICAgICAgICBmcm9tOiBzZWwuZnJvbSwgdG86IHNlbC50byxcbiAgICAgICAgICAgIGluc2VydDogdmlldy5zdGF0ZS5kb2Muc2xpY2Uoc2VsLmZyb20sIGNoYW5nZS5mcm9tKS5hcHBlbmQoY2hhbmdlLmluc2VydCkuYXBwZW5kKHZpZXcuc3RhdGUuZG9jLnNsaWNlKGNoYW5nZS50bywgc2VsLnRvKSlcbiAgICAgICAgfTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgIGxldCBzdGFydFN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgaWYgKGJyb3dzZXIuaW9zICYmIHZpZXcuaW5wdXRTdGF0ZS5mbHVzaElPU0tleSh2aWV3KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQW5kcm9pZCBicm93c2VycyBkb24ndCBmaXJlIHJlYXNvbmFibGUga2V5IGV2ZW50cyBmb3IgZW50ZXIsXG4gICAgICAgIC8vIGJhY2tzcGFjZSwgb3IgZGVsZXRlLiBTbyB0aGlzIGRldGVjdHMgY2hhbmdlcyB0aGF0IGxvb2sgbGlrZVxuICAgICAgICAvLyB0aGV5J3JlIGNhdXNlZCBieSB0aG9zZSBrZXlzLCBhbmQgcmVpbnRlcnByZXRzIHRoZW0gYXMga2V5XG4gICAgICAgIC8vIGV2ZW50cy4gKFNvbWUgb2YgdGhlc2Uga2V5cyBhcmUgYWxzbyBoYW5kbGVkIGJ5IGJlZm9yZWlucHV0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgdGhlIHBlbmRpbmdBbmRyb2lkS2V5IG1lY2hhbmlzbSwgYnV0IHRoYXQncyBub3RcbiAgICAgICAgLy8gcmVsaWFibGUgaW4gYWxsIHNpdHVhdGlvbnMuKVxuICAgICAgICBpZiAoYnJvd3Nlci5hbmRyb2lkICYmXG4gICAgICAgICAgICAoKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tICYmIGNoYW5nZS50byA9PSBzZWwudG8gJiZcbiAgICAgICAgICAgICAgICBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIGNoYW5nZS5pbnNlcnQubGluZXMgPT0gMiAmJlxuICAgICAgICAgICAgICAgIGRpc3BhdGNoS2V5KHZpZXcuY29udGVudERPTSwgXCJFbnRlclwiLCAxMykpIHx8XG4gICAgICAgICAgICAgICAgKGNoYW5nZS5mcm9tID09IHNlbC5mcm9tIC0gMSAmJiBjaGFuZ2UudG8gPT0gc2VsLnRvICYmIGNoYW5nZS5pbnNlcnQubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hLZXkodmlldy5jb250ZW50RE9NLCBcIkJhY2tzcGFjZVwiLCA4KSkgfHxcbiAgICAgICAgICAgICAgICAoY2hhbmdlLmZyb20gPT0gc2VsLmZyb20gJiYgY2hhbmdlLnRvID09IHNlbC50byArIDEgJiYgY2hhbmdlLmluc2VydC5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaEtleSh2aWV3LmNvbnRlbnRET00sIFwiRGVsZXRlXCIsIDQ2KSkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgdGV4dCA9IGNoYW5nZS5pbnNlcnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZpZXcuc3RhdGUuZmFjZXQoaW5wdXRIYW5kbGVyKS5zb21lKGggPT4gaCh2aWV3LCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvLCB0ZXh0KSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDApXG4gICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaW5nKys7XG4gICAgICAgIGxldCB0cjtcbiAgICAgICAgaWYgKGNoYW5nZS5mcm9tID49IHNlbC5mcm9tICYmIGNoYW5nZS50byA8PSBzZWwudG8gJiYgY2hhbmdlLnRvIC0gY2hhbmdlLmZyb20gPj0gKHNlbC50byAtIHNlbC5mcm9tKSAvIDMgJiZcbiAgICAgICAgICAgICghbmV3U2VsIHx8IG5ld1NlbC5tYWluLmVtcHR5ICYmIG5ld1NlbC5tYWluLmZyb20gPT0gY2hhbmdlLmZyb20gKyBjaGFuZ2UuaW5zZXJ0Lmxlbmd0aCkgJiZcbiAgICAgICAgICAgIHZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwKSB7XG4gICAgICAgICAgICBsZXQgYmVmb3JlID0gc2VsLmZyb20gPCBjaGFuZ2UuZnJvbSA/IHN0YXJ0U3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIGNoYW5nZS5mcm9tKSA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSBzZWwudG8gPiBjaGFuZ2UudG8gPyBzdGFydFN0YXRlLnNsaWNlRG9jKGNoYW5nZS50bywgc2VsLnRvKSA6IFwiXCI7XG4gICAgICAgICAgICB0ciA9IHN0YXJ0U3RhdGUucmVwbGFjZVNlbGVjdGlvbih2aWV3LnN0YXRlLnRvVGV4dChiZWZvcmUgKyBjaGFuZ2UuaW5zZXJ0LnNsaWNlU3RyaW5nKDAsIHVuZGVmaW5lZCwgdmlldy5zdGF0ZS5saW5lQnJlYWspICsgYWZ0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzID0gc3RhcnRTdGF0ZS5jaGFuZ2VzKGNoYW5nZSk7XG4gICAgICAgICAgICBsZXQgbWFpblNlbCA9IG5ld1NlbCAmJiAhc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5lcShuZXdTZWwubWFpbikgJiYgbmV3U2VsLm1haW4udG8gPD0gY2hhbmdlcy5uZXdMZW5ndGhcbiAgICAgICAgICAgICAgICA/IG5ld1NlbC5tYWluIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gVHJ5IHRvIGFwcGx5IGEgY29tcG9zaXRpb24gY2hhbmdlIHRvIGFsbCBjdXJzb3JzXG4gICAgICAgICAgICBpZiAoc3RhcnRTdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aCA+IDEgJiYgdmlldy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmXG4gICAgICAgICAgICAgICAgY2hhbmdlLnRvIDw9IHNlbC50byAmJiBjaGFuZ2UudG8gPj0gc2VsLnRvIC0gMTApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVwbGFjZWQgPSB2aWV3LnN0YXRlLnNsaWNlRG9jKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIGxldCBjb21wb3NpdGlvblJhbmdlID0gY29tcG9zaXRpb25TdXJyb3VuZGluZ05vZGUodmlldykgfHwgdmlldy5zdGF0ZS5kb2MubGluZUF0KHNlbC5oZWFkKTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc2VsLnRvIC0gY2hhbmdlLnRvLCBzaXplID0gc2VsLnRvIC0gc2VsLmZyb207XG4gICAgICAgICAgICAgICAgdHIgPSBzdGFydFN0YXRlLmNoYW5nZUJ5UmFuZ2UocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZnJvbSA9PSBzZWwuZnJvbSAmJiByYW5nZS50byA9PSBzZWwudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByYW5nZTogbWFpblNlbCB8fCByYW5nZS5tYXAoY2hhbmdlcykgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvID0gcmFuZ2UudG8gLSBvZmZzZXQsIGZyb20gPSB0byAtIHJlcGxhY2VkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvIC0gcmFuZ2UuZnJvbSAhPSBzaXplIHx8IHZpZXcuc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pICE9IHJlcGxhY2VkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSdzIG5vIHdheSB0byBtYWtlIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIGluIHRoZSBzYW1lIG5vZGUgd29yayB3aXRob3V0IGFib3J0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb3NpdGlvbiwgc28gY3Vyc29ycyBpbiB0aGUgY29tcG9zaXRpb24gcmFuZ2UgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRpb25SYW5nZSAmJiByYW5nZS50byA+PSBjb21wb3NpdGlvblJhbmdlLmZyb20gJiYgcmFuZ2UuZnJvbSA8PSBjb21wb3NpdGlvblJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2UgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlQ2hhbmdlcyA9IHN0YXJ0U3RhdGUuY2hhbmdlcyh7IGZyb20sIHRvLCBpbnNlcnQ6IGNoYW5nZS5pbnNlcnQgfSksIHNlbE9mZiA9IHJhbmdlLnRvIC0gc2VsLnRvO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlczogcmFuZ2VDaGFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6ICFtYWluU2VsID8gcmFuZ2UubWFwKHJhbmdlQ2hhbmdlcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVkaXRvclNlbGVjdGlvbi5yYW5nZShNYXRoLm1heCgwLCBtYWluU2VsLmFuY2hvciArIHNlbE9mZiksIE1hdGgubWF4KDAsIG1haW5TZWwuaGVhZCArIHNlbE9mZikpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBtYWluU2VsICYmIHN0YXJ0U3RhdGUuc2VsZWN0aW9uLnJlcGxhY2VSYW5nZShtYWluU2VsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZXJFdmVudCA9IFwiaW5wdXQudHlwZVwiO1xuICAgICAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIHVzZXJFdmVudCArPSBcIi5jb21wb3NlXCI7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB1c2VyRXZlbnQgKz0gXCIuc3RhcnRcIjtcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHIsIHsgc2Nyb2xsSW50b1ZpZXc6IHRydWUsIHVzZXJFdmVudCB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV3U2VsICYmICFuZXdTZWwubWFpbi5lcShzZWwpKSB7XG4gICAgICAgIGxldCBzY3JvbGxJbnRvVmlldyA9IGZhbHNlLCB1c2VyRXZlbnQgPSBcInNlbGVjdFwiO1xuICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwKSB7XG4gICAgICAgICAgICBpZiAodmlldy5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4gPT0gXCJzZWxlY3RcIilcbiAgICAgICAgICAgICAgICBzY3JvbGxJbnRvVmlldyA9IHRydWU7XG4gICAgICAgICAgICB1c2VyRXZlbnQgPSB2aWV3LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiBuZXdTZWwsIHNjcm9sbEludG9WaWV3LCB1c2VyRXZlbnQgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlKSB7XG4gICAgbGV0IG1pbkxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG4gICAgbGV0IGZyb20gPSAwO1xuICAgIHdoaWxlIChmcm9tIDwgbWluTGVuICYmIGEuY2hhckNvZGVBdChmcm9tKSA9PSBiLmNoYXJDb2RlQXQoZnJvbSkpXG4gICAgICAgIGZyb20rKztcbiAgICBpZiAoZnJvbSA9PSBtaW5MZW4gJiYgYS5sZW5ndGggPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0b0EgPSBhLmxlbmd0aCwgdG9CID0gYi5sZW5ndGg7XG4gICAgd2hpbGUgKHRvQSA+IDAgJiYgdG9CID4gMCAmJiBhLmNoYXJDb2RlQXQodG9BIC0gMSkgPT0gYi5jaGFyQ29kZUF0KHRvQiAtIDEpKSB7XG4gICAgICAgIHRvQS0tO1xuICAgICAgICB0b0ItLTtcbiAgICB9XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgZnJvbSAtIE1hdGgubWluKHRvQSwgdG9CKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSB0b0EgKyBhZGp1c3QgLSBmcm9tO1xuICAgIH1cbiAgICBpZiAodG9BIDwgZnJvbSAmJiBhLmxlbmd0aCA8IGIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IGZyb20gJiYgcHJlZmVycmVkUG9zID49IHRvQSA/IGZyb20gLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBmcm9tIC09IG1vdmU7XG4gICAgICAgIHRvQiA9IGZyb20gKyAodG9CIC0gdG9BKTtcbiAgICAgICAgdG9BID0gZnJvbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodG9CIDwgZnJvbSkge1xuICAgICAgICBsZXQgbW92ZSA9IHByZWZlcnJlZFBvcyA8PSBmcm9tICYmIHByZWZlcnJlZFBvcyA+PSB0b0IgPyBmcm9tIC0gcHJlZmVycmVkUG9zIDogMDtcbiAgICAgICAgZnJvbSAtPSBtb3ZlO1xuICAgICAgICB0b0EgPSBmcm9tICsgKHRvQSAtIHRvQik7XG4gICAgICAgIHRvQiA9IGZyb207XG4gICAgfVxuICAgIHJldHVybiB7IGZyb20sIHRvQSwgdG9CIH07XG59XG5mdW5jdGlvbiBzZWxlY3Rpb25Qb2ludHModmlldykge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmlldy5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdmlldy5jb250ZW50RE9NKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGxldCB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9ID0gdmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSk7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT0gYW5jaG9yTm9kZSB8fCBmb2N1c09mZnNldCAhPSBhbmNob3JPZmZzZXQpXG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgRE9NUG9pbnQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbVBvaW50cyhwb2ludHMsIGJhc2UpIHtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYW5jaG9yID0gcG9pbnRzWzBdLnBvcywgaGVhZCA9IHBvaW50cy5sZW5ndGggPT0gMiA/IHBvaW50c1sxXS5wb3MgOiBhbmNob3I7XG4gICAgcmV0dXJuIGFuY2hvciA+IC0xICYmIGhlYWQgPiAtMSA/IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUoYW5jaG9yICsgYmFzZSwgaGVhZCArIGJhc2UpIDogbnVsbDtcbn1cblxuLy8gVGhlIGVkaXRvcidzIHVwZGF0ZSBzdGF0ZSBtYWNoaW5lIGxvb2tzIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4vL1xuLy8gICAgIElkbGUg4oaSIFVwZGF0aW5nIOKHhiBJZGxlICh1bmNoZWNrZWQpIOKGkiBNZWFzdXJpbmcg4oaSIElkbGVcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgICAgICDihpNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGluZyAobWVhc3VyZSlcbi8vXG4vLyBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuICdJZGxlJyBhbmQgJ0lkbGUgKHVuY2hlY2tlZCknIGxpZXMgaW5cbi8vIHdoZXRoZXIgYSBsYXlvdXQgY2hlY2sgaGFzIGJlZW4gc2NoZWR1bGVkLiBBIHJlZ3VsYXIgdXBkYXRlIHRocm91Z2hcbi8vIHRoZSBgdXBkYXRlYCBtZXRob2QgdXBkYXRlcyB0aGUgRE9NIGluIGEgd3JpdGUtb25seSBmYXNoaW9uLCBhbmRcbi8vIHJlbGllcyBvbiBhIGNoZWNrIChzY2hlZHVsZWQgd2l0aCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCkgdG8gbWFrZVxuLy8gc3VyZSBldmVyeXRoaW5nIGlzIHdoZXJlIGl0IHNob3VsZCBiZSBhbmQgdGhlIHZpZXdwb3J0IGNvdmVycyB0aGVcbi8vIHZpc2libGUgY29kZS4gVGhhdCBjaGVjayBjb250aW51ZXMgdG8gbWVhc3VyZSBhbmQgdGhlbiBvcHRpb25hbGx5XG4vLyB1cGRhdGUgdW50aWwgaXQgcmVhY2hlcyBhIGNvaGVyZW50IHN0YXRlLlxuLyoqXG5BbiBlZGl0b3IgdmlldyByZXByZXNlbnRzIHRoZSBlZGl0b3IncyB1c2VyIGludGVyZmFjZS4gSXQgaG9sZHNcbnRoZSBlZGl0YWJsZSBET00gc3VyZmFjZSwgYW5kIHBvc3NpYmx5IG90aGVyIGVsZW1lbnRzIHN1Y2ggYXMgdGhlXG5saW5lIG51bWJlciBndXR0ZXIuIEl0IGhhbmRsZXMgZXZlbnRzIGFuZCBkaXNwYXRjaGVzIHN0YXRlXG50cmFuc2FjdGlvbnMgZm9yIGVkaXRpbmcgYWN0aW9ucy5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdmlldy4gWW91J2xsIHVzdWFsbHkgd2FudCB0byBwdXQgYHZpZXcuZG9tYCBpbnRvXG4gICAgeW91ciBkb2N1bWVudCBhZnRlciBjcmVhdGluZyBhIHZpZXcsIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHNlZVxuICAgIGl0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgSW5pdGlhbGl6YXRpb24gb3B0aW9ucy5cbiAgICAqL1xuICAgIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbk1hcCA9IG5ldyBNYXA7XG4gICAgICAgIHRoaXMuZWRpdG9yQXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5jb250ZW50QXR0cnMgPSB7fTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGluZyAqLztcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLnNjcm9sbERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuc2Nyb2xsRE9NLmNsYXNzTmFtZSA9IFwiY20tc2Nyb2xsZXJcIjtcbiAgICAgICAgdGhpcy5zY3JvbGxET00uYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgdGhpcy5hbm5vdW5jZURPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IC0xMDAwMHB4XCI7XG4gICAgICAgIHRoaXMuYW5ub3VuY2VET00uc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuYW5ub3VuY2VET00pO1xuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbERPTSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoID0gY29uZmlnLmRpc3BhdGNoIHx8ICgodHIpID0+IHRoaXMudXBkYXRlKFt0cl0pKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yb290ID0gKGNvbmZpZy5yb290IHx8IGdldFJvb3QoY29uZmlnLnBhcmVudCkgfHwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUoY29uZmlnLnN0YXRlIHx8IEVkaXRvclN0YXRlLmNyZWF0ZSgpKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldCh2aWV3UGx1Z2luKS5tYXAoc3BlYyA9PiBuZXcgUGx1Z2luSW5zdGFuY2Uoc3BlYykpO1xuICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgcGx1Z2luLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBET01PYnNlcnZlcih0aGlzLCAoZnJvbSwgdG8sIHR5cGVPdmVyKSA9PiB7XG4gICAgICAgICAgICBhcHBseURPTUNoYW5nZSh0aGlzLCBmcm9tLCB0bywgdHlwZU92ZXIpO1xuICAgICAgICB9LCBldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUucnVuU2Nyb2xsSGFuZGxlcnModGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIuaW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgICAgIHRoaXMubWVhc3VyZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlID0gbmV3IElucHV0U3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG5ldyBEb2NWaWV3KHRoaXMpO1xuICAgICAgICB0aGlzLm1vdW50U3R5bGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogSWRsZSAqLztcbiAgICAgICAgZW5zdXJlR2xvYmFsSGFuZGxlcigpO1xuICAgICAgICB0aGlzLnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgICAgIGlmIChjb25maWcucGFyZW50KVxuICAgICAgICAgICAgY29uZmlnLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlOyB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBkaXNwbGF5IGxhcmdlIGRvY3VtZW50cyB3aXRob3V0IGNvbnN1bWluZyB0b28gbXVjaFxuICAgIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICAgIGNvZGUgdGhhdCBpcyB2aXNpYmxlIChwbHVzIGEgbWFyZ2luIGFyb3VuZCBpdCkgdG8gdGhlIERPTS4gVGhpc1xuICAgIHByb3BlcnR5IHRlbGxzIHlvdSB0aGUgZXh0ZW50IG9mIHRoZSBjdXJyZW50IGRyYXduIHZpZXdwb3J0LCBpblxuICAgIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLnZpZXdwb3J0OyB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICAgIHZpZXdwb3J0LCBpdHMgc2l6ZSBjYW4gYmUgYSBsb3QgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCB2aXNpYmxlXG4gICAgY29udGVudC4gVGh1cywgaWYgeW91IGFyZSBkb2luZyBzb21ldGhpbmcgbGlrZSBzdHlsaW5nIHRoZVxuICAgIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gICAgdGhlc2UgcmFuZ2VzLCB3aGljaCBhcmUgdGhlIHN1YnNldCBvZiB0aGUgdmlld3BvcnQgdGhhdCBpc1xuICAgIGFjdHVhbGx5IGRyYXduLlxuICAgICovXG4gICAgZ2V0IHZpc2libGVSYW5nZXMoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBmYWxzZSB3aGVuIHRoZSBlZGl0b3IgaXMgZW50aXJlbHkgc2Nyb2xsZWQgb3V0IG9mIHZpZXdcbiAgICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAgICovXG4gICAgZ2V0IGluVmlldygpIHsgcmV0dXJuIHRoaXMudmlld1N0YXRlLmluVmlldzsgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgICBbSU1FXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnB1dF9tZXRob2QpLlxuICAgICovXG4gICAgZ2V0IGNvbXBvc2luZygpIHsgcmV0dXJuIHRoaXMuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPiAwOyB9XG4gICAgZGlzcGF0Y2goLi4uaW5wdXQpIHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2goaW5wdXQubGVuZ3RoID09IDEgJiYgaW5wdXRbMF0gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbiA/IGlucHV0WzBdXG4gICAgICAgICAgICA6IHRoaXMuc3RhdGUudXBkYXRlKC4uLmlucHV0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdmlldyBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIHRyYW5zYWN0aW9ucy4gVGhpcyB3aWxsXG4gICAgdXBkYXRlIHRoZSB2aXNpYmxlIGRvY3VtZW50IGFuZCBzZWxlY3Rpb24gdG8gbWF0Y2ggdGhlIHN0YXRlXG4gICAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gICAgY2hhbmdlLiBZb3Ugc2hvdWxkIHVzdWFsbHkgY2FsbFxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZCwgd2hpY2ggdXNlcyB0aGlzXG4gICAgYXMgYSBwcmltaXRpdmUuXG4gICAgKi9cbiAgICB1cGRhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlICE9IDAgLyogSWRsZSAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGxldCByZWRyYXduID0gZmFsc2UsIHVwZGF0ZTtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHIuc3RhcnRTdGF0ZSAhPSBzdGF0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byB1cGRhdGUgc3RhdGUgd2l0aCBhIHRyYW5zYWN0aW9uIHRoYXQgZG9lc24ndCBzdGFydCBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZS5cIik7XG4gICAgICAgICAgICBzdGF0ZSA9IHRyLnN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBwaHJhc2VzIGNoYW5nZSwgcmVkcmF3IHRoZSBlZGl0b3JcbiAgICAgICAgaWYgKHN0YXRlLmZhY2V0KEVkaXRvclN0YXRlLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoRWRpdG9yU3RhdGUucGhyYXNlcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZSA9IG5ldyBWaWV3VXBkYXRlKHRoaXMsIHN0YXRlLCB0cmFuc2FjdGlvbnMpO1xuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0ID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRpbmcgKi87XG4gICAgICAgICAgICBmb3IgKGxldCB0ciBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBzY3JvbGxUYXJnZXQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0ci5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBtYWluIH0gPSB0ci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQobWFpbi5lbXB0eSA/IG1haW4gOiBFZGl0b3JTZWxlY3Rpb24uY3Vyc29yKG1haW4uaGVhZCwgbWFpbi5oZWFkID4gbWFpbi5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0ci5lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzKHNjcm9sbFRvKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldCA9IG5ldyBTY3JvbGxUYXJnZXQoZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUuaXMoY2VudGVyT24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVGFyZ2V0ID0gbmV3IFNjcm9sbFRhcmdldChlLnZhbHVlLCBcImNlbnRlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5pcyhzY3JvbGxJbnRvVmlldykpXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXQgPSBlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlld1N0YXRlLnVwZGF0ZSh1cGRhdGUsIHNjcm9sbFRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmJpZGlDYWNoZSA9IENhY2hlZE9yZGVyLnVwZGF0ZSh0aGlzLmJpZGlDYWNoZSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBsdWdpbnModXBkYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0U3RhdGUudXBkYXRlKHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpICE9IHRoaXMuc3R5bGVNb2R1bGVzKVxuICAgICAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd0Fubm91bmNlbWVudHModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24ocmVkcmF3biwgdHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuaXNVc2VyRXZlbnQoXCJzZWxlY3QucG9pbnRlclwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDAgLyogSWRsZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVkcmF3biB8fCBzY3JvbGxUYXJnZXQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYylcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNldCB0aGUgdmlldyB0byB0aGUgZ2l2ZW4gc3RhdGUuIChUaGlzIHdpbGwgY2F1c2UgdGhlIGVudGlyZVxuICAgIGRvY3VtZW50IHRvIGJlIHJlZHJhd24gYW5kIGFsbCB2aWV3IHBsdWdpbnMgdG8gYmUgcmVpbml0aWFsaXplZCxcbiAgICBzbyB5b3Ugc2hvdWxkIHByb2JhYmx5IG9ubHkgdXNlIGl0IHdoZW4gdGhlIG5ldyBzdGF0ZSBpc24ndFxuICAgIGRlcml2ZWQgZnJvbSB0aGUgb2xkIHN0YXRlLiBPdGhlcndpc2UsIHVzZVxuICAgIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZC4pXG4gICAgKi9cbiAgICBzZXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwIC8qIElkbGUgKi8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxscyB0byBFZGl0b3JWaWV3LnNldFN0YXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMiAvKiBVcGRhdGluZyAqLztcbiAgICAgICAgbGV0IGhhZEZvY3VzID0gdGhpcy5oYXNGb2N1cztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBWaWV3U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3U3RhdGUuZmFjZXQodmlld1BsdWdpbikubWFwKHNwZWMgPT4gbmV3IFBsdWdpbkluc3RhbmNlKHNwZWMpKTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBwbHVnaW4gb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcgPSBuZXcgRG9jVmlldyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubW91bnRTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXR0cnMoKTtcbiAgICAgICAgICAgIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBJZGxlICovO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWRGb2N1cylcbiAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICAgIH1cbiAgICB1cGRhdGVQbHVnaW5zKHVwZGF0ZSkge1xuICAgICAgICBsZXQgcHJldlNwZWNzID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQodmlld1BsdWdpbiksIHNwZWNzID0gdXBkYXRlLnN0YXRlLmZhY2V0KHZpZXdQbHVnaW4pO1xuICAgICAgICBpZiAocHJldlNwZWNzICE9IHNwZWNzKSB7XG4gICAgICAgICAgICBsZXQgbmV3UGx1Z2lucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgc3BlYyBvZiBzcGVjcykge1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHByZXZTcGVjcy5pbmRleE9mKHNwZWMpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UGx1Z2lucy5wdXNoKG5ldyBQbHVnaW5JbnN0YW5jZShzcGVjKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gdGhpcy5wbHVnaW5zW2ZvdW5kXTtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLm11c3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG5ld1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5tdXN0VXBkYXRlICE9IHVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmRlc3Ryb3kodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMgPSBuZXdQbHVnaW5zO1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS5lbnN1cmVIYW5kbGVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICAgICAgICAgIHAubXVzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGx1Z2luc1tpXS51cGRhdGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWVhc3VyZShmbHVzaCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAwOyAvLyBQcmV2ZW50IHJlcXVlc3RNZWFzdXJlIGNhbGxzIGZyb20gc2NoZWR1bGluZyBhbm90aGVyIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICBpZiAoZmx1c2gpXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDEgLyogTWVhc3VyaW5nICovO1xuICAgICAgICAgICAgICAgIGxldCBvbGRWaWV3cG9ydCA9IHRoaXMudmlld3BvcnQ7XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZWQgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghY2hhbmdlZCAmJiAhdGhpcy5tZWFzdXJlUmVxdWVzdHMubGVuZ3RoICYmIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIk1lYXN1cmUgbG9vcCByZXN0YXJ0ZWQgbW9yZSB0aGFuIDUgdGltZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlZpZXdwb3J0IGZhaWxlZCB0byBzdGFiaWxpemVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyaW5nID0gW107XG4gICAgICAgICAgICAgICAgLy8gT25seSBydW4gbWVhc3VyZSByZXF1ZXN0cyBpbiB0aGlzIGN5Y2xlIHdoZW4gdGhlIHZpZXdwb3J0IGRpZG4ndCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIShjaGFuZ2VkICYgNCAvKiBWaWV3cG9ydCAqLykpXG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLm1lYXN1cmVSZXF1ZXN0cywgbWVhc3VyaW5nXSA9IFttZWFzdXJpbmcsIHRoaXMubWVhc3VyZVJlcXVlc3RzXTtcbiAgICAgICAgICAgICAgICBsZXQgbWVhc3VyZWQgPSBtZWFzdXJpbmcubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0ucmVhZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nRXhjZXB0aW9uKHRoaXMuc3RhdGUsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJhZE1lYXN1cmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlID0gbmV3IFZpZXdVcGRhdGUodGhpcywgdGhpcy5zdGF0ZSksIHJlZHJhd24gPSBmYWxzZSwgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB1cGRhdGUuZmxhZ3MgfD0gY2hhbmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmZsYWdzIHw9IGNoYW5nZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSA9IDIgLyogVXBkYXRpbmcgKi87XG4gICAgICAgICAgICAgICAgaWYgKCF1cGRhdGUuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5zKHVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUodXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVBdHRycygpO1xuICAgICAgICAgICAgICAgICAgICByZWRyYXduID0gdGhpcy5kb2NWaWV3LnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lYXN1cmluZy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkW2ldICE9IEJhZE1lYXN1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSBtZWFzdXJpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ud3JpdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ud3JpdGUobWVhc3VyZWRbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dFeGNlcHRpb24odGhpcy5zdGF0ZSwgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy52aWV3U3RhdGUuc2Nyb2xsVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy5zY3JvbGxJbnRvVmlldyh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXduKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gb2xkVmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IG9sZFZpZXdwb3J0LnRvICYmXG4gICAgICAgICAgICAgICAgICAgICFzY3JvbGxlZCAmJiB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMCAvKiBJZGxlICovO1xuICAgICAgICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgIXVwZGF0ZWQuZW1wdHkpXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlLmZhY2V0KHVwZGF0ZUxpc3RlbmVyKSlcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcih1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBDU1MgY2xhc3NlcyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWRpdG9yIHRoZW1lcy5cbiAgICAqL1xuICAgIGdldCB0aGVtZUNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVGhlbWVJRCArIFwiIFwiICtcbiAgICAgICAgICAgICh0aGlzLnN0YXRlLmZhY2V0KGRhcmtUaGVtZSkgPyBiYXNlRGFya0lEIDogYmFzZUxpZ2h0SUQpICsgXCIgXCIgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5mYWNldCh0aGVtZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF0dHJzKCkge1xuICAgICAgICBsZXQgZWRpdG9yQXR0cnMgPSBhdHRyc0Zyb21GYWNldCh0aGlzLCBlZGl0b3JBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICBjbGFzczogXCJjbS1lZGl0b3JcIiArICh0aGlzLmhhc0ZvY3VzID8gXCIgY20tZm9jdXNlZCBcIiA6IFwiIFwiKSArIHRoaXMudGhlbWVDbGFzc2VzXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY29udGVudEF0dHJzID0ge1xuICAgICAgICAgICAgc3BlbGxjaGVjazogXCJmYWxzZVwiLFxuICAgICAgICAgICAgYXV0b2NvcnJlY3Q6IFwib2ZmXCIsXG4gICAgICAgICAgICBhdXRvY2FwaXRhbGl6ZTogXCJvZmZcIixcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogXCJub1wiLFxuICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiAhdGhpcy5zdGF0ZS5mYWNldChlZGl0YWJsZSkgPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWNvbnRlbnRcIixcbiAgICAgICAgICAgIHN0eWxlOiBgJHticm93c2VyLnRhYlNpemV9OiAke3RoaXMuc3RhdGUudGFiU2l6ZX1gLFxuICAgICAgICAgICAgcm9sZTogXCJ0ZXh0Ym94XCIsXG4gICAgICAgICAgICBcImFyaWEtbXVsdGlsaW5lXCI6IFwidHJ1ZVwiXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICAgICAgY29udGVudEF0dHJzW1wiYXJpYS1yZWFkb25seVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICBhdHRyc0Zyb21GYWNldCh0aGlzLCBjb250ZW50QXR0cmlidXRlcywgY29udGVudEF0dHJzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlQXR0cnModGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgY29udGVudEF0dHJzKTtcbiAgICAgICAgICAgIHVwZGF0ZUF0dHJzKHRoaXMuZG9tLCB0aGlzLmVkaXRvckF0dHJzLCBlZGl0b3JBdHRycyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVkaXRvckF0dHJzID0gZWRpdG9yQXR0cnM7XG4gICAgICAgIHRoaXMuY29udGVudEF0dHJzID0gY29udGVudEF0dHJzO1xuICAgIH1cbiAgICBzaG93QW5ub3VuY2VtZW50cyh0cnMpIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgdHIgb2YgdHJzKVxuICAgICAgICAgICAgZm9yIChsZXQgZWZmZWN0IG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhFZGl0b3JWaWV3LmFubm91bmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdiA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGVmZmVjdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50U3R5bGVzKCkge1xuICAgICAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoc3R5bGVNb2R1bGUpO1xuICAgICAgICBTdHlsZU1vZHVsZS5tb3VudCh0aGlzLnJvb3QsIHRoaXMuc3R5bGVNb2R1bGVzLmNvbmNhdChiYXNlVGhlbWUpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHJlYWRNZWFzdXJlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgPT0gMiAvKiBVcGRhdGluZyAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWRpbmcgdGhlIGVkaXRvciBsYXlvdXQgaXNuJ3QgYWxsb3dlZCBkdXJpbmcgYW4gdXBkYXRlXCIpO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSA9PSAwIC8qIElkbGUgKi8gJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmUoZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBTY2hlZHVsZSBhIGxheW91dCBtZWFzdXJlbWVudCwgb3B0aW9uYWxseSBwcm92aWRpbmcgY2FsbGJhY2tzIHRvXG4gICAgZG8gY3VzdG9tIERPTSBtZWFzdXJpbmcgZm9sbG93ZWQgYnkgYSBET00gd3JpdGUgcGhhc2UuIFVzaW5nXG4gICAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgICBleGFtcGxlLCBhbiBldmVudCBoYW5kbGVyLCBiZWNhdXNlIGl0J2xsIG1ha2Ugc3VyZSBtZWFzdXJpbmcgYW5kXG4gICAgZHJhd2luZyBkb25lIGJ5IG90aGVyIGNvbXBvbmVudHMgaXMgc3luY2hyb25pemVkLCBhdm9pZGluZ1xuICAgIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAgICovXG4gICAgcmVxdWVzdE1lYXN1cmUocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkIDwgMClcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSk7XG4gICAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC5rZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXS5rZXkgPT09IHJlcXVlc3Qua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tpXSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENvbGxlY3QgYWxsIHZhbHVlcyBwcm92aWRlZCBieSB0aGUgYWN0aXZlIHBsdWdpbnMgZm9yIGEgZ2l2ZW5cbiAgICBmaWVsZC5cbiAgICAqL1xuICAgIHBsdWdpbkZpZWxkKGZpZWxkKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi51cGRhdGUodGhpcykudGFrZUZpZWxkKGZpZWxkLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIGEgc3BlY2lmaWMgcGx1Z2luLCBpZiBwcmVzZW50LiBOb3RlIHRoYXRcbiAgICBwbHVnaW5zIHRoYXQgY3Jhc2ggY2FuIGJlIGRyb3BwZWQgZnJvbSBhIHZpZXcsIHNvIGV2ZW4gd2hlbiB5b3VcbiAgICBrbm93IHlvdSByZWdpc3RlcmVkIGEgZ2l2ZW4gcGx1Z2luLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjaGVja1xuICAgIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBwbHVnaW4ocGx1Z2luKSB7XG4gICAgICAgIGxldCBrbm93biA9IHRoaXMucGx1Z2luTWFwLmdldChwbHVnaW4pO1xuICAgICAgICBpZiAoa25vd24gPT09IHVuZGVmaW5lZCB8fCBrbm93biAmJiBrbm93bi5zcGVjICE9IHBsdWdpbilcbiAgICAgICAgICAgIHRoaXMucGx1Z2luTWFwLnNldChwbHVnaW4sIGtub3duID0gdGhpcy5wbHVnaW5zLmZpbmQocCA9PiBwLnNwZWMgPT0gcGx1Z2luKSB8fCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGtub3duICYmIGtub3duLnVwZGF0ZSh0aGlzKS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHRvcCBwb3NpdGlvbiBvZiB0aGUgZG9jdW1lbnQsIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVGhpc1xuICAgIG1heSBiZSBuZWdhdGl2ZSB3aGVuIHRoZSBlZGl0b3IgaXMgc2Nyb2xsZWQgZG93bi4gUG9pbnRzXG4gICAgZGlyZWN0bHkgdG8gdGhlIHRvcCBvZiB0aGUgZmlyc3QgbGluZSwgbm90IGFib3ZlIHRoZSBwYWRkaW5nLlxuICAgICovXG4gICAgZ2V0IGRvY3VtZW50VG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3A7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcG9ydHMgdGhlIHBhZGRpbmcgYWJvdmUgYW5kIGJlbG93IHRoZSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBkb2N1bWVudFBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB7IHRvcDogdGhpcy52aWV3U3RhdGUucGFkZGluZ1RvcCwgYm90dG9tOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nQm90dG9tIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbi5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIHBvc2l0aW9uIGlzIGludGVycHJldGVkIGFzIGEgc2NyZWVuIHBvc2l0aW9uLFxuICAgIG1lYW5pbmcgYGRvY1RvcGAgaXMgc2V0IHRvIHRoZSBET00gdG9wIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3JcbiAgICBjb250ZW50IChmb3JjaW5nIGEgbGF5b3V0KS4gWW91IGNhbiBwYXNzIGEgZGlmZmVyZW50IGBkb2NUb3BgXG4gICAgdmFsdWXigJRmb3IgZXhhbXBsZSAwIHRvIGludGVycHJldCBgaGVpZ2h0YCBhcyBhIGRvY3VtZW50LXJlbGF0aXZlXG4gICAgcG9zaXRpb24sIG9yIGEgcHJlY29tcHV0ZWQgZG9jdW1lbnQgdG9wXG4gICAgKGB2aWV3LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wYCkgdG8gbGltaXQgbGF5b3V0XG4gICAgcXVlcmllcy5cbiAgICBcbiAgICAqRGVwcmVjYXRlZDogdXNlIGBlbGVtZW50QXRIZWlnaHRgIGluc3RlYWQuKlxuICAgICovXG4gICAgYmxvY2tBdEhlaWdodChoZWlnaHQsIGRvY1RvcCkge1xuICAgICAgICBsZXQgdG9wID0gZW5zdXJlVG9wKGRvY1RvcCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRBdEhlaWdodChoZWlnaHQgLSB0b3ApLm1vdmVZKHRvcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIHRleHQgbGluZSBvciBibG9jayB3aWRnZXQgYXQgdGhlIGdpdmVuIHZlcnRpY2FsXG4gICAgcG9zaXRpb24gKHdoaWNoIGlzIGludGVycHJldGVkIGFzIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICAgIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcClcbiAgICAqL1xuICAgIGVsZW1lbnRBdEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZWFkTWVhc3VyZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmVsZW1lbnRBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGluZm9ybWF0aW9uIGZvciB0aGUgdmlzdWFsIGxpbmUgKHNlZVxuICAgIFtgdmlzdWFsTGluZUF0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudmlzdWFsTGluZUF0KSkgYXQgdGhlIGdpdmVuXG4gICAgdmVydGljYWwgcG9zaXRpb24uIFRoZSByZXN1bHRpbmcgYmxvY2sgaW5mbyBtaWdodCBob2xkIGFub3RoZXJcbiAgICBhcnJheSBvZiBibG9jayBpbmZvIHN0cnVjdHMgaW4gaXRzIGB0eXBlYCBmaWVsZCBpZiB0aGlzIGxpbmVcbiAgICBjb25zaXN0cyBvZiBtb3JlIHRoYW4gb25lIGJsb2NrLlxuICAgIFxuICAgIERlZmF1bHRzIHRvIHRyZWF0aW5nIGBoZWlnaHRgIGFzIGEgc2NyZWVuIHBvc2l0aW9uLiBTZWVcbiAgICBbYGJsb2NrQXRIZWlnaHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5ibG9ja0F0SGVpZ2h0KSBmb3IgdGhlXG4gICAgaW50ZXJwcmV0YXRpb24gb2YgdGhlIGBkb2NUb3BgIHBhcmFtZXRlci5cbiAgICBcbiAgICAqRGVwcmVjYXRlZDogdXNlIGBsaW5lQmxvY2tBdEhlaWdodGAgaW5zdGVhZC4qXG4gICAgKi9cbiAgICB2aXN1YWxMaW5lQXRIZWlnaHQoaGVpZ2h0LCBkb2NUb3ApIHtcbiAgICAgICAgbGV0IHRvcCA9IGVuc3VyZVRvcChkb2NUb3AsIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lQmxvY2tBdEhlaWdodChoZWlnaHQgLSB0b3ApLm1vdmVZKHRvcCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGxpbmUgYmxvY2sgKHNlZVxuICAgIFtgbGluZUJsb2NrQXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgYXQgdGhlIGdpdmVuXG4gICAgaGVpZ2h0LlxuICAgICovXG4gICAgbGluZUJsb2NrQXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdEhlaWdodChoZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICBJdGVyYXRlIG92ZXIgdGhlIGhlaWdodCBpbmZvcm1hdGlvbiBvZiB0aGUgdmlzdWFsIGxpbmVzIGluIHRoZVxuICAgIHZpZXdwb3J0LiBUaGUgaGVpZ2h0cyBvZiBsaW5lcyBhcmUgcmVwb3J0ZWQgcmVsYXRpdmUgdG8gdGhlXG4gICAgZ2l2ZW4gZG9jdW1lbnQgdG9wLCB3aGljaCBkZWZhdWx0cyB0byB0aGUgc2NyZWVuIHBvc2l0aW9uIG9mIHRoZVxuICAgIGRvY3VtZW50IChmb3JjaW5nIGEgbGF5b3V0KS5cbiAgICBcbiAgICAqRGVwcmVjYXRlZDogdXNlIGB2aWV3cG9ydExpbmVCbG9ja3NgIGluc3RlYWQuKlxuICAgICovXG4gICAgdmlld3BvcnRMaW5lcyhmLCBkb2NUb3ApIHtcbiAgICAgICAgbGV0IHRvcCA9IGVuc3VyZVRvcChkb2NUb3AsIHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHRoaXMudmlld3BvcnRMaW5lQmxvY2tzKVxuICAgICAgICAgICAgZihsaW5lLm1vdmVZKHRvcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGV4dGVudCBhbmQgdmVydGljYWwgcG9zaXRpb24gb2YgYWxsIFtsaW5lXG4gICAgYmxvY2tzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lQmxvY2tBdCkgaW4gdGhlIHZpZXdwb3J0LiBQb3NpdGlvbnNcbiAgICBhcmUgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gICAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKTtcbiAgICAqL1xuICAgIGdldCB2aWV3cG9ydExpbmVCbG9ja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydExpbmVzO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBleHRlbnQgYW5kIGhlaWdodCBvZiB0aGUgdmlzdWFsIGxpbmUgKGEgcmFuZ2UgZGVsaW1pdGVkXG4gICAgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgbm9uLVtoaWRkZW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uXnJhbmdlKVxuICAgIGxpbmUgYnJlYWtzLCBvciB0aGUgc3RhcnQvZW5kIG9mIHRoZSBkb2N1bWVudCkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIFxuICAgIFZlcnRpY2FsIHBvc2l0aW9ucyBhcmUgY29tcHV0ZWQgcmVsYXRpdmUgdG8gdGhlIGBkb2NUb3BgXG4gICAgYXJndW1lbnQsIHdoaWNoIGRlZmF1bHRzIHRvIDAgZm9yIHRoaXMgbWV0aG9kLiBZb3UgY2FuIHBhc3NcbiAgICBgdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcGAgaGVyZSB0byBnZXQgc2NyZWVuXG4gICAgY29vcmRpbmF0ZXMuXG4gICAgXG4gICAgKkRlcHJlY2F0ZWQ6IHVzZSBgbGluZUJsb2NrQXRgIGluc3RlYWQuKlxuICAgICovXG4gICAgdmlzdWFsTGluZUF0KHBvcywgZG9jVG9wID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lQmxvY2tBdChwb3MpLm1vdmVZKGRvY1RvcCArIHRoaXMudmlld1N0YXRlLnBhZGRpbmdUb3ApO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBsaW5lIGJsb2NrIGFyb3VuZCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uIEEgbGluZVxuICAgIGJsb2NrIGlzIGEgcmFuZ2UgZGVsaW1pdGVkIG9uIGJvdGggc2lkZXMgYnkgZWl0aGVyIGFcbiAgICBub24tW2hpZGRlbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmFuZ2UpIGxpbmUgYnJlYWtzLCBvciB0aGVcbiAgICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICAgIHRleHQsIGJ1dCBtYXkgYmUgYnJva2VuIGludG8gbXVsdGlwbGUgdGV4dGJsb2NrcyBieSBibG9ja1xuICAgIHdpZGdldHMuXG4gICAgKi9cbiAgICBsaW5lQmxvY2tBdChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0KHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBlZGl0b3IncyB0b3RhbCBjb250ZW50IGhlaWdodC5cbiAgICAqL1xuICAgIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgICBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3RleHQuZmluZENsdXN0ZXJCcmVhaykuIGBmb3J3YXJkYCBkZXRlcm1pbmVzIHdoZXRoZXJcbiAgICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gTW90aW9uIGluXG4gICAgYmlkaXJlY3Rpb25hbCB0ZXh0IGlzIGluIHZpc3VhbCBvcmRlciwgaW4gdGhlIGVkaXRvcidzIFt0ZXh0XG4gICAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS4gV2hlbiB0aGUgc3RhcnRcbiAgICBwb3NpdGlvbiB3YXMgdGhlIGxhc3Qgb25lIG9uIHRoZSBsaW5lLCB0aGUgcmV0dXJuZWQgcG9zaXRpb25cbiAgICB3aWxsIGJlIGFjcm9zcyB0aGUgbGluZSBicmVhay4gSWYgdGhlcmUgaXMgbm8gZnVydGhlciBsaW5lLCB0aGVcbiAgICBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICBcbiAgICBCeSBkZWZhdWx0LCB0aGlzIG1ldGhvZCBtb3ZlcyBvdmVyIGEgc2luZ2xlIGNsdXN0ZXIuIFRoZVxuICAgIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICAgIGJlIGNhbGxlZCB3aXRoIHRoZSBmaXJzdCBjbHVzdGVyIGFzIGFyZ3VtZW50LCBhbmQgc2hvdWxkIHJldHVyblxuICAgIGEgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcywgZm9yIGVhY2ggc3Vic2VxdWVudCBjbHVzdGVyLFxuICAgIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgICAqL1xuICAgIG1vdmVCeUNoYXIoc3RhcnQsIGZvcndhcmQsIGJ5KSB7XG4gICAgICAgIHJldHVybiBza2lwQXRvbXModGhpcywgc3RhcnQsIG1vdmVCeUNoYXIodGhpcywgc3RhcnQsIGZvcndhcmQsIGJ5KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYSBjdXJzb3IgcG9zaXRpb24gYWNyb3NzIHRoZSBuZXh0IGdyb3VwIG9mIGVpdGhlclxuICAgIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICAgIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gICAgKi9cbiAgICBtb3ZlQnlHcm91cChzdGFydCwgZm9yd2FyZCkge1xuICAgICAgICByZXR1cm4gc2tpcEF0b21zKHRoaXMsIHN0YXJ0LCBtb3ZlQnlDaGFyKHRoaXMsIHN0YXJ0LCBmb3J3YXJkLCBpbml0aWFsID0+IGJ5R3JvdXAodGhpcywgc3RhcnQuaGVhZCwgaW5pdGlhbCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBsaW5lIGJvdW5kYXJ5IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uIElmXG4gICAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICAgIGZ1cnRoZXIgd3JhcCBwb2ludCBvbiB0aGUgY3VycmVudCBsaW5lLCB0aGUgd3JhcCBwb2ludCB3aWxsIGJlXG4gICAgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzdGFydCBvciBlbmRcbiAgICBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIG1vdmVUb0xpbmVCb3VuZGFyeShzdGFydCwgZm9yd2FyZCwgaW5jbHVkZVdyYXAgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBtb3ZlVG9MaW5lQm91bmRhcnkodGhpcywgc3RhcnQsIGZvcndhcmQsIGluY2x1ZGVXcmFwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gICAgaXQgZGVmYXVsdHMgdG8gbW92aW5nIHRvIHRoZSBuZXh0IGxpbmUgKGluY2x1ZGluZyB3cmFwcGVkXG4gICAgbGluZXMpLiBPdGhlcndpc2UsIGBkaXN0YW5jZWAgc2hvdWxkIHByb3ZpZGUgYSBwb3NpdGl2ZSBkaXN0YW5jZVxuICAgIGluIHBpeGVscy5cbiAgICBcbiAgICBXaGVuIGBzdGFydGAgaGFzIGFcbiAgICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgICBtb3Rpb24gd2lsbCB1c2UgdGhhdCBhcyBhIHRhcmdldCBob3Jpem9udGFsIHBvc2l0aW9uLiBPdGhlcndpc2UsXG4gICAgdGhlIGN1cnNvcidzIG93biBob3Jpem9udGFsIHBvc2l0aW9uIGlzIHVzZWQuIFRoZSByZXR1cm5lZFxuICAgIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICAgIHVzZWQuXG4gICAgKi9cbiAgICBtb3ZlVmVydGljYWxseShzdGFydCwgZm9yd2FyZCwgZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNraXBBdG9tcyh0aGlzLCBzdGFydCwgbW92ZVZlcnRpY2FsbHkodGhpcywgc3RhcnQsIGZvcndhcmQsIGRpc3RhbmNlKSk7XG4gICAgfVxuICAgIC8vIEZJWE1FIHJlbW92ZSBvbiBuZXh0IG1ham9yIHZlcnNpb25cbiAgICBzY3JvbGxQb3NJbnRvVmlldyhwb3MpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNjcm9sbFRvLm9mKEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocG9zKSkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIERPTSBwYXJlbnQgbm9kZSBhbmQgb2Zmc2V0IChjaGlsZCBvZmZzZXQgaWYgYG5vZGVgIGlzXG4gICAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgICBnaXZlbiBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICBcbiAgICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgICBgdmlzaWJsZVJhbmdlc2AsIHRoZSByZXN1bHRpbmcgRE9NIHBvc2l0aW9uIGlzbid0IG5lY2Vzc2FyaWx5XG4gICAgbWVhbmluZ2Z1bCAoaXQgbWF5IGp1c3QgcG9pbnQgYmVmb3JlIG9yIGFmdGVyIGEgcGxhY2Vob2xkZXJcbiAgICBlbGVtZW50KS5cbiAgICAqL1xuICAgIGRvbUF0UG9zKHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2NWaWV3LmRvbUF0UG9zKHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICAgIGZvciBhc3NvY2lhdGluZyBwb3NpdGlvbnMgd2l0aCBET00gZXZlbnRzLiBXaWxsIHJhaXNlIGFuIGVycm9yXG4gICAgd2hlbiBgbm9kZWAgaXNuJ3QgcGFydCBvZiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4gICAgKi9cbiAgICBwb3NBdERPTShub2RlLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBwb3NBdENvb3Jkcyhjb29yZHMsIHByZWNpc2UgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIHJldHVybiBwb3NBdENvb3Jkcyh0aGlzLCBjb29yZHMsIHByZWNpc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYHNpZGVgIGRldGVybWluZXMgd2hldGhlciB0aGUgY29vcmRpbmF0ZXMgYXJlIGJhc2VkIG9uIHRoZVxuICAgIGVsZW1lbnQgYmVmb3JlICgtMSkgb3IgYWZ0ZXIgKDEpIHRoZSBwb3NpdGlvbiAoaWYgbm8gZWxlbWVudCBpc1xuICAgIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gICAgYW5vdGhlciBzdHJhdGVneSB0byBnZXQgcmVhc29uYWJsZSBjb29yZGluYXRlcykuXG4gICAgKi9cbiAgICBjb29yZHNBdFBvcyhwb3MsIHNpZGUgPSAxKSB7XG4gICAgICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgICAgIGxldCByZWN0ID0gdGhpcy5kb2NWaWV3LmNvb3Jkc0F0KHBvcywgc2lkZSk7XG4gICAgICAgIGlmICghcmVjdCB8fCByZWN0LmxlZnQgPT0gcmVjdC5yaWdodClcbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpLCBvcmRlciA9IHRoaXMuYmlkaVNwYW5zKGxpbmUpO1xuICAgICAgICBsZXQgc3BhbiA9IG9yZGVyW0JpZGlTcGFuLmZpbmQob3JkZXIsIHBvcyAtIGxpbmUuZnJvbSwgLTEsIHNpZGUpXTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5SZWN0KHJlY3QsIChzcGFuLmRpciA9PSBEaXJlY3Rpb24uTFRSKSA9PSAoc2lkZSA+IDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICAgIGFjY3VyYXRlbHkgcmVmbGVjdCB0aGUgd2lkdGggb2YgYWxsIGNoYXJhY3RlcnMgKGdpdmVuIHZhcmlhYmxlXG4gICAgd2lkdGggZm9udHMgb3Igc3R5bGluZyBvZiBpbnZpZGlkdWFsIHJhbmdlcykuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdENoYXJhY3RlcldpZHRoKCkgeyByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDsgfVxuICAgIC8qKlxuICAgIFRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIGxpbmUgaW4gdGhlIGVkaXRvci4gTWF5IG5vdCBiZSBhY2N1cmF0ZVxuICAgIGZvciBhbGwgbGluZXMuXG4gICAgKi9cbiAgICBnZXQgZGVmYXVsdExpbmVIZWlnaHQoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZUhlaWdodDsgfVxuICAgIC8qKlxuICAgIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAgIChbYGRpcmVjdGlvbmBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9kaXJlY3Rpb24pXG4gICAgQ1NTIHByb3BlcnR5KSBvZiB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZ2V0IHRleHREaXJlY3Rpb24oKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUuZGlyZWN0aW9uOyB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGlzIGVkaXRvciBbd3JhcHMgbGluZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZylcbiAgICAoYXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICBbYHdoaXRlLXNwYWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3doaXRlLXNwYWNlKVxuICAgIENTUyBwcm9wZXJ0eSBvZiBpdHMgY29udGVudCBlbGVtZW50KS5cbiAgICAqL1xuICAgIGdldCBsaW5lV3JhcHBpbmcoKSB7IHJldHVybiB0aGlzLnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUubGluZVdyYXBwaW5nOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgYmlkaXJlY3Rpb25hbCB0ZXh0IHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW4gbGluZVxuICAgICh3aGljaCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQpIGFzIGFuIGFycmF5IG9mIHNwYW5cbiAgICBvYmplY3RzLiBUaGUgb3JkZXIgb2YgdGhlc2Ugc3BhbnMgbWF0Y2hlcyB0aGUgW3RleHRcbiAgICBkaXJlY3Rpb25dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnRleHREaXJlY3Rpb24p4oCUaWYgdGhhdCBpc1xuICAgIGxlZnQtdG8tcmlnaHQsIHRoZSBsZWZ0bW9zdCBzcGFucyBjb21lIGZpcnN0LCBvdGhlcndpc2UgdGhlXG4gICAgcmlnaHRtb3N0IHNwYW5zIGNvbWUgZmlyc3QuXG4gICAgKi9cbiAgICBiaWRpU3BhbnMobGluZSkge1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPiBNYXhCaWRpTGluZSlcbiAgICAgICAgICAgIHJldHVybiB0cml2aWFsT3JkZXIobGluZS5sZW5ndGgpO1xuICAgICAgICBsZXQgZGlyID0gdGhpcy50ZXh0RGlyZWN0aW9uO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB0aGlzLmJpZGlDYWNoZSlcbiAgICAgICAgICAgIGlmIChlbnRyeS5mcm9tID09IGxpbmUuZnJvbSAmJiBlbnRyeS5kaXIgPT0gZGlyKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5vcmRlcjtcbiAgICAgICAgbGV0IG9yZGVyID0gY29tcHV0ZU9yZGVyKGxpbmUudGV4dCwgdGhpcy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgdGhpcy5iaWRpQ2FjaGUucHVzaChuZXcgQ2FjaGVkT3JkZXIobGluZS5mcm9tLCBsaW5lLnRvLCBkaXIsIG9yZGVyKSk7XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgICAqL1xuICAgIGdldCBoYXNGb2N1cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBTYWZhcmkgcmV0dXJuIGZhbHNlIGZvciBoYXNGb2N1cyB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgb3BlblxuICAgICAgICAvLyBvciBjbG9zaW5nLCB3aGljaCBsZWFkcyB1cyB0byBpZ25vcmUgc2VsZWN0aW9uIGNoYW5nZXMgZnJvbSB0aGVcbiAgICAgICAgLy8gY29udGV4dCBtZW51IGJlY2F1c2UgaXQgbG9va3MgbGlrZSB0aGUgZWRpdG9yIGlzbid0IGZvY3VzZWQuXG4gICAgICAgIC8vIFRoaXMga2x1ZGdlcyBhcm91bmQgdGhhdC5cbiAgICAgICAgcmV0dXJuIChkb2N1bWVudC5oYXNGb2N1cygpIHx8IGJyb3dzZXIuc2FmYXJpICYmICgoX2EgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0Q29udGV4dE1lbnUpID4gRGF0ZS5ub3coKSAtIDNlNCkgJiZcbiAgICAgICAgICAgIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTTtcbiAgICB9XG4gICAgLyoqXG4gICAgUHV0IGZvY3VzIG9uIHRoZSBlZGl0b3IuXG4gICAgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgICAgICAgZm9jdXNQcmV2ZW50U2Nyb2xsKHRoaXMuY29udGVudERPTSk7XG4gICAgICAgICAgICB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICAgIGRvY3VtZW50LCB1bnJlZ2lzdGVyaW5nIGV2ZW50IGhhbmRsZXJzLCBhbmQgbm90aWZ5aW5nXG4gICAgcGx1Z2lucy4gVGhlIHZpZXcgaW5zdGFuY2UgY2FuIG5vIGxvbmdlciBiZSB1c2VkIGFmdGVyXG4gICAgY2FsbGluZyB0aGlzLlxuICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChsZXQgcGx1Z2luIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbi5kZXN0cm95KHRoaXMpO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnB1dFN0YXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEpXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm1lYXN1cmVTY2hlZHVsZWQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gICAgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhIHRyYW5zYWN0aW9uIHRvXG4gICAgY2F1c2UgaXQgdG8gc2Nyb2xsIHRoZSBnaXZlbiBwb3NpdGlvbiBvciByYW5nZSBpbnRvIHZpZXcuXG4gICAgKi9cbiAgICBzdGF0aWMgc2Nyb2xsSW50b1ZpZXcocG9zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHNjcm9sbEludG9WaWV3Lm9mKG5ldyBTY3JvbGxUYXJnZXQodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiID8gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpIDogcG9zLCBvcHRpb25zLnksIG9wdGlvbnMueCwgb3B0aW9ucy55TWFyZ2luLCBvcHRpb25zLnhNYXJnaW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmFjZXQgdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLiBUaGUgdmFsdWVcbiAgICBzaG91bGQgYmUgYW4gb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gaGFuZGxlciBmdW5jdGlvbnMuIFRoZVxuICAgIGZpcnN0IHN1Y2ggZnVuY3Rpb24gdG8gcmV0dXJuIHRydWUgd2lsbCBiZSBhc3N1bWVkIHRvIGhhdmUgaGFuZGxlZFxuICAgIHRoYXQgZXZlbnQsIGFuZCBubyBvdGhlciBoYW5kbGVycyBvciBidWlsdC1pbiBiZWhhdmlvciB3aWxsIGJlXG4gICAgYWN0aXZhdGVkIGZvciBpdC5cbiAgICBUaGVzZSBhcmUgcmVnaXN0ZXJlZCBvbiB0aGUgW2NvbnRlbnRcbiAgICBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb250ZW50RE9NKSwgZXhjZXB0IGZvciBgc2Nyb2xsYFxuICAgIGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGUgZWRpdG9yJ3MgW3Njcm9sbFxuICAgIGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnNjcm9sbERPTSkgb3Igb25lIG9mIGl0cyBwYXJlbnQgbm9kZXNcbiAgICBpcyBzY3JvbGxlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBkb21FdmVudEhhbmRsZXJzKGhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiBWaWV3UGx1Z2luLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50SGFuZGxlcnM6IGhhbmRsZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0aGVtZSBleHRlbnNpb24uIFRoZSBmaXJzdCBhcmd1bWVudCBjYW4gYmUgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pXG4gICAgc3R5bGUgc3BlYyBwcm92aWRpbmcgdGhlIHN0eWxlcyBmb3IgdGhlIHRoZW1lLiBUaGVzZSB3aWxsIGJlXG4gICAgcHJlZml4ZWQgd2l0aCBhIGdlbmVyYXRlZCBjbGFzcyBmb3IgdGhlIHN0eWxlLlxuICAgIFxuICAgIEJlY2F1c2UgdGhlIHNlbGVjdG9ycyB3aWxsIGJlIHByZWZpeGVkIHdpdGggYSBzY29wZSBjbGFzcywgcnVsZVxuICAgIHRoYXQgZGlyZWN0bHkgbWF0Y2ggdGhlIGVkaXRvcidzIFt3cmFwcGVyXG4gICAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9tKeKAlHRvIHdoaWNoIHRoZSBzY29wZSBjbGFzcyB3aWxsIGJlXG4gICAgYWRkZWTigJRuZWVkIHRvIGJlIGV4cGxpY2l0bHkgZGlmZmVyZW50aWF0ZWQgYnkgYWRkaW5nIGFuIGAmYCB0b1xuICAgIHRoZSBzZWxlY3RvciBmb3IgdGhhdCBlbGVtZW504oCUZm9yIGV4YW1wbGVcbiAgICBgJi5jbS1mb2N1c2VkYC5cbiAgICBcbiAgICBXaGVuIGBkYXJrYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIHRoZW1lIHdpbGwgYmUgbWFya2VkIGFzIGRhcmssXG4gICAgd2hpY2ggd2lsbCBjYXVzZSB0aGUgYCZkYXJrYCBydWxlcyBmcm9tIFtiYXNlXG4gICAgdGhlbWVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15iYXNlVGhlbWUpIHRvIGJlIHVzZWQgKGFzIG9wcG9zZWQgdG9cbiAgICBgJmxpZ2h0YCB3aGVuIGEgbGlnaHQgdGhlbWUgaXMgYWN0aXZlKS5cbiAgICAqL1xuICAgIHN0YXRpYyB0aGVtZShzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBwcmVmaXggPSBTdHlsZU1vZHVsZS5uZXdOYW1lKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBbdGhlbWUub2YocHJlZml4KSwgc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShgLiR7cHJlZml4fWAsIHNwZWMpKV07XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGFyaylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRhcmtUaGVtZS5vZih0cnVlKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBhZGRzIHN0eWxlcyB0byB0aGUgYmFzZSB0aGVtZS4gTGlrZVxuICAgIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcbiAgICBwbGFjZSBvZiB0aGUgZWRpdG9yIHdyYXBwZXIgZWxlbWVudCB3aGVuIGRpcmVjdGx5IHRhcmdldGluZ1xuICAgIHRoYXQuIFlvdSBjYW4gYWxzbyB1c2UgYCZkYXJrYCBvciBgJmxpZ2h0YCBpbnN0ZWFkIHRvIG9ubHlcbiAgICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cbiAgICAqL1xuICAgIHN0YXRpYyBiYXNlVGhlbWUoc3BlYykge1xuICAgICAgICByZXR1cm4gUHJlYy5sb3dlc3Qoc3R5bGVNb2R1bGUub2YoYnVpbGRUaGVtZShcIi5cIiArIGJhc2VUaGVtZUlELCBzcGVjLCBsaWdodERhcmtJRHMpKSk7XG4gICAgfVxufVxuLyoqXG5FZmZlY3QgdGhhdCBjYW4gYmUgW2FkZGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5lZmZlY3RzKSB0byBhXG50cmFuc2FjdGlvbiB0byBtYWtlIGl0IHNjcm9sbCB0aGUgZ2l2ZW4gcmFuZ2UgaW50byB2aWV3LlxuXG4qRGVwcmVjYXRlZCouIFVzZSBbYHNjcm9sbEludG9WaWV3YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdec2Nyb2xsSW50b1ZpZXcpIGluc3RlYWQuXG4qL1xuRWRpdG9yVmlldy5zY3JvbGxUbyA9IHNjcm9sbFRvO1xuLyoqXG5FZmZlY3QgdGhhdCBtYWtlcyB0aGUgZWRpdG9yIHNjcm9sbCB0aGUgZ2l2ZW4gcmFuZ2UgdG8gdGhlXG5jZW50ZXIgb2YgdGhlIHZpc2libGUgdmlldy5cblxuKkRlcHJlY2F0ZWQqLiBVc2UgW2BzY3JvbGxJbnRvVmlld2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnNjcm9sbEludG9WaWV3KSBpbnN0ZWFkLlxuKi9cbkVkaXRvclZpZXcuY2VudGVyT24gPSBjZW50ZXJPbjtcbi8qKlxuRmFjZXQgdG8gYWRkIGEgW3N0eWxlXG5tb2R1bGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJpam5oL3N0eWxlLW1vZCNkb2N1bWVudGF0aW9uKSB0b1xuYW4gZWRpdG9yIHZpZXcuIFRoZSB2aWV3IHdpbGwgZW5zdXJlIHRoYXQgdGhlIG1vZHVsZSBpc1xubW91bnRlZCBpbiBpdHMgW2RvY3VtZW50XG5yb290XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5jb25zdHJ1Y3Rvcl5jb25maWcucm9vdCkuXG4qL1xuRWRpdG9yVmlldy5zdHlsZU1vZHVsZSA9IHN0eWxlTW9kdWxlO1xuLyoqXG5BbiBpbnB1dCBoYW5kbGVyIGNhbiBvdmVycmlkZSB0aGUgd2F5IGNoYW5nZXMgdG8gdGhlIGVkaXRhYmxlXG5ET00gY29udGVudCBhcmUgaGFuZGxlZC4gSGFuZGxlcnMgYXJlIHBhc3NlZCB0aGUgZG9jdW1lbnRcbnBvc2l0aW9ucyBiZXR3ZWVuIHdoaWNoIHRoZSBjaGFuZ2Ugd2FzIGZvdW5kLCBhbmQgdGhlIG5ld1xuY29udGVudC4gV2hlbiBvbmUgcmV0dXJucyB0cnVlLCBubyBmdXJ0aGVyIGlucHV0IGhhbmRsZXJzIGFyZVxuY2FsbGVkIGFuZCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyBwcmV2ZW50ZWQuXG4qL1xuRWRpdG9yVmlldy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4vKipcbkFsbG93cyB5b3UgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRoZVxubGlicmFyeSBjYXRjaGVzIGFuIGV4Y2VwdGlvbiBmcm9tIGFuIGV4dGVuc2lvbiAobW9zdGx5IGZyb20gdmlld1xucGx1Z2lucywgYnV0IG1heSBiZSB1c2VkIGJ5IG90aGVyIGV4dGVuc2lvbnMgdG8gcm91dGUgZXhjZXB0aW9uc1xuZnJvbSB1c2VyLWNvZGUtcHJvdmlkZWQgY2FsbGJhY2tzKS4gVGhpcyBpcyBtb3N0bHkgdXNlZnVsIGZvclxuZGVidWdnaW5nIGFuZCBsb2dnaW5nLiBTZWUgW2Bsb2dFeGNlcHRpb25gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcubG9nRXhjZXB0aW9uKS5cbiovXG5FZGl0b3JWaWV3LmV4Y2VwdGlvblNpbmsgPSBleGNlcHRpb25TaW5rO1xuLyoqXG5BIGZhY2V0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbmV2ZXJ5IHRpbWUgdGhlIHZpZXcgdXBkYXRlcy5cbiovXG5FZGl0b3JWaWV3LnVwZGF0ZUxpc3RlbmVyID0gdXBkYXRlTGlzdGVuZXI7XG4vKipcbkZhY2V0IHRoYXQgY29udHJvbHMgd2hldGhlciB0aGUgZWRpdG9yIGNvbnRlbnQgRE9NIGlzIGVkaXRhYmxlLlxuV2hlbiBpdHMgaGlnaGVzdC1wcmVjZWRlbmNlIHZhbHVlIGlzIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdpbGxcbm5vdCBsb25nZXIgaGF2ZSBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgYXR0cmlidXRlIHNldC4gKE5vdGUgdGhhdFxudGhpcyBkb2Vzbid0IGFmZmVjdCBBUEkgY2FsbHMgdGhhdCBjaGFuZ2UgdGhlIGVkaXRvciBjb250ZW50LFxuZXZlbiB3aGVuIHRob3NlIGFyZSBib3VuZCB0byBrZXlzIG9yIGJ1dHRvbnMuIFNlZSB0aGVcbltgcmVhZE9ubHlgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLnJlYWRPbmx5KSBmYWNldCBmb3IgdGhhdC4pXG4qL1xuRWRpdG9yVmlldy5lZGl0YWJsZSA9IGVkaXRhYmxlO1xuLyoqXG5BbGxvd3MgeW91IHRvIGluZmx1ZW5jZSB0aGUgd2F5IG1vdXNlIHNlbGVjdGlvbiBoYXBwZW5zLiBUaGVcbmZ1bmN0aW9ucyBpbiB0aGlzIGZhY2V0IHdpbGwgYmUgY2FsbGVkIGZvciBhIGBtb3VzZWRvd25gIGV2ZW50XG5vbiB0aGUgZWRpdG9yLCBhbmQgY2FuIHJldHVybiBhbiBvYmplY3QgdGhhdCBvdmVycmlkZXMgdGhlIHdheSBhXG5zZWxlY3Rpb24gaXMgY29tcHV0ZWQgZnJvbSB0aGF0IG1vdXNlIGNsaWNrIG9yIGRyYWcuXG4qL1xuRWRpdG9yVmlldy5tb3VzZVNlbGVjdGlvblN0eWxlID0gbW91c2VTZWxlY3Rpb25TdHlsZTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGlvbiBkcmFnIGV2ZW50XG5zaG91bGQgbW92ZSBvciBjb3B5IHRoZSBzZWxlY3Rpb24uIFRoZSBnaXZlbiBwcmVkaWNhdGUgd2lsbCBiZVxuY2FsbGVkIHdpdGggdGhlIGBtb3VzZWRvd25gIGV2ZW50LCBhbmQgY2FuIHJldHVybiBgdHJ1ZWAgd2hlblxudGhlIGRyYWcgc2hvdWxkIG1vdmUgdGhlIGNvbnRlbnQuXG4qL1xuRWRpdG9yVmlldy5kcmFnTW92ZXNTZWxlY3Rpb24gPSBkcmFnTW92ZXNTZWxlY3Rpb24kMTtcbi8qKlxuRmFjZXQgdXNlZCB0byBjb25maWd1cmUgd2hldGhlciBhIGdpdmVuIHNlbGVjdGluZyBjbGljayBhZGRzXG5hIG5ldyByYW5nZSB0byB0aGUgZXhpc3Rpbmcgc2VsZWN0aW9uIG9yIHJlcGxhY2VzIGl0IGVudGlyZWx5LlxuKi9cbkVkaXRvclZpZXcuY2xpY2tBZGRzU2VsZWN0aW9uUmFuZ2UgPSBjbGlja0FkZHNTZWxlY3Rpb25SYW5nZTtcbi8qKlxuQSBmYWNldCB0aGF0IGRldGVybWluZXMgd2hpY2ggW2RlY29yYXRpb25zXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbilcbmFyZSBzaG93biBpbiB0aGUgdmlldy4gU2VlIGFsc28gW3ZpZXdcbnBsdWdpbnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XmRlY29yYXRpb25zKSwgd2hpY2ggaGF2ZSBhIHNlcGFyYXRlXG5tZWNoYW5pc20gZm9yIHByb3ZpZGluZyBkZWNvcmF0aW9ucy5cbiovXG5FZGl0b3JWaWV3LmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4vKipcblRoaXMgZmFjZXQgcmVjb3JkcyB3aGV0aGVyIGEgZGFyayB0aGVtZSBpcyBhY3RpdmUuIFRoZSBleHRlbnNpb25cbnJldHVybmVkIGJ5IFtgdGhlbWVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld150aGVtZSkgYXV0b21hdGljYWxseVxuaW5jbHVkZXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3aGVuIHRoZSBgZGFya2Agb3B0aW9uIGlzIHNldCB0b1xudHJ1ZS5cbiovXG5FZGl0b3JWaWV3LmRhcmtUaGVtZSA9IGRhcmtUaGVtZTtcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBhZGRpdGlvbmFsIERPTSBhdHRyaWJ1dGVzIGZvciB0aGUgZWRpdG9yJ3NcbmVkaXRhYmxlIERPTSBlbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuY29udGVudEF0dHJpYnV0ZXMgPSBjb250ZW50QXR0cmlidXRlcztcbi8qKlxuRmFjZXQgdGhhdCBwcm92aWRlcyBET00gYXR0cmlidXRlcyBmb3IgdGhlIGVkaXRvcidzIG91dGVyXG5lbGVtZW50LlxuKi9cbkVkaXRvclZpZXcuZWRpdG9yQXR0cmlidXRlcyA9IGVkaXRvckF0dHJpYnV0ZXM7XG4vKipcbkFuIGV4dGVuc2lvbiB0aGF0IGVuYWJsZXMgbGluZSB3cmFwcGluZyBpbiB0aGUgZWRpdG9yIChieVxuc2V0dGluZyBDU1MgYHdoaXRlLXNwYWNlYCB0byBgcHJlLXdyYXBgIGluIHRoZSBjb250ZW50KS5cbiovXG5FZGl0b3JWaWV3LmxpbmVXcmFwcGluZyA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgXCJjbGFzc1wiOiBcImNtLWxpbmVXcmFwcGluZ1wiIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdXNlZCB0byBpbmNsdWRlIHNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50cyBpbiBhXG50cmFuc2FjdGlvbi4gVGhlc2Ugd2lsbCBiZSBhZGRlZCB0byB0aGUgRE9NIGluIGEgdmlzdWFsbHkgaGlkZGVuXG5lbGVtZW50IHdpdGggYGFyaWEtbGl2ZT1cInBvbGl0ZVwiYCBzZXQsIGFuZCBzaG91bGQgYmUgdXNlZCB0b1xuZGVzY3JpYmUgZWZmZWN0cyB0aGF0IGFyZSB2aXN1YWxseSBvYnZpb3VzIGJ1dCBtYXkgbm90IGJlXG5ub3RpY2VkIGJ5IHNjcmVlbiByZWFkZXIgdXNlcnMgKHN1Y2ggYXMgbW92aW5nIHRvIHRoZSBuZXh0XG5zZWFyY2ggbWF0Y2gpLlxuKi9cbkVkaXRvclZpZXcuYW5ub3VuY2UgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG4vLyBNYXhpbXVtIGxpbmUgbGVuZ3RoIGZvciB3aGljaCB3ZSBjb21wdXRlIGFjY3VyYXRlIGJpZGkgaW5mb1xuY29uc3QgTWF4QmlkaUxpbmUgPSA0MDk2O1xuLy8gRklYTUUgcmVtb3ZlIHRoaXMgYW5kIGl0cyBjYWxsZXJzIG9uIG5leHQgYnJlYWtpbmcgcmVsZWFzZVxuZnVuY3Rpb24gZW5zdXJlVG9wKGdpdmVuLCB2aWV3KSB7XG4gICAgcmV0dXJuIChnaXZlbiA9PSBudWxsID8gdmlldy5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IGdpdmVuKSArIHZpZXcudmlld1N0YXRlLnBhZGRpbmdUb3A7XG59XG5sZXQgcmVzaXplRGVib3VuY2UgPSAtMTtcbmZ1bmN0aW9uIGVuc3VyZUdsb2JhbEhhbmRsZXIoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAocmVzaXplRGVib3VuY2UgPT0gLTEpXG4gICAgICAgICAgICByZXNpemVEZWJvdW5jZSA9IHNldFRpbWVvdXQoaGFuZGxlUmVzaXplLCA1MCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVSZXNpemUoKSB7XG4gICAgcmVzaXplRGVib3VuY2UgPSAtMTtcbiAgICBsZXQgZm91bmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmNtLWNvbnRlbnRcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb3VuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZG9jVmlldyA9IENvbnRlbnRWaWV3LmdldChmb3VuZFtpXSk7XG4gICAgICAgIGlmIChkb2NWaWV3KVxuICAgICAgICAgICAgZG9jVmlldy5lZGl0b3JWaWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfVxufVxuY29uc3QgQmFkTWVhc3VyZSA9IHt9O1xuY2xhc3MgQ2FjaGVkT3JkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvLCBkaXIsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICAgIHRoaXMub3JkZXIgPSBvcmRlcjtcbiAgICB9XG4gICAgc3RhdGljIHVwZGF0ZShjYWNoZSwgY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBsYXN0RGlyID0gY2FjaGUubGVuZ3RoID8gY2FjaGVbY2FjaGUubGVuZ3RoIC0gMV0uZGlyIDogRGlyZWN0aW9uLkxUUjtcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGgubWF4KDAsIGNhY2hlLmxlbmd0aCAtIDEwKTsgaSA8IGNhY2hlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZW50cnkgPSBjYWNoZVtpXTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5kaXIgPT0gbGFzdERpciAmJiAhY2hhbmdlcy50b3VjaGVzUmFuZ2UoZW50cnkuZnJvbSwgZW50cnkudG8pKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBDYWNoZWRPcmRlcihjaGFuZ2VzLm1hcFBvcyhlbnRyeS5mcm9tLCAxKSwgY2hhbmdlcy5tYXBQb3MoZW50cnkudG8sIC0xKSwgZW50cnkuZGlyLCBlbnRyeS5vcmRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cnNGcm9tRmFjZXQodmlldywgZmFjZXQsIGJhc2UpIHtcbiAgICBmb3IgKGxldCBzb3VyY2VzID0gdmlldy5zdGF0ZS5mYWNldChmYWNldCksIGkgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzb3VyY2VzW2ldLCB2YWx1ZSA9IHR5cGVvZiBzb3VyY2UgPT0gXCJmdW5jdGlvblwiID8gc291cmNlKHZpZXcpIDogc291cmNlO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICBjb21iaW5lQXR0cnModmFsdWUsIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgY3VycmVudFBsYXRmb3JtID0gYnJvd3Nlci5tYWMgPyBcIm1hY1wiIDogYnJvd3Nlci53aW5kb3dzID8gXCJ3aW5cIiA6IGJyb3dzZXIubGludXggPyBcImxpbnV4XCIgOiBcImtleVwiO1xuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lLCBwbGF0Zm9ybSkge1xuICAgIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbGV0IHJlc3VsdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChyZXN1bHQgPT0gXCJTcGFjZVwiKVxuICAgICAgICByZXN1bHQgPSBcIiBcIjtcbiAgICBsZXQgYWx0LCBjdHJsLCBzaGlmdCwgbWV0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBhbHQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybSA9PSBcIm1hY1wiKVxuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0cmwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCk7XG4gICAgfVxuICAgIGlmIChhbHQpXG4gICAgICAgIHJlc3VsdCA9IFwiQWx0LVwiICsgcmVzdWx0O1xuICAgIGlmIChjdHJsKVxuICAgICAgICByZXN1bHQgPSBcIkN0cmwtXCIgKyByZXN1bHQ7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIHJlc3VsdCA9IFwiTWV0YS1cIiArIHJlc3VsdDtcbiAgICBpZiAoc2hpZnQpXG4gICAgICAgIHJlc3VsdCA9IFwiU2hpZnQtXCIgKyByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVycyhuYW1lLCBldmVudCwgc2hpZnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICE9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSlcbiAgICAgICAgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lO1xuICAgIHJldHVybiBuYW1lO1xufVxuY29uc3QgaGFuZGxlS2V5RXZlbnRzID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuZG9tRXZlbnRIYW5kbGVycyh7XG4gICAga2V5ZG93bihldmVudCwgdmlldykge1xuICAgICAgICByZXR1cm4gcnVuSGFuZGxlcnMoZ2V0S2V5bWFwKHZpZXcuc3RhdGUpLCBldmVudCwgdmlldywgXCJlZGl0b3JcIik7XG4gICAgfVxufSk7XG4vKipcbkZhY2V0IHVzZWQgZm9yIHJlZ2lzdGVyaW5nIGtleW1hcHMuXG5cbllvdSBjYW4gYWRkIG11bHRpcGxlIGtleW1hcHMgdG8gYW4gZWRpdG9yLiBUaGVpciBwcmlvcml0aWVzXG5kZXRlcm1pbmUgdGhlaXIgcHJlY2VkZW5jZSAodGhlIG9uZXMgc3BlY2lmaWVkIGVhcmx5IG9yIHdpdGggaGlnaFxucHJpb3JpdHkgZ2V0IGNoZWNrZWQgZmlyc3QpLiBXaGVuIGEgaGFuZGxlciBoYXMgcmV0dXJuZWQgYHRydWVgXG5mb3IgYSBnaXZlbiBrZXksIG5vIGZ1cnRoZXIgaGFuZGxlcnMgYXJlIGNhbGxlZC5cbiovXG5jb25zdCBrZXltYXAgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgZW5hYmxlczogaGFuZGxlS2V5RXZlbnRzIH0pO1xuY29uc3QgS2V5bWFwcyA9IC8qQF9fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xuLy8gVGhpcyBpcyBoaWRkZW4gYmVoaW5kIGFuIGluZGlyZWN0aW9uLCByYXRoZXIgdGhhbiBkaXJlY3RseSBjb21wdXRlZFxuLy8gYnkgdGhlIGZhY2V0LCB0byBrZWVwIGludGVybmFsIHR5cGVzIG91dCBvZiB0aGUgZmFjZXQncyB0eXBlLlxuZnVuY3Rpb24gZ2V0S2V5bWFwKHN0YXRlKSB7XG4gICAgbGV0IGJpbmRpbmdzID0gc3RhdGUuZmFjZXQoa2V5bWFwKTtcbiAgICBsZXQgbWFwID0gS2V5bWFwcy5nZXQoYmluZGluZ3MpO1xuICAgIGlmICghbWFwKVxuICAgICAgICBLZXltYXBzLnNldChiaW5kaW5ncywgbWFwID0gYnVpbGRLZXltYXAoYmluZGluZ3MucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pKSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuUnVuIHRoZSBrZXkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBzY29wZS4gVGhlIGV2ZW50XG5vYmplY3Qgc2hvdWxkIGJlIGBcImtleWRvd25cImAgZXZlbnQuIFJldHVybnMgdHJ1ZSBpZiBhbnkgb2YgdGhlXG5oYW5kbGVycyBoYW5kbGVkIGl0LlxuKi9cbmZ1bmN0aW9uIHJ1blNjb3BlSGFuZGxlcnModmlldywgZXZlbnQsIHNjb3BlKSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJzKGdldEtleW1hcCh2aWV3LnN0YXRlKSwgZXZlbnQsIHZpZXcsIHNjb3BlKTtcbn1cbmxldCBzdG9yZWRQcmVmaXggPSBudWxsO1xuY29uc3QgUHJlZml4VGltZW91dCA9IDQwMDA7XG5mdW5jdGlvbiBidWlsZEtleW1hcChiaW5kaW5ncywgcGxhdGZvcm0gPSBjdXJyZW50UGxhdGZvcm0pIHtcbiAgICBsZXQgYm91bmQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBpc1ByZWZpeCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IGNoZWNrUHJlZml4ID0gKG5hbWUsIGlzKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gaXNQcmVmaXhbbmFtZV07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG51bGwpXG4gICAgICAgICAgICBpc1ByZWZpeFtuYW1lXSA9IGlzO1xuICAgICAgICBlbHNlIGlmIChjdXJyZW50ICE9IGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBuYW1lICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gICAgfTtcbiAgICBsZXQgYWRkID0gKHNjb3BlLCBrZXksIGNvbW1hbmQsIHByZXZlbnREZWZhdWx0KSA9PiB7XG4gICAgICAgIGxldCBzY29wZU9iaiA9IGJvdW5kW3Njb3BlXSB8fCAoYm91bmRbc2NvcGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGtleS5zcGxpdCgvICg/ISQpLykubWFwKGsgPT4gbm9ybWFsaXplS2V5TmFtZShrLCBwbGF0Zm9ybSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJlZml4ID0gcGFydHMuc2xpY2UoMCwgaSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICBjaGVja1ByZWZpeChwcmVmaXgsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzY29wZU9ialtwcmVmaXhdKVxuICAgICAgICAgICAgICAgIHNjb3BlT2JqW3ByZWZpeF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kczogWyh2aWV3KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91ck9iaiA9IHN0b3JlZFByZWZpeCA9IHsgdmlldywgcHJlZml4LCBzY29wZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBpZiAoc3RvcmVkUHJlZml4ID09IG91ck9iailcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUHJlZml4ID0gbnVsbDsgfSwgUHJlZml4VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwgPSBwYXJ0cy5qb2luKFwiIFwiKTtcbiAgICAgICAgY2hlY2tQcmVmaXgoZnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgYmluZGluZyA9IHNjb3BlT2JqW2Z1bGxdIHx8IChzY29wZU9ialtmdWxsXSA9IHsgcHJldmVudERlZmF1bHQ6IGZhbHNlLCBjb21tYW5kczogW10gfSk7XG4gICAgICAgIGJpbmRpbmcuY29tbWFuZHMucHVzaChjb21tYW5kKTtcbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KVxuICAgICAgICAgICAgYmluZGluZy5wcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfTtcbiAgICBmb3IgKGxldCBiIG9mIGJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBuYW1lID0gYltwbGF0Zm9ybV0gfHwgYi5rZXk7XG4gICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBzY29wZSBvZiBiLnNjb3BlID8gYi5zY29wZS5zcGxpdChcIiBcIikgOiBbXCJlZGl0b3JcIl0pIHtcbiAgICAgICAgICAgIGFkZChzY29wZSwgbmFtZSwgYi5ydW4sIGIucHJldmVudERlZmF1bHQpO1xuICAgICAgICAgICAgaWYgKGIuc2hpZnQpXG4gICAgICAgICAgICAgICAgYWRkKHNjb3BlLCBcIlNoaWZ0LVwiICsgbmFtZSwgYi5zaGlmdCwgYi5wcmV2ZW50RGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kO1xufVxuZnVuY3Rpb24gcnVuSGFuZGxlcnMobWFwLCBldmVudCwgdmlldywgc2NvcGUpIHtcbiAgICBsZXQgbmFtZSA9IGtleU5hbWUoZXZlbnQpLCBpc0NoYXIgPSBuYW1lLmxlbmd0aCA9PSAxICYmIG5hbWUgIT0gXCIgXCI7XG4gICAgbGV0IHByZWZpeCA9IFwiXCIsIGZhbGx0aHJvdWdoID0gZmFsc2U7XG4gICAgaWYgKHN0b3JlZFByZWZpeCAmJiBzdG9yZWRQcmVmaXgudmlldyA9PSB2aWV3ICYmIHN0b3JlZFByZWZpeC5zY29wZSA9PSBzY29wZSkge1xuICAgICAgICBwcmVmaXggPSBzdG9yZWRQcmVmaXgucHJlZml4ICsgXCIgXCI7XG4gICAgICAgIGlmIChmYWxsdGhyb3VnaCA9IG1vZGlmaWVyQ29kZXMuaW5kZXhPZihldmVudC5rZXlDb2RlKSA8IDApXG4gICAgICAgICAgICBzdG9yZWRQcmVmaXggPSBudWxsO1xuICAgIH1cbiAgICBsZXQgcnVuRm9yID0gKGJpbmRpbmcpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNtZCBvZiBiaW5kaW5nLmNvbW1hbmRzKVxuICAgICAgICAgICAgICAgIGlmIChjbWQodmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJldmVudERlZmF1bHQpXG4gICAgICAgICAgICAgICAgZmFsbHRocm91Z2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGxldCBzY29wZU9iaiA9IG1hcFtzY29wZV0sIGJhc2VOYW1lO1xuICAgIGlmIChzY29wZU9iaikge1xuICAgICAgICBpZiAocnVuRm9yKHNjb3BlT2JqW3ByZWZpeCArIG1vZGlmaWVycyhuYW1lLCBldmVudCwgIWlzQ2hhcildKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoaXNDaGFyICYmIChldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgJiZcbiAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKGJhc2VOYW1lLCBldmVudCwgdHJ1ZSldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NoYXIgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChydW5Gb3Ioc2NvcGVPYmpbcHJlZml4ICsgbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCB0cnVlKV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxsdGhyb3VnaDtcbn1cblxuY29uc3QgQ2FuSGlkZVByaW1hcnkgPSAhYnJvd3Nlci5pb3M7IC8vIEZJWE1FIHRlc3QgSUVcbmNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBjdXJzb3JCbGlua1JhdGU6IDEyMDAsXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgY3Vyc29yQmxpbmtSYXRlOiAoYSwgYikgPT4gTWF0aC5taW4oYSwgYiksXG4gICAgICAgICAgICBkcmF3UmFuZ2VDdXJzb3I6IChhLCBiKSA9PiBhIHx8IGJcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaGlkZXMgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2VsZWN0aW9uIGFuZFxuY3Vyc29yLCByZXBsYWNpbmcgdGhlIHNlbGVjdGlvbiB3aXRoIGEgYmFja2dyb3VuZCBiZWhpbmQgdGhlIHRleHRcbih3aXRoIHRoZSBgY20tc2VsZWN0aW9uQmFja2dyb3VuZGAgY2xhc3MpLCBhbmQgdGhlXG5jdXJzb3JzIHdpdGggZWxlbWVudHMgb3ZlcmxhaWQgb3ZlciB0aGUgY29kZSAodXNpbmdcbmBjbS1jdXJzb3ItcHJpbWFyeWAgYW5kIGBjbS1jdXJzb3Itc2Vjb25kYXJ5YCkuXG5cblRoaXMgYWxsb3dzIHRoZSBlZGl0b3IgdG8gZGlzcGxheSBzZWNvbmRhcnkgc2VsZWN0aW9uIHJhbmdlcywgYW5kXG50ZW5kcyB0byBwcm9kdWNlIGEgdHlwZSBvZiBzZWxlY3Rpb24gbW9yZSBpbiBsaW5lIHdpdGggdGhhdCB1c2Vyc1xuZXhwZWN0IGluIGEgdGV4dCBlZGl0b3IgKHRoZSBuYXRpdmUgc2VsZWN0aW9uIHN0eWxpbmcgd2lsbCBvZnRlblxubGVhdmUgZ2FwcyBiZXR3ZWVuIGxpbmVzIGFuZCB3b24ndCBmaWxsIHRoZSBob3Jpem9udGFsIHNwYWNlIGFmdGVyXG5hIGxpbmUgd2hlbiB0aGUgc2VsZWN0aW9uIGNvbnRpbnVlcyBwYXN0IGl0KS5cblxuSXQgZG9lcyBoYXZlIGEgcGVyZm9ybWFuY2UgY29zdCwgaW4gdGhhdCBpdCByZXF1aXJlcyBhbiBleHRyYSBET01cbmxheW91dCBjeWNsZSBmb3IgbWFueSB1cGRhdGVzICh0aGUgc2VsZWN0aW9uIGlzIGRyYXduIGJhc2VkIG9uIERPTVxubGF5b3V0IGluZm9ybWF0aW9uIHRoYXQncyBvbmx5IGF2YWlsYWJsZSBhZnRlciBsYXlpbmcgb3V0IHRoZVxuY29udGVudCkuXG4qL1xuZnVuY3Rpb24gZHJhd1NlbGVjdGlvbihjb25maWcgPSB7fSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZy5vZihjb25maWcpLFxuICAgICAgICBkcmF3U2VsZWN0aW9uUGx1Z2luLFxuICAgICAgICBoaWRlTmF0aXZlU2VsZWN0aW9uXG4gICAgXTtcbn1cbmNsYXNzIFBpZWNlIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQsIGNsYXNzTmFtZSkge1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnRvcCA9IHRvcDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBlbHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgIHRoaXMuYWRqdXN0KGVsdCk7XG4gICAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuICAgIGFkanVzdChlbHQpIHtcbiAgICAgICAgZWx0LnN0eWxlLmxlZnQgPSB0aGlzLmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS50b3AgPSB0aGlzLnRvcCArIFwicHhcIjtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPj0gMClcbiAgICAgICAgICAgIGVsdC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICB9XG4gICAgZXEocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0ID09IHAubGVmdCAmJiB0aGlzLnRvcCA9PSBwLnRvcCAmJiB0aGlzLndpZHRoID09IHAud2lkdGggJiYgdGhpcy5oZWlnaHQgPT0gcC5oZWlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID09IHAuY2xhc3NOYW1lO1xuICAgIH1cbn1cbmNvbnN0IGRyYXdTZWxlY3Rpb25QbHVnaW4gPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5yYW5nZVBpZWNlcyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnNvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRQb3MuYmluZCh0aGlzKSwgd3JpdGU6IHRoaXMuZHJhd1NlbC5iaW5kKHRoaXMpIH07XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIgPSB2aWV3LnNjcm9sbERPTS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5jbGFzc05hbWUgPSBcImNtLXNlbGVjdGlvbkxheWVyXCI7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTGF5ZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyID0gdmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuY2xhc3NOYW1lID0gXCJjbS1jdXJzb3JMYXllclwiO1xuICAgICAgICB0aGlzLmN1cnNvckxheWVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLm1lYXN1cmVSZXEpO1xuICAgICAgICB0aGlzLnNldEJsaW5rUmF0ZSgpO1xuICAgIH1cbiAgICBzZXRCbGlua1JhdGUoKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIuc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKS5jdXJzb3JCbGlua1JhdGUgKyBcIm1zXCI7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGNvbmZDaGFuZ2VkID0gdXBkYXRlLnN0YXJ0U3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLmdlb21ldHJ5Q2hhbmdlZCB8fCB1cGRhdGUudmlld3BvcnRDaGFuZ2VkKVxuICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIGlmICh1cGRhdGUudHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuc2Nyb2xsSW50b1ZpZXcpKVxuICAgICAgICAgICAgdGhpcy5jdXJzb3JMYXllci5zdHlsZS5hbmltYXRpb25OYW1lID0gdGhpcy5jdXJzb3JMYXllci5zdHlsZS5hbmltYXRpb25OYW1lID09IFwiY20tYmxpbmtcIiA/IFwiY20tYmxpbmsyXCIgOiBcImNtLWJsaW5rXCI7XG4gICAgICAgIGlmIChjb25mQ2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuc2V0QmxpbmtSYXRlKCk7XG4gICAgfVxuICAgIHJlYWRQb3MoKSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzLnZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChzZWxlY3Rpb25Db25maWcpO1xuICAgICAgICBsZXQgcmFuZ2VQaWVjZXMgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLm1hcChyID0+IHIuZW1wdHkgPyBbXSA6IG1lYXN1cmVSYW5nZSh0aGlzLnZpZXcsIHIpKS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKTtcbiAgICAgICAgbGV0IGN1cnNvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgciBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgcHJpbSA9IHIgPT0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICBpZiAoci5lbXB0eSA/ICFwcmltIHx8IENhbkhpZGVQcmltYXJ5IDogY29uZi5kcmF3UmFuZ2VDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGllY2UgPSBtZWFzdXJlQ3Vyc29yKHRoaXMudmlldywgciwgcHJpbSk7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3JzLnB1c2gocGllY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJhbmdlUGllY2VzLCBjdXJzb3JzIH07XG4gICAgfVxuICAgIGRyYXdTZWwoeyByYW5nZVBpZWNlcywgY3Vyc29ycyB9KSB7XG4gICAgICAgIGlmIChyYW5nZVBpZWNlcy5sZW5ndGggIT0gdGhpcy5yYW5nZVBpZWNlcy5sZW5ndGggfHwgcmFuZ2VQaWVjZXMuc29tZSgocCwgaSkgPT4gIXAuZXEodGhpcy5yYW5nZVBpZWNlc1tpXSkpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkxheWVyLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAobGV0IHAgb2YgcmFuZ2VQaWVjZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5hcHBlbmRDaGlsZChwLmRyYXcoKSk7XG4gICAgICAgICAgICB0aGlzLnJhbmdlUGllY2VzID0gcmFuZ2VQaWVjZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnNvcnMubGVuZ3RoICE9IHRoaXMuY3Vyc29ycy5sZW5ndGggfHwgY3Vyc29ycy5zb21lKChjLCBpKSA9PiAhYy5lcSh0aGlzLmN1cnNvcnNbaV0pKSkge1xuICAgICAgICAgICAgbGV0IG9sZEN1cnNvcnMgPSB0aGlzLmN1cnNvckxheWVyLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKG9sZEN1cnNvcnMubGVuZ3RoICE9PSBjdXJzb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yTGF5ZXIudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjdXJzb3JzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvckxheWVyLmFwcGVuZENoaWxkKGMuZHJhdygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvcnMuZm9yRWFjaCgoYywgaWR4KSA9PiBjLmFkanVzdChvbGRDdXJzb3JzW2lkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3Vyc29ycyA9IGN1cnNvcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25MYXllci5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jdXJzb3JMYXllci5yZW1vdmUoKTtcbiAgICB9XG59KTtcbmNvbnN0IHRoZW1lU3BlYyA9IHtcbiAgICBcIi5jbS1saW5lXCI6IHtcbiAgICAgICAgXCImIDo6c2VsZWN0aW9uXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50ICFpbXBvcnRhbnRcIiB9LFxuICAgICAgICBcIiY6OnNlbGVjdGlvblwiOiB7IGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudCAhaW1wb3J0YW50XCIgfVxuICAgIH1cbn07XG5pZiAoQ2FuSGlkZVByaW1hcnkpXG4gICAgdGhlbWVTcGVjW1wiLmNtLWxpbmVcIl0uY2FyZXRDb2xvciA9IFwidHJhbnNwYXJlbnQgIWltcG9ydGFudFwiO1xuY29uc3QgaGlkZU5hdGl2ZVNlbGVjdGlvbiA9IC8qQF9fUFVSRV9fKi9QcmVjLmhpZ2hlc3QoLypAX19QVVJFX18qL0VkaXRvclZpZXcudGhlbWUodGhlbWVTcGVjKSk7XG5mdW5jdGlvbiBnZXRCYXNlKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuc2Nyb2xsRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBsZWZ0ID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0IC0gdmlldy5zY3JvbGxET00uY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIHsgbGVmdDogbGVmdCAtIHZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQsIHRvcDogcmVjdC50b3AgLSB2aWV3LnNjcm9sbERPTS5zY3JvbGxUb3AgfTtcbn1cbmZ1bmN0aW9uIHdyYXBwZWRMaW5lKHZpZXcsIHBvcywgaW5zaWRlKSB7XG4gICAgbGV0IHJhbmdlID0gRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihwb3MpO1xuICAgIHJldHVybiB7IGZyb206IE1hdGgubWF4KGluc2lkZS5mcm9tLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgZmFsc2UsIHRydWUpLmZyb20pLFxuICAgICAgICB0bzogTWF0aC5taW4oaW5zaWRlLnRvLCB2aWV3Lm1vdmVUb0xpbmVCb3VuZGFyeShyYW5nZSwgdHJ1ZSwgdHJ1ZSkuZnJvbSksXG4gICAgICAgIHR5cGU6IEJsb2NrVHlwZS5UZXh0IH07XG59XG5mdW5jdGlvbiBibG9ja0F0KHZpZXcsIHBvcykge1xuICAgIGxldCBsaW5lID0gdmlldy5saW5lQmxvY2tBdChwb3MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxpbmUudHlwZSkpXG4gICAgICAgIGZvciAobGV0IGwgb2YgbGluZS50eXBlKSB7XG4gICAgICAgICAgICBpZiAobC50byA+IHBvcyB8fCBsLnRvID09IHBvcyAmJiAobC50byA9PSBsaW5lLnRvIHx8IGwudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVSYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGlmIChyYW5nZS50byA8PSB2aWV3LnZpZXdwb3J0LmZyb20gfHwgcmFuZ2UuZnJvbSA+PSB2aWV3LnZpZXdwb3J0LnRvKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGZyb20gPSBNYXRoLm1heChyYW5nZS5mcm9tLCB2aWV3LnZpZXdwb3J0LmZyb20pLCB0byA9IE1hdGgubWluKHJhbmdlLnRvLCB2aWV3LnZpZXdwb3J0LnRvKTtcbiAgICBsZXQgbHRyID0gdmlldy50ZXh0RGlyZWN0aW9uID09IERpcmVjdGlvbi5MVFI7XG4gICAgbGV0IGNvbnRlbnQgPSB2aWV3LmNvbnRlbnRET00sIGNvbnRlbnRSZWN0ID0gY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYmFzZSA9IGdldEJhc2Uodmlldyk7XG4gICAgbGV0IGxpbmVTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgbGV0IGxlZnRTaWRlID0gY29udGVudFJlY3QubGVmdCArIHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nTGVmdCkgKyBNYXRoLm1pbigwLCBwYXJzZUludChsaW5lU3R5bGUudGV4dEluZGVudCkpO1xuICAgIGxldCByaWdodFNpZGUgPSBjb250ZW50UmVjdC5yaWdodCAtIHBhcnNlSW50KGxpbmVTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgIGxldCBzdGFydEJsb2NrID0gYmxvY2tBdCh2aWV3LCBmcm9tKSwgZW5kQmxvY2sgPSBibG9ja0F0KHZpZXcsIHRvKTtcbiAgICBsZXQgdmlzdWFsU3RhcnQgPSBzdGFydEJsb2NrLnR5cGUgPT0gQmxvY2tUeXBlLlRleHQgPyBzdGFydEJsb2NrIDogbnVsbDtcbiAgICBsZXQgdmlzdWFsRW5kID0gZW5kQmxvY2sudHlwZSA9PSBCbG9ja1R5cGUuVGV4dCA/IGVuZEJsb2NrIDogbnVsbDtcbiAgICBpZiAodmlldy5saW5lV3JhcHBpbmcpIHtcbiAgICAgICAgaWYgKHZpc3VhbFN0YXJ0KVxuICAgICAgICAgICAgdmlzdWFsU3RhcnQgPSB3cmFwcGVkTGluZSh2aWV3LCBmcm9tLCB2aXN1YWxTdGFydCk7XG4gICAgICAgIGlmICh2aXN1YWxFbmQpXG4gICAgICAgICAgICB2aXN1YWxFbmQgPSB3cmFwcGVkTGluZSh2aWV3LCB0bywgdmlzdWFsRW5kKTtcbiAgICB9XG4gICAgaWYgKHZpc3VhbFN0YXJ0ICYmIHZpc3VhbEVuZCAmJiB2aXN1YWxTdGFydC5mcm9tID09IHZpc3VhbEVuZC5mcm9tKSB7XG4gICAgICAgIHJldHVybiBwaWVjZXMoZHJhd0ZvckxpbmUocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHZpc3VhbFN0YXJ0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgdG9wID0gdmlzdWFsU3RhcnQgPyBkcmF3Rm9yTGluZShyYW5nZS5mcm9tLCBudWxsLCB2aXN1YWxTdGFydCkgOiBkcmF3Rm9yV2lkZ2V0KHN0YXJ0QmxvY2ssIGZhbHNlKTtcbiAgICAgICAgbGV0IGJvdHRvbSA9IHZpc3VhbEVuZCA/IGRyYXdGb3JMaW5lKG51bGwsIHJhbmdlLnRvLCB2aXN1YWxFbmQpIDogZHJhd0ZvcldpZGdldChlbmRCbG9jaywgdHJ1ZSk7XG4gICAgICAgIGxldCBiZXR3ZWVuID0gW107XG4gICAgICAgIGlmICgodmlzdWFsU3RhcnQgfHwgc3RhcnRCbG9jaykudG8gPCAodmlzdWFsRW5kIHx8IGVuZEJsb2NrKS5mcm9tIC0gMSlcbiAgICAgICAgICAgIGJldHdlZW4ucHVzaChwaWVjZShsZWZ0U2lkZSwgdG9wLmJvdHRvbSwgcmlnaHRTaWRlLCBib3R0b20udG9wKSk7XG4gICAgICAgIGVsc2UgaWYgKHRvcC5ib3R0b20gPCBib3R0b20udG9wICYmIHZpZXcuZWxlbWVudEF0SGVpZ2h0KCh0b3AuYm90dG9tICsgYm90dG9tLnRvcCkgLyAyKS50eXBlID09IEJsb2NrVHlwZS5UZXh0KVxuICAgICAgICAgICAgdG9wLmJvdHRvbSA9IGJvdHRvbS50b3AgPSAodG9wLmJvdHRvbSArIGJvdHRvbS50b3ApIC8gMjtcbiAgICAgICAgcmV0dXJuIHBpZWNlcyh0b3ApLmNvbmNhdChiZXR3ZWVuKS5jb25jYXQocGllY2VzKGJvdHRvbSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWVjZShsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaWVjZShsZWZ0IC0gYmFzZS5sZWZ0LCB0b3AgLSBiYXNlLnRvcCAtIDAuMDEgLyogRXBzaWxvbiAqLywgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3AgKyAwLjAxIC8qIEVwc2lsb24gKi8sIFwiY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGllY2VzKHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfSkge1xuICAgICAgICBsZXQgcGllY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG9yaXpvbnRhbC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHBpZWNlKGhvcml6b250YWxbaV0sIHRvcCwgaG9yaXpvbnRhbFtpICsgMV0sIGJvdHRvbSkpO1xuICAgICAgICByZXR1cm4gcGllY2VzO1xuICAgIH1cbiAgICAvLyBHZXRzIHBhc3NlZCBmcm9tL3RvIGluIGxpbmUtbG9jYWwgcG9zaXRpb25zXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUoZnJvbSwgdG8sIGxpbmUpIHtcbiAgICAgICAgbGV0IHRvcCA9IDFlOSwgYm90dG9tID0gLTFlOSwgaG9yaXpvbnRhbCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBhZGRTcGFuKGZyb20sIGZyb21PcGVuLCB0bywgdG9PcGVuLCBkaXIpIHtcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgMi8tMiBpcyBhIGtsdWRnZSB0byBmb3JjZSB0aGUgdmlldyB0byByZXR1cm5cbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9uIHRoZSBwcm9wZXIgc2lkZSBvZiBibG9jayB3aWRnZXRzLCBzaW5jZVxuICAgICAgICAgICAgLy8gbm9ybWFsaXppbmcgdGhlIHNpZGUgdGhlcmUsIHRob3VnaCBhcHByb3ByaWF0ZSBmb3IgbW9zdFxuICAgICAgICAgICAgLy8gY29vcmRzQXRQb3MgcXVlcmllcywgd291bGQgYnJlYWsgc2VsZWN0aW9uIGRyYXdpbmcuXG4gICAgICAgICAgICBsZXQgZnJvbUNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MoZnJvbSwgKGZyb20gPT0gbGluZS50byA/IC0yIDogMikpO1xuICAgICAgICAgICAgbGV0IHRvQ29vcmRzID0gdmlldy5jb29yZHNBdFBvcyh0bywgKHRvID09IGxpbmUuZnJvbSA/IDIgOiAtMikpO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5taW4oZnJvbUNvb3Jkcy50b3AsIHRvQ29vcmRzLnRvcCwgdG9wKTtcbiAgICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGZyb21Db29yZHMuYm90dG9tLCB0b0Nvb3Jkcy5ib3R0b20sIGJvdHRvbSk7XG4gICAgICAgICAgICBpZiAoZGlyID09IERpcmVjdGlvbi5MVFIpXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbC5wdXNoKGx0ciAmJiBmcm9tT3BlbiA/IGxlZnRTaWRlIDogZnJvbUNvb3Jkcy5sZWZ0LCBsdHIgJiYgdG9PcGVuID8gcmlnaHRTaWRlIDogdG9Db29yZHMucmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhvcml6b250YWwucHVzaCghbHRyICYmIHRvT3BlbiA/IGxlZnRTaWRlIDogdG9Db29yZHMubGVmdCwgIWx0ciAmJiBmcm9tT3BlbiA/IHJpZ2h0U2lkZSA6IGZyb21Db29yZHMucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydCA9IGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IGxpbmUuZnJvbSwgZW5kID0gdG8gIT09IG51bGwgJiYgdG8gIT09IHZvaWQgMCA/IHRvIDogbGluZS50bztcbiAgICAgICAgLy8gU3BsaXQgdGhlIHJhbmdlIGJ5IHZpc2libGUgcmFuZ2UgYW5kIGRvY3VtZW50IGxpbmVcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpXG4gICAgICAgICAgICBpZiAoci50byA+IHN0YXJ0ICYmIHIuZnJvbSA8IGVuZCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IE1hdGgubWF4KHIuZnJvbSwgc3RhcnQpLCBlbmRQb3MgPSBNYXRoLm1pbihyLnRvLCBlbmQpOzspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvY0xpbmUgPSB2aWV3LnN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgc3BhbiBvZiB2aWV3LmJpZGlTcGFucyhkb2NMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYW5Gcm9tID0gc3Bhbi5mcm9tICsgZG9jTGluZS5mcm9tLCBzcGFuVG8gPSBzcGFuLnRvICsgZG9jTGluZS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5Gcm9tID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFuVG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkU3BhbihNYXRoLm1heChzcGFuRnJvbSwgcG9zKSwgZnJvbSA9PSBudWxsICYmIHNwYW5Gcm9tIDw9IHN0YXJ0LCBNYXRoLm1pbihzcGFuVG8sIGVuZFBvcyksIHRvID09IG51bGwgJiYgc3BhblRvID49IGVuZCwgc3Bhbi5kaXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IGRvY0xpbmUudG8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGVuZFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGhvcml6b250YWwubGVuZ3RoID09IDApXG4gICAgICAgICAgICBhZGRTcGFuKHN0YXJ0LCBmcm9tID09IG51bGwsIGVuZCwgdG8gPT0gbnVsbCwgdmlldy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCBib3R0b20sIGhvcml6b250YWwgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd0ZvcldpZGdldChibG9jaywgdG9wKSB7XG4gICAgICAgIGxldCB5ID0gY29udGVudFJlY3QudG9wICsgKHRvcCA/IGJsb2NrLnRvcCA6IGJsb2NrLmJvdHRvbSk7XG4gICAgICAgIHJldHVybiB7IHRvcDogeSwgYm90dG9tOiB5LCBob3Jpem9udGFsOiBbXSB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lYXN1cmVDdXJzb3IodmlldywgY3Vyc29yLCBwcmltYXJ5KSB7XG4gICAgbGV0IHBvcyA9IHZpZXcuY29vcmRzQXRQb3MoY3Vyc29yLmhlYWQsIGN1cnNvci5hc3NvYyB8fCAxKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGJhc2UgPSBnZXRCYXNlKHZpZXcpO1xuICAgIHJldHVybiBuZXcgUGllY2UocG9zLmxlZnQgLSBiYXNlLmxlZnQsIHBvcy50b3AgLSBiYXNlLnRvcCwgLTEsIHBvcy5ib3R0b20gLSBwb3MudG9wLCBwcmltYXJ5ID8gXCJjbS1jdXJzb3IgY20tY3Vyc29yLXByaW1hcnlcIiA6IFwiY20tY3Vyc29yIGNtLWN1cnNvci1zZWNvbmRhcnlcIik7XG59XG5cbmNvbnN0IHNldERyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKHtcbiAgICBtYXAocG9zLCBtYXBwaW5nKSB7IHJldHVybiBwb3MgPT0gbnVsbCA/IG51bGwgOiBtYXBwaW5nLm1hcFBvcyhwb3MpOyB9XG59KTtcbmNvbnN0IGRyb3BDdXJzb3JQb3MgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgdXBkYXRlKHBvcywgdHIpIHtcbiAgICAgICAgaWYgKHBvcyAhPSBudWxsKVxuICAgICAgICAgICAgcG9zID0gdHIuY2hhbmdlcy5tYXBQb3MocG9zKTtcbiAgICAgICAgcmV0dXJuIHRyLmVmZmVjdHMucmVkdWNlKChwb3MsIGUpID0+IGUuaXMoc2V0RHJvcEN1cnNvclBvcykgPyBlLnZhbHVlIDogcG9zLCBwb3MpO1xuICAgIH1cbn0pO1xuY29uc3QgZHJhd0Ryb3BDdXJzb3IgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1lYXN1cmVSZXEgPSB7IHJlYWQ6IHRoaXMucmVhZFBvcy5iaW5kKHRoaXMpLCB3cml0ZTogdGhpcy5kcmF3Q3Vyc29yLmJpbmQodGhpcykgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjdXJzb3JQb3MgPSB1cGRhdGUuc3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcyk7XG4gICAgICAgIGlmIChjdXJzb3JQb3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmN1cnNvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMudmlldy5zY3JvbGxET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IuY2xhc3NOYW1lID0gXCJjbS1kcm9wQ3Vyc29yXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZHJvcEN1cnNvclBvcykgIT0gY3Vyc29yUG9zIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5nZW9tZXRyeUNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZFBvcygpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKTtcbiAgICAgICAgbGV0IHJlY3QgPSBwb3MgIT0gbnVsbCAmJiB0aGlzLnZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKCFyZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBvdXRlciA9IHRoaXMudmlldy5zY3JvbGxET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgLSBvdXRlci5sZWZ0ICsgdGhpcy52aWV3LnNjcm9sbERPTS5zY3JvbGxMZWZ0LFxuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCAtIG91dGVyLnRvcCArIHRoaXMudmlldy5zY3JvbGxET00uc2Nyb2xsVG9wLFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRyYXdDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvcikge1xuICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBwb3MubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXCJweFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmhlaWdodCA9IHBvcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gXCItMTAwMDAwcHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJzb3IpXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgc2V0RHJvcFBvcyhwb3MpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5zdGF0ZS5maWVsZChkcm9wQ3Vyc29yUG9zKSAhPSBwb3MpXG4gICAgICAgICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBzZXREcm9wQ3Vyc29yUG9zLm9mKHBvcykgfSk7XG4gICAgfVxufSwge1xuICAgIGV2ZW50SGFuZGxlcnM6IHtcbiAgICAgICAgZHJhZ292ZXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJvcFBvcyh0aGlzLnZpZXcucG9zQXRDb29yZHMoeyB4OiBldmVudC5jbGllbnRYLCB5OiBldmVudC5jbGllbnRZIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2xlYXZlKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09IHRoaXMudmlldy5jb250ZW50RE9NIHx8ICF0aGlzLnZpZXcuY29udGVudERPTS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdlbmQoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3AoKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyb3BQb3MobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbi8qKlxuRHJhd3MgYSBjdXJzb3IgYXQgdGhlIGN1cnJlbnQgZHJvcCBwb3NpdGlvbiB3aGVuIHNvbWV0aGluZyBpc1xuZHJhZ2dlZCBvdmVyIHRoZSBlZGl0b3IuXG4qL1xuZnVuY3Rpb24gZHJvcEN1cnNvcigpIHtcbiAgICByZXR1cm4gW2Ryb3BDdXJzb3JQb3MsIGRyYXdEcm9wQ3Vyc29yXTtcbn1cblxuZnVuY3Rpb24gaXRlck1hdGNoZXMoZG9jLCByZSwgZnJvbSwgdG8sIGYpIHtcbiAgICByZS5sYXN0SW5kZXggPSAwO1xuICAgIGZvciAobGV0IGN1cnNvciA9IGRvYy5pdGVyUmFuZ2UoZnJvbSwgdG8pLCBwb3MgPSBmcm9tLCBtOyAhY3Vyc29yLm5leHQoKS5kb25lOyBwb3MgKz0gY3Vyc29yLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIWN1cnNvci5saW5lQnJlYWspXG4gICAgICAgICAgICB3aGlsZSAobSA9IHJlLmV4ZWMoY3Vyc29yLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBmKHBvcyArIG0uaW5kZXgsIHBvcyArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCwgbSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWF0Y2hSYW5nZXModmlldywgbWF4TGVuZ3RoKSB7XG4gICAgbGV0IHZpc2libGUgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKHZpc2libGUubGVuZ3RoID09IDEgJiYgdmlzaWJsZVswXS5mcm9tID09IHZpZXcudmlld3BvcnQuZnJvbSAmJlxuICAgICAgICB2aXNpYmxlWzBdLnRvID09IHZpZXcudmlld3BvcnQudG8pXG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgdmlzaWJsZSkge1xuICAgICAgICBmcm9tID0gTWF0aC5tYXgodmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLmZyb20sIGZyb20gLSBtYXhMZW5ndGgpO1xuICAgICAgICB0byA9IE1hdGgubWluKHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG8sIHRvICsgbWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA+PSBmcm9tKVxuICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS50byA9IHRvO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5IZWxwZXIgY2xhc3MgdXNlZCB0byBtYWtlIGl0IGVhc2llciB0byBtYWludGFpbiBkZWNvcmF0aW9ucyBvblxudmlzaWJsZSBjb2RlIHRoYXQgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi4gVG8gYmUgdXNlZFxuaW4gYSBbdmlldyBwbHVnaW5dKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5WaWV3UGx1Z2luKS4gSW5zdGFuY2VzIG9mIHRoaXMgb2JqZWN0XG5yZXByZXNlbnQgYSBtYXRjaGluZyBjb25maWd1cmF0aW9uLlxuKi9cbmNsYXNzIE1hdGNoRGVjb3JhdG9yIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBkZWNvcmF0b3IuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgbGV0IHsgcmVnZXhwLCBkZWNvcmF0aW9uLCBib3VuZGFyeSwgbWF4TGVuZ3RoID0gMTAwMCB9ID0gY29uZmlnO1xuICAgICAgICBpZiAoIXJlZ2V4cC5nbG9iYWwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICAgICAgdGhpcy5yZWdleHAgPSByZWdleHA7XG4gICAgICAgIHRoaXMuZ2V0RGVjbyA9IHR5cGVvZiBkZWNvcmF0aW9uID09IFwiZnVuY3Rpb25cIiA/IGRlY29yYXRpb24gOiAoKSA9PiBkZWNvcmF0aW9uO1xuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wdXRlIHRoZSBmdWxsIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgbWF0Y2hlcyBpbiB0aGUgZ2l2ZW5cbiAgICB2aWV3J3Mgdmlld3BvcnQuIFlvdSdsbCB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIGluaXRpYWxpemluZyB5b3VyXG4gICAgcGx1Z2luLlxuICAgICovXG4gICAgY3JlYXRlRGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBidWlsZCA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1hdGNoUmFuZ2VzKHZpZXcsIHRoaXMubWF4TGVuZ3RoKSlcbiAgICAgICAgICAgIGl0ZXJNYXRjaGVzKHZpZXcuc3RhdGUuZG9jLCB0aGlzLnJlZ2V4cCwgZnJvbSwgdG8sIChhLCBiLCBtKSA9PiBidWlsZC5hZGQoYSwgYiwgdGhpcy5nZXREZWNvKG0sIHZpZXcsIGEpKSk7XG4gICAgICAgIHJldHVybiBidWlsZC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIGEgc2V0IG9mIGRlY29yYXRpb25zIGZvciBhIHZpZXcgdXBkYXRlLiBgZGVjb2AgX211c3RfIGJlXG4gICAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBwcm9kdWNlZCBieSBfdGhpc18gYE1hdGNoRGVjb3JhdG9yYCBmb3JcbiAgICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAqL1xuICAgIHVwZGF0ZURlY28odXBkYXRlLCBkZWNvKSB7XG4gICAgICAgIGxldCBjaGFuZ2VGcm9tID0gMWU5LCBjaGFuZ2VUbyA9IC0xO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQpXG4gICAgICAgICAgICB1cGRhdGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygoX2YsIF90LCBmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0byA+IHVwZGF0ZS52aWV3LnZpZXdwb3J0LmZyb20gJiYgZnJvbSA8IHVwZGF0ZS52aWV3LnZpZXdwb3J0LnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUZyb20gPSBNYXRoLm1pbihmcm9tLCBjaGFuZ2VGcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlVG8gPSBNYXRoLm1heCh0bywgY2hhbmdlVG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAodXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBjaGFuZ2VUbyAtIGNoYW5nZUZyb20gPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGVjbyh1cGRhdGUudmlldyk7XG4gICAgICAgIGlmIChjaGFuZ2VUbyA+IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUmFuZ2UodXBkYXRlLnZpZXcsIGRlY28ubWFwKHVwZGF0ZS5jaGFuZ2VzKSwgY2hhbmdlRnJvbSwgY2hhbmdlVG8pO1xuICAgICAgICByZXR1cm4gZGVjbztcbiAgICB9XG4gICAgdXBkYXRlUmFuZ2UodmlldywgZGVjbywgdXBkYXRlRnJvbSwgdXBkYXRlVG8pIHtcbiAgICAgICAgZm9yIChsZXQgciBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoci5mcm9tLCB1cGRhdGVGcm9tKSwgdG8gPSBNYXRoLm1pbihyLnRvLCB1cGRhdGVUbyk7XG4gICAgICAgICAgICBpZiAodG8gPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb21MaW5lID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KGZyb20pLCB0b0xpbmUgPSBmcm9tTGluZS50byA8IHRvID8gdmlldy5zdGF0ZS5kb2MubGluZUF0KHRvKSA6IGZyb21MaW5lO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KHIuZnJvbSwgZnJvbUxpbmUuZnJvbSksIGVuZCA9IE1hdGgubWluKHIudG8sIHRvTGluZS50byk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGZyb20gPiBmcm9tTGluZS5mcm9tOyBmcm9tLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGZyb21MaW5lLnRleHRbZnJvbSAtIDEgLSBmcm9tTGluZS5mcm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyB0byA8IHRvTGluZS50bzsgdG8rKylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QodG9MaW5lLnRleHRbdG8gLSB0b0xpbmUuZnJvbV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBbXSwgbTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUxpbmUgPT0gdG9MaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVnZXhwLmxhc3RJbmRleCA9IHN0YXJ0IC0gZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChtID0gdGhpcy5yZWdleHAuZXhlYyhmcm9tTGluZS50ZXh0KSkgJiYgbS5pbmRleCA8IGVuZCAtIGZyb21MaW5lLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBtLmluZGV4ICsgZnJvbUxpbmUuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHRoaXMuZ2V0RGVjbyhtLCB2aWV3LCBwb3MpLnJhbmdlKHBvcywgcG9zICsgbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlck1hdGNoZXModmlldy5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBzdGFydCwgZW5kLCAoZnJvbSwgdG8sIG0pID0+IHJhbmdlcy5wdXNoKHRoaXMuZ2V0RGVjbyhtLCB2aWV3LCBmcm9tKS5yYW5nZShmcm9tLCB0bykpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjbyA9IGRlY28udXBkYXRlKHsgZmlsdGVyRnJvbTogc3RhcnQsIGZpbHRlclRvOiBlbmQsIGZpbHRlcjogKGZyb20sIHRvKSA9PiBmcm9tIDwgc3RhcnQgfHwgdG8gPiBlbmQsIGFkZDogcmFuZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvO1xuICAgIH1cbn1cblxuY29uc3QgVW5pY29kZVJlZ2V4cFN1cHBvcnQgPSAveC8udW5pY29kZSAhPSBudWxsID8gXCJndVwiIDogXCJnXCI7XG5jb25zdCBTcGVjaWFscyA9IC8qQF9fUFVSRV9fKi9uZXcgUmVnRXhwKFwiW1xcdTAwMDAtXFx1MDAwOFxcdTAwMGEtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYlxcdTIwMGVcXHUyMDBmXFx1MjAyOFxcdTIwMjlcXHUyMDJkXFx1MjAyZVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdXCIsIFVuaWNvZGVSZWdleHBTdXBwb3J0KTtcbmNvbnN0IE5hbWVzID0ge1xuICAgIDA6IFwibnVsbFwiLFxuICAgIDc6IFwiYmVsbFwiLFxuICAgIDg6IFwiYmFja3NwYWNlXCIsXG4gICAgMTA6IFwibmV3bGluZVwiLFxuICAgIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAgIDEzOiBcImNhcnJpYWdlIHJldHVyblwiLFxuICAgIDI3OiBcImVzY2FwZVwiLFxuICAgIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICAgIDgyMDQ6IFwiemVybyB3aWR0aCBub24tam9pbmVyXCIsXG4gICAgODIwNTogXCJ6ZXJvIHdpZHRoIGpvaW5lclwiLFxuICAgIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gICAgODIwNzogXCJyaWdodC10by1sZWZ0IG1hcmtcIixcbiAgICA4MjMyOiBcImxpbmUgc2VwYXJhdG9yXCIsXG4gICAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gICAgODIzODogXCJyaWdodC10by1sZWZ0IG92ZXJyaWRlXCIsXG4gICAgODIzMzogXCJwYXJhZ3JhcGggc2VwYXJhdG9yXCIsXG4gICAgNjUyNzk6IFwiemVybyB3aWR0aCBuby1icmVhayBzcGFjZVwiLFxuICAgIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IF9zdXBwb3J0c1RhYlNpemUgPSBudWxsO1xuZnVuY3Rpb24gc3VwcG9ydHNUYWJTaXplKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoX3N1cHBvcnRzVGFiU2l6ZSA9PSBudWxsICYmIHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG4gICAgICAgIF9zdXBwb3J0c1RhYlNpemUgPSAoKF9hID0gc3R5bGVzLnRhYlNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN0eWxlcy5Nb3pUYWJTaXplKSAhPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3N1cHBvcnRzVGFiU2l6ZSB8fCBmYWxzZTtcbn1cbmNvbnN0IHNwZWNpYWxDaGFyQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShjb25maWdzKSB7XG4gICAgICAgIGxldCBjb25maWcgPSBjb21iaW5lQ29uZmlnKGNvbmZpZ3MsIHtcbiAgICAgICAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgICAgICAgIHNwZWNpYWxDaGFyczogU3BlY2lhbHMsXG4gICAgICAgICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjb25maWcucmVwbGFjZVRhYnMgPSAhc3VwcG9ydHNUYWJTaXplKCkpXG4gICAgICAgICAgICBjb25maWcuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlxcdHxcIiArIGNvbmZpZy5zcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIGlmIChjb25maWcuYWRkU3BlY2lhbENoYXJzKVxuICAgICAgICAgICAgY29uZmlnLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAoY29uZmlnLnNwZWNpYWxDaGFycy5zb3VyY2UgKyBcInxcIiArIGNvbmZpZy5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBVbmljb2RlUmVnZXhwU3VwcG9ydCk7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgaW5zdGFsbHMgaGlnaGxpZ2h0aW5nIG9mIHNwZWNpYWxcbmNoYXJhY3RlcnMuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0U3BlY2lhbENoYXJzKFxuLyoqXG5Db25maWd1cmF0aW9uIG9wdGlvbnMuXG4qL1xuY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW3NwZWNpYWxDaGFyQ29uZmlnLm9mKGNvbmZpZyksIHNwZWNpYWxDaGFyUGx1Z2luKCldO1xufVxubGV0IF9wbHVnaW4gPSBudWxsO1xuZnVuY3Rpb24gc3BlY2lhbENoYXJQbHVnaW4oKSB7XG4gICAgcmV0dXJuIF9wbHVnaW4gfHwgKF9wbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3Iodmlldy5zdGF0ZS5mYWNldChzcGVjaWFsQ2hhckNvbmZpZykpO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFrZURlY29yYXRvcihjb25mKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoRGVjb3JhdG9yKHtcbiAgICAgICAgICAgICAgICByZWdleHA6IGNvbmYuc3BlY2lhbENoYXJzLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IChtLCB2aWV3LCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZG9jIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29kZSA9IGNvZGVQb2ludEF0KG1bMF0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzaXplID0gdmlldy5zdGF0ZS50YWJTaXplLCBjb2wgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIHNpemUsIHBvcyAtIGxpbmUuZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgVGFiV2lkZ2V0KChzaXplIC0gKGNvbCAlIHNpemUpKSAqIHRoaXMudmlldy5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29yYXRpb25DYWNoZVtjb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGVjb3JhdGlvbkNhY2hlW2NvZGVdID0gRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgU3BlY2lhbENoYXJXaWRnZXQoY29uZiwgY29kZSkgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm91bmRhcnk6IGNvbmYucmVwbGFjZVRhYnMgPyB1bmRlZmluZWQgOiAvW15dL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICAgICAgbGV0IGNvbmYgPSB1cGRhdGUuc3RhdGUuZmFjZXQoc3BlY2lhbENoYXJDb25maWcpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KHNwZWNpYWxDaGFyQ29uZmlnKSAhPSBjb25mKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0b3IgPSB0aGlzLm1ha2VEZWNvcmF0b3IoY29uZik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odXBkYXRlLnZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLnVwZGF0ZURlY28odXBkYXRlLCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xuICAgIH0pKTtcbn1cbmNvbnN0IERlZmF1bHRQbGFjZWhvbGRlciA9IFwiXFx1MjAyMlwiO1xuLy8gQXNzaWducyBwbGFjZWhvbGRlciBjaGFyYWN0ZXJzIGZyb20gdGhlIENvbnRyb2wgUGljdHVyZXMgYmxvY2sgdG9cbi8vIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIkMShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPj0gMzIpXG4gICAgICAgIHJldHVybiBEZWZhdWx0UGxhY2Vob2xkZXI7XG4gICAgaWYgKGNvZGUgPT0gMTApXG4gICAgICAgIHJldHVybiBcIlxcdTI0MjRcIjtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5MjE2ICsgY29kZSk7XG59XG5jbGFzcyBTcGVjaWFsQ2hhcldpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIG90aGVyLmNvZGUgPT0gdGhpcy5jb2RlOyB9XG4gICAgdG9ET00odmlldykge1xuICAgICAgICBsZXQgcGggPSBwbGFjZWhvbGRlciQxKHRoaXMuY29kZSk7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5zdGF0ZS5waHJhc2UoXCJDb250cm9sIGNoYXJhY3RlclwiKSArIFwiIFwiICsgKE5hbWVzW3RoaXMuY29kZV0gfHwgXCIweFwiICsgdGhpcy5jb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGxldCBjdXN0b20gPSB0aGlzLm9wdGlvbnMucmVuZGVyICYmIHRoaXMub3B0aW9ucy5yZW5kZXIodGhpcy5jb2RlLCBkZXNjLCBwaCk7XG4gICAgICAgIGlmIChjdXN0b20pXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tO1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gcGg7XG4gICAgICAgIHNwYW4udGl0bGUgPSBkZXNjO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgZGVzYyk7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gXCJjbS1zcGVjaWFsQ2hhclwiO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuY2xhc3MgVGFiV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBlcShvdGhlcikgeyByZXR1cm4gb3RoZXIud2lkdGggPT0gdGhpcy53aWR0aDsgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJcXHRcIjtcbiAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSBcImNtLXRhYlwiO1xuICAgICAgICBzcGFuLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIGlnbm9yZUV2ZW50KCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuY29uc3QgcGx1Z2luID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAxMDAwO1xuICAgICAgICB0aGlzLmF0dHJzID0geyBzdHlsZTogXCJwYWRkaW5nLWJvdHRvbTogMTAwMHB4XCIgfTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdXBkYXRlLnZpZXcudmlld1N0YXRlLmVkaXRvckhlaWdodCAtIHVwZGF0ZS52aWV3LmRlZmF1bHRMaW5lSGVpZ2h0O1xuICAgICAgICBpZiAoaGVpZ2h0ICE9IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuYXR0cnMgPSB7IHN0eWxlOiBgcGFkZGluZy1ib3R0b206ICR7aGVpZ2h0fXB4YCB9O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4vKipcblJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgbWFrZXMgc3VyZSB0aGUgY29udGVudCBoYXMgYSBib3R0b21cbm1hcmdpbiBlcXVpdmFsZW50IHRvIHRoZSBoZWlnaHQgb2YgdGhlIGVkaXRvciwgbWludXMgb25lIGxpbmVcbmhlaWdodCwgc28gdGhhdCBldmVyeSBsaW5lIGluIHRoZSBkb2N1bWVudCBjYW4gYmUgc2Nyb2xsZWQgdG8gdGhlXG50b3Agb2YgdGhlIGVkaXRvci5cblxuVGhpcyBpcyBvbmx5IG1lYW5pbmdmdWwgd2hlbiB0aGUgZWRpdG9yIGlzIHNjcm9sbGFibGUsIGFuZCBzaG91bGRcbm5vdCBiZSBlbmFibGVkIGluIGVkaXRvcnMgdGhhdCB0YWtlIHRoZSBzaXplIG9mIHRoZWlyIGNvbnRlbnQuXG4qL1xuZnVuY3Rpb24gc2Nyb2xsUGFzdEVuZCgpIHtcbiAgICByZXR1cm4gW3BsdWdpbiwgY29udGVudEF0dHJpYnV0ZXMub2YodmlldyA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IG51bGw7IH0pXTtcbn1cblxuLyoqXG5NYXJrIGxpbmVzIHRoYXQgaGF2ZSBhIGN1cnNvciBvbiB0aGVtIHdpdGggdGhlIGBcImNtLWFjdGl2ZUxpbmVcImBcbkRPTSBjbGFzcy5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRBY3RpdmVMaW5lKCkge1xuICAgIHJldHVybiBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXI7XG59XG5jb25zdCBsaW5lRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLmxpbmUoeyBjbGFzczogXCJjbS1hY3RpdmVMaW5lXCIgfSk7XG5jb25zdCBhY3RpdmVMaW5lSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZ2V0RGVjbyh2aWV3KTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmdldERlY28odXBkYXRlLnZpZXcpO1xuICAgIH1cbiAgICBnZXREZWNvKHZpZXcpIHtcbiAgICAgICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAtMSwgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCByIG9mIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyLmVtcHR5KVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQoci5oZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5lLmZyb20gPiBsYXN0TGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZGVjby5wdXNoKGxpbmVEZWNvLnJhbmdlKGxpbmUuZnJvbSkpO1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lU3RhcnQgPSBsaW5lLmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb24uc2V0KGRlY28pO1xuICAgIH1cbn0sIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KTtcblxuY2xhc3MgUGxhY2Vob2xkZXIgZXh0ZW5kcyBXaWRnZXRUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvRE9NKCkge1xuICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICB3cmFwLmNsYXNzTmFtZSA9IFwiY20tcGxhY2Vob2xkZXJcIjtcbiAgICAgICAgd3JhcC5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodHlwZW9mIHRoaXMuY29udGVudCA9PSBcInN0cmluZ1wiID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jb250ZW50KSA6IHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB3cmFwLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJwbGFjZWhvbGRlciBcIiArIHRoaXMuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyYXAuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgICAgICByZXR1cm4gd3JhcDtcbiAgICB9XG4gICAgaWdub3JlRXZlbnQoKSB7IHJldHVybiBmYWxzZTsgfVxufVxuLyoqXG5FeHRlbnNpb24gdGhhdCBlbmFibGVzIGEgcGxhY2Vob2xkZXLigJRhIHBpZWNlIG9mIGV4YW1wbGUgY29udGVudFxudG8gc2hvdyB3aGVuIHRoZSBlZGl0b3IgaXMgZW1wdHkuXG4qL1xuZnVuY3Rpb24gcGxhY2Vob2xkZXIoY29udGVudCkge1xuICAgIHJldHVybiBWaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gRGVjb3JhdGlvbi5zZXQoW0RlY29yYXRpb24ud2lkZ2V0KHsgd2lkZ2V0OiBuZXcgUGxhY2Vob2xkZXIoY29udGVudCksIHNpZGU6IDEgfSkucmFuZ2UoMCldKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZGVjb3JhdGlvbnMoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZG9jLmxlbmd0aCA/IERlY29yYXRpb24ubm9uZSA6IHRoaXMucGxhY2Vob2xkZXI7IH1cbiAgICB9LCB7IGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnMgfSk7XG59XG5cbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX190ZXN0ID0geyBIZWlnaHRNYXAsIEhlaWdodE9yYWNsZSwgTWVhc3VyZWRIZWlnaHRzLCBRdWVyeVR5cGUsIENoYW5nZWRSYW5nZSwgY29tcHV0ZU9yZGVyLCBtb3ZlVmlzdWFsbHkgfTtcblxuZXhwb3J0IHsgQmlkaVNwYW4sIEJsb2NrSW5mbywgQmxvY2tUeXBlLCBEZWNvcmF0aW9uLCBEaXJlY3Rpb24sIEVkaXRvclZpZXcsIE1hdGNoRGVjb3JhdG9yLCBQbHVnaW5GaWVsZCwgUGx1Z2luRmllbGRQcm92aWRlciwgVmlld1BsdWdpbiwgVmlld1VwZGF0ZSwgV2lkZ2V0VHlwZSwgX190ZXN0LCBkcmF3U2VsZWN0aW9uLCBkcm9wQ3Vyc29yLCBoaWdobGlnaHRBY3RpdmVMaW5lLCBoaWdobGlnaHRTcGVjaWFsQ2hhcnMsIGtleW1hcCwgbG9nRXhjZXB0aW9uLCBwbGFjZWhvbGRlciwgcnVuU2NvcGVIYW5kbGVycywgc2Nyb2xsUGFzdEVuZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@codemirror/view/dist/index.js\n");

/***/ }),

/***/ "./node_modules/style-mod/src/style-mod.js":
/*!*************************************************!*\
  !*** ./node_modules/style-mod/src/style-mod.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StyleModule\": function() { return /* binding */ StyleModule; }\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar C = \"\\u037C\";\nvar COUNT = typeof Symbol == \"undefined\" ? \"__\" + C : Symbol[\"for\"](C);\nvar SET = typeof Symbol == \"undefined\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\");\nvar top = typeof globalThis != \"undefined\" ? globalThis : typeof window != \"undefined\" ? window : {}; // :: - Style modules encapsulate a set of CSS rules defined from\n// JavaScript. Their definitions are only available in a given DOM\n// root after it has been _mounted_ there with `StyleModule.mount`.\n//\n// Style modules should be created once and stored somewhere, as\n// opposed to re-creating them every time you need them. The amount of\n// CSS rules generated for a given DOM root is bounded by the amount\n// of style modules that were used. So to avoid leaking rules, don't\n// create these dynamically, but treat them as one-time allocations.\n\nvar StyleModule = /*#__PURE__*/function () {\n  // :: (Object<Style>, ?{finish: ?(string) → string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  function StyleModule(spec, options) {\n    _classCallCheck(this, StyleModule);\n\n    this.rules = [];\n\n    var _ref = options || {},\n        finish = _ref.finish;\n\n    function splitSelector(selector) {\n      return /^@/.test(selector) ? [selector] : selector.split(/,\\s*/);\n    }\n\n    function render(selectors, spec, target, isKeyframes) {\n      var local = [],\n          isAt = /^@(\\w+)\\b/.exec(selectors[0]),\n          keyframes = isAt && isAt[1] == \"keyframes\";\n      if (isAt && spec == null) return target.push(selectors[0] + \";\");\n\n      for (var prop in spec) {\n        var value = spec[prop];\n\n        if (/&/.test(prop)) {\n          render(prop.split(/,\\s*/).map(function (part) {\n            return selectors.map(function (sel) {\n              return part.replace(/&/, sel);\n            });\n          }).reduce(function (a, b) {\n            return a.concat(b);\n          }), value, target);\n        } else if (value && _typeof(value) == \"object\") {\n          if (!isAt) throw new RangeError(\"The value of a property (\" + prop + \") should be a primitive value.\");\n          render(splitSelector(prop), value, local, keyframes);\n        } else if (value != null) {\n          local.push(prop.replace(/_.*/, \"\").replace(/[A-Z]/g, function (l) {\n            return \"-\" + l.toLowerCase();\n          }) + \": \" + value + \";\");\n        }\n      }\n\n      if (local.length || keyframes) {\n        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(\", \") + \" {\" + local.join(\" \") + \"}\");\n      }\n    }\n\n    for (var prop in spec) {\n      render(splitSelector(prop), spec[prop], this.rules);\n    }\n  } // :: () → string\n  // Returns a string containing the module's CSS rules.\n\n\n  _createClass(StyleModule, [{\n    key: \"getRules\",\n    value: function getRules() {\n      return this.rules.join(\"\\n\");\n    } // :: () → string\n    // Generate a new unique CSS class name.\n\n  }], [{\n    key: \"newName\",\n    value: function newName() {\n      var id = top[COUNT] || 1;\n      top[COUNT] = id + 1;\n      return C + id.toString(36);\n    } // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)\n    //\n    // Mount the given set of modules in the given DOM root, which ensures\n    // that the CSS rules defined by the module are available in that\n    // context.\n    //\n    // Rules are only added to the document once per root.\n    //\n    // Rule order will follow the order of the modules, so that rules from\n    // modules later in the array take precedence of those from earlier\n    // modules. If you call this function multiple times for the same root\n    // in a way that changes the order of already mounted modules, the old\n    // order will be changed.\n\n  }, {\n    key: \"mount\",\n    value: function mount(root, modules) {\n      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);\n    }\n  }]);\n\n  return StyleModule;\n}();\nvar adoptedSet = null;\n\nvar StyleSet = /*#__PURE__*/function () {\n  function StyleSet(root) {\n    _classCallCheck(this, StyleSet);\n\n    if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != \"undefined\") {\n      if (adoptedSet) {\n        root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);\n        return root[SET] = adoptedSet;\n      }\n\n      this.sheet = new CSSStyleSheet();\n      root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);\n      adoptedSet = this;\n    } else {\n      this.styleTag = (root.ownerDocument || root).createElement(\"style\");\n      var target = root.head || root;\n      target.insertBefore(this.styleTag, target.firstChild);\n    }\n\n    this.modules = [];\n    root[SET] = this;\n  }\n\n  _createClass(StyleSet, [{\n    key: \"mount\",\n    value: function mount(modules) {\n      var sheet = this.sheet;\n      var pos = 0\n      /* Current rule offset */\n      ,\n          j = 0;\n      /* Index into this.modules */\n\n      for (var i = 0; i < modules.length; i++) {\n        var mod = modules[i],\n            index = this.modules.indexOf(mod);\n\n        if (index < j && index > -1) {\n          // Ordering conflict\n          this.modules.splice(index, 1);\n          j--;\n          index = -1;\n        }\n\n        if (index == -1) {\n          this.modules.splice(j++, 0, mod);\n          if (sheet) for (var k = 0; k < mod.rules.length; k++) {\n            sheet.insertRule(mod.rules[k], pos++);\n          }\n        } else {\n          while (j < index) {\n            pos += this.modules[j++].rules.length;\n          }\n\n          pos += mod.rules.length;\n          j++;\n        }\n      }\n\n      if (!sheet) {\n        var text = \"\";\n\n        for (var _i = 0; _i < this.modules.length; _i++) {\n          text += this.modules[_i].getRules() + \"\\n\";\n        }\n\n        this.styleTag.textContent = text;\n      }\n    }\n  }]);\n\n  return StyleSet;\n}(); // Style::Object<union<Style,string>>\n//\n// A style is an object that, in the simple case, maps CSS property\n// names to strings holding their values, as in `{color: \"red\",\n// fontWeight: \"bold\"}`. The property names can be given in\n// camel-case—the library will insert a dash before capital letters\n// when converting them to CSS.\n//\n// If you include an underscore in a property name, it and everything\n// after it will be removed from the output, which can be useful when\n// providing a property multiple times, for browser compatibility\n// reasons.\n//\n// A property in a style object can also be a sub-selector, which\n// extends the current context to add a pseudo-selector or a child\n// selector. Such a property should contain a `&` character, which\n// will be replaced by the current selector. For example `{\"&:before\":\n// {content: '\"hi\"'}}`. Sub-selectors and regular properties can\n// freely be mixed in a given object. Any property containing a `&` is\n// assumed to be a sub-selector.\n//\n// Finally, a property can specify an @-block to be wrapped around the\n// styles defined inside the object that's the property's value. For\n// example to create a media query you can do `{\"@media screen and\n// (min-width: 400px)\": {...}}`.//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFHQTs7O0FBdkNBO0FBQUE7QUFBQTtBQXdDQTtBQUFBO0FBR0E7O0FBM0NBO0FBQUE7QUFBQTtBQTZDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE5REE7QUFBQTtBQUFBO0FBZ0VBO0FBQ0E7QUFqRUE7O0FBQUE7QUFBQTtBQW9FQTs7QUFFQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc3R5bGUtbW9kL3NyYy9zdHlsZS1tb2QuanM/YWU0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDID0gXCJcXHUwMzdjXCJcbmNvbnN0IENPVU5UID0gdHlwZW9mIFN5bWJvbCA9PSBcInVuZGVmaW5lZFwiID8gXCJfX1wiICsgQyA6IFN5bWJvbC5mb3IoQylcbmNvbnN0IFNFVCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJ1bmRlZmluZWRcIiA/IFwiX19zdHlsZVNldFwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU4KSA6IFN5bWJvbChcInN0eWxlU2V0XCIpXG5jb25zdCB0b3AgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9XG5cbi8vIDo6IC0gU3R5bGUgbW9kdWxlcyBlbmNhcHN1bGF0ZSBhIHNldCBvZiBDU1MgcnVsZXMgZGVmaW5lZCBmcm9tXG4vLyBKYXZhU2NyaXB0LiBUaGVpciBkZWZpbml0aW9ucyBhcmUgb25seSBhdmFpbGFibGUgaW4gYSBnaXZlbiBET01cbi8vIHJvb3QgYWZ0ZXIgaXQgaGFzIGJlZW4gX21vdW50ZWRfIHRoZXJlIHdpdGggYFN0eWxlTW9kdWxlLm1vdW50YC5cbi8vXG4vLyBTdHlsZSBtb2R1bGVzIHNob3VsZCBiZSBjcmVhdGVkIG9uY2UgYW5kIHN0b3JlZCBzb21ld2hlcmUsIGFzXG4vLyBvcHBvc2VkIHRvIHJlLWNyZWF0aW5nIHRoZW0gZXZlcnkgdGltZSB5b3UgbmVlZCB0aGVtLiBUaGUgYW1vdW50IG9mXG4vLyBDU1MgcnVsZXMgZ2VuZXJhdGVkIGZvciBhIGdpdmVuIERPTSByb290IGlzIGJvdW5kZWQgYnkgdGhlIGFtb3VudFxuLy8gb2Ygc3R5bGUgbW9kdWxlcyB0aGF0IHdlcmUgdXNlZC4gU28gdG8gYXZvaWQgbGVha2luZyBydWxlcywgZG9uJ3Rcbi8vIGNyZWF0ZSB0aGVzZSBkeW5hbWljYWxseSwgYnV0IHRyZWF0IHRoZW0gYXMgb25lLXRpbWUgYWxsb2NhdGlvbnMuXG5leHBvcnQgY2xhc3MgU3R5bGVNb2R1bGUge1xuICAvLyA6OiAoT2JqZWN0PFN0eWxlPiwgP3tmaW5pc2g6ID8oc3RyaW5nKSDihpIgc3RyaW5nfSlcbiAgLy8gQ3JlYXRlIGEgc3R5bGUgbW9kdWxlIGZyb20gdGhlIGdpdmVuIHNwZWMuXG4gIC8vXG4gIC8vIFdoZW4gYGZpbmlzaGAgaXMgZ2l2ZW4sIGl0IGlzIGNhbGxlZCBvbiByZWd1bGFyIChub24tYEBgKVxuICAvLyBzZWxlY3RvcnMgKGFmdGVyIGAmYCBleHBhbnNpb24pIHRvIGNvbXB1dGUgdGhlIGZpbmFsIHNlbGVjdG9yLlxuICBjb25zdHJ1Y3RvcihzcGVjLCBvcHRpb25zKSB7XG4gICAgdGhpcy5ydWxlcyA9IFtdXG4gICAgbGV0IHtmaW5pc2h9ID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgZnVuY3Rpb24gc3BsaXRTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIC9eQC8udGVzdChzZWxlY3RvcikgPyBbc2VsZWN0b3JdIDogc2VsZWN0b3Iuc3BsaXQoLyxcXHMqLylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoc2VsZWN0b3JzLCBzcGVjLCB0YXJnZXQsIGlzS2V5ZnJhbWVzKSB7XG4gICAgICBsZXQgbG9jYWwgPSBbXSwgaXNBdCA9IC9eQChcXHcrKVxcYi8uZXhlYyhzZWxlY3RvcnNbMF0pLCBrZXlmcmFtZXMgPSBpc0F0ICYmIGlzQXRbMV0gPT0gXCJrZXlmcmFtZXNcIlxuICAgICAgaWYgKGlzQXQgJiYgc3BlYyA9PSBudWxsKSByZXR1cm4gdGFyZ2V0LnB1c2goc2VsZWN0b3JzWzBdICsgXCI7XCIpXG4gICAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gc3BlY1twcm9wXVxuICAgICAgICBpZiAoLyYvLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICByZW5kZXIocHJvcC5zcGxpdCgvLFxccyovKS5tYXAocGFydCA9PiBzZWxlY3RvcnMubWFwKHNlbCA9PiBwYXJ0LnJlcGxhY2UoLyYvLCBzZWwpKSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSksXG4gICAgICAgICAgICAgICAgIHZhbHVlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBpZiAoIWlzQXQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgKFwiICsgcHJvcCArIFwiKSBzaG91bGQgYmUgYSBwcmltaXRpdmUgdmFsdWUuXCIpXG4gICAgICAgICAgcmVuZGVyKHNwbGl0U2VsZWN0b3IocHJvcCksIHZhbHVlLCBsb2NhbCwga2V5ZnJhbWVzKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBsb2NhbC5wdXNoKHByb3AucmVwbGFjZSgvXy4qLywgXCJcIikucmVwbGFjZSgvW0EtWl0vZywgbCA9PiBcIi1cIiArIGwudG9Mb3dlckNhc2UoKSkgKyBcIjogXCIgKyB2YWx1ZSArIFwiO1wiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG9jYWwubGVuZ3RoIHx8IGtleWZyYW1lcykge1xuICAgICAgICB0YXJnZXQucHVzaCgoZmluaXNoICYmICFpc0F0ICYmICFpc0tleWZyYW1lcyA/IHNlbGVjdG9ycy5tYXAoZmluaXNoKSA6IHNlbGVjdG9ycykuam9pbihcIiwgXCIpICtcbiAgICAgICAgICAgICAgICAgICAgXCIge1wiICsgbG9jYWwuam9pbihcIiBcIikgKyBcIn1cIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIHNwZWMpIHJlbmRlcihzcGxpdFNlbGVjdG9yKHByb3ApLCBzcGVjW3Byb3BdLCB0aGlzLnJ1bGVzKVxuICB9XG5cbiAgLy8gOjogKCkg4oaSIHN0cmluZ1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1vZHVsZSdzIENTUyBydWxlcy5cbiAgZ2V0UnVsZXMoKSB7IHJldHVybiB0aGlzLnJ1bGVzLmpvaW4oXCJcXG5cIikgfVxuXG4gIC8vIDo6ICgpIOKGkiBzdHJpbmdcbiAgLy8gR2VuZXJhdGUgYSBuZXcgdW5pcXVlIENTUyBjbGFzcyBuYW1lLlxuICBzdGF0aWMgbmV3TmFtZSgpIHtcbiAgICBsZXQgaWQgPSB0b3BbQ09VTlRdIHx8IDFcbiAgICB0b3BbQ09VTlRdID0gaWQgKyAxXG4gICAgcmV0dXJuIEMgKyBpZC50b1N0cmluZygzNilcbiAgfVxuXG4gIC8vIDo6ICh1bmlvbjxEb2N1bWVudCwgU2hhZG93Um9vdD4sIHVuaW9uPFtTdHlsZU1vZHVsZV0sIFN0eWxlTW9kdWxlPilcbiAgLy9cbiAgLy8gTW91bnQgdGhlIGdpdmVuIHNldCBvZiBtb2R1bGVzIGluIHRoZSBnaXZlbiBET00gcm9vdCwgd2hpY2ggZW5zdXJlc1xuICAvLyB0aGF0IHRoZSBDU1MgcnVsZXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIGFyZSBhdmFpbGFibGUgaW4gdGhhdFxuICAvLyBjb250ZXh0LlxuICAvL1xuICAvLyBSdWxlcyBhcmUgb25seSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgb25jZSBwZXIgcm9vdC5cbiAgLy9cbiAgLy8gUnVsZSBvcmRlciB3aWxsIGZvbGxvdyB0aGUgb3JkZXIgb2YgdGhlIG1vZHVsZXMsIHNvIHRoYXQgcnVsZXMgZnJvbVxuICAvLyBtb2R1bGVzIGxhdGVyIGluIHRoZSBhcnJheSB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2UgZnJvbSBlYXJsaWVyXG4gIC8vIG1vZHVsZXMuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJvb3RcbiAgLy8gaW4gYSB3YXkgdGhhdCBjaGFuZ2VzIHRoZSBvcmRlciBvZiBhbHJlYWR5IG1vdW50ZWQgbW9kdWxlcywgdGhlIG9sZFxuICAvLyBvcmRlciB3aWxsIGJlIGNoYW5nZWQuXG4gIHN0YXRpYyBtb3VudChyb290LCBtb2R1bGVzKSB7XG4gICAgKHJvb3RbU0VUXSB8fCBuZXcgU3R5bGVTZXQocm9vdCkpLm1vdW50KEFycmF5LmlzQXJyYXkobW9kdWxlcykgPyBtb2R1bGVzIDogW21vZHVsZXNdKVxuICB9XG59XG5cbmxldCBhZG9wdGVkU2V0ID0gbnVsbFxuXG5jbGFzcyBTdHlsZVNldCB7XG4gIGNvbnN0cnVjdG9yKHJvb3QpIHtcbiAgICBpZiAoIXJvb3QuaGVhZCAmJiByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiB0eXBlb2YgQ1NTU3R5bGVTaGVldCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoYWRvcHRlZFNldCkge1xuICAgICAgICByb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9IFthZG9wdGVkU2V0LnNoZWV0XS5jb25jYXQocm9vdC5hZG9wdGVkU3R5bGVTaGVldHMpXG4gICAgICAgIHJldHVybiByb290W1NFVF0gPSBhZG9wdGVkU2V0XG4gICAgICB9XG4gICAgICB0aGlzLnNoZWV0ID0gbmV3IENTU1N0eWxlU2hlZXRcbiAgICAgIHJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3RoaXMuc2hlZXRdLmNvbmNhdChyb290LmFkb3B0ZWRTdHlsZVNoZWV0cylcbiAgICAgIGFkb3B0ZWRTZXQgPSB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGVUYWcgPSAocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QpLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKVxuICAgICAgbGV0IHRhcmdldCA9IHJvb3QuaGVhZCB8fCByb290XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMuc3R5bGVUYWcsIHRhcmdldC5maXJzdENoaWxkKVxuICAgIH1cbiAgICB0aGlzLm1vZHVsZXMgPSBbXVxuICAgIHJvb3RbU0VUXSA9IHRoaXNcbiAgfVxuXG4gIG1vdW50KG1vZHVsZXMpIHtcbiAgICBsZXQgc2hlZXQgPSB0aGlzLnNoZWV0XG4gICAgbGV0IHBvcyA9IDAgLyogQ3VycmVudCBydWxlIG9mZnNldCAqLywgaiA9IDAgLyogSW5kZXggaW50byB0aGlzLm1vZHVsZXMgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtb2QgPSBtb2R1bGVzW2ldLCBpbmRleCA9IHRoaXMubW9kdWxlcy5pbmRleE9mKG1vZClcbiAgICAgIGlmIChpbmRleCA8IGogJiYgaW5kZXggPiAtMSkgeyAvLyBPcmRlcmluZyBjb25mbGljdFxuICAgICAgICB0aGlzLm1vZHVsZXMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICBqLS1cbiAgICAgICAgaW5kZXggPSAtMVxuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaisrLCAwLCBtb2QpXG4gICAgICAgIGlmIChzaGVldCkgZm9yIChsZXQgayA9IDA7IGsgPCBtb2QucnVsZXMubGVuZ3RoOyBrKyspXG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShtb2QucnVsZXNba10sIHBvcysrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKGogPCBpbmRleCkgcG9zICs9IHRoaXMubW9kdWxlc1tqKytdLnJ1bGVzLmxlbmd0aFxuICAgICAgICBwb3MgKz0gbW9kLnJ1bGVzLmxlbmd0aFxuICAgICAgICBqKytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB0ZXh0ICs9IHRoaXMubW9kdWxlc1tpXS5nZXRSdWxlcygpICsgXCJcXG5cIlxuICAgICAgdGhpcy5zdHlsZVRhZy50ZXh0Q29udGVudCA9IHRleHRcbiAgICB9XG4gIH1cbn1cblxuLy8gU3R5bGU6Ok9iamVjdDx1bmlvbjxTdHlsZSxzdHJpbmc+PlxuLy9cbi8vIEEgc3R5bGUgaXMgYW4gb2JqZWN0IHRoYXQsIGluIHRoZSBzaW1wbGUgY2FzZSwgbWFwcyBDU1MgcHJvcGVydHlcbi8vIG5hbWVzIHRvIHN0cmluZ3MgaG9sZGluZyB0aGVpciB2YWx1ZXMsIGFzIGluIGB7Y29sb3I6IFwicmVkXCIsXG4vLyBmb250V2VpZ2h0OiBcImJvbGRcIn1gLiBUaGUgcHJvcGVydHkgbmFtZXMgY2FuIGJlIGdpdmVuIGluXG4vLyBjYW1lbC1jYXNl4oCUdGhlIGxpYnJhcnkgd2lsbCBpbnNlcnQgYSBkYXNoIGJlZm9yZSBjYXBpdGFsIGxldHRlcnNcbi8vIHdoZW4gY29udmVydGluZyB0aGVtIHRvIENTUy5cbi8vXG4vLyBJZiB5b3UgaW5jbHVkZSBhbiB1bmRlcnNjb3JlIGluIGEgcHJvcGVydHkgbmFtZSwgaXQgYW5kIGV2ZXJ5dGhpbmdcbi8vIGFmdGVyIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBvdXRwdXQsIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlblxuLy8gcHJvdmlkaW5nIGEgcHJvcGVydHkgbXVsdGlwbGUgdGltZXMsIGZvciBicm93c2VyIGNvbXBhdGliaWxpdHlcbi8vIHJlYXNvbnMuXG4vL1xuLy8gQSBwcm9wZXJ0eSBpbiBhIHN0eWxlIG9iamVjdCBjYW4gYWxzbyBiZSBhIHN1Yi1zZWxlY3Rvciwgd2hpY2hcbi8vIGV4dGVuZHMgdGhlIGN1cnJlbnQgY29udGV4dCB0byBhZGQgYSBwc2V1ZG8tc2VsZWN0b3Igb3IgYSBjaGlsZFxuLy8gc2VsZWN0b3IuIFN1Y2ggYSBwcm9wZXJ0eSBzaG91bGQgY29udGFpbiBhIGAmYCBjaGFyYWN0ZXIsIHdoaWNoXG4vLyB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBjdXJyZW50IHNlbGVjdG9yLiBGb3IgZXhhbXBsZSBge1wiJjpiZWZvcmVcIjpcbi8vIHtjb250ZW50OiAnXCJoaVwiJ319YC4gU3ViLXNlbGVjdG9ycyBhbmQgcmVndWxhciBwcm9wZXJ0aWVzIGNhblxuLy8gZnJlZWx5IGJlIG1peGVkIGluIGEgZ2l2ZW4gb2JqZWN0LiBBbnkgcHJvcGVydHkgY29udGFpbmluZyBhIGAmYCBpc1xuLy8gYXNzdW1lZCB0byBiZSBhIHN1Yi1zZWxlY3Rvci5cbi8vXG4vLyBGaW5hbGx5LCBhIHByb3BlcnR5IGNhbiBzcGVjaWZ5IGFuIEAtYmxvY2sgdG8gYmUgd3JhcHBlZCBhcm91bmQgdGhlXG4vLyBzdHlsZXMgZGVmaW5lZCBpbnNpZGUgdGhlIG9iamVjdCB0aGF0J3MgdGhlIHByb3BlcnR5J3MgdmFsdWUuIEZvclxuLy8gZXhhbXBsZSB0byBjcmVhdGUgYSBtZWRpYSBxdWVyeSB5b3UgY2FuIGRvIGB7XCJAbWVkaWEgc2NyZWVuIGFuZFxuLy8gKG1pbi13aWR0aDogNDAwcHgpXCI6IHsuLi59fWAuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/style-mod/src/style-mod.js\n");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"base\": function() { return /* binding */ base; },\n/* harmony export */   \"shift\": function() { return /* binding */ shift; },\n/* harmony export */   \"keyName\": function() { return /* binding */ keyName; }\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\",\n  229: \"q\"\n};\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\",\n  229: \"Q\"\n};\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar safari = typeof navigator != \"undefined\" && /Apple Computer/.test(navigator.vendor);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac; // Fill in the digit keys\n\nfor (var i = 0; i < 10; i++) {\n  base[48 + i] = base[96 + i] = String(i);\n} // The function keys\n\n\nfor (var i = 1; i <= 24; i++) {\n  base[i + 111] = \"F\" + i;\n} // And the alphabetic keys\n\n\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n} // For each code that doesn't have a shift-equivalent, copy the base name\n\n\nfor (var code in base) {\n  if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n}\n\nfunction keyName(event) {\n  // Don't trust event.key in Chrome when there are modifiers until\n  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || (safari || ie) && event.shiftKey && event.key && event.key.length == 1;\n  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\"; // Edge sometimes produces wrong names (Issue #3)\n\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\"; // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdzNjLWtleW5hbWUvaW5kZXguZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckRBO0FBd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF6QkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQUE7QUFBQTs7O0FBR0E7QUFBQTtBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5lcy5qcz85ZWE3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgYmFzZSA9IHtcbiAgODogXCJCYWNrc3BhY2VcIixcbiAgOTogXCJUYWJcIixcbiAgMTA6IFwiRW50ZXJcIixcbiAgMTI6IFwiTnVtTG9ja1wiLFxuICAxMzogXCJFbnRlclwiLFxuICAxNjogXCJTaGlmdFwiLFxuICAxNzogXCJDb250cm9sXCIsXG4gIDE4OiBcIkFsdFwiLFxuICAyMDogXCJDYXBzTG9ja1wiLFxuICAyNzogXCJFc2NhcGVcIixcbiAgMzI6IFwiIFwiLFxuICAzMzogXCJQYWdlVXBcIixcbiAgMzQ6IFwiUGFnZURvd25cIixcbiAgMzU6IFwiRW5kXCIsXG4gIDM2OiBcIkhvbWVcIixcbiAgMzc6IFwiQXJyb3dMZWZ0XCIsXG4gIDM4OiBcIkFycm93VXBcIixcbiAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICA0MDogXCJBcnJvd0Rvd25cIixcbiAgNDQ6IFwiUHJpbnRTY3JlZW5cIixcbiAgNDU6IFwiSW5zZXJ0XCIsXG4gIDQ2OiBcIkRlbGV0ZVwiLFxuICA1OTogXCI7XCIsXG4gIDYxOiBcIj1cIixcbiAgOTE6IFwiTWV0YVwiLFxuICA5MjogXCJNZXRhXCIsXG4gIDEwNjogXCIqXCIsXG4gIDEwNzogXCIrXCIsXG4gIDEwODogXCIsXCIsXG4gIDEwOTogXCItXCIsXG4gIDExMDogXCIuXCIsXG4gIDExMTogXCIvXCIsXG4gIDE0NDogXCJOdW1Mb2NrXCIsXG4gIDE0NTogXCJTY3JvbGxMb2NrXCIsXG4gIDE2MDogXCJTaGlmdFwiLFxuICAxNjE6IFwiU2hpZnRcIixcbiAgMTYyOiBcIkNvbnRyb2xcIixcbiAgMTYzOiBcIkNvbnRyb2xcIixcbiAgMTY0OiBcIkFsdFwiLFxuICAxNjU6IFwiQWx0XCIsXG4gIDE3MzogXCItXCIsXG4gIDE4NjogXCI7XCIsXG4gIDE4NzogXCI9XCIsXG4gIDE4ODogXCIsXCIsXG4gIDE4OTogXCItXCIsXG4gIDE5MDogXCIuXCIsXG4gIDE5MTogXCIvXCIsXG4gIDE5MjogXCJgXCIsXG4gIDIxOTogXCJbXCIsXG4gIDIyMDogXCJcXFxcXCIsXG4gIDIyMTogXCJdXCIsXG4gIDIyMjogXCInXCIsXG4gIDIyOTogXCJxXCJcbn1cblxuZXhwb3J0IHZhciBzaGlmdCA9IHtcbiAgNDg6IFwiKVwiLFxuICA0OTogXCIhXCIsXG4gIDUwOiBcIkBcIixcbiAgNTE6IFwiI1wiLFxuICA1MjogXCIkXCIsXG4gIDUzOiBcIiVcIixcbiAgNTQ6IFwiXlwiLFxuICA1NTogXCImXCIsXG4gIDU2OiBcIipcIixcbiAgNTc6IFwiKFwiLFxuICA1OTogXCI6XCIsXG4gIDYxOiBcIitcIixcbiAgMTczOiBcIl9cIixcbiAgMTg2OiBcIjpcIixcbiAgMTg3OiBcIitcIixcbiAgMTg4OiBcIjxcIixcbiAgMTg5OiBcIl9cIixcbiAgMTkwOiBcIj5cIixcbiAgMTkxOiBcIj9cIixcbiAgMTkyOiBcIn5cIixcbiAgMjE5OiBcIntcIixcbiAgMjIwOiBcInxcIixcbiAgMjIxOiBcIn1cIixcbiAgMjIyOiBcIlxcXCJcIixcbiAgMjI5OiBcIlFcIlxufVxuXG52YXIgY2hyb21lID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBzYWZhcmkgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0FwcGxlIENvbXB1dGVyLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpXG52YXIgZ2Vja28gPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL0dlY2tvXFwvXFxkKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxudmFyIG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbnZhciBpZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudClcbnZhciBicm9rZW5Nb2RpZmllck5hbWVzID0gY2hyb21lICYmIChtYWMgfHwgK2Nocm9tZVsxXSA8IDU3KSB8fCBnZWNrbyAmJiBtYWNcblxuLy8gRmlsbCBpbiB0aGUgZGlnaXQga2V5c1xuZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSBiYXNlWzQ4ICsgaV0gPSBiYXNlWzk2ICsgaV0gPSBTdHJpbmcoaSlcblxuLy8gVGhlIGZ1bmN0aW9uIGtleXNcbmZvciAodmFyIGkgPSAxOyBpIDw9IDI0OyBpKyspIGJhc2VbaSArIDExMV0gPSBcIkZcIiArIGlcblxuLy8gQW5kIHRoZSBhbHBoYWJldGljIGtleXNcbmZvciAodmFyIGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7XG4gIGJhc2VbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkgKyAzMilcbiAgc2hpZnRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIEZvciBlYWNoIGNvZGUgdGhhdCBkb2Vzbid0IGhhdmUgYSBzaGlmdC1lcXVpdmFsZW50LCBjb3B5IHRoZSBiYXNlIG5hbWVcbmZvciAodmFyIGNvZGUgaW4gYmFzZSkgaWYgKCFzaGlmdC5oYXNPd25Qcm9wZXJ0eShjb2RlKSkgc2hpZnRbY29kZV0gPSBiYXNlW2NvZGVdXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlOYW1lKGV2ZW50KSB7XG4gIC8vIERvbid0IHRydXN0IGV2ZW50LmtleSBpbiBDaHJvbWUgd2hlbiB0aGVyZSBhcmUgbW9kaWZpZXJzIHVudGlsXG4gIC8vIHRoZXkgZml4IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYzMzgzOFxuICB2YXIgaWdub3JlS2V5ID0gYnJva2VuTW9kaWZpZXJOYW1lcyAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSkgfHxcbiAgICAoc2FmYXJpIHx8IGllKSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PSAxXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/w3c-keyname/index.es.js\n");

/***/ })

}]);