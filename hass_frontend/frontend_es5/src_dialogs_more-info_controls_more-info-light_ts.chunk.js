"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_dialogs_more-info_controls_more-info-light_ts"],{

/***/ "./src/common/dom/stop_propagation.ts":
/*!********************************************!*\
  !*** ./src/common/dom/stop_propagation.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stopPropagation\": function() { return /* binding */ stopPropagation; }\n/* harmony export */ });\nvar stopPropagation = function stopPropagation(ev) {\n  return ev.stopPropagation();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tbW9uL2RvbS9zdG9wX3Byb3BhZ2F0aW9uLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9jb21tb24vZG9tL3N0b3BfcHJvcGFnYXRpb24udHM/ZWYwMSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgc3RvcFByb3BhZ2F0aW9uID0gKGV2KSA9PiBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/common/dom/stop_propagation.ts\n");

/***/ }),

/***/ "./src/components/ha-color-picker.js":
/*!*******************************************!*\
  !*** ./src/components/ha-color-picker.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _common_color_convert_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/color/convert-color */ \"./src/common/color/convert-color.ts\");\n/* harmony import */ var _mixins_events_mixin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mixins/events-mixin */ \"./src/mixins/events-mixin.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _templateObject;\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/* eslint-plugin-disable lit */\n\n\n\n\n/**\n * Color-picker custom element\n *\n * @appliesMixin EventsMixin\n */\n\nvar HaColorPicker = /*#__PURE__*/function (_EventsMixin) {\n  _inherits(HaColorPicker, _EventsMixin);\n\n  var _super = _createSuper(HaColorPicker);\n\n  function HaColorPicker() {\n    _classCallCheck(this, HaColorPicker);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HaColorPicker, [{\n    key: \"ready\",\n    value: function ready() {\n      var _this = this;\n\n      _get(_getPrototypeOf(HaColorPicker.prototype), \"ready\", this).call(this);\n\n      this.setupLayers();\n      this.drawColorWheel();\n      this.drawMarker();\n\n      if (this.desiredHsColor) {\n        this.applyHsColor(this.desiredHsColor);\n      }\n\n      if (this.desiredRgbColor) {\n        this.applyRgbColor(this.desiredRgbColor);\n      }\n\n      this.interactionLayer.addEventListener(\"mousedown\", function (ev) {\n        return _this.onMouseDown(ev);\n      });\n      this.interactionLayer.addEventListener(\"touchstart\", function (ev) {\n        return _this.onTouchStart(ev);\n      });\n    } // converts browser coordinates to canvas canvas coordinates\n    // origin is wheel center\n    // returns {x: X, y: Y} object\n\n  }, {\n    key: \"convertToCanvasCoordinates\",\n    value: function convertToCanvasCoordinates(clientX, clientY) {\n      var svgPoint = this.interactionLayer.createSVGPoint();\n      svgPoint.x = clientX;\n      svgPoint.y = clientY;\n      var cc = svgPoint.matrixTransform(this.interactionLayer.getScreenCTM().inverse());\n      return {\n        x: cc.x,\n        y: cc.y\n      };\n    } // Mouse events\n\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(ev) {\n      var cc = this.convertToCanvasCoordinates(ev.clientX, ev.clientY); // return if we're not on the wheel\n\n      if (!this.isInWheel(cc.x, cc.y)) {\n        return;\n      } // a mousedown in wheel is always a color select action\n\n\n      this.onMouseSelect(ev); // allow dragging\n\n      this.canvas.classList.add(\"mouse\", \"dragging\");\n      this.addEventListener(\"mousemove\", this.onMouseSelect);\n      this.addEventListener(\"mouseup\", this.onMouseUp);\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp() {\n      this.canvas.classList.remove(\"mouse\", \"dragging\");\n      this.removeEventListener(\"mousemove\", this.onMouseSelect);\n    }\n  }, {\n    key: \"onMouseSelect\",\n    value: function onMouseSelect(ev) {\n      var _this2 = this;\n\n      requestAnimationFrame(function () {\n        return _this2.processUserSelect(ev);\n      });\n    } // Touch events\n\n  }, {\n    key: \"onTouchStart\",\n    value: function onTouchStart(ev) {\n      var _this3 = this;\n\n      var touch = ev.changedTouches[0];\n      var cc = this.convertToCanvasCoordinates(touch.clientX, touch.clientY); // return if we're not on the wheel\n\n      if (!this.isInWheel(cc.x, cc.y)) {\n        return;\n      }\n\n      if (ev.target === this.marker) {\n        // drag marker\n        ev.preventDefault();\n        this.canvas.classList.add(\"touch\", \"dragging\");\n        this.addEventListener(\"touchmove\", this.onTouchSelect);\n        this.addEventListener(\"touchend\", this.onTouchEnd);\n        return;\n      } // don't fire color selection immediately,\n      // wait for touchend and invalidate when we scroll\n\n\n      this.tapBecameScroll = false;\n      this.addEventListener(\"touchend\", this.onTap);\n      this.addEventListener(\"touchmove\", function () {\n        _this3.tapBecameScroll = true;\n      }, {\n        passive: true\n      });\n    }\n  }, {\n    key: \"onTap\",\n    value: function onTap(ev) {\n      if (this.tapBecameScroll) {\n        return;\n      }\n\n      ev.preventDefault();\n      this.onTouchSelect(ev);\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd() {\n      this.canvas.classList.remove(\"touch\", \"dragging\");\n      this.removeEventListener(\"touchmove\", this.onTouchSelect);\n    }\n  }, {\n    key: \"onTouchSelect\",\n    value: function onTouchSelect(ev) {\n      var _this4 = this;\n\n      requestAnimationFrame(function () {\n        return _this4.processUserSelect(ev.changedTouches[0]);\n      });\n    }\n    /*\n     * General event/selection handling\n     */\n    // Process user input to color\n\n  }, {\n    key: \"processUserSelect\",\n    value: function processUserSelect(ev) {\n      var canvasXY = this.convertToCanvasCoordinates(ev.clientX, ev.clientY);\n      var hs = this.getColor(canvasXY.x, canvasXY.y);\n      var rgb;\n\n      if (!this.isInWheel(canvasXY.x, canvasXY.y)) {\n        var _hs2rgb = (0,_common_color_convert_color__WEBPACK_IMPORTED_MODULE_2__.hs2rgb)([hs.h, hs.s]),\n            _hs2rgb2 = _slicedToArray(_hs2rgb, 3),\n            r = _hs2rgb2[0],\n            g = _hs2rgb2[1],\n            b = _hs2rgb2[2];\n\n        rgb = {\n          r: r,\n          g: g,\n          b: b\n        };\n      } else {\n        rgb = this.getRgbColor(canvasXY.x, canvasXY.y);\n      }\n\n      this.onColorSelect(hs, rgb);\n    } // apply color to marker position and canvas\n\n  }, {\n    key: \"onColorSelect\",\n    value: function onColorSelect(hs, rgb) {\n      var _this5 = this;\n\n      this.setMarkerOnColor(hs); // marker always follows mouse 'raw' hs value (= mouse position)\n\n      if (!this.ignoreSegments) {\n        // apply segments if needed\n        hs = this.applySegmentFilter(hs);\n      } // always apply the new color to the interface / canvas\n\n\n      this.applyColorToCanvas(hs); // throttling is applied to updating the exposed colors (properties)\n      // and firing of events\n\n      if (this.colorSelectIsThrottled) {\n        // make sure we apply the last selected color\n        // eventually after throttle limit has passed\n        clearTimeout(this.ensureFinalSelect);\n        this.ensureFinalSelect = setTimeout(function () {\n          _this5.fireColorSelected(hs, rgb); // do it for the final time\n\n        }, this.throttle);\n        return;\n      }\n\n      this.fireColorSelected(hs, rgb); // do it\n\n      this.colorSelectIsThrottled = true;\n      setTimeout(function () {\n        _this5.colorSelectIsThrottled = false;\n      }, this.throttle);\n    } // set color values and fire colorselected event\n\n  }, {\n    key: \"fireColorSelected\",\n    value: function fireColorSelected(hs, rgb) {\n      this.hsColor = hs;\n      this.fire(\"colorselected\", {\n        hs: hs,\n        rgb: rgb\n      });\n    }\n    /*\n     * Interface updating\n     */\n    // set marker position to the given color\n\n  }, {\n    key: \"setMarkerOnColor\",\n    value: function setMarkerOnColor(hs) {\n      if (!this.marker || !this.tooltip) {\n        return;\n      }\n\n      var dist = hs.s * this.radius;\n      var theta = (hs.h - 180) / 180 * Math.PI;\n      var markerdX = -dist * Math.cos(theta);\n      var markerdY = -dist * Math.sin(theta);\n      var translateString = \"translate(\".concat(markerdX, \",\").concat(markerdY, \")\");\n      this.marker.setAttribute(\"transform\", translateString);\n      this.tooltip.setAttribute(\"transform\", translateString);\n    } // apply given color to interface elements\n\n  }, {\n    key: \"applyColorToCanvas\",\n    value: function applyColorToCanvas(hs) {\n      if (!this.interactionLayer) {\n        return;\n      } // we're not really converting hs to hsl here, but we keep it cheap\n      // setting the color on the interactionLayer, the svg elements can inherit\n\n\n      this.interactionLayer.style.color = \"hsl(\".concat(hs.h, \", 100%, \").concat(100 - hs.s * 50, \"%)\");\n    }\n  }, {\n    key: \"applyHsColor\",\n    value: function applyHsColor(hs) {\n      // do nothing is we already have the same color\n      if (this.hsColor && this.hsColor.h === hs.h && this.hsColor.s === hs.s) {\n        return;\n      }\n\n      this.setMarkerOnColor(hs); // marker is always set on 'raw' hs position\n\n      if (!this.ignoreSegments) {\n        // apply segments if needed\n        hs = this.applySegmentFilter(hs);\n      }\n\n      this.hsColor = hs; // always apply the new color to the interface / canvas\n\n      this.applyColorToCanvas(hs);\n    }\n  }, {\n    key: \"applyRgbColor\",\n    value: function applyRgbColor(rgb) {\n      var _rgb2hs = (0,_common_color_convert_color__WEBPACK_IMPORTED_MODULE_2__.rgb2hs)(rgb),\n          _rgb2hs2 = _slicedToArray(_rgb2hs, 2),\n          h = _rgb2hs2[0],\n          s = _rgb2hs2[1];\n\n      this.applyHsColor({\n        h: h,\n        s: s\n      });\n    }\n    /*\n     * input processing helpers\n     */\n    // get angle (degrees)\n\n  }, {\n    key: \"getAngle\",\n    value: function getAngle(dX, dY) {\n      var theta = Math.atan2(-dY, -dX); // radians from the left edge, clockwise = positive\n\n      var angle = theta / Math.PI * 180 + 180; // degrees, clockwise from right\n\n      return angle;\n    } // returns true when coordinates are in the colorwheel\n\n  }, {\n    key: \"isInWheel\",\n    value: function isInWheel(x, y) {\n      return this.getDistance(x, y) <= 1;\n    } // returns distance from wheel center, 0 = center, 1 = edge, >1 = outside\n\n  }, {\n    key: \"getDistance\",\n    value: function getDistance(dX, dY) {\n      return Math.sqrt(dX * dX + dY * dY) / this.radius;\n    }\n    /*\n     * Getting colors\n     */\n\n  }, {\n    key: \"getColor\",\n    value: function getColor(x, y) {\n      var hue = this.getAngle(x, y); // degrees, clockwise from right\n\n      var relativeDistance = this.getDistance(x, y); // edge of radius = 1\n\n      var sat = Math.min(relativeDistance, 1); // Distance from center\n\n      return {\n        h: hue,\n        s: sat\n      };\n    }\n  }, {\n    key: \"getRgbColor\",\n    value: function getRgbColor(x, y) {\n      // get current pixel\n      var imageData = this.backgroundLayer.getContext(\"2d\").getImageData(x + 250, y + 250, 1, 1);\n      var pixel = imageData.data;\n      return {\n        r: pixel[0],\n        g: pixel[1],\n        b: pixel[2]\n      };\n    }\n  }, {\n    key: \"applySegmentFilter\",\n    value: function applySegmentFilter(hs) {\n      // apply hue segment steps\n      if (this.hueSegments) {\n        var angleStep = 360 / this.hueSegments;\n        var halfAngleStep = angleStep / 2;\n        hs.h -= halfAngleStep; // take the 'centered segemnts' into account\n\n        if (hs.h < 0) {\n          hs.h += 360;\n        } // don't end up below 0\n\n\n        var rest = hs.h % angleStep;\n        hs.h -= rest - angleStep;\n      } // apply saturation segment steps\n\n\n      if (this.saturationSegments) {\n        if (this.saturationSegments === 1) {\n          hs.s = 1;\n        } else {\n          var segmentSize = 1 / this.saturationSegments;\n          var saturationStep = 1 / (this.saturationSegments - 1);\n          var calculatedSat = Math.floor(hs.s / segmentSize) * saturationStep;\n          hs.s = Math.min(calculatedSat, 1);\n        }\n      }\n\n      return hs;\n    }\n    /*\n     * Drawing related stuff\n     */\n\n  }, {\n    key: \"setupLayers\",\n    value: function setupLayers() {\n      this.canvas = this.$.canvas;\n      this.backgroundLayer = this.$.backgroundLayer;\n      this.interactionLayer = this.$.interactionLayer; // coordinate origin position (center of the wheel)\n\n      this.originX = this.width / 2;\n      this.originY = this.originX; // synchronise width/height coordinates\n\n      this.backgroundLayer.width = this.width;\n      this.backgroundLayer.height = this.height;\n      this.interactionLayer.setAttribute(\"viewBox\", \"\".concat(-this.originX, \" \").concat(-this.originY, \" \").concat(this.width, \" \").concat(this.height));\n    }\n  }, {\n    key: \"drawColorWheel\",\n    value: function drawColorWheel() {\n      /*\n       *  Setting up all paremeters\n       */\n      var shadowColor;\n      var shadowOffsetX;\n      var shadowOffsetY;\n      var shadowBlur;\n      var context = this.backgroundLayer.getContext(\"2d\"); // postioning and sizing\n\n      var cX = this.originX;\n      var cY = this.originY;\n      var radius = this.radius;\n      var counterClockwise = false; // styling of the wheel\n\n      var wheelStyle = window.getComputedStyle(this.backgroundLayer, null);\n      var borderWidth = parseInt(wheelStyle.getPropertyValue(\"--wheel-borderwidth\"), 10);\n      var borderColor = wheelStyle.getPropertyValue(\"--wheel-bordercolor\").trim();\n      var wheelShadow = wheelStyle.getPropertyValue(\"--wheel-shadow\").trim(); // extract shadow properties from CSS variable\n      // the shadow should be defined as: \"10px 5px 5px 0px COLOR\"\n\n      if (wheelShadow !== \"none\") {\n        var values = wheelShadow.split(\"px \");\n        shadowColor = values.pop();\n        shadowOffsetX = parseInt(values[0], 10);\n        shadowOffsetY = parseInt(values[1], 10);\n        shadowBlur = parseInt(values[2], 10) || 0;\n      }\n\n      var borderRadius = radius + borderWidth / 2;\n      var wheelRadius = radius;\n      var shadowRadius = radius + borderWidth;\n      /*\n       *  Drawing functions\n       */\n\n      function drawCircle(hueSegments, saturationSegments) {\n        hueSegments = hueSegments || 360; // reset 0 segments to 360\n\n        var angleStep = 360 / hueSegments;\n        var halfAngleStep = angleStep / 2; // center segments on color\n\n        for (var angle = 0; angle <= 360; angle += angleStep) {\n          var startAngle = (angle - halfAngleStep) * (Math.PI / 180);\n          var endAngle = (angle + halfAngleStep + 1) * (Math.PI / 180);\n          context.beginPath();\n          context.moveTo(cX, cY);\n          context.arc(cX, cY, wheelRadius, startAngle, endAngle, counterClockwise);\n          context.closePath(); // gradient\n\n          var gradient = context.createRadialGradient(cX, cY, 0, cX, cY, wheelRadius);\n          var lightness = 100; // first gradient stop\n\n          gradient.addColorStop(0, \"hsl(\".concat(angle, \", 100%, \").concat(lightness, \"%)\")); // segment gradient stops\n\n          if (saturationSegments > 0) {\n            var ratioStep = 1 / saturationSegments;\n            var ratio = 0;\n\n            for (var stop = 1; stop < saturationSegments; stop += 1) {\n              var prevLighness = lightness;\n              ratio = stop * ratioStep;\n              lightness = 100 - 50 * ratio;\n              gradient.addColorStop(ratio, \"hsl(\".concat(angle, \", 100%, \").concat(prevLighness, \"%)\"));\n              gradient.addColorStop(ratio, \"hsl(\".concat(angle, \", 100%, \").concat(lightness, \"%)\"));\n            }\n\n            gradient.addColorStop(ratio, \"hsl(\".concat(angle, \", 100%, 50%)\"));\n          } // last gradient stop\n\n\n          gradient.addColorStop(1, \"hsl(\".concat(angle, \", 100%, 50%)\"));\n          context.fillStyle = gradient;\n          context.fill();\n        }\n      }\n\n      function drawShadow() {\n        context.save();\n        context.beginPath();\n        context.arc(cX, cY, shadowRadius, 0, 2 * Math.PI, false);\n        context.shadowColor = shadowColor;\n        context.shadowOffsetX = shadowOffsetX;\n        context.shadowOffsetY = shadowOffsetY;\n        context.shadowBlur = shadowBlur;\n        context.fillStyle = \"white\";\n        context.fill();\n        context.restore();\n      }\n\n      function drawBorder() {\n        context.beginPath();\n        context.arc(cX, cY, borderRadius, 0, 2 * Math.PI, false);\n        context.lineWidth = borderWidth;\n        context.strokeStyle = borderColor;\n        context.stroke();\n      }\n      /*\n       *   Call the drawing functions\n       *   draws the shadow, wheel and border\n       */\n\n\n      if (wheelStyle.shadow !== \"none\") {\n        drawShadow();\n      }\n\n      drawCircle(this.hueSegments, this.saturationSegments);\n\n      if (borderWidth > 0) {\n        drawBorder();\n      }\n    }\n    /*\n     *   Draw the (draggable) marker and tooltip\n     *   on the interactionLayer)\n     */\n\n  }, {\n    key: \"drawMarker\",\n    value: function drawMarker() {\n      var svgElement = this.interactionLayer;\n      var markerradius = this.radius * 0.08;\n      var tooltipradius = this.radius * 0.15;\n      var TooltipOffsetY = -(tooltipradius * 3);\n      var TooltipOffsetX = 0;\n      svgElement.marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      svgElement.marker.setAttribute(\"id\", \"marker\");\n      svgElement.marker.setAttribute(\"r\", markerradius);\n      this.marker = svgElement.marker;\n      svgElement.appendChild(svgElement.marker);\n      svgElement.tooltip = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n      svgElement.tooltip.setAttribute(\"id\", \"colorTooltip\");\n      svgElement.tooltip.setAttribute(\"r\", tooltipradius);\n      svgElement.tooltip.setAttribute(\"cx\", TooltipOffsetX);\n      svgElement.tooltip.setAttribute(\"cy\", TooltipOffsetY);\n      this.tooltip = svgElement.tooltip;\n      svgElement.appendChild(svgElement.tooltip);\n    }\n  }, {\n    key: \"segmentationChange\",\n    value: function segmentationChange() {\n      if (this.backgroundLayer) {\n        this.drawColorWheel();\n      }\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return (0,_polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      <style>\\n        :host {\\n          user-select: none;\\n          -webkit-user-select: none;\\n        }\\n\\n        #canvas {\\n          position: relative;\\n          width: 100%;\\n          max-width: 330px;\\n        }\\n        #canvas > * {\\n          display: block;\\n        }\\n        #interactionLayer {\\n          color: white;\\n          position: absolute;\\n          cursor: crosshair;\\n          width: 100%;\\n          height: 100%;\\n          overflow: visible;\\n        }\\n        #backgroundLayer {\\n          width: 100%;\\n          overflow: visible;\\n          --wheel-bordercolor: var(--ha-color-picker-wheel-bordercolor, white);\\n          --wheel-borderwidth: var(--ha-color-picker-wheel-borderwidth, 3);\\n          --wheel-shadow: var(\\n            --ha-color-picker-wheel-shadow,\\n            rgb(15, 15, 15) 10px 5px 5px 0px\\n          );\\n        }\\n\\n        #marker {\\n          fill: currentColor;\\n          stroke: var(--ha-color-picker-marker-bordercolor, white);\\n          stroke-width: var(--ha-color-picker-marker-borderwidth, 3);\\n          filter: url(#marker-shadow);\\n        }\\n        .dragging #marker {\\n        }\\n\\n        #colorTooltip {\\n          display: none;\\n          fill: currentColor;\\n          stroke: var(--ha-color-picker-tooltip-bordercolor, white);\\n          stroke-width: var(--ha-color-picker-tooltip-borderwidth, 3);\\n        }\\n\\n        .touch.dragging #colorTooltip {\\n          display: inherit;\\n        }\\n      </style>\\n      <div id=\\\"canvas\\\">\\n        <svg id=\\\"interactionLayer\\\">\\n          <defs>\\n            <filter\\n              id=\\\"marker-shadow\\\"\\n              x=\\\"-50%\\\"\\n              y=\\\"-50%\\\"\\n              width=\\\"200%\\\"\\n              height=\\\"200%\\\"\\n              filterUnits=\\\"objectBoundingBox\\\"\\n            >\\n              <feOffset\\n                result=\\\"offOut\\\"\\n                in=\\\"SourceAlpha\\\"\\n                dx=\\\"2\\\"\\n                dy=\\\"2\\\"\\n              ></feOffset>\\n              <feGaussianBlur\\n                result=\\\"blurOut\\\"\\n                in=\\\"offOut\\\"\\n                stdDeviation=\\\"2\\\"\\n              ></feGaussianBlur>\\n              <feComponentTransfer in=\\\"blurOut\\\" result=\\\"alphaOut\\\">\\n                <feFuncA type=\\\"linear\\\" slope=\\\"0.3\\\"></feFuncA>\\n              </feComponentTransfer>\\n              <feBlend\\n                in=\\\"SourceGraphic\\\"\\n                in2=\\\"alphaOut\\\"\\n                mode=\\\"normal\\\"\\n              ></feBlend>\\n            </filter>\\n          </defs>\\n        </svg>\\n        <canvas id=\\\"backgroundLayer\\\"></canvas>\\n      </div>\\n    \"])));\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        hsColor: {\n          type: Object\n        },\n        // use these properties to update the state via attributes\n        desiredHsColor: {\n          type: Object,\n          observer: \"applyHsColor\"\n        },\n        // use these properties to update the state via attributes\n        desiredRgbColor: {\n          type: Object,\n          observer: \"applyRgbColor\"\n        },\n        // width, height and radius apply to the coordinates of\n        // of the canvas.\n        // border width are relative to these numbers\n        // the onscreen displayed size should be controlled with css\n        // and should be the same or smaller\n        width: {\n          type: Number,\n          value: 500\n        },\n        height: {\n          type: Number,\n          value: 500\n        },\n        radius: {\n          type: Number,\n          value: 225\n        },\n        // the amount segments for the hue\n        // 0 = continuous gradient\n        // other than 0 gives 'pie-pieces'\n        hueSegments: {\n          type: Number,\n          value: 0,\n          observer: \"segmentationChange\"\n        },\n        // the amount segments for the hue\n        // 0 = continuous gradient\n        // 1 = only fully saturated\n        // > 1 = segments from white to fully saturated\n        saturationSegments: {\n          type: Number,\n          value: 0,\n          observer: \"segmentationChange\"\n        },\n        // set to true to make the segments purely esthetical\n        // this allows selection off all collors, also\n        // interpolated between the segments\n        ignoreSegments: {\n          type: Boolean,\n          value: false\n        },\n        // throttle te amount of 'colorselected' events fired\n        // value is timeout in milliseconds\n        throttle: {\n          type: Number,\n          value: 500\n        }\n      };\n    }\n  }]);\n\n  return HaColorPicker;\n}((0,_mixins_events_mixin__WEBPACK_IMPORTED_MODULE_3__.EventsMixin)(_polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__.PolymerElement));\n\ncustomElements.define(\"ha-color-picker\", HaColorPicker);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9oYS1jb2xvci1waWNrZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUF3S0E7QUFBQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFHQTtBQUdBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7Ozs7QUFJQTtBQUFBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7OztBQUdBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFJQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFJQTtBQUdBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTs7QUFFQTtBQVFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTs7QUFDQTtBQUNBOzs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUF0bkJBO0FBQ0E7QUEwRkE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFsRUE7QUF1RUE7Ozs7QUF0S0E7O0FBeW5CQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2NvbXBvbmVudHMvaGEtY29sb3ItcGlja2VyLmpzPzQ5YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZ1wiO1xuLyogZXNsaW50LXBsdWdpbi1kaXNhYmxlIGxpdCAqL1xuaW1wb3J0IHsgUG9seW1lckVsZW1lbnQgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnRcIjtcbmltcG9ydCB7IGhzMnJnYiwgcmdiMmhzIH0gZnJvbSBcIi4uL2NvbW1vbi9jb2xvci9jb252ZXJ0LWNvbG9yXCI7XG5pbXBvcnQgeyBFdmVudHNNaXhpbiB9IGZyb20gXCIuLi9taXhpbnMvZXZlbnRzLW1peGluXCI7XG4vKipcbiAqIENvbG9yLXBpY2tlciBjdXN0b20gZWxlbWVudFxuICpcbiAqIEBhcHBsaWVzTWl4aW4gRXZlbnRzTWl4aW5cbiAqL1xuY2xhc3MgSGFDb2xvclBpY2tlciBleHRlbmRzIEV2ZW50c01peGluKFBvbHltZXJFbGVtZW50KSB7XG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgI2NhbnZhcyB7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIG1heC13aWR0aDogMzMwcHg7XG4gICAgICAgIH1cbiAgICAgICAgI2NhbnZhcyA+ICoge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB9XG4gICAgICAgICNpbnRlcmFjdGlvbkxheWVyIHtcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIGN1cnNvcjogY3Jvc3NoYWlyO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgICAgfVxuICAgICAgICAjYmFja2dyb3VuZExheWVyIHtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcbiAgICAgICAgICAtLXdoZWVsLWJvcmRlcmNvbG9yOiB2YXIoLS1oYS1jb2xvci1waWNrZXItd2hlZWwtYm9yZGVyY29sb3IsIHdoaXRlKTtcbiAgICAgICAgICAtLXdoZWVsLWJvcmRlcndpZHRoOiB2YXIoLS1oYS1jb2xvci1waWNrZXItd2hlZWwtYm9yZGVyd2lkdGgsIDMpO1xuICAgICAgICAgIC0td2hlZWwtc2hhZG93OiB2YXIoXG4gICAgICAgICAgICAtLWhhLWNvbG9yLXBpY2tlci13aGVlbC1zaGFkb3csXG4gICAgICAgICAgICByZ2IoMTUsIDE1LCAxNSkgMTBweCA1cHggNXB4IDBweFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAjbWFya2VyIHtcbiAgICAgICAgICBmaWxsOiBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgc3Ryb2tlOiB2YXIoLS1oYS1jb2xvci1waWNrZXItbWFya2VyLWJvcmRlcmNvbG9yLCB3aGl0ZSk7XG4gICAgICAgICAgc3Ryb2tlLXdpZHRoOiB2YXIoLS1oYS1jb2xvci1waWNrZXItbWFya2VyLWJvcmRlcndpZHRoLCAzKTtcbiAgICAgICAgICBmaWx0ZXI6IHVybCgjbWFya2VyLXNoYWRvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLmRyYWdnaW5nICNtYXJrZXIge1xuICAgICAgICB9XG5cbiAgICAgICAgI2NvbG9yVG9vbHRpcCB7XG4gICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgICBmaWxsOiBjdXJyZW50Q29sb3I7XG4gICAgICAgICAgc3Ryb2tlOiB2YXIoLS1oYS1jb2xvci1waWNrZXItdG9vbHRpcC1ib3JkZXJjb2xvciwgd2hpdGUpO1xuICAgICAgICAgIHN0cm9rZS13aWR0aDogdmFyKC0taGEtY29sb3ItcGlja2VyLXRvb2x0aXAtYm9yZGVyd2lkdGgsIDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLnRvdWNoLmRyYWdnaW5nICNjb2xvclRvb2x0aXAge1xuICAgICAgICAgIGRpc3BsYXk6IGluaGVyaXQ7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgICA8ZGl2IGlkPVwiY2FudmFzXCI+XG4gICAgICAgIDxzdmcgaWQ9XCJpbnRlcmFjdGlvbkxheWVyXCI+XG4gICAgICAgICAgPGRlZnM+XG4gICAgICAgICAgICA8ZmlsdGVyXG4gICAgICAgICAgICAgIGlkPVwibWFya2VyLXNoYWRvd1wiXG4gICAgICAgICAgICAgIHg9XCItNTAlXCJcbiAgICAgICAgICAgICAgeT1cIi01MCVcIlxuICAgICAgICAgICAgICB3aWR0aD1cIjIwMCVcIlxuICAgICAgICAgICAgICBoZWlnaHQ9XCIyMDAlXCJcbiAgICAgICAgICAgICAgZmlsdGVyVW5pdHM9XCJvYmplY3RCb3VuZGluZ0JveFwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxmZU9mZnNldFxuICAgICAgICAgICAgICAgIHJlc3VsdD1cIm9mZk91dFwiXG4gICAgICAgICAgICAgICAgaW49XCJTb3VyY2VBbHBoYVwiXG4gICAgICAgICAgICAgICAgZHg9XCIyXCJcbiAgICAgICAgICAgICAgICBkeT1cIjJcIlxuICAgICAgICAgICAgICA+PC9mZU9mZnNldD5cbiAgICAgICAgICAgICAgPGZlR2F1c3NpYW5CbHVyXG4gICAgICAgICAgICAgICAgcmVzdWx0PVwiYmx1ck91dFwiXG4gICAgICAgICAgICAgICAgaW49XCJvZmZPdXRcIlxuICAgICAgICAgICAgICAgIHN0ZERldmlhdGlvbj1cIjJcIlxuICAgICAgICAgICAgICA+PC9mZUdhdXNzaWFuQmx1cj5cbiAgICAgICAgICAgICAgPGZlQ29tcG9uZW50VHJhbnNmZXIgaW49XCJibHVyT3V0XCIgcmVzdWx0PVwiYWxwaGFPdXRcIj5cbiAgICAgICAgICAgICAgICA8ZmVGdW5jQSB0eXBlPVwibGluZWFyXCIgc2xvcGU9XCIwLjNcIj48L2ZlRnVuY0E+XG4gICAgICAgICAgICAgIDwvZmVDb21wb25lbnRUcmFuc2Zlcj5cbiAgICAgICAgICAgICAgPGZlQmxlbmRcbiAgICAgICAgICAgICAgICBpbj1cIlNvdXJjZUdyYXBoaWNcIlxuICAgICAgICAgICAgICAgIGluMj1cImFscGhhT3V0XCJcbiAgICAgICAgICAgICAgICBtb2RlPVwibm9ybWFsXCJcbiAgICAgICAgICAgICAgPjwvZmVCbGVuZD5cbiAgICAgICAgICAgIDwvZmlsdGVyPlxuICAgICAgICAgIDwvZGVmcz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgIDxjYW52YXMgaWQ9XCJiYWNrZ3JvdW5kTGF5ZXJcIj48L2NhbnZhcz5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhzQ29sb3I6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgfSxcblxuICAgICAgLy8gdXNlIHRoZXNlIHByb3BlcnRpZXMgdG8gdXBkYXRlIHRoZSBzdGF0ZSB2aWEgYXR0cmlidXRlc1xuICAgICAgZGVzaXJlZEhzQ29sb3I6IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBvYnNlcnZlcjogXCJhcHBseUhzQ29sb3JcIixcbiAgICAgIH0sXG5cbiAgICAgIC8vIHVzZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB0aGUgc3RhdGUgdmlhIGF0dHJpYnV0ZXNcbiAgICAgIGRlc2lyZWRSZ2JDb2xvcjoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgIG9ic2VydmVyOiBcImFwcGx5UmdiQ29sb3JcIixcbiAgICAgIH0sXG5cbiAgICAgIC8vIHdpZHRoLCBoZWlnaHQgYW5kIHJhZGl1cyBhcHBseSB0byB0aGUgY29vcmRpbmF0ZXMgb2ZcbiAgICAgIC8vIG9mIHRoZSBjYW52YXMuXG4gICAgICAvLyBib3JkZXIgd2lkdGggYXJlIHJlbGF0aXZlIHRvIHRoZXNlIG51bWJlcnNcbiAgICAgIC8vIHRoZSBvbnNjcmVlbiBkaXNwbGF5ZWQgc2l6ZSBzaG91bGQgYmUgY29udHJvbGxlZCB3aXRoIGNzc1xuICAgICAgLy8gYW5kIHNob3VsZCBiZSB0aGUgc2FtZSBvciBzbWFsbGVyXG4gICAgICB3aWR0aDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiA1MDAsXG4gICAgICB9LFxuXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogNTAwLFxuICAgICAgfSxcblxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDIyNSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIHRoZSBhbW91bnQgc2VnbWVudHMgZm9yIHRoZSBodWVcbiAgICAgIC8vIDAgPSBjb250aW51b3VzIGdyYWRpZW50XG4gICAgICAvLyBvdGhlciB0aGFuIDAgZ2l2ZXMgJ3BpZS1waWVjZXMnXG4gICAgICBodWVTZWdtZW50czoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAwLFxuICAgICAgICBvYnNlcnZlcjogXCJzZWdtZW50YXRpb25DaGFuZ2VcIixcbiAgICAgIH0sXG5cbiAgICAgIC8vIHRoZSBhbW91bnQgc2VnbWVudHMgZm9yIHRoZSBodWVcbiAgICAgIC8vIDAgPSBjb250aW51b3VzIGdyYWRpZW50XG4gICAgICAvLyAxID0gb25seSBmdWxseSBzYXR1cmF0ZWRcbiAgICAgIC8vID4gMSA9IHNlZ21lbnRzIGZyb20gd2hpdGUgdG8gZnVsbHkgc2F0dXJhdGVkXG4gICAgICBzYXR1cmF0aW9uU2VnbWVudHM6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgb2JzZXJ2ZXI6IFwic2VnbWVudGF0aW9uQ2hhbmdlXCIsXG4gICAgICB9LFxuXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSB0byBtYWtlIHRoZSBzZWdtZW50cyBwdXJlbHkgZXN0aGV0aWNhbFxuICAgICAgLy8gdGhpcyBhbGxvd3Mgc2VsZWN0aW9uIG9mZiBhbGwgY29sbG9ycywgYWxzb1xuICAgICAgLy8gaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIHNlZ21lbnRzXG4gICAgICBpZ25vcmVTZWdtZW50czoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICB9LFxuXG4gICAgICAvLyB0aHJvdHRsZSB0ZSBhbW91bnQgb2YgJ2NvbG9yc2VsZWN0ZWQnIGV2ZW50cyBmaXJlZFxuICAgICAgLy8gdmFsdWUgaXMgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcbiAgICAgIHRocm90dGxlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDUwMCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgdGhpcy5zZXR1cExheWVycygpO1xuICAgIHRoaXMuZHJhd0NvbG9yV2hlZWwoKTtcbiAgICB0aGlzLmRyYXdNYXJrZXIoKTtcblxuICAgIGlmICh0aGlzLmRlc2lyZWRIc0NvbG9yKSB7XG4gICAgICB0aGlzLmFwcGx5SHNDb2xvcih0aGlzLmRlc2lyZWRIc0NvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kZXNpcmVkUmdiQ29sb3IpIHtcbiAgICAgIHRoaXMuYXBwbHlSZ2JDb2xvcih0aGlzLmRlc2lyZWRSZ2JDb2xvcik7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkxheWVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGV2KSA9PlxuICAgICAgdGhpcy5vbk1vdXNlRG93bihldilcbiAgICApO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25MYXllci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCAoZXYpID0+XG4gICAgICB0aGlzLm9uVG91Y2hTdGFydChldilcbiAgICApO1xuICB9XG5cbiAgLy8gY29udmVydHMgYnJvd3NlciBjb29yZGluYXRlcyB0byBjYW52YXMgY2FudmFzIGNvb3JkaW5hdGVzXG4gIC8vIG9yaWdpbiBpcyB3aGVlbCBjZW50ZXJcbiAgLy8gcmV0dXJucyB7eDogWCwgeTogWX0gb2JqZWN0XG4gIGNvbnZlcnRUb0NhbnZhc0Nvb3JkaW5hdGVzKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICBjb25zdCBzdmdQb2ludCA9IHRoaXMuaW50ZXJhY3Rpb25MYXllci5jcmVhdGVTVkdQb2ludCgpO1xuICAgIHN2Z1BvaW50LnggPSBjbGllbnRYO1xuICAgIHN2Z1BvaW50LnkgPSBjbGllbnRZO1xuICAgIGNvbnN0IGNjID0gc3ZnUG9pbnQubWF0cml4VHJhbnNmb3JtKFxuICAgICAgdGhpcy5pbnRlcmFjdGlvbkxheWVyLmdldFNjcmVlbkNUTSgpLmludmVyc2UoKVxuICAgICk7XG4gICAgcmV0dXJuIHsgeDogY2MueCwgeTogY2MueSB9O1xuICB9XG5cbiAgLy8gTW91c2UgZXZlbnRzXG5cbiAgb25Nb3VzZURvd24oZXYpIHtcbiAgICBjb25zdCBjYyA9IHRoaXMuY29udmVydFRvQ2FudmFzQ29vcmRpbmF0ZXMoZXYuY2xpZW50WCwgZXYuY2xpZW50WSk7XG4gICAgLy8gcmV0dXJuIGlmIHdlJ3JlIG5vdCBvbiB0aGUgd2hlZWxcbiAgICBpZiAoIXRoaXMuaXNJbldoZWVsKGNjLngsIGNjLnkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGEgbW91c2Vkb3duIGluIHdoZWVsIGlzIGFsd2F5cyBhIGNvbG9yIHNlbGVjdCBhY3Rpb25cbiAgICB0aGlzLm9uTW91c2VTZWxlY3QoZXYpO1xuICAgIC8vIGFsbG93IGRyYWdnaW5nXG4gICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LmFkZChcIm1vdXNlXCIsIFwiZHJhZ2dpbmdcIik7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZVNlbGVjdCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcCk7XG4gIH1cblxuICBvbk1vdXNlVXAoKSB7XG4gICAgdGhpcy5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZShcIm1vdXNlXCIsIFwiZHJhZ2dpbmdcIik7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZVNlbGVjdCk7XG4gIH1cblxuICBvbk1vdXNlU2VsZWN0KGV2KSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMucHJvY2Vzc1VzZXJTZWxlY3QoZXYpKTtcbiAgfVxuXG4gIC8vIFRvdWNoIGV2ZW50c1xuXG4gIG9uVG91Y2hTdGFydChldikge1xuICAgIGNvbnN0IHRvdWNoID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgY29uc3QgY2MgPSB0aGlzLmNvbnZlcnRUb0NhbnZhc0Nvb3JkaW5hdGVzKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgIC8vIHJldHVybiBpZiB3ZSdyZSBub3Qgb24gdGhlIHdoZWVsXG4gICAgaWYgKCF0aGlzLmlzSW5XaGVlbChjYy54LCBjYy55KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXYudGFyZ2V0ID09PSB0aGlzLm1hcmtlcikge1xuICAgICAgLy8gZHJhZyBtYXJrZXJcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKFwidG91Y2hcIiwgXCJkcmFnZ2luZ1wiKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2hTZWxlY3QpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5vblRvdWNoRW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gZG9uJ3QgZmlyZSBjb2xvciBzZWxlY3Rpb24gaW1tZWRpYXRlbHksXG4gICAgLy8gd2FpdCBmb3IgdG91Y2hlbmQgYW5kIGludmFsaWRhdGUgd2hlbiB3ZSBzY3JvbGxcbiAgICB0aGlzLnRhcEJlY2FtZVNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMub25UYXApO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMudGFwQmVjYW1lU2Nyb2xsID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICB7IHBhc3NpdmU6IHRydWUgfVxuICAgICk7XG4gIH1cblxuICBvblRhcChldikge1xuICAgIGlmICh0aGlzLnRhcEJlY2FtZVNjcm9sbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMub25Ub3VjaFNlbGVjdChldik7XG4gIH1cblxuICBvblRvdWNoRW5kKCkge1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTGlzdC5yZW1vdmUoXCJ0b3VjaFwiLCBcImRyYWdnaW5nXCIpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLm9uVG91Y2hTZWxlY3QpO1xuICB9XG5cbiAgb25Ub3VjaFNlbGVjdChldikge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLnByb2Nlc3NVc2VyU2VsZWN0KGV2LmNoYW5nZWRUb3VjaGVzWzBdKSk7XG4gIH1cblxuICAvKlxuICAgKiBHZW5lcmFsIGV2ZW50L3NlbGVjdGlvbiBoYW5kbGluZ1xuICAgKi9cblxuICAvLyBQcm9jZXNzIHVzZXIgaW5wdXQgdG8gY29sb3JcbiAgcHJvY2Vzc1VzZXJTZWxlY3QoZXYpIHtcbiAgICBjb25zdCBjYW52YXNYWSA9IHRoaXMuY29udmVydFRvQ2FudmFzQ29vcmRpbmF0ZXMoZXYuY2xpZW50WCwgZXYuY2xpZW50WSk7XG4gICAgY29uc3QgaHMgPSB0aGlzLmdldENvbG9yKGNhbnZhc1hZLngsIGNhbnZhc1hZLnkpO1xuICAgIGxldCByZ2I7XG4gICAgaWYgKCF0aGlzLmlzSW5XaGVlbChjYW52YXNYWS54LCBjYW52YXNYWS55KSkge1xuICAgICAgY29uc3QgW3IsIGcsIGJdID0gaHMycmdiKFtocy5oLCBocy5zXSk7XG4gICAgICByZ2IgPSB7IHIsIGcsIGIgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmdiID0gdGhpcy5nZXRSZ2JDb2xvcihjYW52YXNYWS54LCBjYW52YXNYWS55KTtcbiAgICB9XG4gICAgdGhpcy5vbkNvbG9yU2VsZWN0KGhzLCByZ2IpO1xuICB9XG5cbiAgLy8gYXBwbHkgY29sb3IgdG8gbWFya2VyIHBvc2l0aW9uIGFuZCBjYW52YXNcbiAgb25Db2xvclNlbGVjdChocywgcmdiKSB7XG4gICAgdGhpcy5zZXRNYXJrZXJPbkNvbG9yKGhzKTsgLy8gbWFya2VyIGFsd2F5cyBmb2xsb3dzIG1vdXNlICdyYXcnIGhzIHZhbHVlICg9IG1vdXNlIHBvc2l0aW9uKVxuICAgIGlmICghdGhpcy5pZ25vcmVTZWdtZW50cykge1xuICAgICAgLy8gYXBwbHkgc2VnbWVudHMgaWYgbmVlZGVkXG4gICAgICBocyA9IHRoaXMuYXBwbHlTZWdtZW50RmlsdGVyKGhzKTtcbiAgICB9XG4gICAgLy8gYWx3YXlzIGFwcGx5IHRoZSBuZXcgY29sb3IgdG8gdGhlIGludGVyZmFjZSAvIGNhbnZhc1xuICAgIHRoaXMuYXBwbHlDb2xvclRvQ2FudmFzKGhzKTtcbiAgICAvLyB0aHJvdHRsaW5nIGlzIGFwcGxpZWQgdG8gdXBkYXRpbmcgdGhlIGV4cG9zZWQgY29sb3JzIChwcm9wZXJ0aWVzKVxuICAgIC8vIGFuZCBmaXJpbmcgb2YgZXZlbnRzXG4gICAgaWYgKHRoaXMuY29sb3JTZWxlY3RJc1Rocm90dGxlZCkge1xuICAgICAgLy8gbWFrZSBzdXJlIHdlIGFwcGx5IHRoZSBsYXN0IHNlbGVjdGVkIGNvbG9yXG4gICAgICAvLyBldmVudHVhbGx5IGFmdGVyIHRocm90dGxlIGxpbWl0IGhhcyBwYXNzZWRcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVuc3VyZUZpbmFsU2VsZWN0KTtcbiAgICAgIHRoaXMuZW5zdXJlRmluYWxTZWxlY3QgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5maXJlQ29sb3JTZWxlY3RlZChocywgcmdiKTsgLy8gZG8gaXQgZm9yIHRoZSBmaW5hbCB0aW1lXG4gICAgICB9LCB0aGlzLnRocm90dGxlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maXJlQ29sb3JTZWxlY3RlZChocywgcmdiKTsgLy8gZG8gaXRcbiAgICB0aGlzLmNvbG9yU2VsZWN0SXNUaHJvdHRsZWQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jb2xvclNlbGVjdElzVGhyb3R0bGVkID0gZmFsc2U7XG4gICAgfSwgdGhpcy50aHJvdHRsZSk7XG4gIH1cblxuICAvLyBzZXQgY29sb3IgdmFsdWVzIGFuZCBmaXJlIGNvbG9yc2VsZWN0ZWQgZXZlbnRcbiAgZmlyZUNvbG9yU2VsZWN0ZWQoaHMsIHJnYikge1xuICAgIHRoaXMuaHNDb2xvciA9IGhzO1xuICAgIHRoaXMuZmlyZShcImNvbG9yc2VsZWN0ZWRcIiwgeyBocywgcmdiIH0pO1xuICB9XG5cbiAgLypcbiAgICogSW50ZXJmYWNlIHVwZGF0aW5nXG4gICAqL1xuXG4gIC8vIHNldCBtYXJrZXIgcG9zaXRpb24gdG8gdGhlIGdpdmVuIGNvbG9yXG4gIHNldE1hcmtlck9uQ29sb3IoaHMpIHtcbiAgICBpZiAoIXRoaXMubWFya2VyIHx8ICF0aGlzLnRvb2x0aXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdCA9IGhzLnMgKiB0aGlzLnJhZGl1cztcbiAgICBjb25zdCB0aGV0YSA9ICgoaHMuaCAtIDE4MCkgLyAxODApICogTWF0aC5QSTtcbiAgICBjb25zdCBtYXJrZXJkWCA9IC1kaXN0ICogTWF0aC5jb3ModGhldGEpO1xuICAgIGNvbnN0IG1hcmtlcmRZID0gLWRpc3QgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgY29uc3QgdHJhbnNsYXRlU3RyaW5nID0gYHRyYW5zbGF0ZSgke21hcmtlcmRYfSwke21hcmtlcmRZfSlgO1xuICAgIHRoaXMubWFya2VyLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGVTdHJpbmcpO1xuICAgIHRoaXMudG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlU3RyaW5nKTtcbiAgfVxuXG4gIC8vIGFwcGx5IGdpdmVuIGNvbG9yIHRvIGludGVyZmFjZSBlbGVtZW50c1xuICBhcHBseUNvbG9yVG9DYW52YXMoaHMpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25MYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyB3ZSdyZSBub3QgcmVhbGx5IGNvbnZlcnRpbmcgaHMgdG8gaHNsIGhlcmUsIGJ1dCB3ZSBrZWVwIGl0IGNoZWFwXG4gICAgLy8gc2V0dGluZyB0aGUgY29sb3Igb24gdGhlIGludGVyYWN0aW9uTGF5ZXIsIHRoZSBzdmcgZWxlbWVudHMgY2FuIGluaGVyaXRcbiAgICB0aGlzLmludGVyYWN0aW9uTGF5ZXIuc3R5bGUuY29sb3IgPSBgaHNsKCR7aHMuaH0sIDEwMCUsICR7XG4gICAgICAxMDAgLSBocy5zICogNTBcbiAgICB9JSlgO1xuICB9XG5cbiAgYXBwbHlIc0NvbG9yKGhzKSB7XG4gICAgLy8gZG8gbm90aGluZyBpcyB3ZSBhbHJlYWR5IGhhdmUgdGhlIHNhbWUgY29sb3JcbiAgICBpZiAodGhpcy5oc0NvbG9yICYmIHRoaXMuaHNDb2xvci5oID09PSBocy5oICYmIHRoaXMuaHNDb2xvci5zID09PSBocy5zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0TWFya2VyT25Db2xvcihocyk7IC8vIG1hcmtlciBpcyBhbHdheXMgc2V0IG9uICdyYXcnIGhzIHBvc2l0aW9uXG4gICAgaWYgKCF0aGlzLmlnbm9yZVNlZ21lbnRzKSB7XG4gICAgICAvLyBhcHBseSBzZWdtZW50cyBpZiBuZWVkZWRcbiAgICAgIGhzID0gdGhpcy5hcHBseVNlZ21lbnRGaWx0ZXIoaHMpO1xuICAgIH1cbiAgICB0aGlzLmhzQ29sb3IgPSBocztcbiAgICAvLyBhbHdheXMgYXBwbHkgdGhlIG5ldyBjb2xvciB0byB0aGUgaW50ZXJmYWNlIC8gY2FudmFzXG4gICAgdGhpcy5hcHBseUNvbG9yVG9DYW52YXMoaHMpO1xuICB9XG5cbiAgYXBwbHlSZ2JDb2xvcihyZ2IpIHtcbiAgICBjb25zdCBbaCwgc10gPSByZ2IyaHMocmdiKTtcbiAgICB0aGlzLmFwcGx5SHNDb2xvcih7IGgsIHMgfSk7XG4gIH1cblxuICAvKlxuICAgKiBpbnB1dCBwcm9jZXNzaW5nIGhlbHBlcnNcbiAgICovXG5cbiAgLy8gZ2V0IGFuZ2xlIChkZWdyZWVzKVxuICBnZXRBbmdsZShkWCwgZFkpIHtcbiAgICBjb25zdCB0aGV0YSA9IE1hdGguYXRhbjIoLWRZLCAtZFgpOyAvLyByYWRpYW5zIGZyb20gdGhlIGxlZnQgZWRnZSwgY2xvY2t3aXNlID0gcG9zaXRpdmVcbiAgICBjb25zdCBhbmdsZSA9ICh0aGV0YSAvIE1hdGguUEkpICogMTgwICsgMTgwOyAvLyBkZWdyZWVzLCBjbG9ja3dpc2UgZnJvbSByaWdodFxuICAgIHJldHVybiBhbmdsZTtcbiAgfVxuXG4gIC8vIHJldHVybnMgdHJ1ZSB3aGVuIGNvb3JkaW5hdGVzIGFyZSBpbiB0aGUgY29sb3J3aGVlbFxuICBpc0luV2hlZWwoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKHgsIHkpIDw9IDE7XG4gIH1cblxuICAvLyByZXR1cm5zIGRpc3RhbmNlIGZyb20gd2hlZWwgY2VudGVyLCAwID0gY2VudGVyLCAxID0gZWRnZSwgPjEgPSBvdXRzaWRlXG4gIGdldERpc3RhbmNlKGRYLCBkWSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZFggKiBkWCArIGRZICogZFkpIC8gdGhpcy5yYWRpdXM7XG4gIH1cblxuICAvKlxuICAgKiBHZXR0aW5nIGNvbG9yc1xuICAgKi9cblxuICBnZXRDb2xvcih4LCB5KSB7XG4gICAgY29uc3QgaHVlID0gdGhpcy5nZXRBbmdsZSh4LCB5KTsgLy8gZGVncmVlcywgY2xvY2t3aXNlIGZyb20gcmlnaHRcbiAgICBjb25zdCByZWxhdGl2ZURpc3RhbmNlID0gdGhpcy5nZXREaXN0YW5jZSh4LCB5KTsgLy8gZWRnZSBvZiByYWRpdXMgPSAxXG4gICAgY29uc3Qgc2F0ID0gTWF0aC5taW4ocmVsYXRpdmVEaXN0YW5jZSwgMSk7IC8vIERpc3RhbmNlIGZyb20gY2VudGVyXG4gICAgcmV0dXJuIHsgaDogaHVlLCBzOiBzYXQgfTtcbiAgfVxuXG4gIGdldFJnYkNvbG9yKHgsIHkpIHtcbiAgICAvLyBnZXQgY3VycmVudCBwaXhlbFxuICAgIGNvbnN0IGltYWdlRGF0YSA9IHRoaXMuYmFja2dyb3VuZExheWVyXG4gICAgICAuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgICAuZ2V0SW1hZ2VEYXRhKHggKyAyNTAsIHkgKyAyNTAsIDEsIDEpO1xuICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgcmV0dXJuIHsgcjogcGl4ZWxbMF0sIGc6IHBpeGVsWzFdLCBiOiBwaXhlbFsyXSB9O1xuICB9XG5cbiAgYXBwbHlTZWdtZW50RmlsdGVyKGhzKSB7XG4gICAgLy8gYXBwbHkgaHVlIHNlZ21lbnQgc3RlcHNcbiAgICBpZiAodGhpcy5odWVTZWdtZW50cykge1xuICAgICAgY29uc3QgYW5nbGVTdGVwID0gMzYwIC8gdGhpcy5odWVTZWdtZW50cztcbiAgICAgIGNvbnN0IGhhbGZBbmdsZVN0ZXAgPSBhbmdsZVN0ZXAgLyAyO1xuICAgICAgaHMuaCAtPSBoYWxmQW5nbGVTdGVwOyAvLyB0YWtlIHRoZSAnY2VudGVyZWQgc2VnZW1udHMnIGludG8gYWNjb3VudFxuICAgICAgaWYgKGhzLmggPCAwKSB7XG4gICAgICAgIGhzLmggKz0gMzYwO1xuICAgICAgfSAvLyBkb24ndCBlbmQgdXAgYmVsb3cgMFxuICAgICAgY29uc3QgcmVzdCA9IGhzLmggJSBhbmdsZVN0ZXA7XG4gICAgICBocy5oIC09IHJlc3QgLSBhbmdsZVN0ZXA7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgc2F0dXJhdGlvbiBzZWdtZW50IHN0ZXBzXG4gICAgaWYgKHRoaXMuc2F0dXJhdGlvblNlZ21lbnRzKSB7XG4gICAgICBpZiAodGhpcy5zYXR1cmF0aW9uU2VnbWVudHMgPT09IDEpIHtcbiAgICAgICAgaHMucyA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzZWdtZW50U2l6ZSA9IDEgLyB0aGlzLnNhdHVyYXRpb25TZWdtZW50cztcbiAgICAgICAgY29uc3Qgc2F0dXJhdGlvblN0ZXAgPSAxIC8gKHRoaXMuc2F0dXJhdGlvblNlZ21lbnRzIC0gMSk7XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRTYXQgPSBNYXRoLmZsb29yKGhzLnMgLyBzZWdtZW50U2l6ZSkgKiBzYXR1cmF0aW9uU3RlcDtcbiAgICAgICAgaHMucyA9IE1hdGgubWluKGNhbGN1bGF0ZWRTYXQsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaHM7XG4gIH1cblxuICAvKlxuICAgKiBEcmF3aW5nIHJlbGF0ZWQgc3R1ZmZcbiAgICovXG5cbiAgc2V0dXBMYXllcnMoKSB7XG4gICAgdGhpcy5jYW52YXMgPSB0aGlzLiQuY2FudmFzO1xuICAgIHRoaXMuYmFja2dyb3VuZExheWVyID0gdGhpcy4kLmJhY2tncm91bmRMYXllcjtcbiAgICB0aGlzLmludGVyYWN0aW9uTGF5ZXIgPSB0aGlzLiQuaW50ZXJhY3Rpb25MYXllcjtcblxuICAgIC8vIGNvb3JkaW5hdGUgb3JpZ2luIHBvc2l0aW9uIChjZW50ZXIgb2YgdGhlIHdoZWVsKVxuICAgIHRoaXMub3JpZ2luWCA9IHRoaXMud2lkdGggLyAyO1xuICAgIHRoaXMub3JpZ2luWSA9IHRoaXMub3JpZ2luWDtcblxuICAgIC8vIHN5bmNocm9uaXNlIHdpZHRoL2hlaWdodCBjb29yZGluYXRlc1xuICAgIHRoaXMuYmFja2dyb3VuZExheWVyLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICB0aGlzLmJhY2tncm91bmRMYXllci5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICB0aGlzLmludGVyYWN0aW9uTGF5ZXIuc2V0QXR0cmlidXRlKFxuICAgICAgXCJ2aWV3Qm94XCIsXG4gICAgICBgJHstdGhpcy5vcmlnaW5YfSAkey10aGlzLm9yaWdpbll9ICR7dGhpcy53aWR0aH0gJHt0aGlzLmhlaWdodH1gXG4gICAgKTtcbiAgfVxuXG4gIGRyYXdDb2xvcldoZWVsKCkge1xuICAgIC8qXG4gICAgICogIFNldHRpbmcgdXAgYWxsIHBhcmVtZXRlcnNcbiAgICAgKi9cbiAgICBsZXQgc2hhZG93Q29sb3I7XG4gICAgbGV0IHNoYWRvd09mZnNldFg7XG4gICAgbGV0IHNoYWRvd09mZnNldFk7XG4gICAgbGV0IHNoYWRvd0JsdXI7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuYmFja2dyb3VuZExheWVyLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAvLyBwb3N0aW9uaW5nIGFuZCBzaXppbmdcbiAgICBjb25zdCBjWCA9IHRoaXMub3JpZ2luWDtcbiAgICBjb25zdCBjWSA9IHRoaXMub3JpZ2luWTtcbiAgICBjb25zdCByYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICBjb25zdCBjb3VudGVyQ2xvY2t3aXNlID0gZmFsc2U7XG4gICAgLy8gc3R5bGluZyBvZiB0aGUgd2hlZWxcbiAgICBjb25zdCB3aGVlbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5iYWNrZ3JvdW5kTGF5ZXIsIG51bGwpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcGFyc2VJbnQoXG4gICAgICB3aGVlbFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLXdoZWVsLWJvcmRlcndpZHRoXCIpLFxuICAgICAgMTBcbiAgICApO1xuICAgIGNvbnN0IGJvcmRlckNvbG9yID0gd2hlZWxTdHlsZVxuICAgICAgLmdldFByb3BlcnR5VmFsdWUoXCItLXdoZWVsLWJvcmRlcmNvbG9yXCIpXG4gICAgICAudHJpbSgpO1xuICAgIGNvbnN0IHdoZWVsU2hhZG93ID0gd2hlZWxTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS13aGVlbC1zaGFkb3dcIikudHJpbSgpO1xuICAgIC8vIGV4dHJhY3Qgc2hhZG93IHByb3BlcnRpZXMgZnJvbSBDU1MgdmFyaWFibGVcbiAgICAvLyB0aGUgc2hhZG93IHNob3VsZCBiZSBkZWZpbmVkIGFzOiBcIjEwcHggNXB4IDVweCAwcHggQ09MT1JcIlxuICAgIGlmICh3aGVlbFNoYWRvdyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHdoZWVsU2hhZG93LnNwbGl0KFwicHggXCIpO1xuICAgICAgc2hhZG93Q29sb3IgPSB2YWx1ZXMucG9wKCk7XG4gICAgICBzaGFkb3dPZmZzZXRYID0gcGFyc2VJbnQodmFsdWVzWzBdLCAxMCk7XG4gICAgICBzaGFkb3dPZmZzZXRZID0gcGFyc2VJbnQodmFsdWVzWzFdLCAxMCk7XG4gICAgICBzaGFkb3dCbHVyID0gcGFyc2VJbnQodmFsdWVzWzJdLCAxMCkgfHwgMDtcbiAgICB9XG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gcmFkaXVzICsgYm9yZGVyV2lkdGggLyAyO1xuICAgIGNvbnN0IHdoZWVsUmFkaXVzID0gcmFkaXVzO1xuICAgIGNvbnN0IHNoYWRvd1JhZGl1cyA9IHJhZGl1cyArIGJvcmRlcldpZHRoO1xuXG4gICAgLypcbiAgICAgKiAgRHJhd2luZyBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3Q2lyY2xlKGh1ZVNlZ21lbnRzLCBzYXR1cmF0aW9uU2VnbWVudHMpIHtcbiAgICAgIGh1ZVNlZ21lbnRzID0gaHVlU2VnbWVudHMgfHwgMzYwOyAvLyByZXNldCAwIHNlZ21lbnRzIHRvIDM2MFxuICAgICAgY29uc3QgYW5nbGVTdGVwID0gMzYwIC8gaHVlU2VnbWVudHM7XG4gICAgICBjb25zdCBoYWxmQW5nbGVTdGVwID0gYW5nbGVTdGVwIC8gMjsgLy8gY2VudGVyIHNlZ21lbnRzIG9uIGNvbG9yXG4gICAgICBmb3IgKGxldCBhbmdsZSA9IDA7IGFuZ2xlIDw9IDM2MDsgYW5nbGUgKz0gYW5nbGVTdGVwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSAoYW5nbGUgLSBoYWxmQW5nbGVTdGVwKSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgY29uc3QgZW5kQW5nbGUgPSAoYW5nbGUgKyBoYWxmQW5nbGVTdGVwICsgMSkgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGNYLCBjWSk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIGNYLFxuICAgICAgICAgIGNZLFxuICAgICAgICAgIHdoZWVsUmFkaXVzLFxuICAgICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgY291bnRlckNsb2Nrd2lzZVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAvLyBncmFkaWVudFxuICAgICAgICBjb25zdCBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgY1gsXG4gICAgICAgICAgY1ksXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjWCxcbiAgICAgICAgICBjWSxcbiAgICAgICAgICB3aGVlbFJhZGl1c1xuICAgICAgICApO1xuICAgICAgICBsZXQgbGlnaHRuZXNzID0gMTAwO1xuICAgICAgICAvLyBmaXJzdCBncmFkaWVudCBzdG9wXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBgaHNsKCR7YW5nbGV9LCAxMDAlLCAke2xpZ2h0bmVzc30lKWApO1xuICAgICAgICAvLyBzZWdtZW50IGdyYWRpZW50IHN0b3BzXG4gICAgICAgIGlmIChzYXR1cmF0aW9uU2VnbWVudHMgPiAwKSB7XG4gICAgICAgICAgY29uc3QgcmF0aW9TdGVwID0gMSAvIHNhdHVyYXRpb25TZWdtZW50cztcbiAgICAgICAgICBsZXQgcmF0aW8gPSAwO1xuICAgICAgICAgIGZvciAobGV0IHN0b3AgPSAxOyBzdG9wIDwgc2F0dXJhdGlvblNlZ21lbnRzOyBzdG9wICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZMaWdobmVzcyA9IGxpZ2h0bmVzcztcbiAgICAgICAgICAgIHJhdGlvID0gc3RvcCAqIHJhdGlvU3RlcDtcbiAgICAgICAgICAgIGxpZ2h0bmVzcyA9IDEwMCAtIDUwICogcmF0aW87XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoXG4gICAgICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgICAgICBgaHNsKCR7YW5nbGV9LCAxMDAlLCAke3ByZXZMaWdobmVzc30lKWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AocmF0aW8sIGBoc2woJHthbmdsZX0sIDEwMCUsICR7bGlnaHRuZXNzfSUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChyYXRpbywgYGhzbCgke2FuZ2xlfSwgMTAwJSwgNTAlKWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxhc3QgZ3JhZGllbnQgc3RvcFxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgYGhzbCgke2FuZ2xlfSwgMTAwJSwgNTAlKWApO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdTaGFkb3coKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LmFyYyhjWCwgY1ksIHNoYWRvd1JhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHNoYWRvd09mZnNldFg7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBzaGFkb3dPZmZzZXRZO1xuICAgICAgY29udGV4dC5zaGFkb3dCbHVyID0gc2hhZG93Qmx1cjtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKGNYLCBjWSwgYm9yZGVyUmFkaXVzLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiAgIENhbGwgdGhlIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgICogICBkcmF3cyB0aGUgc2hhZG93LCB3aGVlbCBhbmQgYm9yZGVyXG4gICAgICovXG4gICAgaWYgKHdoZWVsU3R5bGUuc2hhZG93ICE9PSBcIm5vbmVcIikge1xuICAgICAgZHJhd1NoYWRvdygpO1xuICAgIH1cbiAgICBkcmF3Q2lyY2xlKHRoaXMuaHVlU2VnbWVudHMsIHRoaXMuc2F0dXJhdGlvblNlZ21lbnRzKTtcbiAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBkcmF3Qm9yZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogICBEcmF3IHRoZSAoZHJhZ2dhYmxlKSBtYXJrZXIgYW5kIHRvb2x0aXBcbiAgICogICBvbiB0aGUgaW50ZXJhY3Rpb25MYXllcilcbiAgICovXG5cbiAgZHJhd01hcmtlcigpIHtcbiAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy5pbnRlcmFjdGlvbkxheWVyO1xuICAgIGNvbnN0IG1hcmtlcnJhZGl1cyA9IHRoaXMucmFkaXVzICogMC4wODtcbiAgICBjb25zdCB0b29sdGlwcmFkaXVzID0gdGhpcy5yYWRpdXMgKiAwLjE1O1xuICAgIGNvbnN0IFRvb2x0aXBPZmZzZXRZID0gLSh0b29sdGlwcmFkaXVzICogMyk7XG4gICAgY29uc3QgVG9vbHRpcE9mZnNldFggPSAwO1xuXG4gICAgc3ZnRWxlbWVudC5tYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICBcImNpcmNsZVwiXG4gICAgKTtcbiAgICBzdmdFbGVtZW50Lm1hcmtlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcIm1hcmtlclwiKTtcbiAgICBzdmdFbGVtZW50Lm1hcmtlci5zZXRBdHRyaWJ1dGUoXCJyXCIsIG1hcmtlcnJhZGl1cyk7XG4gICAgdGhpcy5tYXJrZXIgPSBzdmdFbGVtZW50Lm1hcmtlcjtcbiAgICBzdmdFbGVtZW50LmFwcGVuZENoaWxkKHN2Z0VsZW1lbnQubWFya2VyKTtcblxuICAgIHN2Z0VsZW1lbnQudG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgIFwiY2lyY2xlXCJcbiAgICApO1xuICAgIHN2Z0VsZW1lbnQudG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImNvbG9yVG9vbHRpcFwiKTtcbiAgICBzdmdFbGVtZW50LnRvb2x0aXAuc2V0QXR0cmlidXRlKFwiclwiLCB0b29sdGlwcmFkaXVzKTtcbiAgICBzdmdFbGVtZW50LnRvb2x0aXAuc2V0QXR0cmlidXRlKFwiY3hcIiwgVG9vbHRpcE9mZnNldFgpO1xuICAgIHN2Z0VsZW1lbnQudG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBUb29sdGlwT2Zmc2V0WSk7XG4gICAgdGhpcy50b29sdGlwID0gc3ZnRWxlbWVudC50b29sdGlwO1xuICAgIHN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnRWxlbWVudC50b29sdGlwKTtcbiAgfVxuXG4gIHNlZ21lbnRhdGlvbkNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5iYWNrZ3JvdW5kTGF5ZXIpIHtcbiAgICAgIHRoaXMuZHJhd0NvbG9yV2hlZWwoKTtcbiAgICB9XG4gIH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShcImhhLWNvbG9yLXBpY2tlclwiLCBIYUNvbG9yUGlja2VyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/ha-color-picker.js\n");

/***/ }),

/***/ "./src/components/ha-labeled-slider.js":
/*!*********************************************!*\
  !*** ./src/components/ha-labeled-slider.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @polymer/polymer/lib/utils/html-tag */ \"./node_modules/@polymer/polymer/lib/utils/html-tag.js\");\n/* harmony import */ var _polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @polymer/polymer/polymer-element */ \"./node_modules/@polymer/polymer/polymer-element.js\");\n/* harmony import */ var _ha_icon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ha-icon */ \"./src/components/ha-icon.ts\");\n/* harmony import */ var _ha_slider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ha-slider */ \"./src/components/ha-slider.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _templateObject;\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n/* eslint-plugin-disable lit */\n\n\n\n\n\nvar HaLabeledSlider = /*#__PURE__*/function (_PolymerElement) {\n  _inherits(HaLabeledSlider, _PolymerElement);\n\n  var _super = _createSuper(HaLabeledSlider);\n\n  function HaLabeledSlider() {\n    _classCallCheck(this, HaLabeledSlider);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HaLabeledSlider, [{\n    key: \"_getTitle\",\n    value: function _getTitle() {\n      return \"\".concat(this.caption).concat(this.caption && this.required ? \" *\" : \"\");\n    }\n  }], [{\n    key: \"template\",\n    get: function get() {\n      return (0,_polymer_polymer_lib_utils_html_tag__WEBPACK_IMPORTED_MODULE_0__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n      <style>\\n        :host {\\n          display: block;\\n        }\\n\\n        .title {\\n          margin: 5px 0 8px;\\n          color: var(--primary-text-color);\\n        }\\n\\n        .slider-container {\\n          display: flex;\\n        }\\n\\n        ha-icon {\\n          margin-top: 4px;\\n          color: var(--secondary-text-color);\\n        }\\n\\n        ha-slider {\\n          flex-grow: 1;\\n          background-image: var(--ha-slider-background);\\n          border-radius: 4px;\\n        }\\n      </style>\\n\\n      <div class=\\\"title\\\">[[_getTitle()]]</div>\\n      <div class=\\\"extra-container\\\"><slot name=\\\"extra\\\"></slot></div>\\n      <div class=\\\"slider-container\\\">\\n        <ha-icon icon=\\\"[[icon]]\\\" hidden$=\\\"[[!icon]]\\\"></ha-icon>\\n        <ha-slider\\n          min=\\\"[[min]]\\\"\\n          max=\\\"[[max]]\\\"\\n          step=\\\"[[step]]\\\"\\n          pin=\\\"[[pin]]\\\"\\n          disabled=\\\"[[disabled]]\\\"\\n          value=\\\"{{value}}\\\"\\n        ></ha-slider>\\n      </div>\\n      <template is=\\\"dom-if\\\" if=\\\"[[helper]]\\\">\\n        <ha-input-helper-text>[[helper]]</ha-input-helper-text>\\n      </template>\\n    \"])));\n    }\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return {\n        caption: String,\n        disabled: Boolean,\n        required: Boolean,\n        min: Number,\n        max: Number,\n        pin: Boolean,\n        step: Number,\n        helper: String,\n        extra: {\n          type: Boolean,\n          value: false\n        },\n        ignoreBarTouch: {\n          type: Boolean,\n          value: true\n        },\n        icon: {\n          type: String,\n          value: \"\"\n        },\n        value: {\n          type: Number,\n          notify: true\n        }\n      };\n    }\n  }]);\n\n  return HaLabeledSlider;\n}(_polymer_polymer_polymer_element__WEBPACK_IMPORTED_MODULE_1__.PolymerElement);\n\ncustomElements.define(\"ha-labeled-slider\", HaLabeledSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9oYS1sYWJlbGVkLXNsaWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFnREE7QUFDQTtBQUNBOzs7QUFqREE7QUFDQTtBQTRDQTs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQXRCQTtBQTJCQTs7OztBQWhGQTs7QUFtRkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9jb21wb25lbnRzL2hhLWxhYmVsZWQtc2xpZGVyLmpzPzhiMmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaHRtbCB9IGZyb20gXCJAcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9odG1sLXRhZ1wiO1xuLyogZXNsaW50LXBsdWdpbi1kaXNhYmxlIGxpdCAqL1xuaW1wb3J0IHsgUG9seW1lckVsZW1lbnQgfSBmcm9tIFwiQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnRcIjtcbmltcG9ydCBcIi4vaGEtaWNvblwiO1xuaW1wb3J0IFwiLi9oYS1zbGlkZXJcIjtcblxuY2xhc3MgSGFMYWJlbGVkU2xpZGVyIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICAudGl0bGUge1xuICAgICAgICAgIG1hcmdpbjogNXB4IDAgOHB4O1xuICAgICAgICAgIGNvbG9yOiB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLnNsaWRlci1jb250YWluZXIge1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIH1cblxuICAgICAgICBoYS1pY29uIHtcbiAgICAgICAgICBtYXJnaW4tdG9wOiA0cHg7XG4gICAgICAgICAgY29sb3I6IHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhLXNsaWRlciB7XG4gICAgICAgICAgZmxleC1ncm93OiAxO1xuICAgICAgICAgIGJhY2tncm91bmQtaW1hZ2U6IHZhcigtLWhhLXNsaWRlci1iYWNrZ3JvdW5kKTtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPltbX2dldFRpdGxlKCldXTwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImV4dHJhLWNvbnRhaW5lclwiPjxzbG90IG5hbWU9XCJleHRyYVwiPjwvc2xvdD48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzbGlkZXItY29udGFpbmVyXCI+XG4gICAgICAgIDxoYS1pY29uIGljb249XCJbW2ljb25dXVwiIGhpZGRlbiQ9XCJbWyFpY29uXV1cIj48L2hhLWljb24+XG4gICAgICAgIDxoYS1zbGlkZXJcbiAgICAgICAgICBtaW49XCJbW21pbl1dXCJcbiAgICAgICAgICBtYXg9XCJbW21heF1dXCJcbiAgICAgICAgICBzdGVwPVwiW1tzdGVwXV1cIlxuICAgICAgICAgIHBpbj1cIltbcGluXV1cIlxuICAgICAgICAgIGRpc2FibGVkPVwiW1tkaXNhYmxlZF1dXCJcbiAgICAgICAgICB2YWx1ZT1cInt7dmFsdWV9fVwiXG4gICAgICAgID48L2hhLXNsaWRlcj5cbiAgICAgIDwvZGl2PlxuICAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLWlmXCIgaWY9XCJbW2hlbHBlcl1dXCI+XG4gICAgICAgIDxoYS1pbnB1dC1oZWxwZXItdGV4dD5bW2hlbHBlcl1dPC9oYS1pbnB1dC1oZWxwZXItdGV4dD5cbiAgICAgIDwvdGVtcGxhdGU+XG4gICAgYDtcbiAgfVxuXG4gIF9nZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jYXB0aW9ufSR7dGhpcy5jYXB0aW9uICYmIHRoaXMucmVxdWlyZWQgPyBcIiAqXCIgOiBcIlwifWA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhcHRpb246IFN0cmluZyxcbiAgICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IEJvb2xlYW4sXG4gICAgICBtaW46IE51bWJlcixcbiAgICAgIG1heDogTnVtYmVyLFxuICAgICAgcGluOiBCb29sZWFuLFxuICAgICAgc3RlcDogTnVtYmVyLFxuICAgICAgaGVscGVyOiBTdHJpbmcsXG5cbiAgICAgIGV4dHJhOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBpZ25vcmVCYXJUb3VjaDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgIH0sXG4gICAgICBpY29uOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwiaGEtbGFiZWxlZC1zbGlkZXJcIiwgSGFMYWJlbGVkU2xpZGVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/ha-labeled-slider.js\n");

/***/ }),

/***/ "./src/dialogs/more-info/controls/more-info-light.ts":
/*!***********************************************************!*\
  !*** ./src/dialogs/more-info/controls/more-info-light.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _material_mwc_list_mwc_list_item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @material/mwc-list/mwc-list-item */ \"./node_modules/@material/mwc-list/mwc-list-item.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! memoize-one */ \"./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var _common_dom_stop_propagation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../common/dom/stop_propagation */ \"./src/common/dom/stop_propagation.ts\");\n/* harmony import */ var _common_entity_supports_feature__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../common/entity/supports-feature */ \"./src/common/entity/supports-feature.ts\");\n/* harmony import */ var _components_ha_attributes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/ha-attributes */ \"./src/components/ha-attributes.ts\");\n/* harmony import */ var _components_ha_button_toggle_group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../components/ha-button-toggle-group */ \"./src/components/ha-button-toggle-group.ts\");\n/* harmony import */ var _components_ha_color_picker__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../components/ha-color-picker */ \"./src/components/ha-color-picker.js\");\n/* harmony import */ var _components_ha_icon_button__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../components/ha-icon-button */ \"./src/components/ha-icon-button.ts\");\n/* harmony import */ var _components_ha_labeled_slider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../components/ha-labeled-slider */ \"./src/components/ha-labeled-slider.js\");\n/* harmony import */ var _components_ha_select__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../components/ha-select */ \"./src/components/ha-select.ts\");\n/* harmony import */ var _data_light__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../data/light */ \"./src/data/light.ts\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14;\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { \"static\": [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return _toArray(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def[\"static\"] ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\nvar mdiPalette = \"M17.5,12A1.5,1.5 0 0,1 16,10.5A1.5,1.5 0 0,1 17.5,9A1.5,1.5 0 0,1 19,10.5A1.5,1.5 0 0,1 17.5,12M14.5,8A1.5,1.5 0 0,1 13,6.5A1.5,1.5 0 0,1 14.5,5A1.5,1.5 0 0,1 16,6.5A1.5,1.5 0 0,1 14.5,8M9.5,8A1.5,1.5 0 0,1 8,6.5A1.5,1.5 0 0,1 9.5,5A1.5,1.5 0 0,1 11,6.5A1.5,1.5 0 0,1 9.5,8M6.5,12A1.5,1.5 0 0,1 5,10.5A1.5,1.5 0 0,1 6.5,9A1.5,1.5 0 0,1 8,10.5A1.5,1.5 0 0,1 6.5,12M12,3A9,9 0 0,0 3,12A9,9 0 0,0 12,21A1.5,1.5 0 0,0 13.5,19.5C13.5,19.11 13.35,18.76 13.11,18.5C12.88,18.23 12.73,17.88 12.73,17.5A1.5,1.5 0 0,1 14.23,16H16A5,5 0 0,0 21,11C21,6.58 16.97,3 12,3Z\";\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar MoreInfoLight = _decorate([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.customElement)(\"more-info-light\")], function (_initialize, _LitElement) {\n  var MoreInfoLight = /*#__PURE__*/function (_LitElement2) {\n    _inherits(MoreInfoLight, _LitElement2);\n\n    var _super = _createSuper(MoreInfoLight);\n\n    function MoreInfoLight() {\n      var _this;\n\n      _classCallCheck(this, MoreInfoLight);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this = _super.call.apply(_super, [this].concat(args));\n\n      _initialize(_assertThisInitialized(_this));\n\n      return _this;\n    }\n\n    return MoreInfoLight;\n  }(_LitElement);\n\n  return {\n    F: MoreInfoLight,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"stateObj\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_brightnessSliderValue\",\n      value: function value() {\n        return 0;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_ctSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_cwSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_wwSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_wvSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_colorBrightnessSliderValue\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_brightnessAdjusted\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_hueSegments\",\n      value: function value() {\n        return 24;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_saturationSegments\",\n      value: function value() {\n        return 8;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_colorPickerColor\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_mode\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        var _attributes$effect_li;\n\n        if (!this.hass || !this.stateObj) {\n          return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\"])));\n        }\n\n        var supportsTemp = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.COLOR_TEMP);\n        var supportsWhite = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.WHITE);\n        var supportsRgbww = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW);\n        var supportsRgbw = !supportsRgbww && (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW);\n        var supportsColor = supportsRgbww || supportsRgbw || (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColor)(this.stateObj);\n        return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n      <div class=\\\"content\\\">\\n        \", \"\\n        \", \"\\n        <ha-attributes\\n          .hass=\", \"\\n          .stateObj=\", \"\\n          extra-filters=\\\"brightness,color_temp,white_value,effect_list,effect,hs_color,rgb_color,rgbw_color,rgbww_color,xy_color,min_mireds,max_mireds,entity_id,supported_color_modes,color_mode\\\"\\n        ></ha-attributes>\\n      </div>\\n    \"])), (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsDimming)(this.stateObj) ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\\n              <ha-labeled-slider\\n                caption=\", \"\\n                icon=\\\"hass:brightness-5\\\"\\n                min=\\\"1\\\"\\n                max=\\\"100\\\"\\n                value=\", \"\\n                @change=\", \"\\n                pin\\n              ></ha-labeled-slider>\\n            \"])), this.hass.localize(\"ui.card.light.brightness\"), this._brightnessSliderValue, this._brightnessSliderChanged) : \"\", this.stateObj.state === \"on\" ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\\n              \", \"\\n              \", \"\\n              \", \"\\n              \", \"\\n              \", \"\\n            \"])), supportsTemp || supportsColor ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"<hr />\"]))) : \"\", supportsColor && (supportsTemp || supportsWhite) ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"<ha-button-toggle-group\\n                    fullWidth\\n                    .buttons=\", \"\\n                    .active=\", \"\\n                    @value-changed=\", \"\\n                  ></ha-button-toggle-group>\"])), this._toggleButtons(supportsTemp, supportsWhite), this._mode, this._modeChanged) : \"\", supportsTemp && (!supportsColor && !supportsWhite || this._mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.COLOR_TEMP) ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\\n                    <ha-labeled-slider\\n                      class=\\\"color_temp\\\"\\n                      caption=\", \"\\n                      icon=\\\"hass:thermometer\\\"\\n                      .min=\", \"\\n                      .max=\", \"\\n                      .value=\", \"\\n                      @change=\", \"\\n                      pin\\n                    ></ha-labeled-slider>\\n                  \"])), this.hass.localize(\"ui.card.light.color_temperature\"), this.stateObj.attributes.min_mireds, this.stateObj.attributes.max_mireds, this._ctSliderValue, this._ctSliderChanged) : \"\", supportsColor && (!supportsTemp && !supportsWhite || this._mode === \"color\") ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\\n                    <div class=\\\"segmentationContainer\\\">\\n                      <ha-color-picker\\n                        class=\\\"color\\\"\\n                        @colorselected=\", \"\\n                        .desiredRgbColor=\", \"\\n                        throttle=\\\"500\\\"\\n                        .hueSegments=\", \"\\n                        .saturationSegments=\", \"\\n                      >\\n                      </ha-color-picker>\\n                      <ha-icon-button\\n                        .path=\", \"\\n                        @click=\", \"\\n                        class=\\\"segmentationButton\\\"\\n                      ></ha-icon-button>\\n                    </div>\\n\\n                    \", \"\\n                    \", \"\\n                    \", \"\\n                  \"])), this._colorPicked, this._colorPickerColor, this._hueSegments, this._saturationSegments, mdiPalette, this._segmentClick, supportsRgbw || supportsRgbww ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"<ha-labeled-slider\\n                          .caption=\", \"\\n                          icon=\\\"hass:brightness-7\\\"\\n                          max=\\\"100\\\"\\n                          .value=\", \"\\n                          @change=\", \"\\n                          pin\\n                        ></ha-labeled-slider>\"])), this.hass.localize(\"ui.card.light.color_brightness\"), this._colorBrightnessSliderValue, this._colorBrightnessSliderChanged) : \"\", supportsRgbw ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\\n                          <ha-labeled-slider\\n                            .caption=\", \"\\n                            icon=\\\"hass:file-word-box\\\"\\n                            max=\\\"100\\\"\\n                            .name=\", \"\\n                            .value=\", \"\\n                            @change=\", \"\\n                            pin\\n                          ></ha-labeled-slider>\\n                        \"])), this.hass.localize(\"ui.card.light.white_value\"), \"wv\", this._wvSliderValue, this._wvSliderChanged) : \"\", supportsRgbww ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\n                          <ha-labeled-slider\\n                            .caption=\", \"\\n                            icon=\\\"hass:file-word-box-outline\\\"\\n                            max=\\\"100\\\"\\n                            .name=\", \"\\n                            .value=\", \"\\n                            @change=\", \"\\n                            pin\\n                          ></ha-labeled-slider>\\n                          <ha-labeled-slider\\n                            .caption=\", \"\\n                            icon=\\\"hass:file-word-box\\\"\\n                            max=\\\"100\\\"\\n                            .name=\", \"\\n                            .value=\", \"\\n                            @change=\", \"\\n                            pin\\n                          ></ha-labeled-slider>\\n                        \"])), this.hass.localize(\"ui.card.light.cold_white_value\"), \"cw\", this._cwSliderValue, this._wvSliderChanged, this.hass.localize(\"ui.card.light.warm_white_value\"), \"ww\", this._wwSliderValue, this._wvSliderChanged) : \"\") : \"\", (0,_common_entity_supports_feature__WEBPACK_IMPORTED_MODULE_4__.supportsFeature)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.SUPPORT_EFFECT) && (_attributes$effect_li = this.stateObj.attributes.effect_list) !== null && _attributes$effect_li !== void 0 && _attributes$effect_li.length ? (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"\\n                    <hr />\\n                    <ha-select\\n                      .label=\", \"\\n                      .value=\", \"\\n                      fixedMenuPosition\\n                      naturalMenuWidth\\n                      @selected=\", \"\\n                      @closed=\", \"\\n                    >\\n                      \", \"\\n                    </ha-select>\\n                  \"])), this.hass.localize(\"ui.card.light.effect\"), this.stateObj.attributes.effect || \"\", this._effectChanged, _common_dom_stop_propagation__WEBPACK_IMPORTED_MODULE_3__.stopPropagation, this.stateObj.attributes.effect_list.map(function (effect) {\n          return (0,lit__WEBPACK_IMPORTED_MODULE_1__.html)(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\\n                          <mwc-list-item .value=\", \">\\n                            \", \"\\n                          </mwc-list-item>\\n                        \"])), effect, effect);\n        })) : \"\") : \"\", this.hass, this.stateObj);\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        _get(_getPrototypeOf(MoreInfoLight.prototype), \"willUpdate\", this).call(this, changedProps);\n\n        if (!changedProps.has(\"stateObj\")) {\n          return;\n        }\n\n        var stateObj = this.stateObj;\n        var oldStateObj = changedProps.get(\"stateObj\");\n\n        if (stateObj.state === \"on\") {\n          // Don't change tab when the color mode changes\n          if ((oldStateObj === null || oldStateObj === void 0 ? void 0 : oldStateObj.entity_id) !== stateObj.entity_id || (oldStateObj === null || oldStateObj === void 0 ? void 0 : oldStateObj.state) !== stateObj.state) {\n            this._mode = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightIsInColorMode)(this.stateObj) ? \"color\" : this.stateObj.attributes.color_mode;\n          }\n\n          var brightnessAdjust = 100;\n          this._brightnessAdjusted = undefined;\n\n          if (stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGB && !(0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW) && !(0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW)) {\n            var maxVal = Math.max.apply(Math, _toConsumableArray(stateObj.attributes.rgb_color));\n\n            if (maxVal < 255) {\n              this._brightnessAdjusted = maxVal;\n              brightnessAdjust = this._brightnessAdjusted / 255 * 100;\n            }\n          }\n\n          this._brightnessSliderValue = Math.round(stateObj.attributes.brightness * brightnessAdjust / 255);\n          this._ctSliderValue = stateObj.attributes.color_temp;\n          this._wvSliderValue = stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW ? Math.round(stateObj.attributes.rgbw_color[3] * 100 / 255) : undefined;\n          this._cwSliderValue = stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW ? Math.round(stateObj.attributes.rgbww_color[3] * 100 / 255) : undefined;\n          this._wwSliderValue = stateObj.attributes.color_mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW ? Math.round(stateObj.attributes.rgbww_color[4] * 100 / 255) : undefined;\n          var currentRgbColor = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.getLightCurrentModeRgbColor)(stateObj);\n          this._colorBrightnessSliderValue = currentRgbColor ? Math.round(Math.max.apply(Math, _toConsumableArray(currentRgbColor.slice(0, 3))) * 100 / 255) : undefined;\n          this._colorPickerColor = currentRgbColor === null || currentRgbColor === void 0 ? void 0 : currentRgbColor.slice(0, 3);\n        } else {\n          this._brightnessSliderValue = 0;\n        }\n      }\n    }, {\n      kind: \"field\",\n      key: \"_toggleButtons\",\n      value: function value() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(function (supportsTemp, supportsWhite) {\n          var modes = [{\n            label: \"Color\",\n            value: \"color\"\n          }];\n\n          if (supportsTemp) {\n            modes.push({\n              label: \"Temperature\",\n              value: _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.COLOR_TEMP\n            });\n          }\n\n          if (supportsWhite) {\n            modes.push({\n              label: \"White\",\n              value: _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.WHITE\n            });\n          }\n\n          return modes;\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_modeChanged\",\n      value: function _modeChanged(ev) {\n        this._mode = ev.detail.value;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_effectChanged\",\n      value: function _effectChanged(ev) {\n        var newVal = ev.target.value;\n\n        if (!newVal || this.stateObj.attributes.effect === newVal) {\n          return;\n        }\n\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          effect: newVal\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_brightnessSliderChanged\",\n      value: function _brightnessSliderChanged(ev) {\n        var bri = Number(ev.target.value);\n\n        if (isNaN(bri)) {\n          return;\n        }\n\n        this._brightnessSliderValue = bri;\n\n        if (this._mode === _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.WHITE) {\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            white: Math.min(255, Math.round(bri * 255 / 100))\n          });\n          return;\n        }\n\n        if (this._brightnessAdjusted) {\n          var rgb = this.stateObj.attributes.rgb_color || [0, 0, 0];\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            brightness_pct: bri,\n            rgb_color: this._adjustColorBrightness(rgb, this._brightnessAdjusted, true)\n          });\n          return;\n        }\n\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          brightness_pct: bri\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_ctSliderChanged\",\n      value: function _ctSliderChanged(ev) {\n        var ct = Number(ev.target.value);\n\n        if (isNaN(ct)) {\n          return;\n        }\n\n        this._ctSliderValue = ct;\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          color_temp: ct\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_wvSliderChanged\",\n      value: function _wvSliderChanged(ev) {\n        var target = ev.target;\n        var wv = Number(target.value);\n        var name = target.name;\n\n        if (isNaN(wv)) {\n          return;\n        }\n\n        if (name === \"wv\") {\n          this._wvSliderValue = wv;\n        } else if (name === \"cw\") {\n          this._cwSliderValue = wv;\n        } else if (name === \"ww\") {\n          this._wwSliderValue = wv;\n        }\n\n        wv = Math.min(255, Math.round(wv * 255 / 100));\n        var rgb = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.getLightCurrentModeRgbColor)(this.stateObj);\n\n        if (name === \"wv\") {\n          var rgbw_color = rgb || [0, 0, 0, 0];\n          rgbw_color[3] = wv;\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            rgbw_color: rgbw_color\n          });\n          return;\n        }\n\n        var rgbww_color = rgb || [0, 0, 0, 0, 0];\n\n        while (rgbww_color.length < 5) {\n          rgbww_color.push(0);\n        }\n\n        rgbww_color[name === \"cw\" ? 3 : 4] = wv;\n        this.hass.callService(\"light\", \"turn_on\", {\n          entity_id: this.stateObj.entity_id,\n          rgbww_color: rgbww_color\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_colorBrightnessSliderChanged\",\n      value: function _colorBrightnessSliderChanged(ev) {\n        var _getLightCurrentModeR;\n\n        var target = ev.target;\n        var value = Number(target.value);\n\n        if (isNaN(value)) {\n          return;\n        }\n\n        var oldValue = this._colorBrightnessSliderValue;\n        this._colorBrightnessSliderValue = value;\n        value = value * 255 / 100;\n        var rgb = ((_getLightCurrentModeR = (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.getLightCurrentModeRgbColor)(this.stateObj)) === null || _getLightCurrentModeR === void 0 ? void 0 : _getLightCurrentModeR.slice(0, 3)) || [255, 255, 255];\n\n        this._setRgbWColor(this._adjustColorBrightness( // first normalize the value\n        oldValue ? this._adjustColorBrightness(rgb, oldValue * 255 / 100, true) : rgb, value));\n      }\n    }, {\n      kind: \"method\",\n      key: \"_segmentClick\",\n      value: function _segmentClick() {\n        if (this._hueSegments === 24 && this._saturationSegments === 8) {\n          this._hueSegments = 0;\n          this._saturationSegments = 0;\n        } else {\n          this._hueSegments = 24;\n          this._saturationSegments = 8;\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"_adjustColorBrightness\",\n      value: function _adjustColorBrightness(rgbColor, value) {\n        var invert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (value !== undefined && value !== 255) {\n          var ratio = value / 255;\n\n          if (invert) {\n            ratio = 1 / ratio;\n          }\n\n          rgbColor[0] = Math.min(255, Math.round(rgbColor[0] * ratio));\n          rgbColor[1] = Math.min(255, Math.round(rgbColor[1] * ratio));\n          rgbColor[2] = Math.min(255, Math.round(rgbColor[2] * ratio));\n        }\n\n        return rgbColor;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_setRgbWColor\",\n      value: function _setRgbWColor(rgbColor) {\n        if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW)) {\n          var rgbww_color = this.stateObj.attributes.rgbww_color ? _toConsumableArray(this.stateObj.attributes.rgbww_color) : [0, 0, 0, 0, 0];\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            rgbww_color: rgbColor.concat(rgbww_color.slice(3))\n          });\n        } else if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW)) {\n          var rgbw_color = this.stateObj.attributes.rgbw_color ? _toConsumableArray(this.stateObj.attributes.rgbw_color) : [0, 0, 0, 0];\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            rgbw_color: rgbColor.concat(rgbw_color.slice(3))\n          });\n        }\n      }\n      /**\n       * Called when a new color has been picked.\n       * should be throttled with the 'throttle=' attribute of the color picker\n       */\n\n    }, {\n      kind: \"method\",\n      key: \"_colorPicked\",\n      value: function _colorPicked(ev) {\n        this._colorPickerColor = [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b];\n\n        if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBWW) || (0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGBW)) {\n          this._setRgbWColor(this._colorBrightnessSliderValue ? this._adjustColorBrightness([ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b], this._colorBrightnessSliderValue * 255 / 100) : [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b]);\n        } else if ((0,_data_light__WEBPACK_IMPORTED_MODULE_11__.lightSupportsColorMode)(this.stateObj, _data_light__WEBPACK_IMPORTED_MODULE_11__.LightColorModes.RGB)) {\n          var rgb_color = [ev.detail.rgb.r, ev.detail.rgb.g, ev.detail.rgb.b];\n\n          if (this._brightnessAdjusted) {\n            this.hass.callService(\"light\", \"turn_on\", {\n              entity_id: this.stateObj.entity_id,\n              brightness_pct: this._brightnessSliderValue,\n              rgb_color: this._adjustColorBrightness(rgb_color, this._brightnessAdjusted, true)\n            });\n          } else {\n            this.hass.callService(\"light\", \"turn_on\", {\n              entity_id: this.stateObj.entity_id,\n              rgb_color: rgb_color\n            });\n          }\n        } else {\n          this.hass.callService(\"light\", \"turn_on\", {\n            entity_id: this.stateObj.entity_id,\n            hs_color: [ev.detail.hs.h, ev.detail.hs.s * 100]\n          });\n        }\n      }\n    }, {\n      kind: \"get\",\n      \"static\": true,\n      key: \"styles\",\n      value: function styles() {\n        return (0,lit__WEBPACK_IMPORTED_MODULE_1__.css)(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\\n      .content {\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      }\\n\\n      .content > * {\\n        width: 100%;\\n      }\\n\\n      .color_temp {\\n        --ha-slider-background: -webkit-linear-gradient(\\n          right,\\n          rgb(255, 160, 0) 0%,\\n          white 50%,\\n          rgb(166, 209, 255) 100%\\n        );\\n        /* The color temp minimum value shouldn't be rendered differently. It's not \\\"off\\\". */\\n        --paper-slider-knob-start-border-color: var(--primary-color);\\n        margin-bottom: 4px;\\n      }\\n\\n      .segmentationContainer {\\n        position: relative;\\n        max-height: 500px;\\n        display: flex;\\n        justify-content: center;\\n      }\\n\\n      ha-button-toggle-group {\\n        margin-bottom: 8px;\\n      }\\n\\n      ha-color-picker {\\n        --ha-color-picker-wheel-borderwidth: 5;\\n        --ha-color-picker-wheel-bordercolor: white;\\n        --ha-color-picker-wheel-shadow: none;\\n        --ha-color-picker-marker-borderwidth: 2;\\n        --ha-color-picker-marker-bordercolor: white;\\n      }\\n\\n      .segmentationButton {\\n        position: absolute;\\n        top: 5%;\\n        left: 0;\\n        color: var(--secondary-text-color);\\n      }\\n\\n      hr {\\n        border-color: var(--divider-color);\\n        border-bottom: none;\\n        margin: 16px 0;\\n      }\\n    \"])));\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_1__.LitElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGlhbG9ncy9tb3JlLWluZm8vY29udHJvbHMvbW9yZS1pbmZvLWxpZ2h0LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFhQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUNBO0FBQUE7QUFBQTs7Ozs7QUFFQTtBQUFBO0FBQUE7Ozs7O0FBRUE7OztBQUFBOzs7O0FBRUE7Ozs7O0FBRUE7Ozs7O0FBRUE7Ozs7O0FBRUE7Ozs7O0FBRUE7Ozs7O0FBRUE7Ozs7O0FBRUE7OztBQUFBOzs7O0FBRUE7OztBQUFBOzs7O0FBRUE7Ozs7O0FBRUE7Ozs7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUFLQTtBQUtBO0FBSUE7QUFHQTtBQW9JQTtBQUFBO0FBa0JBOzs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFJQTtBQUdBOztBQUVBO0FBQ0E7O0FBQ0E7QUFLQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBR0E7QUFDQTtBQUlBO0FBSUE7QUFLQTtBQUVBO0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFTQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7OztBQUVBO0FBQUE7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBRUE7O0FBSUE7QUFHQTtBQU1BOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBRUE7QUFJQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBQ0E7QUFNQTs7QUFNQTtBQUlBO0FBUUE7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBdURBOzs7QUE5a0JBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9zcmMvZGlhbG9ncy9tb3JlLWluZm8vY29udHJvbHMvbW9yZS1pbmZvLWxpZ2h0LnRzPzAxMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiQG1hdGVyaWFsL213Yy1saXN0L213Yy1saXN0LWl0ZW1cIjtcbmltcG9ydCB7IG1kaVBhbGV0dGUgfSBmcm9tIFwiQG1kaS9qc1wiO1xuaW1wb3J0IHtcbiAgY3NzLFxuICBDU1NSZXN1bHRHcm91cCxcbiAgaHRtbCxcbiAgTGl0RWxlbWVudCxcbiAgUHJvcGVydHlWYWx1ZXMsXG4gIFRlbXBsYXRlUmVzdWx0LFxufSBmcm9tIFwibGl0XCI7XG5pbXBvcnQgeyBjdXN0b21FbGVtZW50LCBwcm9wZXJ0eSwgc3RhdGUgfSBmcm9tIFwibGl0L2RlY29yYXRvcnNcIjtcbmltcG9ydCBtZW1vaXplT25lIGZyb20gXCJtZW1vaXplLW9uZVwiO1xuaW1wb3J0IHsgc3RvcFByb3BhZ2F0aW9uIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9kb20vc3RvcF9wcm9wYWdhdGlvblwiO1xuaW1wb3J0IHsgc3VwcG9ydHNGZWF0dXJlIH0gZnJvbSBcIi4uLy4uLy4uL2NvbW1vbi9lbnRpdHkvc3VwcG9ydHMtZmVhdHVyZVwiO1xuaW1wb3J0IFwiLi4vLi4vLi4vY29tcG9uZW50cy9oYS1hdHRyaWJ1dGVzXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLWJ1dHRvbi10b2dnbGUtZ3JvdXBcIjtcbmltcG9ydCBcIi4uLy4uLy4uL2NvbXBvbmVudHMvaGEtY29sb3ItcGlja2VyXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLWljb24tYnV0dG9uXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLWxhYmVsZWQtc2xpZGVyXCI7XG5pbXBvcnQgXCIuLi8uLi8uLi9jb21wb25lbnRzL2hhLXNlbGVjdFwiO1xuaW1wb3J0IHtcbiAgZ2V0TGlnaHRDdXJyZW50TW9kZVJnYkNvbG9yLFxuICBMaWdodENvbG9yTW9kZXMsXG4gIExpZ2h0RW50aXR5LFxuICBsaWdodElzSW5Db2xvck1vZGUsXG4gIGxpZ2h0U3VwcG9ydHNDb2xvcixcbiAgbGlnaHRTdXBwb3J0c0NvbG9yTW9kZSxcbiAgbGlnaHRTdXBwb3J0c0RpbW1pbmcsXG4gIFNVUFBPUlRfRUZGRUNULFxufSBmcm9tIFwiLi4vLi4vLi4vZGF0YS9saWdodFwiO1xuaW1wb3J0IHR5cGUgeyBIb21lQXNzaXN0YW50IH0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzXCI7XG5cbkBjdXN0b21FbGVtZW50KFwibW9yZS1pbmZvLWxpZ2h0XCIpXG5jbGFzcyBNb3JlSW5mb0xpZ2h0IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIGhhc3MhOiBIb21lQXNzaXN0YW50O1xuXG4gIEBwcm9wZXJ0eSh7IGF0dHJpYnV0ZTogZmFsc2UgfSkgcHVibGljIHN0YXRlT2JqPzogTGlnaHRFbnRpdHk7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfYnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gMDtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9jdFNsaWRlclZhbHVlPzogbnVtYmVyO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2N3U2xpZGVyVmFsdWU/OiBudW1iZXI7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfd3dTbGlkZXJWYWx1ZT86IG51bWJlcjtcblxuICBAc3RhdGUoKSBwcml2YXRlIF93dlNsaWRlclZhbHVlPzogbnVtYmVyO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlPzogbnVtYmVyO1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX2JyaWdodG5lc3NBZGp1c3RlZD86IG51bWJlcjtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9odWVTZWdtZW50cyA9IDI0O1xuXG4gIEBzdGF0ZSgpIHByaXZhdGUgX3NhdHVyYXRpb25TZWdtZW50cyA9IDg7XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfY29sb3JQaWNrZXJDb2xvcj86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9tb2RlPzogXCJjb2xvclwiIHwgTGlnaHRDb2xvck1vZGVzO1xuXG4gIHByb3RlY3RlZCByZW5kZXIoKTogVGVtcGxhdGVSZXN1bHQge1xuICAgIGlmICghdGhpcy5oYXNzIHx8ICF0aGlzLnN0YXRlT2JqKSB7XG4gICAgICByZXR1cm4gaHRtbGBgO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cHBvcnRzVGVtcCA9IGxpZ2h0U3VwcG9ydHNDb2xvck1vZGUoXG4gICAgICB0aGlzLnN0YXRlT2JqLFxuICAgICAgTGlnaHRDb2xvck1vZGVzLkNPTE9SX1RFTVBcbiAgICApO1xuXG4gICAgY29uc3Qgc3VwcG9ydHNXaGl0ZSA9IGxpZ2h0U3VwcG9ydHNDb2xvck1vZGUoXG4gICAgICB0aGlzLnN0YXRlT2JqLFxuICAgICAgTGlnaHRDb2xvck1vZGVzLldISVRFXG4gICAgKTtcblxuICAgIGNvbnN0IHN1cHBvcnRzUmdid3cgPSBsaWdodFN1cHBvcnRzQ29sb3JNb2RlKFxuICAgICAgdGhpcy5zdGF0ZU9iaixcbiAgICAgIExpZ2h0Q29sb3JNb2Rlcy5SR0JXV1xuICAgICk7XG5cbiAgICBjb25zdCBzdXBwb3J0c1JnYncgPVxuICAgICAgIXN1cHBvcnRzUmdid3cgJiZcbiAgICAgIGxpZ2h0U3VwcG9ydHNDb2xvck1vZGUodGhpcy5zdGF0ZU9iaiwgTGlnaHRDb2xvck1vZGVzLlJHQlcpO1xuXG4gICAgY29uc3Qgc3VwcG9ydHNDb2xvciA9XG4gICAgICBzdXBwb3J0c1JnYnd3IHx8IHN1cHBvcnRzUmdidyB8fCBsaWdodFN1cHBvcnRzQ29sb3IodGhpcy5zdGF0ZU9iaik7XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICR7bGlnaHRTdXBwb3J0c0RpbW1pbmcodGhpcy5zdGF0ZU9iailcbiAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgIDxoYS1sYWJlbGVkLXNsaWRlclxuICAgICAgICAgICAgICAgIGNhcHRpb249JHt0aGlzLmhhc3MubG9jYWxpemUoXCJ1aS5jYXJkLmxpZ2h0LmJyaWdodG5lc3NcIil9XG4gICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6YnJpZ2h0bmVzcy01XCJcbiAgICAgICAgICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgIHZhbHVlPSR7dGhpcy5fYnJpZ2h0bmVzc1NsaWRlclZhbHVlfVxuICAgICAgICAgICAgICAgIEBjaGFuZ2U9JHt0aGlzLl9icmlnaHRuZXNzU2xpZGVyQ2hhbmdlZH1cbiAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgPjwvaGEtbGFiZWxlZC1zbGlkZXI+XG4gICAgICAgICAgICBgXG4gICAgICAgICAgOiBcIlwifVxuICAgICAgICAke3RoaXMuc3RhdGVPYmouc3RhdGUgPT09IFwib25cIlxuICAgICAgICAgID8gaHRtbGBcbiAgICAgICAgICAgICAgJHtzdXBwb3J0c1RlbXAgfHwgc3VwcG9ydHNDb2xvciA/IGh0bWxgPGhyIC8+YCA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNUZW1wIHx8IHN1cHBvcnRzV2hpdGUpXG4gICAgICAgICAgICAgICAgPyBodG1sYDxoYS1idXR0b24tdG9nZ2xlLWdyb3VwXG4gICAgICAgICAgICAgICAgICAgIGZ1bGxXaWR0aFxuICAgICAgICAgICAgICAgICAgICAuYnV0dG9ucz0ke3RoaXMuX3RvZ2dsZUJ1dHRvbnMoc3VwcG9ydHNUZW1wLCBzdXBwb3J0c1doaXRlKX1cbiAgICAgICAgICAgICAgICAgICAgLmFjdGl2ZT0ke3RoaXMuX21vZGV9XG4gICAgICAgICAgICAgICAgICAgIEB2YWx1ZS1jaGFuZ2VkPSR7dGhpcy5fbW9kZUNoYW5nZWR9XG4gICAgICAgICAgICAgICAgICA+PC9oYS1idXR0b24tdG9nZ2xlLWdyb3VwPmBcbiAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNUZW1wICYmXG4gICAgICAgICAgICAgICgoIXN1cHBvcnRzQ29sb3IgJiYgIXN1cHBvcnRzV2hpdGUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9PT0gTGlnaHRDb2xvck1vZGVzLkNPTE9SX1RFTVApXG4gICAgICAgICAgICAgICAgPyBodG1sYFxuICAgICAgICAgICAgICAgICAgICA8aGEtbGFiZWxlZC1zbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbG9yX3RlbXBcIlxuICAgICAgICAgICAgICAgICAgICAgIGNhcHRpb249JHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgICAgICAgICAgICBcInVpLmNhcmQubGlnaHQuY29sb3JfdGVtcGVyYXR1cmVcIlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6dGhlcm1vbWV0ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgIC5taW49JHt0aGlzLnN0YXRlT2JqLmF0dHJpYnV0ZXMubWluX21pcmVkc31cbiAgICAgICAgICAgICAgICAgICAgICAubWF4PSR7dGhpcy5zdGF0ZU9iai5hdHRyaWJ1dGVzLm1heF9taXJlZHN9XG4gICAgICAgICAgICAgICAgICAgICAgLnZhbHVlPSR7dGhpcy5fY3RTbGlkZXJWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPSR7dGhpcy5fY3RTbGlkZXJDaGFuZ2VkfVxuICAgICAgICAgICAgICAgICAgICAgIHBpblxuICAgICAgICAgICAgICAgICAgICA+PC9oYS1sYWJlbGVkLXNsaWRlcj5cbiAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNDb2xvciAmJlxuICAgICAgICAgICAgICAoKCFzdXBwb3J0c1RlbXAgJiYgIXN1cHBvcnRzV2hpdGUpIHx8IHRoaXMuX21vZGUgPT09IFwiY29sb3JcIilcbiAgICAgICAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWdtZW50YXRpb25Db250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8aGEtY29sb3ItcGlja2VyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImNvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIEBjb2xvcnNlbGVjdGVkPSR7dGhpcy5fY29sb3JQaWNrZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAuZGVzaXJlZFJnYkNvbG9yPSR7dGhpcy5fY29sb3JQaWNrZXJDb2xvcn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlPVwiNTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odWVTZWdtZW50cz0ke3RoaXMuX2h1ZVNlZ21lbnRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNhdHVyYXRpb25TZWdtZW50cz0ke3RoaXMuX3NhdHVyYXRpb25TZWdtZW50c31cbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgPC9oYS1jb2xvci1waWNrZXI+XG4gICAgICAgICAgICAgICAgICAgICAgPGhhLWljb24tYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAucGF0aD0ke21kaVBhbGV0dGV9XG4gICAgICAgICAgICAgICAgICAgICAgICBAY2xpY2s9JHt0aGlzLl9zZWdtZW50Q2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInNlZ21lbnRhdGlvbkJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgPjwvaGEtaWNvbi1idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICR7c3VwcG9ydHNSZ2J3IHx8IHN1cHBvcnRzUmdid3dcbiAgICAgICAgICAgICAgICAgICAgICA/IGh0bWxgPGhhLWxhYmVsZWQtc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXB0aW9uPSR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidWkuY2FyZC5saWdodC5jb2xvcl9icmlnaHRuZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6YnJpZ2h0bmVzcy03XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnZhbHVlPSR7dGhpcy5fY29sb3JCcmlnaHRuZXNzU2xpZGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIEBjaGFuZ2U9JHt0aGlzLl9jb2xvckJyaWdodG5lc3NTbGlkZXJDaGFuZ2VkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgICAgICAgICAgID48L2hhLWxhYmVsZWQtc2xpZGVyPmBcbiAgICAgICAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgICAgICR7c3VwcG9ydHNSZ2J3XG4gICAgICAgICAgICAgICAgICAgICAgPyBodG1sYFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8aGEtbGFiZWxlZC1zbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FwdGlvbj0ke3RoaXMuaGFzcy5sb2NhbGl6ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidWkuY2FyZC5saWdodC53aGl0ZV92YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiaGFzczpmaWxlLXdvcmQtYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uYW1lPSR7XCJ3dlwifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZT0ke3RoaXMuX3d2U2xpZGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNoYW5nZT0ke3RoaXMuX3d2U2xpZGVyQ2hhbmdlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaGEtbGFiZWxlZC1zbGlkZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgICAgICAgOiBcIlwifVxuICAgICAgICAgICAgICAgICAgICAke3N1cHBvcnRzUmdid3dcbiAgICAgICAgICAgICAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxoYS1sYWJlbGVkLXNsaWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXB0aW9uPSR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1aS5jYXJkLmxpZ2h0LmNvbGRfd2hpdGVfdmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6ZmlsZS13b3JkLWJveC1vdXRsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCIxMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5uYW1lPSR7XCJjd1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC52YWx1ZT0ke3RoaXMuX2N3U2xpZGVyVmFsdWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGNoYW5nZT0ke3RoaXMuX3d2U2xpZGVyQ2hhbmdlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaGEtbGFiZWxlZC1zbGlkZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxoYS1sYWJlbGVkLXNsaWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXB0aW9uPSR7dGhpcy5oYXNzLmxvY2FsaXplKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1aS5jYXJkLmxpZ2h0Lndhcm1fd2hpdGVfdmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImhhc3M6ZmlsZS13b3JkLWJveFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMTAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubmFtZT0ke1wid3dcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFsdWU9JHt0aGlzLl93d1NsaWRlclZhbHVlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBjaGFuZ2U9JHt0aGlzLl93dlNsaWRlckNoYW5nZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgID48L2hhLWxhYmVsZWQtc2xpZGVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgIDogXCJcIn1cbiAgICAgICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7c3VwcG9ydHNGZWF0dXJlKHRoaXMuc3RhdGVPYmosIFNVUFBPUlRfRUZGRUNUKSAmJlxuICAgICAgICAgICAgICB0aGlzLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLmVmZmVjdF9saXN0Py5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IGh0bWxgXG4gICAgICAgICAgICAgICAgICAgIDxociAvPlxuICAgICAgICAgICAgICAgICAgICA8aGEtc2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICAgLmxhYmVsPSR7dGhpcy5oYXNzLmxvY2FsaXplKFwidWkuY2FyZC5saWdodC5lZmZlY3RcIil9XG4gICAgICAgICAgICAgICAgICAgICAgLnZhbHVlPSR7dGhpcy5zdGF0ZU9iai5hdHRyaWJ1dGVzLmVmZmVjdCB8fCBcIlwifVxuICAgICAgICAgICAgICAgICAgICAgIGZpeGVkTWVudVBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgbmF0dXJhbE1lbnVXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgIEBzZWxlY3RlZD0ke3RoaXMuX2VmZmVjdENoYW5nZWR9XG4gICAgICAgICAgICAgICAgICAgICAgQGNsb3NlZD0ke3N0b3BQcm9wYWdhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICR7dGhpcy5zdGF0ZU9iai5hdHRyaWJ1dGVzLmVmZmVjdF9saXN0Lm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlZmZlY3Q6IHN0cmluZykgPT4gaHRtbGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPG13Yy1saXN0LWl0ZW0gLnZhbHVlPSR7ZWZmZWN0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2VmZmVjdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9td2MtbGlzdC1pdGVtPlxuICAgICAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvaGEtc2VsZWN0PlxuICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIDogXCJcIn1cbiAgICAgICAgICAgIGBcbiAgICAgICAgICA6IFwiXCJ9XG4gICAgICAgIDxoYS1hdHRyaWJ1dGVzXG4gICAgICAgICAgLmhhc3M9JHt0aGlzLmhhc3N9XG4gICAgICAgICAgLnN0YXRlT2JqPSR7dGhpcy5zdGF0ZU9ian1cbiAgICAgICAgICBleHRyYS1maWx0ZXJzPVwiYnJpZ2h0bmVzcyxjb2xvcl90ZW1wLHdoaXRlX3ZhbHVlLGVmZmVjdF9saXN0LGVmZmVjdCxoc19jb2xvcixyZ2JfY29sb3Iscmdid19jb2xvcixyZ2J3d19jb2xvcix4eV9jb2xvcixtaW5fbWlyZWRzLG1heF9taXJlZHMsZW50aXR5X2lkLHN1cHBvcnRlZF9jb2xvcl9tb2Rlcyxjb2xvcl9tb2RlXCJcbiAgICAgICAgPjwvaGEtYXR0cmlidXRlcz5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBwdWJsaWMgd2lsbFVwZGF0ZShjaGFuZ2VkUHJvcHM6IFByb3BlcnR5VmFsdWVzPHRoaXM+KSB7XG4gICAgc3VwZXIud2lsbFVwZGF0ZShjaGFuZ2VkUHJvcHMpO1xuXG4gICAgaWYgKCFjaGFuZ2VkUHJvcHMuaGFzKFwic3RhdGVPYmpcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGVPYmogPSB0aGlzLnN0YXRlT2JqISBhcyBMaWdodEVudGl0eTtcbiAgICBjb25zdCBvbGRTdGF0ZU9iaiA9IGNoYW5nZWRQcm9wcy5nZXQoXCJzdGF0ZU9ialwiKSBhcyBMaWdodEVudGl0eSB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChzdGF0ZU9iai5zdGF0ZSA9PT0gXCJvblwiKSB7XG4gICAgICAvLyBEb24ndCBjaGFuZ2UgdGFiIHdoZW4gdGhlIGNvbG9yIG1vZGUgY2hhbmdlc1xuICAgICAgaWYgKFxuICAgICAgICBvbGRTdGF0ZU9iaj8uZW50aXR5X2lkICE9PSBzdGF0ZU9iai5lbnRpdHlfaWQgfHxcbiAgICAgICAgb2xkU3RhdGVPYmo/LnN0YXRlICE9PSBzdGF0ZU9iai5zdGF0ZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX21vZGUgPSBsaWdodElzSW5Db2xvck1vZGUodGhpcy5zdGF0ZU9iaiEpXG4gICAgICAgICAgPyBcImNvbG9yXCJcbiAgICAgICAgICA6IHRoaXMuc3RhdGVPYmohLmF0dHJpYnV0ZXMuY29sb3JfbW9kZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJyaWdodG5lc3NBZGp1c3QgPSAxMDA7XG4gICAgICB0aGlzLl9icmlnaHRuZXNzQWRqdXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlT2JqLmF0dHJpYnV0ZXMuY29sb3JfbW9kZSA9PT0gTGlnaHRDb2xvck1vZGVzLlJHQiAmJlxuICAgICAgICAhbGlnaHRTdXBwb3J0c0NvbG9yTW9kZShzdGF0ZU9iaiwgTGlnaHRDb2xvck1vZGVzLlJHQldXKSAmJlxuICAgICAgICAhbGlnaHRTdXBwb3J0c0NvbG9yTW9kZShzdGF0ZU9iaiwgTGlnaHRDb2xvck1vZGVzLlJHQlcpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgbWF4VmFsID0gTWF0aC5tYXgoLi4uc3RhdGVPYmouYXR0cmlidXRlcy5yZ2JfY29sb3IpO1xuICAgICAgICBpZiAobWF4VmFsIDwgMjU1KSB7XG4gICAgICAgICAgdGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkID0gbWF4VmFsO1xuICAgICAgICAgIGJyaWdodG5lc3NBZGp1c3QgPSAodGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkIC8gMjU1KSAqIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gTWF0aC5yb3VuZChcbiAgICAgICAgKHN0YXRlT2JqLmF0dHJpYnV0ZXMuYnJpZ2h0bmVzcyAqIGJyaWdodG5lc3NBZGp1c3QpIC8gMjU1XG4gICAgICApO1xuICAgICAgdGhpcy5fY3RTbGlkZXJWYWx1ZSA9IHN0YXRlT2JqLmF0dHJpYnV0ZXMuY29sb3JfdGVtcDtcbiAgICAgIHRoaXMuX3d2U2xpZGVyVmFsdWUgPVxuICAgICAgICBzdGF0ZU9iai5hdHRyaWJ1dGVzLmNvbG9yX21vZGUgPT09IExpZ2h0Q29sb3JNb2Rlcy5SR0JXXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChzdGF0ZU9iai5hdHRyaWJ1dGVzLnJnYndfY29sb3JbM10gKiAxMDApIC8gMjU1KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY3dTbGlkZXJWYWx1ZSA9XG4gICAgICAgIHN0YXRlT2JqLmF0dHJpYnV0ZXMuY29sb3JfbW9kZSA9PT0gTGlnaHRDb2xvck1vZGVzLlJHQldXXG4gICAgICAgICAgPyBNYXRoLnJvdW5kKChzdGF0ZU9iai5hdHRyaWJ1dGVzLnJnYnd3X2NvbG9yWzNdICogMTAwKSAvIDI1NSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3d3U2xpZGVyVmFsdWUgPVxuICAgICAgICBzdGF0ZU9iai5hdHRyaWJ1dGVzLmNvbG9yX21vZGUgPT09IExpZ2h0Q29sb3JNb2Rlcy5SR0JXV1xuICAgICAgICAgID8gTWF0aC5yb3VuZCgoc3RhdGVPYmouYXR0cmlidXRlcy5yZ2J3d19jb2xvcls0XSAqIDEwMCkgLyAyNTUpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRSZ2JDb2xvciA9IGdldExpZ2h0Q3VycmVudE1vZGVSZ2JDb2xvcihzdGF0ZU9iaik7XG5cbiAgICAgIHRoaXMuX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gY3VycmVudFJnYkNvbG9yXG4gICAgICAgID8gTWF0aC5yb3VuZCgoTWF0aC5tYXgoLi4uY3VycmVudFJnYkNvbG9yLnNsaWNlKDAsIDMpKSAqIDEwMCkgLyAyNTUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLl9jb2xvclBpY2tlckNvbG9yID0gY3VycmVudFJnYkNvbG9yPy5zbGljZSgwLCAzKSBhcyBbXG4gICAgICAgIG51bWJlcixcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBudW1iZXJcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JyaWdodG5lc3NTbGlkZXJWYWx1ZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdG9nZ2xlQnV0dG9ucyA9IG1lbW9pemVPbmUoXG4gICAgKHN1cHBvcnRzVGVtcDogYm9vbGVhbiwgc3VwcG9ydHNXaGl0ZTogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgbW9kZXMgPSBbeyBsYWJlbDogXCJDb2xvclwiLCB2YWx1ZTogXCJjb2xvclwiIH1dO1xuICAgICAgaWYgKHN1cHBvcnRzVGVtcCkge1xuICAgICAgICBtb2Rlcy5wdXNoKHsgbGFiZWw6IFwiVGVtcGVyYXR1cmVcIiwgdmFsdWU6IExpZ2h0Q29sb3JNb2Rlcy5DT0xPUl9URU1QIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzV2hpdGUpIHtcbiAgICAgICAgbW9kZXMucHVzaCh7IGxhYmVsOiBcIldoaXRlXCIsIHZhbHVlOiBMaWdodENvbG9yTW9kZXMuV0hJVEUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZXM7XG4gICAgfVxuICApO1xuXG4gIHByaXZhdGUgX21vZGVDaGFuZ2VkKGV2OiBDdXN0b21FdmVudCkge1xuICAgIHRoaXMuX21vZGUgPSBldi5kZXRhaWwudmFsdWU7XG4gIH1cblxuICBwcml2YXRlIF9lZmZlY3RDaGFuZ2VkKGV2KSB7XG4gICAgY29uc3QgbmV3VmFsID0gZXYudGFyZ2V0LnZhbHVlO1xuXG4gICAgaWYgKCFuZXdWYWwgfHwgdGhpcy5zdGF0ZU9iaiEuYXR0cmlidXRlcy5lZmZlY3QgPT09IG5ld1ZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICBlbnRpdHlfaWQ6IHRoaXMuc3RhdGVPYmohLmVudGl0eV9pZCxcbiAgICAgIGVmZmVjdDogbmV3VmFsLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfYnJpZ2h0bmVzc1NsaWRlckNoYW5nZWQoZXY6IEN1c3RvbUV2ZW50KSB7XG4gICAgY29uc3QgYnJpID0gTnVtYmVyKChldi50YXJnZXQgYXMgYW55KS52YWx1ZSk7XG5cbiAgICBpZiAoaXNOYU4oYnJpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2JyaWdodG5lc3NTbGlkZXJWYWx1ZSA9IGJyaTtcblxuICAgIGlmICh0aGlzLl9tb2RlID09PSBMaWdodENvbG9yTW9kZXMuV0hJVEUpIHtcbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICB3aGl0ZTogTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKChicmkgKiAyNTUpIC8gMTAwKSksXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkKSB7XG4gICAgICBjb25zdCByZ2IgPVxuICAgICAgICB0aGlzLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLnJnYl9jb2xvciB8fFxuICAgICAgICAoWzAsIDAsIDBdIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk7XG5cbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICBicmlnaHRuZXNzX3BjdDogYnJpLFxuICAgICAgICByZ2JfY29sb3I6IHRoaXMuX2FkanVzdENvbG9yQnJpZ2h0bmVzcyhcbiAgICAgICAgICByZ2IsXG4gICAgICAgICAgdGhpcy5fYnJpZ2h0bmVzc0FkanVzdGVkLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICBlbnRpdHlfaWQ6IHRoaXMuc3RhdGVPYmohLmVudGl0eV9pZCxcbiAgICAgIGJyaWdodG5lc3NfcGN0OiBicmksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9jdFNsaWRlckNoYW5nZWQoZXY6IEN1c3RvbUV2ZW50KSB7XG4gICAgY29uc3QgY3QgPSBOdW1iZXIoKGV2LnRhcmdldCBhcyBhbnkpLnZhbHVlKTtcblxuICAgIGlmIChpc05hTihjdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdFNsaWRlclZhbHVlID0gY3Q7XG5cbiAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICBjb2xvcl90ZW1wOiBjdCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX3d2U2xpZGVyQ2hhbmdlZChldjogQ3VzdG9tRXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldi50YXJnZXQgYXMgYW55O1xuICAgIGxldCB3diA9IE51bWJlcih0YXJnZXQudmFsdWUpO1xuICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubmFtZTtcblxuICAgIGlmIChpc05hTih3dikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ3dlwiKSB7XG4gICAgICB0aGlzLl93dlNsaWRlclZhbHVlID0gd3Y7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcImN3XCIpIHtcbiAgICAgIHRoaXMuX2N3U2xpZGVyVmFsdWUgPSB3djtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwid3dcIikge1xuICAgICAgdGhpcy5fd3dTbGlkZXJWYWx1ZSA9IHd2O1xuICAgIH1cblxuICAgIHd2ID0gTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKCh3diAqIDI1NSkgLyAxMDApKTtcblxuICAgIGNvbnN0IHJnYiA9IGdldExpZ2h0Q3VycmVudE1vZGVSZ2JDb2xvcih0aGlzLnN0YXRlT2JqISk7XG5cbiAgICBpZiAobmFtZSA9PT0gXCJ3dlwiKSB7XG4gICAgICBjb25zdCByZ2J3X2NvbG9yID0gcmdiIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIHJnYndfY29sb3JbM10gPSB3djtcbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICByZ2J3X2NvbG9yLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgcmdid3dfY29sb3IgPSByZ2IgfHwgWzAsIDAsIDAsIDAsIDBdO1xuICAgIHdoaWxlIChyZ2J3d19jb2xvci5sZW5ndGggPCA1KSB7XG4gICAgICByZ2J3d19jb2xvci5wdXNoKDApO1xuICAgIH1cbiAgICByZ2J3d19jb2xvcltuYW1lID09PSBcImN3XCIgPyAzIDogNF0gPSB3djtcbiAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICByZ2J3d19jb2xvcixcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbG9yQnJpZ2h0bmVzc1NsaWRlckNoYW5nZWQoZXY6IEN1c3RvbUV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXYudGFyZ2V0IGFzIGFueTtcbiAgICBsZXQgdmFsdWUgPSBOdW1iZXIodGFyZ2V0LnZhbHVlKTtcblxuICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlO1xuICAgIHRoaXMuX2NvbG9yQnJpZ2h0bmVzc1NsaWRlclZhbHVlID0gdmFsdWU7XG5cbiAgICB2YWx1ZSA9ICh2YWx1ZSAqIDI1NSkgLyAxMDA7XG5cbiAgICBjb25zdCByZ2IgPSAoZ2V0TGlnaHRDdXJyZW50TW9kZVJnYkNvbG9yKHRoaXMuc3RhdGVPYmohKT8uc2xpY2UoMCwgMykgfHwgW1xuICAgICAgMjU1LCAyNTUsIDI1NSxcbiAgICBdKSBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgICB0aGlzLl9zZXRSZ2JXQ29sb3IoXG4gICAgICB0aGlzLl9hZGp1c3RDb2xvckJyaWdodG5lc3MoXG4gICAgICAgIC8vIGZpcnN0IG5vcm1hbGl6ZSB0aGUgdmFsdWVcbiAgICAgICAgb2xkVmFsdWVcbiAgICAgICAgICA/IHRoaXMuX2FkanVzdENvbG9yQnJpZ2h0bmVzcyhyZ2IsIChvbGRWYWx1ZSAqIDI1NSkgLyAxMDAsIHRydWUpXG4gICAgICAgICAgOiByZ2IsXG4gICAgICAgIHZhbHVlXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NlZ21lbnRDbGljaygpIHtcbiAgICBpZiAodGhpcy5faHVlU2VnbWVudHMgPT09IDI0ICYmIHRoaXMuX3NhdHVyYXRpb25TZWdtZW50cyA9PT0gOCkge1xuICAgICAgdGhpcy5faHVlU2VnbWVudHMgPSAwO1xuICAgICAgdGhpcy5fc2F0dXJhdGlvblNlZ21lbnRzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faHVlU2VnbWVudHMgPSAyNDtcbiAgICAgIHRoaXMuX3NhdHVyYXRpb25TZWdtZW50cyA9IDg7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfYWRqdXN0Q29sb3JCcmlnaHRuZXNzKFxuICAgIHJnYkNvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgdmFsdWU/OiBudW1iZXIsXG4gICAgaW52ZXJ0ID0gZmFsc2VcbiAgKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IDI1NSkge1xuICAgICAgbGV0IHJhdGlvID0gdmFsdWUgLyAyNTU7XG4gICAgICBpZiAoaW52ZXJ0KSB7XG4gICAgICAgIHJhdGlvID0gMSAvIHJhdGlvO1xuICAgICAgfVxuICAgICAgcmdiQ29sb3JbMF0gPSBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocmdiQ29sb3JbMF0gKiByYXRpbykpO1xuICAgICAgcmdiQ29sb3JbMV0gPSBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocmdiQ29sb3JbMV0gKiByYXRpbykpO1xuICAgICAgcmdiQ29sb3JbMl0gPSBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQocmdiQ29sb3JbMl0gKiByYXRpbykpO1xuICAgIH1cbiAgICByZXR1cm4gcmdiQ29sb3I7XG4gIH1cblxuICBwcml2YXRlIF9zZXRSZ2JXQ29sb3IocmdiQ29sb3I6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSkge1xuICAgIGlmIChsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCV1cpKSB7XG4gICAgICBjb25zdCByZ2J3d19jb2xvcjogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSA9IHRoaXNcbiAgICAgICAgLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLnJnYnd3X2NvbG9yXG4gICAgICAgID8gWy4uLnRoaXMuc3RhdGVPYmohLmF0dHJpYnV0ZXMucmdid3dfY29sb3JdXG4gICAgICAgIDogWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgdGhpcy5oYXNzLmNhbGxTZXJ2aWNlKFwibGlnaHRcIiwgXCJ0dXJuX29uXCIsIHtcbiAgICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICAgIHJnYnd3X2NvbG9yOiByZ2JDb2xvci5jb25jYXQocmdid3dfY29sb3Iuc2xpY2UoMykpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCVykpIHtcbiAgICAgIGNvbnN0IHJnYndfY29sb3I6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID0gdGhpcy5zdGF0ZU9iaiFcbiAgICAgICAgLmF0dHJpYnV0ZXMucmdid19jb2xvclxuICAgICAgICA/IFsuLi50aGlzLnN0YXRlT2JqIS5hdHRyaWJ1dGVzLnJnYndfY29sb3JdXG4gICAgICAgIDogWzAsIDAsIDAsIDBdO1xuICAgICAgdGhpcy5oYXNzLmNhbGxTZXJ2aWNlKFwibGlnaHRcIiwgXCJ0dXJuX29uXCIsIHtcbiAgICAgICAgZW50aXR5X2lkOiB0aGlzLnN0YXRlT2JqIS5lbnRpdHlfaWQsXG4gICAgICAgIHJnYndfY29sb3I6IHJnYkNvbG9yLmNvbmNhdChyZ2J3X2NvbG9yLnNsaWNlKDMpKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIG5ldyBjb2xvciBoYXMgYmVlbiBwaWNrZWQuXG4gICAqIHNob3VsZCBiZSB0aHJvdHRsZWQgd2l0aCB0aGUgJ3Rocm90dGxlPScgYXR0cmlidXRlIG9mIHRoZSBjb2xvciBwaWNrZXJcbiAgICovXG4gIHByaXZhdGUgX2NvbG9yUGlja2VkKFxuICAgIGV2OiBDdXN0b21FdmVudDx7XG4gICAgICBoczogeyBoOiBudW1iZXI7IHM6IG51bWJlciB9O1xuICAgICAgcmdiOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfTtcbiAgICB9PlxuICApIHtcbiAgICB0aGlzLl9jb2xvclBpY2tlckNvbG9yID0gW1xuICAgICAgZXYuZGV0YWlsLnJnYi5yLFxuICAgICAgZXYuZGV0YWlsLnJnYi5nLFxuICAgICAgZXYuZGV0YWlsLnJnYi5iLFxuICAgIF07XG5cbiAgICBpZiAoXG4gICAgICBsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCV1cpIHx8XG4gICAgICBsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCVylcbiAgICApIHtcbiAgICAgIHRoaXMuX3NldFJnYldDb2xvcihcbiAgICAgICAgdGhpcy5fY29sb3JCcmlnaHRuZXNzU2xpZGVyVmFsdWVcbiAgICAgICAgICA/IHRoaXMuX2FkanVzdENvbG9yQnJpZ2h0bmVzcyhcbiAgICAgICAgICAgICAgW2V2LmRldGFpbC5yZ2IuciwgZXYuZGV0YWlsLnJnYi5nLCBldi5kZXRhaWwucmdiLmJdLFxuICAgICAgICAgICAgICAodGhpcy5fY29sb3JCcmlnaHRuZXNzU2xpZGVyVmFsdWUgKiAyNTUpIC8gMTAwXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiBbZXYuZGV0YWlsLnJnYi5yLCBldi5kZXRhaWwucmdiLmcsIGV2LmRldGFpbC5yZ2IuYl1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChsaWdodFN1cHBvcnRzQ29sb3JNb2RlKHRoaXMuc3RhdGVPYmohLCBMaWdodENvbG9yTW9kZXMuUkdCKSkge1xuICAgICAgY29uc3QgcmdiX2NvbG9yOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPSBbXG4gICAgICAgIGV2LmRldGFpbC5yZ2IucixcbiAgICAgICAgZXYuZGV0YWlsLnJnYi5nLFxuICAgICAgICBldi5kZXRhaWwucmdiLmIsXG4gICAgICBdO1xuICAgICAgaWYgKHRoaXMuX2JyaWdodG5lc3NBZGp1c3RlZCkge1xuICAgICAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICAgIGJyaWdodG5lc3NfcGN0OiB0aGlzLl9icmlnaHRuZXNzU2xpZGVyVmFsdWUsXG4gICAgICAgICAgcmdiX2NvbG9yOiB0aGlzLl9hZGp1c3RDb2xvckJyaWdodG5lc3MoXG4gICAgICAgICAgICByZ2JfY29sb3IsXG4gICAgICAgICAgICB0aGlzLl9icmlnaHRuZXNzQWRqdXN0ZWQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhc3MuY2FsbFNlcnZpY2UoXCJsaWdodFwiLCBcInR1cm5fb25cIiwge1xuICAgICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICAgIHJnYl9jb2xvcixcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzcy5jYWxsU2VydmljZShcImxpZ2h0XCIsIFwidHVybl9vblwiLCB7XG4gICAgICAgIGVudGl0eV9pZDogdGhpcy5zdGF0ZU9iaiEuZW50aXR5X2lkLFxuICAgICAgICBoc19jb2xvcjogW2V2LmRldGFpbC5ocy5oLCBldi5kZXRhaWwuaHMucyAqIDEwMF0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0eWxlcygpOiBDU1NSZXN1bHRHcm91cCB7XG4gICAgcmV0dXJuIGNzc2BcbiAgICAgIC5jb250ZW50IHtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIH1cblxuICAgICAgLmNvbnRlbnQgPiAqIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgIC5jb2xvcl90ZW1wIHtcbiAgICAgICAgLS1oYS1zbGlkZXItYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgcmdiKDI1NSwgMTYwLCAwKSAwJSxcbiAgICAgICAgICB3aGl0ZSA1MCUsXG4gICAgICAgICAgcmdiKDE2NiwgMjA5LCAyNTUpIDEwMCVcbiAgICAgICAgKTtcbiAgICAgICAgLyogVGhlIGNvbG9yIHRlbXAgbWluaW11bSB2YWx1ZSBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgZGlmZmVyZW50bHkuIEl0J3Mgbm90IFwib2ZmXCIuICovXG4gICAgICAgIC0tcGFwZXItc2xpZGVyLWtub2Itc3RhcnQtYm9yZGVyLWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogNHB4O1xuICAgICAgfVxuXG4gICAgICAuc2VnbWVudGF0aW9uQ29udGFpbmVyIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXgtaGVpZ2h0OiA1MDBweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICB9XG5cbiAgICAgIGhhLWJ1dHRvbi10b2dnbGUtZ3JvdXAge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG4gICAgICB9XG5cbiAgICAgIGhhLWNvbG9yLXBpY2tlciB7XG4gICAgICAgIC0taGEtY29sb3ItcGlja2VyLXdoZWVsLWJvcmRlcndpZHRoOiA1O1xuICAgICAgICAtLWhhLWNvbG9yLXBpY2tlci13aGVlbC1ib3JkZXJjb2xvcjogd2hpdGU7XG4gICAgICAgIC0taGEtY29sb3ItcGlja2VyLXdoZWVsLXNoYWRvdzogbm9uZTtcbiAgICAgICAgLS1oYS1jb2xvci1waWNrZXItbWFya2VyLWJvcmRlcndpZHRoOiAyO1xuICAgICAgICAtLWhhLWNvbG9yLXBpY2tlci1tYXJrZXItYm9yZGVyY29sb3I6IHdoaXRlO1xuICAgICAgfVxuXG4gICAgICAuc2VnbWVudGF0aW9uQnV0dG9uIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDUlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBjb2xvcjogdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBociB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tZGl2aWRlci1jb2xvcik7XG4gICAgICAgIGJvcmRlci1ib3R0b206IG5vbmU7XG4gICAgICAgIG1hcmdpbjogMTZweCAwO1xuICAgICAgfVxuICAgIGA7XG4gIH1cbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRUYWdOYW1lTWFwIHtcbiAgICBcIm1vcmUtaW5mby1saWdodFwiOiBNb3JlSW5mb0xpZ2h0O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/dialogs/more-info/controls/more-info-light.ts\n");

/***/ })

}]);