"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_comlink_dist_esm_comlink_mjs"],{

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createEndpoint\": function() { return /* binding */ createEndpoint; },\n/* harmony export */   \"expose\": function() { return /* binding */ expose; },\n/* harmony export */   \"proxy\": function() { return /* binding */ proxy; },\n/* harmony export */   \"proxyMarker\": function() { return /* binding */ proxyMarker; },\n/* harmony export */   \"releaseProxy\": function() { return /* binding */ releaseProxy; },\n/* harmony export */   \"transfer\": function() { return /* binding */ transfer; },\n/* harmony export */   \"transferHandlers\": function() { return /* binding */ transferHandlers; },\n/* harmony export */   \"windowEndpoint\": function() { return /* binding */ windowEndpoint; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Copyright 2019 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar proxyMarker = Symbol(\"Comlink.proxy\");\nvar createEndpoint = Symbol(\"Comlink.endpoint\");\nvar releaseProxy = Symbol(\"Comlink.releaseProxy\");\nvar throwMarker = Symbol(\"Comlink.thrown\");\n\nvar isObject = function isObject(val) {\n  return _typeof(val) === \"object\" && val !== null || typeof val === \"function\";\n};\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\n\n\nvar proxyTransferHandler = {\n  canHandle: function canHandle(val) {\n    return isObject(val) && val[proxyMarker];\n  },\n  serialize: function serialize(obj) {\n    var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1,\n        port2 = _MessageChannel.port2;\n\n    expose(obj, port1);\n    return [port2, [port2]];\n  },\n  deserialize: function deserialize(port) {\n    port.start();\n    return wrap(port);\n  }\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\n\nvar throwTransferHandler = {\n  canHandle: function canHandle(value) {\n    return isObject(value) && throwMarker in value;\n  },\n  serialize: function serialize(_ref) {\n    var value = _ref.value;\n    var serialized;\n\n    if (value instanceof Error) {\n      serialized = {\n        isError: true,\n        value: {\n          message: value.message,\n          name: value.name,\n          stack: value.stack\n        }\n      };\n    } else {\n      serialized = {\n        isError: false,\n        value: value\n      };\n    }\n\n    return [serialized, []];\n  },\n  deserialize: function deserialize(serialized) {\n    if (serialized.isError) {\n      throw Object.assign(new Error(serialized.value.message), serialized.value);\n    }\n\n    throw serialized.value;\n  }\n};\n/**\n * Allows customizing the serialization of certain values.\n */\n\nvar transferHandlers = new Map([[\"proxy\", proxyTransferHandler], [\"throw\", throwTransferHandler]]);\n\nfunction expose(obj) {\n  var ep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : self;\n  ep.addEventListener(\"message\", function callback(ev) {\n    if (!ev || !ev.data) {\n      return;\n    }\n\n    var _Object$assign = Object.assign({\n      path: []\n    }, ev.data),\n        id = _Object$assign.id,\n        type = _Object$assign.type,\n        path = _Object$assign.path;\n\n    var argumentList = (ev.data.argumentList || []).map(fromWireValue);\n    var returnValue;\n\n    try {\n      var parent = path.slice(0, -1).reduce(function (obj, prop) {\n        return obj[prop];\n      }, obj);\n      var rawValue = path.reduce(function (obj, prop) {\n        return obj[prop];\n      }, obj);\n\n      switch (type) {\n        case \"GET\"\n        /* GET */\n        :\n          {\n            returnValue = rawValue;\n          }\n          break;\n\n        case \"SET\"\n        /* SET */\n        :\n          {\n            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n            returnValue = true;\n          }\n          break;\n\n        case \"APPLY\"\n        /* APPLY */\n        :\n          {\n            returnValue = rawValue.apply(parent, argumentList);\n          }\n          break;\n\n        case \"CONSTRUCT\"\n        /* CONSTRUCT */\n        :\n          {\n            var value = _construct(rawValue, _toConsumableArray(argumentList));\n\n            returnValue = proxy(value);\n          }\n          break;\n\n        case \"ENDPOINT\"\n        /* ENDPOINT */\n        :\n          {\n            var _MessageChannel2 = new MessageChannel(),\n                port1 = _MessageChannel2.port1,\n                port2 = _MessageChannel2.port2;\n\n            expose(obj, port2);\n            returnValue = transfer(port1, [port1]);\n          }\n          break;\n\n        case \"RELEASE\"\n        /* RELEASE */\n        :\n          {\n            returnValue = undefined;\n          }\n          break;\n\n        default:\n          return;\n      }\n    } catch (value) {\n      returnValue = _defineProperty({\n        value: value\n      }, throwMarker, 0);\n    }\n\n    Promise.resolve(returnValue)[\"catch\"](function (value) {\n      return _defineProperty({\n        value: value\n      }, throwMarker, 0);\n    }).then(function (returnValue) {\n      var _toWireValue = toWireValue(returnValue),\n          _toWireValue2 = _slicedToArray(_toWireValue, 2),\n          wireValue = _toWireValue2[0],\n          transferables = _toWireValue2[1];\n\n      ep.postMessage(Object.assign(Object.assign({}, wireValue), {\n        id: id\n      }), transferables);\n\n      if (type === \"RELEASE\"\n      /* RELEASE */\n      ) {\n        // detach and deactive after sending release response above.\n        ep.removeEventListener(\"message\", callback);\n        closeEndPoint(ep);\n      }\n    });\n  });\n\n  if (ep.start) {\n    ep.start();\n  }\n}\n\nfunction isMessagePort(endpoint) {\n  return endpoint.constructor.name === \"MessagePort\";\n}\n\nfunction closeEndPoint(endpoint) {\n  if (isMessagePort(endpoint)) endpoint.close();\n}\n\nfunction wrap(ep, target) {\n  return createProxy(ep, [], target);\n}\n\nfunction throwIfProxyReleased(isReleased) {\n  if (isReleased) {\n    throw new Error(\"Proxy has been released and is not useable\");\n  }\n}\n\nfunction createProxy(ep) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};\n  var isProxyReleased = false;\n  var proxy = new Proxy(target, {\n    get: function get(_target, prop) {\n      throwIfProxyReleased(isProxyReleased);\n\n      if (prop === releaseProxy) {\n        return function () {\n          return requestResponseMessage(ep, {\n            type: \"RELEASE\"\n            /* RELEASE */\n            ,\n            path: path.map(function (p) {\n              return p.toString();\n            })\n          }).then(function () {\n            closeEndPoint(ep);\n            isProxyReleased = true;\n          });\n        };\n      }\n\n      if (prop === \"then\") {\n        if (path.length === 0) {\n          return {\n            then: function then() {\n              return proxy;\n            }\n          };\n        }\n\n        var r = requestResponseMessage(ep, {\n          type: \"GET\"\n          /* GET */\n          ,\n          path: path.map(function (p) {\n            return p.toString();\n          })\n        }).then(fromWireValue);\n        return r.then.bind(r);\n      }\n\n      return createProxy(ep, [].concat(_toConsumableArray(path), [prop]));\n    },\n    set: function set(_target, prop, rawValue) {\n      throwIfProxyReleased(isProxyReleased); // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n      // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n\n      var _toWireValue3 = toWireValue(rawValue),\n          _toWireValue4 = _slicedToArray(_toWireValue3, 2),\n          value = _toWireValue4[0],\n          transferables = _toWireValue4[1];\n\n      return requestResponseMessage(ep, {\n        type: \"SET\"\n        /* SET */\n        ,\n        path: [].concat(_toConsumableArray(path), [prop]).map(function (p) {\n          return p.toString();\n        }),\n        value: value\n      }, transferables).then(fromWireValue);\n    },\n    apply: function apply(_target, _thisArg, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n      var last = path[path.length - 1];\n\n      if (last === createEndpoint) {\n        return requestResponseMessage(ep, {\n          type: \"ENDPOINT\"\n          /* ENDPOINT */\n\n        }).then(fromWireValue);\n      } // We just pretend that `bind()` didn’t happen.\n\n\n      if (last === \"bind\") {\n        return createProxy(ep, path.slice(0, -1));\n      }\n\n      var _processArguments = processArguments(rawArgumentList),\n          _processArguments2 = _slicedToArray(_processArguments, 2),\n          argumentList = _processArguments2[0],\n          transferables = _processArguments2[1];\n\n      return requestResponseMessage(ep, {\n        type: \"APPLY\"\n        /* APPLY */\n        ,\n        path: path.map(function (p) {\n          return p.toString();\n        }),\n        argumentList: argumentList\n      }, transferables).then(fromWireValue);\n    },\n    construct: function construct(_target, rawArgumentList) {\n      throwIfProxyReleased(isProxyReleased);\n\n      var _processArguments3 = processArguments(rawArgumentList),\n          _processArguments4 = _slicedToArray(_processArguments3, 2),\n          argumentList = _processArguments4[0],\n          transferables = _processArguments4[1];\n\n      return requestResponseMessage(ep, {\n        type: \"CONSTRUCT\"\n        /* CONSTRUCT */\n        ,\n        path: path.map(function (p) {\n          return p.toString();\n        }),\n        argumentList: argumentList\n      }, transferables).then(fromWireValue);\n    }\n  });\n  return proxy;\n}\n\nfunction myFlat(arr) {\n  return Array.prototype.concat.apply([], arr);\n}\n\nfunction processArguments(argumentList) {\n  var processed = argumentList.map(toWireValue);\n  return [processed.map(function (v) {\n    return v[0];\n  }), myFlat(processed.map(function (v) {\n    return v[1];\n  }))];\n}\n\nvar transferCache = new WeakMap();\n\nfunction transfer(obj, transfers) {\n  transferCache.set(obj, transfers);\n  return obj;\n}\n\nfunction proxy(obj) {\n  return Object.assign(obj, _defineProperty({}, proxyMarker, true));\n}\n\nfunction windowEndpoint(w) {\n  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : self;\n  var targetOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"*\";\n  return {\n    postMessage: function postMessage(msg, transferables) {\n      return w.postMessage(msg, targetOrigin, transferables);\n    },\n    addEventListener: context.addEventListener.bind(context),\n    removeEventListener: context.removeEventListener.bind(context)\n  };\n}\n\nfunction toWireValue(value) {\n  var _iterator = _createForOfIteratorHelper(transferHandlers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          name = _step$value[0],\n          handler = _step$value[1];\n\n      if (handler.canHandle(value)) {\n        var _handler$serialize = handler.serialize(value),\n            _handler$serialize2 = _slicedToArray(_handler$serialize, 2),\n            serializedValue = _handler$serialize2[0],\n            transferables = _handler$serialize2[1];\n\n        return [{\n          type: \"HANDLER\"\n          /* HANDLER */\n          ,\n          name: name,\n          value: serializedValue\n        }, transferables];\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return [{\n    type: \"RAW\"\n    /* RAW */\n    ,\n    value: value\n  }, transferCache.get(value) || []];\n}\n\nfunction fromWireValue(value) {\n  switch (value.type) {\n    case \"HANDLER\"\n    /* HANDLER */\n    :\n      return transferHandlers.get(value.name).deserialize(value.value);\n\n    case \"RAW\"\n    /* RAW */\n    :\n      return value.value;\n  }\n}\n\nfunction requestResponseMessage(ep, msg, transfers) {\n  return new Promise(function (resolve) {\n    var id = generateUUID();\n    ep.addEventListener(\"message\", function l(ev) {\n      if (!ev.data || !ev.data.id || ev.data.id !== id) {\n        return;\n      }\n\n      ep.removeEventListener(\"message\", l);\n      resolve(ev.data);\n    });\n\n    if (ep.start) {\n      ep.start();\n    }\n\n    ep.postMessage(Object.assign({\n      id: id\n    }, msg), transfers);\n  });\n}\n\nfunction generateUUID() {\n  return new Array(4).fill(0).map(function () {\n    return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16);\n  }).join(\"-\");\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29tbGluay9kaXN0L2VzbS9jb21saW5rLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7QUF3QkE7QUFDQTtBQUNBO0FBRUE7O0FBdUpBO0FBQUE7QUFBQTtBQWdDQTs7Ozs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFzQkE7Ozs7QUFHQTtBQUlBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBRkE7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOztBQUNBO0FBQ0E7QUEzQkE7QUE4QkE7Ozs7QUFHQTs7QUFRQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFwQ0E7QUFzQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBR0E7QUFBQTtBQURBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQURBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUdBO0FBQUE7QUFEQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFHQTtBQUFBO0FBREE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBT0E7QUE1RUE7QUE4RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFHQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBRUE7QUFBQTtBQURBO0FBRUE7QUFDQTtBQUhBO0FBT0E7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBY0E7QUFFQTtBQUFBO0FBREE7QUFFQTtBQUZBO0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQUE7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uLy4uL3NyYy9jb21saW5rLnRzPzI0YjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBFbmRwb2ludCxcbiAgRXZlbnRTb3VyY2UsXG4gIE1lc3NhZ2UsXG4gIE1lc3NhZ2VUeXBlLFxuICBQb3N0TWVzc2FnZVdpdGhPcmlnaW4sXG4gIFdpcmVWYWx1ZSxcbiAgV2lyZVZhbHVlVHlwZSxcbn0gZnJvbSBcIi4vcHJvdG9jb2xcIjtcbmV4cG9ydCB7IEVuZHBvaW50IH07XG5cbmV4cG9ydCBjb25zdCBwcm94eU1hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIik7XG5leHBvcnQgY29uc3QgY3JlYXRlRW5kcG9pbnQgPSBTeW1ib2woXCJDb21saW5rLmVuZHBvaW50XCIpO1xuZXhwb3J0IGNvbnN0IHJlbGVhc2VQcm94eSA9IFN5bWJvbChcIkNvbWxpbmsucmVsZWFzZVByb3h5XCIpO1xuXG5jb25zdCB0aHJvd01hcmtlciA9IFN5bWJvbChcIkNvbWxpbmsudGhyb3duXCIpO1xuXG4vKipcbiAqIEludGVyZmFjZSBvZiB2YWx1ZXMgdGhhdCB3ZXJlIG1hcmtlZCB0byBiZSBwcm94aWVkIHdpdGggYGNvbWxpbmsucHJveHkoKWAuXG4gKiBDYW4gYWxzbyBiZSBpbXBsZW1lbnRlZCBieSBjbGFzc2VzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5TWFya2VkIHtcbiAgW3Byb3h5TWFya2VyXTogdHJ1ZTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHR5cGUgYW5kIHdyYXBzIGl0IGluIGEgUHJvbWlzZSwgaWYgaXQgbm90IGFscmVhZHkgaXMgb25lLlxuICogVGhpcyBpcyB0byBhdm9pZCBgUHJvbWlzZTxQcm9taXNlPFQ+PmAuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgVW5wcm9taXNpZnk8VD5gLlxuICovXG50eXBlIFByb21pc2lmeTxUPiA9IFQgZXh0ZW5kcyBQcm9taXNlPHVua25vd24+ID8gVCA6IFByb21pc2U8VD47XG4vKipcbiAqIFRha2VzIGEgdHlwZSB0aGF0IG1heSBiZSBQcm9taXNlIGFuZCB1bndyYXBzIHRoZSBQcm9taXNlIHR5cGUuXG4gKiBJZiBgUGAgaXMgbm90IGEgUHJvbWlzZSwgaXQgcmV0dXJucyBgUGAuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgUHJvbWlzaWZ5PFQ+YC5cbiAqL1xudHlwZSBVbnByb21pc2lmeTxQPiA9IFAgZXh0ZW5kcyBQcm9taXNlPGluZmVyIFQ+ID8gVCA6IFA7XG5cbi8qKlxuICogVGFrZXMgdGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIHByb3BlcnR5IGFuZCByZXR1cm5zIHRoZSB0eXBlIHRoYXQgaXMgdmlzaWJsZSB0byB0aGUgbG9jYWwgdGhyZWFkIG9uIHRoZSBwcm94eS5cbiAqXG4gKiBOb3RlOiBUaGlzIG5lZWRzIHRvIGJlIGl0cyBvd24gdHlwZSBhbGlhcywgb3RoZXJ3aXNlIGl0IHdpbGwgbm90IGRpc3RyaWJ1dGUgb3ZlciB1bmlvbnMuXG4gKiBTZWUgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svYWR2YW5jZWQtdHlwZXMuaHRtbCNkaXN0cmlidXRpdmUtY29uZGl0aW9uYWwtdHlwZXNcbiAqL1xudHlwZSBSZW1vdGVQcm9wZXJ0eTxUPiA9XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhIG1ldGhvZCwgY29tbGluayB3aWxsIHByb3h5IGl0IGF1dG9tYXRpY2FsbHkuXG4gIC8vIE9iamVjdHMgYXJlIG9ubHkgcHJveGllZCBpZiB0aGV5IGFyZSBtYXJrZWQgdG8gYmUgcHJveGllZC5cbiAgLy8gT3RoZXJ3aXNlLCB0aGUgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSBjbG9uZWQgdmFsdWUuXG4gIFQgZXh0ZW5kcyBGdW5jdGlvbiB8IFByb3h5TWFya2VkID8gUmVtb3RlPFQ+IDogUHJvbWlzaWZ5PFQ+O1xuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHByb3BlcnR5IGFzIGEgcmVtb3RlIHRocmVhZCB3b3VsZCBzZWUgaXQgdGhyb3VnaCBhIHByb3h5IChlLmcuIHdoZW4gcGFzc2VkIGluIGFzIGEgZnVuY3Rpb25cbiAqIGFyZ3VtZW50KSBhbmQgcmV0dXJucyB0aGUgdHlwZSB0aGF0IHRoZSBsb2NhbCB0aHJlYWQgaGFzIHRvIHN1cHBseS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGBSZW1vdGVQcm9wZXJ0eTxUPmAuXG4gKlxuICogTm90ZTogVGhpcyBuZWVkcyB0byBiZSBpdHMgb3duIHR5cGUgYWxpYXMsIG90aGVyd2lzZSBpdCB3aWxsIG5vdCBkaXN0cmlidXRlIG92ZXIgdW5pb25zLiBTZWVcbiAqIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2FkdmFuY2VkLXR5cGVzLmh0bWwjZGlzdHJpYnV0aXZlLWNvbmRpdGlvbmFsLXR5cGVzXG4gKi9cbnR5cGUgTG9jYWxQcm9wZXJ0eTxUPiA9IFQgZXh0ZW5kcyBGdW5jdGlvbiB8IFByb3h5TWFya2VkXG4gID8gTG9jYWw8VD5cbiAgOiBVbnByb21pc2lmeTxUPjtcblxuLyoqXG4gKiBQcm94aWVzIGBUYCBpZiBpdCBpcyBhIGBQcm94eU1hcmtlZGAsIGNsb25lcyBpdCBvdGhlcndpc2UgKGFzIGhhbmRsZWQgYnkgc3RydWN0dXJlZCBjbG9uaW5nIGFuZCB0cmFuc2ZlciBoYW5kbGVycykuXG4gKi9cbmV4cG9ydCB0eXBlIFByb3h5T3JDbG9uZTxUPiA9IFQgZXh0ZW5kcyBQcm94eU1hcmtlZCA/IFJlbW90ZTxUPiA6IFQ7XG4vKipcbiAqIEludmVyc2Ugb2YgYFByb3h5T3JDbG9uZTxUPmAuXG4gKi9cbmV4cG9ydCB0eXBlIFVucHJveHlPckNsb25lPFQ+ID0gVCBleHRlbmRzIFJlbW90ZU9iamVjdDxQcm94eU1hcmtlZD5cbiAgPyBMb2NhbDxUPlxuICA6IFQ7XG5cbi8qKlxuICogVGFrZXMgdGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIG9iamVjdCBpbiB0aGUgb3RoZXIgdGhyZWFkIGFuZCByZXR1cm5zIHRoZSB0eXBlIGFzIGl0IGlzIHZpc2libGUgdG8gdGhlIGxvY2FsIHRocmVhZFxuICogd2hlbiBwcm94aWVkIHdpdGggYENvbWxpbmsucHJveHkoKWAuXG4gKlxuICogVGhpcyBkb2VzIG5vdCBoYW5kbGUgY2FsbCBzaWduYXR1cmVzLCB3aGljaCBpcyBoYW5kbGVkIGJ5IHRoZSBtb3JlIGdlbmVyYWwgYFJlbW90ZTxUPmAgdHlwZS5cbiAqXG4gKiBAdGVtcGxhdGUgVCBUaGUgcmF3IHR5cGUgb2YgYSByZW1vdGUgb2JqZWN0IGFzIHNlZW4gaW4gdGhlIG90aGVyIHRocmVhZC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVtb3RlT2JqZWN0PFQ+ID0geyBbUCBpbiBrZXlvZiBUXTogUmVtb3RlUHJvcGVydHk8VFtQXT4gfTtcbi8qKlxuICogVGFrZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0IGFzIGEgcmVtb3RlIHRocmVhZCB3b3VsZCBzZWUgaXQgdGhyb3VnaCBhIHByb3h5IChlLmcuIHdoZW4gcGFzc2VkIGluIGFzIGEgZnVuY3Rpb25cbiAqIGFyZ3VtZW50KSBhbmQgcmV0dXJucyB0aGUgdHlwZSB0aGF0IHRoZSBsb2NhbCB0aHJlYWQgaGFzIHRvIHN1cHBseS5cbiAqXG4gKiBUaGlzIGRvZXMgbm90IGhhbmRsZSBjYWxsIHNpZ25hdHVyZXMsIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhlIG1vcmUgZ2VuZXJhbCBgTG9jYWw8VD5gIHR5cGUuXG4gKlxuICogVGhpcyBpcyB0aGUgaW52ZXJzZSBvZiBgUmVtb3RlT2JqZWN0PFQ+YC5cbiAqXG4gKiBAdGVtcGxhdGUgVCBUaGUgdHlwZSBvZiBhIHByb3hpZWQgb2JqZWN0LlxuICovXG5leHBvcnQgdHlwZSBMb2NhbE9iamVjdDxUPiA9IHsgW1AgaW4ga2V5b2YgVF06IExvY2FsUHJvcGVydHk8VFtQXT4gfTtcblxuLyoqXG4gKiBBZGRpdGlvbmFsIHNwZWNpYWwgY29tbGluayBtZXRob2RzIGF2YWlsYWJsZSBvbiBlYWNoIHByb3h5IHJldHVybmVkIGJ5IGBDb21saW5rLndyYXAoKWAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJveHlNZXRob2RzIHtcbiAgW2NyZWF0ZUVuZHBvaW50XTogKCkgPT4gUHJvbWlzZTxNZXNzYWdlUG9ydD47XG4gIFtyZWxlYXNlUHJveHldOiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFRha2VzIHRoZSByYXcgdHlwZSBvZiBhIHJlbW90ZSBvYmplY3QsIGZ1bmN0aW9uIG9yIGNsYXNzIGluIHRoZSBvdGhlciB0aHJlYWQgYW5kIHJldHVybnMgdGhlIHR5cGUgYXMgaXQgaXMgdmlzaWJsZSB0b1xuICogdGhlIGxvY2FsIHRocmVhZCBmcm9tIHRoZSBwcm94eSByZXR1cm4gdmFsdWUgb2YgYENvbWxpbmsud3JhcCgpYCBvciBgQ29tbGluay5wcm94eSgpYC5cbiAqL1xuZXhwb3J0IHR5cGUgUmVtb3RlPFQ+ID1cbiAgLy8gSGFuZGxlIHByb3BlcnRpZXNcbiAgUmVtb3RlT2JqZWN0PFQ+ICZcbiAgICAvLyBIYW5kbGUgY2FsbCBzaWduYXR1cmUgKGlmIHByZXNlbnQpXG4gICAgKFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgVEFyZ3VtZW50cykgPT4gaW5mZXIgVFJldHVyblxuICAgICAgPyAoXG4gICAgICAgICAgLi4uYXJnczogeyBbSSBpbiBrZXlvZiBUQXJndW1lbnRzXTogVW5wcm94eU9yQ2xvbmU8VEFyZ3VtZW50c1tJXT4gfVxuICAgICAgICApID0+IFByb21pc2lmeTxQcm94eU9yQ2xvbmU8VW5wcm9taXNpZnk8VFJldHVybj4+PlxuICAgICAgOiB1bmtub3duKSAmXG4gICAgLy8gSGFuZGxlIGNvbnN0cnVjdCBzaWduYXR1cmUgKGlmIHByZXNlbnQpXG4gICAgLy8gVGhlIHJldHVybiBvZiBjb25zdHJ1Y3Qgc2lnbmF0dXJlcyBpcyBhbHdheXMgcHJveGllZCAod2hldGhlciBtYXJrZWQgb3Igbm90KVxuICAgIChUIGV4dGVuZHMgeyBuZXcgKC4uLmFyZ3M6IGluZmVyIFRBcmd1bWVudHMpOiBpbmZlciBUSW5zdGFuY2UgfVxuICAgICAgPyB7XG4gICAgICAgICAgbmV3IChcbiAgICAgICAgICAgIC4uLmFyZ3M6IHtcbiAgICAgICAgICAgICAgW0kgaW4ga2V5b2YgVEFyZ3VtZW50c106IFVucHJveHlPckNsb25lPFRBcmd1bWVudHNbSV0+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk6IFByb21pc2lmeTxSZW1vdGU8VEluc3RhbmNlPj47XG4gICAgICAgIH1cbiAgICAgIDogdW5rbm93bikgJlxuICAgIC8vIEluY2x1ZGUgYWRkaXRpb25hbCBzcGVjaWFsIGNvbWxpbmsgbWV0aG9kcyBhdmFpbGFibGUgb24gdGhlIHByb3h5LlxuICAgIFByb3h5TWV0aG9kcztcblxuLyoqXG4gKiBFeHByZXNzZXMgdGhhdCBhIHR5cGUgY2FuIGJlIGVpdGhlciBhIHN5bmMgb3IgYXN5bmMuXG4gKi9cbnR5cGUgTWF5YmVQcm9taXNlPFQ+ID0gUHJvbWlzZTxUPiB8IFQ7XG5cbi8qKlxuICogVGFrZXMgdGhlIHJhdyB0eXBlIG9mIGEgcmVtb3RlIG9iamVjdCwgZnVuY3Rpb24gb3IgY2xhc3MgYXMgYSByZW1vdGUgdGhyZWFkIHdvdWxkIHNlZSBpdCB0aHJvdWdoIGEgcHJveHkgKGUuZy4gd2hlblxuICogcGFzc2VkIGluIGFzIGEgZnVuY3Rpb24gYXJndW1lbnQpIGFuZCByZXR1cm5zIHRoZSB0eXBlIHRoZSBsb2NhbCB0aHJlYWQgaGFzIHRvIHN1cHBseS5cbiAqXG4gKiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGBSZW1vdGU8VD5gLiBJdCB0YWtlcyBhIGBSZW1vdGU8VD5gIGFuZCByZXR1cm5zIGl0cyBvcmlnaW5hbCBpbnB1dCBgVGAuXG4gKi9cbmV4cG9ydCB0eXBlIExvY2FsPFQ+ID1cbiAgLy8gT21pdCB0aGUgc3BlY2lhbCBwcm94eSBtZXRob2RzICh0aGV5IGRvbid0IG5lZWQgdG8gYmUgc3VwcGxpZWQsIGNvbWxpbmsgYWRkcyB0aGVtKVxuICBPbWl0PExvY2FsT2JqZWN0PFQ+LCBrZXlvZiBQcm94eU1ldGhvZHM+ICZcbiAgICAvLyBIYW5kbGUgY2FsbCBzaWduYXR1cmVzIChpZiBwcmVzZW50KVxuICAgIChUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFRBcmd1bWVudHMpID0+IGluZmVyIFRSZXR1cm5cbiAgICAgID8gKFxuICAgICAgICAgIC4uLmFyZ3M6IHsgW0kgaW4ga2V5b2YgVEFyZ3VtZW50c106IFByb3h5T3JDbG9uZTxUQXJndW1lbnRzW0ldPiB9XG4gICAgICAgICkgPT4gLy8gVGhlIHJhdyBmdW5jdGlvbiBjb3VsZCBlaXRoZXIgYmUgc3luYyBvciBhc3luYywgYnV0IGlzIGFsd2F5cyBwcm94aWVkIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgTWF5YmVQcm9taXNlPFVucHJveHlPckNsb25lPFVucHJvbWlzaWZ5PFRSZXR1cm4+Pj5cbiAgICAgIDogdW5rbm93bikgJlxuICAgIC8vIEhhbmRsZSBjb25zdHJ1Y3Qgc2lnbmF0dXJlIChpZiBwcmVzZW50KVxuICAgIC8vIFRoZSByZXR1cm4gb2YgY29uc3RydWN0IHNpZ25hdHVyZXMgaXMgYWx3YXlzIHByb3hpZWQgKHdoZXRoZXIgbWFya2VkIG9yIG5vdClcbiAgICAoVCBleHRlbmRzIHsgbmV3ICguLi5hcmdzOiBpbmZlciBUQXJndW1lbnRzKTogaW5mZXIgVEluc3RhbmNlIH1cbiAgICAgID8ge1xuICAgICAgICAgIG5ldyAoXG4gICAgICAgICAgICAuLi5hcmdzOiB7XG4gICAgICAgICAgICAgIFtJIGluIGtleW9mIFRBcmd1bWVudHNdOiBQcm94eU9yQ2xvbmU8VEFyZ3VtZW50c1tJXT47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTogLy8gVGhlIHJhdyBjb25zdHJ1Y3RvciBjb3VsZCBlaXRoZXIgYmUgc3luYyBvciBhc3luYywgYnV0IGlzIGFsd2F5cyBwcm94aWVkIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICBNYXliZVByb21pc2U8TG9jYWw8VW5wcm9taXNpZnk8VEluc3RhbmNlPj4+O1xuICAgICAgICB9XG4gICAgICA6IHVua25vd24pO1xuXG5jb25zdCBpc09iamVjdCA9ICh2YWw6IHVua25vd24pOiB2YWwgaXMgb2JqZWN0ID0+XG4gICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuXG4vKipcbiAqIEN1c3RvbWl6ZXMgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMgYXMgZGV0ZXJtaW5lZCBieSBgY2FuSGFuZGxlKClgLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIFRoZSBpbnB1dCB0eXBlIGJlaW5nIGhhbmRsZWQgYnkgdGhpcyB0cmFuc2ZlciBoYW5kbGVyLlxuICogQHRlbXBsYXRlIFMgVGhlIHNlcmlhbGl6ZWQgdHlwZSBzZW50IG92ZXIgdGhlIHdpcmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJIYW5kbGVyPFQsIFM+IHtcbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIGZvciBldmVyeSB2YWx1ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzIHRyYW5zZmVyIGhhbmRsZXJcbiAgICogc2hvdWxkIHNlcmlhbGl6ZSB0aGUgdmFsdWUsIHdoaWNoIGluY2x1ZGVzIGNoZWNraW5nIHRoYXQgaXQgaXMgb2YgdGhlIHJpZ2h0XG4gICAqIHR5cGUgKGJ1dCBjYW4gcGVyZm9ybSBjaGVja3MgYmV5b25kIHRoYXQgYXMgd2VsbCkuXG4gICAqL1xuICBjYW5IYW5kbGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUO1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBpZiBgY2FuSGFuZGxlKClgIHJldHVybmVkIGB0cnVlYCB0byBwcm9kdWNlIGFcbiAgICogdmFsdWUgdGhhdCBjYW4gYmUgc2VudCBpbiBhIG1lc3NhZ2UsIGNvbnNpc3Rpbmcgb2Ygc3RydWN0dXJlZC1jbG9uZWFibGVcbiAgICogdmFsdWVzIGFuZC9vciB0cmFuc2ZlcnJhYmxlIG9iamVjdHMuXG4gICAqL1xuICBzZXJpYWxpemUodmFsdWU6IFQpOiBbUywgVHJhbnNmZXJhYmxlW11dO1xuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB0byBkZXNlcmlhbGl6ZSBhbiBpbmNvbWluZyB2YWx1ZSB0aGF0IHdhcyBzZXJpYWxpemVkIGluIHRoZVxuICAgKiBvdGhlciB0aHJlYWQgd2l0aCB0aGlzIHRyYW5zZmVyIGhhbmRsZXIgKGtub3duIHRocm91Z2ggdGhlIG5hbWUgaXQgd2FzXG4gICAqIHJlZ2lzdGVyZWQgdW5kZXIpLlxuICAgKi9cbiAgZGVzZXJpYWxpemUodmFsdWU6IFMpOiBUO1xufVxuXG4vKipcbiAqIEludGVybmFsIHRyYW5zZmVyIGhhbmRsZSB0byBoYW5kbGUgb2JqZWN0cyBtYXJrZWQgdG8gcHJveHkuXG4gKi9cbmNvbnN0IHByb3h5VHJhbnNmZXJIYW5kbGVyOiBUcmFuc2ZlckhhbmRsZXI8b2JqZWN0LCBNZXNzYWdlUG9ydD4gPSB7XG4gIGNhbkhhbmRsZTogKHZhbCk6IHZhbCBpcyBQcm94eU1hcmtlZCA9PlxuICAgIGlzT2JqZWN0KHZhbCkgJiYgKHZhbCBhcyBQcm94eU1hcmtlZClbcHJveHlNYXJrZXJdLFxuICBzZXJpYWxpemUob2JqKSB7XG4gICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGV4cG9zZShvYmosIHBvcnQxKTtcbiAgICByZXR1cm4gW3BvcnQyLCBbcG9ydDJdXTtcbiAgfSxcbiAgZGVzZXJpYWxpemUocG9ydCkge1xuICAgIHBvcnQuc3RhcnQoKTtcbiAgICByZXR1cm4gd3JhcChwb3J0KTtcbiAgfSxcbn07XG5cbmludGVyZmFjZSBUaHJvd25WYWx1ZSB7XG4gIFt0aHJvd01hcmtlcl06IHVua25vd247IC8vIGp1c3QgbmVlZHMgdG8gYmUgcHJlc2VudFxuICB2YWx1ZTogdW5rbm93bjtcbn1cbnR5cGUgU2VyaWFsaXplZFRocm93blZhbHVlID1cbiAgfCB7IGlzRXJyb3I6IHRydWU7IHZhbHVlOiBFcnJvciB9XG4gIHwgeyBpc0Vycm9yOiBmYWxzZTsgdmFsdWU6IHVua25vd24gfTtcblxuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGVyIHRvIGhhbmRsZSB0aHJvd24gZXhjZXB0aW9ucy5cbiAqL1xuY29uc3QgdGhyb3dUcmFuc2ZlckhhbmRsZXI6IFRyYW5zZmVySGFuZGxlcjxcbiAgVGhyb3duVmFsdWUsXG4gIFNlcmlhbGl6ZWRUaHJvd25WYWx1ZVxuPiA9IHtcbiAgY2FuSGFuZGxlOiAodmFsdWUpOiB2YWx1ZSBpcyBUaHJvd25WYWx1ZSA9PlxuICAgIGlzT2JqZWN0KHZhbHVlKSAmJiB0aHJvd01hcmtlciBpbiB2YWx1ZSxcbiAgc2VyaWFsaXplKHsgdmFsdWUgfSkge1xuICAgIGxldCBzZXJpYWxpemVkOiBTZXJpYWxpemVkVGhyb3duVmFsdWU7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgbWVzc2FnZTogdmFsdWUubWVzc2FnZSxcbiAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgICAgIHN0YWNrOiB2YWx1ZS5zdGFjayxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQgPSB7IGlzRXJyb3I6IGZhbHNlLCB2YWx1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTtcbiAgfSxcbiAgZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGlmIChzZXJpYWxpemVkLmlzRXJyb3IpIHtcbiAgICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIG5ldyBFcnJvcihzZXJpYWxpemVkLnZhbHVlLm1lc3NhZ2UpLFxuICAgICAgICBzZXJpYWxpemVkLnZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgICB0aHJvdyBzZXJpYWxpemVkLnZhbHVlO1xuICB9LFxufTtcblxuLyoqXG4gKiBBbGxvd3MgY3VzdG9taXppbmcgdGhlIHNlcmlhbGl6YXRpb24gb2YgY2VydGFpbiB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2ZlckhhbmRsZXJzID0gbmV3IE1hcDxcbiAgc3RyaW5nLFxuICBUcmFuc2ZlckhhbmRsZXI8dW5rbm93biwgdW5rbm93bj5cbj4oW1xuICBbXCJwcm94eVwiLCBwcm94eVRyYW5zZmVySGFuZGxlcl0sXG4gIFtcInRocm93XCIsIHRocm93VHJhbnNmZXJIYW5kbGVyXSxcbl0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwb3NlKG9iajogYW55LCBlcDogRW5kcG9pbnQgPSBzZWxmIGFzIGFueSkge1xuICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBjYWxsYmFjayhldjogTWVzc2FnZUV2ZW50KSB7XG4gICAgaWYgKCFldiB8fCAhZXYuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCB0eXBlLCBwYXRoIH0gPSB7XG4gICAgICBwYXRoOiBbXSBhcyBzdHJpbmdbXSxcbiAgICAgIC4uLihldi5kYXRhIGFzIE1lc3NhZ2UpLFxuICAgIH07XG4gICAgY29uc3QgYXJndW1lbnRMaXN0ID0gKGV2LmRhdGEuYXJndW1lbnRMaXN0IHx8IFtdKS5tYXAoZnJvbVdpcmVWYWx1ZSk7XG4gICAgbGV0IHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLnNsaWNlKDAsIC0xKS5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgY29uc3QgcmF3VmFsdWUgPSBwYXRoLnJlZHVjZSgob2JqLCBwcm9wKSA9PiBvYmpbcHJvcF0sIG9iaik7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5HRVQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuU0VUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhcmVudFtwYXRoLnNsaWNlKC0xKVswXV0gPSBmcm9tV2lyZVZhbHVlKGV2LmRhdGEudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBNZXNzYWdlVHlwZS5BUFBMWTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJhd1ZhbHVlLmFwcGx5KHBhcmVudCwgYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuQ09OU1RSVUNUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHJhd1ZhbHVlKC4uLmFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb3h5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTWVzc2FnZVR5cGUuRU5EUE9JTlQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgeyBwb3J0MSwgcG9ydDIgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDIpO1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB0cmFuc2Zlcihwb3J0MSwgW3BvcnQxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1lc3NhZ2VUeXBlLlJFTEVBU0U6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoICh2YWx1ZSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgfVxuICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSlcbiAgICAgIC5jYXRjaCgodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIFt0aHJvd01hcmtlcl06IDAgfTtcbiAgICAgIH0pXG4gICAgICAudGhlbigocmV0dXJuVmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgIGVwLnBvc3RNZXNzYWdlKHsgLi4ud2lyZVZhbHVlLCBpZCB9LCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgaWYgKHR5cGUgPT09IE1lc3NhZ2VUeXBlLlJFTEVBU0UpIHtcbiAgICAgICAgICAvLyBkZXRhY2ggYW5kIGRlYWN0aXZlIGFmdGVyIHNlbmRpbmcgcmVsZWFzZSByZXNwb25zZSBhYm92ZS5cbiAgICAgICAgICBlcC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBjYWxsYmFjayBhcyBhbnkpO1xuICAgICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfSBhcyBhbnkpO1xuICBpZiAoZXAuc3RhcnQpIHtcbiAgICBlcC5zdGFydCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQ6IEVuZHBvaW50KTogZW5kcG9pbnQgaXMgTWVzc2FnZVBvcnQge1xuICByZXR1cm4gZW5kcG9pbnQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJNZXNzYWdlUG9ydFwiO1xufVxuXG5mdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50OiBFbmRwb2ludCkge1xuICBpZiAoaXNNZXNzYWdlUG9ydChlbmRwb2ludCkpIGVuZHBvaW50LmNsb3NlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwPFQ+KGVwOiBFbmRwb2ludCwgdGFyZ2V0PzogYW55KTogUmVtb3RlPFQ+IHtcbiAgcmV0dXJuIGNyZWF0ZVByb3h5PFQ+KGVwLCBbXSwgdGFyZ2V0KSBhcyBhbnk7XG59XG5cbmZ1bmN0aW9uIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUmVsZWFzZWQ6IGJvb2xlYW4pIHtcbiAgaWYgKGlzUmVsZWFzZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm94eSBoYXMgYmVlbiByZWxlYXNlZCBhbmQgaXMgbm90IHVzZWFibGVcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHk8VD4oXG4gIGVwOiBFbmRwb2ludCxcbiAgcGF0aDogKHN0cmluZyB8IG51bWJlciB8IHN5bWJvbClbXSA9IFtdLFxuICB0YXJnZXQ6IG9iamVjdCA9IGZ1bmN0aW9uICgpIHt9XG4pOiBSZW1vdGU8VD4ge1xuICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7XG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHRhcmdldCwge1xuICAgIGdldChfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7XG4gICAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5SRUxFQVNFLFxuICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjbG9zZUVuZFBvaW50KGVwKTtcbiAgICAgICAgICAgIGlzUHJveHlSZWxlYXNlZCA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gXCJ0aGVuXCIpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gcHJveHkgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwge1xuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkdFVCxcbiAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgfSkudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHIudGhlbi5iaW5kKHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBbLi4ucGF0aCwgcHJvcF0pO1xuICAgIH0sXG4gICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7XG4gICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgwq9cXF8o44OEKV8vwq9cbiAgICAgIGNvbnN0IFt2YWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShcbiAgICAgICAgZXAsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBNZXNzYWdlVHlwZS5TRVQsXG4gICAgICAgICAgcGF0aDogWy4uLnBhdGgsIHByb3BdLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgKS50aGVuKGZyb21XaXJlVmFsdWUpIGFzIGFueTtcbiAgICB9LFxuICAgIGFwcGx5KF90YXJnZXQsIF90aGlzQXJnLCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICBjb25zdCBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKChsYXN0IGFzIGFueSkgPT09IGNyZWF0ZUVuZHBvaW50KSB7XG4gICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCB7XG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuRU5EUE9JTlQsXG4gICAgICAgIH0pLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBqdXN0IHByZXRlbmQgdGhhdCBgYmluZCgpYCBkaWRu4oCZdCBoYXBwZW4uXG4gICAgICBpZiAobGFzdCA9PT0gXCJiaW5kXCIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKFxuICAgICAgICBlcCxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IE1lc3NhZ2VUeXBlLkFQUExZLFxuICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgIH0sXG4gICAgY29uc3RydWN0KF90YXJnZXQsIHJhd0FyZ3VtZW50TGlzdCkge1xuICAgICAgdGhyb3dJZlByb3h5UmVsZWFzZWQoaXNQcm94eVJlbGVhc2VkKTtcbiAgICAgIGNvbnN0IFthcmd1bWVudExpc3QsIHRyYW5zZmVyYWJsZXNdID0gcHJvY2Vzc0FyZ3VtZW50cyhyYXdBcmd1bWVudExpc3QpO1xuICAgICAgcmV0dXJuIHJlcXVlc3RSZXNwb25zZU1lc3NhZ2UoXG4gICAgICAgIGVwLFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogTWVzc2FnZVR5cGUuQ09OU1RSVUNULFxuICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNmZXJhYmxlc1xuICAgICAgKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcHJveHkgYXMgYW55O1xufVxuXG5mdW5jdGlvbiBteUZsYXQ8VD4oYXJyOiAoVCB8IFRbXSlbXSk6IFRbXSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXJndW1lbnRzKGFyZ3VtZW50TGlzdDogYW55W10pOiBbV2lyZVZhbHVlW10sIFRyYW5zZmVyYWJsZVtdXSB7XG4gIGNvbnN0IHByb2Nlc3NlZCA9IGFyZ3VtZW50TGlzdC5tYXAodG9XaXJlVmFsdWUpO1xuICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTtcbn1cblxuY29uc3QgdHJhbnNmZXJDYWNoZSA9IG5ldyBXZWFrTWFwPGFueSwgVHJhbnNmZXJhYmxlW10+KCk7XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmZXI8VD4ob2JqOiBULCB0cmFuc2ZlcnM6IFRyYW5zZmVyYWJsZVtdKTogVCB7XG4gIHRyYW5zZmVyQ2FjaGUuc2V0KG9iaiwgdHJhbnNmZXJzKTtcbiAgcmV0dXJuIG9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3h5PFQ+KG9iajogVCk6IFQgJiBQcm94eU1hcmtlZCB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgeyBbcHJveHlNYXJrZXJdOiB0cnVlIH0pIGFzIGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpbmRvd0VuZHBvaW50KFxuICB3OiBQb3N0TWVzc2FnZVdpdGhPcmlnaW4sXG4gIGNvbnRleHQ6IEV2ZW50U291cmNlID0gc2VsZixcbiAgdGFyZ2V0T3JpZ2luID0gXCIqXCJcbik6IEVuZHBvaW50IHtcbiAgcmV0dXJuIHtcbiAgICBwb3N0TWVzc2FnZTogKG1zZzogYW55LCB0cmFuc2ZlcmFibGVzOiBUcmFuc2ZlcmFibGVbXSkgPT5cbiAgICAgIHcucG9zdE1lc3NhZ2UobXNnLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNvbnRleHQuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKGNvbnRleHQpLFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b1dpcmVWYWx1ZSh2YWx1ZTogYW55KTogW1dpcmVWYWx1ZSwgVHJhbnNmZXJhYmxlW11dIHtcbiAgZm9yIChjb25zdCBbbmFtZSwgaGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgIGlmIChoYW5kbGVyLmNhbkhhbmRsZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IFtzZXJpYWxpemVkVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFdpcmVWYWx1ZVR5cGUuSEFORExFUixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyYWJsZXMsXG4gICAgICBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFdpcmVWYWx1ZVR5cGUuUkFXLFxuICAgICAgdmFsdWUsXG4gICAgfSxcbiAgICB0cmFuc2ZlckNhY2hlLmdldCh2YWx1ZSkgfHwgW10sXG4gIF07XG59XG5cbmZ1bmN0aW9uIGZyb21XaXJlVmFsdWUodmFsdWU6IFdpcmVWYWx1ZSk6IGFueSB7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgV2lyZVZhbHVlVHlwZS5IQU5ETEVSOlxuICAgICAgcmV0dXJuIHRyYW5zZmVySGFuZGxlcnMuZ2V0KHZhbHVlLm5hbWUpIS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7XG4gICAgY2FzZSBXaXJlVmFsdWVUeXBlLlJBVzpcbiAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKFxuICBlcDogRW5kcG9pbnQsXG4gIG1zZzogTWVzc2FnZSxcbiAgdHJhbnNmZXJzPzogVHJhbnNmZXJhYmxlW11cbik6IFByb21pc2U8V2lyZVZhbHVlPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVVVUlEKCk7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gbChldjogTWVzc2FnZUV2ZW50KSB7XG4gICAgICBpZiAoIWV2LmRhdGEgfHwgIWV2LmRhdGEuaWQgfHwgZXYuZGF0YS5pZCAhPT0gaWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbCBhcyBhbnkpO1xuICAgICAgcmVzb2x2ZShldi5kYXRhKTtcbiAgICB9IGFzIGFueSk7XG4gICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICBlcC5zdGFydCgpO1xuICAgIH1cbiAgICBlcC5wb3N0TWVzc2FnZSh7IGlkLCAuLi5tc2cgfSwgdHJhbnNmZXJzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IEFycmF5KDQpXG4gICAgLmZpbGwoMClcbiAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKS50b1N0cmluZygxNikpXG4gICAgLmpvaW4oXCItXCIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/comlink/dist/esm/comlink.mjs\n");

/***/ })

}]);