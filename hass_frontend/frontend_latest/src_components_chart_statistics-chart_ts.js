"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_components_chart_statistics-chart_ts"],{

/***/ "./src/components/chart/statistics-chart.ts":
/*!**************************************************!*\
  !*** ./src/components/chart/statistics-chart.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   supportedStatTypeMap: () => (/* binding */ supportedStatTypeMap)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_decorate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/decorate */ \"./node_modules/@babel/runtime/helpers/esm/decorate.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/decorators */ \"./node_modules/lit/decorators.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! memoize-one */ \"./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var _common_color_colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../common/color/colors */ \"./src/common/color/colors.ts\");\n/* harmony import */ var _common_config_is_component_loaded__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../common/config/is_component_loaded */ \"./src/common/config/is_component_loaded.ts\");\n/* harmony import */ var _common_number_format_number__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../common/number/format_number */ \"./src/common/number/format_number.ts\");\n/* harmony import */ var _data_recorder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../data/recorder */ \"./src/data/recorder.ts\");\n/* harmony import */ var _ha_chart_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ha-chart-base */ \"./src/components/chart/ha-chart-base.ts\");\n\n\n\n\n\n\n\n\n\nconst supportedStatTypeMap = {\n  mean: \"mean\",\n  min: \"min\",\n  max: \"max\",\n  sum: \"sum\",\n  state: \"sum\",\n  change: \"sum\"\n};\nlet StatisticsChart = (0,_babel_runtime_helpers_decorate__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.customElement)(\"statistics-chart\")], function (_initialize, _LitElement) {\n  class StatisticsChart extends _LitElement {\n    constructor(...args) {\n      super(...args);\n      _initialize(this);\n    }\n  }\n  return {\n    F: StatisticsChart,\n    d: [{\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"hass\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"statisticsData\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"metadata\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)()],\n      key: \"names\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)()],\n      key: \"unit\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        attribute: false\n      })],\n      key: \"endTime\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        type: Array\n      })],\n      key: \"statTypes\",\n      value() {\n        return [\"sum\", \"min\", \"mean\", \"max\"];\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)()],\n      key: \"chartType\",\n      value() {\n        return \"line\";\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        type: Boolean\n      })],\n      key: \"hideLegend\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.property)({\n        type: Boolean\n      })],\n      key: \"isLoadingData\",\n      value() {\n        return false;\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_chartData\",\n      value() {\n        return {\n          datasets: []\n        };\n      }\n    }, {\n      kind: \"field\",\n      decorators: [(0,lit_decorators__WEBPACK_IMPORTED_MODULE_2__.state)()],\n      key: \"_chartOptions\",\n      value: void 0\n    }, {\n      kind: \"field\",\n      key: \"_computedStyle\",\n      value: void 0\n    }, {\n      kind: \"method\",\n      key: \"shouldUpdate\",\n      value: function shouldUpdate(changedProps) {\n        return changedProps.size > 1 || !changedProps.has(\"hass\");\n      }\n    }, {\n      kind: \"method\",\n      key: \"willUpdate\",\n      value: function willUpdate(changedProps) {\n        if (!this.hasUpdated || changedProps.has(\"unit\")) {\n          this._createOptions();\n        }\n        if (changedProps.has(\"statisticsData\") || changedProps.has(\"statTypes\") || changedProps.has(\"chartType\") || changedProps.has(\"hideLegend\")) {\n          this._generateData();\n        }\n      }\n    }, {\n      kind: \"method\",\n      key: \"firstUpdated\",\n      value: function firstUpdated() {\n        this._computedStyle = getComputedStyle(this);\n      }\n    }, {\n      kind: \"method\",\n      key: \"render\",\n      value: function render() {\n        if (!(0,_common_config_is_component_loaded__WEBPACK_IMPORTED_MODULE_4__.isComponentLoaded)(this.hass, \"history\")) {\n          return lit__WEBPACK_IMPORTED_MODULE_1__.html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.history_charts.history_disabled\")}\n      </div>`;\n        }\n        if (this.isLoadingData && !this.statisticsData) {\n          return lit__WEBPACK_IMPORTED_MODULE_1__.html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.statistics_charts.loading_statistics\")}\n      </div>`;\n        }\n        if (!this.statisticsData || !Object.keys(this.statisticsData).length) {\n          return lit__WEBPACK_IMPORTED_MODULE_1__.html`<div class=\"info\">\n        ${this.hass.localize(\"ui.components.statistics_charts.no_statistics_found\")}\n      </div>`;\n        }\n        return lit__WEBPACK_IMPORTED_MODULE_1__.html`\n      <ha-chart-base\n        .hass=${this.hass}\n        .data=${this._chartData}\n        .options=${this._chartOptions}\n        .chartType=${this.chartType}\n      ></ha-chart-base>\n    `;\n      }\n    }, {\n      kind: \"method\",\n      key: \"_createOptions\",\n      value: function _createOptions(unit) {\n        this._chartOptions = {\n          parsing: false,\n          animation: false,\n          interaction: {\n            mode: \"nearest\",\n            axis: \"x\"\n          },\n          scales: {\n            x: {\n              type: \"time\",\n              adapters: {\n                date: {\n                  locale: this.hass.locale\n                }\n              },\n              ticks: {\n                maxRotation: 0,\n                sampleSize: 5,\n                autoSkipPadding: 20,\n                major: {\n                  enabled: true\n                },\n                font: context => context.tick && context.tick.major ? {\n                  weight: \"bold\"\n                } : {}\n              },\n              time: {\n                tooltipFormat: \"datetime\"\n              }\n            },\n            y: {\n              beginAtZero: false,\n              ticks: {\n                maxTicksLimit: 7\n              },\n              title: {\n                display: unit || this.unit,\n                text: unit || this.unit\n              }\n            }\n          },\n          plugins: {\n            tooltip: {\n              callbacks: {\n                label: context => `${context.dataset.label}: ${(0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_5__.formatNumber)(context.parsed.y, this.hass.locale)} ${\n                // @ts-ignore\n                context.dataset.unit || \"\"}`\n              }\n            },\n            filler: {\n              propagate: true\n            },\n            legend: {\n              display: !this.hideLegend,\n              labels: {\n                usePointStyle: true\n              }\n            }\n          },\n          elements: {\n            line: {\n              tension: 0.4,\n              cubicInterpolationMode: \"monotone\",\n              borderWidth: 1.5\n            },\n            bar: {\n              borderWidth: 1.5,\n              borderRadius: 4\n            },\n            point: {\n              hitRadius: 50\n            }\n          },\n          // @ts-expect-error\n          locale: (0,_common_number_format_number__WEBPACK_IMPORTED_MODULE_5__.numberFormatToLocale)(this.hass.locale)\n        };\n      }\n    }, {\n      kind: \"field\",\n      key: \"_getStatisticsMetaData\",\n      value() {\n        return (0,memoize_one__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(async statisticIds => {\n          const statsMetadataArray = await (0,_data_recorder__WEBPACK_IMPORTED_MODULE_6__.getStatisticMetadata)(this.hass, statisticIds);\n          const statisticsMetaData = {};\n          statsMetadataArray.forEach(x => {\n            statisticsMetaData[x.statistic_id] = x;\n          });\n          return statisticsMetaData;\n        });\n      }\n    }, {\n      kind: \"method\",\n      key: \"_generateData\",\n      value: async function _generateData() {\n        if (!this.statisticsData) {\n          return;\n        }\n        const statisticsMetaData = this.metadata || (await this._getStatisticsMetaData(Object.keys(this.statisticsData)));\n        let colorIndex = 0;\n        const statisticsData = Object.entries(this.statisticsData);\n        const totalDataSets = [];\n        let endTime;\n        if (statisticsData.length === 0) {\n          return;\n        }\n        endTime = this.endTime ||\n        // Get the highest date from the last date of each statistic\n        new Date(Math.max(...statisticsData.map(([_, stats]) => new Date(stats[stats.length - 1].start).getTime())));\n        if (endTime > new Date()) {\n          endTime = new Date();\n        }\n        let unit;\n        const names = this.names || {};\n        statisticsData.forEach(([statistic_id, stats]) => {\n          const meta = statisticsMetaData === null || statisticsMetaData === void 0 ? void 0 : statisticsMetaData[statistic_id];\n          let name = names[statistic_id];\n          if (name === undefined) {\n            name = (0,_data_recorder__WEBPACK_IMPORTED_MODULE_6__.getStatisticLabel)(this.hass, statistic_id, meta);\n          }\n          if (!this.unit) {\n            if (unit === undefined) {\n              unit = (0,_data_recorder__WEBPACK_IMPORTED_MODULE_6__.getDisplayUnit)(this.hass, statistic_id, meta);\n            } else if (unit !== null && unit !== (0,_data_recorder__WEBPACK_IMPORTED_MODULE_6__.getDisplayUnit)(this.hass, statistic_id, meta)) {\n              // Clear unit if not all statistics have same unit\n              unit = null;\n            }\n          }\n\n          // array containing [value1, value2, etc]\n          let prevValues = null;\n          let prevEndTime;\n\n          // The datasets for the current statistic\n          const statDataSets = [];\n          const pushData = (start, end, dataValues) => {\n            if (!dataValues) return;\n            if (start > end) {\n              // Drop data points that are after the requested endTime. This could happen if\n              // endTime is \"now\" and client time is not in sync with server time.\n              return;\n            }\n            statDataSets.forEach((d, i) => {\n              if (this.chartType === \"line\" && prevEndTime && prevValues && prevEndTime.getTime() !== start.getTime()) {\n                // if the end of the previous data doesn't match the start of the current data,\n                // we have to draw a gap so add a value at the end time, and then an empty value.\n                d.data.push({\n                  x: prevEndTime.getTime(),\n                  y: prevValues[i]\n                });\n                // @ts-expect-error\n                d.data.push({\n                  x: prevEndTime.getTime(),\n                  y: null\n                });\n              }\n              d.data.push({\n                x: start.getTime(),\n                y: dataValues[i]\n              });\n            });\n            prevValues = dataValues;\n            prevEndTime = end;\n          };\n          const color = (0,_common_color_colors__WEBPACK_IMPORTED_MODULE_3__.getGraphColorByIndex)(colorIndex, this._computedStyle || getComputedStyle(this));\n          colorIndex++;\n          const statTypes = [];\n          const drawBands = this.statTypes.includes(\"mean\") && (0,_data_recorder__WEBPACK_IMPORTED_MODULE_6__.statisticsHaveType)(stats, \"mean\");\n          const sortedTypes = drawBands ? [...this.statTypes].sort((a, b) => {\n            if (a === \"min\" || b === \"max\") {\n              return -1;\n            }\n            if (a === \"max\" || b === \"min\") {\n              return +1;\n            }\n            return 0;\n          }) : this.statTypes;\n          sortedTypes.forEach(type => {\n            if ((0,_data_recorder__WEBPACK_IMPORTED_MODULE_6__.statisticsHaveType)(stats, type)) {\n              const band = drawBands && (type === \"min\" || type === \"max\");\n              statTypes.push(type);\n              statDataSets.push({\n                label: name ? `${name} (${this.hass.localize(`ui.components.statistics_charts.statistic_types.${type}`)})\n            ` : this.hass.localize(`ui.components.statistics_charts.statistic_types.${type}`),\n                fill: drawBands ? type === \"min\" ? \"+1\" : type === \"max\" ? \"-1\" : false : false,\n                borderColor: band ? color + (this.hideLegend ? \"00\" : \"7F\") : color,\n                backgroundColor: band ? color + \"3F\" : color + \"7F\",\n                pointRadius: 0,\n                data: [],\n                // @ts-ignore\n                unit: meta === null || meta === void 0 ? void 0 : meta.unit_of_measurement,\n                band\n              });\n            }\n          });\n          let prevDate = null;\n          // Process chart data.\n          let firstSum = null;\n          stats.forEach(stat => {\n            const startDate = new Date(stat.start);\n            if (prevDate === startDate) {\n              return;\n            }\n            prevDate = startDate;\n            const dataValues = [];\n            statTypes.forEach(type => {\n              let val;\n              if (type === \"sum\") {\n                if (firstSum === null || firstSum === undefined) {\n                  val = 0;\n                  firstSum = stat.sum;\n                } else {\n                  val = (stat.sum || 0) - firstSum;\n                }\n              } else {\n                val = stat[type];\n              }\n              dataValues.push(val !== null && val !== undefined ? Math.round(val * 100) / 100 : null);\n            });\n            pushData(startDate, new Date(stat.end), dataValues);\n          });\n\n          // Concat two arrays\n          Array.prototype.push.apply(totalDataSets, statDataSets);\n        });\n        if (unit) {\n          this._createOptions(unit);\n        }\n        this._chartData = {\n          datasets: totalDataSets\n        };\n      }\n    }, {\n      kind: \"get\",\n      static: true,\n      key: \"styles\",\n      value: function styles() {\n        return lit__WEBPACK_IMPORTED_MODULE_1__.css`\n      :host {\n        display: block;\n        min-height: 60px;\n      }\n      .info {\n        text-align: center;\n        line-height: 60px;\n        color: var(--secondary-text-color);\n      }\n    `;\n      }\n    }]\n  };\n}, lit__WEBPACK_IMPORTED_MODULE_1__.LitElement);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jaGFydC9zdGF0aXN0aWNzLWNoYXJ0LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBTUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFxWUE7QUFBQTtBQUFBO0FBcllBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUtBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUVBO0FBRUE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4vc3JjL2NvbXBvbmVudHMvY2hhcnQvc3RhdGlzdGljcy1jaGFydC50cz84MWNiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHtcbiAgQ2hhcnREYXRhLFxuICBDaGFydERhdGFzZXQsXG4gIENoYXJ0T3B0aW9ucyxcbiAgQ2hhcnRUeXBlLFxufSBmcm9tIFwiY2hhcnQuanNcIjtcbmltcG9ydCB7XG4gIGNzcyxcbiAgQ1NTUmVzdWx0R3JvdXAsXG4gIGh0bWwsXG4gIExpdEVsZW1lbnQsXG4gIFByb3BlcnR5VmFsdWVzLFxuICBUZW1wbGF0ZVJlc3VsdCxcbn0gZnJvbSBcImxpdFwiO1xuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCwgcHJvcGVydHksIHN0YXRlIH0gZnJvbSBcImxpdC9kZWNvcmF0b3JzXCI7XG5pbXBvcnQgbWVtb2l6ZU9uZSBmcm9tIFwibWVtb2l6ZS1vbmVcIjtcbmltcG9ydCB7IGdldEdyYXBoQ29sb3JCeUluZGV4IH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9jb2xvci9jb2xvcnNcIjtcbmltcG9ydCB7IGlzQ29tcG9uZW50TG9hZGVkIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9jb25maWcvaXNfY29tcG9uZW50X2xvYWRlZFwiO1xuaW1wb3J0IHtcbiAgZm9ybWF0TnVtYmVyLFxuICBudW1iZXJGb3JtYXRUb0xvY2FsZSxcbn0gZnJvbSBcIi4uLy4uL2NvbW1vbi9udW1iZXIvZm9ybWF0X251bWJlclwiO1xuaW1wb3J0IHtcbiAgZ2V0RGlzcGxheVVuaXQsXG4gIGdldFN0YXRpc3RpY0xhYmVsLFxuICBnZXRTdGF0aXN0aWNNZXRhZGF0YSxcbiAgU3RhdGlzdGljcyxcbiAgc3RhdGlzdGljc0hhdmVUeXBlLFxuICBTdGF0aXN0aWNzTWV0YURhdGEsXG4gIFN0YXRpc3RpY1R5cGUsXG59IGZyb20gXCIuLi8uLi9kYXRhL3JlY29yZGVyXCI7XG5pbXBvcnQgdHlwZSB7IEhvbWVBc3Npc3RhbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCBcIi4vaGEtY2hhcnQtYmFzZVwiO1xuXG5leHBvcnQgY29uc3Qgc3VwcG9ydGVkU3RhdFR5cGVNYXA6IFJlY29yZDxTdGF0aXN0aWNUeXBlLCBTdGF0aXN0aWNUeXBlPiA9IHtcbiAgbWVhbjogXCJtZWFuXCIsXG4gIG1pbjogXCJtaW5cIixcbiAgbWF4OiBcIm1heFwiLFxuICBzdW06IFwic3VtXCIsXG4gIHN0YXRlOiBcInN1bVwiLFxuICBjaGFuZ2U6IFwic3VtXCIsXG59O1xuXG5AY3VzdG9tRWxlbWVudChcInN0YXRpc3RpY3MtY2hhcnRcIilcbmNsYXNzIFN0YXRpc3RpY3NDaGFydCBleHRlbmRzIExpdEVsZW1lbnQge1xuICBAcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlIH0pIHB1YmxpYyBoYXNzITogSG9tZUFzc2lzdGFudDtcblxuICBAcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlIH0pIHB1YmxpYyBzdGF0aXN0aWNzRGF0YT86IFN0YXRpc3RpY3M7XG5cbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgbWV0YWRhdGE/OiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIFN0YXRpc3RpY3NNZXRhRGF0YVxuICA+O1xuXG4gIEBwcm9wZXJ0eSgpIHB1YmxpYyBuYW1lcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG5cbiAgQHByb3BlcnR5KCkgcHVibGljIHVuaXQ/OiBzdHJpbmc7XG5cbiAgQHByb3BlcnR5KHsgYXR0cmlidXRlOiBmYWxzZSB9KSBwdWJsaWMgZW5kVGltZT86IERhdGU7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogQXJyYXkgfSkgcHVibGljIHN0YXRUeXBlczogQXJyYXk8U3RhdGlzdGljVHlwZT4gPSBbXG4gICAgXCJzdW1cIixcbiAgICBcIm1pblwiLFxuICAgIFwibWVhblwiLFxuICAgIFwibWF4XCIsXG4gIF07XG5cbiAgQHByb3BlcnR5KCkgcHVibGljIGNoYXJ0VHlwZTogQ2hhcnRUeXBlID0gXCJsaW5lXCI7XG5cbiAgQHByb3BlcnR5KHsgdHlwZTogQm9vbGVhbiB9KSBwdWJsaWMgaGlkZUxlZ2VuZCA9IGZhbHNlO1xuXG4gIEBwcm9wZXJ0eSh7IHR5cGU6IEJvb2xlYW4gfSkgcHVibGljIGlzTG9hZGluZ0RhdGEgPSBmYWxzZTtcblxuICBAc3RhdGUoKSBwcml2YXRlIF9jaGFydERhdGE6IENoYXJ0RGF0YSA9IHsgZGF0YXNldHM6IFtdIH07XG5cbiAgQHN0YXRlKCkgcHJpdmF0ZSBfY2hhcnRPcHRpb25zPzogQ2hhcnRPcHRpb25zO1xuXG4gIHByaXZhdGUgX2NvbXB1dGVkU3R5bGU/OiBDU1NTdHlsZURlY2xhcmF0aW9uO1xuXG4gIHByb3RlY3RlZCBzaG91bGRVcGRhdGUoY2hhbmdlZFByb3BzOiBQcm9wZXJ0eVZhbHVlcyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBjaGFuZ2VkUHJvcHMuc2l6ZSA+IDEgfHwgIWNoYW5nZWRQcm9wcy5oYXMoXCJoYXNzXCIpO1xuICB9XG5cbiAgcHVibGljIHdpbGxVcGRhdGUoY2hhbmdlZFByb3BzOiBQcm9wZXJ0eVZhbHVlcykge1xuICAgIGlmICghdGhpcy5oYXNVcGRhdGVkIHx8IGNoYW5nZWRQcm9wcy5oYXMoXCJ1bml0XCIpKSB7XG4gICAgICB0aGlzLl9jcmVhdGVPcHRpb25zKCk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGNoYW5nZWRQcm9wcy5oYXMoXCJzdGF0aXN0aWNzRGF0YVwiKSB8fFxuICAgICAgY2hhbmdlZFByb3BzLmhhcyhcInN0YXRUeXBlc1wiKSB8fFxuICAgICAgY2hhbmdlZFByb3BzLmhhcyhcImNoYXJ0VHlwZVwiKSB8fFxuICAgICAgY2hhbmdlZFByb3BzLmhhcyhcImhpZGVMZWdlbmRcIilcbiAgICApIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlRGF0YSgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBmaXJzdFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVuZGVyKCk6IFRlbXBsYXRlUmVzdWx0IHtcbiAgICBpZiAoIWlzQ29tcG9uZW50TG9hZGVkKHRoaXMuaGFzcywgXCJoaXN0b3J5XCIpKSB7XG4gICAgICByZXR1cm4gaHRtbGA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgICAgICAke3RoaXMuaGFzcy5sb2NhbGl6ZShcInVpLmNvbXBvbmVudHMuaGlzdG9yeV9jaGFydHMuaGlzdG9yeV9kaXNhYmxlZFwiKX1cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNMb2FkaW5nRGF0YSAmJiAhdGhpcy5zdGF0aXN0aWNzRGF0YSkge1xuICAgICAgcmV0dXJuIGh0bWxgPGRpdiBjbGFzcz1cImluZm9cIj5cbiAgICAgICAgJHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgXCJ1aS5jb21wb25lbnRzLnN0YXRpc3RpY3NfY2hhcnRzLmxvYWRpbmdfc3RhdGlzdGljc1wiXG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5gO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGF0aXN0aWNzRGF0YSB8fCAhT2JqZWN0LmtleXModGhpcy5zdGF0aXN0aWNzRGF0YSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaHRtbGA8ZGl2IGNsYXNzPVwiaW5mb1wiPlxuICAgICAgICAke3RoaXMuaGFzcy5sb2NhbGl6ZShcbiAgICAgICAgICBcInVpLmNvbXBvbmVudHMuc3RhdGlzdGljc19jaGFydHMubm9fc3RhdGlzdGljc19mb3VuZFwiXG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5gO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPGhhLWNoYXJ0LWJhc2VcbiAgICAgICAgLmhhc3M9JHt0aGlzLmhhc3N9XG4gICAgICAgIC5kYXRhPSR7dGhpcy5fY2hhcnREYXRhfVxuICAgICAgICAub3B0aW9ucz0ke3RoaXMuX2NoYXJ0T3B0aW9uc31cbiAgICAgICAgLmNoYXJ0VHlwZT0ke3RoaXMuY2hhcnRUeXBlfVxuICAgICAgPjwvaGEtY2hhcnQtYmFzZT5cbiAgICBgO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3JlYXRlT3B0aW9ucyh1bml0Pzogc3RyaW5nKSB7XG4gICAgdGhpcy5fY2hhcnRPcHRpb25zID0ge1xuICAgICAgcGFyc2luZzogZmFsc2UsXG4gICAgICBhbmltYXRpb246IGZhbHNlLFxuICAgICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgbW9kZTogXCJuZWFyZXN0XCIsXG4gICAgICAgIGF4aXM6IFwieFwiLFxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgdHlwZTogXCJ0aW1lXCIsXG4gICAgICAgICAgYWRhcHRlcnM6IHtcbiAgICAgICAgICAgIGRhdGU6IHtcbiAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmhhc3MubG9jYWxlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBtYXhSb3RhdGlvbjogMCxcbiAgICAgICAgICAgIHNhbXBsZVNpemU6IDUsXG4gICAgICAgICAgICBhdXRvU2tpcFBhZGRpbmc6IDIwLFxuICAgICAgICAgICAgbWFqb3I6IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb250OiAoY29udGV4dCkgPT5cbiAgICAgICAgICAgICAgY29udGV4dC50aWNrICYmIGNvbnRleHQudGljay5tYWpvclxuICAgICAgICAgICAgICAgID8gKHsgd2VpZ2h0OiBcImJvbGRcIiB9IGFzIGFueSlcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltZToge1xuICAgICAgICAgICAgdG9vbHRpcEZvcm1hdDogXCJkYXRldGltZVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBiZWdpbkF0WmVybzogZmFsc2UsXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIG1heFRpY2tzTGltaXQ6IDcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZGlzcGxheTogdW5pdCB8fCB0aGlzLnVuaXQsXG4gICAgICAgICAgICB0ZXh0OiB1bml0IHx8IHRoaXMudW5pdCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgbGFiZWw6IChjb250ZXh0KSA9PlxuICAgICAgICAgICAgICBgJHtjb250ZXh0LmRhdGFzZXQubGFiZWx9OiAke2Zvcm1hdE51bWJlcihcbiAgICAgICAgICAgICAgICBjb250ZXh0LnBhcnNlZC55LFxuICAgICAgICAgICAgICAgIHRoaXMuaGFzcy5sb2NhbGVcbiAgICAgICAgICAgICAgKX0gJHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29udGV4dC5kYXRhc2V0LnVuaXQgfHwgXCJcIlxuICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBmaWxsZXI6IHtcbiAgICAgICAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIGRpc3BsYXk6ICF0aGlzLmhpZGVMZWdlbmQsXG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgbGluZToge1xuICAgICAgICAgIHRlbnNpb246IDAuNCxcbiAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiBcIm1vbm90b25lXCIsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDEuNSxcbiAgICAgICAgfSxcbiAgICAgICAgYmFyOiB7IGJvcmRlcldpZHRoOiAxLjUsIGJvcmRlclJhZGl1czogNCB9LFxuICAgICAgICBwb2ludDoge1xuICAgICAgICAgIGhpdFJhZGl1czogNTAsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgbG9jYWxlOiBudW1iZXJGb3JtYXRUb0xvY2FsZSh0aGlzLmhhc3MubG9jYWxlKSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBfZ2V0U3RhdGlzdGljc01ldGFEYXRhID0gbWVtb2l6ZU9uZShcbiAgICBhc3luYyAoc3RhdGlzdGljSWRzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdHNNZXRhZGF0YUFycmF5ID0gYXdhaXQgZ2V0U3RhdGlzdGljTWV0YWRhdGEoXG4gICAgICAgIHRoaXMuaGFzcyxcbiAgICAgICAgc3RhdGlzdGljSWRzXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhdGlzdGljc01ldGFEYXRhID0ge307XG4gICAgICBzdGF0c01ldGFkYXRhQXJyYXkuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgICBzdGF0aXN0aWNzTWV0YURhdGFbeC5zdGF0aXN0aWNfaWRdID0geDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRpc3RpY3NNZXRhRGF0YTtcbiAgICB9XG4gICk7XG5cbiAgcHJpdmF0ZSBhc3luYyBfZ2VuZXJhdGVEYXRhKCkge1xuICAgIGlmICghdGhpcy5zdGF0aXN0aWNzRGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXRpc3RpY3NNZXRhRGF0YSA9XG4gICAgICB0aGlzLm1ldGFkYXRhIHx8XG4gICAgICAoYXdhaXQgdGhpcy5fZ2V0U3RhdGlzdGljc01ldGFEYXRhKE9iamVjdC5rZXlzKHRoaXMuc3RhdGlzdGljc0RhdGEpKSk7XG5cbiAgICBsZXQgY29sb3JJbmRleCA9IDA7XG4gICAgY29uc3Qgc3RhdGlzdGljc0RhdGEgPSBPYmplY3QuZW50cmllcyh0aGlzLnN0YXRpc3RpY3NEYXRhKTtcbiAgICBjb25zdCB0b3RhbERhdGFTZXRzOiBDaGFydERhdGFzZXQ8XCJsaW5lXCI+W10gPSBbXTtcbiAgICBsZXQgZW5kVGltZTogRGF0ZTtcblxuICAgIGlmIChzdGF0aXN0aWNzRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbmRUaW1lID1cbiAgICAgIHRoaXMuZW5kVGltZSB8fFxuICAgICAgLy8gR2V0IHRoZSBoaWdoZXN0IGRhdGUgZnJvbSB0aGUgbGFzdCBkYXRlIG9mIGVhY2ggc3RhdGlzdGljXG4gICAgICBuZXcgRGF0ZShcbiAgICAgICAgTWF0aC5tYXgoXG4gICAgICAgICAgLi4uc3RhdGlzdGljc0RhdGEubWFwKChbXywgc3RhdHNdKSA9PlxuICAgICAgICAgICAgbmV3IERhdGUoc3RhdHNbc3RhdHMubGVuZ3RoIC0gMV0uc3RhcnQpLmdldFRpbWUoKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcblxuICAgIGlmIChlbmRUaW1lID4gbmV3IERhdGUoKSkge1xuICAgICAgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuXG4gICAgbGV0IHVuaXQ6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw7XG5cbiAgICBjb25zdCBuYW1lcyA9IHRoaXMubmFtZXMgfHwge307XG4gICAgc3RhdGlzdGljc0RhdGEuZm9yRWFjaCgoW3N0YXRpc3RpY19pZCwgc3RhdHNdKSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gc3RhdGlzdGljc01ldGFEYXRhPy5bc3RhdGlzdGljX2lkXTtcbiAgICAgIGxldCBuYW1lID0gbmFtZXNbc3RhdGlzdGljX2lkXTtcbiAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmFtZSA9IGdldFN0YXRpc3RpY0xhYmVsKHRoaXMuaGFzcywgc3RhdGlzdGljX2lkLCBtZXRhKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnVuaXQpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVuaXQgPSBnZXREaXNwbGF5VW5pdCh0aGlzLmhhc3MsIHN0YXRpc3RpY19pZCwgbWV0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdW5pdCAhPT0gbnVsbCAmJlxuICAgICAgICAgIHVuaXQgIT09IGdldERpc3BsYXlVbml0KHRoaXMuaGFzcywgc3RhdGlzdGljX2lkLCBtZXRhKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBDbGVhciB1bml0IGlmIG5vdCBhbGwgc3RhdGlzdGljcyBoYXZlIHNhbWUgdW5pdFxuICAgICAgICAgIHVuaXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFycmF5IGNvbnRhaW5pbmcgW3ZhbHVlMSwgdmFsdWUyLCBldGNdXG4gICAgICBsZXQgcHJldlZhbHVlczogQXJyYXk8bnVtYmVyIHwgbnVsbD4gfCBudWxsID0gbnVsbDtcbiAgICAgIGxldCBwcmV2RW5kVGltZTogRGF0ZSB8IHVuZGVmaW5lZDtcblxuICAgICAgLy8gVGhlIGRhdGFzZXRzIGZvciB0aGUgY3VycmVudCBzdGF0aXN0aWNcbiAgICAgIGNvbnN0IHN0YXREYXRhU2V0czogQ2hhcnREYXRhc2V0PFwibGluZVwiPltdID0gW107XG5cbiAgICAgIGNvbnN0IHB1c2hEYXRhID0gKFxuICAgICAgICBzdGFydDogRGF0ZSxcbiAgICAgICAgZW5kOiBEYXRlLFxuICAgICAgICBkYXRhVmFsdWVzOiBBcnJheTxudW1iZXIgfCBudWxsPiB8IG51bGxcbiAgICAgICkgPT4ge1xuICAgICAgICBpZiAoIWRhdGFWYWx1ZXMpIHJldHVybjtcbiAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgLy8gRHJvcCBkYXRhIHBvaW50cyB0aGF0IGFyZSBhZnRlciB0aGUgcmVxdWVzdGVkIGVuZFRpbWUuIFRoaXMgY291bGQgaGFwcGVuIGlmXG4gICAgICAgICAgLy8gZW5kVGltZSBpcyBcIm5vd1wiIGFuZCBjbGllbnQgdGltZSBpcyBub3QgaW4gc3luYyB3aXRoIHNlcnZlciB0aW1lLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0RGF0YVNldHMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuY2hhcnRUeXBlID09PSBcImxpbmVcIiAmJlxuICAgICAgICAgICAgcHJldkVuZFRpbWUgJiZcbiAgICAgICAgICAgIHByZXZWYWx1ZXMgJiZcbiAgICAgICAgICAgIHByZXZFbmRUaW1lLmdldFRpbWUoKSAhPT0gc3RhcnQuZ2V0VGltZSgpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBkYXRhIGRvZXNuJ3QgbWF0Y2ggdGhlIHN0YXJ0IG9mIHRoZSBjdXJyZW50IGRhdGEsXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGRyYXcgYSBnYXAgc28gYWRkIGEgdmFsdWUgYXQgdGhlIGVuZCB0aW1lLCBhbmQgdGhlbiBhbiBlbXB0eSB2YWx1ZS5cbiAgICAgICAgICAgIGQuZGF0YS5wdXNoKHsgeDogcHJldkVuZFRpbWUuZ2V0VGltZSgpLCB5OiBwcmV2VmFsdWVzW2ldISB9KTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGQuZGF0YS5wdXNoKHsgeDogcHJldkVuZFRpbWUuZ2V0VGltZSgpLCB5OiBudWxsIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkLmRhdGEucHVzaCh7IHg6IHN0YXJ0LmdldFRpbWUoKSwgeTogZGF0YVZhbHVlc1tpXSEgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2VmFsdWVzID0gZGF0YVZhbHVlcztcbiAgICAgICAgcHJldkVuZFRpbWUgPSBlbmQ7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb2xvciA9IGdldEdyYXBoQ29sb3JCeUluZGV4KFxuICAgICAgICBjb2xvckluZGV4LFxuICAgICAgICB0aGlzLl9jb21wdXRlZFN0eWxlIHx8IGdldENvbXB1dGVkU3R5bGUodGhpcylcbiAgICAgICk7XG4gICAgICBjb2xvckluZGV4Kys7XG5cbiAgICAgIGNvbnN0IHN0YXRUeXBlczogdGhpc1tcInN0YXRUeXBlc1wiXSA9IFtdO1xuXG4gICAgICBjb25zdCBkcmF3QmFuZHMgPVxuICAgICAgICB0aGlzLnN0YXRUeXBlcy5pbmNsdWRlcyhcIm1lYW5cIikgJiYgc3RhdGlzdGljc0hhdmVUeXBlKHN0YXRzLCBcIm1lYW5cIik7XG5cbiAgICAgIGNvbnN0IHNvcnRlZFR5cGVzID0gZHJhd0JhbmRzXG4gICAgICAgID8gWy4uLnRoaXMuc3RhdFR5cGVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSA9PT0gXCJtaW5cIiB8fCBiID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhID09PSBcIm1heFwiIHx8IGIgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICsxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSlcbiAgICAgICAgOiB0aGlzLnN0YXRUeXBlcztcblxuICAgICAgc29ydGVkVHlwZXMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGlzdGljc0hhdmVUeXBlKHN0YXRzLCB0eXBlKSkge1xuICAgICAgICAgIGNvbnN0IGJhbmQgPSBkcmF3QmFuZHMgJiYgKHR5cGUgPT09IFwibWluXCIgfHwgdHlwZSA9PT0gXCJtYXhcIik7XG4gICAgICAgICAgc3RhdFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgc3RhdERhdGFTZXRzLnB1c2goe1xuICAgICAgICAgICAgbGFiZWw6IG5hbWVcbiAgICAgICAgICAgICAgPyBgJHtuYW1lfSAoJHt0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgICAgICBgdWkuY29tcG9uZW50cy5zdGF0aXN0aWNzX2NoYXJ0cy5zdGF0aXN0aWNfdHlwZXMuJHt0eXBlfWBcbiAgICAgICAgICAgICAgICApfSlcbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgOiB0aGlzLmhhc3MubG9jYWxpemUoXG4gICAgICAgICAgICAgICAgICBgdWkuY29tcG9uZW50cy5zdGF0aXN0aWNzX2NoYXJ0cy5zdGF0aXN0aWNfdHlwZXMuJHt0eXBlfWBcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgZmlsbDogZHJhd0JhbmRzXG4gICAgICAgICAgICAgID8gdHlwZSA9PT0gXCJtaW5cIlxuICAgICAgICAgICAgICAgID8gXCIrMVwiXG4gICAgICAgICAgICAgICAgOiB0eXBlID09PSBcIm1heFwiXG4gICAgICAgICAgICAgICAgPyBcIi0xXCJcbiAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogYmFuZCA/IGNvbG9yICsgKHRoaXMuaGlkZUxlZ2VuZCA/IFwiMDBcIiA6IFwiN0ZcIikgOiBjb2xvcixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFuZCA/IGNvbG9yICsgXCIzRlwiIDogY29sb3IgKyBcIjdGXCIsXG4gICAgICAgICAgICBwb2ludFJhZGl1czogMCxcbiAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdW5pdDogbWV0YT8udW5pdF9vZl9tZWFzdXJlbWVudCxcbiAgICAgICAgICAgIGJhbmQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBsZXQgcHJldkRhdGU6IERhdGUgfCBudWxsID0gbnVsbDtcbiAgICAgIC8vIFByb2Nlc3MgY2hhcnQgZGF0YS5cbiAgICAgIGxldCBmaXJzdFN1bTogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCA9IG51bGw7XG4gICAgICBzdGF0cy5mb3JFYWNoKChzdGF0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKHN0YXQuc3RhcnQpO1xuICAgICAgICBpZiAocHJldkRhdGUgPT09IHN0YXJ0RGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2RGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlczogQXJyYXk8bnVtYmVyIHwgbnVsbD4gPSBbXTtcbiAgICAgICAgc3RhdFR5cGVzLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICBsZXQgdmFsOiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlID09PSBcInN1bVwiKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RTdW0gPT09IG51bGwgfHwgZmlyc3RTdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICAgICAgICBmaXJzdFN1bSA9IHN0YXQuc3VtO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gKHN0YXQuc3VtIHx8IDApIC0gZmlyc3RTdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9IHN0YXRbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFWYWx1ZXMucHVzaChcbiAgICAgICAgICAgIHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IE1hdGgucm91bmQodmFsICogMTAwKSAvIDEwMFxuICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcHVzaERhdGEoc3RhcnREYXRlLCBuZXcgRGF0ZShzdGF0LmVuZCksIGRhdGFWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENvbmNhdCB0d28gYXJyYXlzXG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0b3RhbERhdGFTZXRzLCBzdGF0RGF0YVNldHMpO1xuICAgIH0pO1xuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZU9wdGlvbnModW5pdCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2hhcnREYXRhID0ge1xuICAgICAgZGF0YXNldHM6IHRvdGFsRGF0YVNldHMsXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3R5bGVzKCk6IENTU1Jlc3VsdEdyb3VwIHtcbiAgICByZXR1cm4gY3NzYFxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgbWluLWhlaWdodDogNjBweDtcbiAgICAgIH1cbiAgICAgIC5pbmZvIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBsaW5lLWhlaWdodDogNjBweDtcbiAgICAgICAgY29sb3I6IHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKTtcbiAgICAgIH1cbiAgICBgO1xuICB9XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIEhUTUxFbGVtZW50VGFnTmFtZU1hcCB7XG4gICAgXCJzdGF0aXN0aWNzLWNoYXJ0XCI6IFN0YXRpc3RpY3NDaGFydDtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/chart/statistics-chart.ts\n");

/***/ })

}]);