{"version":3,"file":"48e15b58.js","mappings":";;AAwCA;;AAEA;AACA;;;AAiOA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAzOA;ACpBA;AAGA;AACA;;;;;AA+QA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAxRA;ACGA;;AAEA;;;AA8QA;AACA;;;;AAIA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;;;AA3RA;;ACaA;;;AAIA;AACA;AACA;AACA;;AAEA;AAEA;AACA;;;;AAhBA;;;;;;;;;AApCA;;;;ACoBA;;;;ACDA;AACA;AACA;AACA;;;AAGA;;;AAGA;;AAGA;AACA;;AAEA;;;AAIA;AACA;;;AAGA;;AAGA;AACA;;;;;;;AAQA;AACA;;;AAGA;;;AAGA;;AA9DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;ACOA;AACA;AACA;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AATA;ACgEA;AAnCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+DA;ACyDA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAGA;;;AAIA;;AAEA;AAEA;AACA;AACA;;AAEA;;;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;AAGA;AAEA;AACA;;;AAIA;;;AAKA;;;AAIA;;;AAGA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAIA;;;;;;;AA7NA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;ACIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AA/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;ACmFA;;AAEA;AACA;AACA;AACA;;AAIA;;AAGA;AACA;;;;;AAuCA;;AAGA;AACA;AACA;;AAEA;AAGA;;AAEA;;;AAGA;;AAGA;AACA;;;AAGA;AAEA;AACA;AAEA;AAEA;AACA;;AAEA;;;;;;AAOA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5JA","sources":["webpack://home-assistant-frontend/./src/components/device/ha-device-picker.ts","webpack://home-assistant-frontend/./src/components/entity/ha-entity-picker.ts","webpack://home-assistant-frontend/./src/components/ha-area-picker.ts","webpack://home-assistant-frontend/./src/components/ha-blueprint-picker.ts","webpack://home-assistant-frontend/./src/components/ha-code-editor.ts","webpack://home-assistant-frontend/./src/components/ha-expansion-panel.ts","webpack://home-assistant-frontend/./src/components/ha-markdown.ts","webpack://home-assistant-frontend/./src/components/ha-selector/ha-selector.ts","webpack://home-assistant-frontend/./src/layouts/ha-app-layout.js","webpack://home-assistant-frontend/./src/layouts/hass-tabs-subpage-data-table.ts","webpack://home-assistant-frontend/./src/components/ha-tab.ts","webpack://home-assistant-frontend/./src/layouts/hass-tabs-subpage.ts"],"sourcesContent":["import \"@material/mwc-list/mwc-list-item\";\nimport { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { stringCompare } from \"../../common/string/compare\";\nimport {\n  AreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../../data/area_registry\";\nimport {\n  computeDeviceName,\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../../data/entity_registry\";\nimport { SubscribeMixin } from \"../../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\n\ninterface Device {\n  name: string;\n  area: string;\n  id: string;\n}\n\nexport type HaDevicePickerDeviceFilterFunc = (\n  device: DeviceRegistryEntry\n) => boolean;\n\nconst rowRenderer: ComboBoxLitRenderer<Device> = (item) => html`<mwc-list-item\n  .twoline=${!!item.area}\n>\n  <span>${item.name}</span>\n  <span slot=\"secondary\">${item.area}</span>\n</mwc-list-item>`;\n\n@customElement(\"ha-device-picker\")\nexport class HaDevicePicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public devices?: DeviceRegistryEntry[];\n\n  @property() public areas?: AreaRegistryEntry[];\n\n  @property() public entities?: EntityRegistryEntry[];\n\n  /**\n   * Show only devices with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no devices with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only devices with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _init = false;\n\n  private _getDevices = memoizeOne(\n    (\n      devices: DeviceRegistryEntry[],\n      areas: AreaRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"]\n    ): Device[] => {\n      if (!devices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_devices\"),\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n      }\n\n      const areaLookup: { [areaId: string]: AreaRegistryEntry } = {};\n      for (const area of areas) {\n        areaLookup[area.area_id] = area;\n      }\n\n      let inputDevices = devices.filter(\n        (device) => device.id === this.value || !device.disabled_by\n      );\n\n      if (includeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices.filter(\n          (device) =>\n            // We always want to include the device of the current value\n            device.id === this.value || deviceFilter!(device)\n        );\n      }\n\n      const outputDevices = inputDevices.map((device) => ({\n        id: device.id,\n        name: computeDeviceName(\n          device,\n          this.hass,\n          deviceEntityLookup[device.id]\n        ),\n        area:\n          device.area_id && areaLookup[device.area_id]\n            ? areaLookup[device.area_id].name\n            : this.hass.localize(\"ui.components.device-picker.no_area\"),\n      }));\n      if (!outputDevices.length) {\n        return [\n          {\n            id: \"no_devices\",\n            area: \"\",\n            name: this.hass.localize(\"ui.components.device-picker.no_match\"),\n          },\n        ];\n      }\n      if (outputDevices.length === 1) {\n        return outputDevices;\n      }\n      return outputDevices.sort((a, b) =>\n        stringCompare(a.name || \"\", b.name || \"\")\n      );\n    }\n  );\n\n  public async open() {\n    await this.updateComplete;\n    await this.comboBox?.open();\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    await this.comboBox?.focus();\n  }\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this.devices = devices;\n      }),\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this.areas = areas;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this.entities = entities;\n      }),\n    ];\n  }\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this.devices && this.areas && this.entities) ||\n      (this._init && changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getDevices(\n        this.devices!,\n        this.areas!,\n        this.entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.device-picker.device\")\n          : this.label}\n        .value=${this._value}\n        .helper=${this.helper}\n        .renderer=${rowRenderer}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        item-value-path=\"id\"\n        item-label-path=\"name\"\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._deviceChanged}\n      ></ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _deviceChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_devices\") {\n      newValue = \"\";\n    }\n\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-device-picker\": HaDevicePicker;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport { HassEntity } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport { computeDomain } from \"../../common/entity/compute_domain\";\nimport { computeStateName } from \"../../common/entity/compute_state_name\";\nimport { caseInsensitiveStringCompare } from \"../../common/string/compare\";\nimport { PolymerChangedEvent } from \"../../polymer-types\";\nimport { HomeAssistant } from \"../../types\";\nimport \"../ha-combo-box\";\nimport type { HaComboBox } from \"../ha-combo-box\";\nimport \"../ha-icon-button\";\nimport \"../ha-svg-icon\";\nimport \"./state-badge\";\n\ninterface HassEntityWithCachedName extends HassEntity {\n  friendly_name: string;\n}\n\nexport type HaEntityPickerEntityFilterFunc = (entity: HassEntity) => boolean;\n\n// eslint-disable-next-line lit/prefer-static-styles\nconst rowRenderer: ComboBoxLitRenderer<HassEntityWithCachedName> = (item) =>\n  html`<mwc-list-item graphic=\"avatar\" .twoline=${!!item.entity_id}>\n    ${item.state\n      ? html`<state-badge slot=\"graphic\" .stateObj=${item}></state-badge>`\n      : \"\"}\n    <span>${item.friendly_name}</span>\n    <span slot=\"secondary\">${item.entity_id}</span>\n  </mwc-list-item>`;\n\n@customElement(\"ha-entity-picker\")\nexport class HaEntityPicker extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public autofocus = false;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @property({ type: Boolean, attribute: \"allow-custom-entity\" })\n  public allowCustomEntity;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  /**\n   * Show entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  /**\n   * Show only entities with these unit of measuments.\n   * @type {Array}\n   * @attr include-unit-of-measurement\n   */\n  @property({ type: Array, attribute: \"include-unit-of-measurement\" })\n  public includeUnitOfMeasurement?: string[];\n\n  /**\n   * List of allowed entities to show. Will ignore all other filters.\n   * @type {Array}\n   * @attr include-entities\n   */\n  @property({ type: Array, attribute: \"include-entities\" })\n  public includeEntities?: string[];\n\n  /**\n   * List of entities to be excluded.\n   * @type {Array}\n   * @attr exclude-entities\n   */\n  @property({ type: Array, attribute: \"exclude-entities\" })\n  public excludeEntities?: string[];\n\n  @property() public entityFilter?: HaEntityPickerEntityFilterFunc;\n\n  @property({ type: Boolean }) public hideClearIcon = false;\n\n  @state() private _opened = false;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  public async open() {\n    await this.updateComplete;\n    await this.comboBox?.open();\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    await this.comboBox?.focus();\n  }\n\n  private _initedStates = false;\n\n  private _states: HassEntityWithCachedName[] = [];\n\n  private _getStates = memoizeOne(\n    (\n      _opened: boolean,\n      hass: this[\"hass\"],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      entityFilter: this[\"entityFilter\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      includeUnitOfMeasurement: this[\"includeUnitOfMeasurement\"],\n      includeEntities: this[\"includeEntities\"],\n      excludeEntities: this[\"excludeEntities\"]\n    ): HassEntityWithCachedName[] => {\n      let states: HassEntityWithCachedName[] = [];\n\n      if (!hass) {\n        return [];\n      }\n      let entityIds = Object.keys(hass.states);\n\n      if (!entityIds.length) {\n        return [\n          {\n            entity_id: \"\",\n            state: \"\",\n            last_changed: \"\",\n            last_updated: \"\",\n            context: { id: \"\", user_id: null, parent_id: null },\n            friendly_name: this.hass!.localize(\n              \"ui.components.entity.entity-picker.no_entities\"\n            ),\n            attributes: {\n              friendly_name: this.hass!.localize(\n                \"ui.components.entity.entity-picker.no_entities\"\n              ),\n              icon: \"mdi:magnify\",\n            },\n          },\n        ];\n      }\n\n      if (includeEntities) {\n        entityIds = entityIds.filter((entityId) =>\n          this.includeEntities!.includes(entityId)\n        );\n\n        return entityIds\n          .map((key) => ({\n            ...hass!.states[key],\n            friendly_name: computeStateName(hass!.states[key]) || key,\n          }))\n          .sort((entityA, entityB) =>\n            caseInsensitiveStringCompare(\n              entityA.friendly_name,\n              entityB.friendly_name\n            )\n          );\n      }\n\n      if (excludeEntities) {\n        entityIds = entityIds.filter(\n          (entityId) => !excludeEntities!.includes(entityId)\n        );\n      }\n\n      if (includeDomains) {\n        entityIds = entityIds.filter((eid) =>\n          includeDomains.includes(computeDomain(eid))\n        );\n      }\n\n      if (excludeDomains) {\n        entityIds = entityIds.filter(\n          (eid) => !excludeDomains.includes(computeDomain(eid))\n        );\n      }\n\n      states = entityIds\n        .map((key) => ({\n          ...hass!.states[key],\n          friendly_name: computeStateName(hass!.states[key]) || key,\n        }))\n        .sort((entityA, entityB) =>\n          caseInsensitiveStringCompare(\n            entityA.friendly_name,\n            entityB.friendly_name\n          )\n        );\n\n      if (includeDeviceClasses) {\n        states = states.filter(\n          (stateObj) =>\n            // We always want to include the entity of the current value\n            stateObj.entity_id === this.value ||\n            (stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class))\n        );\n      }\n\n      if (includeUnitOfMeasurement) {\n        states = states.filter(\n          (stateObj) =>\n            // We always want to include the entity of the current value\n            stateObj.entity_id === this.value ||\n            (stateObj.attributes.unit_of_measurement &&\n              includeUnitOfMeasurement.includes(\n                stateObj.attributes.unit_of_measurement\n              ))\n        );\n      }\n\n      if (entityFilter) {\n        states = states.filter(\n          (stateObj) =>\n            // We always want to include the entity of the current value\n            stateObj.entity_id === this.value || entityFilter!(stateObj)\n        );\n      }\n\n      if (!states.length) {\n        return [\n          {\n            entity_id: \"\",\n            state: \"\",\n            last_changed: \"\",\n            last_updated: \"\",\n            context: { id: \"\", user_id: null, parent_id: null },\n            friendly_name: this.hass!.localize(\n              \"ui.components.entity.entity-picker.no_match\"\n            ),\n            attributes: {\n              friendly_name: this.hass!.localize(\n                \"ui.components.entity.entity-picker.no_match\"\n              ),\n              icon: \"mdi:magnify\",\n            },\n          },\n        ];\n      }\n\n      return states;\n    }\n  );\n\n  protected shouldUpdate(changedProps: PropertyValues) {\n    if (\n      changedProps.has(\"value\") ||\n      changedProps.has(\"label\") ||\n      changedProps.has(\"disabled\")\n    ) {\n      return true;\n    }\n    return !(!changedProps.has(\"_opened\") && this._opened);\n  }\n\n  public willUpdate(changedProps: PropertyValues) {\n    if (!this._initedStates || (changedProps.has(\"_opened\") && this._opened)) {\n      this._states = this._getStates(\n        this._opened,\n        this.hass,\n        this.includeDomains,\n        this.excludeDomains,\n        this.entityFilter,\n        this.includeDeviceClasses,\n        this.includeUnitOfMeasurement,\n        this.includeEntities,\n        this.excludeEntities\n      );\n      if (this._initedStates) {\n        (this.comboBox as any).filteredItems = this._states;\n      }\n      this._initedStates = true;\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        item-value-path=\"entity_id\"\n        item-label-path=\"friendly_name\"\n        .hass=${this.hass}\n        .value=${this._value}\n        .label=${this.label === undefined\n          ? this.hass.localize(\"ui.components.entity.entity-picker.entity\")\n          : this.label}\n        .helper=${this.helper}\n        .allowCustomValue=${this.allowCustomEntity}\n        .filteredItems=${this._states}\n        .renderer=${rowRenderer}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._valueChanged}\n        @filter-changed=${this._filterChanged}\n      >\n      </ha-combo-box>\n    `;\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _valueChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    const newValue = ev.detail.value;\n    if (newValue !== this._value) {\n      this._setValue(newValue);\n    }\n  }\n\n  private _filterChanged(ev: CustomEvent): void {\n    const filterString = ev.detail.value.toLowerCase();\n    (this.comboBox as any).filteredItems = this._states.filter(\n      (entityState) =>\n        entityState.entity_id.toLowerCase().includes(filterString) ||\n        computeStateName(entityState).toLowerCase().includes(filterString)\n    );\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-entity-picker\": HaEntityPicker;\n  }\n}\n","import { UnsubscribeFunc } from \"home-assistant-js-websocket\";\nimport { html, LitElement, PropertyValues, TemplateResult } from \"lit\";\nimport { ComboBoxLitRenderer } from \"@vaadin/combo-box/lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { computeDomain } from \"../common/entity/compute_domain\";\nimport {\n  AreaRegistryEntry,\n  createAreaRegistryEntry,\n  subscribeAreaRegistry,\n} from \"../data/area_registry\";\nimport {\n  DeviceEntityLookup,\n  DeviceRegistryEntry,\n  subscribeDeviceRegistry,\n} from \"../data/device_registry\";\nimport {\n  EntityRegistryEntry,\n  subscribeEntityRegistry,\n} from \"../data/entity_registry\";\nimport {\n  showAlertDialog,\n  showPromptDialog,\n} from \"../dialogs/generic/show-dialog-box\";\nimport { SubscribeMixin } from \"../mixins/subscribe-mixin\";\nimport { PolymerChangedEvent } from \"../polymer-types\";\nimport { HomeAssistant } from \"../types\";\nimport type { HaDevicePickerDeviceFilterFunc } from \"./device/ha-device-picker\";\nimport \"./ha-combo-box\";\nimport type { HaComboBox } from \"./ha-combo-box\";\nimport \"./ha-icon-button\";\nimport \"./ha-svg-icon\";\n\nconst rowRenderer: ComboBoxLitRenderer<AreaRegistryEntry> = (\n  item\n) => html`<mwc-list-item\n  class=${classMap({ \"add-new\": item.area_id === \"add_new\" })}\n>\n  ${item.name}\n</mwc-list-item>`;\n\n@customElement(\"ha-area-picker\")\nexport class HaAreaPicker extends SubscribeMixin(LitElement) {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value?: string;\n\n  @property() public helper?: string;\n\n  @property() public placeholder?: string;\n\n  @property({ type: Boolean, attribute: \"no-add\" })\n  public noAdd?: boolean;\n\n  /**\n   * Show only areas with entities from specific domains.\n   * @type {Array}\n   * @attr include-domains\n   */\n  @property({ type: Array, attribute: \"include-domains\" })\n  public includeDomains?: string[];\n\n  /**\n   * Show no areas with entities of these domains.\n   * @type {Array}\n   * @attr exclude-domains\n   */\n  @property({ type: Array, attribute: \"exclude-domains\" })\n  public excludeDomains?: string[];\n\n  /**\n   * Show only areas with entities of these device classes.\n   * @type {Array}\n   * @attr include-device-classes\n   */\n  @property({ type: Array, attribute: \"include-device-classes\" })\n  public includeDeviceClasses?: string[];\n\n  @property() public deviceFilter?: HaDevicePickerDeviceFilterFunc;\n\n  @property() public entityFilter?: (entity: EntityRegistryEntry) => boolean;\n\n  @property({ type: Boolean }) public disabled?: boolean;\n\n  @property({ type: Boolean }) public required?: boolean;\n\n  @state() private _areas?: AreaRegistryEntry[];\n\n  @state() private _devices?: DeviceRegistryEntry[];\n\n  @state() private _entities?: EntityRegistryEntry[];\n\n  @state() private _opened?: boolean;\n\n  @query(\"ha-combo-box\", true) public comboBox!: HaComboBox;\n\n  private _filter?: string;\n\n  private _init = false;\n\n  public hassSubscribe(): UnsubscribeFunc[] {\n    return [\n      subscribeAreaRegistry(this.hass.connection!, (areas) => {\n        this._areas = areas;\n      }),\n      subscribeDeviceRegistry(this.hass.connection!, (devices) => {\n        this._devices = devices;\n      }),\n      subscribeEntityRegistry(this.hass.connection!, (entities) => {\n        this._entities = entities;\n      }),\n    ];\n  }\n\n  public async open() {\n    await this.updateComplete;\n    await this.comboBox?.open();\n  }\n\n  public async focus() {\n    await this.updateComplete;\n    await this.comboBox?.focus();\n  }\n\n  private _getAreas = memoizeOne(\n    (\n      areas: AreaRegistryEntry[],\n      devices: DeviceRegistryEntry[],\n      entities: EntityRegistryEntry[],\n      includeDomains: this[\"includeDomains\"],\n      excludeDomains: this[\"excludeDomains\"],\n      includeDeviceClasses: this[\"includeDeviceClasses\"],\n      deviceFilter: this[\"deviceFilter\"],\n      entityFilter: this[\"entityFilter\"],\n      noAdd: this[\"noAdd\"]\n    ): AreaRegistryEntry[] => {\n      if (!areas.length) {\n        return [\n          {\n            area_id: \"no_areas\",\n            name: this.hass.localize(\"ui.components.area-picker.no_areas\"),\n            picture: null,\n          },\n        ];\n      }\n\n      const deviceEntityLookup: DeviceEntityLookup = {};\n      let inputDevices: DeviceRegistryEntry[] | undefined;\n      let inputEntities: EntityRegistryEntry[] | undefined;\n\n      if (includeDomains || excludeDomains || includeDeviceClasses) {\n        for (const entity of entities) {\n          if (!entity.device_id) {\n            continue;\n          }\n          if (!(entity.device_id in deviceEntityLookup)) {\n            deviceEntityLookup[entity.device_id] = [];\n          }\n          deviceEntityLookup[entity.device_id].push(entity);\n        }\n        inputDevices = devices;\n        inputEntities = entities.filter((entity) => entity.area_id);\n      } else {\n        if (deviceFilter) {\n          inputDevices = devices;\n        }\n        if (entityFilter) {\n          inputEntities = entities.filter((entity) => entity.area_id);\n        }\n      }\n\n      if (includeDomains) {\n        inputDevices = inputDevices!.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) =>\n            includeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n        inputEntities = inputEntities!.filter((entity) =>\n          includeDomains.includes(computeDomain(entity.entity_id))\n        );\n      }\n\n      if (excludeDomains) {\n        inputDevices = inputDevices!.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return true;\n          }\n          return entities.every(\n            (entity) =>\n              !excludeDomains.includes(computeDomain(entity.entity_id))\n          );\n        });\n        inputEntities = inputEntities!.filter(\n          (entity) => !excludeDomains.includes(computeDomain(entity.entity_id))\n        );\n      }\n\n      if (includeDeviceClasses) {\n        inputDevices = inputDevices!.filter((device) => {\n          const devEntities = deviceEntityLookup[device.id];\n          if (!devEntities || !devEntities.length) {\n            return false;\n          }\n          return deviceEntityLookup[device.id].some((entity) => {\n            const stateObj = this.hass.states[entity.entity_id];\n            if (!stateObj) {\n              return false;\n            }\n            return (\n              stateObj.attributes.device_class &&\n              includeDeviceClasses.includes(stateObj.attributes.device_class)\n            );\n          });\n        });\n        inputEntities = inputEntities!.filter((entity) => {\n          const stateObj = this.hass.states[entity.entity_id];\n          return (\n            stateObj.attributes.device_class &&\n            includeDeviceClasses.includes(stateObj.attributes.device_class)\n          );\n        });\n      }\n\n      if (deviceFilter) {\n        inputDevices = inputDevices!.filter((device) => deviceFilter!(device));\n      }\n\n      if (entityFilter) {\n        inputEntities = inputEntities!.filter((entity) =>\n          entityFilter!(entity)\n        );\n      }\n\n      let outputAreas = areas;\n\n      let areaIds: string[] | undefined;\n\n      if (inputDevices) {\n        areaIds = inputDevices\n          .filter((device) => device.area_id)\n          .map((device) => device.area_id!);\n      }\n\n      if (inputEntities) {\n        areaIds = (areaIds ?? []).concat(\n          inputEntities\n            .filter((entity) => entity.area_id)\n            .map((entity) => entity.area_id!)\n        );\n      }\n\n      if (areaIds) {\n        outputAreas = areas.filter((area) => areaIds!.includes(area.area_id));\n      }\n\n      if (!outputAreas.length) {\n        outputAreas = [\n          {\n            area_id: \"no_areas\",\n            name: this.hass.localize(\"ui.components.area-picker.no_match\"),\n            picture: null,\n          },\n        ];\n      }\n\n      return noAdd\n        ? outputAreas\n        : [\n            ...outputAreas,\n            {\n              area_id: \"add_new\",\n              name: this.hass.localize(\"ui.components.area-picker.add_new\"),\n              picture: null,\n            },\n          ];\n    }\n  );\n\n  protected updated(changedProps: PropertyValues) {\n    if (\n      (!this._init && this._devices && this._areas && this._entities) ||\n      (this._init && changedProps.has(\"_opened\") && this._opened)\n    ) {\n      this._init = true;\n      (this.comboBox as any).items = this._getAreas(\n        this._areas!,\n        this._devices!,\n        this._entities!,\n        this.includeDomains,\n        this.excludeDomains,\n        this.includeDeviceClasses,\n        this.deviceFilter,\n        this.entityFilter,\n        this.noAdd\n      );\n    }\n  }\n\n  protected render(): TemplateResult {\n    return html`\n      <ha-combo-box\n        .hass=${this.hass}\n        .helper=${this.helper}\n        item-value-path=\"area_id\"\n        item-id-path=\"area_id\"\n        item-label-path=\"name\"\n        .value=${this.value}\n        .disabled=${this.disabled}\n        .required=${this.required}\n        .label=${this.label === undefined && this.hass\n          ? this.hass.localize(\"ui.components.area-picker.area\")\n          : this.label}\n        .placeholder=${this.placeholder\n          ? this._area(this.placeholder)?.name\n          : undefined}\n        .renderer=${rowRenderer}\n        @filter-changed=${this._filterChanged}\n        @opened-changed=${this._openedChanged}\n        @value-changed=${this._areaChanged}\n      >\n      </ha-combo-box>\n    `;\n  }\n\n  private _area = memoizeOne((areaId: string): AreaRegistryEntry | undefined =>\n    this._areas?.find((area) => area.area_id === areaId)\n  );\n\n  private _filterChanged(ev: CustomEvent): void {\n    this._filter = ev.detail.value;\n    if (!this._filter) {\n      this.comboBox.filteredItems = this.comboBox.items;\n      return;\n    }\n    // @ts-ignore\n    if (!this.noAdd && this.comboBox._comboBox.filteredItems?.length === 0) {\n      this.comboBox.filteredItems = [\n        {\n          area_id: \"add_new_suggestion\",\n          name: this.hass.localize(\n            \"ui.components.area-picker.add_new_sugestion\",\n            { name: this._filter }\n          ),\n          picture: null,\n        },\n      ];\n    } else {\n      this.comboBox.filteredItems = this.comboBox.items?.filter((item) =>\n        item.name.toLowerCase().includes(this._filter!.toLowerCase())\n      );\n    }\n  }\n\n  private get _value() {\n    return this.value || \"\";\n  }\n\n  private _openedChanged(ev: PolymerChangedEvent<boolean>) {\n    this._opened = ev.detail.value;\n  }\n\n  private _areaChanged(ev: PolymerChangedEvent<string>) {\n    ev.stopPropagation();\n    let newValue = ev.detail.value;\n\n    if (newValue === \"no_areas\") {\n      newValue = \"\";\n    }\n\n    if (![\"add_new_suggestion\", \"add_new\"].includes(newValue)) {\n      if (newValue !== this._value) {\n        this._setValue(newValue);\n      }\n      return;\n    }\n\n    (ev.target as any).value = this._value;\n    showPromptDialog(this, {\n      title: this.hass.localize(\"ui.components.area-picker.add_dialog.title\"),\n      text: this.hass.localize(\"ui.components.area-picker.add_dialog.text\"),\n      confirmText: this.hass.localize(\n        \"ui.components.area-picker.add_dialog.add\"\n      ),\n      inputLabel: this.hass.localize(\n        \"ui.components.area-picker.add_dialog.name\"\n      ),\n      defaultValue:\n        newValue === \"add_new_suggestion\" ? this._filter : undefined,\n      confirm: async (name) => {\n        if (!name) {\n          return;\n        }\n        try {\n          const area = await createAreaRegistryEntry(this.hass, {\n            name,\n          });\n          this._areas = [...this._areas!, area];\n          (this.comboBox as any).filteredItems = this._getAreas(\n            this._areas!,\n            this._devices!,\n            this._entities!,\n            this.includeDomains,\n            this.excludeDomains,\n            this.includeDeviceClasses,\n            this.deviceFilter,\n            this.entityFilter,\n            this.noAdd\n          );\n          await this.updateComplete;\n          await this.comboBox.updateComplete;\n          this._setValue(area.area_id);\n        } catch (err: any) {\n          showAlertDialog(this, {\n            title: this.hass.localize(\n              \"ui.components.area-picker.add_dialog.failed_create_area\"\n            ),\n            text: err.message,\n          });\n        }\n      },\n    });\n  }\n\n  private _setValue(value: string) {\n    this.value = value;\n    setTimeout(() => {\n      fireEvent(this, \"value-changed\", { value });\n      fireEvent(this, \"change\");\n    }, 0);\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-area-picker\": HaAreaPicker;\n  }\n}\n","import \"@material/mwc-list/mwc-list-item\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { stopPropagation } from \"../common/dom/stop_propagation\";\nimport { stringCompare } from \"../common/string/compare\";\nimport {\n  Blueprint,\n  BlueprintDomain,\n  Blueprints,\n  fetchBlueprints,\n} from \"../data/blueprint\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-select\";\n\n@customElement(\"ha-blueprint-picker\")\nclass HaBluePrintPicker extends LitElement {\n  public hass?: HomeAssistant;\n\n  @property() public label?: string;\n\n  @property() public value = \"\";\n\n  @property() public domain: BlueprintDomain = \"automation\";\n\n  @property() public blueprints?: Blueprints;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  public open() {\n    const select = this.shadowRoot?.querySelector(\"ha-select\");\n    if (select) {\n      // @ts-expect-error\n      select.menuOpen = true;\n    }\n  }\n\n  private _processedBlueprints = memoizeOne((blueprints?: Blueprints) => {\n    if (!blueprints) {\n      return [];\n    }\n    const result = Object.entries(blueprints)\n      .filter(([_path, blueprint]) => !(\"error\" in blueprint))\n      .map(([path, blueprint]) => ({\n        ...(blueprint as Blueprint).metadata,\n        path,\n      }));\n    return result.sort((a, b) => stringCompare(a.name, b.name));\n  });\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n    return html`\n      <ha-select\n        .label=${this.label ||\n        this.hass.localize(\"ui.components.blueprint-picker.select_blueprint\")}\n        fixedMenuPosition\n        naturalMenuWidth\n        .value=${this.value}\n        .disabled=${this.disabled}\n        @selected=${this._blueprintChanged}\n        @closed=${stopPropagation}\n      >\n        ${this._processedBlueprints(this.blueprints).map(\n          (blueprint) => html`\n            <mwc-list-item .value=${blueprint.path}>\n              ${blueprint.name}\n            </mwc-list-item>\n          `\n        )}\n      </ha-select>\n    `;\n  }\n\n  protected firstUpdated(changedProps) {\n    super.firstUpdated(changedProps);\n    if (this.blueprints === undefined) {\n      fetchBlueprints(this.hass!, this.domain).then((blueprints) => {\n        this.blueprints = blueprints;\n      });\n    }\n  }\n\n  private _blueprintChanged(ev) {\n    const newValue = ev.target.value;\n\n    if (newValue !== this.value) {\n      this.value = newValue;\n      setTimeout(() => {\n        fireEvent(this, \"value-changed\", { value: newValue });\n        fireEvent(this, \"change\");\n      }, 0);\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: inline-block;\n      }\n      ha-select {\n        width: 100%;\n        min-width: 200px;\n        display: block;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-blueprint-picker\": HaBluePrintPicker;\n  }\n}\n","import type {\n  Completion,\n  CompletionContext,\n  CompletionResult,\n  CompletionSource,\n} from \"@codemirror/autocomplete\";\nimport type { EditorView, KeyBinding, ViewUpdate } from \"@codemirror/view\";\nimport { HassEntities } from \"home-assistant-js-websocket\";\nimport { css, CSSResultGroup, PropertyValues, ReactiveElement } from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport memoizeOne from \"memoize-one\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { loadCodeMirror } from \"../resources/codemirror.ondemand\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-icon\";\n\ndeclare global {\n  interface HASSDomEvents {\n    \"editor-save\": undefined;\n  }\n}\n\nconst saveKeyBinding: KeyBinding = {\n  key: \"Mod-s\",\n  run: (view: EditorView) => {\n    fireEvent(view.dom, \"editor-save\");\n    return true;\n  },\n};\n\nconst renderIcon = (completion: Completion) => {\n  const icon = document.createElement(\"ha-icon\");\n  icon.icon = completion.label;\n  return icon;\n};\n\n@customElement(\"ha-code-editor\")\nexport class HaCodeEditor extends ReactiveElement {\n  public codemirror?: EditorView;\n\n  @property() public mode = \"yaml\";\n\n  public hass?: HomeAssistant;\n\n  @property({ type: Boolean }) public autofocus = false;\n\n  @property({ type: Boolean }) public readOnly = false;\n\n  @property({ type: Boolean, attribute: \"autocomplete-entities\" })\n  public autocompleteEntities = false;\n\n  @property({ type: Boolean, attribute: \"autocomplete-icons\" })\n  public autocompleteIcons = false;\n\n  @property() public error = false;\n\n  @state() private _value = \"\";\n\n  private _loadedCodeMirror?: typeof import(\"../resources/codemirror\");\n\n  private _iconList?: Completion[];\n\n  public set value(value: string) {\n    this._value = value;\n  }\n\n  public get value(): string {\n    return this.codemirror ? this.codemirror.state.doc.toString() : this._value;\n  }\n\n  public get hasComments(): boolean {\n    if (!this.codemirror || !this._loadedCodeMirror) {\n      return false;\n    }\n    const className = this._loadedCodeMirror.HighlightStyle.get(\n      this.codemirror.state,\n      this._loadedCodeMirror.tags.comment\n    );\n    return !!this.shadowRoot!.querySelector(`span.${className}`);\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    if (!this.codemirror) {\n      return;\n    }\n    if (this.autofocus !== false) {\n      this.codemirror.focus();\n    }\n  }\n\n  protected update(changedProps: PropertyValues): void {\n    super.update(changedProps);\n\n    if (!this.codemirror) {\n      return;\n    }\n\n    if (changedProps.has(\"mode\")) {\n      this.codemirror.dispatch({\n        effects: this._loadedCodeMirror!.langCompartment!.reconfigure(\n          this._mode\n        ),\n      });\n    }\n    if (changedProps.has(\"readOnly\")) {\n      this.codemirror.dispatch({\n        effects: this._loadedCodeMirror!.readonlyCompartment!.reconfigure(\n          this._loadedCodeMirror!.EditorView!.editable.of(!this.readOnly)\n        ),\n      });\n    }\n    if (changedProps.has(\"_value\") && this._value !== this.value) {\n      this.codemirror.dispatch({\n        changes: {\n          from: 0,\n          to: this.codemirror.state.doc.length,\n          insert: this._value,\n        },\n      });\n    }\n    if (changedProps.has(\"error\")) {\n      this.classList.toggle(\"error-state\", this.error);\n    }\n  }\n\n  protected firstUpdated(changedProps: PropertyValues): void {\n    super.firstUpdated(changedProps);\n    this._blockKeyboardShortcuts();\n    this._load();\n  }\n\n  private get _mode() {\n    return this._loadedCodeMirror!.langs[this.mode];\n  }\n\n  private async _load(): Promise<void> {\n    this._loadedCodeMirror = await loadCodeMirror();\n    const extensions = [\n      this._loadedCodeMirror.lineNumbers(),\n      this._loadedCodeMirror.EditorState.allowMultipleSelections.of(true),\n      this._loadedCodeMirror.history(),\n      this._loadedCodeMirror.highlightSelectionMatches(),\n      this._loadedCodeMirror.highlightActiveLine(),\n      this._loadedCodeMirror.drawSelection(),\n      this._loadedCodeMirror.rectangularSelection(),\n      this._loadedCodeMirror.keymap.of([\n        ...this._loadedCodeMirror.defaultKeymap,\n        ...this._loadedCodeMirror.searchKeymap,\n        ...this._loadedCodeMirror.historyKeymap,\n        ...this._loadedCodeMirror.tabKeyBindings,\n        saveKeyBinding,\n      ] as KeyBinding[]),\n      this._loadedCodeMirror.langCompartment.of(this._mode),\n      this._loadedCodeMirror.theme,\n      this._loadedCodeMirror.Prec.fallback(\n        this._loadedCodeMirror.highlightStyle\n      ),\n      this._loadedCodeMirror.readonlyCompartment.of(\n        this._loadedCodeMirror.EditorView.editable.of(!this.readOnly)\n      ),\n      this._loadedCodeMirror.EditorView.updateListener.of((update) =>\n        this._onUpdate(update)\n      ),\n    ];\n\n    if (!this.readOnly) {\n      const completionSources: CompletionSource[] = [];\n      if (this.autocompleteEntities && this.hass) {\n        completionSources.push(this._entityCompletions.bind(this));\n      }\n      if (this.autocompleteIcons) {\n        completionSources.push(this._mdiCompletions.bind(this));\n      }\n      if (completionSources.length > 0) {\n        extensions.push(\n          this._loadedCodeMirror.autocompletion({\n            override: completionSources,\n            maxRenderedOptions: 10,\n          })\n        );\n      }\n    }\n\n    this.codemirror = new this._loadedCodeMirror.EditorView({\n      state: this._loadedCodeMirror.EditorState.create({\n        doc: this._value,\n        extensions,\n      }),\n      root: this.shadowRoot!,\n      parent: this.shadowRoot!,\n    });\n  }\n\n  private _getStates = memoizeOne((states: HassEntities): Completion[] => {\n    if (!states) {\n      return [];\n    }\n    const options = Object.keys(states).map((key) => ({\n      type: \"variable\",\n      label: key,\n      detail: states[key].attributes.friendly_name,\n      info: `State: ${states[key].state}`,\n    }));\n\n    return options;\n  });\n\n  private _entityCompletions(\n    context: CompletionContext\n  ): CompletionResult | null | Promise<CompletionResult | null> {\n    const entityWord = context.matchBefore(/[a-z_]{3,}\\.\\w*/);\n\n    if (\n      !entityWord ||\n      (entityWord.from === entityWord.to && !context.explicit)\n    ) {\n      return null;\n    }\n\n    const states = this._getStates(this.hass!.states);\n\n    if (!states || !states.length) {\n      return null;\n    }\n\n    return {\n      from: Number(entityWord.from),\n      options: states,\n      span: /^[a-z_]{3,}\\.\\w*$/,\n    };\n  }\n\n  private _getIconItems = async (): Promise<Completion[]> => {\n    if (!this._iconList) {\n      let iconList: {\n        name: string;\n        keywords: string[];\n      }[];\n      if (__SUPERVISOR__) {\n        iconList = [];\n      } else {\n        iconList = (await import(\"../../build/mdi/iconList.json\")).default;\n      }\n\n      this._iconList = iconList.map((icon) => ({\n        type: \"variable\",\n        label: `mdi:${icon.name}`,\n        detail: icon.keywords.join(\", \"),\n        info: renderIcon,\n      }));\n    }\n\n    return this._iconList;\n  };\n\n  private async _mdiCompletions(\n    context: CompletionContext\n  ): Promise<CompletionResult | null> {\n    const match = context.matchBefore(/mdi:\\S*/);\n\n    if (!match || (match.from === match.to && !context.explicit)) {\n      return null;\n    }\n\n    const iconItems = await this._getIconItems();\n\n    return {\n      from: Number(match.from),\n      options: iconItems,\n      span: /^mdi:\\S*$/,\n    };\n  }\n\n  private _blockKeyboardShortcuts() {\n    this.addEventListener(\"keydown\", (ev) => ev.stopPropagation());\n  }\n\n  private _onUpdate(update: ViewUpdate): void {\n    if (!update.docChanged) {\n      return;\n    }\n    const newValue = this.value;\n    if (newValue === this._value) {\n      return;\n    }\n    this._value = newValue;\n    fireEvent(this, \"value-changed\", { value: this._value });\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host(.error-state) .cm-gutters {\n        border-color: var(--error-state-color, red);\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-code-editor\": HaCodeEditor;\n  }\n}\n","import { mdiChevronDown } from \"@mdi/js\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, query, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { nextRender } from \"../common/util/render-status\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-expansion-panel\")\nexport class HaExpansionPanel extends LitElement {\n  @property({ type: Boolean, reflect: true }) expanded = false;\n\n  @property({ type: Boolean, reflect: true }) outlined = false;\n\n  @property({ type: Boolean, reflect: true }) leftChevron = false;\n\n  @property() header?: string;\n\n  @property() secondary?: string;\n\n  @state() _showContent = this.expanded;\n\n  @query(\".container\") private _container!: HTMLDivElement;\n\n  protected render(): TemplateResult {\n    return html`\n      <div class=\"top\">\n        <div\n          id=\"summary\"\n          @click=${this._toggleContainer}\n          @keydown=${this._toggleContainer}\n          @focus=${this._focusChanged}\n          @blur=${this._focusChanged}\n          role=\"button\"\n          tabindex=\"0\"\n          aria-expanded=${this.expanded}\n          aria-controls=\"sect1\"\n        >\n          ${this.leftChevron\n            ? html`\n                <ha-svg-icon\n                  .path=${mdiChevronDown}\n                  class=\"summary-icon ${classMap({ expanded: this.expanded })}\"\n                ></ha-svg-icon>\n              `\n            : \"\"}\n          <slot name=\"header\">\n            <div class=\"header\">\n              ${this.header}\n              <slot class=\"secondary\" name=\"secondary\">${this.secondary}</slot>\n            </div>\n          </slot>\n          ${!this.leftChevron\n            ? html`\n                <ha-svg-icon\n                  .path=${mdiChevronDown}\n                  class=\"summary-icon ${classMap({ expanded: this.expanded })}\"\n                ></ha-svg-icon>\n              `\n            : \"\"}\n        </div>\n        <slot name=\"icons\"></slot>\n      </div>\n      <div\n        class=\"container ${classMap({ expanded: this.expanded })}\"\n        @transitionend=${this._handleTransitionEnd}\n        role=\"region\"\n        aria-labelledby=\"summary\"\n        aria-hidden=${!this.expanded}\n        tabindex=\"-1\"\n      >\n        ${this._showContent ? html`<slot></slot>` : \"\"}\n      </div>\n    `;\n  }\n\n  protected willUpdate(changedProps: PropertyValues) {\n    super.willUpdate(changedProps);\n    if (changedProps.has(\"expanded\") && this.expanded) {\n      this._showContent = this.expanded;\n      setTimeout(() => {\n        // Verify we're still expanded\n        if (this.expanded) {\n          this._container.style.overflow = \"initial\";\n        }\n      }, 300);\n    }\n  }\n\n  private _handleTransitionEnd() {\n    this._container.style.removeProperty(\"height\");\n    this._container.style.overflow = this.expanded ? \"initial\" : \"hidden\";\n    this._showContent = this.expanded;\n  }\n\n  private async _toggleContainer(ev): Promise<void> {\n    if (ev.defaultPrevented) {\n      return;\n    }\n    if (ev.type === \"keydown\" && ev.key !== \"Enter\" && ev.key !== \" \") {\n      return;\n    }\n    ev.preventDefault();\n    const newExpanded = !this.expanded;\n    fireEvent(this, \"expanded-will-change\", { expanded: newExpanded });\n    this._container.style.overflow = \"hidden\";\n\n    if (newExpanded) {\n      this._showContent = true;\n      // allow for dynamic content to be rendered\n      await nextRender();\n    }\n\n    const scrollHeight = this._container.scrollHeight;\n    this._container.style.height = `${scrollHeight}px`;\n\n    if (!newExpanded) {\n      setTimeout(() => {\n        this._container.style.height = \"0px\";\n      }, 0);\n    }\n\n    this.expanded = newExpanded;\n    fireEvent(this, \"expanded-changed\", { expanded: this.expanded });\n  }\n\n  private _focusChanged(ev) {\n    this.shadowRoot!.querySelector(\".top\")!.classList.toggle(\n      \"focused\",\n      ev.type === \"focus\"\n    );\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n\n      .top {\n        display: flex;\n        align-items: center;\n      }\n\n      .top.focused {\n        background: var(--input-fill-color);\n      }\n\n      :host([outlined]) {\n        box-shadow: none;\n        border-width: 1px;\n        border-style: solid;\n        border-color: var(\n          --ha-card-border-color,\n          var(--divider-color, #e0e0e0)\n        );\n        border-radius: var(--ha-card-border-radius, 12px);\n      }\n\n      .summary-icon {\n        margin-left: 8px;\n      }\n\n      :host([leftchevron]) .summary-icon {\n        margin-left: 0;\n        margin-right: 8px;\n      }\n\n      #summary {\n        flex: 1;\n        display: flex;\n        padding: var(--expansion-panel-summary-padding, 0 8px);\n        min-height: 48px;\n        align-items: center;\n        cursor: pointer;\n        overflow: hidden;\n        font-weight: 500;\n        outline: none;\n      }\n\n      .summary-icon {\n        transition: transform 150ms cubic-bezier(0.4, 0, 0.2, 1);\n        direction: var(--direction);\n      }\n\n      .summary-icon.expanded {\n        transform: rotate(180deg);\n      }\n\n      .header,\n      ::slotted([slot=\"header\"]) {\n        flex: 1;\n      }\n\n      .container {\n        padding: var(--expansion-panel-content-padding, 0 8px);\n        overflow: hidden;\n        transition: height 300ms cubic-bezier(0.4, 0, 0.2, 1);\n        height: 0px;\n      }\n\n      .container.expanded {\n        height: auto;\n      }\n\n      .secondary {\n        display: block;\n        color: var(--secondary-text-color);\n        font-size: 12px;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-expansion-panel\": HaExpansionPanel;\n  }\n\n  // for fire event\n  interface HASSDomEvents {\n    \"expanded-changed\": {\n      expanded: boolean;\n    };\n    \"expanded-will-change\": {\n      expanded: boolean;\n    };\n  }\n}\n","import { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport \"./ha-markdown-element\";\n\n// Import components that are allwoed to be defined.\nimport \"./ha-alert\";\nimport \"./ha-icon\";\nimport \"./ha-svg-icon\";\n\n@customElement(\"ha-markdown\")\nexport class HaMarkdown extends LitElement {\n  @property() public content?;\n\n  @property({ type: Boolean }) public allowSvg = false;\n\n  @property({ type: Boolean }) public breaks = false;\n\n  protected render(): TemplateResult {\n    if (!this.content) {\n      return html``;\n    }\n\n    return html`<ha-markdown-element\n      .content=${this.content}\n      .allowSvg=${this.allowSvg}\n      .breaks=${this.breaks}\n    ></ha-markdown-element>`;\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n      ha-markdown-element {\n        -ms-user-select: text;\n        -webkit-user-select: text;\n        -moz-user-select: text;\n      }\n      ha-markdown-element > *:first-child {\n        margin-top: 0;\n      }\n      ha-markdown-element > *:last-child {\n        margin-bottom: 0;\n      }\n      a {\n        color: var(--primary-color);\n      }\n      img {\n        max-width: 100%;\n      }\n      code,\n      pre {\n        background-color: var(--markdown-code-background-color, none);\n        border-radius: 3px;\n      }\n      svg {\n        background-color: var(--markdown-svg-background-color, none);\n        color: var(--markdown-svg-color, none);\n      }\n      code {\n        font-size: 85%;\n        padding: 0.2em 0.4em;\n      }\n      pre code {\n        padding: 0;\n      }\n      pre {\n        padding: 16px;\n        overflow: auto;\n        line-height: 1.45;\n        font-family: var(--code-font-family, monospace);\n      }\n      h1,\n      h2,\n      h3,\n      h4,\n      h5,\n      h6 {\n        line-height: initial;\n      }\n      h2 {\n        font-size: 1.5em;\n        font-weight: bold;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-markdown\": HaMarkdown;\n  }\n}\n","import { html, LitElement, PropertyValues } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { dynamicElement } from \"../../common/dom/dynamic-element-directive\";\nimport type { Selector } from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\n\nconst LOAD_ELEMENTS = {\n  action: () => import(\"./ha-selector-action\"),\n  addon: () => import(\"./ha-selector-addon\"),\n  area: () => import(\"./ha-selector-area\"),\n  attribute: () => import(\"./ha-selector-attribute\"),\n  boolean: () => import(\"./ha-selector-boolean\"),\n  \"color-rgb\": () => import(\"./ha-selector-color-rgb\"),\n  \"config-entry\": () => import(\"./ha-selector-config-entry\"),\n  date: () => import(\"./ha-selector-date\"),\n  datetime: () => import(\"./ha-selector-datetime\"),\n  device: () => import(\"./ha-selector-device\"),\n  duration: () => import(\"./ha-selector-duration\"),\n  entity: () => import(\"./ha-selector-entity\"),\n  statistic: () => import(\"./ha-selector-statistic\"),\n  file: () => import(\"./ha-selector-file\"),\n  navigation: () => import(\"./ha-selector-navigation\"),\n  number: () => import(\"./ha-selector-number\"),\n  object: () => import(\"./ha-selector-object\"),\n  select: () => import(\"./ha-selector-select\"),\n  state: () => import(\"./ha-selector-state\"),\n  target: () => import(\"./ha-selector-target\"),\n  template: () => import(\"./ha-selector-template\"),\n  text: () => import(\"./ha-selector-text\"),\n  time: () => import(\"./ha-selector-time\"),\n  icon: () => import(\"./ha-selector-icon\"),\n  media: () => import(\"./ha-selector-media\"),\n  theme: () => import(\"./ha-selector-theme\"),\n  location: () => import(\"./ha-selector-location\"),\n  \"color-temp\": () => import(\"./ha-selector-color-temp\"),\n  \"ui-action\": () => import(\"./ha-selector-ui-action\"),\n};\n\n@customElement(\"ha-selector\")\nexport class HaSelector extends LitElement {\n  @property() public hass!: HomeAssistant;\n\n  @property() public selector!: Selector;\n\n  @property() public value?: any;\n\n  @property() public label?: string;\n\n  @property() public helper?: string;\n\n  @property() public placeholder?: any;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  @property() public context?: Record<string, any>;\n\n  public focus() {\n    this.shadowRoot?.getElementById(\"selector\")?.focus();\n  }\n\n  private get _type() {\n    return Object.keys(this.selector)[0];\n  }\n\n  protected willUpdate(changedProps: PropertyValues) {\n    if (changedProps.has(\"selector\") && this.selector) {\n      LOAD_ELEMENTS[this._type]?.();\n    }\n  }\n\n  protected render() {\n    return html`\n      ${dynamicElement(`ha-selector-${this._type}`, {\n        hass: this.hass,\n        selector: this.selector,\n        value: this.value,\n        label: this.label,\n        placeholder: this.placeholder,\n        disabled: this.disabled,\n        required: this.required,\n        helper: this.helper,\n        context: this.context,\n        id: \"selector\",\n      })}\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector\": HaSelector;\n  }\n}\n","/* eslint-plugin-disable lit */\n/**\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n/*\nThis code is copied from app-header-layout.\n'fullbleed' support is removed as Home Assisstant doesn't use it.\ntransform: translate(0) is added.\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport \"@polymer/app-layout/app-header-layout/app-header-layout\";\nimport { html } from \"@polymer/polymer/lib/utils/html-tag\";\nimport \"@polymer/polymer/polymer-element\";\n\nclass HaAppLayout extends customElements.get(\"app-header-layout\") {\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          /**\n         * Force app-header-layout to have its own stacking context so that its parent can\n         * control the stacking of it relative to other elements (e.g. app-drawer-layout).\n         * This could be done using \\`isolation: isolate\\`, but that's not well supported\n         * across browsers.\n         */\n          position: relative;\n          z-index: 0;\n          padding: env(safe-area-inset-top) env(safe-area-inset-right)\n            env(safe-area-inset-bottom) env(safe-area-inset-left);\n        }\n\n        #wrapper ::slotted([slot=\"header\"]) {\n          @apply --layout-fixed-top;\n          z-index: 1;\n        }\n\n        #wrapper.initializing ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) {\n          height: 100%;\n        }\n\n        :host([has-scrolling-region]) #wrapper ::slotted([slot=\"header\"]) {\n          position: absolute;\n        }\n\n        :host([has-scrolling-region])\n          #wrapper.initializing\n          ::slotted([slot=\"header\"]) {\n          position: relative;\n        }\n\n        :host([has-scrolling-region]) #wrapper #contentContainer {\n          @apply --layout-fit;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch;\n        }\n\n        :host([has-scrolling-region]) #wrapper.initializing #contentContainer {\n          position: relative;\n        }\n\n        #contentContainer {\n          /* Create a stacking context here so that all children appear below the header. */\n          position: relative;\n          z-index: 0;\n          /* Using 'transform' will cause 'position: fixed' elements to behave like\n           'position: absolute' relative to this element. */\n          transform: translate(0);\n          margin-left: env(safe-area-inset-left);\n          margin-right: env(safe-area-inset-right);\n        }\n\n        @media print {\n          :host([has-scrolling-region]) #wrapper #contentContainer {\n            overflow-y: visible;\n          }\n        }\n      </style>\n\n      <div id=\"wrapper\" class=\"initializing\">\n        <slot id=\"headerSlot\" name=\"header\"></slot>\n\n        <div id=\"contentContainer\"><slot></slot></div>\n        <slot id=\"fab\" name=\"fab\"></slot>\n      </div>\n    `;\n  }\n}\ncustomElements.define(\"ha-app-layout\", HaAppLayout);\n","import \"@material/mwc-button/mwc-button\";\nimport \"@polymer/paper-tooltip/paper-tooltip\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport { customElement, property, query } from \"lit/decorators\";\nimport { fireEvent } from \"../common/dom/fire_event\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { computeRTLDirection } from \"../common/util/compute_rtl\";\nimport \"../components/data-table/ha-data-table\";\nimport type {\n  DataTableColumnContainer,\n  DataTableRowData,\n  HaDataTable,\n} from \"../components/data-table/ha-data-table\";\nimport type { HomeAssistant, Route } from \"../types\";\nimport \"./hass-tabs-subpage\";\nimport type { PageNavigation } from \"./hass-tabs-subpage\";\n\ndeclare global {\n  // for fire event\n  interface HASSDomEvents {\n    \"search-changed\": { value: string };\n    \"clear-filter\": undefined;\n  }\n}\n\n@customElement(\"hass-tabs-subpage-data-table\")\nexport class HaTabsSubpageDataTable extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ attribute: false }) public localizeFunc?: LocalizeFunc;\n\n  @property({ type: Boolean }) public isWide = false;\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property({ type: Boolean }) public supervisor = false;\n\n  @property({ type: Boolean, attribute: \"main-page\" }) public mainPage = false;\n\n  /**\n   * Object with the columns.\n   * @type {Object}\n   */\n  @property({ type: Object }) public columns: DataTableColumnContainer = {};\n\n  /**\n   * Data to show in the table.\n   * @type {Array}\n   */\n  @property({ type: Array }) public data: DataTableRowData[] = [];\n\n  /**\n   * Should rows be selectable.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public selectable = false;\n\n  /**\n   * Should rows be clickable.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public clickable = false;\n\n  /**\n   * Do we need to add padding for a fab.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public hasFab = false;\n\n  /**\n   * Add an extra row at the bottom of the data table\n   * @type {TemplateResult}\n   */\n  @property({ attribute: false }) public appendRow?: TemplateResult;\n\n  /**\n   * Field with a unique id per entry in data.\n   * @type {String}\n   */\n  @property({ type: String }) public id = \"id\";\n\n  /**\n   * String to filter the data in the data table on.\n   * @type {String}\n   */\n  @property({ type: String }) public filter = \"\";\n\n  @property() public searchLabel?: string;\n\n  /**\n   * List of strings that show what the data is currently filtered by.\n   * @type {Array}\n   */\n  @property({ type: Array }) public activeFilters?;\n\n  /**\n   * Text to how how many items are hidden.\n   * @type {String}\n   */\n  @property() public hiddenLabel?: string;\n\n  /**\n   * How many items are hidden because of active filters.\n   * @type {Number}\n   */\n  @property({ type: Number }) public numHidden = 0;\n\n  /**\n   * What path to use when the back button is pressed.\n   * @type {String}\n   * @attr back-path\n   */\n  @property({ type: String, attribute: \"back-path\" }) public backPath?: string;\n\n  /**\n   * Function to call when the back button is pressed.\n   * @type {() => void}\n   */\n  @property() public backCallback?: () => void;\n\n  /**\n   * String to show when there are no records in the data table.\n   * @type {String}\n   */\n  @property({ type: String }) public noDataText?: string;\n\n  @property() public route!: Route;\n\n  /**\n   * Array of tabs to show on the page.\n   * @type {Array}\n   */\n  @property() public tabs: PageNavigation[] = [];\n\n  /**\n   * Force hides the filter menu.\n   * @type {Boolean}\n   */\n  @property({ type: Boolean }) public hideFilterMenu = false;\n\n  @query(\"ha-data-table\", true) private _dataTable!: HaDataTable;\n\n  public clearSelection() {\n    this._dataTable.clearSelection();\n  }\n\n  protected render(): TemplateResult {\n    const hiddenLabel = this.numHidden\n      ? this.hiddenLabel ||\n        this.hass.localize(\n          \"ui.components.data-table.hidden\",\n          \"number\",\n          this.numHidden\n        ) ||\n        this.numHidden\n      : undefined;\n\n    const filterInfo = this.activeFilters\n      ? html`${this.hass.localize(\"ui.components.data-table.filtering_by\")}\n        ${this.activeFilters.join(\", \")}\n        ${hiddenLabel ? `(${hiddenLabel})` : \"\"}`\n      : hiddenLabel;\n\n    const headerToolbar = html`<search-input\n      .hass=${this.hass}\n      .filter=${this.filter}\n      .suffix=${!this.narrow}\n      @value-changed=${this._handleSearchChange}\n      .label=${this.searchLabel ||\n      this.hass.localize(\"ui.components.data-table.search\")}\n    >\n      ${!this.narrow\n        ? html`<div\n            class=\"filters\"\n            slot=\"suffix\"\n            @click=${this._preventDefault}\n          >\n            ${filterInfo\n              ? html`<div class=\"active-filters\">\n                  ${filterInfo}\n                  <mwc-button @click=${this._clearFilter}>\n                    ${this.hass.localize(\"ui.components.data-table.clear\")}\n                  </mwc-button>\n                </div>`\n              : \"\"}\n            <slot name=\"filter-menu\"></slot>\n          </div>`\n        : \"\"}\n    </search-input>`;\n\n    return html`\n      <hass-tabs-subpage\n        .hass=${this.hass}\n        .localizeFunc=${this.localizeFunc}\n        .narrow=${this.narrow}\n        .isWide=${this.isWide}\n        .backPath=${this.backPath}\n        .backCallback=${this.backCallback}\n        .route=${this.route}\n        .tabs=${this.tabs}\n        .mainPage=${this.mainPage}\n        .supervisor=${this.supervisor}\n      >\n        ${!this.hideFilterMenu\n          ? html`\n              <div slot=\"toolbar-icon\">\n                ${this.narrow\n                  ? html`\n                      <div class=\"filter-menu\">\n                        ${this.numHidden || this.activeFilters\n                          ? html`<span class=\"badge\"\n                              >${this.numHidden || \"!\"}</span\n                            >`\n                          : \"\"}\n                        <slot name=\"filter-menu\"></slot>\n                      </div>\n                    `\n                  : \"\"}<slot name=\"toolbar-icon\"></slot>\n              </div>\n            `\n          : \"\"}\n        ${this.narrow\n          ? html`\n              <div slot=\"header\">\n                <slot name=\"header\">\n                  <div class=\"search-toolbar\">${headerToolbar}</div>\n                </slot>\n              </div>\n            `\n          : \"\"}\n        <ha-data-table\n          .hass=${this.hass}\n          .columns=${this.columns}\n          .data=${this.data}\n          .filter=${this.filter}\n          .selectable=${this.selectable}\n          .hasFab=${this.hasFab}\n          .id=${this.id}\n          .noDataText=${this.noDataText}\n          .dir=${computeRTLDirection(this.hass)}\n          .clickable=${this.clickable}\n          .appendRow=${this.appendRow}\n        >\n          ${!this.narrow\n            ? html`\n                <div slot=\"header\">\n                  <slot name=\"header\">\n                    <div class=\"table-header\">${headerToolbar}</div>\n                  </slot>\n                </div>\n              `\n            : html` <div slot=\"header\"></div> `}\n        </ha-data-table>\n        <div slot=\"fab\"><slot name=\"fab\"></slot></div>\n      </hass-tabs-subpage>\n    `;\n  }\n\n  private _preventDefault(ev) {\n    ev.preventDefault();\n  }\n\n  private _handleSearchChange(ev: CustomEvent) {\n    if (this.filter === ev.detail.value) {\n      return;\n    }\n    this.filter = ev.detail.value;\n    fireEvent(this, \"search-changed\", { value: this.filter });\n  }\n\n  private _clearFilter() {\n    fireEvent(this, \"clear-filter\");\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      ha-data-table {\n        width: 100%;\n        height: 100%;\n        --data-table-border-width: 0;\n      }\n      :host(:not([narrow])) ha-data-table {\n        height: calc(100vh - 1px - var(--header-height));\n        display: block;\n      }\n      :host([narrow]) hass-tabs-subpage {\n        --main-title-margin: 0;\n      }\n      .table-header {\n        display: flex;\n        align-items: center;\n        --mdc-shape-small: 0;\n        height: 56px;\n      }\n      .search-toolbar {\n        display: flex;\n        align-items: center;\n        color: var(--secondary-text-color);\n      }\n      search-input {\n        --mdc-text-field-fill-color: var(--sidebar-background-color);\n        --mdc-text-field-idle-line-color: var(--divider-color);\n        --text-field-overflow: visible;\n        z-index: 5;\n      }\n      .table-header search-input {\n        display: block;\n        position: absolute;\n        top: 0;\n        right: 0;\n        left: 0;\n      }\n      .search-toolbar search-input {\n        display: block;\n        width: 100%;\n        color: var(--secondary-text-color);\n        --mdc-ripple-color: transparant;\n      }\n      .filters {\n        --mdc-text-field-fill-color: var(--input-fill-color);\n        --mdc-text-field-idle-line-color: var(--input-idle-line-color);\n        --mdc-shape-small: 4px;\n        --text-field-overflow: initial;\n        display: flex;\n        justify-content: flex-end;\n        margin-right: 8px;\n        color: var(--primary-text-color);\n      }\n      .active-filters {\n        color: var(--primary-text-color);\n        position: relative;\n        display: flex;\n        align-items: center;\n        padding: 2px 2px 2px 8px;\n        margin-left: 4px;\n        font-size: 14px;\n        width: max-content;\n        cursor: initial;\n      }\n      .active-filters ha-svg-icon {\n        color: var(--primary-color);\n      }\n      .active-filters mwc-button {\n        margin-left: 8px;\n      }\n      .active-filters::before {\n        background-color: var(--primary-color);\n        opacity: 0.12;\n        border-radius: 4px;\n        position: absolute;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        content: \"\";\n      }\n      .badge {\n        min-width: 20px;\n        box-sizing: border-box;\n        border-radius: 50%;\n        font-weight: 400;\n        background-color: var(--primary-color);\n        line-height: 20px;\n        text-align: center;\n        padding: 0px 4px;\n        color: var(--text-primary-color);\n        position: absolute;\n        right: 0;\n        top: 4px;\n        font-size: 0.65em;\n      }\n      .filter-menu {\n        position: relative;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hass-tabs-subpage-data-table\": HaTabsSubpageDataTable;\n  }\n}\n","import type { Ripple } from \"@material/mwc-ripple\";\nimport \"@material/mwc-ripple/mwc-ripple\";\nimport { RippleHandlers } from \"@material/mwc-ripple/ripple-handlers\";\nimport { css, CSSResultGroup, html, LitElement, TemplateResult } from \"lit\";\nimport {\n  customElement,\n  eventOptions,\n  property,\n  queryAsync,\n  state,\n} from \"lit/decorators\";\nimport { ifDefined } from \"lit/directives/if-defined\";\n\n@customElement(\"ha-tab\")\nexport class HaTab extends LitElement {\n  @property({ type: Boolean, reflect: true }) public active = false;\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property() public name?: string;\n\n  @queryAsync(\"mwc-ripple\") private _ripple!: Promise<Ripple | null>;\n\n  @state() private _shouldRenderRipple = false;\n\n  protected render(): TemplateResult {\n    return html`\n      <div\n        tabindex=\"0\"\n        role=\"tab\"\n        aria-selected=${this.active}\n        aria-label=${ifDefined(this.name)}\n        @focus=${this.handleRippleFocus}\n        @blur=${this.handleRippleBlur}\n        @mousedown=${this.handleRippleActivate}\n        @mouseup=${this.handleRippleDeactivate}\n        @mouseenter=${this.handleRippleMouseEnter}\n        @mouseleave=${this.handleRippleMouseLeave}\n        @touchstart=${this.handleRippleActivate}\n        @touchend=${this.handleRippleDeactivate}\n        @touchcancel=${this.handleRippleDeactivate}\n        @keydown=${this._handleKeyDown}\n      >\n        ${this.narrow ? html`<slot name=\"icon\"></slot>` : \"\"}\n        <span class=\"name\">${this.name}</span>\n        ${this._shouldRenderRipple ? html`<mwc-ripple></mwc-ripple>` : \"\"}\n      </div>\n    `;\n  }\n\n  private _rippleHandlers: RippleHandlers = new RippleHandlers(() => {\n    this._shouldRenderRipple = true;\n    return this._ripple;\n  });\n\n  private _handleKeyDown(ev: KeyboardEvent): void {\n    if (ev.keyCode === 13) {\n      (ev.target as HTMLElement).click();\n    }\n  }\n\n  @eventOptions({ passive: true })\n  private handleRippleActivate(evt?: Event) {\n    this._rippleHandlers.startPress(evt);\n  }\n\n  private handleRippleDeactivate() {\n    this._rippleHandlers.endPress();\n  }\n\n  private handleRippleMouseEnter() {\n    this._rippleHandlers.startHover();\n  }\n\n  private handleRippleMouseLeave() {\n    this._rippleHandlers.endHover();\n  }\n\n  private handleRippleFocus() {\n    this._rippleHandlers.startFocus();\n  }\n\n  private handleRippleBlur() {\n    this._rippleHandlers.endFocus();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      div {\n        padding: 0 32px;\n        display: flex;\n        flex-direction: column;\n        text-align: center;\n        box-sizing: border-box;\n        align-items: center;\n        justify-content: center;\n        width: 100%;\n        height: var(--header-height);\n        cursor: pointer;\n        position: relative;\n        outline: none;\n      }\n\n      .name {\n        white-space: nowrap;\n        overflow: hidden;\n        text-overflow: ellipsis;\n        max-width: 100%;\n      }\n\n      :host([active]) {\n        color: var(--primary-color);\n      }\n\n      :host(:not([narrow])[active]) div {\n        border-bottom: 2px solid var(--primary-color);\n      }\n\n      :host([narrow]) {\n        min-width: 0;\n        display: flex;\n        justify-content: center;\n        overflow: hidden;\n      }\n\n      :host([narrow]) div {\n        padding: 0 4px;\n      }\n    `;\n  }\n}\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-tab\": HaTab;\n  }\n}\n","import \"@material/mwc-ripple\";\nimport {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, eventOptions, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport memoizeOne from \"memoize-one\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { restoreScroll } from \"../common/decorators/restore-scroll\";\nimport { LocalizeFunc } from \"../common/translations/localize\";\nimport { computeRTL } from \"../common/util/compute_rtl\";\nimport \"../components/ha-icon-button-arrow-prev\";\nimport \"../components/ha-menu-button\";\nimport \"../components/ha-svg-icon\";\nimport \"../components/ha-tab\";\nimport { HomeAssistant, Route } from \"../types\";\n\nexport interface PageNavigation {\n  path: string;\n  translationKey?: string;\n  component?: string;\n  components?: string[];\n  name?: string;\n  core?: boolean;\n  advancedOnly?: boolean;\n  iconPath?: string;\n  description?: string;\n  iconColor?: string;\n  info?: any;\n}\n\n@customElement(\"hass-tabs-subpage\")\nclass HassTabsSubpage extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property({ type: Boolean }) public supervisor = false;\n\n  @property({ attribute: false }) public localizeFunc?: LocalizeFunc;\n\n  @property({ type: String, attribute: \"back-path\" }) public backPath?: string;\n\n  @property() public backCallback?: () => void;\n\n  @property({ type: Boolean, attribute: \"main-page\" }) public mainPage = false;\n\n  @property({ attribute: false }) public route!: Route;\n\n  @property({ attribute: false }) public tabs!: PageNavigation[];\n\n  @property({ type: Boolean, reflect: true }) public narrow = false;\n\n  @property({ type: Boolean, reflect: true, attribute: \"is-wide\" })\n  public isWide = false;\n\n  @property({ type: Boolean, reflect: true }) public rtl = false;\n\n  @state() private _activeTab?: PageNavigation;\n\n  // @ts-ignore\n  @restoreScroll(\".content\") private _savedScrollPos?: number;\n\n  private _getTabs = memoizeOne(\n    (\n      tabs: PageNavigation[],\n      activeTab: PageNavigation | undefined,\n      showAdvanced: boolean | undefined,\n      _components,\n      _language,\n      _narrow,\n      localizeFunc\n    ) => {\n      const shownTabs = tabs.filter(\n        (page) =>\n          (!page.component ||\n            page.core ||\n            isComponentLoaded(this.hass, page.component)) &&\n          (!page.advancedOnly || showAdvanced)\n      );\n\n      if (shownTabs.length < 2) {\n        if (shownTabs.length === 1) {\n          const page = shownTabs[0];\n          return [\n            page.translationKey ? localizeFunc(page.translationKey) : page.name,\n          ];\n        }\n        return [\"\"];\n      }\n\n      return shownTabs.map(\n        (page) =>\n          html`\n            <a href=${page.path}>\n              <ha-tab\n                .hass=${this.hass}\n                .active=${page.path === activeTab?.path}\n                .narrow=${this.narrow}\n                .name=${page.translationKey\n                  ? localizeFunc(page.translationKey)\n                  : page.name}\n              >\n                ${page.iconPath\n                  ? html`<ha-svg-icon\n                      slot=\"icon\"\n                      .path=${page.iconPath}\n                    ></ha-svg-icon>`\n                  : \"\"}\n              </ha-tab>\n            </a>\n          `\n      );\n    }\n  );\n\n  public willUpdate(changedProperties: PropertyValues) {\n    if (changedProperties.has(\"route\")) {\n      this._activeTab = this.tabs.find((tab) =>\n        `${this.route.prefix}${this.route.path}`.includes(tab.path)\n      );\n    }\n    if (changedProperties.has(\"hass\")) {\n      const oldHass = changedProperties.get(\"hass\") as\n        | HomeAssistant\n        | undefined;\n      if (!oldHass || oldHass.language !== this.hass.language) {\n        this.rtl = computeRTL(this.hass);\n      }\n    }\n    super.willUpdate(changedProperties);\n  }\n\n  protected render(): TemplateResult {\n    const tabs = this._getTabs(\n      this.tabs,\n      this._activeTab,\n      this.hass.userData?.showAdvanced,\n      this.hass.config.components,\n      this.hass.language,\n      this.narrow,\n      this.localizeFunc || this.hass.localize\n    );\n    const showTabs = tabs.length > 1;\n    return html`\n      <div class=\"toolbar\">\n        ${this.mainPage || (!this.backPath && history.state?.root)\n          ? html`\n              <ha-menu-button\n                .hassio=${this.supervisor}\n                .hass=${this.hass}\n                .narrow=${this.narrow}\n              ></ha-menu-button>\n            `\n          : this.backPath\n          ? html`\n              <a href=${this.backPath}>\n                <ha-icon-button-arrow-prev\n                  .hass=${this.hass}\n                ></ha-icon-button-arrow-prev>\n              </a>\n            `\n          : html`\n              <ha-icon-button-arrow-prev\n                .hass=${this.hass}\n                @click=${this._backTapped}\n              ></ha-icon-button-arrow-prev>\n            `}\n        ${this.narrow || !showTabs\n          ? html`<div class=\"main-title\">\n              <slot name=\"header\">${!showTabs ? tabs[0] : \"\"}</slot>\n            </div>`\n          : \"\"}\n        ${showTabs\n          ? html`\n              <div id=\"tabbar\" class=${classMap({ \"bottom-bar\": this.narrow })}>\n                ${tabs}\n              </div>\n            `\n          : \"\"}\n        <div id=\"toolbar-icon\">\n          <slot name=\"toolbar-icon\"></slot>\n        </div>\n      </div>\n      <div\n        class=\"content ${classMap({ tabs: showTabs })}\"\n        @scroll=${this._saveScrollPos}\n      >\n        <slot></slot>\n      </div>\n      <div id=\"fab\" class=${classMap({ tabs: showTabs })}>\n        <slot name=\"fab\"></slot>\n      </div>\n    `;\n  }\n\n  @eventOptions({ passive: true })\n  private _saveScrollPos(e: Event) {\n    this._savedScrollPos = (e.target as HTMLDivElement).scrollTop;\n  }\n\n  private _backTapped(): void {\n    if (this.backCallback) {\n      this.backCallback();\n      return;\n    }\n    history.back();\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n        height: 100%;\n        background-color: var(--primary-background-color);\n      }\n\n      :host([narrow]) {\n        width: 100%;\n        position: fixed;\n      }\n\n      ha-menu-button {\n        margin-right: 24px;\n      }\n\n      .toolbar {\n        display: flex;\n        align-items: center;\n        font-size: 20px;\n        height: var(--header-height);\n        background-color: var(--sidebar-background-color);\n        font-weight: 400;\n        border-bottom: 1px solid var(--divider-color);\n        padding: 0 16px;\n        box-sizing: border-box;\n      }\n      .toolbar a {\n        color: var(--sidebar-text-color);\n        text-decoration: none;\n      }\n      .bottom-bar a {\n        width: 25%;\n      }\n\n      #tabbar {\n        display: flex;\n        font-size: 14px;\n        overflow: hidden;\n      }\n\n      #tabbar > a {\n        overflow: hidden;\n        max-width: 45%;\n      }\n\n      #tabbar.bottom-bar {\n        position: absolute;\n        bottom: 0;\n        left: 0;\n        padding: 0 16px;\n        box-sizing: border-box;\n        background-color: var(--sidebar-background-color);\n        border-top: 1px solid var(--divider-color);\n        justify-content: space-around;\n        z-index: 2;\n        font-size: 12px;\n        width: 100%;\n        padding-bottom: env(safe-area-inset-bottom);\n      }\n\n      #tabbar:not(.bottom-bar) {\n        flex: 1;\n        justify-content: center;\n      }\n\n      :host(:not([narrow])) #toolbar-icon {\n        min-width: 40px;\n      }\n\n      ha-menu-button,\n      ha-icon-button-arrow-prev,\n      ::slotted([slot=\"toolbar-icon\"]) {\n        display: flex;\n        flex-shrink: 0;\n        pointer-events: auto;\n        color: var(--sidebar-icon-color);\n      }\n\n      .main-title {\n        flex: 1;\n        max-height: var(--header-height);\n        line-height: 20px;\n        color: var(--sidebar-text-color);\n        margin: var(--main-title-margin, 0 0 0 24px);\n      }\n\n      .content {\n        position: relative;\n        width: calc(\n          100% - env(safe-area-inset-left) - env(safe-area-inset-right)\n        );\n        margin-left: env(safe-area-inset-left);\n        margin-right: env(safe-area-inset-right);\n        height: calc(100% - 1px - var(--header-height));\n        height: calc(\n          100% - 1px - var(--header-height) - env(safe-area-inset-bottom)\n        );\n        overflow: auto;\n        -webkit-overflow-scrolling: touch;\n      }\n\n      :host([narrow]) .content.tabs {\n        height: calc(100% - 2 * var(--header-height));\n        height: calc(\n          100% - 2 * var(--header-height) - env(safe-area-inset-bottom)\n        );\n      }\n\n      #fab {\n        position: fixed;\n        right: calc(16px + env(safe-area-inset-right));\n        bottom: calc(16px + env(safe-area-inset-bottom));\n        z-index: 1;\n      }\n      :host([narrow]) #fab.tabs {\n        bottom: calc(84px + env(safe-area-inset-bottom));\n      }\n      #fab[is-wide] {\n        bottom: 24px;\n        right: 24px;\n      }\n      :host([rtl]) #fab {\n        right: auto;\n        left: calc(16px + env(safe-area-inset-left));\n      }\n      :host([rtl][is-wide]) #fab {\n        bottom: 24px;\n        left: 24px;\n        right: auto;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hass-tabs-subpage\": HassTabsSubpage;\n  }\n}\n"],"names":[],"sourceRoot":""}