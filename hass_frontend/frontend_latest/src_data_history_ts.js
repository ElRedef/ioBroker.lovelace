"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["src_data_history_ts"],{

/***/ "./src/data/history.ts":
/*!*****************************!*\
  !*** ./src/data/history.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeHistory: () => (/* binding */ computeHistory),\n/* harmony export */   entityIdHistoryNeedsAttributes: () => (/* binding */ entityIdHistoryNeedsAttributes),\n/* harmony export */   fetchDateWS: () => (/* binding */ fetchDateWS),\n/* harmony export */   subscribeHistory: () => (/* binding */ subscribeHistory),\n/* harmony export */   subscribeHistoryStatesTimeWindow: () => (/* binding */ subscribeHistoryStatesTimeWindow)\n/* harmony export */ });\n/* harmony import */ var _common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/entity/compute_domain */ \"./src/common/entity/compute_domain.ts\");\n/* harmony import */ var _common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/entity/compute_state_display */ \"./src/common/entity/compute_state_display.ts\");\n/* harmony import */ var _common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/entity/compute_state_name */ \"./src/common/entity/compute_state_name.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__]);\n_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nconst DOMAINS_USE_LAST_UPDATED = [\"climate\", \"humidifier\", \"water_heater\"];\nconst NEED_ATTRIBUTE_DOMAINS = [\"climate\", \"humidifier\", \"input_datetime\", \"thermostat\", \"water_heater\", \"person\", \"device_tracker\"];\nconst LINE_ATTRIBUTES_TO_KEEP = [\"temperature\", \"current_temperature\", \"target_temp_low\", \"target_temp_high\", \"hvac_action\", \"humidity\", \"mode\"];\nconst entityIdHistoryNeedsAttributes = (hass, entityId) => !hass.states[entityId] || NEED_ATTRIBUTE_DOMAINS.includes((0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId));\nconst fetchDateWS = (hass, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/history_during_period\",\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  if (entityIds.length !== 0) {\n    return hass.callWS({\n      ...params,\n      entity_ids: entityIds\n    });\n  }\n  return hass.callWS(params);\n};\nconst subscribeHistory = (hass, callbackFunction, startTime, endTime, entityIds) => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: startTime.toISOString(),\n    end_time: endTime.toISOString(),\n    minimal_response: true,\n    no_attributes: !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  const stream = new HistoryStream(hass);\n  return hass.connection.subscribeMessage(message => callbackFunction(stream.processMessage(message)), params);\n};\nclass HistoryStream {\n  constructor(hass, hoursToShow) {\n    this.hass = void 0;\n    this.hoursToShow = void 0;\n    this.combinedHistory = void 0;\n    this.hass = hass;\n    this.hoursToShow = hoursToShow;\n    this.combinedHistory = {};\n  }\n  processMessage(streamMessage) {\n    if (!this.combinedHistory || !Object.keys(this.combinedHistory).length) {\n      this.combinedHistory = streamMessage.states;\n      return this.combinedHistory;\n    }\n    if (!Object.keys(streamMessage.states).length) {\n      // Empty messages are still sent to\n      // indicate no more historical events\n      return this.combinedHistory;\n    }\n    const purgeBeforePythonTime = this.hoursToShow ? (new Date().getTime() - 60 * 60 * this.hoursToShow * 1000) / 1000 : undefined;\n    const newHistory = {};\n    for (const entityId of Object.keys(this.combinedHistory)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(streamMessage.states)) {\n      newHistory[entityId] = [];\n    }\n    for (const entityId of Object.keys(newHistory)) {\n      if (entityId in this.combinedHistory && entityId in streamMessage.states) {\n        const entityCombinedHistory = this.combinedHistory[entityId];\n        const lastEntityCombinedHistory = entityCombinedHistory[entityCombinedHistory.length - 1];\n        newHistory[entityId] = entityCombinedHistory.concat(streamMessage.states[entityId]);\n        if (streamMessage.states[entityId][0].lu < lastEntityCombinedHistory.lu) {\n          // If the history is out of order we have to sort it.\n          newHistory[entityId] = newHistory[entityId].sort((a, b) => a.lu - b.lu);\n        }\n      } else if (entityId in this.combinedHistory) {\n        newHistory[entityId] = this.combinedHistory[entityId];\n      } else {\n        newHistory[entityId] = streamMessage.states[entityId];\n      }\n      // Remove old history\n      if (purgeBeforePythonTime && entityId in this.combinedHistory) {\n        const expiredStates = newHistory[entityId].filter(state => state.lu < purgeBeforePythonTime);\n        if (!expiredStates.length) {\n          continue;\n        }\n        newHistory[entityId] = newHistory[entityId].filter(state => state.lu >= purgeBeforePythonTime);\n        if (newHistory[entityId].length && newHistory[entityId][0].lu === purgeBeforePythonTime) {\n          continue;\n        }\n        // Update the first entry to the start time state\n        // as we need to preserve the start time state and\n        // only expire the rest of the history as it ages.\n        const lastExpiredState = expiredStates[expiredStates.length - 1];\n        lastExpiredState.lu = purgeBeforePythonTime;\n        newHistory[entityId].unshift(lastExpiredState);\n      }\n    }\n    this.combinedHistory = newHistory;\n    return this.combinedHistory;\n  }\n}\nconst subscribeHistoryStatesTimeWindow = (hass, callbackFunction, hoursToShow, entityIds, minimalResponse = true, significantChangesOnly = true, noAttributes) => {\n  const params = {\n    type: \"history/stream\",\n    entity_ids: entityIds,\n    start_time: new Date(new Date().getTime() - 60 * 60 * hoursToShow * 1000).toISOString(),\n    minimal_response: minimalResponse,\n    significant_changes_only: significantChangesOnly,\n    no_attributes: noAttributes !== null && noAttributes !== void 0 ? noAttributes : !entityIds.some(entityId => entityIdHistoryNeedsAttributes(hass, entityId))\n  };\n  const stream = new HistoryStream(hass, hoursToShow);\n  return hass.connection.subscribeMessage(message => callbackFunction(stream.processMessage(message)), params);\n};\nconst equalState = (obj1, obj2) => obj1.state === obj2.state && (\n// Only compare attributes if both states have an attributes object.\n// When `minimal_response` is sent, only the first and last state\n// will have attributes except for domains in DOMAINS_USE_LAST_UPDATED.\n!obj1.attributes || !obj2.attributes || LINE_ATTRIBUTES_TO_KEEP.every(attr => obj1.attributes[attr] === obj2.attributes[attr]));\nconst processTimelineEntity = (localize, language, entities, entityId, states, current_state) => {\n  const data = [];\n  const first = states[0];\n  for (const state of states) {\n    if (data.length > 0 && state.s === data[data.length - 1].state) {\n      continue;\n    }\n    const currentAttributes = {};\n    if (current_state !== null && current_state !== void 0 && current_state.attributes.device_class) {\n      currentAttributes.device_class = current_state === null || current_state === void 0 ? void 0 : current_state.attributes.device_class;\n    }\n    data.push({\n      state_localize: (0,_common_entity_compute_state_display__WEBPACK_IMPORTED_MODULE_1__.computeStateDisplayFromEntityAttributes)(localize, language, entities[entityId], entityId, {\n        ...(state.a || first.a),\n        ...currentAttributes\n      }, state.s),\n      state: state.s,\n      // lc (last_changed) may be omitted if its the same\n      // as lu (last_updated).\n      last_changed: (state.lc ? state.lc : state.lu) * 1000\n    });\n  }\n  return {\n    name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateNameFromEntityAttributes)(entityId, (current_state === null || current_state === void 0 ? void 0 : current_state.attributes) || first.a),\n    entity_id: entityId,\n    data\n  };\n};\nconst processLineChartEntities = (unit, entities, hassEntities) => {\n  const data = [];\n  Object.keys(entities).forEach(entityId => {\n    const states = entities[entityId];\n    const first = states[0];\n    const domain = (0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId);\n    const processedStates = [];\n    for (const state of states) {\n      let processedState;\n      if (DOMAINS_USE_LAST_UPDATED.includes(domain)) {\n        processedState = {\n          state: state.s,\n          last_changed: state.lu * 1000,\n          attributes: {}\n        };\n        for (const attr of LINE_ATTRIBUTES_TO_KEEP) {\n          if (attr in state.a) {\n            processedState.attributes[attr] = state.a[attr];\n          }\n        }\n      } else {\n        processedState = {\n          state: state.s,\n          // lc (last_changed) may be omitted if its the same\n          // as lu (last_updated).\n          last_changed: (state.lc ? state.lc : state.lu) * 1000,\n          attributes: {}\n        };\n      }\n      if (processedStates.length > 1 && equalState(processedState, processedStates[processedStates.length - 1]) && equalState(processedState, processedStates[processedStates.length - 2])) {\n        continue;\n      }\n      processedStates.push(processedState);\n    }\n    const attributes = entityId in hassEntities ? hassEntities[entityId].attributes : \"friendly_name\" in first.a ? first.a : undefined;\n    data.push({\n      domain,\n      name: (0,_common_entity_compute_state_name__WEBPACK_IMPORTED_MODULE_2__.computeStateNameFromEntityAttributes)(entityId, attributes || {}),\n      entity_id: entityId,\n      states: processedStates\n    });\n  });\n  return {\n    unit,\n    identifier: Object.keys(entities).join(\"\"),\n    data\n  };\n};\nconst stateUsesUnits = state => attributesHaveUnits(state.attributes);\nconst attributesHaveUnits = attributes => \"unit_of_measurement\" in attributes || \"state_class\" in attributes;\nconst computeHistory = (hass, stateHistory, localize) => {\n  const lineChartDevices = {};\n  const timelineDevices = [];\n  if (!stateHistory) {\n    return {\n      line: [],\n      timeline: []\n    };\n  }\n  Object.keys(stateHistory).forEach(entityId => {\n    const stateInfo = stateHistory[entityId];\n    if (stateInfo.length === 0) {\n      return;\n    }\n    const currentState = entityId in hass.states ? hass.states[entityId] : undefined;\n    const stateWithUnitorStateClass = !currentState && stateInfo.find(state => state.a && attributesHaveUnits(state.a));\n    let unit;\n    if (currentState && stateUsesUnits(currentState)) {\n      unit = currentState.attributes.unit_of_measurement || \" \";\n    } else if (stateWithUnitorStateClass) {\n      unit = stateWithUnitorStateClass.a.unit_of_measurement || \" \";\n    } else {\n      unit = {\n        zone: localize(\"ui.dialogs.more_info_control.zone.graph_unit\"),\n        climate: hass.config.unit_system.temperature,\n        counter: \"#\",\n        humidifier: \"%\",\n        input_number: \"#\",\n        number: \"#\",\n        water_heater: hass.config.unit_system.temperature\n      }[(0,_common_entity_compute_domain__WEBPACK_IMPORTED_MODULE_0__.computeDomain)(entityId)];\n    }\n    if (!unit) {\n      timelineDevices.push(processTimelineEntity(localize, hass.locale, hass.entities, entityId, stateInfo, currentState));\n    } else if (unit in lineChartDevices && entityId in lineChartDevices[unit]) {\n      lineChartDevices[unit][entityId].push(...stateInfo);\n    } else {\n      if (!(unit in lineChartDevices)) {\n        lineChartDevices[unit] = {};\n      }\n      lineChartDevices[unit][entityId] = stateInfo;\n    }\n  });\n  const unitStates = Object.keys(lineChartDevices).map(unit => processLineChartEntities(unit, lineChartDevices[unit], hass.states));\n  return {\n    line: unitStates,\n    timeline: timelineDevices\n  };\n};\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGF0YS9oaXN0b3J5LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVNBO0FBbUVBO0FBT0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQU9BO0FBQUE7QUFOQTtBQUVBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBR0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uL3NyYy9kYXRhL2hpc3RvcnkudHM/MzUwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBIYXNzRW50aXRpZXMsXG4gIEhhc3NFbnRpdHksXG4gIEhhc3NFbnRpdHlBdHRyaWJ1dGVCYXNlLFxufSBmcm9tIFwiaG9tZS1hc3Npc3RhbnQtanMtd2Vic29ja2V0XCI7XG5pbXBvcnQgeyBjb21wdXRlRG9tYWluIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9kb21haW5cIjtcbmltcG9ydCB7IGNvbXB1dGVTdGF0ZURpc3BsYXlGcm9tRW50aXR5QXR0cmlidXRlcyB9IGZyb20gXCIuLi9jb21tb24vZW50aXR5L2NvbXB1dGVfc3RhdGVfZGlzcGxheVwiO1xuaW1wb3J0IHsgY29tcHV0ZVN0YXRlTmFtZUZyb21FbnRpdHlBdHRyaWJ1dGVzIH0gZnJvbSBcIi4uL2NvbW1vbi9lbnRpdHkvY29tcHV0ZV9zdGF0ZV9uYW1lXCI7XG5pbXBvcnQgeyBMb2NhbGl6ZUZ1bmMgfSBmcm9tIFwiLi4vY29tbW9uL3RyYW5zbGF0aW9ucy9sb2NhbGl6ZVwiO1xuaW1wb3J0IHsgSG9tZUFzc2lzdGFudCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgRnJvbnRlbmRMb2NhbGVEYXRhIH0gZnJvbSBcIi4vdHJhbnNsYXRpb25cIjtcblxuY29uc3QgRE9NQUlOU19VU0VfTEFTVF9VUERBVEVEID0gW1wiY2xpbWF0ZVwiLCBcImh1bWlkaWZpZXJcIiwgXCJ3YXRlcl9oZWF0ZXJcIl07XG5jb25zdCBORUVEX0FUVFJJQlVURV9ET01BSU5TID0gW1xuICBcImNsaW1hdGVcIixcbiAgXCJodW1pZGlmaWVyXCIsXG4gIFwiaW5wdXRfZGF0ZXRpbWVcIixcbiAgXCJ0aGVybW9zdGF0XCIsXG4gIFwid2F0ZXJfaGVhdGVyXCIsXG4gIFwicGVyc29uXCIsXG4gIFwiZGV2aWNlX3RyYWNrZXJcIixcbl07XG5jb25zdCBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUCA9IFtcbiAgXCJ0ZW1wZXJhdHVyZVwiLFxuICBcImN1cnJlbnRfdGVtcGVyYXR1cmVcIixcbiAgXCJ0YXJnZXRfdGVtcF9sb3dcIixcbiAgXCJ0YXJnZXRfdGVtcF9oaWdoXCIsXG4gIFwiaHZhY19hY3Rpb25cIixcbiAgXCJodW1pZGl0eVwiLFxuICBcIm1vZGVcIixcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNoYXJ0U3RhdGUge1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYXN0X2NoYW5nZWQ6IG51bWJlcjtcbiAgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZUNoYXJ0RW50aXR5IHtcbiAgZG9tYWluOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW50aXR5X2lkOiBzdHJpbmc7XG4gIHN0YXRlczogTGluZUNoYXJ0U3RhdGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaW5lQ2hhcnRVbml0IHtcbiAgdW5pdDogc3RyaW5nO1xuICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gIGRhdGE6IExpbmVDaGFydEVudGl0eVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVsaW5lU3RhdGUge1xuICBzdGF0ZV9sb2NhbGl6ZTogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBsYXN0X2NoYW5nZWQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUaW1lbGluZUVudGl0eSB7XG4gIG5hbWU6IHN0cmluZztcbiAgZW50aXR5X2lkOiBzdHJpbmc7XG4gIGRhdGE6IFRpbWVsaW5lU3RhdGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5UmVzdWx0IHtcbiAgbGluZTogTGluZUNoYXJ0VW5pdFtdO1xuICB0aW1lbGluZTogVGltZWxpbmVFbnRpdHlbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5U3RhdGVzIHtcbiAgW2VudGl0eUlkOiBzdHJpbmddOiBFbnRpdHlIaXN0b3J5U3RhdGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlIaXN0b3J5U3RhdGUge1xuICAvKiogc3RhdGUgKi9cbiAgczogc3RyaW5nO1xuICAvKiogYXR0cmlidXRlcyAqL1xuICBhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAvKiogbGFzdF9jaGFuZ2VkOyBpZiBzZXQsIGFsc28gYXBwbGllcyB0byBsdSAqL1xuICBsYzogbnVtYmVyO1xuICAvKiogbGFzdF91cGRhdGVkICovXG4gIGx1OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVN0cmVhbU1lc3NhZ2Uge1xuICBzdGF0ZXM6IEhpc3RvcnlTdGF0ZXM7XG4gIHN0YXJ0X3RpbWU/OiBudW1iZXI7IC8vIFN0YXJ0IHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIGNodW5rXG4gIGVuZF90aW1lPzogbnVtYmVyOyAvLyBFbmQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgY2h1bmtcbn1cblxuZXhwb3J0IGNvbnN0IGVudGl0eUlkSGlzdG9yeU5lZWRzQXR0cmlidXRlcyA9IChcbiAgaGFzczogSG9tZUFzc2lzdGFudCxcbiAgZW50aXR5SWQ6IHN0cmluZ1xuKSA9PlxuICAhaGFzcy5zdGF0ZXNbZW50aXR5SWRdIHx8XG4gIE5FRURfQVRUUklCVVRFX0RPTUFJTlMuaW5jbHVkZXMoY29tcHV0ZURvbWFpbihlbnRpdHlJZCkpO1xuXG5leHBvcnQgY29uc3QgZmV0Y2hEYXRlV1MgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXJ0VGltZTogRGF0ZSxcbiAgZW5kVGltZTogRGF0ZSxcbiAgZW50aXR5SWRzOiBzdHJpbmdbXVxuKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB0eXBlOiBcImhpc3RvcnkvaGlzdG9yeV9kdXJpbmdfcGVyaW9kXCIsXG4gICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kX3RpbWU6IGVuZFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICBtaW5pbWFsX3Jlc3BvbnNlOiB0cnVlLFxuICAgIG5vX2F0dHJpYnV0ZXM6ICFlbnRpdHlJZHMuc29tZSgoZW50aXR5SWQpID0+XG4gICAgICBlbnRpdHlJZEhpc3RvcnlOZWVkc0F0dHJpYnV0ZXMoaGFzcywgZW50aXR5SWQpXG4gICAgKSxcbiAgfTtcbiAgaWYgKGVudGl0eUlkcy5sZW5ndGggIT09IDApIHtcbiAgICByZXR1cm4gaGFzcy5jYWxsV1M8SGlzdG9yeVN0YXRlcz4oeyAuLi5wYXJhbXMsIGVudGl0eV9pZHM6IGVudGl0eUlkcyB9KTtcbiAgfVxuICByZXR1cm4gaGFzcy5jYWxsV1M8SGlzdG9yeVN0YXRlcz4ocGFyYW1zKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzdWJzY3JpYmVIaXN0b3J5ID0gKFxuICBoYXNzOiBIb21lQXNzaXN0YW50LFxuICBjYWxsYmFja0Z1bmN0aW9uOiAoZGF0YTogSGlzdG9yeVN0YXRlcykgPT4gdm9pZCxcbiAgc3RhcnRUaW1lOiBEYXRlLFxuICBlbmRUaW1lOiBEYXRlLFxuICBlbnRpdHlJZHM6IHN0cmluZ1tdXG4pOiBQcm9taXNlPCgpID0+IFByb21pc2U8dm9pZD4+ID0+IHtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIHR5cGU6IFwiaGlzdG9yeS9zdHJlYW1cIixcbiAgICBlbnRpdHlfaWRzOiBlbnRpdHlJZHMsXG4gICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgZW5kX3RpbWU6IGVuZFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICBtaW5pbWFsX3Jlc3BvbnNlOiB0cnVlLFxuICAgIG5vX2F0dHJpYnV0ZXM6ICFlbnRpdHlJZHMuc29tZSgoZW50aXR5SWQpID0+XG4gICAgICBlbnRpdHlJZEhpc3RvcnlOZWVkc0F0dHJpYnV0ZXMoaGFzcywgZW50aXR5SWQpXG4gICAgKSxcbiAgfTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IEhpc3RvcnlTdHJlYW0oaGFzcyk7XG4gIHJldHVybiBoYXNzLmNvbm5lY3Rpb24uc3Vic2NyaWJlTWVzc2FnZTxIaXN0b3J5U3RyZWFtTWVzc2FnZT4oXG4gICAgKG1lc3NhZ2UpID0+IGNhbGxiYWNrRnVuY3Rpb24oc3RyZWFtLnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpKSxcbiAgICBwYXJhbXNcbiAgKTtcbn07XG5cbmNsYXNzIEhpc3RvcnlTdHJlYW0ge1xuICBoYXNzOiBIb21lQXNzaXN0YW50O1xuXG4gIGhvdXJzVG9TaG93PzogbnVtYmVyO1xuXG4gIGNvbWJpbmVkSGlzdG9yeTogSGlzdG9yeVN0YXRlcztcblxuICBjb25zdHJ1Y3RvcihoYXNzOiBIb21lQXNzaXN0YW50LCBob3Vyc1RvU2hvdz86IG51bWJlcikge1xuICAgIHRoaXMuaGFzcyA9IGhhc3M7XG4gICAgdGhpcy5ob3Vyc1RvU2hvdyA9IGhvdXJzVG9TaG93O1xuICAgIHRoaXMuY29tYmluZWRIaXN0b3J5ID0ge307XG4gIH1cblxuICBwcm9jZXNzTWVzc2FnZShzdHJlYW1NZXNzYWdlOiBIaXN0b3J5U3RyZWFtTWVzc2FnZSk6IEhpc3RvcnlTdGF0ZXMge1xuICAgIGlmICghdGhpcy5jb21iaW5lZEhpc3RvcnkgfHwgIU9iamVjdC5rZXlzKHRoaXMuY29tYmluZWRIaXN0b3J5KS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY29tYmluZWRIaXN0b3J5ID0gc3RyZWFtTWVzc2FnZS5zdGF0ZXM7XG4gICAgICByZXR1cm4gdGhpcy5jb21iaW5lZEhpc3Rvcnk7XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmtleXMoc3RyZWFtTWVzc2FnZS5zdGF0ZXMpLmxlbmd0aCkge1xuICAgICAgLy8gRW1wdHkgbWVzc2FnZXMgYXJlIHN0aWxsIHNlbnQgdG9cbiAgICAgIC8vIGluZGljYXRlIG5vIG1vcmUgaGlzdG9yaWNhbCBldmVudHNcbiAgICAgIHJldHVybiB0aGlzLmNvbWJpbmVkSGlzdG9yeTtcbiAgICB9XG4gICAgY29uc3QgcHVyZ2VCZWZvcmVQeXRob25UaW1lID0gdGhpcy5ob3Vyc1RvU2hvd1xuICAgICAgPyAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSA2MCAqIDYwICogdGhpcy5ob3Vyc1RvU2hvdyAqIDEwMDApIC8gMTAwMFxuICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbmV3SGlzdG9yeTogSGlzdG9yeVN0YXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZW50aXR5SWQgb2YgT2JqZWN0LmtleXModGhpcy5jb21iaW5lZEhpc3RvcnkpKSB7XG4gICAgICBuZXdIaXN0b3J5W2VudGl0eUlkXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVudGl0eUlkIG9mIE9iamVjdC5rZXlzKHN0cmVhbU1lc3NhZ2Uuc3RhdGVzKSkge1xuICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0gPSBbXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbnRpdHlJZCBvZiBPYmplY3Qua2V5cyhuZXdIaXN0b3J5KSkge1xuICAgICAgaWYgKFxuICAgICAgICBlbnRpdHlJZCBpbiB0aGlzLmNvbWJpbmVkSGlzdG9yeSAmJlxuICAgICAgICBlbnRpdHlJZCBpbiBzdHJlYW1NZXNzYWdlLnN0YXRlc1xuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IGVudGl0eUNvbWJpbmVkSGlzdG9yeSA9IHRoaXMuY29tYmluZWRIaXN0b3J5W2VudGl0eUlkXTtcbiAgICAgICAgY29uc3QgbGFzdEVudGl0eUNvbWJpbmVkSGlzdG9yeSA9XG4gICAgICAgICAgZW50aXR5Q29tYmluZWRIaXN0b3J5W2VudGl0eUNvbWJpbmVkSGlzdG9yeS5sZW5ndGggLSAxXTtcbiAgICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0gPSBlbnRpdHlDb21iaW5lZEhpc3RvcnkuY29uY2F0KFxuICAgICAgICAgIHN0cmVhbU1lc3NhZ2Uuc3RhdGVzW2VudGl0eUlkXVxuICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc3RyZWFtTWVzc2FnZS5zdGF0ZXNbZW50aXR5SWRdWzBdLmx1IDwgbGFzdEVudGl0eUNvbWJpbmVkSGlzdG9yeS5sdVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBJZiB0aGUgaGlzdG9yeSBpcyBvdXQgb2Ygb3JkZXIgd2UgaGF2ZSB0byBzb3J0IGl0LlxuICAgICAgICAgIG5ld0hpc3RvcnlbZW50aXR5SWRdID0gbmV3SGlzdG9yeVtlbnRpdHlJZF0uc29ydChcbiAgICAgICAgICAgIChhLCBiKSA9PiBhLmx1IC0gYi5sdVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW50aXR5SWQgaW4gdGhpcy5jb21iaW5lZEhpc3RvcnkpIHtcbiAgICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0gPSB0aGlzLmNvbWJpbmVkSGlzdG9yeVtlbnRpdHlJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdIaXN0b3J5W2VudGl0eUlkXSA9IHN0cmVhbU1lc3NhZ2Uuc3RhdGVzW2VudGl0eUlkXTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBvbGQgaGlzdG9yeVxuICAgICAgaWYgKHB1cmdlQmVmb3JlUHl0aG9uVGltZSAmJiBlbnRpdHlJZCBpbiB0aGlzLmNvbWJpbmVkSGlzdG9yeSkge1xuICAgICAgICBjb25zdCBleHBpcmVkU3RhdGVzID0gbmV3SGlzdG9yeVtlbnRpdHlJZF0uZmlsdGVyKFxuICAgICAgICAgIChzdGF0ZSkgPT4gc3RhdGUubHUgPCBwdXJnZUJlZm9yZVB5dGhvblRpbWVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFleHBpcmVkU3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld0hpc3RvcnlbZW50aXR5SWRdID0gbmV3SGlzdG9yeVtlbnRpdHlJZF0uZmlsdGVyKFxuICAgICAgICAgIChzdGF0ZSkgPT4gc3RhdGUubHUgPj0gcHVyZ2VCZWZvcmVQeXRob25UaW1lXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBuZXdIaXN0b3J5W2VudGl0eUlkXS5sZW5ndGggJiZcbiAgICAgICAgICBuZXdIaXN0b3J5W2VudGl0eUlkXVswXS5sdSA9PT0gcHVyZ2VCZWZvcmVQeXRob25UaW1lXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgZmlyc3QgZW50cnkgdG8gdGhlIHN0YXJ0IHRpbWUgc3RhdGVcbiAgICAgICAgLy8gYXMgd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgc3RhcnQgdGltZSBzdGF0ZSBhbmRcbiAgICAgICAgLy8gb25seSBleHBpcmUgdGhlIHJlc3Qgb2YgdGhlIGhpc3RvcnkgYXMgaXQgYWdlcy5cbiAgICAgICAgY29uc3QgbGFzdEV4cGlyZWRTdGF0ZSA9IGV4cGlyZWRTdGF0ZXNbZXhwaXJlZFN0YXRlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGFzdEV4cGlyZWRTdGF0ZS5sdSA9IHB1cmdlQmVmb3JlUHl0aG9uVGltZTtcbiAgICAgICAgbmV3SGlzdG9yeVtlbnRpdHlJZF0udW5zaGlmdChsYXN0RXhwaXJlZFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21iaW5lZEhpc3RvcnkgPSBuZXdIaXN0b3J5O1xuICAgIHJldHVybiB0aGlzLmNvbWJpbmVkSGlzdG9yeTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlSGlzdG9yeVN0YXRlc1RpbWVXaW5kb3cgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIGNhbGxiYWNrRnVuY3Rpb246IChkYXRhOiBIaXN0b3J5U3RhdGVzKSA9PiB2b2lkLFxuICBob3Vyc1RvU2hvdzogbnVtYmVyLFxuICBlbnRpdHlJZHM6IHN0cmluZ1tdLFxuICBtaW5pbWFsUmVzcG9uc2UgPSB0cnVlLFxuICBzaWduaWZpY2FudENoYW5nZXNPbmx5ID0gdHJ1ZSxcbiAgbm9BdHRyaWJ1dGVzPzogYm9vbGVhblxuKTogUHJvbWlzZTwoKSA9PiBQcm9taXNlPHZvaWQ+PiA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICB0eXBlOiBcImhpc3Rvcnkvc3RyZWFtXCIsXG4gICAgZW50aXR5X2lkczogZW50aXR5SWRzLFxuICAgIHN0YXJ0X3RpbWU6IG5ldyBEYXRlKFxuICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSA2MCAqIDYwICogaG91cnNUb1Nob3cgKiAxMDAwXG4gICAgKS50b0lTT1N0cmluZygpLFxuICAgIG1pbmltYWxfcmVzcG9uc2U6IG1pbmltYWxSZXNwb25zZSxcbiAgICBzaWduaWZpY2FudF9jaGFuZ2VzX29ubHk6IHNpZ25pZmljYW50Q2hhbmdlc09ubHksXG4gICAgbm9fYXR0cmlidXRlczpcbiAgICAgIG5vQXR0cmlidXRlcyA/P1xuICAgICAgIWVudGl0eUlkcy5zb21lKChlbnRpdHlJZCkgPT5cbiAgICAgICAgZW50aXR5SWRIaXN0b3J5TmVlZHNBdHRyaWJ1dGVzKGhhc3MsIGVudGl0eUlkKVxuICAgICAgKSxcbiAgfTtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IEhpc3RvcnlTdHJlYW0oaGFzcywgaG91cnNUb1Nob3cpO1xuICByZXR1cm4gaGFzcy5jb25uZWN0aW9uLnN1YnNjcmliZU1lc3NhZ2U8SGlzdG9yeVN0cmVhbU1lc3NhZ2U+KFxuICAgIChtZXNzYWdlKSA9PiBjYWxsYmFja0Z1bmN0aW9uKHN0cmVhbS5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKSksXG4gICAgcGFyYW1zXG4gICk7XG59O1xuXG5jb25zdCBlcXVhbFN0YXRlID0gKG9iajE6IExpbmVDaGFydFN0YXRlLCBvYmoyOiBMaW5lQ2hhcnRTdGF0ZSkgPT5cbiAgb2JqMS5zdGF0ZSA9PT0gb2JqMi5zdGF0ZSAmJlxuICAvLyBPbmx5IGNvbXBhcmUgYXR0cmlidXRlcyBpZiBib3RoIHN0YXRlcyBoYXZlIGFuIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICAvLyBXaGVuIGBtaW5pbWFsX3Jlc3BvbnNlYCBpcyBzZW50LCBvbmx5IHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZVxuICAvLyB3aWxsIGhhdmUgYXR0cmlidXRlcyBleGNlcHQgZm9yIGRvbWFpbnMgaW4gRE9NQUlOU19VU0VfTEFTVF9VUERBVEVELlxuICAoIW9iajEuYXR0cmlidXRlcyB8fFxuICAgICFvYmoyLmF0dHJpYnV0ZXMgfHxcbiAgICBMSU5FX0FUVFJJQlVURVNfVE9fS0VFUC5ldmVyeShcbiAgICAgIChhdHRyKSA9PiBvYmoxLmF0dHJpYnV0ZXMhW2F0dHJdID09PSBvYmoyLmF0dHJpYnV0ZXMhW2F0dHJdXG4gICAgKSk7XG5cbmNvbnN0IHByb2Nlc3NUaW1lbGluZUVudGl0eSA9IChcbiAgbG9jYWxpemU6IExvY2FsaXplRnVuYyxcbiAgbGFuZ3VhZ2U6IEZyb250ZW5kTG9jYWxlRGF0YSxcbiAgZW50aXRpZXM6IEhvbWVBc3Npc3RhbnRbXCJlbnRpdGllc1wiXSxcbiAgZW50aXR5SWQ6IHN0cmluZyxcbiAgc3RhdGVzOiBFbnRpdHlIaXN0b3J5U3RhdGVbXSxcbiAgY3VycmVudF9zdGF0ZTogSGFzc0VudGl0eSB8IHVuZGVmaW5lZFxuKTogVGltZWxpbmVFbnRpdHkgPT4ge1xuICBjb25zdCBkYXRhOiBUaW1lbGluZVN0YXRlW10gPSBbXTtcbiAgY29uc3QgZmlyc3Q6IEVudGl0eUhpc3RvcnlTdGF0ZSA9IHN0YXRlc1swXTtcbiAgZm9yIChjb25zdCBzdGF0ZSBvZiBzdGF0ZXMpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwICYmIHN0YXRlLnMgPT09IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zdGF0ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXM6IEhhc3NFbnRpdHlBdHRyaWJ1dGVCYXNlID0ge307XG4gICAgaWYgKGN1cnJlbnRfc3RhdGU/LmF0dHJpYnV0ZXMuZGV2aWNlX2NsYXNzKSB7XG4gICAgICBjdXJyZW50QXR0cmlidXRlcy5kZXZpY2VfY2xhc3MgPSBjdXJyZW50X3N0YXRlPy5hdHRyaWJ1dGVzLmRldmljZV9jbGFzcztcbiAgICB9XG5cbiAgICBkYXRhLnB1c2goe1xuICAgICAgc3RhdGVfbG9jYWxpemU6IGNvbXB1dGVTdGF0ZURpc3BsYXlGcm9tRW50aXR5QXR0cmlidXRlcyhcbiAgICAgICAgbG9jYWxpemUsXG4gICAgICAgIGxhbmd1YWdlLFxuICAgICAgICBlbnRpdGllc1tlbnRpdHlJZF0sXG4gICAgICAgIGVudGl0eUlkLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uKHN0YXRlLmEgfHwgZmlyc3QuYSksXG4gICAgICAgICAgLi4uY3VycmVudEF0dHJpYnV0ZXMsXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlLnNcbiAgICAgICksXG4gICAgICBzdGF0ZTogc3RhdGUucyxcbiAgICAgIC8vIGxjIChsYXN0X2NoYW5nZWQpIG1heSBiZSBvbWl0dGVkIGlmIGl0cyB0aGUgc2FtZVxuICAgICAgLy8gYXMgbHUgKGxhc3RfdXBkYXRlZCkuXG4gICAgICBsYXN0X2NoYW5nZWQ6IChzdGF0ZS5sYyA/IHN0YXRlLmxjIDogc3RhdGUubHUpICogMTAwMCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogY29tcHV0ZVN0YXRlTmFtZUZyb21FbnRpdHlBdHRyaWJ1dGVzKFxuICAgICAgZW50aXR5SWQsXG4gICAgICBjdXJyZW50X3N0YXRlPy5hdHRyaWJ1dGVzIHx8IGZpcnN0LmFcbiAgICApLFxuICAgIGVudGl0eV9pZDogZW50aXR5SWQsXG4gICAgZGF0YSxcbiAgfTtcbn07XG5cbmNvbnN0IHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyA9IChcbiAgdW5pdCxcbiAgZW50aXRpZXM6IEhpc3RvcnlTdGF0ZXMsXG4gIGhhc3NFbnRpdGllczogSGFzc0VudGl0aWVzXG4pOiBMaW5lQ2hhcnRVbml0ID0+IHtcbiAgY29uc3QgZGF0YTogTGluZUNoYXJ0RW50aXR5W10gPSBbXTtcblxuICBPYmplY3Qua2V5cyhlbnRpdGllcykuZm9yRWFjaCgoZW50aXR5SWQpID0+IHtcbiAgICBjb25zdCBzdGF0ZXMgPSBlbnRpdGllc1tlbnRpdHlJZF07XG4gICAgY29uc3QgZmlyc3Q6IEVudGl0eUhpc3RvcnlTdGF0ZSA9IHN0YXRlc1swXTtcbiAgICBjb25zdCBkb21haW4gPSBjb21wdXRlRG9tYWluKGVudGl0eUlkKTtcbiAgICBjb25zdCBwcm9jZXNzZWRTdGF0ZXM6IExpbmVDaGFydFN0YXRlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGUgb2Ygc3RhdGVzKSB7XG4gICAgICBsZXQgcHJvY2Vzc2VkU3RhdGU6IExpbmVDaGFydFN0YXRlO1xuXG4gICAgICBpZiAoRE9NQUlOU19VU0VfTEFTVF9VUERBVEVELmluY2x1ZGVzKGRvbWFpbikpIHtcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGUgPSB7XG4gICAgICAgICAgc3RhdGU6IHN0YXRlLnMsXG4gICAgICAgICAgbGFzdF9jaGFuZ2VkOiBzdGF0ZS5sdSAqIDEwMDAsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIExJTkVfQVRUUklCVVRFU19UT19LRUVQKSB7XG4gICAgICAgICAgaWYgKGF0dHIgaW4gc3RhdGUuYSkge1xuICAgICAgICAgICAgcHJvY2Vzc2VkU3RhdGUuYXR0cmlidXRlcyFbYXR0cl0gPSBzdGF0ZS5hW2F0dHJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGUgPSB7XG4gICAgICAgICAgc3RhdGU6IHN0YXRlLnMsXG4gICAgICAgICAgLy8gbGMgKGxhc3RfY2hhbmdlZCkgbWF5IGJlIG9taXR0ZWQgaWYgaXRzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYXMgbHUgKGxhc3RfdXBkYXRlZCkuXG4gICAgICAgICAgbGFzdF9jaGFuZ2VkOiAoc3RhdGUubGMgPyBzdGF0ZS5sYyA6IHN0YXRlLmx1KSAqIDEwMDAsXG4gICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgZXF1YWxTdGF0ZShcbiAgICAgICAgICBwcm9jZXNzZWRTdGF0ZSxcbiAgICAgICAgICBwcm9jZXNzZWRTdGF0ZXNbcHJvY2Vzc2VkU3RhdGVzLmxlbmd0aCAtIDFdXG4gICAgICAgICkgJiZcbiAgICAgICAgZXF1YWxTdGF0ZShwcm9jZXNzZWRTdGF0ZSwgcHJvY2Vzc2VkU3RhdGVzW3Byb2Nlc3NlZFN0YXRlcy5sZW5ndGggLSAyXSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc2VkU3RhdGVzLnB1c2gocHJvY2Vzc2VkU3RhdGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPVxuICAgICAgZW50aXR5SWQgaW4gaGFzc0VudGl0aWVzXG4gICAgICAgID8gaGFzc0VudGl0aWVzW2VudGl0eUlkXS5hdHRyaWJ1dGVzXG4gICAgICAgIDogXCJmcmllbmRseV9uYW1lXCIgaW4gZmlyc3QuYVxuICAgICAgICA/IGZpcnN0LmFcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBkYXRhLnB1c2goe1xuICAgICAgZG9tYWluLFxuICAgICAgbmFtZTogY29tcHV0ZVN0YXRlTmFtZUZyb21FbnRpdHlBdHRyaWJ1dGVzKGVudGl0eUlkLCBhdHRyaWJ1dGVzIHx8IHt9KSxcbiAgICAgIGVudGl0eV9pZDogZW50aXR5SWQsXG4gICAgICBzdGF0ZXM6IHByb2Nlc3NlZFN0YXRlcyxcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB1bml0LFxuICAgIGlkZW50aWZpZXI6IE9iamVjdC5rZXlzKGVudGl0aWVzKS5qb2luKFwiXCIpLFxuICAgIGRhdGEsXG4gIH07XG59O1xuXG5jb25zdCBzdGF0ZVVzZXNVbml0cyA9IChzdGF0ZTogSGFzc0VudGl0eSkgPT5cbiAgYXR0cmlidXRlc0hhdmVVbml0cyhzdGF0ZS5hdHRyaWJ1dGVzKTtcblxuY29uc3QgYXR0cmlidXRlc0hhdmVVbml0cyA9IChhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KSA9PlxuICBcInVuaXRfb2ZfbWVhc3VyZW1lbnRcIiBpbiBhdHRyaWJ1dGVzIHx8IFwic3RhdGVfY2xhc3NcIiBpbiBhdHRyaWJ1dGVzO1xuXG5leHBvcnQgY29uc3QgY29tcHV0ZUhpc3RvcnkgPSAoXG4gIGhhc3M6IEhvbWVBc3Npc3RhbnQsXG4gIHN0YXRlSGlzdG9yeTogSGlzdG9yeVN0YXRlcyxcbiAgbG9jYWxpemU6IExvY2FsaXplRnVuY1xuKTogSGlzdG9yeVJlc3VsdCA9PiB7XG4gIGNvbnN0IGxpbmVDaGFydERldmljZXM6IHsgW3VuaXQ6IHN0cmluZ106IEhpc3RvcnlTdGF0ZXMgfSA9IHt9O1xuICBjb25zdCB0aW1lbGluZURldmljZXM6IFRpbWVsaW5lRW50aXR5W10gPSBbXTtcbiAgaWYgKCFzdGF0ZUhpc3RvcnkpIHtcbiAgICByZXR1cm4geyBsaW5lOiBbXSwgdGltZWxpbmU6IFtdIH07XG4gIH1cbiAgT2JqZWN0LmtleXMoc3RhdGVIaXN0b3J5KS5mb3JFYWNoKChlbnRpdHlJZCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlSW5mbyA9IHN0YXRlSGlzdG9yeVtlbnRpdHlJZF07XG4gICAgaWYgKHN0YXRlSW5mby5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPVxuICAgICAgZW50aXR5SWQgaW4gaGFzcy5zdGF0ZXMgPyBoYXNzLnN0YXRlc1tlbnRpdHlJZF0gOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3RhdGVXaXRoVW5pdG9yU3RhdGVDbGFzcyA9XG4gICAgICAhY3VycmVudFN0YXRlICYmXG4gICAgICBzdGF0ZUluZm8uZmluZCgoc3RhdGUpID0+IHN0YXRlLmEgJiYgYXR0cmlidXRlc0hhdmVVbml0cyhzdGF0ZS5hKSk7XG5cbiAgICBsZXQgdW5pdDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBzdGF0ZVVzZXNVbml0cyhjdXJyZW50U3RhdGUpKSB7XG4gICAgICB1bml0ID0gY3VycmVudFN0YXRlLmF0dHJpYnV0ZXMudW5pdF9vZl9tZWFzdXJlbWVudCB8fCBcIiBcIjtcbiAgICB9IGVsc2UgaWYgKHN0YXRlV2l0aFVuaXRvclN0YXRlQ2xhc3MpIHtcbiAgICAgIHVuaXQgPSBzdGF0ZVdpdGhVbml0b3JTdGF0ZUNsYXNzLmEudW5pdF9vZl9tZWFzdXJlbWVudCB8fCBcIiBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pdCA9IHtcbiAgICAgICAgem9uZTogbG9jYWxpemUoXCJ1aS5kaWFsb2dzLm1vcmVfaW5mb19jb250cm9sLnpvbmUuZ3JhcGhfdW5pdFwiKSxcbiAgICAgICAgY2xpbWF0ZTogaGFzcy5jb25maWcudW5pdF9zeXN0ZW0udGVtcGVyYXR1cmUsXG4gICAgICAgIGNvdW50ZXI6IFwiI1wiLFxuICAgICAgICBodW1pZGlmaWVyOiBcIiVcIixcbiAgICAgICAgaW5wdXRfbnVtYmVyOiBcIiNcIixcbiAgICAgICAgbnVtYmVyOiBcIiNcIixcbiAgICAgICAgd2F0ZXJfaGVhdGVyOiBoYXNzLmNvbmZpZy51bml0X3N5c3RlbS50ZW1wZXJhdHVyZSxcbiAgICAgIH1bY29tcHV0ZURvbWFpbihlbnRpdHlJZCldO1xuICAgIH1cblxuICAgIGlmICghdW5pdCkge1xuICAgICAgdGltZWxpbmVEZXZpY2VzLnB1c2goXG4gICAgICAgIHByb2Nlc3NUaW1lbGluZUVudGl0eShcbiAgICAgICAgICBsb2NhbGl6ZSxcbiAgICAgICAgICBoYXNzLmxvY2FsZSxcbiAgICAgICAgICBoYXNzLmVudGl0aWVzLFxuICAgICAgICAgIGVudGl0eUlkLFxuICAgICAgICAgIHN0YXRlSW5mbyxcbiAgICAgICAgICBjdXJyZW50U3RhdGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgaW4gbGluZUNoYXJ0RGV2aWNlcyAmJiBlbnRpdHlJZCBpbiBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdKSB7XG4gICAgICBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdW2VudGl0eUlkXS5wdXNoKC4uLnN0YXRlSW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHVuaXQgaW4gbGluZUNoYXJ0RGV2aWNlcykpIHtcbiAgICAgICAgbGluZUNoYXJ0RGV2aWNlc1t1bml0XSA9IHt9O1xuICAgICAgfVxuICAgICAgbGluZUNoYXJ0RGV2aWNlc1t1bml0XVtlbnRpdHlJZF0gPSBzdGF0ZUluZm87XG4gICAgfVxuICB9KTtcblxuICBjb25zdCB1bml0U3RhdGVzID0gT2JqZWN0LmtleXMobGluZUNoYXJ0RGV2aWNlcykubWFwKCh1bml0KSA9PlxuICAgIHByb2Nlc3NMaW5lQ2hhcnRFbnRpdGllcyh1bml0LCBsaW5lQ2hhcnREZXZpY2VzW3VuaXRdLCBoYXNzLnN0YXRlcylcbiAgKTtcblxuICByZXR1cm4geyBsaW5lOiB1bml0U3RhdGVzLCB0aW1lbGluZTogdGltZWxpbmVEZXZpY2VzIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/data/history.ts\n");

/***/ })

}]);