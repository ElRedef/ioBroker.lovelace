/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_node-vibrant_dist_vibrant_js"],{

/***/ "./node_modules/node-vibrant/dist/vibrant.js":
/*!***************************************************!*\
  !*** ./node_modules/node-vibrant/dist/vibrant.js ***!
  \***************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(window, function () {\n  return (/******/function (modules) {\n      // webpackBootstrap\n      /******/ // The module cache\n      /******/\n      var installedModules = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __nested_webpack_require_576__(moduleId) {\n        /******/\n        /******/ // Check if module is in cache\n        /******/if (installedModules[moduleId]) {\n          /******/return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = installedModules[moduleId] = {\n          /******/i: moduleId,\n          /******/l: false,\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_576__);\n        /******/\n        /******/ // Flag the module as loaded\n        /******/\n        module.l = true;\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /******/\n      /******/ // expose the modules object (__webpack_modules__)\n      /******/\n      __nested_webpack_require_576__.m = modules;\n      /******/\n      /******/ // expose the module cache\n      /******/\n      __nested_webpack_require_576__.c = installedModules;\n      /******/\n      /******/ // define getter function for harmony exports\n      /******/\n      __nested_webpack_require_576__.d = function (exports, name, getter) {\n        /******/if (!__nested_webpack_require_576__.o(exports, name)) {\n          /******/Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n      };\n      /******/\n      /******/ // define __esModule on exports\n      /******/\n      __nested_webpack_require_576__.r = function (exports) {\n        /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n      /******/ // create a fake namespace object\n      /******/ // mode & 1: value is a module id, require it\n      /******/ // mode & 2: merge all properties of value into the ns\n      /******/ // mode & 4: return value when already ns object\n      /******/ // mode & 8|1: behave like require\n      /******/\n      __nested_webpack_require_576__.t = function (value, mode) {\n        /******/if (mode & 1) value = __nested_webpack_require_576__(value);\n        /******/\n        if (mode & 8) return value;\n        /******/\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n        var ns = Object.create(null);\n        /******/\n        __nested_webpack_require_576__.r(ns);\n        /******/\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n        if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_576__.d(ns, key, function (key) {\n          return value[key];\n        }.bind(null, key));\n        /******/\n        return ns;\n        /******/\n      };\n      /******/\n      /******/ // getDefaultExport function for compatibility with non-harmony modules\n      /******/\n      __nested_webpack_require_576__.n = function (module) {\n        /******/var getter = module && module.__esModule ? /******/function getDefault() {\n          return module['default'];\n        } : /******/function getModuleExports() {\n          return module;\n        };\n        /******/\n        __nested_webpack_require_576__.d(getter, 'a', getter);\n        /******/\n        return getter;\n        /******/\n      };\n      /******/\n      /******/ // Object.prototype.hasOwnProperty.call\n      /******/\n      __nested_webpack_require_576__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n      /******/ // __webpack_public_path__\n      /******/\n      __nested_webpack_require_576__.p = \"\";\n      /******/\n      /******/\n      /******/ // Load entry module and return exports\n      /******/\n      return __nested_webpack_require_576__(__nested_webpack_require_576__.s = 10);\n      /******/\n    }\n    /************************************************************************/\n    /******/([/* 0 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.assignDeep = exports.mapValues = void 0;\n      function mapValues(o, mapper) {\n        var result = {};\n        for (var key in o) {\n          if (o.hasOwnProperty(key)) {\n            var v = o[key];\n            result[key] = mapper(v);\n          }\n        }\n        return result;\n      }\n      exports.mapValues = mapValues;\n      /**\n       * Overwrite values or properties on objects and lists recursively.\n       * A shallow copy will be created for each array value.\n       */\n      function assignDeep(target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n          sources[_i - 1] = arguments[_i];\n        }\n        sources.forEach(function (s) {\n          if (!s) return;\n          for (var key in s) {\n            if (s.hasOwnProperty(key)) {\n              var v = s[key];\n              if (Array.isArray(v)) {\n                // Shallow copy\n                target[key] = v.slice(0);\n              } else if (typeof v === 'object') {\n                if (!target[key]) target[key] = {};\n                assignDeep(target[key], v);\n              } else {\n                target[key] = v;\n              }\n            }\n          }\n        });\n        return target;\n      }\n      exports.assignDeep = assignDeep;\n\n      /***/\n    }, /* 1 */\n    /***/function (module, exports, __nested_webpack_require_6375__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var options_1 = __nested_webpack_require_6375__(7);\n      var builder_1 = __importDefault(__nested_webpack_require_6375__(8));\n      var utils_1 = __nested_webpack_require_6375__(0);\n      var Vibrant = /** @class */function () {\n        function Vibrant(_src, opts) {\n          this._src = _src;\n          this.opts = utils_1.assignDeep({}, Vibrant.DefaultOpts, opts);\n        }\n        Vibrant.use = function (pipeline) {\n          this._pipeline = pipeline;\n        };\n        Vibrant.from = function (src) {\n          return new builder_1.default(src);\n        };\n        Object.defineProperty(Vibrant.prototype, \"result\", {\n          get: function () {\n            return this._result;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Vibrant.prototype._process = function (image, opts) {\n          var quantizer = this.opts.quantizer;\n          image.scaleDown(this.opts);\n          var processOpts = options_1.buildProcessOptions(this.opts, opts);\n          return Vibrant._pipeline.process(image.getImageData(), processOpts);\n        };\n        Vibrant.prototype.palette = function () {\n          return this.swatches();\n        };\n        Vibrant.prototype.swatches = function () {\n          throw new Error('Method deprecated. Use `Vibrant.result.palettes[name]` instead');\n        };\n        Vibrant.prototype.getPalette = function () {\n          var _this = this;\n          var arg0 = arguments[0];\n          var arg1 = arguments[1];\n          var name = typeof arg0 === 'string' ? arg0 : 'default';\n          var cb = typeof arg0 === 'string' ? arg1 : arg0;\n          var image = new this.opts.ImageClass();\n          return image.load(this._src).then(function (image) {\n            return _this._process(image, {\n              generators: [name]\n            });\n          }).then(function (result) {\n            _this._result = result;\n            return result.palettes[name];\n          }).then(function (res) {\n            image.remove();\n            if (cb) {\n              cb(undefined, res);\n            }\n            return res;\n          }).catch(function (err) {\n            image.remove();\n            if (cb) {\n              cb(err);\n            }\n            return Promise.reject(err);\n          });\n        };\n        Vibrant.prototype.getPalettes = function () {\n          var _this = this;\n          var arg0 = arguments[0];\n          var arg1 = arguments[1];\n          var names = Array.isArray(arg0) ? arg0 : ['*'];\n          var cb = Array.isArray(arg0) ? arg1 : arg0;\n          var image = new this.opts.ImageClass();\n          return image.load(this._src).then(function (image) {\n            return _this._process(image, {\n              generators: names\n            });\n          }).then(function (result) {\n            _this._result = result;\n            return result.palettes;\n          }).then(function (res) {\n            image.remove();\n            if (cb) {\n              cb(undefined, res);\n            }\n            return res;\n          }).catch(function (err) {\n            image.remove();\n            if (cb) {\n              cb(err);\n            }\n            return Promise.reject(err);\n          });\n        };\n        Vibrant.DefaultOpts = {\n          colorCount: 64,\n          quality: 5,\n          filters: []\n        };\n        return Vibrant;\n      }();\n      exports.default = Vibrant;\n\n      /***/\n    }, /* 2 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.applyFilters = exports.ImageBase = void 0;\n      var ImageBase = /** @class */function () {\n        function ImageBase() {}\n        ImageBase.prototype.scaleDown = function (opts) {\n          var width = this.getWidth();\n          var height = this.getHeight();\n          var ratio = 1;\n          if (opts.maxDimension > 0) {\n            var maxSide = Math.max(width, height);\n            if (maxSide > opts.maxDimension) ratio = opts.maxDimension / maxSide;\n          } else {\n            ratio = 1 / opts.quality;\n          }\n          if (ratio < 1) this.resize(width * ratio, height * ratio, ratio);\n        };\n        return ImageBase;\n      }();\n      exports.ImageBase = ImageBase;\n      function applyFilters(imageData, filters) {\n        if (filters.length > 0) {\n          var pixels = imageData.data;\n          var n = pixels.length / 4;\n          var offset = void 0;\n          var r = void 0;\n          var g = void 0;\n          var b = void 0;\n          var a = void 0;\n          for (var i = 0; i < n; i++) {\n            offset = i * 4;\n            r = pixels[offset + 0];\n            g = pixels[offset + 1];\n            b = pixels[offset + 2];\n            a = pixels[offset + 3];\n            // Mark ignored color\n            for (var j = 0; j < filters.length; j++) {\n              if (!filters[j](r, g, b, a)) {\n                pixels[offset + 3] = 0;\n                break;\n              }\n            }\n          }\n        }\n        return imageData;\n      }\n      exports.applyFilters = applyFilters;\n\n      /***/\n    }, /* 3 */\n    /***/function (module, exports, __nested_webpack_require_11815__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.Swatch = void 0;\n      var converter_1 = __nested_webpack_require_11815__(4);\n      var Swatch = /** @class */function () {\n        function Swatch(rgb, population) {\n          this._rgb = rgb;\n          this._population = population;\n        }\n        Swatch.applyFilters = function (colors, filters) {\n          return filters.length > 0 ? colors.filter(function (_a) {\n            var r = _a.r,\n              g = _a.g,\n              b = _a.b;\n            for (var j = 0; j < filters.length; j++) {\n              if (!filters[j](r, g, b, 255)) return false;\n            }\n            return true;\n          }) : colors;\n        };\n        /**\n         * Make a value copy of a swatch based on a previous one. Returns a new Swatch instance\n         * @param {Swatch} swatch\n         */\n        Swatch.clone = function (swatch) {\n          return new Swatch(swatch._rgb, swatch._population);\n        };\n        Object.defineProperty(Swatch.prototype, \"r\", {\n          /**\n           * The red value in the RGB value\n           */\n          get: function () {\n            return this._rgb[0];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"g\", {\n          /**\n           * The green value in the RGB value\n           */\n          get: function () {\n            return this._rgb[1];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"b\", {\n          /**\n           * The blue value in the RGB value\n           */\n          get: function () {\n            return this._rgb[2];\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"rgb\", {\n          /**\n           * The color value as a rgb value\n           */\n          get: function () {\n            return this._rgb;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"hsl\", {\n          /**\n           * The color value as a hsl value\n           */\n          get: function () {\n            if (!this._hsl) {\n              var _a = this._rgb,\n                r = _a[0],\n                g = _a[1],\n                b = _a[2];\n              this._hsl = converter_1.rgbToHsl(r, g, b);\n            }\n            return this._hsl;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"hex\", {\n          /**\n           * The color value as a hex string\n           */\n          get: function () {\n            if (!this._hex) {\n              var _a = this._rgb,\n                r = _a[0],\n                g = _a[1],\n                b = _a[2];\n              this._hex = converter_1.rgbToHex(r, g, b);\n            }\n            return this._hex;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"population\", {\n          get: function () {\n            return this._population;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        /**\n         * Get the JSON object for the swatch\n         */\n        Swatch.prototype.toJSON = function () {\n          return {\n            rgb: this.rgb,\n            population: this.population\n          };\n        };\n        /**\n         * Get the color value as a rgb value\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getRgb = function () {\n          return this._rgb;\n        };\n        /**\n         * Get the color value as a hsl value\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getHsl = function () {\n          return this.hsl;\n        };\n        /**\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getPopulation = function () {\n          return this._population;\n        };\n        /**\n         * Get the color value as a hex string\n         * @deprecated Use property instead\n         */\n        // TODO: deprecate internally, use property instead\n        Swatch.prototype.getHex = function () {\n          return this.hex;\n        };\n        Swatch.prototype.getYiq = function () {\n          if (!this._yiq) {\n            var rgb = this._rgb;\n            this._yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n          }\n          return this._yiq;\n        };\n        Object.defineProperty(Swatch.prototype, \"titleTextColor\", {\n          get: function () {\n            if (this._titleTextColor) {\n              this._titleTextColor = this.getYiq() < 200 ? '#fff' : '#000';\n            }\n            return this._titleTextColor;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Swatch.prototype, \"bodyTextColor\", {\n          get: function () {\n            if (this._bodyTextColor) {\n              this._bodyTextColor = this.getYiq() < 150 ? '#fff' : '#000';\n            }\n            return this._bodyTextColor;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Swatch.prototype.getTitleTextColor = function () {\n          return this.titleTextColor;\n        };\n        Swatch.prototype.getBodyTextColor = function () {\n          return this.bodyTextColor;\n        };\n        return Swatch;\n      }();\n      exports.Swatch = Swatch;\n\n      /***/\n    }, /* 4 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.getColorDiffStatus = exports.hexDiff = exports.rgbDiff = exports.deltaE94 = exports.rgbToCIELab = exports.xyzToCIELab = exports.rgbToXyz = exports.hslToRgb = exports.rgbToHsl = exports.rgbToHex = exports.hexToRgb = exports.DELTAE94_DIFF_STATUS = void 0;\n      exports.DELTAE94_DIFF_STATUS = {\n        NA: 0,\n        PERFECT: 1,\n        CLOSE: 2,\n        GOOD: 10,\n        SIMILAR: 50\n      };\n      /**\n       * Converts hex string to RGB\n       * @param hex - The hex value you with to get the RGB value of\n       * @returns an array in the order of `red, green, blue` numerical values\n       */\n      function hexToRgb(hex) {\n        var m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        if (!m) throw new RangeError(\"'\" + hex + \"' is not a valid hex color\");\n        return [m[1], m[2], m[3]].map(function (s) {\n          return parseInt(s, 16);\n        });\n      }\n      exports.hexToRgb = hexToRgb;\n      /**\n       * Given values for an RGB color convert to and return a valid HEX string\n       * @param r - Red value in RGB\n       * @param g - Green value in RGB\n       * @param b - Blue value in RGB\n       * @returns a valid hex string with pre-pending pound sign\n       */\n      function rgbToHex(r, g, b) {\n        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n      }\n      exports.rgbToHex = rgbToHex;\n      /**\n       * Given values for an RGB color convert to and return a valid HSL value\n       * @param r - Red value in RGB\n       * @param g - Green value in RGB\n       * @param b - Blue value in RGB\n       * @returns an array in the order of `hue, saturation, light` numerical values\n       */\n      function rgbToHsl(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var h = 0;\n        var s = 0;\n        var l = (max + min) / 2;\n        if (max !== min) {\n          var d = max - min;\n          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n          switch (max) {\n            case r:\n              h = (g - b) / d + (g < b ? 6 : 0);\n              break;\n            case g:\n              h = (b - r) / d + 2;\n              break;\n            case b:\n              h = (r - g) / d + 4;\n              break;\n          }\n          h /= 6;\n        }\n        return [h, s, l];\n      }\n      exports.rgbToHsl = rgbToHsl;\n      function hslToRgb(h, s, l) {\n        var r;\n        var g;\n        var b;\n        function hue2rgb(p, q, t) {\n          if (t < 0) t += 1;\n          if (t > 1) t -= 1;\n          if (t < 1 / 6) return p + (q - p) * 6 * t;\n          if (t < 1 / 2) return q;\n          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n          return p;\n        }\n        if (s === 0) {\n          r = g = b = l;\n        } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = hue2rgb(p, q, h + 1 / 3);\n          g = hue2rgb(p, q, h);\n          b = hue2rgb(p, q, h - 1 / 3);\n        }\n        return [r * 255, g * 255, b * 255];\n      }\n      exports.hslToRgb = hslToRgb;\n      function rgbToXyz(r, g, b) {\n        r /= 255;\n        g /= 255;\n        b /= 255;\n        r = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n        g = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n        b = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n        r *= 100;\n        g *= 100;\n        b *= 100;\n        var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n        var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n        var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n        return [x, y, z];\n      }\n      exports.rgbToXyz = rgbToXyz;\n      function xyzToCIELab(x, y, z) {\n        var REF_X = 95.047;\n        var REF_Y = 100;\n        var REF_Z = 108.883;\n        x /= REF_X;\n        y /= REF_Y;\n        z /= REF_Z;\n        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n        var L = 116 * y - 16;\n        var a = 500 * (x - y);\n        var b = 200 * (y - z);\n        return [L, a, b];\n      }\n      exports.xyzToCIELab = xyzToCIELab;\n      function rgbToCIELab(r, g, b) {\n        var _a = rgbToXyz(r, g, b),\n          x = _a[0],\n          y = _a[1],\n          z = _a[2];\n        return xyzToCIELab(x, y, z);\n      }\n      exports.rgbToCIELab = rgbToCIELab;\n      function deltaE94(lab1, lab2) {\n        var WEIGHT_L = 1;\n        var WEIGHT_C = 1;\n        var WEIGHT_H = 1;\n        var L1 = lab1[0],\n          a1 = lab1[1],\n          b1 = lab1[2];\n        var L2 = lab2[0],\n          a2 = lab2[1],\n          b2 = lab2[2];\n        var dL = L1 - L2;\n        var da = a1 - a2;\n        var db = b1 - b2;\n        var xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n        var xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n        var xDL = L2 - L1;\n        var xDC = xC2 - xC1;\n        var xDE = Math.sqrt(dL * dL + da * da + db * db);\n        var xDH = Math.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC)) ? Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC) : 0;\n        var xSC = 1 + 0.045 * xC1;\n        var xSH = 1 + 0.015 * xC1;\n        xDL /= WEIGHT_L;\n        xDC /= WEIGHT_C * xSC;\n        xDH /= WEIGHT_H * xSH;\n        return Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n      }\n      exports.deltaE94 = deltaE94;\n      function rgbDiff(rgb1, rgb2) {\n        var lab1 = rgbToCIELab.apply(undefined, rgb1);\n        var lab2 = rgbToCIELab.apply(undefined, rgb2);\n        return deltaE94(lab1, lab2);\n      }\n      exports.rgbDiff = rgbDiff;\n      function hexDiff(hex1, hex2) {\n        var rgb1 = hexToRgb(hex1);\n        var rgb2 = hexToRgb(hex2);\n        return rgbDiff(rgb1, rgb2);\n      }\n      exports.hexDiff = hexDiff;\n      function getColorDiffStatus(d) {\n        if (d < exports.DELTAE94_DIFF_STATUS.NA) {\n          return 'N/A';\n        }\n        // Not perceptible by human eyes\n        if (d <= exports.DELTAE94_DIFF_STATUS.PERFECT) {\n          return 'Perfect';\n        }\n        // Perceptible through close observation\n        if (d <= exports.DELTAE94_DIFF_STATUS.CLOSE) {\n          return 'Close';\n        }\n        // Perceptible at a glance\n        if (d <= exports.DELTAE94_DIFF_STATUS.GOOD) {\n          return 'Good';\n        }\n        // Colors are more similar than opposite\n        if (d < exports.DELTAE94_DIFF_STATUS.SIMILAR) {\n          return 'Similar';\n        }\n        return 'Wrong';\n      }\n      exports.getColorDiffStatus = getColorDiffStatus;\n\n      /***/\n    }, /* 5 */\n    /***/function (module, exports, __nested_webpack_require_24443__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      var config_1 = __importDefault(__nested_webpack_require_24443__(6));\n      var image_browser_1 = __importDefault(__nested_webpack_require_24443__(9));\n      config_1.default.DefaultOpts.ImageClass = image_browser_1.default;\n      module.exports = config_1.default;\n\n      /***/\n    }, /* 6 */\n    /***/function (module, exports, __nested_webpack_require_24965__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var core_1 = __importDefault(__nested_webpack_require_24965__(1));\n      core_1.default.DefaultOpts.quantizer = 'mmcq';\n      core_1.default.DefaultOpts.generators = ['default'];\n      core_1.default.DefaultOpts.filters = ['default'];\n      exports.default = core_1.default;\n\n      /***/\n    }, /* 7 */\n    /***/function (module, exports, __nested_webpack_require_25593__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.buildProcessOptions = void 0;\n      var utils_1 = __nested_webpack_require_25593__(0);\n      function buildProcessOptions(opts, override) {\n        var colorCount = opts.colorCount,\n          quantizer = opts.quantizer,\n          generators = opts.generators,\n          filters = opts.filters;\n        // Merge with common quantizer options\n        var commonQuantizerOpts = {\n          colorCount: colorCount\n        };\n        var q = typeof quantizer === 'string' ? {\n          name: quantizer,\n          options: {}\n        } : quantizer;\n        q.options = utils_1.assignDeep({}, commonQuantizerOpts, q.options);\n        return utils_1.assignDeep({}, {\n          quantizer: q,\n          generators: generators,\n          filters: filters\n        }, override);\n      }\n      exports.buildProcessOptions = buildProcessOptions;\n\n      /***/\n    }, /* 8 */\n    /***/function (module, exports, __nested_webpack_require_26616__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var _1 = __importDefault(__nested_webpack_require_26616__(1));\n      var utils_1 = __nested_webpack_require_26616__(0);\n      var Builder = /** @class */function () {\n        function Builder(src, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n          this._src = src;\n          this._opts = utils_1.assignDeep({}, _1.default.DefaultOpts, opts);\n        }\n        Builder.prototype.maxColorCount = function (n) {\n          this._opts.colorCount = n;\n          return this;\n        };\n        Builder.prototype.maxDimension = function (d) {\n          this._opts.maxDimension = d;\n          return this;\n        };\n        Builder.prototype.addFilter = function (name) {\n          if (!this._opts.filters) {\n            this._opts.filters = [name];\n          } else {\n            this._opts.filters.push(name);\n          }\n          return this;\n        };\n        Builder.prototype.removeFilter = function (name) {\n          if (this._opts.filters) {\n            var i = this._opts.filters.indexOf(name);\n            if (i > 0) this._opts.filters.splice(i);\n          }\n          return this;\n        };\n        Builder.prototype.clearFilters = function () {\n          this._opts.filters = [];\n          return this;\n        };\n        Builder.prototype.quality = function (q) {\n          this._opts.quality = q;\n          return this;\n        };\n        Builder.prototype.useImageClass = function (imageClass) {\n          this._opts.ImageClass = imageClass;\n          return this;\n        };\n        Builder.prototype.useGenerator = function (generator, options) {\n          if (!this._opts.generators) this._opts.generators = [];\n          this._opts.generators.push(options ? {\n            name: generator,\n            options: options\n          } : generator);\n          return this;\n        };\n        Builder.prototype.useQuantizer = function (quantizer, options) {\n          this._opts.quantizer = options ? {\n            name: quantizer,\n            options: options\n          } : quantizer;\n          return this;\n        };\n        Builder.prototype.build = function () {\n          return new _1.default(this._src, this._opts);\n        };\n        Builder.prototype.getPalette = function (cb) {\n          return this.build().getPalette(cb);\n        };\n        Builder.prototype.getSwatches = function (cb) {\n          return this.build().getPalette(cb);\n        };\n        return Builder;\n      }();\n      exports.default = Builder;\n\n      /***/\n    }, /* 9 */\n    /***/function (module, exports, __nested_webpack_require_29428__) {\n      \"use strict\";\n\n      var __extends = this && this.__extends || function () {\n        var extendStatics = function (d, b) {\n          extendStatics = Object.setPrototypeOf || {\n            __proto__: []\n          } instanceof Array && function (d, b) {\n            d.__proto__ = b;\n          } || function (d, b) {\n            for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n          };\n          return extendStatics(d, b);\n        };\n        return function (d, b) {\n          extendStatics(d, b);\n          function __() {\n            this.constructor = d;\n          }\n          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n      }();\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var image_1 = __nested_webpack_require_29428__(2);\n      function isRelativeUrl(url) {\n        var u = new URL(url, location.href);\n        return u.protocol === location.protocol && u.host === location.host && u.port === location.port;\n      }\n      function isSameOrigin(a, b) {\n        var ua = new URL(a);\n        var ub = new URL(b);\n        // https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n        return ua.protocol === ub.protocol && ua.hostname === ub.hostname && ua.port === ub.port;\n      }\n      var BrowserImage = /** @class */function (_super) {\n        __extends(BrowserImage, _super);\n        function BrowserImage() {\n          return _super !== null && _super.apply(this, arguments) || this;\n        }\n        BrowserImage.prototype._initCanvas = function () {\n          var img = this.image;\n          var canvas = this._canvas = document.createElement('canvas');\n          var context = canvas.getContext('2d');\n          if (!context) throw new ReferenceError('Failed to create canvas context');\n          this._context = context;\n          canvas.className = '@vibrant/canvas';\n          canvas.style.display = 'none';\n          this._width = canvas.width = img.width;\n          this._height = canvas.height = img.height;\n          context.drawImage(img, 0, 0);\n          document.body.appendChild(canvas);\n        };\n        BrowserImage.prototype.load = function (image) {\n          var _this = this;\n          var img;\n          var src;\n          if (typeof image === 'string') {\n            img = document.createElement('img');\n            src = image;\n            if (!isRelativeUrl(src) && !isSameOrigin(window.location.href, src)) {\n              img.crossOrigin = 'anonymous';\n            }\n            img.src = src;\n          } else if (image instanceof HTMLImageElement) {\n            img = image;\n            src = image.src;\n          } else {\n            return Promise.reject(new Error(\"Cannot load buffer as an image in browser\"));\n          }\n          this.image = img;\n          return new Promise(function (resolve, reject) {\n            var onImageLoad = function () {\n              _this._initCanvas();\n              resolve(_this);\n            };\n            if (img.complete) {\n              // Already loaded\n              onImageLoad();\n            } else {\n              img.onload = onImageLoad;\n              img.onerror = function (e) {\n                return reject(new Error(\"Fail to load image: \" + src));\n              };\n            }\n          });\n        };\n        BrowserImage.prototype.clear = function () {\n          this._context.clearRect(0, 0, this._width, this._height);\n        };\n        BrowserImage.prototype.update = function (imageData) {\n          this._context.putImageData(imageData, 0, 0);\n        };\n        BrowserImage.prototype.getWidth = function () {\n          return this._width;\n        };\n        BrowserImage.prototype.getHeight = function () {\n          return this._height;\n        };\n        BrowserImage.prototype.resize = function (targetWidth, targetHeight, ratio) {\n          var _a = this,\n            canvas = _a._canvas,\n            context = _a._context,\n            img = _a.image;\n          this._width = canvas.width = targetWidth;\n          this._height = canvas.height = targetHeight;\n          context.scale(ratio, ratio);\n          context.drawImage(img, 0, 0);\n        };\n        BrowserImage.prototype.getPixelCount = function () {\n          return this._width * this._height;\n        };\n        BrowserImage.prototype.getImageData = function () {\n          return this._context.getImageData(0, 0, this._width, this._height);\n        };\n        BrowserImage.prototype.remove = function () {\n          if (this._canvas && this._canvas.parentNode) {\n            this._canvas.parentNode.removeChild(this._canvas);\n          }\n        };\n        return BrowserImage;\n      }(image_1.ImageBase);\n      exports.default = BrowserImage;\n\n      /***/\n    }, /* 10 */\n    /***/function (module, exports, __nested_webpack_require_34259__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      var Vibrant = __nested_webpack_require_34259__(5);\n      var pipeline_1 = __importDefault(__nested_webpack_require_34259__(11));\n      Vibrant.use(pipeline_1.default);\n      module.exports = Vibrant;\n\n      /***/\n    }, /* 11 */\n    /***/function (module, exports, __nested_webpack_require_34717__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var quantizer_mmcq_1 = __importDefault(__nested_webpack_require_34717__(12));\n      var generator_default_1 = __importDefault(__nested_webpack_require_34717__(16));\n      var pipeline_1 = __nested_webpack_require_34717__(17);\n      var pipeline = new pipeline_1.BasicPipeline().filter.register('default', function (r, g, b, a) {\n        return a >= 125 && !(r > 250 && g > 250 && b > 250);\n      }).quantizer.register('mmcq', quantizer_mmcq_1.default).generator.register('default', generator_default_1.default);\n      exports.default = pipeline;\n\n      /***/\n    }, /* 12 */\n    /***/function (module, exports, __nested_webpack_require_35591__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var color_1 = __nested_webpack_require_35591__(3);\n      var vbox_1 = __importDefault(__nested_webpack_require_35591__(13));\n      var pqueue_1 = __importDefault(__nested_webpack_require_35591__(15));\n      var fractByPopulations = 0.75;\n      function _splitBoxes(pq, target) {\n        var lastSize = pq.size();\n        while (pq.size() < target) {\n          var vbox = pq.pop();\n          if (vbox && vbox.count() > 0) {\n            var _a = vbox.split(),\n              vbox1 = _a[0],\n              vbox2 = _a[1];\n            pq.push(vbox1);\n            if (vbox2 && vbox2.count() > 0) pq.push(vbox2);\n            // No more new boxes, converged\n            if (pq.size() === lastSize) {\n              break;\n            } else {\n              lastSize = pq.size();\n            }\n          } else {\n            break;\n          }\n        }\n      }\n      var MMCQ = function (pixels, opts) {\n        if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n          throw new Error('Wrong MMCQ parameters');\n        }\n        var vbox = vbox_1.default.build(pixels);\n        var colorCount = vbox.histogram.colorCount;\n        var pq = new pqueue_1.default(function (a, b) {\n          return a.count() - b.count();\n        });\n        pq.push(vbox);\n        // first set of colors, sorted by population\n        _splitBoxes(pq, fractByPopulations * opts.colorCount);\n        // Re-order\n        var pq2 = new pqueue_1.default(function (a, b) {\n          return a.count() * a.volume() - b.count() * b.volume();\n        });\n        pq2.contents = pq.contents;\n        // next set - generate the median cuts using the (npix * vol) sorting.\n        _splitBoxes(pq2, opts.colorCount - pq2.size());\n        // calculate the actual colors\n        return generateSwatches(pq2);\n      };\n      function generateSwatches(pq) {\n        var swatches = [];\n        while (pq.size()) {\n          var v = pq.pop();\n          var color = v.avg();\n          var r = color[0],\n            g = color[1],\n            b = color[2];\n          swatches.push(new color_1.Swatch(color, v.count()));\n        }\n        return swatches;\n      }\n      exports.default = MMCQ;\n\n      /***/\n    }, /* 13 */\n    /***/function (module, exports, __nested_webpack_require_38085__) {\n      \"use strict\";\n\n      var __importDefault = this && this.__importDefault || function (mod) {\n        return mod && mod.__esModule ? mod : {\n          \"default\": mod\n        };\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var histogram_1 = __importDefault(__nested_webpack_require_38085__(14));\n      var SIGBITS = 5;\n      var RSHIFT = 8 - SIGBITS;\n      var VBox = /** @class */function () {\n        function VBox(r1, r2, g1, g2, b1, b2, histogram) {\n          this.histogram = histogram;\n          this._volume = -1;\n          this._count = -1;\n          // NOTE: dimension will be mutated by split operation.\n          //       It must be specified explicitly, not from histogram\n          this.dimension = {\n            r1: r1,\n            r2: r2,\n            g1: g1,\n            g2: g2,\n            b1: b1,\n            b2: b2\n          };\n        }\n        VBox.build = function (pixels) {\n          var h = new histogram_1.default(pixels, {\n            sigBits: SIGBITS\n          });\n          var rmin = h.rmin,\n            rmax = h.rmax,\n            gmin = h.gmin,\n            gmax = h.gmax,\n            bmin = h.bmin,\n            bmax = h.bmax;\n          return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, h);\n        };\n        VBox.prototype.invalidate = function () {\n          this._volume = this._count = -1;\n          this._avg = null;\n        };\n        VBox.prototype.volume = function () {\n          if (this._volume < 0) {\n            var _a = this.dimension,\n              r1 = _a.r1,\n              r2 = _a.r2,\n              g1 = _a.g1,\n              g2 = _a.g2,\n              b1 = _a.b1,\n              b2 = _a.b2;\n            this._volume = (r2 - r1 + 1) * (g2 - g1 + 1) * (b2 - b1 + 1);\n          }\n          return this._volume;\n        };\n        VBox.prototype.count = function () {\n          if (this._count < 0) {\n            var _a = this.histogram,\n              hist = _a.hist,\n              getColorIndex = _a.getColorIndex;\n            var _b = this.dimension,\n              r1 = _b.r1,\n              r2 = _b.r2,\n              g1 = _b.g1,\n              g2 = _b.g2,\n              b1 = _b.b1,\n              b2 = _b.b2;\n            var c = 0;\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  c += hist[index];\n                }\n              }\n            }\n            this._count = c;\n          }\n          return this._count;\n        };\n        VBox.prototype.clone = function () {\n          var histogram = this.histogram;\n          var _a = this.dimension,\n            r1 = _a.r1,\n            r2 = _a.r2,\n            g1 = _a.g1,\n            g2 = _a.g2,\n            b1 = _a.b1,\n            b2 = _a.b2;\n          return new VBox(r1, r2, g1, g2, b1, b2, histogram);\n        };\n        VBox.prototype.avg = function () {\n          if (!this._avg) {\n            var _a = this.histogram,\n              hist = _a.hist,\n              getColorIndex = _a.getColorIndex;\n            var _b = this.dimension,\n              r1 = _b.r1,\n              r2 = _b.r2,\n              g1 = _b.g1,\n              g2 = _b.g2,\n              b1 = _b.b1,\n              b2 = _b.b2;\n            var ntot = 0;\n            var mult = 1 << 8 - SIGBITS;\n            var rsum = void 0;\n            var gsum = void 0;\n            var bsum = void 0;\n            rsum = gsum = bsum = 0;\n            for (var r = r1; r <= r2; r++) {\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  var h = hist[index];\n                  ntot += h;\n                  rsum += h * (r + 0.5) * mult;\n                  gsum += h * (g + 0.5) * mult;\n                  bsum += h * (b + 0.5) * mult;\n                }\n              }\n            }\n            if (ntot) {\n              this._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n            } else {\n              this._avg = [~~(mult * (r1 + r2 + 1) / 2), ~~(mult * (g1 + g2 + 1) / 2), ~~(mult * (b1 + b2 + 1) / 2)];\n            }\n          }\n          return this._avg;\n        };\n        VBox.prototype.contains = function (rgb) {\n          var r = rgb[0],\n            g = rgb[1],\n            b = rgb[2];\n          var _a = this.dimension,\n            r1 = _a.r1,\n            r2 = _a.r2,\n            g1 = _a.g1,\n            g2 = _a.g2,\n            b1 = _a.b1,\n            b2 = _a.b2;\n          r >>= RSHIFT;\n          g >>= RSHIFT;\n          b >>= RSHIFT;\n          return r >= r1 && r <= r2 && g >= g1 && g <= g2 && b >= b1 && b <= b2;\n        };\n        VBox.prototype.split = function () {\n          var _a = this.histogram,\n            hist = _a.hist,\n            getColorIndex = _a.getColorIndex;\n          var _b = this.dimension,\n            r1 = _b.r1,\n            r2 = _b.r2,\n            g1 = _b.g1,\n            g2 = _b.g2,\n            b1 = _b.b1,\n            b2 = _b.b2;\n          var count = this.count();\n          if (!count) return [];\n          if (count === 1) return [this.clone()];\n          var rw = r2 - r1 + 1;\n          var gw = g2 - g1 + 1;\n          var bw = b2 - b1 + 1;\n          var maxw = Math.max(rw, gw, bw);\n          var accSum = null;\n          var sum;\n          var total;\n          sum = total = 0;\n          var maxd = null;\n          if (maxw === rw) {\n            maxd = 'r';\n            accSum = new Uint32Array(r2 + 1);\n            for (var r = r1; r <= r2; r++) {\n              sum = 0;\n              for (var g = g1; g <= g2; g++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n              total += sum;\n              accSum[r] = total;\n            }\n          } else if (maxw === gw) {\n            maxd = 'g';\n            accSum = new Uint32Array(g2 + 1);\n            for (var g = g1; g <= g2; g++) {\n              sum = 0;\n              for (var r = r1; r <= r2; r++) {\n                for (var b = b1; b <= b2; b++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n              total += sum;\n              accSum[g] = total;\n            }\n          } else {\n            maxd = 'b';\n            accSum = new Uint32Array(b2 + 1);\n            for (var b = b1; b <= b2; b++) {\n              sum = 0;\n              for (var r = r1; r <= r2; r++) {\n                for (var g = g1; g <= g2; g++) {\n                  var index = getColorIndex(r, g, b);\n                  sum += hist[index];\n                }\n              }\n              total += sum;\n              accSum[b] = total;\n            }\n          }\n          var splitPoint = -1;\n          var reverseSum = new Uint32Array(accSum.length);\n          for (var i = 0; i < accSum.length; i++) {\n            var d = accSum[i];\n            if (splitPoint < 0 && d > total / 2) splitPoint = i;\n            reverseSum[i] = total - d;\n          }\n          var vbox = this;\n          function doCut(d) {\n            var dim1 = d + '1';\n            var dim2 = d + '2';\n            var d1 = vbox.dimension[dim1];\n            var d2 = vbox.dimension[dim2];\n            var vbox1 = vbox.clone();\n            var vbox2 = vbox.clone();\n            var left = splitPoint - d1;\n            var right = d2 - splitPoint;\n            if (left <= right) {\n              d2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n              d2 = Math.max(0, d2);\n            } else {\n              d2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n              d2 = Math.min(vbox.dimension[dim2], d2);\n            }\n            while (!accSum[d2]) d2++;\n            var c2 = reverseSum[d2];\n            while (!c2 && accSum[d2 - 1]) c2 = reverseSum[--d2];\n            vbox1.dimension[dim2] = d2;\n            vbox2.dimension[dim1] = d2 + 1;\n            return [vbox1, vbox2];\n          }\n          return doCut(maxd);\n        };\n        return VBox;\n      }();\n      exports.default = VBox;\n\n      /***/\n    }, /* 14 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var Histogram = /** @class */function () {\n        function Histogram(pixels, opts) {\n          this.pixels = pixels;\n          this.opts = opts;\n          var sigBits = opts.sigBits;\n          var getColorIndex = function (r, g, b) {\n            return (r << 2 * sigBits) + (g << sigBits) + b;\n          };\n          this.getColorIndex = getColorIndex;\n          var rshift = 8 - sigBits;\n          var hn = 1 << 3 * sigBits;\n          var hist = new Uint32Array(hn);\n          var rmax;\n          var rmin;\n          var gmax;\n          var gmin;\n          var bmax;\n          var bmin;\n          var r;\n          var g;\n          var b;\n          var a;\n          rmax = gmax = bmax = 0;\n          rmin = gmin = bmin = Number.MAX_VALUE;\n          var n = pixels.length / 4;\n          var i = 0;\n          while (i < n) {\n            var offset = i * 4;\n            i++;\n            r = pixels[offset + 0];\n            g = pixels[offset + 1];\n            b = pixels[offset + 2];\n            a = pixels[offset + 3];\n            // Ignored pixels' alpha is marked as 0 in filtering stage\n            if (a === 0) continue;\n            r = r >> rshift;\n            g = g >> rshift;\n            b = b >> rshift;\n            var index = getColorIndex(r, g, b);\n            hist[index] += 1;\n            if (r > rmax) rmax = r;\n            if (r < rmin) rmin = r;\n            if (g > gmax) gmax = g;\n            if (g < gmin) gmin = g;\n            if (b > bmax) bmax = b;\n            if (b < bmin) bmin = b;\n          }\n          this._colorCount = hist.reduce(function (total, c) {\n            return c > 0 ? total + 1 : total;\n          }, 0);\n          this.hist = hist;\n          this.rmax = rmax;\n          this.rmin = rmin;\n          this.gmax = gmax;\n          this.gmin = gmin;\n          this.bmax = bmax;\n          this.bmin = bmin;\n        }\n        Object.defineProperty(Histogram.prototype, \"colorCount\", {\n          get: function () {\n            return this._colorCount;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        return Histogram;\n      }();\n      exports.default = Histogram;\n\n      /***/\n    }, /* 15 */\n    /***/function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var PQueue = /** @class */function () {\n        function PQueue(comparator) {\n          this._comparator = comparator;\n          this.contents = [];\n          this._sorted = false;\n        }\n        PQueue.prototype._sort = function () {\n          if (!this._sorted) {\n            this.contents.sort(this._comparator);\n            this._sorted = true;\n          }\n        };\n        PQueue.prototype.push = function (item) {\n          this.contents.push(item);\n          this._sorted = false;\n        };\n        PQueue.prototype.peek = function (index) {\n          this._sort();\n          index = typeof index === 'number' ? index : this.contents.length - 1;\n          return this.contents[index];\n        };\n        PQueue.prototype.pop = function () {\n          this._sort();\n          return this.contents.pop();\n        };\n        PQueue.prototype.size = function () {\n          return this.contents.length;\n        };\n        PQueue.prototype.map = function (mapper) {\n          this._sort();\n          return this.contents.map(mapper);\n        };\n        return PQueue;\n      }();\n      exports.default = PQueue;\n\n      /***/\n    }, /* 16 */\n    /***/function (module, exports, __nested_webpack_require_49977__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var color_1 = __nested_webpack_require_49977__(3);\n      var converter_1 = __nested_webpack_require_49977__(4);\n      var DefaultOpts = {\n        targetDarkLuma: 0.26,\n        maxDarkLuma: 0.45,\n        minLightLuma: 0.55,\n        targetLightLuma: 0.74,\n        minNormalLuma: 0.3,\n        targetNormalLuma: 0.5,\n        maxNormalLuma: 0.7,\n        targetMutesSaturation: 0.3,\n        maxMutesSaturation: 0.4,\n        targetVibrantSaturation: 1.0,\n        minVibrantSaturation: 0.35,\n        weightSaturation: 3,\n        weightLuma: 6.5,\n        weightPopulation: 0.5\n      };\n      function _findMaxPopulation(swatches) {\n        var p = 0;\n        swatches.forEach(function (s) {\n          p = Math.max(p, s.population);\n        });\n        return p;\n      }\n      function _isAlreadySelected(palette, s) {\n        return palette.Vibrant === s || palette.DarkVibrant === s || palette.LightVibrant === s || palette.Muted === s || palette.DarkMuted === s || palette.LightMuted === s;\n      }\n      function _createComparisonValue(saturation, targetSaturation, luma, targetLuma, population, maxPopulation, opts) {\n        function weightedMean() {\n          var values = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n            values[_i] = arguments[_i];\n          }\n          var sum = 0;\n          var weightSum = 0;\n          for (var i = 0; i < values.length; i += 2) {\n            var value = values[i];\n            var weight = values[i + 1];\n            sum += value * weight;\n            weightSum += weight;\n          }\n          return sum / weightSum;\n        }\n        function invertDiff(value, targetValue) {\n          return 1 - Math.abs(value - targetValue);\n        }\n        return weightedMean(invertDiff(saturation, targetSaturation), opts.weightSaturation, invertDiff(luma, targetLuma), opts.weightLuma, population / maxPopulation, opts.weightPopulation);\n      }\n      function _findColorVariation(palette, swatches, maxPopulation, targetLuma, minLuma, maxLuma, targetSaturation, minSaturation, maxSaturation, opts) {\n        var max = null;\n        var maxValue = 0;\n        swatches.forEach(function (swatch) {\n          var _a = swatch.hsl,\n            s = _a[1],\n            l = _a[2];\n          if (s >= minSaturation && s <= maxSaturation && l >= minLuma && l <= maxLuma && !_isAlreadySelected(palette, swatch)) {\n            var value = _createComparisonValue(s, targetSaturation, l, targetLuma, swatch.population, maxPopulation, opts);\n            if (max === null || value > maxValue) {\n              max = swatch;\n              maxValue = value;\n            }\n          }\n        });\n        return max;\n      }\n      function _generateVariationColors(swatches, maxPopulation, opts) {\n        var palette = {\n          Vibrant: null,\n          DarkVibrant: null,\n          LightVibrant: null,\n          Muted: null,\n          DarkMuted: null,\n          LightMuted: null\n        };\n        // mVibrantSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n        palette.Vibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n        // mLightVibrantSwatch = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n        palette.LightVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n        // mDarkVibrantSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n        //     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n        palette.DarkVibrant = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetVibrantSaturation, opts.minVibrantSaturation, 1, opts);\n        // mMutedSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n        palette.Muted = _findColorVariation(palette, swatches, maxPopulation, opts.targetNormalLuma, opts.minNormalLuma, opts.maxNormalLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        // mLightMutedColor = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n        palette.LightMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetLightLuma, opts.minLightLuma, 1, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        // mDarkMutedSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n        //     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n        palette.DarkMuted = _findColorVariation(palette, swatches, maxPopulation, opts.targetDarkLuma, 0, opts.maxDarkLuma, opts.targetMutesSaturation, 0, opts.maxMutesSaturation, opts);\n        return palette;\n      }\n      function _generateEmptySwatches(palette, maxPopulation, opts) {\n        if (!palette.Vibrant && !palette.DarkVibrant && !palette.LightVibrant) {\n          if (!palette.DarkVibrant && palette.DarkMuted) {\n            var _a = palette.DarkMuted.hsl,\n              h = _a[0],\n              s = _a[1],\n              l = _a[2];\n            l = opts.targetDarkLuma;\n            palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n          }\n          if (!palette.LightVibrant && palette.LightMuted) {\n            var _b = palette.LightMuted.hsl,\n              h = _b[0],\n              s = _b[1],\n              l = _b[2];\n            l = opts.targetDarkLuma;\n            palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n          }\n        }\n        if (!palette.Vibrant && palette.DarkVibrant) {\n          var _c = palette.DarkVibrant.hsl,\n            h = _c[0],\n            s = _c[1],\n            l = _c[2];\n          l = opts.targetNormalLuma;\n          palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        } else if (!palette.Vibrant && palette.LightVibrant) {\n          var _d = palette.LightVibrant.hsl,\n            h = _d[0],\n            s = _d[1],\n            l = _d[2];\n          l = opts.targetNormalLuma;\n          palette.Vibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.DarkVibrant && palette.Vibrant) {\n          var _e = palette.Vibrant.hsl,\n            h = _e[0],\n            s = _e[1],\n            l = _e[2];\n          l = opts.targetDarkLuma;\n          palette.DarkVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.LightVibrant && palette.Vibrant) {\n          var _f = palette.Vibrant.hsl,\n            h = _f[0],\n            s = _f[1],\n            l = _f[2];\n          l = opts.targetLightLuma;\n          palette.LightVibrant = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.Muted && palette.Vibrant) {\n          var _g = palette.Vibrant.hsl,\n            h = _g[0],\n            s = _g[1],\n            l = _g[2];\n          l = opts.targetMutesSaturation;\n          palette.Muted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.DarkMuted && palette.DarkVibrant) {\n          var _h = palette.DarkVibrant.hsl,\n            h = _h[0],\n            s = _h[1],\n            l = _h[2];\n          l = opts.targetMutesSaturation;\n          palette.DarkMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n        if (!palette.LightMuted && palette.LightVibrant) {\n          var _j = palette.LightVibrant.hsl,\n            h = _j[0],\n            s = _j[1],\n            l = _j[2];\n          l = opts.targetMutesSaturation;\n          palette.LightMuted = new color_1.Swatch(converter_1.hslToRgb(h, s, l), 0);\n        }\n      }\n      var DefaultGenerator = function (swatches, opts) {\n        opts = Object.assign({}, DefaultOpts, opts);\n        var maxPopulation = _findMaxPopulation(swatches);\n        var palette = _generateVariationColors(swatches, maxPopulation, opts);\n        _generateEmptySwatches(palette, maxPopulation, opts);\n        return palette;\n      };\n      exports.default = DefaultGenerator;\n\n      /***/\n    }, /* 17 */\n    /***/function (module, exports, __nested_webpack_require_58476__) {\n      \"use strict\";\n\n      var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n        function adopt(value) {\n          return value instanceof P ? value : new P(function (resolve) {\n            resolve(value);\n          });\n        }\n        return new (P || (P = Promise))(function (resolve, reject) {\n          function fulfilled(value) {\n            try {\n              step(generator.next(value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function rejected(value) {\n            try {\n              step(generator[\"throw\"](value));\n            } catch (e) {\n              reject(e);\n            }\n          }\n          function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n          }\n          step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n      };\n      var __generator = this && this.__generator || function (thisArg, body) {\n        var _ = {\n            label: 0,\n            sent: function () {\n              if (t[0] & 1) throw t[1];\n              return t[1];\n            },\n            trys: [],\n            ops: []\n          },\n          f,\n          y,\n          t,\n          g;\n        return g = {\n          next: verb(0),\n          \"throw\": verb(1),\n          \"return\": verb(2)\n        }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n          return this;\n        }), g;\n        function verb(n) {\n          return function (v) {\n            return step([n, v]);\n          };\n        }\n        function step(op) {\n          if (f) throw new TypeError(\"Generator is already executing.\");\n          while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return {\n                  value: op[1],\n                  done: false\n                };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2]) _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n          if (op[0] & 5) throw op[1];\n          return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n          };\n        }\n      };\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.BasicPipeline = exports.Stage = void 0;\n      var image_1 = __nested_webpack_require_58476__(2);\n      var Stage = /** @class */function () {\n        function Stage(pipeline) {\n          this.pipeline = pipeline;\n          this._map = {};\n        }\n        Stage.prototype.names = function () {\n          return Object.keys(this._map);\n        };\n        Stage.prototype.has = function (name) {\n          return !!this._map[name];\n        };\n        Stage.prototype.get = function (name) {\n          return this._map[name];\n        };\n        Stage.prototype.register = function (name, stageFn) {\n          this._map[name] = stageFn;\n          return this.pipeline;\n        };\n        return Stage;\n      }();\n      exports.Stage = Stage;\n      var BasicPipeline = /** @class */function () {\n        function BasicPipeline() {\n          this.filter = new Stage(this);\n          this.quantizer = new Stage(this);\n          this.generator = new Stage(this);\n        }\n        BasicPipeline.prototype._buildProcessTasks = function (_a) {\n          var _this = this;\n          var filters = _a.filters,\n            quantizer = _a.quantizer,\n            generators = _a.generators;\n          // Support wildcard for generators\n          if (generators.length === 1 && generators[0] === '*') {\n            generators = this.generator.names();\n          }\n          return {\n            filters: filters.map(function (f) {\n              return createTask(_this.filter, f);\n            }),\n            quantizer: createTask(this.quantizer, quantizer),\n            generators: generators.map(function (g) {\n              return createTask(_this.generator, g);\n            })\n          };\n          function createTask(stage, o) {\n            var name;\n            var options;\n            if (typeof o === 'string') {\n              name = o;\n            } else {\n              name = o.name;\n              options = o.options;\n            }\n            return {\n              name: name,\n              fn: stage.get(name),\n              options: options\n            };\n          }\n        };\n        BasicPipeline.prototype.process = function (imageData, opts) {\n          return __awaiter(this, void 0, void 0, function () {\n            var _a, filters, quantizer, generators, imageFilterData, colors, palettes;\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  _a = this._buildProcessTasks(opts), filters = _a.filters, quantizer = _a.quantizer, generators = _a.generators;\n                  return [4 /*yield*/, this._filterColors(filters, imageData)];\n                case 1:\n                  imageFilterData = _b.sent();\n                  return [4 /*yield*/, this._generateColors(quantizer, imageFilterData)];\n                case 2:\n                  colors = _b.sent();\n                  return [4 /*yield*/, this._generatePalettes(generators, colors)];\n                case 3:\n                  palettes = _b.sent();\n                  return [2 /*return*/, {\n                    colors: colors,\n                    palettes: palettes\n                  }];\n              }\n            });\n          });\n        };\n        BasicPipeline.prototype._filterColors = function (filters, imageData) {\n          return Promise.resolve(image_1.applyFilters(imageData, filters.map(function (_a) {\n            var fn = _a.fn;\n            return fn;\n          })));\n        };\n        BasicPipeline.prototype._generateColors = function (quantizer, imageData) {\n          return Promise.resolve(quantizer.fn(imageData.data, quantizer.options));\n        };\n        BasicPipeline.prototype._generatePalettes = function (generators, colors) {\n          return __awaiter(this, void 0, void 0, function () {\n            var promiseArr;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  return [4 /*yield*/, Promise.all(generators.map(function (_a) {\n                    var fn = _a.fn,\n                      options = _a.options;\n                    return Promise.resolve(fn(colors, options));\n                  }))\n                  // Map the values to the expected name\n                  ];\n\n                case 1:\n                  promiseArr = _a.sent();\n                  // Map the values to the expected name\n                  return [2 /*return*/, Promise.resolve(promiseArr.reduce(function (promises, promiseVal, i) {\n                    promises[generators[i].name] = promiseVal;\n                    return promises;\n                  }, {}))];\n              }\n            });\n          });\n        };\n        return BasicPipeline;\n      }();\n      exports.BasicPipeline = BasicPipeline;\n\n      /***/\n    }\n    /******/])\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbm9kZS12aWJyYW50L2Rpc3QvdmlicmFudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBUUE7QUFDQTs7QUNWQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7O0FBR0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBOztBQUNBOztBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFDQTs7O0FBR0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFYQTtBQWFBOzs7O0FBSUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFuQkE7Ozs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQU1BO0FBRUE7QUFNQTtBQXFCQTtBQUFBO0FBQ0E7QUFDQTtBQXBCQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTs7OztBQU1BO0FBSUE7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQU1BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQXpHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBc0dBO0FBQUE7QUFoSEE7Ozs7Ozs7Ozs7O0FDc0JBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUExQkE7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBMUJBOzs7Ozs7Ozs7OztBQ2hFQTtBQXlCQTtBQW1KQTtBQUNBO0FBQ0E7QUFDQTtBQXJKQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQVVBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSEE7OztBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFLQTtBQUhBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBOzs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7Ozs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQXZKQTs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQU5BO0FBUUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7O0FBRUE7QUFDQTtBQTNCQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBS0E7QUE1QkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBakJBO0FBbUJBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWxCQTtBQW9CQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUF0QkE7Ozs7Ozs7Ozs7OztBQzdMQTtBQUNBO0FBRUE7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDTEE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7QUNEQTtBQVVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTs7Ozs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUVBO0FBR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQVFBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBRUE7QUFBQTtBQUFBOztBQThGQTtBQXhGQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQUE7QUFNQTs7Ozs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDbkVBO0FBV0E7QUFDQTtBQUVBO0FBYUE7QUFJQTtBQVJBO0FBRUE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBckJBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFLQTtBQUNBOzs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBOzs7Ozs7Ozs7OztBQ3BPQTtBQVdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBN0RBO0FBQUE7QUFBQTtBQUFBOzs7O0FBOERBO0FBQUE7Ozs7Ozs7Ozs7O0FDekVBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7O0FDN0NBO0FBRUE7QUFtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFNQTtBQUVBO0FBS0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFFQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7OztBQUlBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoUUE7QUFLQTtBQUVBO0FBQUE7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBaEJBO0FBb0RBO0FBQUE7QUFtQ0E7QUFDQTtBQUNBO0FBNENBO0FBaEZBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBOzs7Ozs7QUFJQTtBQUNBOztBQUFBO0FBQ0E7O0FBQUE7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQUE7OztBQUhBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFBQTtBQWpGQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uPzkxMDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC93ZWJwYWNrL2Jvb3RzdHJhcD83Zjk4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb3JlL3NyYy91dGlscy50cz9mMDhiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1jb3JlL3NyYy9pbmRleC50cz82ZjA5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1pbWFnZS9zcmMvaW5kZXgudHM/YTkzYSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29sb3Ivc3JjL2luZGV4LnRzP2RjMmQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvbG9yL3NyYy9jb252ZXJ0ZXIudHM/NjZkZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3NyYy9icm93c2VyLnRzP2YyNTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC9zcmMvY29uZmlnLnRzP2M2NWEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL29wdGlvbnMudHM/ZTRmZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtY29yZS9zcmMvYnVpbGRlci50cz9mNjIwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1pbWFnZS1icm93c2VyL3NyYy9pbmRleC50cz83YjQ1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvc3JjL2J1bmRsZS50cz9kMThmIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvc3JjL3BpcGVsaW5lL2luZGV4LnRzPzkyNjAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LXF1YW50aXplci1tbWNxL3NyYy9pbmRleC50cz9lMzJhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1xdWFudGl6ZXItbW1jcS9zcmMvdmJveC50cz9jZmRhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL1ZpYnJhbnQvdmlicmFudC1pbWFnZS9zcmMvaGlzdG9ncmFtLnRzPzA4YTYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LXF1YW50aXplci1tbWNxL3NyYy9wcXVldWUudHM/ZDU5OSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9WaWJyYW50L3ZpYnJhbnQtZ2VuZXJhdG9yLWRlZmF1bHQvc3JjL2luZGV4LnRzPzQzNDAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvVmlicmFudC92aWJyYW50LWNvcmUvc3JjL3BpcGVsaW5lL2luZGV4LnRzP2ZhMjciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiVmlicmFudFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJWaWJyYW50XCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTApO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIG1hcFZhbHVlczxULCBSPiAobzogeyBba2V5OiBzdHJpbmddOiBUIH0sIG1hcHBlcjogKHY6IFQpID0+IFIpOiB7IFtrZXk6IHN0cmluZ106IFIgfSB7XG4gIGxldCByZXN1bHQ6IHsgW2tleTogc3RyaW5nXTogUiB9ID0ge31cblxuICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgaWYgKG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29uc3QgdiA9IG9ba2V5XVxuICAgICAgcmVzdWx0W2tleV0gPSBtYXBwZXIodilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogT3ZlcndyaXRlIHZhbHVlcyBvciBwcm9wZXJ0aWVzIG9uIG9iamVjdHMgYW5kIGxpc3RzIHJlY3Vyc2l2ZWx5LlxuICogQSBzaGFsbG93IGNvcHkgd2lsbCBiZSBjcmVhdGVkIGZvciBlYWNoIGFycmF5IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduRGVlcDxUPiAodGFyZ2V0OiBQYXJ0aWFsPFQ+LCAuLi5zb3VyY2VzOiAoUGFydGlhbDxUPiB8IHVuZGVmaW5lZClbXSk6IFQge1xuICBzb3VyY2VzLmZvckVhY2gocyA9PiB7XG4gICAgaWYgKCFzKSByZXR1cm5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzKSB7XG4gICAgICBpZiAocy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnN0IHYgPSBzW2tleV0gYXMgYW55XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgLy8gU2hhbGxvdyBjb3B5XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2LnNsaWNlKDApIGFzIGFueVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0ge30gYXMgYW55XG4gICAgICAgICAgYXNzaWduRGVlcDxhbnk+KHRhcmdldFtrZXldIGFzIGFueSwgdilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHRhcmdldCBhcyBUXG59XG4iLCJpbXBvcnQgeyBPcHRpb25zLCBidWlsZFByb2Nlc3NPcHRpb25zIH0gZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0IHsgQ2FsbGJhY2sgfSBmcm9tICdAdmlicmFudC90eXBlcydcbmltcG9ydCB7IEltYWdlLCBJbWFnZVNvdXJjZSB9IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuXG5pbXBvcnQgeyBGaWx0ZXIsIFBhbGV0dGUsIFN3YXRjaCB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuXG5pbXBvcnQgQnVpbGRlciBmcm9tICcuL2J1aWxkZXInXG5pbXBvcnQgeyBQaXBlbGluZSwgUHJvY2Vzc09wdGlvbnMsIFByb2Nlc3NSZXN1bHQgfSBmcm9tICcuL3BpcGVsaW5lJ1xuaW1wb3J0IHsgYXNzaWduRGVlcCB9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlicmFudFN0YXRpYyB7XG4gIGZyb20gKHNyYzogSW1hZ2VTb3VyY2UpOiBCdWlsZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpYnJhbnQge1xuICBwcml2YXRlIF9yZXN1bHQ6IFByb2Nlc3NSZXN1bHRcbiAgcHJpdmF0ZSBzdGF0aWMgX3BpcGVsaW5lOiBQaXBlbGluZVxuICBzdGF0aWMgdXNlIChwaXBlbGluZTogUGlwZWxpbmUpIHtcbiAgICB0aGlzLl9waXBlbGluZSA9IHBpcGVsaW5lXG4gIH1cbiAgc3RhdGljIERlZmF1bHRPcHRzOiBQYXJ0aWFsPE9wdGlvbnM+ID0ge1xuICAgIGNvbG9yQ291bnQ6IDY0LFxuICAgIHF1YWxpdHk6IDUsXG4gICAgZmlsdGVyczogW11cbiAgfVxuXG4gIHN0YXRpYyBmcm9tIChzcmM6IEltYWdlU291cmNlKTogQnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBCdWlsZGVyKHNyYylcbiAgfVxuXG4gIGdldCByZXN1bHQgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXN1bHRcbiAgfVxuXG4gIG9wdHM6IE9wdGlvbnNcbiAgY29uc3RydWN0b3IgKHByaXZhdGUgX3NyYzogSW1hZ2VTb3VyY2UsIG9wdHM/OiBQYXJ0aWFsPE9wdGlvbnM+KSB7XG4gICAgdGhpcy5vcHRzID0gYXNzaWduRGVlcCh7fSwgVmlicmFudC5EZWZhdWx0T3B0cywgb3B0cylcbiAgfVxuICBwcml2YXRlIF9wcm9jZXNzIChcbiAgICBpbWFnZTogSW1hZ2UsXG4gICAgb3B0cz86IFBhcnRpYWw8UHJvY2Vzc09wdGlvbnM+XG4gICk6IFByb21pc2U8UHJvY2Vzc1Jlc3VsdD4ge1xuICAgIGxldCB7IHF1YW50aXplciB9ID0gdGhpcy5vcHRzXG5cbiAgICBpbWFnZS5zY2FsZURvd24odGhpcy5vcHRzKVxuXG4gICAgbGV0IHByb2Nlc3NPcHRzID0gYnVpbGRQcm9jZXNzT3B0aW9ucyh0aGlzLm9wdHMsIG9wdHMpXG5cbiAgICByZXR1cm4gVmlicmFudC5fcGlwZWxpbmUucHJvY2VzcyhpbWFnZS5nZXRJbWFnZURhdGEoKSwgcHJvY2Vzc09wdHMpXG4gIH1cbiAgcGFsZXR0ZSAoKTogUGFsZXR0ZSB7XG4gICAgcmV0dXJuIHRoaXMuc3dhdGNoZXMoKVxuICB9XG4gIHN3YXRjaGVzICgpOiBQYWxldHRlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnTWV0aG9kIGRlcHJlY2F0ZWQuIFVzZSBgVmlicmFudC5yZXN1bHQucGFsZXR0ZXNbbmFtZV1gIGluc3RlYWQnXG4gICAgKVxuICB9XG5cbiAgZ2V0UGFsZXR0ZSAobmFtZTogc3RyaW5nLCBjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTxQYWxldHRlPlxuICBnZXRQYWxldHRlIChjYj86IENhbGxiYWNrPFBhbGV0dGU+KTogUHJvbWlzZTxQYWxldHRlPlxuICBnZXRQYWxldHRlICgpOiBQcm9taXNlPFBhbGV0dGU+IHtcbiAgICBjb25zdCBhcmcwID0gYXJndW1lbnRzWzBdXG4gICAgY29uc3QgYXJnMSA9IGFyZ3VtZW50c1sxXVxuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycgPyBhcmcwIDogJ2RlZmF1bHQnXG4gICAgY29uc3QgY2IgPSB0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycgPyBhcmcxIDogYXJnMFxuICAgIGxldCBpbWFnZSA9IG5ldyB0aGlzLm9wdHMuSW1hZ2VDbGFzcygpXG4gICAgcmV0dXJuIGltYWdlXG4gICAgICAubG9hZCh0aGlzLl9zcmMpXG4gICAgICAudGhlbihpbWFnZSA9PiB0aGlzLl9wcm9jZXNzKGltYWdlLCB7IGdlbmVyYXRvcnM6IFtuYW1lXSB9KSlcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIHRoaXMuX3Jlc3VsdCA9IHJlc3VsdFxuICAgICAgICByZXR1cm4gcmVzdWx0LnBhbGV0dGVzW25hbWVdXG4gICAgICB9KVxuICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgaW1hZ2UucmVtb3ZlKClcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IodW5kZWZpbmVkLCByZXMpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBpbWFnZS5yZW1vdmUoKVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihlcnIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycilcbiAgICAgIH0pXG4gIH1cbiAgZ2V0UGFsZXR0ZXMgKFxuICAgIG5hbWVzOiBzdHJpbmdbXSxcbiAgICBjYj86IENhbGxiYWNrPFBhbGV0dGU+XG4gICk6IFByb21pc2U8eyBbbmFtZTogc3RyaW5nXTogUGFsZXR0ZSB9PlxuICBnZXRQYWxldHRlcyAoY2I/OiBDYWxsYmFjazxQYWxldHRlPik6IFByb21pc2U8eyBbbmFtZTogc3RyaW5nXTogUGFsZXR0ZSB9PlxuICBnZXRQYWxldHRlcyAoKTogUHJvbWlzZTx7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH0+IHtcbiAgICBjb25zdCBhcmcwID0gYXJndW1lbnRzWzBdXG4gICAgY29uc3QgYXJnMSA9IGFyZ3VtZW50c1sxXVxuICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuaXNBcnJheShhcmcwKSA/IGFyZzAgOiBbJyonXVxuICAgIGNvbnN0IGNiID0gQXJyYXkuaXNBcnJheShhcmcwKSA/IGFyZzEgOiBhcmcwXG4gICAgbGV0IGltYWdlID0gbmV3IHRoaXMub3B0cy5JbWFnZUNsYXNzKClcbiAgICByZXR1cm4gaW1hZ2VcbiAgICAgIC5sb2FkKHRoaXMuX3NyYylcbiAgICAgIC50aGVuKGltYWdlID0+XG4gICAgICAgIHRoaXMuX3Byb2Nlc3MoaW1hZ2UsIHtcbiAgICAgICAgICBnZW5lcmF0b3JzOiBuYW1lc1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0XG4gICAgICAgIHJldHVybiByZXN1bHQucGFsZXR0ZXNcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICBpbWFnZS5yZW1vdmUoKVxuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYih1bmRlZmluZWQsIHJlcylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGltYWdlLnJlbW92ZSgpXG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVycilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKVxuICAgICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ2FsbGJhY2sgfSBmcm9tICdAdmlicmFudC90eXBlcydcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuXG5leHBvcnQgdHlwZSBJbWFnZUNhbGxiYWNrID0gQ2FsbGJhY2s8SW1hZ2U+XG5cbmV4cG9ydCB0eXBlIEltYWdlU291cmNlID0gc3RyaW5nIHwgSFRNTEltYWdlRWxlbWVudCB8IEJ1ZmZlclxuXG5leHBvcnQgdHlwZSBQaXhlbHMgPSBVaW50OENsYW1wZWRBcnJheSB8IEJ1ZmZlclxuZXhwb3J0IGludGVyZmFjZSBJbWFnZURhdGEge1xuICBkYXRhOiBQaXhlbHMsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VPcHRpb25zIHtcbiAgcXVhbGl0eTogbnVtYmVyXG4gIG1heERpbWVuc2lvbjogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2Uge1xuICBsb2FkIChpbWFnZTogSW1hZ2VTb3VyY2UpOiBQcm9taXNlPEltYWdlPlxuICBjbGVhciAoKTogdm9pZFxuICB1cGRhdGUgKGltYWdlRGF0YTogSW1hZ2VEYXRhKTogdm9pZFxuICBnZXRXaWR0aCAoKTogbnVtYmVyXG4gIGdldEhlaWdodCAoKTogbnVtYmVyXG4gIHJlc2l6ZSAodGFyZ2V0V2lkdGg6IG51bWJlciwgdGFyZ2V0SGVpZ2h0OiBudW1iZXIsIHJhdGlvOiBudW1iZXIpOiB2b2lkXG4gIGdldFBpeGVsQ291bnQgKCk6IG51bWJlclxuICBnZXRJbWFnZURhdGEgKCk6IEltYWdlRGF0YVxuICByZW1vdmUgKCk6IHZvaWRcbiAgc2NhbGVEb3duIChvcHRzOiBJbWFnZU9wdGlvbnMpOiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VDbGFzcyB7XG4gIG5ldygpOiBJbWFnZVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW1hZ2VCYXNlIGltcGxlbWVudHMgSW1hZ2Uge1xuICBhYnN0cmFjdCBsb2FkIChpbWFnZTogSW1hZ2VTb3VyY2UpOiBQcm9taXNlPEltYWdlQmFzZT5cbiAgYWJzdHJhY3QgY2xlYXIgKCk6IHZvaWRcbiAgYWJzdHJhY3QgdXBkYXRlIChpbWFnZURhdGE6IEltYWdlRGF0YSk6IHZvaWRcbiAgYWJzdHJhY3QgZ2V0V2lkdGggKCk6IG51bWJlclxuICBhYnN0cmFjdCBnZXRIZWlnaHQgKCk6IG51bWJlclxuICBhYnN0cmFjdCByZXNpemUgKHRhcmdldFdpZHRoOiBudW1iZXIsIHRhcmdldEhlaWdodDogbnVtYmVyLCByYXRpbzogbnVtYmVyKTogdm9pZFxuICBhYnN0cmFjdCBnZXRQaXhlbENvdW50ICgpOiBudW1iZXJcbiAgYWJzdHJhY3QgZ2V0SW1hZ2VEYXRhICgpOiBJbWFnZURhdGFcbiAgYWJzdHJhY3QgcmVtb3ZlICgpOiB2b2lkXG5cbiAgc2NhbGVEb3duIChvcHRzOiBJbWFnZU9wdGlvbnMpOiB2b2lkIHtcbiAgICBsZXQgd2lkdGg6IG51bWJlciA9IHRoaXMuZ2V0V2lkdGgoKVxuICAgIGxldCBoZWlnaHQ6IG51bWJlciA9IHRoaXMuZ2V0SGVpZ2h0KClcblxuICAgIGxldCByYXRpbzogbnVtYmVyID0gMVxuXG4gICAgaWYgKG9wdHMubWF4RGltZW5zaW9uID4gMCkge1xuICAgICAgbGV0IG1heFNpZGU6IG51bWJlciA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpXG4gICAgICBpZiAobWF4U2lkZSA+IG9wdHMubWF4RGltZW5zaW9uKSByYXRpbyA9IG9wdHMubWF4RGltZW5zaW9uIC8gbWF4U2lkZVxuICAgIH0gZWxzZSB7XG4gICAgICByYXRpbyA9IDEgLyBvcHRzLnF1YWxpdHlcbiAgICB9XG5cbiAgICBpZiAocmF0aW8gPCAxKSB0aGlzLnJlc2l6ZSh3aWR0aCAqIHJhdGlvLCBoZWlnaHQgKiByYXRpbywgcmF0aW8pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RmlsdGVycyAoaW1hZ2VEYXRhOiBJbWFnZURhdGEsIGZpbHRlcnM6IEZpbHRlcltdKSB7XG4gIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICBsZXQgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGFcbiAgICBsZXQgbiA9IHBpeGVscy5sZW5ndGggLyA0XG4gICAgbGV0IG9mZnNldFxuICAgIGxldCByXG4gICAgbGV0IGdcbiAgICBsZXQgYlxuICAgIGxldCBhXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIG9mZnNldCA9IGkgKiA0XG4gICAgICByID0gcGl4ZWxzW29mZnNldCArIDBdXG4gICAgICBnID0gcGl4ZWxzW29mZnNldCArIDFdXG4gICAgICBiID0gcGl4ZWxzW29mZnNldCArIDJdXG4gICAgICBhID0gcGl4ZWxzW29mZnNldCArIDNdXG4gICAgICAvLyBNYXJrIGlnbm9yZWQgY29sb3JcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmlsdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIWZpbHRlcnNbal0ociwgZywgYiwgYSkpIHtcbiAgICAgICAgICBwaXhlbHNbb2Zmc2V0ICsgM10gPSAwXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbWFnZURhdGFcbn1cbiIsImltcG9ydCB7IHJnYlRvSHNsLCByZ2JUb0hleCB9IGZyb20gJy4vY29udmVydGVyJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlciB7XG4gIChyZWQ6IG51bWJlciwgZ3JlZW46IG51bWJlciwgYmx1ZTogbnVtYmVyLCBhbHBoYTogbnVtYmVyKTogYm9vbGVhblxufVxuXG4vKipcbiAqIDNkIGZsb2F0aW5nIHBvaW50ZXIgdmVjdG9yXG4gKi9cbmV4cG9ydCB0eXBlIFZlYzMgPSBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cblxuLyoqXG4gKiBUaGUgbGF5b3V0IGZvciBhIG5vZGUtdmlicmFudCBQYWxldHRlLiBBbGxvd3MgeW91IHRvIGtlZXAgdHJhY2sgb2ZcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYWxldHRlIHtcbiAgVmlicmFudDogU3dhdGNoIHwgbnVsbFxuICBNdXRlZDogU3dhdGNoIHwgbnVsbFxuICBEYXJrVmlicmFudDogU3dhdGNoIHwgbnVsbFxuICBEYXJrTXV0ZWQ6IFN3YXRjaCB8IG51bGxcbiAgTGlnaHRWaWJyYW50OiBTd2F0Y2ggfCBudWxsXG4gIExpZ2h0TXV0ZWQ6IFN3YXRjaCB8IG51bGxcbiAgLy8gP1xuICBbbmFtZTogc3RyaW5nXTogU3dhdGNoIHwgbnVsbFxufVxuXG5leHBvcnQgY2xhc3MgU3dhdGNoIHtcbiAgc3RhdGljIGFwcGx5RmlsdGVycyAoY29sb3JzOiBTd2F0Y2hbXSwgZmlsdGVyczogRmlsdGVyW10pOiBTd2F0Y2hbXSB7XG4gICAgcmV0dXJuIGZpbHRlcnMubGVuZ3RoID4gMFxuICAgICAgPyBjb2xvcnMuZmlsdGVyKCh7IHIsIGcsIGIgfSkgPT4ge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpbHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoIWZpbHRlcnNbal0ociwgZywgYiwgMjU1KSkgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0pXG4gICAgICA6IGNvbG9yc1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSB2YWx1ZSBjb3B5IG9mIGEgc3dhdGNoIGJhc2VkIG9uIGEgcHJldmlvdXMgb25lLiBSZXR1cm5zIGEgbmV3IFN3YXRjaCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3YXRjaH0gc3dhdGNoXG4gICAqL1xuICBzdGF0aWMgY2xvbmUgKHN3YXRjaDogU3dhdGNoKSB7XG4gICAgcmV0dXJuIG5ldyBTd2F0Y2goc3dhdGNoLl9yZ2IsIHN3YXRjaC5fcG9wdWxhdGlvbilcbiAgfVxuICBwcml2YXRlIF9oc2w6IFZlYzNcbiAgcHJpdmF0ZSBfcmdiOiBWZWMzXG4gIHByaXZhdGUgX3lpcTogbnVtYmVyXG4gIHByaXZhdGUgX3BvcHVsYXRpb246IG51bWJlclxuICBwcml2YXRlIF9oZXg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBUaGUgcmVkIHZhbHVlIGluIHRoZSBSR0IgdmFsdWVcbiAgICovXG4gIGdldCByICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9yZ2JbMF1cbiAgfVxuICAvKipcbiAgICogVGhlIGdyZWVuIHZhbHVlIGluIHRoZSBSR0IgdmFsdWVcbiAgICovXG4gIGdldCBnICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9yZ2JbMV1cbiAgfVxuICAvKipcbiAgICogVGhlIGJsdWUgdmFsdWUgaW4gdGhlIFJHQiB2YWx1ZVxuICAgKi9cbiAgZ2V0IGIgKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlsyXVxuICB9XG4gIC8qKlxuICAgKiBUaGUgY29sb3IgdmFsdWUgYXMgYSByZ2IgdmFsdWVcbiAgICovXG4gIGdldCByZ2IgKCk6IFZlYzMge1xuICAgIHJldHVybiB0aGlzLl9yZ2JcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbG9yIHZhbHVlIGFzIGEgaHNsIHZhbHVlXG4gICAqL1xuICBnZXQgaHNsICgpOiBWZWMzIHtcbiAgICBpZiAoIXRoaXMuX2hzbCkge1xuICAgICAgbGV0IFtyLCBnLCBiXSA9IHRoaXMuX3JnYlxuICAgICAgdGhpcy5faHNsID0gcmdiVG9Ic2wociwgZywgYilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hzbFxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjb2xvciB2YWx1ZSBhcyBhIGhleCBzdHJpbmdcbiAgICovXG4gIGdldCBoZXggKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLl9oZXgpIHtcbiAgICAgIGxldCBbciwgZywgYl0gPSB0aGlzLl9yZ2JcbiAgICAgIHRoaXMuX2hleCA9IHJnYlRvSGV4KHIsIGcsIGIpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9oZXhcbiAgfVxuICBnZXQgcG9wdWxhdGlvbiAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcG9wdWxhdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgSlNPTiBvYmplY3QgZm9yIHRoZSBzd2F0Y2hcbiAgICovXG4gIHRvSlNPTiAoKToge3JnYjogVmVjMywgcG9wdWxhdGlvbjogbnVtYmVyfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJnYjogdGhpcy5yZ2IsXG4gICAgICBwb3B1bGF0aW9uOiB0aGlzLnBvcHVsYXRpb25cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciB2YWx1ZSBhcyBhIHJnYiB2YWx1ZVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcHJvcGVydHkgaW5zdGVhZFxuICAgKi9cbiAgLy8gVE9ETzogZGVwcmVjYXRlIGludGVybmFsbHksIHVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gIGdldFJnYiAoKTogVmVjMyB7XG4gICAgcmV0dXJuIHRoaXMuX3JnYlxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvbG9yIHZhbHVlIGFzIGEgaHNsIHZhbHVlXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gICAqL1xuICAvLyBUT0RPOiBkZXByZWNhdGUgaW50ZXJuYWxseSwgdXNlIHByb3BlcnR5IGluc3RlYWRcbiAgZ2V0SHNsICgpOiBWZWMzIHtcbiAgICByZXR1cm4gdGhpcy5oc2xcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHByb3BlcnR5IGluc3RlYWRcbiAgICovXG4gIC8vIFRPRE86IGRlcHJlY2F0ZSBpbnRlcm5hbGx5LCB1c2UgcHJvcGVydHkgaW5zdGVhZFxuICBnZXRQb3B1bGF0aW9uICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wb3B1bGF0aW9uXG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY29sb3IgdmFsdWUgYXMgYSBoZXggc3RyaW5nXG4gICAqIEBkZXByZWNhdGVkIFVzZSBwcm9wZXJ0eSBpbnN0ZWFkXG4gICAqL1xuICAvLyBUT0RPOiBkZXByZWNhdGUgaW50ZXJuYWxseSwgdXNlIHByb3BlcnR5IGluc3RlYWRcbiAgZ2V0SGV4ICgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmhleFxuICB9XG5cbiAgcHJpdmF0ZSBnZXRZaXEgKCk6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLl95aXEpIHtcbiAgICAgIGxldCByZ2IgPSB0aGlzLl9yZ2JcbiAgICAgIHRoaXMuX3lpcSA9IChyZ2JbMF0gKiAyOTkgKyByZ2JbMV0gKiA1ODcgKyByZ2JbMl0gKiAxMTQpIC8gMTAwMFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5feWlxXG4gIH1cblxuICBwcml2YXRlIF90aXRsZVRleHRDb2xvcjogc3RyaW5nXG4gIHByaXZhdGUgX2JvZHlUZXh0Q29sb3I6IHN0cmluZ1xuXG4gIGdldCB0aXRsZVRleHRDb2xvciAoKSB7XG4gICAgaWYgKHRoaXMuX3RpdGxlVGV4dENvbG9yKSB7XG4gICAgICB0aGlzLl90aXRsZVRleHRDb2xvciA9IHRoaXMuZ2V0WWlxKCkgPCAyMDAgPyAnI2ZmZicgOiAnIzAwMCdcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RpdGxlVGV4dENvbG9yXG4gIH1cbiAgZ2V0IGJvZHlUZXh0Q29sb3IgKCkge1xuICAgIGlmICh0aGlzLl9ib2R5VGV4dENvbG9yKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dENvbG9yID0gdGhpcy5nZXRZaXEoKSA8IDE1MCA/ICcjZmZmJyA6ICcjMDAwJ1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYm9keVRleHRDb2xvclxuICB9XG4gIGdldFRpdGxlVGV4dENvbG9yICgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnRpdGxlVGV4dENvbG9yXG4gIH1cblxuICBnZXRCb2R5VGV4dENvbG9yICgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmJvZHlUZXh0Q29sb3JcbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChyZ2I6IFZlYzMsIHBvcHVsYXRpb246IG51bWJlcikge1xuICAgIHRoaXMuX3JnYiA9IHJnYlxuICAgIHRoaXMuX3BvcHVsYXRpb24gPSBwb3B1bGF0aW9uXG4gIH1cbn1cbiIsImltcG9ydCB7IFZlYzMgfSBmcm9tICcuLydcblxuZXhwb3J0IGNvbnN0IERFTFRBRTk0X0RJRkZfU1RBVFVTID0ge1xuICBOQTogMCxcbiAgUEVSRkVDVDogMSxcbiAgQ0xPU0U6IDIsXG4gIEdPT0Q6IDEwLFxuICBTSU1JTEFSOiA1MFxufVxuXG4vKipcbiAqIENvbnZlcnRzIGhleCBzdHJpbmcgdG8gUkdCXG4gKiBAcGFyYW0gaGV4IC0gVGhlIGhleCB2YWx1ZSB5b3Ugd2l0aCB0byBnZXQgdGhlIFJHQiB2YWx1ZSBvZlxuICogQHJldHVybnMgYW4gYXJyYXkgaW4gdGhlIG9yZGVyIG9mIGByZWQsIGdyZWVuLCBibHVlYCBudW1lcmljYWwgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1JnYiAoaGV4OiBzdHJpbmcpOiBWZWMzIHtcbiAgbGV0IG0gPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoaGV4KVxuXG4gIGlmICghbSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCcke2hleH0nIGlzIG5vdCBhIHZhbGlkIGhleCBjb2xvcmApXG5cbiAgcmV0dXJuIFttWzFdLCBtWzJdLCBtWzNdXS5tYXAoKHMpID0+IHBhcnNlSW50KHMsIDE2KSkgYXMgVmVjM1xufVxuXG4vKipcbiAqIEdpdmVuIHZhbHVlcyBmb3IgYW4gUkdCIGNvbG9yIGNvbnZlcnQgdG8gYW5kIHJldHVybiBhIHZhbGlkIEhFWCBzdHJpbmdcbiAqIEBwYXJhbSByIC0gUmVkIHZhbHVlIGluIFJHQlxuICogQHBhcmFtIGcgLSBHcmVlbiB2YWx1ZSBpbiBSR0JcbiAqIEBwYXJhbSBiIC0gQmx1ZSB2YWx1ZSBpbiBSR0JcbiAqIEByZXR1cm5zIGEgdmFsaWQgaGV4IHN0cmluZyB3aXRoIHByZS1wZW5kaW5nIHBvdW5kIHNpZ25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSGV4IChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuICcjJyArICgoMSA8PCAyNCkgKyAociA8PCAxNikgKyAoZyA8PCA4KSArIGIpLnRvU3RyaW5nKDE2KS5zbGljZSgxLCA3KVxufVxuXG4vKipcbiAqIEdpdmVuIHZhbHVlcyBmb3IgYW4gUkdCIGNvbG9yIGNvbnZlcnQgdG8gYW5kIHJldHVybiBhIHZhbGlkIEhTTCB2YWx1ZVxuICogQHBhcmFtIHIgLSBSZWQgdmFsdWUgaW4gUkdCXG4gKiBAcGFyYW0gZyAtIEdyZWVuIHZhbHVlIGluIFJHQlxuICogQHBhcmFtIGIgLSBCbHVlIHZhbHVlIGluIFJHQlxuICogQHJldHVybnMgYW4gYXJyYXkgaW4gdGhlIG9yZGVyIG9mIGBodWUsIHNhdHVyYXRpb24sIGxpZ2h0YCBudW1lcmljYWwgdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hzbCAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcik6IFZlYzMge1xuICByIC89IDI1NVxuICBnIC89IDI1NVxuICBiIC89IDI1NVxuICBsZXQgbWF4ID0gTWF0aC5tYXgociwgZywgYilcbiAgbGV0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpXG4gIGxldCBoOiBudW1iZXIgPSAwXG4gIGxldCBzOiBudW1iZXIgPSAwXG4gIGxldCBsID0gKG1heCArIG1pbikgLyAyXG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGxldCBkID0gbWF4IC0gbWluXG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pXG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgcjpcbiAgICAgICAgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIGc6XG4gICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDJcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNFxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGggLz0gNlxuICB9XG4gIHJldHVybiBbaCwgcywgbF1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzbFRvUmdiIChoOiBudW1iZXIsIHM6IG51bWJlciwgbDogbnVtYmVyKTogVmVjMyB7XG4gIGxldCByOiBudW1iZXJcbiAgbGV0IGc6IG51bWJlclxuICBsZXQgYjogbnVtYmVyXG5cbiAgZnVuY3Rpb24gaHVlMnJnYiAocDogbnVtYmVyLCBxOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKHQgPCAwKSB0ICs9IDFcbiAgICBpZiAodCA+IDEpIHQgLT0gMVxuICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0XG4gICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHFcbiAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDZcbiAgICByZXR1cm4gcFxuICB9XG5cbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsXG4gIH0gZWxzZSB7XG4gICAgbGV0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIChsICogcylcbiAgICBsZXQgcCA9IDIgKiBsIC0gcVxuICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMylcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKVxuICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAoMSAvIDMpKVxuICB9XG4gIHJldHVybiBbXG4gICAgciAqIDI1NSxcbiAgICBnICogMjU1LFxuICAgIGIgKiAyNTVcbiAgXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9YeXogKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpOiBWZWMzIHtcbiAgciAvPSAyNTVcbiAgZyAvPSAyNTVcbiAgYiAvPSAyNTVcbiAgciA9IHIgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKHIgKyAwLjAwNSkgLyAxLjA1NSwgMi40KSA6IHIgLyAxMi45MlxuICBnID0gZyA+IDAuMDQwNDUgPyBNYXRoLnBvdygoZyArIDAuMDA1KSAvIDEuMDU1LCAyLjQpIDogZyAvIDEyLjkyXG4gIGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KChiICsgMC4wMDUpIC8gMS4wNTUsIDIuNCkgOiBiIC8gMTIuOTJcblxuICByICo9IDEwMFxuICBnICo9IDEwMFxuICBiICo9IDEwMFxuXG4gIGxldCB4ID0gciAqIDAuNDEyNCArIGcgKiAwLjM1NzYgKyBiICogMC4xODA1XG4gIGxldCB5ID0gciAqIDAuMjEyNiArIGcgKiAwLjcxNTIgKyBiICogMC4wNzIyXG4gIGxldCB6ID0gciAqIDAuMDE5MyArIGcgKiAwLjExOTIgKyBiICogMC45NTA1XG5cbiAgcmV0dXJuIFt4LCB5LCB6XVxufVxuXG5leHBvcnQgZnVuY3Rpb24geHl6VG9DSUVMYWIgKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiBWZWMzIHtcbiAgbGV0IFJFRl9YID0gOTUuMDQ3XG4gIGxldCBSRUZfWSA9IDEwMFxuICBsZXQgUkVGX1ogPSAxMDguODgzXG5cbiAgeCAvPSBSRUZfWFxuICB5IC89IFJFRl9ZXG4gIHogLz0gUkVGX1pcblxuICB4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogNy43ODcgKiB4ICsgMTYgLyAxMTZcbiAgeSA9IHkgPiAwLjAwODg1NiA/IE1hdGgucG93KHksIDEgLyAzKSA6IDcuNzg3ICogeSArIDE2IC8gMTE2XG4gIHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiA3Ljc4NyAqIHogKyAxNiAvIDExNlxuXG4gIGxldCBMID0gMTE2ICogeSAtIDE2XG4gIGxldCBhID0gNTAwICogKHggLSB5KVxuICBsZXQgYiA9IDIwMCAqICh5IC0geilcblxuICByZXR1cm4gW0wsIGEsIGJdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0NJRUxhYiAocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcik6IFZlYzMge1xuICBsZXQgW3gsIHksIHpdID0gcmdiVG9YeXoociwgZywgYilcbiAgcmV0dXJuIHh5elRvQ0lFTGFiKHgsIHksIHopXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWx0YUU5NCAobGFiMTogVmVjMywgbGFiMjogVmVjMyk6IG51bWJlciB7XG4gIGxldCBXRUlHSFRfTCA9IDFcbiAgbGV0IFdFSUdIVF9DID0gMVxuICBsZXQgV0VJR0hUX0ggPSAxXG5cbiAgbGV0IFtMMSwgYTEsIGIxXSA9IGxhYjFcbiAgbGV0IFtMMiwgYTIsIGIyXSA9IGxhYjJcbiAgbGV0IGRMID0gTDEgLSBMMlxuICBsZXQgZGEgPSBhMSAtIGEyXG4gIGxldCBkYiA9IGIxIC0gYjJcblxuICBsZXQgeEMxID0gTWF0aC5zcXJ0KGExICogYTEgKyBiMSAqIGIxKVxuICBsZXQgeEMyID0gTWF0aC5zcXJ0KGEyICogYTIgKyBiMiAqIGIyKVxuXG4gIGxldCB4REwgPSBMMiAtIEwxXG4gIGxldCB4REMgPSB4QzIgLSB4QzFcbiAgbGV0IHhERSA9IE1hdGguc3FydChkTCAqIGRMICsgZGEgKiBkYSArIGRiICogZGIpXG5cbiAgbGV0IHhESCA9IChNYXRoLnNxcnQoeERFKSA+IE1hdGguc3FydChNYXRoLmFicyh4REwpKSArIE1hdGguc3FydChNYXRoLmFicyh4REMpKSlcbiAgICA/IE1hdGguc3FydCh4REUgKiB4REUgLSB4REwgKiB4REwgLSB4REMgKiB4REMpXG4gICAgOiAwXG5cbiAgbGV0IHhTQyA9IDEgKyAwLjA0NSAqIHhDMVxuICBsZXQgeFNIID0gMSArIDAuMDE1ICogeEMxXG5cbiAgeERMIC89IFdFSUdIVF9MXG4gIHhEQyAvPSBXRUlHSFRfQyAqIHhTQ1xuICB4REggLz0gV0VJR0hUX0ggKiB4U0hcblxuICByZXR1cm4gTWF0aC5zcXJ0KHhETCAqIHhETCArIHhEQyAqIHhEQyArIHhESCAqIHhESClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJnYkRpZmYgKHJnYjE6IFZlYzMsIHJnYjI6IFZlYzMpOiBudW1iZXIge1xuICBsZXQgbGFiMSA9IHJnYlRvQ0lFTGFiLmFwcGx5KHVuZGVmaW5lZCwgcmdiMSlcbiAgbGV0IGxhYjIgPSByZ2JUb0NJRUxhYi5hcHBseSh1bmRlZmluZWQsIHJnYjIpXG4gIHJldHVybiBkZWx0YUU5NChsYWIxLCBsYWIyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4RGlmZiAoaGV4MTogc3RyaW5nLCBoZXgyOiBzdHJpbmcpOiBudW1iZXIge1xuICBsZXQgcmdiMSA9IGhleFRvUmdiKGhleDEpXG4gIGxldCByZ2IyID0gaGV4VG9SZ2IoaGV4MilcblxuICByZXR1cm4gcmdiRGlmZihyZ2IxLCByZ2IyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3JEaWZmU3RhdHVzIChkOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoZCA8IERFTFRBRTk0X0RJRkZfU1RBVFVTLk5BKSB7XG4gICAgcmV0dXJuICdOL0EnXG4gIH1cbiAgLy8gTm90IHBlcmNlcHRpYmxlIGJ5IGh1bWFuIGV5ZXNcbiAgaWYgKGQgPD0gREVMVEFFOTRfRElGRl9TVEFUVVMuUEVSRkVDVCkge1xuICAgIHJldHVybiAnUGVyZmVjdCdcbiAgfVxuICAvLyBQZXJjZXB0aWJsZSB0aHJvdWdoIGNsb3NlIG9ic2VydmF0aW9uXG4gIGlmIChkIDw9IERFTFRBRTk0X0RJRkZfU1RBVFVTLkNMT1NFKSB7XG4gICAgcmV0dXJuICdDbG9zZSdcbiAgfVxuICAvLyBQZXJjZXB0aWJsZSBhdCBhIGdsYW5jZVxuICBpZiAoZCA8PSBERUxUQUU5NF9ESUZGX1NUQVRVUy5HT09EKSB7XG4gICAgcmV0dXJuICdHb29kJ1xuICB9XG4gIC8vIENvbG9ycyBhcmUgbW9yZSBzaW1pbGFyIHRoYW4gb3Bwb3NpdGVcbiAgaWYgKGQgPCBERUxUQUU5NF9ESUZGX1NUQVRVUy5TSU1JTEFSKSB7XG4gICAgcmV0dXJuICdTaW1pbGFyJ1xuICB9XG4gIHJldHVybiAnV3JvbmcnXG5cbn1cbiIsImltcG9ydCBWaWJyYW50IGZyb20gJy4vY29uZmlnJ1xuaW1wb3J0IEJyb3dzZXJJbWFnZSBmcm9tICdAdmlicmFudC9pbWFnZS1icm93c2VyJ1xuXG5WaWJyYW50LkRlZmF1bHRPcHRzLkltYWdlQ2xhc3MgPSBCcm93c2VySW1hZ2VcblxuZXhwb3J0ID0gVmlicmFudFxuIiwiaW1wb3J0IFZpYnJhbnQgZnJvbSAnQHZpYnJhbnQvY29yZSdcblxuVmlicmFudC5EZWZhdWx0T3B0cy5xdWFudGl6ZXIgPSAnbW1jcSdcblZpYnJhbnQuRGVmYXVsdE9wdHMuZ2VuZXJhdG9ycyA9IFsnZGVmYXVsdCddXG5WaWJyYW50LkRlZmF1bHRPcHRzLmZpbHRlcnMgPSBbJ2RlZmF1bHQnXVxuXG5leHBvcnQgZGVmYXVsdCBWaWJyYW50XG4iLCJpbXBvcnQgeyBQYWxldHRlLCBTd2F0Y2gsIEZpbHRlciB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuaW1wb3J0IHsgSW1hZ2UsIEltYWdlQ2xhc3MsIEltYWdlU291cmNlLCBJbWFnZU9wdGlvbnMgfSBmcm9tICdAdmlicmFudC9pbWFnZSdcbmltcG9ydCB7IFF1YW50aXplciwgUXVhbnRpemVyT3B0aW9ucyB9IGZyb20gJ0B2aWJyYW50L3F1YW50aXplcidcbmltcG9ydCB7IEdlbmVyYXRvciB9IGZyb20gJ0B2aWJyYW50L2dlbmVyYXRvcidcbmltcG9ydCB7IFN0YWdlT3B0aW9ucywgUHJvY2Vzc09wdGlvbnMgfSBmcm9tICcuL3BpcGVsaW5lJ1xuaW1wb3J0IHsgYXNzaWduRGVlcCB9IGZyb20gJy4vdXRpbHMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyBleHRlbmRzIEltYWdlT3B0aW9ucywgUXVhbnRpemVyT3B0aW9ucyB7XG4gIHVzZVdvcmtlcjogYm9vbGVhblxuICBJbWFnZUNsYXNzOiBJbWFnZUNsYXNzXG4gIHF1YW50aXplcjogc3RyaW5nIHwgU3RhZ2VPcHRpb25zXG4gIGdlbmVyYXRvcnM6IChzdHJpbmcgfCBTdGFnZU9wdGlvbnMpW11cbiAgZmlsdGVyczogc3RyaW5nW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUHJvY2Vzc09wdGlvbnMgKG9wdHM6IE9wdGlvbnMsIG92ZXJyaWRlPzogUGFydGlhbDxQcm9jZXNzT3B0aW9ucz4pOiBQcm9jZXNzT3B0aW9ucyB7XG4gIGxldCB7IGNvbG9yQ291bnQsIHF1YW50aXplciwgZ2VuZXJhdG9ycywgZmlsdGVycyB9ID0gb3B0c1xuICAvLyBNZXJnZSB3aXRoIGNvbW1vbiBxdWFudGl6ZXIgb3B0aW9uc1xuICBsZXQgY29tbW9uUXVhbnRpemVyT3B0cyA9IHsgY29sb3JDb3VudCB9XG4gIGxldCBxID0gdHlwZW9mIHF1YW50aXplciA9PT0gJ3N0cmluZydcbiAgICA/IHsgbmFtZTogcXVhbnRpemVyLCBvcHRpb25zOiB7fSB9XG4gICAgOiBxdWFudGl6ZXJcbiAgcS5vcHRpb25zID0gYXNzaWduRGVlcCh7fSwgY29tbW9uUXVhbnRpemVyT3B0cywgcS5vcHRpb25zKVxuXG4gIHJldHVybiBhc3NpZ25EZWVwKHt9LCB7XG4gICAgcXVhbnRpemVyOiBxLFxuICAgIGdlbmVyYXRvcnMsXG4gICAgZmlsdGVyc1xuICB9LCBvdmVycmlkZSlcbn1cbiIsImltcG9ydCB7XG4gIE9wdGlvbnNcbn0gZnJvbSAnLi9vcHRpb25zJ1xuaW1wb3J0IHtcbiAgQ2FsbGJhY2tcbn0gZnJvbSAnQHZpYnJhbnQvdHlwZXMnXG5pbXBvcnQge1xuICBJbWFnZUNsYXNzLFxuICBJbWFnZVNvdXJjZVxufSBmcm9tICdAdmlicmFudC9pbWFnZSdcblxuaW1wb3J0IHtcbiAgRmlsdGVyLFxuICBQYWxldHRlXG59IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuaW1wb3J0IFZpYnJhbnQgZnJvbSAnLi8nXG5pbXBvcnQgeyBhc3NpZ25EZWVwIH0gZnJvbSAnLi91dGlscydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVpbGRlciB7XG4gIHByaXZhdGUgX3NyYzogSW1hZ2VTb3VyY2VcbiAgcHJpdmF0ZSBfb3B0czogUGFydGlhbDxPcHRpb25zPlxuICBjb25zdHJ1Y3RvciAoc3JjOiBJbWFnZVNvdXJjZSwgb3B0czogUGFydGlhbDxPcHRpb25zPiA9IHt9KSB7XG4gICAgdGhpcy5fc3JjID0gc3JjXG4gICAgdGhpcy5fb3B0cyA9IGFzc2lnbkRlZXAoe30sIFZpYnJhbnQuRGVmYXVsdE9wdHMsIG9wdHMpXG4gIH1cblxuICBtYXhDb2xvckNvdW50IChuOiBudW1iZXIpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLmNvbG9yQ291bnQgPSBuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG1heERpbWVuc2lvbiAoZDogbnVtYmVyKTogQnVpbGRlciB7XG4gICAgdGhpcy5fb3B0cy5tYXhEaW1lbnNpb24gPSBkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGFkZEZpbHRlciAobmFtZTogc3RyaW5nKTogQnVpbGRlciB7XG4gICAgaWYgKCF0aGlzLl9vcHRzLmZpbHRlcnMpIHtcbiAgICAgIHRoaXMuX29wdHMuZmlsdGVycyA9IFtuYW1lXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcHRzLmZpbHRlcnMucHVzaChuYW1lKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmVtb3ZlRmlsdGVyIChuYW1lOiBzdHJpbmcpOiBCdWlsZGVyIHtcbiAgICBpZiAodGhpcy5fb3B0cy5maWx0ZXJzKSB7XG4gICAgICBsZXQgaSA9IHRoaXMuX29wdHMuZmlsdGVycy5pbmRleE9mKG5hbWUpXG4gICAgICBpZiAoaSA+IDApIHRoaXMuX29wdHMuZmlsdGVycy5zcGxpY2UoaSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNsZWFyRmlsdGVycyAoKTogQnVpbGRlciB7XG4gICAgdGhpcy5fb3B0cy5maWx0ZXJzID0gW11cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcXVhbGl0eSAocTogbnVtYmVyKTogQnVpbGRlciB7XG4gICAgdGhpcy5fb3B0cy5xdWFsaXR5ID0gcVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB1c2VJbWFnZUNsYXNzIChpbWFnZUNsYXNzOiBJbWFnZUNsYXNzKTogQnVpbGRlciB7XG4gICAgdGhpcy5fb3B0cy5JbWFnZUNsYXNzID0gaW1hZ2VDbGFzc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB1c2VHZW5lcmF0b3IgKGdlbmVyYXRvcjogc3RyaW5nLCBvcHRpb25zPzogYW55KTogQnVpbGRlciB7XG4gICAgaWYgKCF0aGlzLl9vcHRzLmdlbmVyYXRvcnMpIHRoaXMuX29wdHMuZ2VuZXJhdG9ycyA9IFtdXG4gICAgdGhpcy5fb3B0cy5nZW5lcmF0b3JzLnB1c2gob3B0aW9ucyA/IHsgbmFtZTogZ2VuZXJhdG9yLCBvcHRpb25zIH0gOiBnZW5lcmF0b3IpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHVzZVF1YW50aXplciAocXVhbnRpemVyOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiBCdWlsZGVyIHtcbiAgICB0aGlzLl9vcHRzLnF1YW50aXplciA9IG9wdGlvbnMgPyB7IG5hbWU6IHF1YW50aXplciwgb3B0aW9ucyB9IDogcXVhbnRpemVyXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGJ1aWxkICgpOiBWaWJyYW50IHtcbiAgICByZXR1cm4gbmV3IFZpYnJhbnQodGhpcy5fc3JjLCB0aGlzLl9vcHRzKVxuICB9XG5cbiAgZ2V0UGFsZXR0ZSAoY2I/OiBDYWxsYmFjazxQYWxldHRlPik6IFByb21pc2U8UGFsZXR0ZT4ge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkKCkuZ2V0UGFsZXR0ZShjYilcbiAgfVxuICBnZXRTd2F0Y2hlcyAoY2I/OiBDYWxsYmFjazxQYWxldHRlPik6IFByb21pc2U8UGFsZXR0ZT4ge1xuICAgIHJldHVybiB0aGlzLmJ1aWxkKCkuZ2V0UGFsZXR0ZShjYilcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgSW1hZ2VPcHRpb25zLFxuICBJbWFnZURhdGEgYXMgVmlicmFudEltYWdlRGF0YSxcbiAgSW1hZ2VTb3VyY2UsXG4gIEltYWdlQ2FsbGJhY2ssXG4gIEltYWdlQmFzZVxufSBmcm9tICdAdmlicmFudC9pbWFnZSdcblxuZnVuY3Rpb24gaXNSZWxhdGl2ZVVybCAodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgbGV0IHUgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZilcbiAgcmV0dXJuIHUucHJvdG9jb2wgPT09IGxvY2F0aW9uLnByb3RvY29sICYmXG4gICAgdS5ob3N0ID09PSBsb2NhdGlvbi5ob3N0ICYmXG4gICAgdS5wb3J0ID09PSBsb2NhdGlvbi5wb3J0XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbiAoYTogc3RyaW5nLCBiOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgbGV0IHVhID0gbmV3IFVSTChhKVxuICBsZXQgdWIgPSBuZXcgVVJMKGIpXG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU2VjdXJpdHkvU2FtZS1vcmlnaW5fcG9saWN5XG4gIHJldHVybiAoXG4gICAgdWEucHJvdG9jb2wgPT09IHViLnByb3RvY29sICYmXG4gICAgdWEuaG9zdG5hbWUgPT09IHViLmhvc3RuYW1lICYmXG4gICAgdWEucG9ydCA9PT0gdWIucG9ydFxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJyb3dzZXJJbWFnZSBleHRlbmRzIEltYWdlQmFzZSB7XG4gIGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50XG4gIHByaXZhdGUgX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbiAgcHJpdmF0ZSBfY29udGV4dDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gIHByaXZhdGUgX3dpZHRoOiBudW1iZXJcbiAgcHJpdmF0ZSBfaGVpZ2h0OiBudW1iZXJcbiAgcHJpdmF0ZSBfaW5pdENhbnZhcyAoKTogdm9pZCB7XG4gICAgY29uc3QgaW1nID0gdGhpcy5pbWFnZVxuICAgIGNvbnN0IGNhbnZhcyA9ICh0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSlcbiAgICBjb25zdCBjb250ZXh0ID0gKGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxuXG4gICAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY2FudmFzIGNvbnRleHQnKVxuXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHRcblxuICAgIGNhbnZhcy5jbGFzc05hbWUgPSAnQHZpYnJhbnQvY2FudmFzJ1xuICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICB0aGlzLl93aWR0aCA9IGNhbnZhcy53aWR0aCA9IGltZy53aWR0aFxuICAgIHRoaXMuX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0XG5cbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApXG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcylcbiAgfVxuICBsb2FkIChpbWFnZTogSW1hZ2VTb3VyY2UpOiBQcm9taXNlPEltYWdlQmFzZT4ge1xuICAgIGxldCBpbWc6IEhUTUxJbWFnZUVsZW1lbnRcbiAgICBsZXQgc3JjOiBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGltYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgIHNyYyA9IGltYWdlXG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZVVybChzcmMpICYmICFpc1NhbWVPcmlnaW4od2luZG93LmxvY2F0aW9uLmhyZWYsIHNyYykpIHtcbiAgICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgICAgIH1cblxuICAgICAgaW1nLnNyYyA9IHNyY1xuICAgIH0gZWxzZSBpZiAoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgICBpbWcgPSBpbWFnZVxuICAgICAgc3JjID0gaW1hZ2Uuc3JjXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKGBDYW5ub3QgbG9hZCBidWZmZXIgYXMgYW4gaW1hZ2UgaW4gYnJvd3NlcmApXG4gICAgICApXG4gICAgfVxuICAgIHRoaXMuaW1hZ2UgPSBpbWdcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTxJbWFnZUJhc2U+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBvbkltYWdlTG9hZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5faW5pdENhbnZhcygpXG4gICAgICAgIHJlc29sdmUodGhpcylcbiAgICAgIH1cblxuICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAvLyBBbHJlYWR5IGxvYWRlZFxuICAgICAgICBvbkltYWdlTG9hZCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWcub25sb2FkID0gb25JbWFnZUxvYWRcbiAgICAgICAgaW1nLm9uZXJyb3IgPSBlID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWwgdG8gbG9hZCBpbWFnZTogJHtzcmN9YCkpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBjbGVhciAoKTogdm9pZCB7XG4gICAgdGhpcy5fY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgfVxuICB1cGRhdGUgKGltYWdlRGF0YTogVmlicmFudEltYWdlRGF0YSk6IHZvaWQge1xuICAgIHRoaXMuX2NvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSBhcyBJbWFnZURhdGEsIDAsIDApXG4gIH1cbiAgZ2V0V2lkdGggKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoXG4gIH1cbiAgZ2V0SGVpZ2h0ICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHRcbiAgfVxuICByZXNpemUgKHRhcmdldFdpZHRoOiBudW1iZXIsIHRhcmdldEhlaWdodDogbnVtYmVyLCByYXRpbzogbnVtYmVyKTogdm9pZCB7XG4gICAgbGV0IHsgX2NhbnZhczogY2FudmFzLCBfY29udGV4dDogY29udGV4dCwgaW1hZ2U6IGltZyB9ID0gdGhpc1xuXG4gICAgdGhpcy5fd2lkdGggPSBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aFxuICAgIHRoaXMuX2hlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRIZWlnaHRcblxuICAgIGNvbnRleHQuc2NhbGUocmF0aW8sIHJhdGlvKVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcbiAgfVxuICBnZXRQaXhlbENvdW50ICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl93aWR0aCAqIHRoaXMuX2hlaWdodFxuICB9XG4gIGdldEltYWdlRGF0YSAoKTogSW1hZ2VEYXRhIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodClcbiAgfVxuICByZW1vdmUgKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9jYW52YXMgJiYgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcylcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBWaWJyYW50ID0gcmVxdWlyZSgnLi9icm93c2VyJylcbmltcG9ydCBwaXBlbGluZSBmcm9tICcuL3BpcGVsaW5lJ1xuXG5WaWJyYW50LnVzZShwaXBlbGluZSlcblxuZXhwb3J0ID0gVmlicmFudFxuIiwiaW1wb3J0IE1NQ1EgZnJvbSAnQHZpYnJhbnQvcXVhbnRpemVyLW1tY3EnXG5pbXBvcnQgRGVmYXVsdEdlbmVyYXRvciBmcm9tICdAdmlicmFudC9nZW5lcmF0b3ItZGVmYXVsdCdcblxuaW1wb3J0IHsgQmFzaWNQaXBlbGluZSB9IGZyb20gJ0B2aWJyYW50L2NvcmUvbGliL3BpcGVsaW5lJ1xuXG5jb25zdCBwaXBlbGluZSA9IG5ldyBCYXNpY1BpcGVsaW5lKClcbiAgLmZpbHRlci5yZWdpc3RlcignZGVmYXVsdCcsIChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyLCBhOiBudW1iZXIpID0+XG4gICAgYSA+PSAxMjVcbiAgICAmJiAhKHIgPiAyNTAgJiYgZyA+IDI1MCAmJiBiID4gMjUwKVxuICApXG4gIC5xdWFudGl6ZXIucmVnaXN0ZXIoJ21tY3EnLCBNTUNRKVxuICAuZ2VuZXJhdG9yLnJlZ2lzdGVyKCdkZWZhdWx0JywgRGVmYXVsdEdlbmVyYXRvcilcblxuZXhwb3J0IGRlZmF1bHQgcGlwZWxpbmVcbiIsImltcG9ydCB7IFF1YW50aXplciwgUXVhbnRpemVyT3B0aW9ucyB9IGZyb20gJ0B2aWJyYW50L3F1YW50aXplcidcbmltcG9ydCB7XG4gIFBpeGVsc1xufSBmcm9tICdAdmlicmFudC9pbWFnZSdcbmltcG9ydCB7IEZpbHRlciwgU3dhdGNoIH0gZnJvbSAnQHZpYnJhbnQvY29sb3InXG5pbXBvcnQgVkJveCBmcm9tICcuL3Zib3gnXG5pbXBvcnQgUFF1ZXVlIGZyb20gJy4vcHF1ZXVlJ1xuXG5jb25zdCBmcmFjdEJ5UG9wdWxhdGlvbnMgPSAwLjc1XG5cbmZ1bmN0aW9uIF9zcGxpdEJveGVzIChwcTogUFF1ZXVlPFZCb3g+LCB0YXJnZXQ6IG51bWJlcik6IHZvaWQge1xuICBsZXQgbGFzdFNpemUgPSBwcS5zaXplKClcbiAgd2hpbGUgKHBxLnNpemUoKSA8IHRhcmdldCkge1xuICAgIGxldCB2Ym94ID0gcHEucG9wKClcblxuICAgIGlmICh2Ym94ICYmIHZib3guY291bnQoKSA+IDApIHtcbiAgICAgIGxldCBbdmJveDEsIHZib3gyXSA9IHZib3guc3BsaXQoKVxuXG4gICAgICBwcS5wdXNoKHZib3gxKVxuICAgICAgaWYgKHZib3gyICYmIHZib3gyLmNvdW50KCkgPiAwKSBwcS5wdXNoKHZib3gyKVxuXG4gICAgICAvLyBObyBtb3JlIG5ldyBib3hlcywgY29udmVyZ2VkXG4gICAgICBpZiAocHEuc2l6ZSgpID09PSBsYXN0U2l6ZSkge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFNpemUgPSBwcS5zaXplKClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgTU1DUSA9IChwaXhlbHM6IFBpeGVscywgb3B0czogUXVhbnRpemVyT3B0aW9ucyk6IEFycmF5PFN3YXRjaD4gPT4ge1xuICBpZiAocGl4ZWxzLmxlbmd0aCA9PT0gMCB8fCBvcHRzLmNvbG9yQ291bnQgPCAyIHx8IG9wdHMuY29sb3JDb3VudCA+IDI1Nikge1xuICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgTU1DUSBwYXJhbWV0ZXJzJylcbiAgfVxuXG4gIGxldCB2Ym94ID0gVkJveC5idWlsZChwaXhlbHMpXG4gIGxldCBjb2xvckNvdW50ID0gdmJveC5oaXN0b2dyYW0uY29sb3JDb3VudFxuICBsZXQgcHEgPSBuZXcgUFF1ZXVlPFZCb3g+KChhLCBiKSA9PiBhLmNvdW50KCkgLSBiLmNvdW50KCkpXG5cbiAgcHEucHVzaCh2Ym94KVxuXG4gIC8vIGZpcnN0IHNldCBvZiBjb2xvcnMsIHNvcnRlZCBieSBwb3B1bGF0aW9uXG4gIF9zcGxpdEJveGVzKHBxLCBmcmFjdEJ5UG9wdWxhdGlvbnMgKiBvcHRzLmNvbG9yQ291bnQpXG5cbiAgLy8gUmUtb3JkZXJcbiAgbGV0IHBxMiA9IG5ldyBQUXVldWU8VkJveD4oKGEsIGIpID0+IGEuY291bnQoKSAqIGEudm9sdW1lKCkgLSBiLmNvdW50KCkgKiBiLnZvbHVtZSgpKVxuICBwcTIuY29udGVudHMgPSBwcS5jb250ZW50c1xuXG4gIC8vIG5leHQgc2V0IC0gZ2VuZXJhdGUgdGhlIG1lZGlhbiBjdXRzIHVzaW5nIHRoZSAobnBpeCAqIHZvbCkgc29ydGluZy5cbiAgX3NwbGl0Qm94ZXMocHEyLCBvcHRzLmNvbG9yQ291bnQgLSBwcTIuc2l6ZSgpKVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgYWN0dWFsIGNvbG9yc1xuICByZXR1cm4gZ2VuZXJhdGVTd2F0Y2hlcyhwcTIpXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3dhdGNoZXMgKHBxOiBQUXVldWU8VkJveD4pIHtcbiAgbGV0IHN3YXRjaGVzOiBTd2F0Y2hbXSA9IFtdXG4gIHdoaWxlIChwcS5zaXplKCkpIHtcbiAgICBsZXQgdiA9IHBxLnBvcCgpIVxuICAgIGxldCBjb2xvciA9IHYuYXZnKClcbiAgICBsZXQgW3IsIGcsIGJdID0gY29sb3JcbiAgICBzd2F0Y2hlcy5wdXNoKG5ldyBTd2F0Y2goY29sb3IsIHYuY291bnQoKSkpXG4gIH1cbiAgcmV0dXJuIHN3YXRjaGVzXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1NQ1FcbiIsImltcG9ydCB7IFZlYzMsIEZpbHRlciB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuaW1wb3J0IHsgUGl4ZWxzIH0gZnJvbSAnQHZpYnJhbnQvaW1hZ2UnXG5pbXBvcnQgSGlzdG9ncmFtIGZyb20gJ0B2aWJyYW50L2ltYWdlL2xpYi9oaXN0b2dyYW0nXG5leHBvcnQgaW50ZXJmYWNlIERpbWVuc2lvbiB7XG4gIHIxOiBudW1iZXJcbiAgcjI6IG51bWJlclxuICBnMTogbnVtYmVyXG4gIGcyOiBudW1iZXJcbiAgYjE6IG51bWJlclxuICBiMjogbnVtYmVyXG4gIFtkOiBzdHJpbmddOiBudW1iZXJcbn1cblxuY29uc3QgU0lHQklUUyA9IDVcbmNvbnN0IFJTSElGVCA9IDggLSBTSUdCSVRTXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZCb3gge1xuICBzdGF0aWMgYnVpbGQgKHBpeGVsczogUGl4ZWxzKTogVkJveCB7XG4gICAgbGV0IGggPSBuZXcgSGlzdG9ncmFtKHBpeGVscywgeyBzaWdCaXRzOiBTSUdCSVRTIH0pXG4gICAgbGV0IHsgcm1pbiwgcm1heCwgZ21pbiwgZ21heCwgYm1pbiwgYm1heCB9ID0gaFxuICAgIHJldHVybiBuZXcgVkJveChybWluLCBybWF4LCBnbWluLCBnbWF4LCBibWluLCBibWF4LCBoKVxuICB9XG5cbiAgZGltZW5zaW9uOiBEaW1lbnNpb25cblxuICBwcml2YXRlIF92b2x1bWUgPSAtMVxuICBwcml2YXRlIF9hdmc6IFZlYzMgfCBudWxsXG4gIHByaXZhdGUgX2NvdW50ID0gLTFcblxuICBjb25zdHJ1Y3RvciAoXG4gICAgcjE6IG51bWJlciwgcjI6IG51bWJlcixcbiAgICBnMTogbnVtYmVyLCBnMjogbnVtYmVyLFxuICAgIGIxOiBudW1iZXIsIGIyOiBudW1iZXIsXG4gICAgcHVibGljIGhpc3RvZ3JhbTogSGlzdG9ncmFtXG4gICkge1xuICAgIC8vIE5PVEU6IGRpbWVuc2lvbiB3aWxsIGJlIG11dGF0ZWQgYnkgc3BsaXQgb3BlcmF0aW9uLlxuICAgIC8vICAgICAgIEl0IG11c3QgYmUgc3BlY2lmaWVkIGV4cGxpY2l0bHksIG5vdCBmcm9tIGhpc3RvZ3JhbVxuICAgIHRoaXMuZGltZW5zaW9uID0geyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH1cbiAgfVxuXG4gIGludmFsaWRhdGUgKCk6IHZvaWQge1xuICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMuX2NvdW50ID0gLTFcbiAgICB0aGlzLl9hdmcgPSBudWxsXG4gIH1cblxuICB2b2x1bWUgKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX3ZvbHVtZSA8IDApIHtcbiAgICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgICB0aGlzLl92b2x1bWUgPSAocjIgLSByMSArIDEpICogKGcyIC0gZzEgKyAxKSAqIChiMiAtIGIxICsgMSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZvbHVtZVxuICB9XG5cbiAgY291bnQgKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX2NvdW50IDwgMCkge1xuICAgICAgbGV0IHsgaGlzdCwgZ2V0Q29sb3JJbmRleCB9ID0gdGhpcy5oaXN0b2dyYW1cbiAgICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgICBsZXQgYyA9IDBcblxuICAgICAgZm9yIChsZXQgciA9IHIxOyByIDw9IHIyOyByKyspIHtcbiAgICAgICAgZm9yIChsZXQgZyA9IGcxOyBnIDw9IGcyOyBnKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBiID0gYjE7IGIgPD0gYjI7IGIrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKVxuICAgICAgICAgICAgYyArPSBoaXN0W2luZGV4XVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY291bnQgPSBjXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jb3VudFxuICB9XG5cbiAgY2xvbmUgKCk6IFZCb3gge1xuICAgIGxldCB7IGhpc3RvZ3JhbSB9ID0gdGhpc1xuICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgcmV0dXJuIG5ldyBWQm94KHIxLCByMiwgZzEsIGcyLCBiMSwgYjIsIGhpc3RvZ3JhbSlcbiAgfVxuXG4gIGF2ZyAoKTogVmVjMyB7XG4gICAgaWYgKCF0aGlzLl9hdmcpIHtcbiAgICAgIGxldCB7IGhpc3QsIGdldENvbG9ySW5kZXggfSA9IHRoaXMuaGlzdG9ncmFtXG4gICAgICBsZXQgeyByMSwgcjIsIGcxLCBnMiwgYjEsIGIyIH0gPSB0aGlzLmRpbWVuc2lvblxuICAgICAgbGV0IG50b3QgPSAwXG4gICAgICBsZXQgbXVsdCA9IDEgPDwgKDggLSBTSUdCSVRTKVxuICAgICAgbGV0IHJzdW06IG51bWJlclxuICAgICAgbGV0IGdzdW06IG51bWJlclxuICAgICAgbGV0IGJzdW06IG51bWJlclxuICAgICAgcnN1bSA9IGdzdW0gPSBic3VtID0gMFxuXG4gICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICBmb3IgKGxldCBnID0gZzE7IGcgPD0gZzI7IGcrKykge1xuICAgICAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBsZXQgaCA9IGhpc3RbaW5kZXhdXG4gICAgICAgICAgICBudG90ICs9IGhcbiAgICAgICAgICAgIHJzdW0gKz0gKGggKiAociArIDAuNSkgKiBtdWx0KVxuICAgICAgICAgICAgZ3N1bSArPSAoaCAqIChnICsgMC41KSAqIG11bHQpXG4gICAgICAgICAgICBic3VtICs9IChoICogKGIgKyAwLjUpICogbXVsdClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChudG90KSB7XG4gICAgICAgIHRoaXMuX2F2ZyA9IFtcbiAgICAgICAgICB+fihyc3VtIC8gbnRvdCksXG4gICAgICAgICAgfn4oZ3N1bSAvIG50b3QpLFxuICAgICAgICAgIH5+KGJzdW0gLyBudG90KVxuICAgICAgICBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hdmcgPSBbXG4gICAgICAgICAgfn4obXVsdCAqIChyMSArIHIyICsgMSkgLyAyKSxcbiAgICAgICAgICB+fihtdWx0ICogKGcxICsgZzIgKyAxKSAvIDIpLFxuICAgICAgICAgIH5+KG11bHQgKiAoYjEgKyBiMiArIDEpIC8gMilcbiAgICAgICAgXVxuICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hdmdcbiAgfVxuXG4gIGNvbnRhaW5zIChyZ2I6IFZlYzMpOiBib29sZWFuIHtcbiAgICBsZXQgW3IsIGcsIGJdID0gcmdiXG4gICAgbGV0IHsgcjEsIHIyLCBnMSwgZzIsIGIxLCBiMiB9ID0gdGhpcy5kaW1lbnNpb25cbiAgICByID4+PSBSU0hJRlRcbiAgICBnID4+PSBSU0hJRlRcbiAgICBiID4+PSBSU0hJRlRcblxuICAgIHJldHVybiByID49IHIxICYmIHIgPD0gcjJcbiAgICAgICYmIGcgPj0gZzEgJiYgZyA8PSBnMlxuICAgICAgJiYgYiA+PSBiMSAmJiBiIDw9IGIyXG4gIH1cblxuICBzcGxpdCAoKTogVkJveFtdIHtcbiAgICBsZXQgeyBoaXN0LCBnZXRDb2xvckluZGV4IH0gPSB0aGlzLmhpc3RvZ3JhbVxuICAgIGxldCB7IHIxLCByMiwgZzEsIGcyLCBiMSwgYjIgfSA9IHRoaXMuZGltZW5zaW9uXG4gICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudCgpXG4gICAgaWYgKCFjb3VudCkgcmV0dXJuIFtdXG4gICAgaWYgKGNvdW50ID09PSAxKSByZXR1cm4gW3RoaXMuY2xvbmUoKV1cbiAgICBsZXQgcncgPSByMiAtIHIxICsgMVxuICAgIGxldCBndyA9IGcyIC0gZzEgKyAxXG4gICAgbGV0IGJ3ID0gYjIgLSBiMSArIDFcblxuICAgIGxldCBtYXh3ID0gTWF0aC5tYXgocncsIGd3LCBidylcbiAgICBsZXQgYWNjU3VtOiBVaW50MzJBcnJheSB8IG51bGwgPSBudWxsXG4gICAgbGV0IHN1bTogbnVtYmVyXG4gICAgbGV0IHRvdGFsOiBudW1iZXJcbiAgICBzdW0gPSB0b3RhbCA9IDBcblxuICAgIGxldCBtYXhkOiAncicgfCAnZycgfCAnYicgfCBudWxsID0gbnVsbFxuXG4gICAgaWYgKG1heHcgPT09IHJ3KSB7XG4gICAgICBtYXhkID0gJ3InXG4gICAgICBhY2NTdW0gPSBuZXcgVWludDMyQXJyYXkocjIgKyAxKVxuICAgICAgZm9yIChsZXQgciA9IHIxOyByIDw9IHIyOyByKyspIHtcbiAgICAgICAgc3VtID0gMFxuICAgICAgICBmb3IgKGxldCBnID0gZzE7IGcgPD0gZzI7IGcrKykge1xuICAgICAgICAgIGZvciAobGV0IGIgPSBiMTsgYiA8PSBiMjsgYisrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgKz0gc3VtXG4gICAgICAgIGFjY1N1bVtyXSA9IHRvdGFsXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtYXh3ID09PSBndykge1xuICAgICAgbWF4ZCA9ICdnJ1xuICAgICAgYWNjU3VtID0gbmV3IFVpbnQzMkFycmF5KGcyICsgMSlcbiAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgIHN1bSA9IDBcbiAgICAgICAgZm9yIChsZXQgciA9IHIxOyByIDw9IHIyOyByKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBiID0gYjE7IGIgPD0gYjI7IGIrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gZ2V0Q29sb3JJbmRleChyLCBnLCBiKVxuICAgICAgICAgICAgc3VtICs9IGhpc3RbaW5kZXhdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvdGFsICs9IHN1bVxuICAgICAgICBhY2NTdW1bZ10gPSB0b3RhbFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhkID0gJ2InXG4gICAgICBhY2NTdW0gPSBuZXcgVWludDMyQXJyYXkoYjIgKyAxKVxuICAgICAgZm9yIChsZXQgYiA9IGIxOyBiIDw9IGIyOyBiKyspIHtcbiAgICAgICAgc3VtID0gMFxuICAgICAgICBmb3IgKGxldCByID0gcjE7IHIgPD0gcjI7IHIrKykge1xuICAgICAgICAgIGZvciAobGV0IGcgPSBnMTsgZyA8PSBnMjsgZysrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICAgICAgICBzdW0gKz0gaGlzdFtpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG90YWwgKz0gc3VtXG4gICAgICAgIGFjY1N1bVtiXSA9IHRvdGFsXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHNwbGl0UG9pbnQgPSAtMVxuICAgIGxldCByZXZlcnNlU3VtID0gbmV3IFVpbnQzMkFycmF5KGFjY1N1bS5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2NTdW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBkID0gYWNjU3VtW2ldXG4gICAgICBpZiAoc3BsaXRQb2ludCA8IDAgJiYgZCA+IHRvdGFsIC8gMikgc3BsaXRQb2ludCA9IGlcbiAgICAgIHJldmVyc2VTdW1baV0gPSB0b3RhbCAtIGRcbiAgICB9XG5cbiAgICBsZXQgdmJveCA9IHRoaXNcblxuICAgIGZ1bmN0aW9uIGRvQ3V0IChkOiBzdHJpbmcpOiBWQm94W10ge1xuICAgICAgbGV0IGRpbTEgPSBkICsgJzEnXG4gICAgICBsZXQgZGltMiA9IGQgKyAnMidcbiAgICAgIGxldCBkMSA9IHZib3guZGltZW5zaW9uW2RpbTFdXG4gICAgICBsZXQgZDIgPSB2Ym94LmRpbWVuc2lvbltkaW0yXVxuICAgICAgbGV0IHZib3gxID0gdmJveC5jbG9uZSgpXG4gICAgICBsZXQgdmJveDIgPSB2Ym94LmNsb25lKClcbiAgICAgIGxldCBsZWZ0ID0gc3BsaXRQb2ludCAtIGQxXG4gICAgICBsZXQgcmlnaHQgPSBkMiAtIHNwbGl0UG9pbnRcbiAgICAgIGlmIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGQyID0gTWF0aC5taW4oZDIgLSAxLCB+fihzcGxpdFBvaW50ICsgcmlnaHQgLyAyKSlcbiAgICAgICAgZDIgPSBNYXRoLm1heCgwLCBkMilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQyID0gTWF0aC5tYXgoZDEsIH5+KHNwbGl0UG9pbnQgLSAxIC0gbGVmdCAvIDIpKVxuICAgICAgICBkMiA9IE1hdGgubWluKHZib3guZGltZW5zaW9uW2RpbTJdLCBkMilcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCFhY2NTdW0hW2QyXSkgZDIrK1xuXG4gICAgICBsZXQgYzIgPSByZXZlcnNlU3VtW2QyXVxuICAgICAgd2hpbGUgKCFjMiAmJiBhY2NTdW0hW2QyIC0gMV0pIGMyID0gcmV2ZXJzZVN1bVstLWQyXVxuXG4gICAgICB2Ym94MS5kaW1lbnNpb25bZGltMl0gPSBkMlxuICAgICAgdmJveDIuZGltZW5zaW9uW2RpbTFdID0gZDIgKyAxXG5cbiAgICAgIHJldHVybiBbdmJveDEsIHZib3gyXVxuICAgIH1cblxuICAgIHJldHVybiBkb0N1dChtYXhkKVxuICB9XG5cbn1cbiIsImltcG9ydCB7IFBpeGVscyB9IGZyb20gJy4vaW5kZXgnXG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9ncmFtT3B0aW9ucyB7XG4gIHNpZ0JpdHM6IG51bWJlclxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIaXN0b2dyYW0ge1xuICBibWluOiBudW1iZXJcbiAgYm1heDogbnVtYmVyXG4gIGdtaW46IG51bWJlclxuICBnbWF4OiBudW1iZXJcbiAgcm1pbjogbnVtYmVyXG4gIHJtYXg6IG51bWJlclxuICBoaXN0OiBVaW50MzJBcnJheVxuICBwcml2YXRlIF9jb2xvckNvdW50OiBudW1iZXJcbiAgZ2V0IGNvbG9yQ291bnQgKCkgeyByZXR1cm4gdGhpcy5fY29sb3JDb3VudCB9XG4gIGdldENvbG9ySW5kZXg6IChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXJcbiAgY29uc3RydWN0b3IgKHB1YmxpYyBwaXhlbHM6IFBpeGVscywgcHVibGljIG9wdHM6IEhpc3RvZ3JhbU9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHNpZ0JpdHMgfSA9IG9wdHNcbiAgICBjb25zdCBnZXRDb2xvckluZGV4ID0gKHI6IG51bWJlciwgZzogbnVtYmVyLCBiOiBudW1iZXIpID0+XG4gICAgICAociA8PCAoMiAqIHNpZ0JpdHMpKSArIChnIDw8IHNpZ0JpdHMpICsgYlxuXG4gICAgdGhpcy5nZXRDb2xvckluZGV4ID0gZ2V0Q29sb3JJbmRleFxuXG4gICAgY29uc3QgcnNoaWZ0ID0gOCAtIHNpZ0JpdHNcbiAgICBjb25zdCBobiA9IDEgPDwgKDMgKiBzaWdCaXRzKVxuICAgIGxldCBoaXN0ID0gbmV3IFVpbnQzMkFycmF5KGhuKVxuICAgIGxldCBybWF4OiBudW1iZXJcbiAgICBsZXQgcm1pbjogbnVtYmVyXG4gICAgbGV0IGdtYXg6IG51bWJlclxuICAgIGxldCBnbWluOiBudW1iZXJcbiAgICBsZXQgYm1heDogbnVtYmVyXG4gICAgbGV0IGJtaW46IG51bWJlclxuICAgIGxldCByOiBudW1iZXJcbiAgICBsZXQgZzogbnVtYmVyXG4gICAgbGV0IGI6IG51bWJlclxuICAgIGxldCBhOiBudW1iZXJcbiAgICBybWF4ID0gZ21heCA9IGJtYXggPSAwXG4gICAgcm1pbiA9IGdtaW4gPSBibWluID0gTnVtYmVyLk1BWF9WQUxVRVxuICAgIGxldCBuID0gcGl4ZWxzLmxlbmd0aCAvIDRcbiAgICBsZXQgaSA9IDBcblxuICAgIHdoaWxlIChpIDwgbikge1xuXG4gICAgICBsZXQgb2Zmc2V0ID0gaSAqIDRcbiAgICAgIGkrK1xuICAgICAgciA9IHBpeGVsc1tvZmZzZXQgKyAwXVxuICAgICAgZyA9IHBpeGVsc1tvZmZzZXQgKyAxXVxuICAgICAgYiA9IHBpeGVsc1tvZmZzZXQgKyAyXVxuICAgICAgYSA9IHBpeGVsc1tvZmZzZXQgKyAzXVxuXG4gICAgICAvLyBJZ25vcmVkIHBpeGVscycgYWxwaGEgaXMgbWFya2VkIGFzIDAgaW4gZmlsdGVyaW5nIHN0YWdlXG4gICAgICBpZiAoYSA9PT0gMCkgY29udGludWVcblxuICAgICAgciA9IHIgPj4gcnNoaWZ0XG4gICAgICBnID0gZyA+PiByc2hpZnRcbiAgICAgIGIgPSBiID4+IHJzaGlmdFxuXG4gICAgICBsZXQgaW5kZXggPSBnZXRDb2xvckluZGV4KHIsIGcsIGIpXG4gICAgICBoaXN0W2luZGV4XSArPSAxXG5cbiAgICAgIGlmIChyID4gcm1heCkgcm1heCA9IHJcbiAgICAgIGlmIChyIDwgcm1pbikgcm1pbiA9IHJcbiAgICAgIGlmIChnID4gZ21heCkgZ21heCA9IGdcbiAgICAgIGlmIChnIDwgZ21pbikgZ21pbiA9IGdcbiAgICAgIGlmIChiID4gYm1heCkgYm1heCA9IGJcbiAgICAgIGlmIChiIDwgYm1pbikgYm1pbiA9IGJcbiAgICB9XG4gICAgdGhpcy5fY29sb3JDb3VudCA9IGhpc3QucmVkdWNlKCh0b3RhbCwgYykgPT4gYyA+IDAgPyB0b3RhbCArIDEgOiB0b3RhbCwgMClcbiAgICB0aGlzLmhpc3QgPSBoaXN0XG4gICAgdGhpcy5ybWF4ID0gcm1heFxuICAgIHRoaXMucm1pbiA9IHJtaW5cbiAgICB0aGlzLmdtYXggPSBnbWF4XG4gICAgdGhpcy5nbWluID0gZ21pblxuICAgIHRoaXMuYm1heCA9IGJtYXhcbiAgICB0aGlzLmJtaW4gPSBibWluXG4gIH1cbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgUFF1ZXVlQ29tcGFyYXRvcjxUPiB7XG4gIChhOiBULCBiOiBUKTogbnVtYmVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBRdWV1ZTxUPiB7XG4gIGNvbnRlbnRzOiBUW11cbiAgcHJpdmF0ZSBfc29ydGVkOiBib29sZWFuXG4gIHByaXZhdGUgX2NvbXBhcmF0b3I6IFBRdWV1ZUNvbXBhcmF0b3I8VD5cbiAgcHJpdmF0ZSBfc29ydCAoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICAgIHRoaXMuY29udGVudHMuc29ydCh0aGlzLl9jb21wYXJhdG9yKVxuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChjb21wYXJhdG9yOiBQUXVldWVDb21wYXJhdG9yPFQ+KSB7XG4gICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3JcbiAgICB0aGlzLmNvbnRlbnRzID0gW11cbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZVxuICB9XG5cbiAgcHVzaCAoaXRlbTogVCk6IHZvaWQge1xuICAgIHRoaXMuY29udGVudHMucHVzaChpdGVtKVxuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlXG4gIH1cblxuICBwZWVrIChpbmRleD86IG51bWJlcik6IFQge1xuICAgIHRoaXMuX3NvcnQoKVxuICAgIGluZGV4ID0gdHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyA/IGluZGV4IDogdGhpcy5jb250ZW50cy5sZW5ndGggLSAxXG4gICAgcmV0dXJuIHRoaXMuY29udGVudHNbaW5kZXhdXG4gIH1cblxuICBwb3AgKCkge1xuICAgIHRoaXMuX3NvcnQoKVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLnBvcCgpXG4gIH1cblxuICBzaXplICgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aFxuICB9XG5cbiAgbWFwPFU+IChtYXBwZXI6IChpdGVtOiBULCBpbmRleDogbnVtYmVyKSA9PiBhbnkpOiBVW10ge1xuICAgIHRoaXMuX3NvcnQoKVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLm1hcChtYXBwZXIpXG4gIH1cbn1cbiIsImltcG9ydCB7IFN3YXRjaCwgUGFsZXR0ZSB9IGZyb20gJ0B2aWJyYW50L2NvbG9yJ1xuaW1wb3J0IHsgR2VuZXJhdG9yIH0gZnJvbSAnQHZpYnJhbnQvZ2VuZXJhdG9yJ1xuaW1wb3J0IHsgaHNsVG9SZ2IgfSBmcm9tICdAdmlicmFudC9jb2xvci9saWIvY29udmVydGVyJ1xuXG5pbnRlcmZhY2UgRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMge1xuICB0YXJnZXREYXJrTHVtYTogbnVtYmVyLFxuICBtYXhEYXJrTHVtYTogbnVtYmVyLFxuICBtaW5MaWdodEx1bWE6IG51bWJlcixcbiAgdGFyZ2V0TGlnaHRMdW1hOiBudW1iZXIsXG4gIG1pbk5vcm1hbEx1bWE6IG51bWJlcixcbiAgdGFyZ2V0Tm9ybWFsTHVtYTogbnVtYmVyLFxuICBtYXhOb3JtYWxMdW1hOiBudW1iZXIsXG4gIHRhcmdldE11dGVzU2F0dXJhdGlvbjogbnVtYmVyLFxuICBtYXhNdXRlc1NhdHVyYXRpb246IG51bWJlcixcbiAgdGFyZ2V0VmlicmFudFNhdHVyYXRpb246IG51bWJlcixcbiAgbWluVmlicmFudFNhdHVyYXRpb246IG51bWJlcixcbiAgd2VpZ2h0U2F0dXJhdGlvbjogbnVtYmVyLFxuICB3ZWlnaHRMdW1hOiBudW1iZXIsXG4gIHdlaWdodFBvcHVsYXRpb246IG51bWJlclxufVxuXG5jb25zdCBEZWZhdWx0T3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMgPSB7XG4gIHRhcmdldERhcmtMdW1hOiAwLjI2LFxuICBtYXhEYXJrTHVtYTogMC40NSxcbiAgbWluTGlnaHRMdW1hOiAwLjU1LFxuICB0YXJnZXRMaWdodEx1bWE6IDAuNzQsXG4gIG1pbk5vcm1hbEx1bWE6IDAuMyxcbiAgdGFyZ2V0Tm9ybWFsTHVtYTogMC41LFxuICBtYXhOb3JtYWxMdW1hOiAwLjcsXG4gIHRhcmdldE11dGVzU2F0dXJhdGlvbjogMC4zLFxuICBtYXhNdXRlc1NhdHVyYXRpb246IDAuNCxcbiAgdGFyZ2V0VmlicmFudFNhdHVyYXRpb246IDEuMCxcbiAgbWluVmlicmFudFNhdHVyYXRpb246IDAuMzUsXG4gIHdlaWdodFNhdHVyYXRpb246IDMsXG4gIHdlaWdodEx1bWE6IDYuNSxcbiAgd2VpZ2h0UG9wdWxhdGlvbjogMC41XG59XG5cbmZ1bmN0aW9uIF9maW5kTWF4UG9wdWxhdGlvbiAoc3dhdGNoZXM6IEFycmF5PFN3YXRjaD4pOiBudW1iZXIge1xuICBsZXQgcCA9IDBcblxuICBzd2F0Y2hlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgcCA9IE1hdGgubWF4KHAsIHMucG9wdWxhdGlvbilcbiAgfSlcblxuICByZXR1cm4gcFxufVxuXG5mdW5jdGlvbiBfaXNBbHJlYWR5U2VsZWN0ZWQgKHBhbGV0dGU6IFBhbGV0dGUsIHM6IFN3YXRjaCk6IGJvb2xlYW4ge1xuICByZXR1cm4gcGFsZXR0ZS5WaWJyYW50ID09PSBzXG4gICAgfHwgcGFsZXR0ZS5EYXJrVmlicmFudCA9PT0gc1xuICAgIHx8IHBhbGV0dGUuTGlnaHRWaWJyYW50ID09PSBzXG4gICAgfHwgcGFsZXR0ZS5NdXRlZCA9PT0gc1xuICAgIHx8IHBhbGV0dGUuRGFya011dGVkID09PSBzXG4gICAgfHwgcGFsZXR0ZS5MaWdodE11dGVkID09PSBzXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDb21wYXJpc29uVmFsdWUgKFxuICBzYXR1cmF0aW9uOiBudW1iZXIsIHRhcmdldFNhdHVyYXRpb246IG51bWJlcixcbiAgbHVtYTogbnVtYmVyLCB0YXJnZXRMdW1hOiBudW1iZXIsXG4gIHBvcHVsYXRpb246IG51bWJlciwgbWF4UG9wdWxhdGlvbjogbnVtYmVyLCBvcHRzOiBEZWZhdWx0R2VuZXJhdG9yT3B0aW9ucyk6IG51bWJlciB7XG5cbiAgZnVuY3Rpb24gd2VpZ2h0ZWRNZWFuICguLi52YWx1ZXM6IG51bWJlcltdKSB7XG4gICAgbGV0IHN1bSA9IDBcbiAgICBsZXQgd2VpZ2h0U3VtID0gMFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbaV1cbiAgICAgIGxldCB3ZWlnaHQgPSB2YWx1ZXNbaSArIDFdXG4gICAgICBzdW0gKz0gdmFsdWUgKiB3ZWlnaHRcbiAgICAgIHdlaWdodFN1bSArPSB3ZWlnaHRcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtIC8gd2VpZ2h0U3VtXG4gIH1cblxuICBmdW5jdGlvbiBpbnZlcnREaWZmICh2YWx1ZTogbnVtYmVyLCB0YXJnZXRWYWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gMSAtIE1hdGguYWJzKHZhbHVlIC0gdGFyZ2V0VmFsdWUpXG4gIH1cblxuICByZXR1cm4gd2VpZ2h0ZWRNZWFuKFxuICAgIGludmVydERpZmYoc2F0dXJhdGlvbiwgdGFyZ2V0U2F0dXJhdGlvbiksIG9wdHMud2VpZ2h0U2F0dXJhdGlvbixcbiAgICBpbnZlcnREaWZmKGx1bWEsIHRhcmdldEx1bWEpLCBvcHRzLndlaWdodEx1bWEsXG4gICAgcG9wdWxhdGlvbiAvIG1heFBvcHVsYXRpb24sIG9wdHMud2VpZ2h0UG9wdWxhdGlvblxuICApXG5cbn1cblxuZnVuY3Rpb24gX2ZpbmRDb2xvclZhcmlhdGlvbiAocGFsZXR0ZTogUGFsZXR0ZSwgc3dhdGNoZXM6IEFycmF5PFN3YXRjaD4sIG1heFBvcHVsYXRpb246IG51bWJlcixcbiAgdGFyZ2V0THVtYTogbnVtYmVyLFxuICBtaW5MdW1hOiBudW1iZXIsXG4gIG1heEx1bWE6IG51bWJlcixcbiAgdGFyZ2V0U2F0dXJhdGlvbjogbnVtYmVyLFxuICBtaW5TYXR1cmF0aW9uOiBudW1iZXIsXG4gIG1heFNhdHVyYXRpb246IG51bWJlcixcbiAgb3B0czogRGVmYXVsdEdlbmVyYXRvck9wdGlvbnMpOiBTd2F0Y2ggfCBudWxsIHtcblxuICBsZXQgbWF4OiBTd2F0Y2ggfCBudWxsID0gbnVsbFxuICBsZXQgbWF4VmFsdWUgPSAwXG5cbiAgc3dhdGNoZXMuZm9yRWFjaCgoc3dhdGNoKSA9PiB7XG4gICAgbGV0IFssIHMsIGxdID0gc3dhdGNoLmhzbFxuXG4gICAgaWYgKHMgPj0gbWluU2F0dXJhdGlvbiAmJiBzIDw9IG1heFNhdHVyYXRpb25cbiAgICAgICYmIGwgPj0gbWluTHVtYSAmJiBsIDw9IG1heEx1bWFcbiAgICAgICYmICFfaXNBbHJlYWR5U2VsZWN0ZWQocGFsZXR0ZSwgc3dhdGNoKVxuICAgICkge1xuICAgICAgbGV0IHZhbHVlID0gX2NyZWF0ZUNvbXBhcmlzb25WYWx1ZShzLCB0YXJnZXRTYXR1cmF0aW9uLCBsLCB0YXJnZXRMdW1hLCBzd2F0Y2gucG9wdWxhdGlvbiwgbWF4UG9wdWxhdGlvbiwgb3B0cylcblxuICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCB2YWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgIG1heCA9IHN3YXRjaFxuICAgICAgICBtYXhWYWx1ZSA9IHZhbHVlXG4gICAgICB9XG5cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIG1heFxufVxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVWYXJpYXRpb25Db2xvcnMgKHN3YXRjaGVzOiBBcnJheTxTd2F0Y2g+LCBtYXhQb3B1bGF0aW9uOiBudW1iZXIsIG9wdHM6IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zKTogUGFsZXR0ZSB7XG4gIGxldCBwYWxldHRlOiBQYWxldHRlID0ge1xuICAgIFZpYnJhbnQ6IG51bGwsXG4gICAgRGFya1ZpYnJhbnQ6IG51bGwsXG4gICAgTGlnaHRWaWJyYW50OiBudWxsLFxuICAgIE11dGVkOiBudWxsLFxuICAgIERhcmtNdXRlZDogbnVsbCxcbiAgICBMaWdodE11dGVkOiBudWxsXG4gIH1cbiAgLy8gbVZpYnJhbnRTd2F0Y2ggPSBmaW5kQ29sb3IoVEFSR0VUX05PUk1BTF9MVU1BLCBNSU5fTk9STUFMX0xVTUEsIE1BWF9OT1JNQUxfTFVNQSxcbiAgLy8gICAgIFRBUkdFVF9WSUJSQU5UX1NBVFVSQVRJT04sIE1JTl9WSUJSQU5UX1NBVFVSQVRJT04sIDFmKVxuICBwYWxldHRlLlZpYnJhbnQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0Tm9ybWFsTHVtYSxcbiAgICBvcHRzLm1pbk5vcm1hbEx1bWEsXG4gICAgb3B0cy5tYXhOb3JtYWxMdW1hLFxuICAgIG9wdHMudGFyZ2V0VmlicmFudFNhdHVyYXRpb24sXG4gICAgb3B0cy5taW5WaWJyYW50U2F0dXJhdGlvbixcbiAgICAxLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtTGlnaHRWaWJyYW50U3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9MSUdIVF9MVU1BLCBNSU5fTElHSFRfTFVNQSwgMWYsXG4gIC8vICAgICBUQVJHRVRfVklCUkFOVF9TQVRVUkFUSU9OLCBNSU5fVklCUkFOVF9TQVRVUkFUSU9OLCAxZilcbiAgcGFsZXR0ZS5MaWdodFZpYnJhbnQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0TGlnaHRMdW1hLFxuICAgIG9wdHMubWluTGlnaHRMdW1hLFxuICAgIDEsXG4gICAgb3B0cy50YXJnZXRWaWJyYW50U2F0dXJhdGlvbixcbiAgICBvcHRzLm1pblZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIDEsXG4gICAgb3B0c1xuICApXG4gIC8vIG1EYXJrVmlicmFudFN3YXRjaCA9IGZpbmRDb2xvcihUQVJHRVRfREFSS19MVU1BLCAwZiwgTUFYX0RBUktfTFVNQSxcbiAgLy8gICAgIFRBUkdFVF9WSUJSQU5UX1NBVFVSQVRJT04sIE1JTl9WSUJSQU5UX1NBVFVSQVRJT04sIDFmKVxuICBwYWxldHRlLkRhcmtWaWJyYW50ID0gX2ZpbmRDb2xvclZhcmlhdGlvbihwYWxldHRlLCBzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbixcbiAgICBvcHRzLnRhcmdldERhcmtMdW1hLFxuICAgIDAsXG4gICAgb3B0cy5tYXhEYXJrTHVtYSxcbiAgICBvcHRzLnRhcmdldFZpYnJhbnRTYXR1cmF0aW9uLFxuICAgIG9wdHMubWluVmlicmFudFNhdHVyYXRpb24sXG4gICAgMSxcbiAgICBvcHRzXG4gIClcbiAgLy8gbU11dGVkU3dhdGNoID0gZmluZENvbG9yKFRBUkdFVF9OT1JNQUxfTFVNQSwgTUlOX05PUk1BTF9MVU1BLCBNQVhfTk9STUFMX0xVTUEsXG4gIC8vICAgICBUQVJHRVRfTVVURURfU0FUVVJBVElPTiwgMGYsIE1BWF9NVVRFRF9TQVRVUkFUSU9OKVxuICBwYWxldHRlLk11dGVkID0gX2ZpbmRDb2xvclZhcmlhdGlvbihwYWxldHRlLCBzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbixcbiAgICBvcHRzLnRhcmdldE5vcm1hbEx1bWEsXG4gICAgb3B0cy5taW5Ob3JtYWxMdW1hLFxuICAgIG9wdHMubWF4Tm9ybWFsTHVtYSxcbiAgICBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvbixcbiAgICAwLFxuICAgIG9wdHMubWF4TXV0ZXNTYXR1cmF0aW9uLFxuICAgIG9wdHNcbiAgKVxuICAvLyBtTGlnaHRNdXRlZENvbG9yID0gZmluZENvbG9yKFRBUkdFVF9MSUdIVF9MVU1BLCBNSU5fTElHSFRfTFVNQSwgMWYsXG4gIC8vICAgICBUQVJHRVRfTVVURURfU0FUVVJBVElPTiwgMGYsIE1BWF9NVVRFRF9TQVRVUkFUSU9OKVxuICBwYWxldHRlLkxpZ2h0TXV0ZWQgPSBfZmluZENvbG9yVmFyaWF0aW9uKHBhbGV0dGUsIHN3YXRjaGVzLCBtYXhQb3B1bGF0aW9uLFxuICAgIG9wdHMudGFyZ2V0TGlnaHRMdW1hLFxuICAgIG9wdHMubWluTGlnaHRMdW1hLFxuICAgIDEsXG4gICAgb3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb24sXG4gICAgMCxcbiAgICBvcHRzLm1heE11dGVzU2F0dXJhdGlvbixcbiAgICBvcHRzXG4gIClcbiAgLy8gbURhcmtNdXRlZFN3YXRjaCA9IGZpbmRDb2xvcihUQVJHRVRfREFSS19MVU1BLCAwZiwgTUFYX0RBUktfTFVNQSxcbiAgLy8gICAgIFRBUkdFVF9NVVRFRF9TQVRVUkFUSU9OLCAwZiwgTUFYX01VVEVEX1NBVFVSQVRJT04pXG4gIHBhbGV0dGUuRGFya011dGVkID0gX2ZpbmRDb2xvclZhcmlhdGlvbihwYWxldHRlLCBzd2F0Y2hlcywgbWF4UG9wdWxhdGlvbixcbiAgICBvcHRzLnRhcmdldERhcmtMdW1hLFxuICAgIDAsXG4gICAgb3B0cy5tYXhEYXJrTHVtYSxcbiAgICBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvbixcbiAgICAwLFxuICAgIG9wdHMubWF4TXV0ZXNTYXR1cmF0aW9uLFxuICAgIG9wdHNcbiAgKVxuICByZXR1cm4gcGFsZXR0ZVxufVxuXG5mdW5jdGlvbiBfZ2VuZXJhdGVFbXB0eVN3YXRjaGVzIChwYWxldHRlOiBQYWxldHRlLCBtYXhQb3B1bGF0aW9uOiBudW1iZXIsIG9wdHM6IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zKTogdm9pZCB7XG4gIGlmICghcGFsZXR0ZS5WaWJyYW50ICYmICFwYWxldHRlLkRhcmtWaWJyYW50ICYmICFwYWxldHRlLkxpZ2h0VmlicmFudCkge1xuICAgIGlmICghcGFsZXR0ZS5EYXJrVmlicmFudCAmJiBwYWxldHRlLkRhcmtNdXRlZCkge1xuICAgICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuRGFya011dGVkLmhzbFxuICAgICAgbCA9IG9wdHMudGFyZ2V0RGFya0x1bWFcbiAgICAgIHBhbGV0dGUuRGFya1ZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICAgIH1cbiAgICBpZiAoIXBhbGV0dGUuTGlnaHRWaWJyYW50ICYmIHBhbGV0dGUuTGlnaHRNdXRlZCkge1xuICAgICAgbGV0IFtoLCBzLCBsXSA9IHBhbGV0dGUuTGlnaHRNdXRlZC5oc2xcbiAgICAgIGwgPSBvcHRzLnRhcmdldERhcmtMdW1hXG4gICAgICBwYWxldHRlLkRhcmtWaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgICB9XG4gIH1cbiAgaWYgKCFwYWxldHRlLlZpYnJhbnQgJiYgcGFsZXR0ZS5EYXJrVmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkRhcmtWaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldE5vcm1hbEx1bWFcbiAgICBwYWxldHRlLlZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9IGVsc2UgaWYgKCFwYWxldHRlLlZpYnJhbnQgJiYgcGFsZXR0ZS5MaWdodFZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5MaWdodFZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0Tm9ybWFsTHVtYVxuICAgIHBhbGV0dGUuVmlicmFudCA9IG5ldyBTd2F0Y2goaHNsVG9SZ2IoaCwgcywgbCksIDApXG4gIH1cbiAgaWYgKCFwYWxldHRlLkRhcmtWaWJyYW50ICYmIHBhbGV0dGUuVmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLlZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0RGFya0x1bWFcbiAgICBwYWxldHRlLkRhcmtWaWJyYW50ID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxuICBpZiAoIXBhbGV0dGUuTGlnaHRWaWJyYW50ICYmIHBhbGV0dGUuVmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLlZpYnJhbnQuaHNsXG4gICAgbCA9IG9wdHMudGFyZ2V0TGlnaHRMdW1hXG4gICAgcGFsZXR0ZS5MaWdodFZpYnJhbnQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5NdXRlZCAmJiBwYWxldHRlLlZpYnJhbnQpIHtcbiAgICBsZXQgW2gsIHMsIGxdID0gcGFsZXR0ZS5WaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvblxuICAgIHBhbGV0dGUuTXV0ZWQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG4gIGlmICghcGFsZXR0ZS5EYXJrTXV0ZWQgJiYgcGFsZXR0ZS5EYXJrVmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkRhcmtWaWJyYW50LmhzbFxuICAgIGwgPSBvcHRzLnRhcmdldE11dGVzU2F0dXJhdGlvblxuICAgIHBhbGV0dGUuRGFya011dGVkID0gbmV3IFN3YXRjaChoc2xUb1JnYihoLCBzLCBsKSwgMClcbiAgfVxuICBpZiAoIXBhbGV0dGUuTGlnaHRNdXRlZCAmJiBwYWxldHRlLkxpZ2h0VmlicmFudCkge1xuICAgIGxldCBbaCwgcywgbF0gPSBwYWxldHRlLkxpZ2h0VmlicmFudC5oc2xcbiAgICBsID0gb3B0cy50YXJnZXRNdXRlc1NhdHVyYXRpb25cbiAgICBwYWxldHRlLkxpZ2h0TXV0ZWQgPSBuZXcgU3dhdGNoKGhzbFRvUmdiKGgsIHMsIGwpLCAwKVxuICB9XG59XG5cbmNvbnN0IERlZmF1bHRHZW5lcmF0b3I6IEdlbmVyYXRvciA9IChzd2F0Y2hlczogQXJyYXk8U3dhdGNoPiwgb3B0cz86IERlZmF1bHRHZW5lcmF0b3JPcHRpb25zKTogUGFsZXR0ZSA9PiB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBEZWZhdWx0T3B0cywgb3B0cylcbiAgbGV0IG1heFBvcHVsYXRpb24gPSBfZmluZE1heFBvcHVsYXRpb24oc3dhdGNoZXMpXG5cbiAgbGV0IHBhbGV0dGUgPSBfZ2VuZXJhdGVWYXJpYXRpb25Db2xvcnMoc3dhdGNoZXMsIG1heFBvcHVsYXRpb24sIG9wdHMpXG4gIF9nZW5lcmF0ZUVtcHR5U3dhdGNoZXMocGFsZXR0ZSwgbWF4UG9wdWxhdGlvbiwgb3B0cylcblxuICByZXR1cm4gcGFsZXR0ZVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWZhdWx0R2VuZXJhdG9yXG4iLCJpbXBvcnQgeyBJbWFnZURhdGEsIGFwcGx5RmlsdGVycyB9IGZyb20gJ0B2aWJyYW50L2ltYWdlJ1xuaW1wb3J0IHsgUXVhbnRpemVyIH0gZnJvbSAnQHZpYnJhbnQvcXVhbnRpemVyJ1xuaW1wb3J0IHsgR2VuZXJhdG9yIH0gZnJvbSAnQHZpYnJhbnQvZ2VuZXJhdG9yJ1xuaW1wb3J0IHsgUGFsZXR0ZSwgU3dhdGNoLCBGaWx0ZXIgfSBmcm9tICdAdmlicmFudC9jb2xvcidcblxuZXhwb3J0IGNsYXNzIFN0YWdlPFQ+IHtcbiAgcHJpdmF0ZSBfbWFwOiB7IFtuYW1lOiBzdHJpbmddOiBUIH0gPSB7fVxuICBjb25zdHJ1Y3RvciAocHJvdGVjdGVkIHBpcGVsaW5lOiBCYXNpY1BpcGVsaW5lKSB7IH1cbiAgbmFtZXMgKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9tYXApXG4gIH1cbiAgaGFzIChuYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gISF0aGlzLl9tYXBbbmFtZV1cbiAgfVxuICBnZXQgKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9tYXBbbmFtZV1cbiAgfVxuICByZWdpc3RlciAobmFtZTogc3RyaW5nLCBzdGFnZUZuOiBUKSB7XG4gICAgdGhpcy5fbWFwW25hbWVdID0gc3RhZ2VGblxuICAgIHJldHVybiB0aGlzLnBpcGVsaW5lXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzUmVzdWx0IHtcbiAgY29sb3JzOiBTd2F0Y2hbXVxuICBwYWxldHRlczogeyBbbmFtZTogc3RyaW5nXTogUGFsZXR0ZSB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhZ2VPcHRpb25zIHtcbiAgbmFtZTogc3RyaW5nXG4gIG9wdGlvbnM/OiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9jZXNzT3B0aW9ucyB7XG4gIGZpbHRlcnM6IHN0cmluZ1tdXG4gIHF1YW50aXplcjogc3RyaW5nIHwgU3RhZ2VPcHRpb25zXG4gIGdlbmVyYXRvcnM6IChzdHJpbmcgfCBTdGFnZU9wdGlvbnMpW11cbn1cblxuaW50ZXJmYWNlIFN0YWdlVGFzazxRPiB7XG4gIG5hbWU6IHN0cmluZ1xuICBmbjogUVxuICBvcHRpb25zPzogYW55XG59XG5cbmludGVyZmFjZSBQcm9jZXNzVGFza3Mge1xuICBmaWx0ZXJzOiBTdGFnZVRhc2s8RmlsdGVyPltdXG4gIHF1YW50aXplcjogU3RhZ2VUYXNrPFF1YW50aXplcj5cbiAgZ2VuZXJhdG9yczogU3RhZ2VUYXNrPEdlbmVyYXRvcj5bXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBpcGVsaW5lIHtcbiAgLy8gcXVhbnRpemVyOiBTdGFnZTxRdWFudGl6ZXI+XG4gIC8vIGdlbmVyYXRvcjogU3RhZ2U8R2VuZXJhdG9yPlxuICBwcm9jZXNzIChpbWFnZURhdGE6IEltYWdlRGF0YSwgb3B0czogUHJvY2Vzc09wdGlvbnMpOiBQcm9taXNlPFByb2Nlc3NSZXN1bHQ+XG59XG5cbmV4cG9ydCBjbGFzcyBCYXNpY1BpcGVsaW5lIGltcGxlbWVudHMgUGlwZWxpbmUge1xuICBwcml2YXRlIF9idWlsZFByb2Nlc3NUYXNrcyAoe1xuICAgIGZpbHRlcnMsXG4gICAgcXVhbnRpemVyLFxuICAgIGdlbmVyYXRvcnNcbiAgfTogUHJvY2Vzc09wdGlvbnMpOiBQcm9jZXNzVGFza3Mge1xuICAgIC8vIFN1cHBvcnQgd2lsZGNhcmQgZm9yIGdlbmVyYXRvcnNcbiAgICBpZiAoZ2VuZXJhdG9ycy5sZW5ndGggPT09IDEgJiYgZ2VuZXJhdG9yc1swXSA9PT0gJyonKSB7XG4gICAgICBnZW5lcmF0b3JzID0gdGhpcy5nZW5lcmF0b3IubmFtZXMoKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyczogZmlsdGVycy5tYXAoZiA9PiBjcmVhdGVUYXNrKHRoaXMuZmlsdGVyLCBmKSksXG4gICAgICBxdWFudGl6ZXI6IGNyZWF0ZVRhc2sodGhpcy5xdWFudGl6ZXIsIHF1YW50aXplciksXG4gICAgICBnZW5lcmF0b3JzOiBnZW5lcmF0b3JzLm1hcChnID0+IGNyZWF0ZVRhc2sodGhpcy5nZW5lcmF0b3IsIGcpKVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVUYXNrPFE+IChcbiAgICAgIHN0YWdlOiBTdGFnZTxRPixcbiAgICAgIG86IHN0cmluZyB8IFN0YWdlT3B0aW9uc1xuICAgICk6IFN0YWdlVGFzazxRPiB7XG4gICAgICBsZXQgbmFtZTogc3RyaW5nXG4gICAgICBsZXQgb3B0aW9uczogYW55XG4gICAgICBpZiAodHlwZW9mIG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBvXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gby5uYW1lXG4gICAgICAgIG9wdGlvbnMgPSBvLm9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZm46IHN0YWdlLmdldChuYW1lKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaWx0ZXI6IFN0YWdlPEZpbHRlcj4gPSBuZXcgU3RhZ2UodGhpcylcbiAgcXVhbnRpemVyOiBTdGFnZTxRdWFudGl6ZXI+ID0gbmV3IFN0YWdlKHRoaXMpXG4gIGdlbmVyYXRvcjogU3RhZ2U8R2VuZXJhdG9yPiA9IG5ldyBTdGFnZSh0aGlzKVxuICBhc3luYyBwcm9jZXNzIChcbiAgICBpbWFnZURhdGE6IEltYWdlRGF0YSxcbiAgICBvcHRzOiBQcm9jZXNzT3B0aW9uc1xuICApOiBQcm9taXNlPFByb2Nlc3NSZXN1bHQ+IHtcbiAgICBsZXQgeyBmaWx0ZXJzLCBxdWFudGl6ZXIsIGdlbmVyYXRvcnMgfSA9IHRoaXMuX2J1aWxkUHJvY2Vzc1Rhc2tzKG9wdHMpXG4gICAgY29uc3QgaW1hZ2VGaWx0ZXJEYXRhID0gYXdhaXQgdGhpcy5fZmlsdGVyQ29sb3JzKGZpbHRlcnMsIGltYWdlRGF0YSlcbiAgICBjb25zdCBjb2xvcnMgPSBhd2FpdCB0aGlzLl9nZW5lcmF0ZUNvbG9ycyhxdWFudGl6ZXIsIGltYWdlRmlsdGVyRGF0YSlcbiAgICBjb25zdCBwYWxldHRlcyA9IGF3YWl0IHRoaXMuX2dlbmVyYXRlUGFsZXR0ZXMoZ2VuZXJhdG9ycywgY29sb3JzKVxuICAgIHJldHVybiB7XG4gICAgICBjb2xvcnMsXG4gICAgICBwYWxldHRlc1xuICAgIH1cbiAgfVxuICBwcml2YXRlIF9maWx0ZXJDb2xvcnMgKGZpbHRlcnM6IFN0YWdlVGFzazxGaWx0ZXI+W10sIGltYWdlRGF0YTogSW1hZ2VEYXRhKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgIGFwcGx5RmlsdGVycyhpbWFnZURhdGEsIGZpbHRlcnMubWFwKCh7IGZuIH0pID0+IGZuKSlcbiAgICApXG4gIH1cbiAgcHJpdmF0ZSBfZ2VuZXJhdGVDb2xvcnMgKFxuICAgIHF1YW50aXplcjogU3RhZ2VUYXNrPFF1YW50aXplcj4sXG4gICAgaW1hZ2VEYXRhOiBJbWFnZURhdGFcbiAgKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShxdWFudGl6ZXIuZm4oaW1hZ2VEYXRhLmRhdGEsIHF1YW50aXplci5vcHRpb25zKSlcbiAgfVxuICBwcml2YXRlIGFzeW5jIF9nZW5lcmF0ZVBhbGV0dGVzIChcbiAgICBnZW5lcmF0b3JzOiBTdGFnZVRhc2s8R2VuZXJhdG9yPltdLFxuICAgIGNvbG9yczogU3dhdGNoW11cbiAgKSB7XG4gICAgLy8gTWFrZSBhIHByb21pc2UgbWFwIHRoYXQgd2lsbCBydW4gdGhlbSBcImNvbmN1cnJlbnRseVwiIChidXQgcmV0dXJuIGluIGV4cGVjdGVkIHJlc3VsdClcbiAgICBjb25zdCBwcm9taXNlQXJyID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBnZW5lcmF0b3JzLm1hcCgoeyBmbiwgb3B0aW9ucyB9KSA9PiBQcm9taXNlLnJlc29sdmUoZm4oY29sb3JzLCBvcHRpb25zKSkpXG4gICAgKVxuICAgIC8vIE1hcCB0aGUgdmFsdWVzIHRvIHRoZSBleHBlY3RlZCBuYW1lXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgIHByb21pc2VBcnIucmVkdWNlKFxuICAgICAgICAocHJvbWlzZXMsIHByb21pc2VWYWwsIGkpID0+IHtcbiAgICAgICAgICBwcm9taXNlc1tnZW5lcmF0b3JzW2ldLm5hbWVdID0gcHJvbWlzZVZhbFxuICAgICAgICAgIHJldHVybiBwcm9taXNlc1xuICAgICAgICB9LFxuICAgICAgICB7fSBhcyB7IFtuYW1lOiBzdHJpbmddOiBQYWxldHRlIH1cbiAgICAgIClcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/node-vibrant/dist/vibrant.js\n");

/***/ })

}]);