"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_Virtualizer_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/ScrollerController.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/ScrollerController.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrollerController: () => (/* binding */ ScrollerController),\n/* harmony export */   ScrollerShim: () => (/* binding */ ScrollerShim)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass ScrollerShim {\n  constructor(element) {\n    this._node = null;\n    this._element = null;\n    const node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  get element() {\n    return this._element || document.scrollingElement || document.documentElement;\n  }\n  get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n  get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n  get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n  get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n  get viewportHeight() {\n    return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n  }\n  get viewportWidth() {\n    return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n  }\n  get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n  get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\nclass ScrollerController extends ScrollerShim {\n  constructor(client, element) {\n    super(element);\n    this._originalScrollTo = null;\n    this._originalScrollBy = null;\n    this._originalScroll = null;\n    this._clients = [];\n    this._retarget = null;\n    this._end = null;\n    this.__destination = null;\n    this.correctingScrollError = false;\n    const node = this._node;\n    const instance = ScrollerController._instanceMap.get(node);\n    if (instance) {\n      instance._attach(client);\n      return instance;\n    } else {\n      this._checkForArrival = this._checkForArrival.bind(this);\n      this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n      this.scrollTo = this.scrollTo.bind(this);\n      this.scrollBy = this.scrollBy.bind(this);\n      this._originalScrollTo = node.scrollTo;\n      this._originalScrollBy = node.scrollBy;\n      this._originalScroll = node.scroll;\n      this._attach(client);\n    }\n  }\n  get _destination() {\n    return this.__destination;\n  }\n  get scrolling() {\n    return this._destination !== null;\n  }\n  scrollTo(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    this._scrollTo(options);\n  }\n  scrollBy(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n  _nativeScrollTo(options) {\n    this._originalScrollTo.bind(this._element || window)(options);\n  }\n  _scrollTo(options, retarget = null, end = null) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n  _setDestination(options) {\n    let {\n      top,\n      left\n    } = options;\n    top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n    left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n      return false;\n    }\n    this.__destination = {\n      top,\n      left,\n      behavior: 'smooth'\n    };\n    return true;\n  }\n  _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n  _updateManagedScrollTo(coordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n  managedScrollTo(options, retarget, end) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n  correctScrollError(coordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() => requestAnimationFrame(() => this.correctingScrollError = false));\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n  _checkForArrival() {\n    if (this._destination !== null) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this;\n      let {\n        top,\n        left\n      } = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n  detach(client) {\n    this._clients = this._clients.splice(this._clients.indexOf(client), 1);\n    if (this._clients.length === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n  _attach(client) {\n    this._clients.push(client);\n    if (this._clients.length === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\nScrollerController._instanceMap = new WeakMap();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1Njcm9sbGVyQ29udHJvbGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztBQVdBO0FBSUE7QUFIQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBR0E7QUFvQkE7QUFDQTtBQWxCQTtBQUlBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUlBO0FBS0E7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFLQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFyTUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC9zcmMvU2Nyb2xsZXJDb250cm9sbGVyLnRzP2Y2NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCB7U2Nyb2xsVG9Db29yZGluYXRlc30gZnJvbSAnLi9sYXlvdXRzL3NoYXJlZC9MYXlvdXQuanMnO1xuXG50eXBlIHJldGFyZ2V0U2Nyb2xsQ2FsbGJhY2sgPSAoKSA9PiBTY3JvbGxUb0Nvb3JkaW5hdGVzO1xudHlwZSBlbmRTY3JvbGxDYWxsYmFjayA9ICgpID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxlclNoaW0ge1xuICBwcm90ZWN0ZWQgX25vZGU6IEVsZW1lbnQgfCBXaW5kb3cgfCBudWxsID0gbnVsbDtcbiAgcHJvdGVjdGVkIF9lbGVtZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudD86IEVsZW1lbnQpIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudCA/PyB3aW5kb3c7XG4gICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fZWxlbWVudCB8fCBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbFRvcCB8fCB3aW5kb3cuc2Nyb2xsWTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQgfHwgd2luZG93LnNjcm9sbFg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2Nyb2xsV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmlld3BvcnRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRcbiAgICAgID8gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgIDogd2luZG93LmlubmVySGVpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldCB2aWV3cG9ydFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50XG4gICAgICA/IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgIDogd2luZG93LmlubmVyV2lkdGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1heFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JvbGxIZWlnaHQgLSB0aGlzLnZpZXdwb3J0SGVpZ2h0O1xuICB9XG5cbiAgcHVibGljIGdldCBtYXhTY3JvbGxMZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLnNjcm9sbFdpZHRoIC0gdGhpcy52aWV3cG9ydFdpZHRoO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTY3JvbGxlckNvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxlclNoaW0ge1xuICBwcml2YXRlIHN0YXRpYyBfaW5zdGFuY2VNYXA6IFdlYWtNYXA8RWxlbWVudCB8IFdpbmRvdywgU2Nyb2xsZXJDb250cm9sbGVyPiA9XG4gICAgbmV3IFdlYWtNYXAoKTtcbiAgcHJpdmF0ZSBfb3JpZ2luYWxTY3JvbGxUbzpcbiAgICB8IHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUb1xuICAgIHwgdHlwZW9mIHdpbmRvdy5zY3JvbGxUb1xuICAgIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX29yaWdpbmFsU2Nyb2xsQnk6XG4gICAgfCB0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICB8IHR5cGVvZiB3aW5kb3cuc2Nyb2xsQnlcbiAgICB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9vcmlnaW5hbFNjcm9sbDpcbiAgICB8IHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxcbiAgICB8IHR5cGVvZiB3aW5kb3cuc2Nyb2xsXG4gICAgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfY2xpZW50czogQXJyYXk8dW5rbm93bj4gPSBbXTtcbiAgcHJpdmF0ZSBfcmV0YXJnZXQ6IHJldGFyZ2V0U2Nyb2xsQ2FsbGJhY2sgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfZW5kOiBlbmRTY3JvbGxDYWxsYmFjayB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9fZGVzdGluYXRpb246IFNjcm9sbFRvT3B0aW9ucyB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogdW5rbm93biwgZWxlbWVudD86IEVsZW1lbnQpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZSE7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBTY3JvbGxlckNvbnRyb2xsZXIuX2luc3RhbmNlTWFwLmdldChub2RlISk7XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5fYXR0YWNoKGNsaWVudCk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoZWNrRm9yQXJyaXZhbCA9IHRoaXMuX2NoZWNrRm9yQXJyaXZhbC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fdXBkYXRlTWFuYWdlZFNjcm9sbFRvID0gdGhpcy5fdXBkYXRlTWFuYWdlZFNjcm9sbFRvLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnNjcm9sbFRvID0gdGhpcy5zY3JvbGxUby5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zY3JvbGxCeSA9IHRoaXMuc2Nyb2xsQnkuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29yaWdpbmFsU2Nyb2xsVG8gPSBub2RlLnNjcm9sbFRvO1xuICAgICAgdGhpcy5fb3JpZ2luYWxTY3JvbGxCeSA9IG5vZGUuc2Nyb2xsQnk7XG4gICAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbCA9IG5vZGUuc2Nyb2xsO1xuICAgICAgdGhpcy5fYXR0YWNoKGNsaWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNvcnJlY3RpbmdTY3JvbGxFcnJvciA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZ2V0IF9kZXN0aW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX2Rlc3RpbmF0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldCBzY3JvbGxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rlc3RpbmF0aW9uICE9PSBudWxsO1xuICB9XG5cbiAgcHVibGljIHNjcm9sbFRvKG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyk6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxUbyh4OiBudW1iZXIsIHk6IG51bWJlcik6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxUbyhwMTogU2Nyb2xsVG9PcHRpb25zIHwgbnVtYmVyLCBwMj86IG51bWJlcik6IHZvaWQ7XG4gIHB1YmxpYyBzY3JvbGxUbyhwMTogU2Nyb2xsVG9PcHRpb25zIHwgbnVtYmVyLCBwMj86IG51bWJlcikge1xuICAgIGNvbnN0IG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyA9XG4gICAgICB0eXBlb2YgcDEgPT09ICdudW1iZXInICYmIHR5cGVvZiBwMiA9PT0gJ251bWJlcidcbiAgICAgICAgPyB7bGVmdDogcDEsIHRvcDogcDJ9XG4gICAgICAgIDogKHAxIGFzIFNjcm9sbFRvT3B0aW9ucyk7XG4gICAgdGhpcy5fc2Nyb2xsVG8ob3B0aW9ucyk7XG4gIH1cblxuICBwdWJsaWMgc2Nyb2xsQnkob3B0aW9uczogU2Nyb2xsVG9PcHRpb25zKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbEJ5KHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbEJ5KHAxOiBTY3JvbGxUb09wdGlvbnMgfCBudW1iZXIsIHAyPzogbnVtYmVyKTogdm9pZDtcbiAgcHVibGljIHNjcm9sbEJ5KHAxOiBTY3JvbGxUb09wdGlvbnMgfCBudW1iZXIsIHAyPzogbnVtYmVyKSB7XG4gICAgY29uc3Qgb3B0aW9uczogU2Nyb2xsVG9PcHRpb25zID1cbiAgICAgIHR5cGVvZiBwMSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHAyID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHtsZWZ0OiBwMSwgdG9wOiBwMn1cbiAgICAgICAgOiAocDEgYXMgU2Nyb2xsVG9PcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy50b3AgKz0gdGhpcy5zY3JvbGxUb3A7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucy5sZWZ0ICs9IHRoaXMuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgdGhpcy5fc2Nyb2xsVG8ob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIF9uYXRpdmVTY3JvbGxUbyhvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMpIHtcbiAgICB0aGlzLl9vcmlnaW5hbFNjcm9sbFRvIS5iaW5kKHRoaXMuX2VsZW1lbnQgfHwgd2luZG93KShvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbFRvKFxuICAgIG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyxcbiAgICByZXRhcmdldDogcmV0YXJnZXRTY3JvbGxDYWxsYmFjayB8IG51bGwgPSBudWxsLFxuICAgIGVuZDogZW5kU2Nyb2xsQ2FsbGJhY2sgfCBudWxsID0gbnVsbFxuICApIHtcbiAgICBpZiAodGhpcy5fZW5kICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbmQoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICB0aGlzLl9zZXREZXN0aW5hdGlvbihvcHRpb25zKTtcbiAgICAgIHRoaXMuX3JldGFyZ2V0ID0gcmV0YXJnZXQ7XG4gICAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsU3RhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8ob3B0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIF9zZXREZXN0aW5hdGlvbihvcHRpb25zOiBTY3JvbGxUb09wdGlvbnMpIHtcbiAgICBsZXQge3RvcCwgbGVmdH0gPSBvcHRpb25zO1xuICAgIHRvcCA9XG4gICAgICB0b3AgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKHRvcCwgdGhpcy5tYXhTY3JvbGxUb3ApKTtcbiAgICBsZWZ0ID1cbiAgICAgIGxlZnQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKGxlZnQsIHRoaXMubWF4U2Nyb2xsTGVmdCkpO1xuICAgIGlmIChcbiAgICAgIHRoaXMuX2Rlc3RpbmF0aW9uICE9PSBudWxsICYmXG4gICAgICBsZWZ0ID09PSB0aGlzLl9kZXN0aW5hdGlvbi5sZWZ0ICYmXG4gICAgICB0b3AgPT09IHRoaXMuX2Rlc3RpbmF0aW9uLnRvcFxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9fZGVzdGluYXRpb24gPSB7dG9wLCBsZWZ0LCBiZWhhdmlvcjogJ3Ntb290aCd9O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVzZXRTY3JvbGxTdGF0ZSgpIHtcbiAgICB0aGlzLl9fZGVzdGluYXRpb24gPSBudWxsO1xuICAgIHRoaXMuX3JldGFyZ2V0ID0gbnVsbDtcbiAgICB0aGlzLl9lbmQgPSBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlTWFuYWdlZFNjcm9sbFRvKGNvb3JkaW5hdGVzOiBTY3JvbGxUb0Nvb3JkaW5hdGVzKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uKSB7XG4gICAgICBpZiAodGhpcy5fc2V0RGVzdGluYXRpb24oY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZVNjcm9sbFRvKHRoaXMuX2Rlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbWFuYWdlZFNjcm9sbFRvKFxuICAgIG9wdGlvbnM6IFNjcm9sbFRvT3B0aW9ucyxcbiAgICByZXRhcmdldDogcmV0YXJnZXRTY3JvbGxDYWxsYmFjayxcbiAgICBlbmQ6IGVuZFNjcm9sbENhbGxiYWNrXG4gICkge1xuICAgIHRoaXMuX3Njcm9sbFRvKG9wdGlvbnMsIHJldGFyZ2V0LCBlbmQpO1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVNYW5hZ2VkU2Nyb2xsVG87XG4gIH1cblxuICBwdWJsaWMgY29ycmVjdFNjcm9sbEVycm9yKGNvb3JkaW5hdGVzOiBTY3JvbGxUb0Nvb3JkaW5hdGVzKSB7XG4gICAgdGhpcy5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPSB0cnVlO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+ICh0aGlzLmNvcnJlY3RpbmdTY3JvbGxFcnJvciA9IGZhbHNlKSlcbiAgICApO1xuICAgIC8vIENvcnJlY3QgdGhlIGVycm9yXG4gICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8oY29vcmRpbmF0ZXMpO1xuICAgIC8vIFRoZW4sIGlmIHdlIHdlcmUgaGVhZGVkIGZvciBhIHNwZWNpZmljIGRlc3RpbmF0aW9uLCB3ZSBjb250aW51ZSBzY3JvbGxpbmc6XG4gICAgLy8gRmlyc3QsIHdlIHVwZGF0ZSBvdXIgdGFyZ2V0IGRlc3RpbmF0aW9uLCBpZiBhcHBsaWNhYmxlLi4uXG4gICAgaWYgKHRoaXMuX3JldGFyZ2V0KSB7XG4gICAgICB0aGlzLl9zZXREZXN0aW5hdGlvbih0aGlzLl9yZXRhcmdldCgpKTtcbiAgICB9XG4gICAgLy8gVGhlbiB3ZSBnbyBhaGVhZCBhbmQgcmVzdW1lIHNjcm9sbGluZ1xuICAgIGlmICh0aGlzLl9kZXN0aW5hdGlvbikge1xuICAgICAgdGhpcy5fbmF0aXZlU2Nyb2xsVG8odGhpcy5fZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrRm9yQXJyaXZhbCgpIHtcbiAgICBpZiAodGhpcy5fZGVzdGluYXRpb24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtzY3JvbGxUb3AsIHNjcm9sbExlZnR9ID0gdGhpcztcbiAgICAgIGxldCB7dG9wLCBsZWZ0fSA9IHRoaXMuX2Rlc3RpbmF0aW9uO1xuICAgICAgdG9wID0gTWF0aC5taW4odG9wIHx8IDAsIHRoaXMubWF4U2Nyb2xsVG9wKTtcbiAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0IHx8IDAsIHRoaXMubWF4U2Nyb2xsTGVmdCk7XG4gICAgICBjb25zdCB0b3BEaWZmID0gTWF0aC5hYnModG9wIC0gc2Nyb2xsVG9wKTtcbiAgICAgIGNvbnN0IGxlZnREaWZmID0gTWF0aC5hYnMobGVmdCAtIHNjcm9sbExlZnQpO1xuICAgICAgLy8gV2UgY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFycml2ZWQgYXQgb3VyIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKHRvcERpZmYgPCAxICYmIGxlZnREaWZmIDwgMSkge1xuICAgICAgICBpZiAodGhpcy5fZW5kKSB7XG4gICAgICAgICAgdGhpcy5fZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXRhY2goY2xpZW50OiB1bmtub3duKSB7XG4gICAgdGhpcy5fY2xpZW50cyA9IHRoaXMuX2NsaWVudHMuc3BsaWNlKHRoaXMuX2NsaWVudHMuaW5kZXhPZihjbGllbnQpLCAxKTtcbiAgICBpZiAodGhpcy5fY2xpZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX25vZGUhLnNjcm9sbFRvID0gdGhpcy5fb3JpZ2luYWxTY3JvbGxUbyE7XG4gICAgICB0aGlzLl9ub2RlIS5zY3JvbGxCeSA9IHRoaXMuX29yaWdpbmFsU2Nyb2xsQnkhO1xuICAgICAgdGhpcy5fbm9kZSEuc2Nyb2xsID0gdGhpcy5fb3JpZ2luYWxTY3JvbGwhO1xuICAgICAgdGhpcy5fbm9kZSEucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fY2hlY2tGb3JBcnJpdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9hdHRhY2goY2xpZW50OiB1bmtub3duKSB7XG4gICAgdGhpcy5fY2xpZW50cy5wdXNoKGNsaWVudCk7XG4gICAgaWYgKHRoaXMuX2NsaWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9ub2RlIS5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG87XG4gICAgICB0aGlzLl9ub2RlIS5zY3JvbGxCeSA9IHRoaXMuc2Nyb2xsQnk7XG4gICAgICB0aGlzLl9ub2RlIS5zY3JvbGwgPSB0aGlzLnNjcm9sbFRvO1xuICAgICAgdGhpcy5fbm9kZSEuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fY2hlY2tGb3JBcnJpdmFsKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/ScrollerController.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/Virtualizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/Virtualizer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   provideResizeObserver: () => (/* binding */ provideResizeObserver),\n/* harmony export */   virtualizerRef: () => (/* binding */ virtualizerRef)\n/* harmony export */ });\n/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events.js */ \"./node_modules/@lit-labs/virtualizer/events.js\");\n/* harmony import */ var _ScrollerController_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ScrollerController.js */ \"./node_modules/@lit-labs/virtualizer/ScrollerController.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n// Virtualizer depends on `ResizeObserver`, which is supported in\n// all modern browsers. For developers whose browser support\n// matrix includes older browsers, we include a compatible\n// polyfill in the package; this bit of module state facilitates\n// a simple mechanism (see ./polyfillLoaders/ResizeObserver.js.)\n// for loading the polyfill.\nlet _ResizeObserver = window === null || window === void 0 ? void 0 : window.ResizeObserver;\n/**\n * Call this function to provide a `ResizeObserver` polyfill for Virtualizer to use.\n * @param Ctor Constructor for a `ResizeObserver` polyfill (recommend using the one provided with the Virtualizer package)\n */\nfunction provideResizeObserver(Ctor) {\n  _ResizeObserver = Ctor;\n}\nconst virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nclass Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    /**\n     * Layout initialization is async because we dynamically load\n     * the default layout if none is specified. This state is to track\n     * whether init is complete.\n     */\n    this._layoutInitialized = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n  _init(config) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    const layoutConfig = config.layout || {};\n    // Save the promise returned by `_initLayout` as a state\n    // variable we can check before updating layout config\n    this._layoutInitialized = this._initLayout(layoutConfig);\n  }\n  _initObservers() {\n    this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n    this._hostElementRO = new _ResizeObserver(() => this._hostElementSizeChanged());\n    this._childrenRO = new _ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n  connected() {\n    this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n    this._scrollerController = new _ScrollerController_js__WEBPACK_IMPORTED_MODULE_1__.ScrollerController(this, this._clippingAncestors[0]);\n    this._schedule(this._updateLayout);\n    this._observeAndListen();\n  }\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n    this._hostElementRO.observe(this._hostElement);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO.observe(ancestor);\n    });\n    this._hostElementRO.observe(this._scrollerController.element);\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n  disconnected() {\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController = this._scrollerController.detach(this) || null;\n    this._mutationObserver.disconnect();\n    this._hostElementRO.disconnect();\n    this._childrenRO.disconnect();\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n  _getSizer() {\n    const hostElement = this._hostElement;\n    if (!this._sizer) {\n      // Use a preexisting sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.textContent = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n  async updateLayoutConfig(layoutConfig) {\n    // If layout initialization hasn't finished yet, we wait\n    // for it to finish so we can check whether the new config\n    // is compatible with the existing layout before proceeding.\n    await this._layoutInitialized;\n    const Ctor = layoutConfig.type ||\n    // The new config is compatible with the current layout,\n    // so we update the config and return true to indicate\n    // a successful update\n    DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {\n        ...layoutConfig\n      };\n      delete config.type;\n      this._layout.config = config;\n      // The new config requires a different layout altogether, but\n      // to limit implementation complexity we don't support dynamically\n      // changing the layout of an existing virtualizer instance.\n      // Returning false here lets the caller know that they should\n      // instead make a new virtualizer instance with the desired layout.\n      return true;\n    }\n    return false;\n  }\n  async _initLayout(layoutConfig) {\n    let config;\n    let Ctor;\n    if (typeof layoutConfig.type === 'function') {\n      // If we have a full LayoutSpecifier, the `type` property\n      // gives us our constructor...\n      Ctor = layoutConfig.type;\n      // ...while the rest of the specifier is our layout config\n      const copy = {\n        ...layoutConfig\n      };\n      delete copy.type;\n      config = copy;\n    } else {\n      // If we don't have a full LayoutSpecifier, we just\n      // have a config for the default layout\n      config = layoutConfig;\n    }\n    if (Ctor === undefined) {\n      // If we don't have a constructor yet, load the default\n      DefaultLayoutConstructor = Ctor = (await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js\"), __webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_flow_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./layouts/flow.js */ \"./node_modules/@lit-labs/virtualizer/layouts/flow.js\"))).FlowLayout;\n    }\n    this._layout = new Ctor(message => this._handleLayoutMessage(message), config);\n    if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n      if (typeof this._layout.measureChildren === 'function') {\n        this._measureChildOverride = this._layout.measureChildren;\n      }\n      this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n    }\n    if (this._layout.listenForChildLoadEvents) {\n      this._hostElement.addEventListener('load', this._loadListener, true);\n    }\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n    return null;\n  }\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  async _schedule(method) {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n      await Promise.resolve();\n      this._scheduled.delete(method);\n      method.call(this);\n    }\n  }\n  async _updateDOM(state) {\n    this._scrollSize = state.scrollSize;\n    this._adjustRange(state.range);\n    this._childrenPos = state.childPositions;\n    this._scrollError = state.scrollError || null;\n    const {\n      _rangeChanged,\n      _itemsChanged\n    } = this;\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n      this._visibilityChanged = false;\n    }\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n      this._rangeChanged = false;\n    } else {\n      this._finishDOMUpdate();\n    }\n  }\n  _finishDOMUpdate() {\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n  _updateLayout() {\n    if (this._layout) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n  _handleScrollEvent() {\n    var _a;\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      (_a = this._layout) === null || _a === void 0 ? void 0 : _a.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n  _handleLayoutMessage(message) {\n    if (message.type === 'stateChanged') {\n      this._updateDOM(message);\n    } else if (message.type === 'visibilityChanged') {\n      this._firstVisible = message.firstVisible;\n      this._lastVisible = message.lastVisible;\n      this._notifyVisibility();\n    } else if (message.type === 'unpinned') {\n      this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_0__.UnpinnedEvent());\n    }\n  }\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling;\n    }\n    return arr;\n  }\n  _updateView() {\n    var _a;\n    const hostElement = this._hostElement;\n    const scrollingElement = (_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.element;\n    const layout = this._layout;\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n      const hostElementBounds = hostElement.getBoundingClientRect();\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      const ancestorBounds = this._clippingAncestors.map(ancestor => ancestor.getBoundingClientRect());\n      ancestorBounds.unshift(hostElementBounds);\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top\n      };\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight\n      };\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n      const height = Math.max(1, bottom - top);\n      const width = Math.max(1, right - left);\n      layout.viewportSize = {\n        width,\n        height\n      };\n      layout.viewportScroll = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  _positionChildren(pos) {\n    if (pos) {\n      pos.forEach(({\n        top,\n        left,\n        width,\n        height,\n        xOffset,\n        yOffset\n      }, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n  async _adjustRange(range) {\n    const {\n      _first,\n      _last,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n  }\n  _correctScrollError() {\n    if (this._scrollError) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this._scrollerController;\n      const {\n        top,\n        left\n      } = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left\n      });\n    }\n  }\n  element(index) {\n    var _a;\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return ((_a = this._items) === null || _a === void 0 ? void 0 : _a[index]) === undefined ? undefined : {\n      scrollIntoView: (options = {}) => this._scrollElementIntoView({\n        ...options,\n        index\n      })\n    };\n  }\n  _scrollElementIntoView(options) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n        const {\n          behavior\n        } = options;\n        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n          behavior\n        }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout.pin = options;\n      }\n    }\n  }\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  _checkScrollIntoViewTarget(pos) {\n    const {\n      index\n    } = this._scrollIntoViewTarget || {};\n    if (index && (pos === null || pos === void 0 ? void 0 : pos.has(index))) {\n      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_0__.RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new _events_js__WEBPACK_IMPORTED_MODULE_0__.VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  get layoutComplete() {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n  _rejectLayoutCompletePromise(reason) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n  _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n    }\n  }\n  _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n  _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n  _childLoaded() {}\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  _childrenSizeChanged(changes) {\n    var _a;\n    // Only measure if the layout requires it\n    if ((_a = this._layout) === null || _a === void 0 ? void 0 : _a.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n  return getElementAncestors(el, includeSelf).filter(a => getComputedStyle(a).overflow !== 'visible');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1ZpcnR1YWxpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7O0FBdUJBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTRDQTtBQUVBOzs7Ozs7OztBQVFBO0FBbUlBO0FBbElBO0FBRUE7QUFFQTtBQUVBOzs7O0FBSUE7QUFFQTs7OztBQUlBO0FBRUE7OztBQUdBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBT0E7QUFFQTtBQUVBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTs7Ozs7QUFLQTtBQUVBO0FBSUE7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7Ozs7O0FBS0E7QUFHQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBR0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7O0FBSUE7QUFLQTtBQUlBO0FBQ0E7O0FBRUE7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFFQTs7QUFHQTs7QUFFQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7QUFDQTtBQUNBOztBQUVBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBSUE7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFHQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9WaXJ0dWFsaXplci50cz8yZjdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBCU0QtMy1DbGF1c2VcbiAqL1xuXG5pbXBvcnQge1xuICBJdGVtQm94LFxuICBNYXJnaW5zLFxuICBMYXlvdXRDb25maWdWYWx1ZSxcbiAgQ2hpbGRQb3NpdGlvbnMsXG4gIENoaWxkTWVhc3VyZW1lbnRzLFxuICBMYXlvdXQsXG4gIExheW91dENvbnN0cnVjdG9yLFxuICBMYXlvdXRTcGVjaWZpZXIsXG4gIFN0YXRlQ2hhbmdlZE1lc3NhZ2UsXG4gIFNpemUsXG4gIEludGVybmFsUmFuZ2UsXG4gIE1lYXN1cmVDaGlsZEZ1bmN0aW9uLFxuICBTY3JvbGxUb0Nvb3JkaW5hdGVzLFxuICBCYXNlTGF5b3V0Q29uZmlnLFxuICBMYXlvdXRIb3N0TWVzc2FnZSxcbn0gZnJvbSAnLi9sYXlvdXRzL3NoYXJlZC9MYXlvdXQuanMnO1xuaW1wb3J0IHtcbiAgUmFuZ2VDaGFuZ2VkRXZlbnQsXG4gIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQsXG4gIFVucGlubmVkRXZlbnQsXG59IGZyb20gJy4vZXZlbnRzLmpzJztcbmltcG9ydCB7U2Nyb2xsZXJDb250cm9sbGVyfSBmcm9tICcuL1Njcm9sbGVyQ29udHJvbGxlci5qcyc7XG5cbi8vIFZpcnR1YWxpemVyIGRlcGVuZHMgb24gYFJlc2l6ZU9ic2VydmVyYCwgd2hpY2ggaXMgc3VwcG9ydGVkIGluXG4vLyBhbGwgbW9kZXJuIGJyb3dzZXJzLiBGb3IgZGV2ZWxvcGVycyB3aG9zZSBicm93c2VyIHN1cHBvcnRcbi8vIG1hdHJpeCBpbmNsdWRlcyBvbGRlciBicm93c2Vycywgd2UgaW5jbHVkZSBhIGNvbXBhdGlibGVcbi8vIHBvbHlmaWxsIGluIHRoZSBwYWNrYWdlOyB0aGlzIGJpdCBvZiBtb2R1bGUgc3RhdGUgZmFjaWxpdGF0ZXNcbi8vIGEgc2ltcGxlIG1lY2hhbmlzbSAoc2VlIC4vcG9seWZpbGxMb2FkZXJzL1Jlc2l6ZU9ic2VydmVyLmpzLilcbi8vIGZvciBsb2FkaW5nIHRoZSBwb2x5ZmlsbC5cbmxldCBfUmVzaXplT2JzZXJ2ZXI6IHR5cGVvZiBSZXNpemVPYnNlcnZlciB8IHVuZGVmaW5lZCA9IHdpbmRvdz8uUmVzaXplT2JzZXJ2ZXI7XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHByb3ZpZGUgYSBgUmVzaXplT2JzZXJ2ZXJgIHBvbHlmaWxsIGZvciBWaXJ0dWFsaXplciB0byB1c2UuXG4gKiBAcGFyYW0gQ3RvciBDb25zdHJ1Y3RvciBmb3IgYSBgUmVzaXplT2JzZXJ2ZXJgIHBvbHlmaWxsIChyZWNvbW1lbmQgdXNpbmcgdGhlIG9uZSBwcm92aWRlZCB3aXRoIHRoZSBWaXJ0dWFsaXplciBwYWNrYWdlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZVJlc2l6ZU9ic2VydmVyKEN0b3I6IHR5cGVvZiBSZXNpemVPYnNlcnZlcikge1xuICBfUmVzaXplT2JzZXJ2ZXIgPSBDdG9yO1xufVxuXG5leHBvcnQgY29uc3QgdmlydHVhbGl6ZXJSZWYgPSBTeW1ib2woJ3ZpcnR1YWxpemVyUmVmJyk7XG5jb25zdCBTSVpFUl9BVFRSSUJVVEUgPSAndmlydHVhbGl6ZXItc2l6ZXInO1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBIVE1MRWxlbWVudEV2ZW50TWFwIHtcbiAgICByYW5nZUNoYW5nZWQ6IFJhbmdlQ2hhbmdlZEV2ZW50O1xuICAgIHZpc2liaWxpdHlDaGFuZ2VkOiBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50O1xuICAgIHVucGlubmVkOiBVbnBpbm5lZEV2ZW50O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlydHVhbGl6ZXJIb3N0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgW3ZpcnR1YWxpemVyUmVmXT86IFZpcnR1YWxpemVyO1xufVxuXG4vKipcbiAqIEEgdmVyeSBsaW1pdGVkIHByb3h5IG9iamVjdCBmb3IgYSB2aXJ0dWFsaXplciBjaGlsZCxcbiAqIHJldHVybmVkIGJ5IFZpcnR1YWxpemVyLmVsZW1lbnQoaWR4OiBudW1iZXIpLiBJbnRyb2R1Y2VkXG4gKiB0byBlbmFibGUgc2Nyb2xsaW5nIGEgdmlydHVhbCBlbGVtZW50IGludG8gdmlldyB1c2luZ1xuICogYSBjYWxsIHRoYXQgbG9va3MgYW5kIGJlaGF2ZXMgZXNzZW50aWFsbHkgdGhlIHNhbWUgYXMgZm9yXG4gKiBhIHJlYWwgRWxlbWVudC4gTWF5IGJlIHVzZWZ1bCBmb3Igb3RoZXIgdGhpbmdzIGxhdGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVyQ2hpbGRFbGVtZW50UHJveHkge1xuICBzY3JvbGxJbnRvVmlldzogKG9wdGlvbnM/OiBTY3JvbGxJbnRvVmlld09wdGlvbnMpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogVXNlZCBpbnRlcm5hbGx5IGZvciBzY3JvbGxpbmcgYSAocG9zc2libHkgdmlydHVhbCkgZWxlbWVudFxuICogaW50byB2aWV3LCBnaXZlbiBpdHMgaW5kZXhcbiAqL1xuaW50ZXJmYWNlIFNjcm9sbEVsZW1lbnRJbnRvVmlld09wdGlvbnMgZXh0ZW5kcyBTY3JvbGxJbnRvVmlld09wdGlvbnMge1xuICBpbmRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpcnR1YWxpemVyQ29uZmlnIHtcbiAgbGF5b3V0PzogTGF5b3V0Q29uZmlnVmFsdWU7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJlbnQgb2YgYWxsIGNoaWxkIG5vZGVzIHRvIGJlIHJlbmRlcmVkLlxuICAgKi9cbiAgaG9zdEVsZW1lbnQ6IFZpcnR1YWxpemVySG9zdEVsZW1lbnQ7XG5cbiAgc2Nyb2xsZXI/OiBib29sZWFuO1xufVxuXG5sZXQgRGVmYXVsdExheW91dENvbnN0cnVjdG9yOiBMYXlvdXRDb25zdHJ1Y3RvcjtcblxuLyoqXG4gKiBQcm92aWRlcyB2aXJ0dWFsIHNjcm9sbGluZyBib2lsZXJwbGF0ZS5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBzZXQgaG9zdEVsZW1lbnQgYW5kIGxheW91dC5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBhbHNvIG92ZXJyaWRlIFZpcnR1YWxSZXBlYXRlcidzIERPTVxuICogbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaXJ0dWFsaXplciB7XG4gIHByaXZhdGUgX2JlbmNobWFya1N0YXJ0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9sYXlvdXQ6IExheW91dCB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX2NsaXBwaW5nQW5jZXN0b3JzOiBIVE1MRWxlbWVudFtdID0gW107XG5cbiAgLyoqXG4gICAqIExheW91dCBwcm92aWRlcyB0aGVzZSB2YWx1ZXMsIHdlIHNldCB0aGVtIG9uIF9yZW5kZXIoKS5cbiAgICogVE9ETyBAc3RyYXZlcnNpOiBDYW4gd2UgZmluZCBhbiBYT1IgdHlwZSwgdXNhYmxlIGZvciB0aGUga2V5IGhlcmU/XG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxTaXplOiBTaXplIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIERpZmZlcmVuY2UgYmV0d2VlbiBzY3JvbGwgdGFyZ2V0J3MgY3VycmVudCBhbmQgcmVxdWlyZWQgc2Nyb2xsIG9mZnNldHMuXG4gICAqIFByb3ZpZGVkIGJ5IGxheW91dC5cbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbEVycm9yOiB7bGVmdDogbnVtYmVyOyB0b3A6IG51bWJlcn0gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBwb3NpdGlvbnMgKHRvcCwgbGVmdCkgb2YgdGhlIGNoaWxkcmVuIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgKi9cbiAgcHJpdmF0ZSBfY2hpbGRyZW5Qb3M6IENoaWxkUG9zaXRpb25zIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gVE9ETzogKGdyYXlub3J0b24pOiB0eXBlXG4gIHByaXZhdGUgX2NoaWxkTWVhc3VyZW1lbnRzOiBDaGlsZE1lYXN1cmVtZW50cyB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX3RvQmVNZWFzdXJlZDogTWFwPEhUTUxFbGVtZW50LCB1bmtub3duPiA9IG5ldyBNYXAoKTtcblxuICBwcml2YXRlIF9yYW5nZUNoYW5nZWQgPSB0cnVlO1xuXG4gIHByaXZhdGUgX2l0ZW1zQ2hhbmdlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfdmlzaWJpbGl0eUNoYW5nZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUaGUgSFRNTEVsZW1lbnQgdGhhdCBob3N0cyB0aGUgdmlydHVhbGl6ZXIuIFNldCBieSBob3N0RWxlbWVudC5cbiAgICovXG4gIHByb3RlY3RlZCBfaG9zdEVsZW1lbnQ/OiBWaXJ0dWFsaXplckhvc3RFbGVtZW50O1xuXG4gIHByaXZhdGUgX3Njcm9sbGVyQ29udHJvbGxlcjogU2Nyb2xsZXJDb250cm9sbGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfaXNTY3JvbGxlciA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3NpemVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gaG9zdEVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIF9ob3N0RWxlbWVudFJPOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gY2hpbGRyZW4uXG4gICAqL1xuICBwcml2YXRlIF9jaGlsZHJlblJPOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX211dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9zY3JvbGxFdmVudExpc3RlbmVyczogKEVsZW1lbnQgfCBXaW5kb3cpW10gPSBbXTtcbiAgcHJpdmF0ZSBfc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xuICAgIHBhc3NpdmU6IHRydWUsXG4gIH07XG5cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFJldGhpbmssIHBlciBsb25nZXIgY29tbWVudCBiZWxvd1xuXG4gIHByaXZhdGUgX2xvYWRMaXN0ZW5lciA9IHRoaXMuX2NoaWxkTG9hZGVkLmJpbmQodGhpcyk7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIGVsZW1lbnQgdG8gc2Nyb2xsIGludG8gdmlldywgcGx1cyBzY3JvbGxcbiAgICogYmVoYXZpb3Igb3B0aW9ucywgYXMgaW1wZXJhdGl2ZWx5IHNwZWNpZmllZCB2aWFcbiAgICogYGVsZW1lbnQoaW5kZXgpLnNjcm9sbEludG9WaWV3KClgXG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxJbnRvVmlld1RhcmdldDogU2Nyb2xsRWxlbWVudEludG9WaWV3T3B0aW9ucyB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX3VwZGF0ZVNjcm9sbEludG9WaWV3Q29vcmRpbmF0ZXM6XG4gICAgfCAoKGNvb3JkaW5hdGVzOiBTY3JvbGxUb0Nvb3JkaW5hdGVzKSA9PiB2b2lkKVxuICAgIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEl0ZW1zIHRvIHJlbmRlci4gU2V0IGJ5IGl0ZW1zLlxuICAgKi9cbiAgcHJpdmF0ZSBfaXRlbXM6IEFycmF5PHVua25vd24+ID0gW107XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBjaGlsZCBpbiB0aGUgcmFuZ2UsIG5vdCBuZWNlc3NhcmlseSB0aGUgZmlyc3QgdmlzaWJsZSBjaGlsZC5cbiAgICogVE9ETyBAc3RyYXZlcnNpOiBDb25zaWRlciByZW5hbWluZyB0aGVzZS5cbiAgICovXG4gIHByb3RlY3RlZCBfZmlyc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgY2hpbGQgaW4gdGhlIHJhbmdlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF9maXJzdFZpc2libGUgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgaXRlbSBpbnRlcnNlY3RpbmcgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJpdmF0ZSBfbGFzdFZpc2libGUgPSAtMTtcblxuICBwcm90ZWN0ZWQgX3NjaGVkdWxlZCA9IG5ldyBXZWFrU2V0KCk7XG5cbiAgLyoqXG4gICAqIEludm9rZWQgYXQgdGhlIGVuZCBvZiBlYWNoIHJlbmRlciBjeWNsZTogY2hpbGRyZW4gaW4gdGhlIHJhbmdlIGFyZVxuICAgKiBtZWFzdXJlZCwgYW5kIHRoZWlyIGRpbWVuc2lvbnMgcGFzc2VkIHRvIHRoaXMgY2FsbGJhY2suIFVzZSBpdCB0byBsYXlvdXRcbiAgICogY2hpbGRyZW4gYXMgbmVlZGVkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9tZWFzdXJlQ2FsbGJhY2s6ICgoc2l6ZXM6IENoaWxkTWVhc3VyZW1lbnRzKSA9PiB2b2lkKSB8IG51bGwgPVxuICAgIG51bGw7XG5cbiAgcHJvdGVjdGVkIF9tZWFzdXJlQ2hpbGRPdmVycmlkZTogTWVhc3VyZUNoaWxkRnVuY3Rpb24gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogU3RhdGUgZm9yIGBsYXlvdXRDb21wbGV0ZWAgcHJvbWlzZVxuICAgKi9cbiAgcHJpdmF0ZSBfbGF5b3V0Q29tcGxldGVQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xheW91dENvbXBsZXRlUmVzb2x2ZXI6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2xheW91dENvbXBsZXRlUmVqZWN0ZXI6IEZ1bmN0aW9uIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX3BlbmRpbmdMYXlvdXRDb21wbGV0ZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIExheW91dCBpbml0aWFsaXphdGlvbiBpcyBhc3luYyBiZWNhdXNlIHdlIGR5bmFtaWNhbGx5IGxvYWRcbiAgICogdGhlIGRlZmF1bHQgbGF5b3V0IGlmIG5vbmUgaXMgc3BlY2lmaWVkLiBUaGlzIHN0YXRlIGlzIHRvIHRyYWNrXG4gICAqIHdoZXRoZXIgaW5pdCBpcyBjb21wbGV0ZS5cbiAgICovXG4gIHByaXZhdGUgX2xheW91dEluaXRpYWxpemVkOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdWaXJ0dWFsaXplciBjb25zdHJ1Y3RvciByZXF1aXJlcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5ob3N0RWxlbWVudCkge1xuICAgICAgdGhpcy5faW5pdChjb25maWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdWaXJ0dWFsaXplciBjb25maWd1cmF0aW9uIHJlcXVpcmVzIHRoZSBcImhvc3RFbGVtZW50XCIgcHJvcGVydHknXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHNldCBpdGVtcyhpdGVtczogQXJyYXk8dW5rbm93bj4gfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykgJiYgaXRlbXMgIT09IHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gICAgfVxuICB9XG5cbiAgX2luaXQoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIHRoaXMuX2lzU2Nyb2xsZXIgPSAhIWNvbmZpZy5zY3JvbGxlcjtcbiAgICB0aGlzLl9pbml0SG9zdEVsZW1lbnQoY29uZmlnKTtcbiAgICAvLyBJZiBubyBsYXlvdXQgaXMgc3BlY2lmaWVkLCB3ZSBtYWtlIGFuIGVtcHR5XG4gICAgLy8gbGF5b3V0IGNvbmZpZywgd2hpY2ggd2lsbCByZXN1bHQgaW4gdGhlIGRlZmF1bHRcbiAgICAvLyBsYXlvdXQgd2l0aCBkZWZhdWx0IHBhcmFtZXRlcnNcbiAgICBjb25zdCBsYXlvdXRDb25maWcgPSBjb25maWcubGF5b3V0IHx8ICh7fSBhcyBCYXNlTGF5b3V0Q29uZmlnKTtcbiAgICAvLyBTYXZlIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IGBfaW5pdExheW91dGAgYXMgYSBzdGF0ZVxuICAgIC8vIHZhcmlhYmxlIHdlIGNhbiBjaGVjayBiZWZvcmUgdXBkYXRpbmcgbGF5b3V0IGNvbmZpZ1xuICAgIHRoaXMuX2xheW91dEluaXRpYWxpemVkID0gdGhpcy5faW5pdExheW91dChsYXlvdXRDb25maWcpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW5pdE9ic2VydmVycygpIHtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoXG4gICAgICB0aGlzLl9maW5pc2hET01VcGRhdGUuYmluZCh0aGlzKVxuICAgICk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyA9IG5ldyBfUmVzaXplT2JzZXJ2ZXIhKCgpID0+XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudFNpemVDaGFuZ2VkKClcbiAgICApO1xuICAgIHRoaXMuX2NoaWxkcmVuUk8gPSBuZXcgX1Jlc2l6ZU9ic2VydmVyIShcbiAgICAgIHRoaXMuX2NoaWxkcmVuU2l6ZUNoYW5nZWQuYmluZCh0aGlzKVxuICAgICk7XG4gIH1cblxuICBfaW5pdEhvc3RFbGVtZW50KGNvbmZpZzogVmlydHVhbGl6ZXJDb25maWcpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9ICh0aGlzLl9ob3N0RWxlbWVudCA9IGNvbmZpZy5ob3N0RWxlbWVudCk7XG4gICAgdGhpcy5fYXBwbHlWaXJ0dWFsaXplclN0eWxlcygpO1xuICAgIGhvc3RFbGVtZW50W3ZpcnR1YWxpemVyUmVmXSA9IHRoaXM7XG4gIH1cblxuICBjb25uZWN0ZWQoKSB7XG4gICAgdGhpcy5faW5pdE9ic2VydmVycygpO1xuICAgIGNvbnN0IGluY2x1ZGVTZWxmID0gdGhpcy5faXNTY3JvbGxlcjtcbiAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycyA9IGdldENsaXBwaW5nQW5jZXN0b3JzKFxuICAgICAgdGhpcy5faG9zdEVsZW1lbnQhLFxuICAgICAgaW5jbHVkZVNlbGZcbiAgICApO1xuXG4gICAgdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyID0gbmV3IFNjcm9sbGVyQ29udHJvbGxlcihcbiAgICAgIHRoaXMsXG4gICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9yc1swXVxuICAgICk7XG5cbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICAgIHRoaXMuX29ic2VydmVBbmRMaXN0ZW4oKTtcbiAgfVxuXG4gIF9vYnNlcnZlQW5kTGlzdGVuKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIhLm9ic2VydmUodGhpcy5faG9zdEVsZW1lbnQhLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyEub2JzZXJ2ZSh0aGlzLl9ob3N0RWxlbWVudCEpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLnB1c2god2luZG93KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICAgIHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgICAgICk7XG4gICAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUoYW5jZXN0b3IpO1xuICAgIH0pO1xuICAgIHRoaXMuX2hvc3RFbGVtZW50Uk8hLm9ic2VydmUodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5lbGVtZW50KTtcbiAgICB0aGlzLl9jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fY2hpbGRyZW5STyEub2JzZXJ2ZShjaGlsZCkpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkKCkge1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLmZvckVhY2goKHRhcmdldCkgPT5cbiAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMgPSBbXTtcbiAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIgPSB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLmRldGFjaCh0aGlzKSB8fCBudWxsO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIhLmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLl9ob3N0RWxlbWVudFJPIS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5fY2hpbGRyZW5STyEuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX3JlamVjdExheW91dENvbXBsZXRlUHJvbWlzZSgnZGlzY29ubmVjdGVkJyk7XG4gIH1cblxuICBwcml2YXRlIF9hcHBseVZpcnR1YWxpemVyU3R5bGVzKCkge1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5faG9zdEVsZW1lbnQhO1xuICAgIC8vIFdvdWxkIHJhdGhlciBzZXQgdGhlc2UgQ1NTIHByb3BlcnRpZXMgb24gdGhlIGhvc3QgdXNpbmcgU2hhZG93IFJvb3RcbiAgICAvLyBzdHlsZSBzY29waW5nIChhbmQgZmFsbGluZyBiYWNrIHRvIGEgZ2xvYmFsIHN0eWxlc2hlZXQgd2hlcmUgbmF0aXZlXG4gICAgLy8gU2hhZG93IERPTSBpcyBub3QgYXZhaWxhYmxlKSwgYnV0IHRoaXMgTW9iaWxlIFNhZmFyaSBidWcgaXMgcHJldmVudGluZ1xuICAgIC8vIHRoYXQgZnJvbSB3b3JraW5nOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjI2MTk1XG4gICAgY29uc3Qgc3R5bGUgPSBob3N0RWxlbWVudC5zdHlsZSBhcyBDU1NTdHlsZURlY2xhcmF0aW9uICYge2NvbnRhaW46IHN0cmluZ307XG4gICAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgICBzdHlsZS5wb3NpdGlvbiA9IHN0eWxlLnBvc2l0aW9uIHx8ICdyZWxhdGl2ZSc7XG4gICAgc3R5bGUuY29udGFpbiA9IHN0eWxlLmNvbnRhaW4gfHwgJ3NpemUgbGF5b3V0JztcblxuICAgIGlmICh0aGlzLl9pc1Njcm9sbGVyKSB7XG4gICAgICBzdHlsZS5vdmVyZmxvdyA9IHN0eWxlLm92ZXJmbG93IHx8ICdhdXRvJztcbiAgICAgIHN0eWxlLm1pbkhlaWdodCA9IHN0eWxlLm1pbkhlaWdodCB8fCAnMTUwcHgnO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRTaXplcigpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50ITtcbiAgICBpZiAoIXRoaXMuX3NpemVyKSB7XG4gICAgICAvLyBVc2UgYSBwcmVleGlzdGluZyBzaXplciBlbGVtZW50IGlmIHByb3ZpZGVkIChmb3IgYmV0dGVyIGludGVncmF0aW9uXG4gICAgICAvLyB3aXRoIHZET00gcmVuZGVyZXJzKVxuICAgICAgbGV0IHNpemVyID0gaG9zdEVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgYFske1NJWkVSX0FUVFJJQlVURX1dYFxuICAgICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmICghc2l6ZXIpIHtcbiAgICAgICAgc2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2l6ZXIuc2V0QXR0cmlidXRlKFNJWkVSX0FUVFJJQlVURSwgJycpO1xuICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZChzaXplcik7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIHRoZSBzY3JvbGxIZWlnaHQgaXMgbGFyZ2UsIHRoZSBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IG1pZ2h0IGJlXG4gICAgICAvLyBpZ25vcmVkLiBTZXR0aW5nIGNvbnRlbnQgYW5kIGZvbnQtc2l6ZSBlbnN1cmVzIHRoZSBlbGVtZW50IGhhcyBhIHNpemUuXG4gICAgICBPYmplY3QuYXNzaWduKHNpemVyLnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBtYXJnaW46ICctMnB4IDAgMCAwJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgIGZvbnRTaXplOiAnMnB4JyxcbiAgICAgIH0pO1xuICAgICAgc2l6ZXIudGV4dENvbnRlbnQgPSAnJm5ic3A7JztcbiAgICAgIHNpemVyLnNldEF0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUsICcnKTtcbiAgICAgIHRoaXMuX3NpemVyID0gc2l6ZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaXplcjtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZUxheW91dENvbmZpZyhsYXlvdXRDb25maWc6IExheW91dENvbmZpZ1ZhbHVlKSB7XG4gICAgLy8gSWYgbGF5b3V0IGluaXRpYWxpemF0aW9uIGhhc24ndCBmaW5pc2hlZCB5ZXQsIHdlIHdhaXRcbiAgICAvLyBmb3IgaXQgdG8gZmluaXNoIHNvIHdlIGNhbiBjaGVjayB3aGV0aGVyIHRoZSBuZXcgY29uZmlnXG4gICAgLy8gaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBleGlzdGluZyBsYXlvdXQgYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgYXdhaXQgdGhpcy5fbGF5b3V0SW5pdGlhbGl6ZWQ7XG4gICAgY29uc3QgQ3RvciA9XG4gICAgICAoKGxheW91dENvbmZpZyBhcyBMYXlvdXRTcGVjaWZpZXIpLnR5cGUgYXMgTGF5b3V0Q29uc3RydWN0b3IpIHx8XG4gICAgICAvLyBUaGUgbmV3IGNvbmZpZyBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgbGF5b3V0LFxuICAgICAgLy8gc28gd2UgdXBkYXRlIHRoZSBjb25maWcgYW5kIHJldHVybiB0cnVlIHRvIGluZGljYXRlXG4gICAgICAvLyBhIHN1Y2Nlc3NmdWwgdXBkYXRlXG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3I7XG4gICAgaWYgKHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIHRoaXMuX2xheW91dCBpbnN0YW5jZW9mIEN0b3IpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb25maWcudHlwZTtcbiAgICAgIHRoaXMuX2xheW91dC5jb25maWcgPSBjb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICAgIC8vIFRoZSBuZXcgY29uZmlnIHJlcXVpcmVzIGEgZGlmZmVyZW50IGxheW91dCBhbHRvZ2V0aGVyLCBidXRcbiAgICAgIC8vIHRvIGxpbWl0IGltcGxlbWVudGF0aW9uIGNvbXBsZXhpdHkgd2UgZG9uJ3Qgc3VwcG9ydCBkeW5hbWljYWxseVxuICAgICAgLy8gY2hhbmdpbmcgdGhlIGxheW91dCBvZiBhbiBleGlzdGluZyB2aXJ0dWFsaXplciBpbnN0YW5jZS5cbiAgICAgIC8vIFJldHVybmluZyBmYWxzZSBoZXJlIGxldHMgdGhlIGNhbGxlciBrbm93IHRoYXQgdGhleSBzaG91bGRcbiAgICAgIC8vIGluc3RlYWQgbWFrZSBhIG5ldyB2aXJ0dWFsaXplciBpbnN0YW5jZSB3aXRoIHRoZSBkZXNpcmVkIGxheW91dC5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9pbml0TGF5b3V0KGxheW91dENvbmZpZzogTGF5b3V0Q29uZmlnVmFsdWUpIHtcbiAgICBsZXQgY29uZmlnOiBCYXNlTGF5b3V0Q29uZmlnIHwgdW5kZWZpbmVkO1xuICAgIGxldCBDdG9yOiBMYXlvdXRDb25zdHJ1Y3RvciB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgZnVsbCBMYXlvdXRTcGVjaWZpZXIsIHRoZSBgdHlwZWAgcHJvcGVydHlcbiAgICAgIC8vIGdpdmVzIHVzIG91ciBjb25zdHJ1Y3Rvci4uLlxuICAgICAgQ3RvciA9IChsYXlvdXRDb25maWcgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlIGFzIExheW91dENvbnN0cnVjdG9yO1xuICAgICAgLy8gLi4ud2hpbGUgdGhlIHJlc3Qgb2YgdGhlIHNwZWNpZmllciBpcyBvdXIgbGF5b3V0IGNvbmZpZ1xuICAgICAgY29uc3QgY29weSA9IHsuLi4obGF5b3V0Q29uZmlnIGFzIExheW91dFNwZWNpZmllcil9IGFzIHtcbiAgICAgICAgdHlwZT86IExheW91dENvbnN0cnVjdG9yO1xuICAgICAgfTtcbiAgICAgIGRlbGV0ZSBjb3B5LnR5cGU7XG4gICAgICBjb25maWcgPSBjb3B5IGFzIEJhc2VMYXlvdXRDb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBmdWxsIExheW91dFNwZWNpZmllciwgd2UganVzdFxuICAgICAgLy8gaGF2ZSBhIGNvbmZpZyBmb3IgdGhlIGRlZmF1bHQgbGF5b3V0XG4gICAgICBjb25maWcgPSBsYXlvdXRDb25maWcgYXMgQmFzZUxheW91dENvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY29uc3RydWN0b3IgeWV0LCBsb2FkIHRoZSBkZWZhdWx0XG4gICAgICBEZWZhdWx0TGF5b3V0Q29uc3RydWN0b3IgPSBDdG9yID0gKGF3YWl0IGltcG9ydCgnLi9sYXlvdXRzL2Zsb3cuanMnKSlcbiAgICAgICAgLkZsb3dMYXlvdXQgYXMgdW5rbm93biBhcyBMYXlvdXRDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXlvdXQgPSBuZXcgQ3RvcihcbiAgICAgIChtZXNzYWdlOiBMYXlvdXRIb3N0TWVzc2FnZSkgPT4gdGhpcy5faGFuZGxlTGF5b3V0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgIGNvbmZpZ1xuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuICYmXG4gICAgICB0eXBlb2YgdGhpcy5fbGF5b3V0LnVwZGF0ZUl0ZW1TaXplcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlID0gdGhpcy5fbGF5b3V0Lm1lYXN1cmVDaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayA9IHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMuYmluZCh0aGlzLl9sYXlvdXQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9sYXlvdXQubGlzdGVuRm9yQ2hpbGRMb2FkRXZlbnRzKSB7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2xvYWRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgfVxuXG4gIC8vIFRPRE8gKGdyYXlub3J0b24pOiBSZXdvcmsgYmVuY2htYXJraW5nIHNvIHRoYXQgaXQgaGFzIG5vIEFQSSBhbmRcbiAgLy8gaW5zdGVhZCBpcyBhbHdheXMgb24gZXhjZXB0IGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIHN0YXJ0QmVuY2htYXJraW5nKCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcEJlbmNobWFya2luZygpIHtcbiAgICBpZiAodGhpcy5fYmVuY2htYXJrU3RhcnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gbm93IC0gdGhpcy5fYmVuY2htYXJrU3RhcnQ7XG4gICAgICBjb25zdCBlbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICAgICAgJ3V2LXZpcnR1YWxpemluZycsXG4gICAgICAgICdtZWFzdXJlJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHZpcnR1YWxpemF0aW9uVGltZSA9IGVudHJpZXNcbiAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAoZSkgPT4gZS5zdGFydFRpbWUgPj0gdGhpcy5fYmVuY2htYXJrU3RhcnQhICYmIGUuc3RhcnRUaW1lIDwgbm93XG4gICAgICAgIClcbiAgICAgICAgLnJlZHVjZSgodCwgbSkgPT4gdCArIG0uZHVyYXRpb24sIDApO1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSBudWxsO1xuICAgICAgcmV0dXJuIHt0aW1lRWxhcHNlZCwgdmlydHVhbGl6YXRpb25UaW1lfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwcml2YXRlIF9tZWFzdXJlQ2hpbGRyZW4oKTogdm9pZCB7XG4gICAgY29uc3QgbW06IENoaWxkTWVhc3VyZW1lbnRzID0ge307XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBjb25zdCBmbiA9IHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlIHx8IHRoaXMuX21lYXN1cmVDaGlsZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZmlyc3QgKyBpO1xuICAgICAgaWYgKHRoaXMuX2l0ZW1zQ2hhbmdlZCB8fCB0aGlzLl90b0JlTWVhc3VyZWQuaGFzKGNoaWxkKSkge1xuICAgICAgICBtbVtpZHhdID0gZm4uY2FsbCh0aGlzLCBjaGlsZCwgdGhpcy5faXRlbXNbaWR4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkTWVhc3VyZW1lbnRzID0gbW07XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB0aGlzLl90b0JlTWVhc3VyZWQuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgbWFyZ2lucyBvZiB0aGUgZ2l2ZW4gY2hpbGQuXG4gICAqL1xuICBfbWVhc3VyZUNoaWxkKGVsZW1lbnQ6IEVsZW1lbnQpOiBJdGVtQm94IHtcbiAgICAvLyBvZmZzZXRXaWR0aCBkb2Vzbid0IHRha2UgdHJhbnNmb3JtcyBpbiBjb25zaWRlcmF0aW9uLCBzbyB3ZSB1c2VcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2hpY2ggZG9lcy5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0fSwgZ2V0TWFyZ2lucyhlbGVtZW50KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX3NjaGVkdWxlKG1ldGhvZDogRnVuY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZC5oYXMobWV0aG9kKSkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkLmFkZChtZXRob2QpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQuZGVsZXRlKG1ldGhvZCk7XG4gICAgICBtZXRob2QuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfdXBkYXRlRE9NKHN0YXRlOiBTdGF0ZUNoYW5nZWRNZXNzYWdlKSB7XG4gICAgdGhpcy5fc2Nyb2xsU2l6ZSA9IHN0YXRlLnNjcm9sbFNpemU7XG4gICAgdGhpcy5fYWRqdXN0UmFuZ2Uoc3RhdGUucmFuZ2UpO1xuICAgIHRoaXMuX2NoaWxkcmVuUG9zID0gc3RhdGUuY2hpbGRQb3NpdGlvbnM7XG4gICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSBzdGF0ZS5zY3JvbGxFcnJvciB8fCBudWxsO1xuICAgIGNvbnN0IHtfcmFuZ2VDaGFuZ2VkLCBfaXRlbXNDaGFuZ2VkfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX3Zpc2liaWxpdHlDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlWaXNpYmlsaXR5KCk7XG4gICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3JhbmdlQ2hhbmdlZCB8fCBfaXRlbXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ub3RpZnlSYW5nZSgpO1xuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpbmlzaERPTVVwZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9maW5pc2hET01VcGRhdGUoKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2NoaWxkcmVuUk8hLm9ic2VydmUoY2hpbGQpKTtcbiAgICB0aGlzLl9jaGVja1Njcm9sbEludG9WaWV3VGFyZ2V0KHRoaXMuX2NoaWxkcmVuUG9zKTtcbiAgICB0aGlzLl9wb3NpdGlvbkNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuUG9zKTtcbiAgICB0aGlzLl9zaXplSG9zdEVsZW1lbnQodGhpcy5fc2Nyb2xsU2l6ZSk7XG4gICAgdGhpcy5fY29ycmVjdFNjcm9sbEVycm9yKCk7XG4gICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1lbmQnKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgIHRoaXMuX2xheW91dCEuaXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQsIHdlIG1heSBoYXZlIG1lYXN1cmVtZW50cyBidXQgbm8gY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMuX21lYXN1cmVDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hpbGRNZWFzdXJlbWVudHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5b3V0IS5yZWZsb3dJZk5lZWRlZCgpO1xuICAgICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoJ3V2LWVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVNjcm9sbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCAmJiAnbWFyaycgaW4gd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWVhc3VyZSgndXYtdmlydHVhbGl6aW5nJywgJ3V2LXN0YXJ0JywgJ3V2LWVuZCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIG1lYXN1cmluZyBwZXJmb3JtYW5jZSBkYXRhOiAnLCBlKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyIS5jb3JyZWN0aW5nU2Nyb2xsRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdXNlci1pbml0aWF0ZWQgc2Nyb2xsLCBzbyB3ZSB1bnBpbiB0aGUgbGF5b3V0XG4gICAgICB0aGlzLl9sYXlvdXQ/LnVucGluKCk7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudDogQ3VzdG9tRXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID09PSB3aW5kb3cgfHxcbiAgICAgICAgICB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycy5pbmNsdWRlcyhldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVTY3JvbGxFdmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS53YXJuKCdldmVudCBub3QgaGFuZGxlZCcsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlTGF5b3V0TWVzc2FnZShtZXNzYWdlOiBMYXlvdXRIb3N0TWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlLnR5cGUgPT09ICdzdGF0ZUNoYW5nZWQnKSB7XG4gICAgICB0aGlzLl91cGRhdGVET00obWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLnR5cGUgPT09ICd2aXNpYmlsaXR5Q2hhbmdlZCcpIHtcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IG1lc3NhZ2UuZmlyc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbGFzdFZpc2libGUgPSBtZXNzYWdlLmxhc3RWaXNpYmxlO1xuICAgICAgdGhpcy5fbm90aWZ5VmlzaWJpbGl0eSgpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSAndW5waW5uZWQnKSB7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChuZXcgVW5waW5uZWRFdmVudCgpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2NoaWxkcmVuKCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgY29uc3QgYXJyOiBBcnJheTxIVE1MRWxlbWVudD4gPSBbXTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuX2hvc3RFbGVtZW50IS5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudDtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgaWYgKCFuZXh0Lmhhc0F0dHJpYnV0ZShTSVpFUl9BVFRSSUJVVEUpKSB7XG4gICAgICAgIGFyci5wdXNoKG5leHQpO1xuICAgICAgfVxuICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nIGFzIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcHJpdmF0ZSBfdXBkYXRlVmlldygpIHtcbiAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50O1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXI/LmVsZW1lbnQ7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy5fbGF5b3V0O1xuXG4gICAgaWYgKGhvc3RFbGVtZW50ICYmIHNjcm9sbGluZ0VsZW1lbnQgJiYgbGF5b3V0KSB7XG4gICAgICBsZXQgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0O1xuXG4gICAgICBjb25zdCBob3N0RWxlbWVudEJvdW5kcyA9IGhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB0b3AgPSAwO1xuICAgICAgbGVmdCA9IDA7XG4gICAgICBib3R0b20gPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgICBjb25zdCBhbmNlc3RvckJvdW5kcyA9IHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzLm1hcCgoYW5jZXN0b3IpID0+XG4gICAgICAgIGFuY2VzdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICApO1xuICAgICAgYW5jZXN0b3JCb3VuZHMudW5zaGlmdChob3N0RWxlbWVudEJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgYm91bmRzIG9mIGFuY2VzdG9yQm91bmRzKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgYm91bmRzLnRvcCk7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1heChsZWZ0LCBib3VuZHMubGVmdCk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWluKGJvdHRvbSwgYm91bmRzLmJvdHRvbSk7XG4gICAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIGJvdW5kcy5yaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMgPSBzY3JvbGxpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICBjb25zdCBvZmZzZXRXaXRoaW5TY3JvbGxlciA9IHtcbiAgICAgICAgbGVmdDogaG9zdEVsZW1lbnRCb3VuZHMubGVmdCAtIHNjcm9sbGluZ0VsZW1lbnRCb3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBob3N0RWxlbWVudEJvdW5kcy50b3AgLSBzY3JvbGxpbmdFbGVtZW50Qm91bmRzLnRvcCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRvdGFsU2Nyb2xsU2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2Nyb2xsaW5nRWxlbWVudC5zY3JvbGxIZWlnaHQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSB0b3AgLSBob3N0RWxlbWVudEJvdW5kcy50b3AgKyBob3N0RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gbGVmdCAtIGhvc3RFbGVtZW50Qm91bmRzLmxlZnQgKyBob3N0RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCgxLCBib3R0b20gLSB0b3ApO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCgxLCByaWdodCAtIGxlZnQpO1xuXG4gICAgICBsYXlvdXQudmlld3BvcnRTaXplID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgICAgbGF5b3V0LnZpZXdwb3J0U2Nyb2xsID0ge3RvcDogc2Nyb2xsVG9wLCBsZWZ0OiBzY3JvbGxMZWZ0fTtcbiAgICAgIGxheW91dC50b3RhbFNjcm9sbFNpemUgPSB0b3RhbFNjcm9sbFNpemU7XG4gICAgICBsYXlvdXQub2Zmc2V0V2l0aGluU2Nyb2xsZXIgPSBvZmZzZXRXaXRoaW5TY3JvbGxlcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBob3N0IGVsZW1lbnQgc28gdGhhdCBpdHMgc2l6ZSByZWZsZWN0cyB0aGVcbiAgICogdG90YWwgc2l6ZSBvZiBhbGwgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9zaXplSG9zdEVsZW1lbnQoc2l6ZT86IFNpemUgfCBudWxsKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZWVtIHRvIGNyYXAgb3V0IGlmIHRoZSBob3N0IGVsZW1lbnQgZ2V0cyBsYXJnZXIgdGhhblxuICAgIC8vIGEgY2VydGFpbiBzaXplLCBzbyB3ZSBjbGFtcCBpdCBoZXJlICh0aGlzIHZhbHVlIGJhc2VkIG9uIGFkIGhvY1xuICAgIC8vIHRlc3RpbmcgaW4gQ2hyb21lIC8gU2FmYXJpIC8gRmlyZWZveCBNYWMpXG4gICAgY29uc3QgbWF4ID0gODIwMDAwMDtcbiAgICBjb25zdCBoID0gc2l6ZSAmJiBzaXplLndpZHRoICE9PSBudWxsID8gTWF0aC5taW4obWF4LCBzaXplLndpZHRoKSA6IDA7XG4gICAgY29uc3QgdiA9IHNpemUgJiYgc2l6ZS5oZWlnaHQgIT09IG51bGwgPyBNYXRoLm1pbihtYXgsIHNpemUuaGVpZ2h0KSA6IDA7XG5cbiAgICBpZiAodGhpcy5faXNTY3JvbGxlcikge1xuICAgICAgdGhpcy5fZ2V0U2l6ZXIoKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7aH1weCwgJHt2fXB4KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5faG9zdEVsZW1lbnQhLnN0eWxlO1xuICAgICAgKHN0eWxlLm1pbldpZHRoIGFzIHN0cmluZyB8IG51bGwpID0gaCA/IGAke2h9cHhgIDogJzEwMCUnO1xuICAgICAgKHN0eWxlLm1pbkhlaWdodCBhcyBzdHJpbmcgfCBudWxsKSA9IHYgPyBgJHt2fXB4YCA6ICcxMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdG9wIGFuZCBsZWZ0IHRyYW5zZm9ybSBzdHlsZSBvZiB0aGUgY2hpbGRyZW4gZnJvbSB0aGUgdmFsdWVzIGluXG4gICAqIHBvcy5cbiAgICovXG4gIHByaXZhdGUgX3Bvc2l0aW9uQ2hpbGRyZW4ocG9zOiBDaGlsZFBvc2l0aW9ucyB8IG51bGwpIHtcbiAgICBpZiAocG9zKSB7XG4gICAgICBwb3MuZm9yRWFjaCgoe3RvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCwgeE9mZnNldCwgeU9mZnNldH0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baW5kZXggLSB0aGlzLl9maXJzdF07XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBjaGlsZC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICAgICAgY2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsICR7dG9wfXB4KWA7XG4gICAgICAgICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChjaGlsZC5zdHlsZS5sZWZ0IGFzIHN0cmluZyB8IG51bGwpID1cbiAgICAgICAgICAgIHhPZmZzZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB4T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAoY2hpbGQuc3R5bGUudG9wIGFzIHN0cmluZyB8IG51bGwpID1cbiAgICAgICAgICAgIHlPZmZzZXQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB5T2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYWRqdXN0UmFuZ2UocmFuZ2U6IEludGVybmFsUmFuZ2UpIHtcbiAgICBjb25zdCB7X2ZpcnN0LCBfbGFzdCwgX2ZpcnN0VmlzaWJsZSwgX2xhc3RWaXNpYmxlfSA9IHRoaXM7XG4gICAgdGhpcy5fZmlyc3QgPSByYW5nZS5maXJzdDtcbiAgICB0aGlzLl9sYXN0ID0gcmFuZ2UubGFzdDtcbiAgICB0aGlzLl9maXJzdFZpc2libGUgPSByYW5nZS5maXJzdFZpc2libGU7XG4gICAgdGhpcy5fbGFzdFZpc2libGUgPSByYW5nZS5sYXN0VmlzaWJsZTtcbiAgICB0aGlzLl9yYW5nZUNoYW5nZWQgPVxuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkIHx8IHRoaXMuX2ZpcnN0ICE9PSBfZmlyc3QgfHwgdGhpcy5fbGFzdCAhPT0gX2xhc3Q7XG4gICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPVxuICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgfHxcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSAhPT0gX2ZpcnN0VmlzaWJsZSB8fFxuICAgICAgdGhpcy5fbGFzdFZpc2libGUgIT09IF9sYXN0VmlzaWJsZTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvcnJlY3RTY3JvbGxFcnJvcigpIHtcbiAgICBpZiAodGhpcy5fc2Nyb2xsRXJyb3IpIHtcbiAgICAgIGNvbnN0IHtzY3JvbGxUb3AsIHNjcm9sbExlZnR9ID0gdGhpcy5fc2Nyb2xsZXJDb250cm9sbGVyITtcbiAgICAgIGNvbnN0IHt0b3AsIGxlZnR9ID0gdGhpcy5fc2Nyb2xsRXJyb3I7XG4gICAgICB0aGlzLl9zY3JvbGxFcnJvciA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLmNvcnJlY3RTY3JvbGxFcnJvcih7XG4gICAgICAgIHRvcDogc2Nyb2xsVG9wIC0gdG9wLFxuICAgICAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gbGVmdCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBlbGVtZW50KGluZGV4OiBudW1iZXIpOiBWaXJ0dWFsaXplckNoaWxkRWxlbWVudFByb3h5IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaW5kZXggPT09IEluZmluaXR5KSB7XG4gICAgICBpbmRleCA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtcz8uW2luZGV4XSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB7XG4gICAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IChvcHRpb25zOiBTY3JvbGxJbnRvVmlld09wdGlvbnMgPSB7fSkgPT5cbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnRJbnRvVmlldyh7Li4ub3B0aW9ucywgaW5kZXh9KSxcbiAgICAgICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgX3Njcm9sbEVsZW1lbnRJbnRvVmlldyhvcHRpb25zOiBTY3JvbGxFbGVtZW50SW50b1ZpZXdPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaW5kZXggPj0gdGhpcy5fZmlyc3QgJiYgb3B0aW9ucy5pbmRleCA8PSB0aGlzLl9sYXN0KSB7XG4gICAgICB0aGlzLl9jaGlsZHJlbltvcHRpb25zLmluZGV4IC0gdGhpcy5fZmlyc3RdLnNjcm9sbEludG9WaWV3KG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmluZGV4ID0gTWF0aC5taW4ob3B0aW9ucy5pbmRleCwgdGhpcy5faXRlbXMubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAob3B0aW9ucy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSB0aGlzLl9sYXlvdXQhLmdldFNjcm9sbEludG9WaWV3Q29vcmRpbmF0ZXMob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHtiZWhhdmlvcn0gPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzID1cbiAgICAgICAgICB0aGlzLl9zY3JvbGxlckNvbnRyb2xsZXIhLm1hbmFnZWRTY3JvbGxUbyhcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29vcmRpbmF0ZXMsIHtiZWhhdmlvcn0pLFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgKCkgPT4gKHRoaXMuX3Njcm9sbEludG9WaWV3VGFyZ2V0ID0gbnVsbClcbiAgICAgICAgICApO1xuICAgICAgICB0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCA9IG9wdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sYXlvdXQhLnBpbiA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGFyZSBzbW9vdGhseSBzY3JvbGxpbmcgdG8gYW4gZWxlbWVudCBhbmQgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIGlzIGluIHRoZSBET00sIHdlIHVwZGF0ZSBvdXIgdGFyZ2V0IGNvb3JkaW5hdGVzIGFzIG5lZWRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfY2hlY2tTY3JvbGxJbnRvVmlld1RhcmdldChwb3M6IENoaWxkUG9zaXRpb25zIHwgbnVsbCkge1xuICAgIGNvbnN0IHtpbmRleH0gPSB0aGlzLl9zY3JvbGxJbnRvVmlld1RhcmdldCB8fCB7fTtcbiAgICBpZiAoaW5kZXggJiYgcG9zPy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLl91cGRhdGVTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzIShcbiAgICAgICAgdGhpcy5fbGF5b3V0IS5nZXRTY3JvbGxJbnRvVmlld0Nvb3JkaW5hdGVzKHRoaXMuX3Njcm9sbEludG9WaWV3VGFyZ2V0ISlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgcmFuZ2VjaGFuZ2UgZXZlbnQgd2l0aCB0aGUgY3VycmVudCBmaXJzdCwgbGFzdCwgZmlyc3RWaXNpYmxlLCBhbmRcbiAgICogbGFzdFZpc2libGUuXG4gICAqL1xuICBwcml2YXRlIF9ub3RpZnlSYW5nZSgpIHtcbiAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBSYW5nZUNoYW5nZWRFdmVudCh7Zmlyc3Q6IHRoaXMuX2ZpcnN0LCBsYXN0OiB0aGlzLl9sYXN0fSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfbm90aWZ5VmlzaWJpbGl0eSgpIHtcbiAgICB0aGlzLl9ob3N0RWxlbWVudCEuZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KHtcbiAgICAgICAgZmlyc3Q6IHRoaXMuX2ZpcnN0VmlzaWJsZSxcbiAgICAgICAgbGFzdDogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGxheW91dENvbXBsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIExhemlseSBjcmVhdGUgcHJvbWlzZVxuICAgIGlmICghdGhpcy5fbGF5b3V0Q29tcGxldGVQcm9taXNlKSB7XG4gICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlamVjdGVyID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UhO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVqZWN0TGF5b3V0Q29tcGxldGVQcm9taXNlKHJlYXNvbjogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2xheW91dENvbXBsZXRlUmVqZWN0ZXIhKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0Q29tcGxldGVTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2NoZWR1bGVMYXlvdXRDb21wbGV0ZSgpIHtcbiAgICAvLyBEb24ndCBkbyBhbnl0aGluZyB1bmxlc3Mgd2UgaGF2ZSBhIHBlbmRpbmcgcHJvbWlzZVxuICAgIC8vIEFuZCBvbmx5IHJlcXVlc3QgYSBmcmFtZSBpZiB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSBzb1xuICAgIGlmICh0aGlzLl9sYXlvdXRDb21wbGV0ZVByb21pc2UgJiYgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID09PSBudWxsKSB7XG4gICAgICAvLyBXYWl0IG9uZSBhZGRpdGlvbmFsIGZyYW1lIHRvIGJlIHN1cmUgdGhlIGxheW91dCBpcyBzdGFibGVcbiAgICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRDb21wbGV0ZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5fcmVzb2x2ZUxheW91dENvbXBsZXRlUHJvbWlzZSgpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9yZXNvbHZlTGF5b3V0Q29tcGxldGVQcm9taXNlKCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9sYXlvdXRDb21wbGV0ZVJlc29sdmVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0TGF5b3V0Q29tcGxldGVTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfcmVzZXRMYXlvdXRDb21wbGV0ZVN0YXRlKCkge1xuICAgIHRoaXMuX2xheW91dENvbXBsZXRlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZXNvbHZlciA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0Q29tcGxldGVSZWplY3RlciA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0xheW91dENvbXBsZXRlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYW5kIHVwZGF0ZSB0aGUgdmlldyBhdCB0aGUgbmV4dCBvcHBvcnR1bml0eSB3aXRoIHRoZSBnaXZlblxuICAgKiBob3N0RWxlbWVudCBzaXplLlxuICAgKi9cbiAgcHJpdmF0ZSBfaG9zdEVsZW1lbnRTaXplQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICB9XG5cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IFJldGhpbmsgaG93IHRoaXMgd29ya3MuIFByb2JhYmx5IGNoaWxkIGxvYWRpbmcgaXMgdG9vIHNwZWNpZmljXG4gIC8vIHRvIGhhdmUgZGVkaWNhdGVkIHN1cHBvcnQgZm9yOyBtaWdodCB3YW50IHNvbWUgbW9yZSBnZW5lcmljIGxpZmVjeWNsZSBob29rcyBmb3JcbiAgLy8gbGF5b3V0cyB0byB1c2UuIFBvc3NpYmx5IGhhbmRsZSBtZWFzdXJlbWVudCB0aGlzIHdheSwgdG9vLCBvciBtYXliZSB0aGF0IHJlbWFpbnNcbiAgLy8gYSBmaXJzdC1jbGFzcyBmZWF0dXJlP1xuXG4gIHByaXZhdGUgX2NoaWxkTG9hZGVkKCkge31cblxuICAvLyBUaGlzIGlzIHRoZSBjYWxsYmFjayBmb3IgdGhlIFJlc2l6ZU9ic2VydmVyIHRoYXQgd2F0Y2hlcyB0aGVcbiAgLy8gdmlydHVhbGl6ZXIncyBjaGlsZHJlbi4gV2UgbGFuZCBoZXJlIGF0IHRoZSBlbmQgb2YgZXZlcnkgdmlydHVhbGl6ZXJcbiAgLy8gdXBkYXRlIGN5Y2xlIHRoYXQgcmVzdWx0cyBpbiBjaGFuZ2VzIHRvIHBoeXNpY2FsIGl0ZW1zLCBhbmQgd2UgYWxzb1xuICAvLyBlbmQgdXAgaGVyZSBpZiBvbmUgb3IgbW9yZSBjaGlsZHJlbiBjaGFuZ2Ugc2l6ZSBpbmRlcGVuZGVudGx5IG9mXG4gIC8vIHRoZSB2aXJ0dWFsaXplciB1cGRhdGUgY3ljbGUuXG4gIHByaXZhdGUgX2NoaWxkcmVuU2l6ZUNoYW5nZWQoY2hhbmdlczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gICAgLy8gT25seSBtZWFzdXJlIGlmIHRoZSBsYXlvdXQgcmVxdWlyZXMgaXRcbiAgICBpZiAodGhpcy5fbGF5b3V0Py5tZWFzdXJlQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fdG9CZU1lYXN1cmVkLnNldChcbiAgICAgICAgICBjaGFuZ2UudGFyZ2V0IGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgIGNoYW5nZS5jb250ZW50UmVjdFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGVuZCBvZiBhbiB1cGRhdGUgY3ljbGUsIHdlIG5lZWQgdG8gcmVzZXQgc29tZVxuICAgIC8vIGludGVybmFsIHN0YXRlLiBUaGlzIHNob3VsZCBiZSBhIGhhcm1sZXNzIG5vLW9wIGlmIHdlJ3JlIGhhbmRsaW5nXG4gICAgLy8gYW4gb3V0LW9mLWN5Y2xlIFJlc2l6ZU9ic2VydmVyIGNhbGxiYWNrLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvIGNhc2VzLlxuICAgIHRoaXMuX3NjaGVkdWxlTGF5b3V0Q29tcGxldGUoKTtcbiAgICB0aGlzLl9pdGVtc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNoYW5nZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGVsOiBFbGVtZW50KTogTWFyZ2lucyB7XG4gIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICByZXR1cm4ge1xuICAgIG1hcmdpblRvcDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luVG9wKSxcbiAgICBtYXJnaW5SaWdodDogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luUmlnaHQpLFxuICAgIG1hcmdpbkJvdHRvbTogZ2V0TWFyZ2luVmFsdWUoc3R5bGUubWFyZ2luQm90dG9tKSxcbiAgICBtYXJnaW5MZWZ0OiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5MZWZ0KSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFyZ2luVmFsdWUodmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGZsb2F0ID0gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IE5hTjtcbiAgcmV0dXJuIE51bWJlci5pc05hTihmbG9hdCkgPyAwIDogZmxvYXQ7XG59XG5cbi8vIFRPRE8gKGdyYXlub3J0b24pOiBEZWFsIHdpdGggaWZyYW1lcz9cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQoZWw6IEVsZW1lbnQpIHtcbiAgaWYgKGVsLmFzc2lnbmVkU2xvdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBlbC5hc3NpZ25lZFNsb3Q7XG4gIH1cbiAgaWYgKGVsLnBhcmVudEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICBjb25zdCBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIChwYXJlbnROb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8vXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRBbmNlc3RvcnMoZWw6IEhUTUxFbGVtZW50LCBpbmNsdWRlU2VsZiA9IGZhbHNlKSB7XG4gIGNvbnN0IGFuY2VzdG9yczogQXJyYXk8SFRNTEVsZW1lbnQ+ID0gW107XG4gIGxldCBwYXJlbnQgPSBpbmNsdWRlU2VsZiA/IGVsIDogKGdldFBhcmVudEVsZW1lbnQoZWwpIGFzIEhUTUxFbGVtZW50KTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGFuY2VzdG9ycy5wdXNoKHBhcmVudCk7XG4gICAgcGFyZW50ID0gZ2V0UGFyZW50RWxlbWVudChwYXJlbnQpIGFzIEhUTUxFbGVtZW50O1xuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nQW5jZXN0b3JzKGVsOiBIVE1MRWxlbWVudCwgaW5jbHVkZVNlbGYgPSBmYWxzZSkge1xuICByZXR1cm4gZ2V0RWxlbWVudEFuY2VzdG9ycyhlbCwgaW5jbHVkZVNlbGYpLmZpbHRlcihcbiAgICAoYSkgPT4gZ2V0Q29tcHV0ZWRTdHlsZShhKS5vdmVyZmxvdyAhPT0gJ3Zpc2libGUnXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/Virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/events.js":
/*!******************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/events.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RangeChangedEvent: () => (/* binding */ RangeChangedEvent),\n/* harmony export */   UnpinnedEvent: () => (/* binding */ UnpinnedEvent),\n/* harmony export */   VisibilityChangedEvent: () => (/* binding */ VisibilityChangedEvent)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nclass RangeChangedEvent extends Event {\n  constructor(range) {\n    super(RangeChangedEvent.eventName, {\n      bubbles: false\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\nRangeChangedEvent.eventName = 'rangeChanged';\nclass VisibilityChangedEvent extends Event {\n  constructor(range) {\n    super(VisibilityChangedEvent.eventName, {\n      bubbles: false\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n}\nVisibilityChangedEvent.eventName = 'visibilityChanged';\nclass UnpinnedEvent extends Event {\n  constructor() {\n    super(UnpinnedEvent.eventName, {\n      bubbles: false\n    });\n  }\n}\nUnpinnedEvent.eventName = 'unpinned';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7QUFNQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQVRBO0FBWUE7QUFNQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVlBO0FBR0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFKQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9ldmVudHMudHM/MzE1MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJhbmdlQ2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBzdGF0aWMgZXZlbnROYW1lID0gJ3JhbmdlQ2hhbmdlZCc7XG5cbiAgZmlyc3Q6IG51bWJlcjtcbiAgbGFzdDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJhbmdlOiBSYW5nZSkge1xuICAgIHN1cGVyKFJhbmdlQ2hhbmdlZEV2ZW50LmV2ZW50TmFtZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndmlzaWJpbGl0eUNoYW5nZWQnO1xuXG4gIGZpcnN0OiBudW1iZXI7XG4gIGxhc3Q6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihyYW5nZTogUmFuZ2UpIHtcbiAgICBzdXBlcihWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50LmV2ZW50TmFtZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVucGlubmVkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAndW5waW5uZWQnO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFVucGlubmVkRXZlbnQuZXZlbnROYW1lLCB7YnViYmxlczogZmFsc2V9KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmFuZ2Uge1xuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/events.js\n");

/***/ })

}]);