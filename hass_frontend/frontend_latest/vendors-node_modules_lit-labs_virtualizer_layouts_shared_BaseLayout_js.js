"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseLayout: () => (/* binding */ BaseLayout),\n/* harmony export */   dim1: () => (/* binding */ dim1),\n/* harmony export */   dim2: () => (/* binding */ dim2),\n/* harmony export */   pos1: () => (/* binding */ pos1),\n/* harmony export */   pos2: () => (/* binding */ pos2)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nfunction dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nfunction dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nfunction pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nfunction pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nclass BaseLayout {\n  constructor(hostSink, config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(() => this.config = config || this._defaultConfig);\n  }\n  get _defaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(items) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize() {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n  set pin(options) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n  get pin() {\n    if (this._pin !== null) {\n      const {\n        index,\n        block\n      } = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block\n      };\n    }\n    return null;\n  }\n  _clampScrollPosition(val) {\n    return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n  }\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n  _updateLayout() {\n    // Override\n  }\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {\n        index,\n        block\n      } = this.pin;\n      this._scrollPosition = this._calculateScrollIntoViewPosition({\n        index,\n        block: block || 'start'\n      }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  _calculateScrollIntoViewPosition(options) {\n    const {\n      block\n    } = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n  getScrollIntoViewCoordinates(options) {\n    return {\n      [this._positionDim]: this._calculateScrollIntoViewPosition(options)\n    };\n  }\n  _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned'\n    });\n  }\n  _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    });\n  }\n  _sendStateChangedMessage() {\n    const childPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null\n      },\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible\n      },\n      childPositions\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n  /**\n   * Number of items to display.\n   */\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({\n          emit: true\n        });\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n    let lastVisible = this._last;\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7QUF5QkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUF3SEE7QUF2SEE7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7OztBQUdBO0FBRUE7OztBQUdBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7QUFHQTtBQUVBO0FBRUE7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7O0FBR0E7QUFFQTs7OztBQUlBO0FBRUE7Ozs7QUFJQTtBQUVBOzs7QUFHQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBd0JBO0FBQ0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7O0FBR0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBT0E7O0FBR0E7QUFDQTtBQUtBOztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vLi4vc3JjL2xheW91dHMvc2hhcmVkL0Jhc2VMYXlvdXQudHM/NmMxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHtcbiAgTGF5b3V0LFxuICBDaGlsZFBvc2l0aW9ucyxcbiAgUG9zaXRpb25zLFxuICBTY3JvbGxEaXJlY3Rpb24sXG4gIFNpemUsXG4gIGRpbWVuc2lvbixcbiAgcG9zaXRpb24sXG4gIFBpbk9wdGlvbnMsXG4gIFNjcm9sbFRvQ29vcmRpbmF0ZXMsXG4gIEJhc2VMYXlvdXRDb25maWcsXG4gIFN0YXRlQ2hhbmdlZE1lc3NhZ2UsXG4gIExheW91dEhvc3RTaW5rLFxufSBmcm9tICcuL0xheW91dC5qcyc7XG5cbnR5cGUgVXBkYXRlVmlzaWJsZUluZGljZXNPcHRpb25zID0ge1xuICBlbWl0PzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBkaW0xKGRpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uKTogZGltZW5zaW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGltMihkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IGRpbWVuc2lvbiB7XG4gIHJldHVybiBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvczEoZGlyZWN0aW9uOiBTY3JvbGxEaXJlY3Rpb24pOiBwb3NpdGlvbiB7XG4gIHJldHVybiBkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JyA6ICd0b3AnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9zMihkaXJlY3Rpb246IFNjcm9sbERpcmVjdGlvbik6IHBvc2l0aW9uIHtcbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3RvcCcgOiAnbGVmdCc7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlTGF5b3V0PEMgZXh0ZW5kcyBCYXNlTGF5b3V0Q29uZmlnPiBpbXBsZW1lbnRzIExheW91dCB7XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBzZXQgdmlld3BvcnQgc2Nyb2xsIHBvc2l0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSBfbGF0ZXN0Q29vcmRzOiBQb3NpdGlvbnMgPSB7bGVmdDogMCwgdG9wOiAwfTtcblxuICAvKipcbiAgICogU2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByaXZhdGUgX2RpcmVjdGlvbjogU2Nyb2xsRGlyZWN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIERpbWVuc2lvbnMgb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgcHJpdmF0ZSBfdmlld3BvcnRTaXplOiBTaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuXG4gIHB1YmxpYyB0b3RhbFNjcm9sbFNpemU6IFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XG5cbiAgcHVibGljIG9mZnNldFdpdGhpblNjcm9sbGVyOiBQb3NpdGlvbnMgPSB7bGVmdDogMCwgdG9wOiAwfTtcblxuICAvKipcbiAgICogRmxhZyBmb3IgZGVib3VuY2luZyBhc3luY2hyb25vdXMgcmVmbG93IHJlcXVlc3RzLlxuICAgKi9cbiAgcHJpdmF0ZSBfcGVuZGluZ1JlZmxvdyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3BlbmRpbmdMYXlvdXRVcGRhdGUgPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgX3BpbjogUGluT3B0aW9ucyB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByb3RlY3RlZCBfZmlyc3RWaXNpYmxlID0gMDtcblxuICAvKipcbiAgICogVGhlIGluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByb3RlY3RlZCBfbGFzdFZpc2libGUgPSAwO1xuXG4gIC8qKlxuICAgKiBQaXhlbCBvZmZzZXQgaW4gdGhlIHNjcm9sbCBkaXJlY3Rpb24gb2YgdGhlIGZpcnN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9waHlzaWNhbE1pbiA9IDA7XG5cbiAgLyoqXG4gICAqIFBpeGVsIG9mZnNldCBpbiB0aGUgc2Nyb2xsIGRpcmVjdGlvbiBvZiB0aGUgbGFzdCBjaGlsZC5cbiAgICovXG4gIHByb3RlY3RlZCBfcGh5c2ljYWxNYXggPSAwO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgZmlyc3QgY2hpbGQuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2ZpcnN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGNoaWxkLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9sYXN0ID0gLTE7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBpbiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBfc2l6ZURpbTogZGltZW5zaW9uID0gJ2hlaWdodCc7XG5cbiAgLyoqXG4gICAqIExlbmd0aCBpbiB0aGUgbm9uLXNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBwcm90ZWN0ZWQgX3NlY29uZGFyeVNpemVEaW06IGRpbWVuc2lvbiA9ICd3aWR0aCc7XG5cbiAgLyoqXG4gICAqIFBvc2l0aW9uIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9wb3NpdGlvbkRpbTogcG9zaXRpb24gPSAndG9wJztcblxuICAvKipcbiAgICogUG9zaXRpb24gaW4gdGhlIG5vbi1zY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zZWNvbmRhcnlQb3NpdGlvbkRpbTogcG9zaXRpb24gPSAnbGVmdCc7XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgc2Nyb2xsIG9mZnNldCBpbiBwaXhlbHMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3Njcm9sbFBvc2l0aW9uID0gMDtcblxuICAvKipcbiAgICogRGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgc2Nyb2xsIG9mZnNldCBhbmQgc2Nyb2xsIG9mZnNldCBjYWxjdWxhdGVkIGR1ZVxuICAgKiB0byBhIHJlZmxvdy5cbiAgICovXG4gIHByb3RlY3RlZCBfc2Nyb2xsRXJyb3IgPSAwO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2YgaXRlbXMgdGhhdCBjb3VsZCBwb3NzaWJseSBiZSBkaXNwbGF5ZWQuIFVzZWQgdG8gaGVscFxuICAgKiBjYWxjdWxhdGUgdGhlIHNjcm9sbCBzaXplLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9pdGVtczogdW5rbm93bltdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSB0b3RhbCAoZXN0aW1hdGVkKSBsZW5ndGggb2YgYWxsIGl0ZW1zIGluIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zY3JvbGxTaXplID0gMTtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIHBpeGVscyBiZXlvbmQgdGhlIHZpZXdwb3J0IHRvIHN0aWxsIGluY2x1ZGVcbiAgICogaW4gdGhlIGFjdGl2ZSByYW5nZSBvZiBpdGVtcy5cbiAgICovXG4gIC8vIFRPRE8gKGdyYXlub3J0b24pOiBQcm9iYWJseSB3YW50IHRvIG1ha2UgdGhpcyBzb21ldGhpbmcgd2UgY2FsY3VsYXRlIGJhc2VkXG4gIC8vIG9uIHZpZXdwb3J0IHNpemUsIGl0ZW0gc2l6ZSwgb3RoZXIgZmFjdG9ycywgcG9zc2libHkgc3RpbGwgd2l0aCBhIGRpYWwgb2Ygc29tZSBraW5kXG4gIHByb3RlY3RlZCBfb3ZlcmhhbmcgPSAxMDAwO1xuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gZGVsaXZlciBtZXNzYWdlcyAoZS5nLiBzdGF0ZUNoYW5nZWQsIHVucGlubmVkKSB0byBob3N0XG4gICAqL1xuICBwcml2YXRlIF9ob3N0U2luazogTGF5b3V0SG9zdFNpbms7XG5cbiAgcHJvdGVjdGVkIGdldCBfZGVmYXVsdENvbmZpZygpOiBDIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgIH0gYXMgQztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGhvc3RTaW5rOiBMYXlvdXRIb3N0U2luaywgY29uZmlnPzogQykge1xuICAgIHRoaXMuX2hvc3RTaW5rID0gaG9zdFNpbms7XG4gICAgLy8gRGVsYXkgc2V0dGluZyBjb25maWcgc28gdGhhdCBzdWJjbGFzc2VzIGRvIHNldHVwIHdvcmsgZmlyc3RcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+ICh0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB0aGlzLl9kZWZhdWx0Q29uZmlnKSk7XG4gIH1cblxuICBzZXQgY29uZmlnKGNvbmZpZzogQykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZGVmYXVsdENvbmZpZywgY29uZmlnKSk7XG4gIH1cblxuICBnZXQgY29uZmlnKCk6IEMge1xuICAgIHJldHVybiB7XG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgIH0gYXMgQztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIGluZGV4IG9mIGNoaWxkcmVuICsgMSwgdG8gaGVscCBlc3RpbWF0ZSB0b3RhbCBoZWlnaHQgb2YgdGhlIHNjcm9sbFxuICAgKiBzcGFjZS5cbiAgICovXG4gIGdldCBpdGVtcygpOiB1bmtub3duW10ge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgfVxuICBzZXQgaXRlbXMoaXRlbXM6IHVua25vd25bXSkge1xuICAgIGlmIChpdGVtcyAhPT0gdGhpcy5faXRlbXMpIHtcbiAgICAgIHRoaXMuX2l0ZW1zID0gaXRlbXM7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmltYXJ5IHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAqL1xuICBnZXQgZGlyZWN0aW9uKCk6IFNjcm9sbERpcmVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbiE7XG4gIH1cbiAgc2V0IGRpcmVjdGlvbihkaXIpIHtcbiAgICAvLyBGb3JjZSBpdCB0byBiZSBlaXRoZXIgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbC5cbiAgICBkaXIgPSBkaXIgPT09ICdob3Jpem9udGFsJyA/IGRpciA6ICd2ZXJ0aWNhbCc7XG4gICAgaWYgKGRpciAhPT0gdGhpcy5fZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXI7XG4gICAgICB0aGlzLl9zaXplRGltID0gZGlyID09PSAnaG9yaXpvbnRhbCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICB0aGlzLl9zZWNvbmRhcnlTaXplRGltID0gZGlyID09PSAnaG9yaXpvbnRhbCcgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgICB0aGlzLl9wb3NpdGlvbkRpbSA9IGRpciA9PT0gJ2hvcml6b250YWwnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB0aGlzLl9zZWNvbmRhcnlQb3NpdGlvbkRpbSA9IGRpciA9PT0gJ2hvcml6b250YWwnID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICB0aGlzLl90cmlnZ2VyUmVmbG93KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlaWdodCBhbmQgd2lkdGggb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgZ2V0IHZpZXdwb3J0U2l6ZSgpOiBTaXplIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplO1xuICB9XG4gIHNldCB2aWV3cG9ydFNpemUoZGltcykge1xuICAgIGNvbnN0IHtfdmlld0RpbTEsIF92aWV3RGltMn0gPSB0aGlzO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5fdmlld3BvcnRTaXplLCBkaW1zKTtcbiAgICBpZiAoX3ZpZXdEaW0yICE9PSB0aGlzLl92aWV3RGltMikge1xuICAgICAgLy8gdGhpcy5fdmlld0RpbTJDaGFuZ2VkKCk7XG4gICAgICB0aGlzLl9zY2hlZHVsZUxheW91dFVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAoX3ZpZXdEaW0xICE9PSB0aGlzLl92aWV3RGltMSkge1xuICAgICAgdGhpcy5fY2hlY2tUaHJlc2hvbGRzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbCBvZmZzZXQgb2YgdGhlIHZpZXdwb3J0LlxuICAgKi9cbiAgZ2V0IHZpZXdwb3J0U2Nyb2xsKCk6IFBvc2l0aW9ucyB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVzdENvb3JkcztcbiAgfVxuICBzZXQgdmlld3BvcnRTY3JvbGwoY29vcmRzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9sYXRlc3RDb29yZHMsIGNvb3Jkcyk7XG4gICAgY29uc3Qgb2xkUG9zID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9sYXRlc3RDb29yZHNbdGhpcy5fcG9zaXRpb25EaW1dO1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGguYWJzKG9sZFBvcyAtIHRoaXMuX3Njcm9sbFBvc2l0aW9uKTtcbiAgICBpZiAoY2hhbmdlID49IDEpIHtcbiAgICAgIHRoaXMuX2NoZWNrVGhyZXNob2xkcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcmVmbG93IGlmIG9uZSBoYXMgYmVlbiBzY2hlZHVsZWQuXG4gICAqL1xuICByZWZsb3dJZk5lZWRlZChmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKGZvcmNlIHx8IHRoaXMuX3BlbmRpbmdSZWZsb3cpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZWZsb3cgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlZmxvdygpO1xuICAgIH1cbiAgfVxuXG4gIHNldCBwaW4ob3B0aW9uczogUGluT3B0aW9ucyB8IG51bGwpIHtcbiAgICB0aGlzLl9waW4gPSBvcHRpb25zO1xuICAgIHRoaXMuX3RyaWdnZXJSZWZsb3coKTtcbiAgfVxuXG4gIGdldCBwaW4oKSB7XG4gICAgaWYgKHRoaXMuX3BpbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge2luZGV4LCBibG9ja30gPSB0aGlzLl9waW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMuaXRlbXMubGVuZ3RoIC0gMSkpLFxuICAgICAgICBibG9jayxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2NsYW1wU2Nyb2xsUG9zaXRpb24odmFsOiBudW1iZXIpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAtdGhpcy5vZmZzZXRXaXRoaW5TY3JvbGxlclt0aGlzLl9wb3NpdGlvbkRpbV0sXG4gICAgICBNYXRoLm1pbih2YWwsIHRoaXMudG90YWxTY3JvbGxTaXplW2RpbTEodGhpcy5kaXJlY3Rpb24pXSAtIHRoaXMuX3ZpZXdEaW0xKVxuICAgICk7XG4gIH1cblxuICB1bnBpbigpIHtcbiAgICBpZiAodGhpcy5fcGluICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9zZW5kVW5waW5uZWRNZXNzYWdlKCk7XG4gICAgICB0aGlzLl9waW4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRvcCBhbmQgbGVmdCBwb3NpdGlvbmluZyBvZiB0aGUgaXRlbSBhdCBpZHguXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldEl0ZW1Qb3NpdGlvbihpZHg6IG51bWJlcik6IFBvc2l0aW9ucztcblxuICAvKipcbiAgICogVXBkYXRlIF9maXJzdCBhbmQgX2xhc3QgYmFzZWQgb24gaXRlbXMgdGhhdCBzaG91bGQgYmUgaW4gdGhlIGN1cnJlbnRcbiAgICogcmFuZ2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX2dldEFjdGl2ZUl0ZW1zKCk6IHZvaWQ7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IF9nZXRJdGVtU2l6ZShfaWR4OiBudW1iZXIpOiBTaXplO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIChwcmVjaXNlbHkgb3IgYnkgZXN0aW1hdGluZywgaWYgbmVlZGVkKSB0aGUgdG90YWwgbGVuZ3RoIG9mIGFsbCBpdGVtcyBpblxuICAgKiB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbiwgaW5jbHVkaW5nIHNwYWNpbmcsIGNhY2hpbmcgdGhlIHZhbHVlIGluIHRoZSBgX3Njcm9sbFNpemVgIGZpZWxkLlxuICAgKlxuICAgKiBTaG91bGQgcmV0dXJuIGEgbWluaW11bSB2YWx1ZSBvZiAxIHRvIGVuc3VyZSBhdCBsZWFzdCBvbmUgaXRlbSBpcyByZW5kZXJlZC5cbiAgICogVE9ETyAoZ3JheW5vcnRvbik6IFBvc3NpYmx5IG5vIGxvbmdlciByZXF1aXJlZCwgYnV0IGxlYXZpbmcgaGVyZSB1bnRpbCBpdCBjYW4gYmUgdmVyaWZpZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgX3VwZGF0ZVNjcm9sbFNpemUoKTogdm9pZDtcblxuICBwcm90ZWN0ZWQgX3VwZGF0ZUxheW91dCgpOiB2b2lkIHtcbiAgICAvLyBPdmVycmlkZVxuICB9XG5cbiAgLy8gcHJvdGVjdGVkIF92aWV3RGltMkNoYW5nZWQoKTogdm9pZCB7XG4gIC8vICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCwgd2hpY2hldmVyIGNvcnJlc3BvbmRzIHRvIHRoZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldCBfdmlld0RpbTEoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplW3RoaXMuX3NpemVEaW1dO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIHZpZXdwb3J0LCB3aGljaGV2ZXIgZG9lcyBOT1QgY29ycmVzcG9uZCB0byB0aGUgc2Nyb2xsaW5nIGRpcmVjdGlvbi5cbiAgICovXG4gIHByb3RlY3RlZCBnZXQgX3ZpZXdEaW0yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2l6ZVt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVSZWZsb3coKSB7XG4gICAgdGhpcy5fcGVuZGluZ1JlZmxvdyA9IHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NjaGVkdWxlTGF5b3V0VXBkYXRlKCkge1xuICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMuX3NjaGVkdWxlUmVmbG93KCk7XG4gIH1cblxuICAvLyBGb3IgdHJpZ2dlcmluZyBhIHJlZmxvdyBiYXNlZCBvbiBpbmNvbWluZyBjaGFuZ2VzIHRvXG4gIC8vIHRoZSBsYXlvdXQgY29uZmlnLlxuICBwcm90ZWN0ZWQgX3RyaWdnZXJSZWZsb3coKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVMYXlvdXRVcGRhdGUoKTtcbiAgICAvLyBUT0RPIGdyYXlub3J0b25AOiByZWZsb3dJZk5lZWRlZCgpIGlzbid0IHJlYWxseSBzdXBwb3NlZFxuICAgIC8vIHRvIGJlIGNhbGxlZCBpbnRlcm5hbGx5LiBBZGRyZXNzIGluIGxhcmdlciBjbGVhbnVwXG4gICAgLy8gb2YgdmlydHVhbGl6ZXIgLyBsYXlvdXQgaW50ZXJhY3Rpb24gcGF0dGVybi5cbiAgICAvLyB0aGlzLnJlZmxvd0lmTmVlZGVkKHRydWUpO1xuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy5yZWZsb3dJZk5lZWRlZCgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVmbG93KCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nTGF5b3V0VXBkYXRlKSB7XG4gICAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICAgIHRoaXMuX3BlbmRpbmdMYXlvdXRVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlU2Nyb2xsU2l6ZSgpO1xuICAgIHRoaXMuX3NldFBvc2l0aW9uRnJvbVBpbigpO1xuICAgIHRoaXMuX2dldEFjdGl2ZUl0ZW1zKCk7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJsZUluZGljZXMoKTtcbiAgICB0aGlzLl9zZW5kU3RhdGVDaGFuZ2VkTWVzc2FnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGFyZSBzdXBwb3NlZCB0byBiZSBwaW5uZWQgdG8gYSBwYXJ0aWN1bGFyXG4gICAqIGl0ZW0gb3Igc2V0IG9mIGNvb3JkaW5hdGVzLCB3ZSBzZXQgYF9zY3JvbGxQb3NpdGlvbmBcbiAgICogYWNjb3JkaW5nbHkgYW5kIGFkanVzdCBgX3Njcm9sbEVycm9yYCBhcyBuZWVkZWRcbiAgICogc28gdGhhdCB0aGUgdmlydHVhbGl6ZXIgY2FuIGtlZXAgdGhlIHNjcm9sbFxuICAgKiBwb3NpdGlvbiBpbiB0aGUgRE9NIGluIHN5bmNcbiAgICovXG4gIHByb3RlY3RlZCBfc2V0UG9zaXRpb25Gcm9tUGluKCkge1xuICAgIGlmICh0aGlzLnBpbiAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFzdFNjcm9sbFBvc2l0aW9uID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgICBjb25zdCB7aW5kZXgsIGJsb2NrfSA9IHRoaXMucGluO1xuICAgICAgdGhpcy5fc2Nyb2xsUG9zaXRpb24gPVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVTY3JvbGxJbnRvVmlld1Bvc2l0aW9uKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBibG9jazogYmxvY2sgfHwgJ3N0YXJ0JyxcbiAgICAgICAgfSkgLSB0aGlzLm9mZnNldFdpdGhpblNjcm9sbGVyW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gbGFzdFNjcm9sbFBvc2l0aW9uIC0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGNvb3JkaW5hdGVzIHRvIHNjcm9sbCB0bywgZ2l2ZW5cbiAgICogYSByZXF1ZXN0IHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCBhdCBhIHNwZWNpZmljXG4gICAqIGluZGV4LlxuICAgKlxuICAgKiBTdXBwb3J0cyB0aGUgc2FtZSBwb3NpdGlvbmluZyBvcHRpb25zIChgc3RhcnRgLFxuICAgKiBgY2VudGVyYCwgYGVuZGAsIGBuZWFyZXN0YCkgYXMgdGhlIHN0YW5kYXJkXG4gICAqIGBFbGVtZW50LnNjcm9sbEludG9WaWV3KClgIG1ldGhvZCwgYnV0IGN1cnJlbnRseVxuICAgKiBvbmx5IGNvbnNpZGVycyB0aGUgcHJvdmlkZWQgdmFsdWUgaW4gdGhlIGBibG9ja2BcbiAgICogZGltZW5zaW9uLCBzaW5jZSB3ZSBkb24ndCB5ZXQgaGF2ZSBhbnkgbGF5b3V0c1xuICAgKiB0aGF0IHN1cHBvcnQgdmlydHVhbGl6YXRpb24gaW4gdHdvIGRpbWVuc2lvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2NhbGN1bGF0ZVNjcm9sbEludG9WaWV3UG9zaXRpb24ob3B0aW9uczogUGluT3B0aW9ucykge1xuICAgIGNvbnN0IHtibG9ja30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5taW4odGhpcy5pdGVtcy5sZW5ndGgsIE1hdGgubWF4KDAsIG9wdGlvbnMuaW5kZXgpKTtcbiAgICBjb25zdCBpdGVtU3RhcnRQb3NpdGlvbiA9IHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpbmRleClbdGhpcy5fcG9zaXRpb25EaW1dO1xuICAgIGxldCBzY3JvbGxQb3NpdGlvbiA9IGl0ZW1TdGFydFBvc2l0aW9uO1xuICAgIGlmIChibG9jayAhPT0gJ3N0YXJ0Jykge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSB0aGlzLl9nZXRJdGVtU2l6ZShpbmRleClbdGhpcy5fc2l6ZURpbV07XG4gICAgICBpZiAoYmxvY2sgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHNjcm9sbFBvc2l0aW9uID1cbiAgICAgICAgICBpdGVtU3RhcnRQb3NpdGlvbiAtIDAuNSAqIHRoaXMuX3ZpZXdEaW0xICsgMC41ICogaXRlbVNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtRW5kUG9zaXRpb24gPSBpdGVtU3RhcnRQb3NpdGlvbiAtIHRoaXMuX3ZpZXdEaW0xICsgaXRlbVNpemU7XG4gICAgICAgIGlmIChibG9jayA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICBzY3JvbGxQb3NpdGlvbiA9IGl0ZW1FbmRQb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBibG9jayA9PT0gJ25lYXJlc3QnXG4gICAgICAgICAgY29uc3QgY3VycmVudFNjcm9sbFBvc2l0aW9uID0gdGhpcy5fc2Nyb2xsUG9zaXRpb247XG4gICAgICAgICAgc2Nyb2xsUG9zaXRpb24gPVxuICAgICAgICAgICAgTWF0aC5hYnMoY3VycmVudFNjcm9sbFBvc2l0aW9uIC0gaXRlbVN0YXJ0UG9zaXRpb24pIDxcbiAgICAgICAgICAgIE1hdGguYWJzKGN1cnJlbnRTY3JvbGxQb3NpdGlvbiAtIGl0ZW1FbmRQb3NpdGlvbilcbiAgICAgICAgICAgICAgPyBpdGVtU3RhcnRQb3NpdGlvblxuICAgICAgICAgICAgICA6IGl0ZW1FbmRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzY3JvbGxQb3NpdGlvbiArPSB0aGlzLm9mZnNldFdpdGhpblNjcm9sbGVyW3RoaXMuX3Bvc2l0aW9uRGltXTtcbiAgICByZXR1cm4gdGhpcy5fY2xhbXBTY3JvbGxQb3NpdGlvbihzY3JvbGxQb3NpdGlvbik7XG4gIH1cblxuICBwdWJsaWMgZ2V0U2Nyb2xsSW50b1ZpZXdDb29yZGluYXRlcyhcbiAgICBvcHRpb25zOiBQaW5PcHRpb25zXG4gICk6IFNjcm9sbFRvQ29vcmRpbmF0ZXMge1xuICAgIHJldHVybiB7XG4gICAgICBbdGhpcy5fcG9zaXRpb25EaW0gYXMgcG9zaXRpb25dOlxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVTY3JvbGxJbnRvVmlld1Bvc2l0aW9uKG9wdGlvbnMpLFxuICAgIH0gYXMgU2Nyb2xsVG9PcHRpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2VuZFVucGlubmVkTWVzc2FnZSgpIHtcbiAgICB0aGlzLl9ob3N0U2luayh7XG4gICAgICB0eXBlOiAndW5waW5uZWQnLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2VuZFZpc2liaWxpdHlDaGFuZ2VkTWVzc2FnZSgpIHtcbiAgICB0aGlzLl9ob3N0U2luayh7XG4gICAgICB0eXBlOiAndmlzaWJpbGl0eUNoYW5nZWQnLFxuICAgICAgZmlyc3RWaXNpYmxlOiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICBsYXN0VmlzaWJsZTogdGhpcy5fbGFzdFZpc2libGUsXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NlbmRTdGF0ZUNoYW5nZWRNZXNzYWdlKCkge1xuICAgIGNvbnN0IGNoaWxkUG9zaXRpb25zOiBDaGlsZFBvc2l0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBpZiAodGhpcy5fZmlyc3QgIT09IC0xICYmIHRoaXMuX2xhc3QgIT09IC0xKSB7XG4gICAgICBmb3IgKGxldCBpZHggPSB0aGlzLl9maXJzdDsgaWR4IDw9IHRoaXMuX2xhc3Q7IGlkeCsrKSB7XG4gICAgICAgIGNoaWxkUG9zaXRpb25zLnNldChpZHgsIHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihpZHgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZTogU3RhdGVDaGFuZ2VkTWVzc2FnZSA9IHtcbiAgICAgIHR5cGU6ICdzdGF0ZUNoYW5nZWQnLFxuICAgICAgc2Nyb2xsU2l6ZToge1xuICAgICAgICBbdGhpcy5fc2l6ZURpbV06IHRoaXMuX3Njcm9sbFNpemUsXG4gICAgICAgIFt0aGlzLl9zZWNvbmRhcnlTaXplRGltXTogbnVsbCxcbiAgICAgIH0gYXMgU2l6ZSxcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIGZpcnN0OiB0aGlzLl9maXJzdCxcbiAgICAgICAgbGFzdDogdGhpcy5fbGFzdCxcbiAgICAgICAgZmlyc3RWaXNpYmxlOiB0aGlzLl9maXJzdFZpc2libGUsXG4gICAgICAgIGxhc3RWaXNpYmxlOiB0aGlzLl9sYXN0VmlzaWJsZSxcbiAgICAgIH0sXG4gICAgICBjaGlsZFBvc2l0aW9ucyxcbiAgICB9O1xuICAgIGlmICh0aGlzLl9zY3JvbGxFcnJvcikge1xuICAgICAgbWVzc2FnZS5zY3JvbGxFcnJvciA9IHtcbiAgICAgICAgW3RoaXMuX3Bvc2l0aW9uRGltXTogdGhpcy5fc2Nyb2xsRXJyb3IsXG4gICAgICAgIFt0aGlzLl9zZWNvbmRhcnlQb3NpdGlvbkRpbV06IDAsXG4gICAgICB9IGFzIFBvc2l0aW9ucztcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gMDtcbiAgICB9XG4gICAgdGhpcy5faG9zdFNpbmsobWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIHRvIGRpc3BsYXkuXG4gICAqL1xuICBwcml2YXRlIGdldCBfbnVtKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSB8fCB0aGlzLl9sYXN0ID09PSAtMSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9sYXN0IC0gdGhpcy5fZmlyc3QgKyAxO1xuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tUaHJlc2hvbGRzKCkge1xuICAgIGlmICgodGhpcy5fdmlld0RpbTEgPT09IDAgJiYgdGhpcy5fbnVtID4gMCkgfHwgdGhpcy5fcGluICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlZmxvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1heCgwLCB0aGlzLl9zY3JvbGxQb3NpdGlvbiAtIHRoaXMuX292ZXJoYW5nKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKFxuICAgICAgICB0aGlzLl9zY3JvbGxTaXplLFxuICAgICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiArIHRoaXMuX3ZpZXdEaW0xICsgdGhpcy5fb3ZlcmhhbmdcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5fcGh5c2ljYWxNaW4gPiBtaW4gfHwgdGhpcy5fcGh5c2ljYWxNYXggPCBtYXgpIHtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVSZWZsb3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpc2libGVJbmRpY2VzKHtlbWl0OiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGluZGljZXMgb2YgdGhlIGZpcnN0IGFuZCBsYXN0IGl0ZW1zIHRvIGludGVyc2VjdCB0aGUgdmlld3BvcnQuXG4gICAqIEVtaXQgYSB2aXNpYmxlaW5kaWNlc2NoYW5nZSBldmVudCB3aGVuIGVpdGhlciBpbmRleCBjaGFuZ2VzLlxuICAgKi9cbiAgcHJvdGVjdGVkIF91cGRhdGVWaXNpYmxlSW5kaWNlcyhvcHRpb25zPzogVXBkYXRlVmlzaWJsZUluZGljZXNPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2ZpcnN0ID09PSAtMSB8fCB0aGlzLl9sYXN0ID09PSAtMSkgcmV0dXJuO1xuXG4gICAgbGV0IGZpcnN0VmlzaWJsZSA9IHRoaXMuX2ZpcnN0O1xuICAgIHdoaWxlIChcbiAgICAgIGZpcnN0VmlzaWJsZSA8IHRoaXMuX2xhc3QgJiZcbiAgICAgIE1hdGgucm91bmQoXG4gICAgICAgIHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihmaXJzdFZpc2libGUpW3RoaXMuX3Bvc2l0aW9uRGltXSArXG4gICAgICAgICAgdGhpcy5fZ2V0SXRlbVNpemUoZmlyc3RWaXNpYmxlKVt0aGlzLl9zaXplRGltXVxuICAgICAgKSA8PSBNYXRoLnJvdW5kKHRoaXMuX3Njcm9sbFBvc2l0aW9uKVxuICAgICkge1xuICAgICAgZmlyc3RWaXNpYmxlKys7XG4gICAgfVxuXG4gICAgbGV0IGxhc3RWaXNpYmxlID0gdGhpcy5fbGFzdDtcbiAgICB3aGlsZSAoXG4gICAgICBsYXN0VmlzaWJsZSA+IHRoaXMuX2ZpcnN0ICYmXG4gICAgICBNYXRoLnJvdW5kKHRoaXMuX2dldEl0ZW1Qb3NpdGlvbihsYXN0VmlzaWJsZSlbdGhpcy5fcG9zaXRpb25EaW1dKSA+PVxuICAgICAgICBNYXRoLnJvdW5kKHRoaXMuX3Njcm9sbFBvc2l0aW9uICsgdGhpcy5fdmlld0RpbTEpXG4gICAgKSB7XG4gICAgICBsYXN0VmlzaWJsZS0tO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGZpcnN0VmlzaWJsZSAhPT0gdGhpcy5fZmlyc3RWaXNpYmxlIHx8XG4gICAgICBsYXN0VmlzaWJsZSAhPT0gdGhpcy5fbGFzdFZpc2libGVcbiAgICApIHtcbiAgICAgIHRoaXMuX2ZpcnN0VmlzaWJsZSA9IGZpcnN0VmlzaWJsZTtcbiAgICAgIHRoaXMuX2xhc3RWaXNpYmxlID0gbGFzdFZpc2libGU7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVtaXQpIHtcbiAgICAgICAgdGhpcy5fc2VuZFZpc2liaWxpdHlDaGFuZ2VkTWVzc2FnZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js\n");

/***/ })

}]);