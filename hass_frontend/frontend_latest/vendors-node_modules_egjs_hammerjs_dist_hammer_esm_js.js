"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_egjs_hammerjs_dist_hammer_esm_js"],{

/***/ "./node_modules/@egjs/hammerjs/dist/hammer.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/@egjs/hammerjs/dist/hammer.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttrRecognizer: () => (/* binding */ AttrRecognizer),\n/* harmony export */   DIRECTION_ALL: () => (/* binding */ DIRECTION_ALL),\n/* harmony export */   DIRECTION_DOWN: () => (/* binding */ DIRECTION_DOWN),\n/* harmony export */   DIRECTION_HORIZONTAL: () => (/* binding */ DIRECTION_HORIZONTAL),\n/* harmony export */   DIRECTION_LEFT: () => (/* binding */ DIRECTION_LEFT),\n/* harmony export */   DIRECTION_NONE: () => (/* binding */ DIRECTION_NONE),\n/* harmony export */   DIRECTION_RIGHT: () => (/* binding */ DIRECTION_RIGHT),\n/* harmony export */   DIRECTION_UP: () => (/* binding */ DIRECTION_UP),\n/* harmony export */   DIRECTION_VERTICAL: () => (/* binding */ DIRECTION_VERTICAL),\n/* harmony export */   INPUT_CANCEL: () => (/* binding */ INPUT_CANCEL),\n/* harmony export */   INPUT_END: () => (/* binding */ INPUT_END),\n/* harmony export */   INPUT_MOVE: () => (/* binding */ INPUT_MOVE),\n/* harmony export */   INPUT_START: () => (/* binding */ INPUT_START),\n/* harmony export */   Input: () => (/* binding */ Input),\n/* harmony export */   Manager: () => (/* binding */ Manager),\n/* harmony export */   MouseInput: () => (/* binding */ MouseInput),\n/* harmony export */   Pan: () => (/* binding */ PanRecognizer),\n/* harmony export */   Pinch: () => (/* binding */ PinchRecognizer),\n/* harmony export */   PointerEventInput: () => (/* binding */ PointerEventInput),\n/* harmony export */   Press: () => (/* binding */ PressRecognizer),\n/* harmony export */   Recognizer: () => (/* binding */ Recognizer),\n/* harmony export */   Rotate: () => (/* binding */ RotateRecognizer),\n/* harmony export */   STATE_BEGAN: () => (/* binding */ STATE_BEGAN),\n/* harmony export */   STATE_CANCELLED: () => (/* binding */ STATE_CANCELLED),\n/* harmony export */   STATE_CHANGED: () => (/* binding */ STATE_CHANGED),\n/* harmony export */   STATE_ENDED: () => (/* binding */ STATE_ENDED),\n/* harmony export */   STATE_FAILED: () => (/* binding */ STATE_FAILED),\n/* harmony export */   STATE_POSSIBLE: () => (/* binding */ STATE_POSSIBLE),\n/* harmony export */   STATE_RECOGNIZED: () => (/* binding */ STATE_RECOGNIZED),\n/* harmony export */   SingleTouchInput: () => (/* binding */ SingleTouchInput),\n/* harmony export */   Swipe: () => (/* binding */ SwipeRecognizer),\n/* harmony export */   Tap: () => (/* binding */ TapRecognizer),\n/* harmony export */   TouchAction: () => (/* binding */ TouchAction),\n/* harmony export */   TouchInput: () => (/* binding */ TouchInput),\n/* harmony export */   TouchMouseInput: () => (/* binding */ TouchMouseInput),\n/* harmony export */   addEventListeners: () => (/* binding */ addEventListeners),\n/* harmony export */   assign: () => (/* binding */ assign$1),\n/* harmony export */   bindFn: () => (/* binding */ bindFn),\n/* harmony export */   boolOrFn: () => (/* binding */ boolOrFn),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   defaults: () => (/* binding */ defaults$1),\n/* harmony export */   each: () => (/* binding */ each),\n/* harmony export */   extend: () => (/* binding */ extend),\n/* harmony export */   hasParent: () => (/* binding */ hasParent),\n/* harmony export */   inArray: () => (/* binding */ inArray),\n/* harmony export */   inherit: () => (/* binding */ inherit),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   off: () => (/* binding */ removeEventListeners),\n/* harmony export */   on: () => (/* binding */ addEventListeners),\n/* harmony export */   prefixed: () => (/* binding */ prefixed),\n/* harmony export */   removeEventListeners: () => (/* binding */ removeEventListeners),\n/* harmony export */   splitStr: () => (/* binding */ splitStr),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   uniqueArray: () => (/* binding */ uniqueArray)\n/* harmony export */ });\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\nvar assign$1 = assign;\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n  abs = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n    if (prop in obj) {\n      return prop;\n    }\n    i++;\n  }\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = ('ontouchstart' in win);\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n  if (!obj) {\n    return;\n  }\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction = /*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n  var _proto = TouchAction.prototype;\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n  var x = 0;\n  var y = 0;\n  var i = 0;\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n  if (abs(x) >= abs(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n  var firstInput = session.firstInput,\n    firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input = /*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n  var _proto = Input.prototype;\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n      i++;\n    }\n    return -1;\n  }\n}\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\nvar PointerEventInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n  function PointerEventInput() {\n    var _this;\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n  var _proto = PointerEventInput.prototype;\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n    values[i] = val;\n    i++;\n  }\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n  return results;\n}\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n  function TouchInput() {\n    var _this;\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n  var _proto = TouchInput.prototype;\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n    if (!touches) {\n      return;\n    }\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return TouchInput;\n}(Input);\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n  i = 0;\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n    i++;\n  }\n  if (!changedTargetTouches.length) {\n    return;\n  }\n  return [\n  // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n  function MouseInput() {\n    var _this;\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n  var _proto = MouseInput.prototype;\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n    if (!this.pressed) {\n      return;\n    }\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n    touch = _eventData$changedPoi[0];\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n  return false;\n}\nvar TouchMouseInput = /*#__PURE__*/\nfunction () {\n  var TouchMouseInput = /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n      _this = _Input.call(this, _manager, callback) || this;\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized(_assertThisInitialized(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized(_assertThisInitialized(_this)), inputData)) {\n          return;\n        }\n        _this.callback(manager, inputEvent, inputData);\n      };\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n    return TouchMouseInput;\n  }(Input);\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n  return false;\n}\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer = /*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n  var _proto = Recognizer.prototype;\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n  _proto.reset = function reset() {};\n  return Recognizer;\n}();\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n  function TapRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n  var _proto = TapRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n  _proto.process = function process(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n    return STATE_FAILED;\n  };\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n  var _proto = AttrRecognizer.prototype;\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n      return state | STATE_CHANGED;\n    }\n    return STATE_FAILED;\n  };\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n  function PanRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n  var _proto = PanRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n    return actions;\n  };\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && (\n    // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n  var _proto = SwipeRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n    this.manager.emit(this.options.event, input);\n  };\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = PinchRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer = /*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n  var _proto = RotateRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer = /*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n  function PressRecognizer(options) {\n    var _this;\n    if (options === void 0) {\n      options = {};\n    }\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n  var _proto = PressRecognizer.prototype;\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n  _proto.process = function process(input) {\n    var _this2 = this;\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n    return STATE_FAILED;\n  };\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n  return PressRecognizer;\n}(Recognizer);\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n  if (!element.style) {\n    return;\n  }\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Manager = /*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n  var _proto = Manager.prototype;\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n    var i = 0;\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && (\n      // 1\n      !curRecognizer || recognizer === curRecognizer ||\n      // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n    var recognizers = this.recognizers;\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n    var existing = this.get(recognizer.options.event);\n    if (existing) {\n      this.remove(existing);\n    }\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n    if (!handlers || !handlers.length) {\n      return;\n    }\n    data.type = event;\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n    var i = 0;\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n  return Manager;\n}();\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput = /*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n  function SingleTouchInput() {\n    var _this;\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n  var _proto = SingleTouchInput.prototype;\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n    if (!this.started) {\n      return;\n    }\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n  return SingleTouchInput;\n}(Input);\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n    i++;\n  }\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer = /*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\n//  style loader but by script tag, not by the loader.\n\nvar defaults$1 = Hammer.defaults;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hammer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGVnanMvaGFtbWVyanMvZGlzdC9oYW1tZXIuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQWhCQTtBQURBO0FBb0JBOztBQUdBO0FDL0JBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7O0FDTkE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQ3ZCQTtBQUVBO0FBRUE7O0FBRUE7QUFGQTtBQUlBOztBQ0pBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFJQTtBQUpBO0FBTUE7O0FDZEE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDUkE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUNoQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUpBO0FBT0E7QUFDQTs7Ozs7QUN2QkE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7QUFFQTs7O0FDYkE7Ozs7Ozs7QUFPQTtBQUNBOzs7QUNDQTs7Ozs7OztBQU1BOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTs7Ozs7QUFNQTtBQUNBO0FBZEE7O0FBa0JBO0FBQ0E7QUFuQkE7O0FBdUJBO0FBQ0E7O0FBR0E7OztBQ3RCQTs7Ozs7Ozs7O0FBUUE7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRkE7QUFLQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUtBOzs7O0FBS0E7QUFHQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOzs7OztBQzVIQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FDYkE7Ozs7Ozs7QUFNQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBRkE7OztBQ3pCQTs7Ozs7OztBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOzs7QUNwQkE7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUE7OztBQ2ZBOzs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUNiQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTs7QUFFQTs7QUNoQkE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUZBOztBQU1BO0FBQ0E7OztBQ3ZCQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOzs7QUNQQTs7Ozs7Ozs7O0FBUUE7QUFDQTs7O0FDUkE7Ozs7Ozs7O0FBT0E7QUFDQTs7O0FDTkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVZBOztBQWFBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBUEE7O0FBV0E7QUFDQTtBQURBO0FBR0E7O0FBR0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUdBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTs7QUFHQTtBQUNBOztBQUVBOzs7QUM1RUE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBVkE7OztBQWVBOztBQUdBOztBQUdBO0FBRUE7QUFDQTs7O0FDbENBOzs7Ozs7QUFPQTtBQUNBOzs7QUNOQTs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFEQTs7O0FDUkE7Ozs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBREE7OztBQ1ZBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7OztBQ0hBOzs7Ozs7Ozs7QUFRQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFGQTtBQU1BOzs7Ozs7Ozs7QUFRQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4REE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBOztBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTs7QUFPQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7OztBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFHQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFIQTtBQU1BO0FBcEJBOztBQXdCQTs7QUF4QkE7O0FBNkJBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7O0FBRUE7Ozs7QUF2REE7O0FDN0NBOzs7Ozs7QUFNQTtBQUNBOzs7QUNMQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBOzs7QUFNQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBT0E7Ozs7Ozs7O0FBUUE7OztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7QUFkQTtBQThCQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQURBOztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUJBOztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBOztBQU1BO0FBQ0E7O0FBRUE7O0FBR0E7OztBQUlBO0FBQUE7QUFFQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7Ozs7Ozs7O0FBUUE7OztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7QUFUQTs7QUFhQTs7O0FBSUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7OztBQXBDQTs7QUNaQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBRUE7QUFDQTs7QUFKQTtBQVFBOzs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBR0E7O0FBSUE7O0FBQUE7OztBQUNBOztBQUNBO0FBZUE7QUFDQTtBQUNBO0FBRUE7O0FBSkE7O0FBU0E7QUFDQTtBQURBOzs7QUFNQTtBQS9CQTtBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdDQTtBQUNBO0FBQ0E7OztBQXpDQTtBQUFBOzs7QUNsRUE7Ozs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7QUFEQTtBQUdBOztBQUVBOzs7QUM1QkE7Ozs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FDUEE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FDTEE7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTtBQURBO0FBR0E7O0FBRUE7OztBQ05BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBOztBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBR0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUxBOztBQVNBO0FBQ0E7O0FBR0E7O0FBRUE7O0FBQ0E7QUFoQkE7O0FBb0JBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUNBO0FBRkE7O0FBS0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUFRQTs7O0FBR0E7O0FBR0E7QUFDQTtBQUNBOztBQVJBOztBQWFBO0FBQ0E7O0FBR0E7OztBQUlBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7Ozs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7QUFRQTs7OztBQ2hTQTs7Ozs7Ozs7Ozs7O0FBV0E7OztBQUNBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFHQTtBQUNBOztBQUdBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBVkE7OztBQWVBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBOztBQUdBOzs7QUFJQTtBQUNBOzs7QUFHQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUlBOzs7O0FBSUE7O0FBR0E7O0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQS9GQTs7QUNSQTs7Ozs7OztBQU1BOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQURBO0FBR0E7O0FBRUE7O0FBRUE7OztBQTdDQTs7QUNaQTs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFEQTtBQUdBO0FBREE7QUFHQTs7QUFFQTs7O0FDUkE7Ozs7Ozs7O0FBT0E7OztBQUNBOztBQUFBO0FBQUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFHQTtBQUNBO0FBQUE7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7O0FBRUE7OztBQWhFQTs7QUNmQTs7Ozs7Ozs7QUFPQTs7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFEQTtBQUdBO0FBREE7QUFHQTs7QUFHQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTs7O0FBekNBOztBQ1ZBOzs7Ozs7OztBQU9BOzs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBSUE7QUFDQTs7QUFHQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUF4QkE7O0FDUEE7Ozs7Ozs7O0FBT0E7OztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFJQTtBQUNBOztBQUdBO0FBQ0E7OztBQWZBOztBQ0VBOzs7Ozs7OztBQU9BOzs7QUFDQTs7QUFBQTtBQUFBOzs7QUFFQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFHQTtBQUNBOztBQUdBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUlBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQU9BOztBQUVBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTs7O0FBSUE7QUFDQTtBQURBO0FBR0E7QUFDQTs7OztBQXREQTtBQ1hBOzs7Ozs7OztBQVFBOzs7Ozs7OztBQVNBOzs7Ozs7QUFPQTs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7Ozs7O0FBT0E7Ozs7Ozs7QUFRQTs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7QUFRQTs7Ozs7OztBQVFBOzs7Ozs7OztBQVNBOztBQXBHQTs7Ozs7Ozs7O0FBK0dBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQzdHQTtBQUNBOzs7Ozs7OztBQVNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTs7QUFOQTtBQVNBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBV0E7O0FBQ0E7O0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUpBOzs7Ozs7Ozs7O0FBY0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBRUE7O0FBSEE7O0FBUUE7QUFFQTtBQUNBOzs7O0FBS0E7OztBQUlBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOztBQUNBO0FBSEE7QUFLQTtBQWRBOzs7QUFtQkE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDQTtBQUNBOztBQUdBO0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBRkE7O0FBTUE7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7O0FBR0E7O0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFJQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFDQTs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7O0FBSkE7QUFPQTs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBO0FBSEE7O0FBT0E7QUFFQTs7O0FBSUE7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU9BO0FBQ0E7Ozs7Ozs7O0FBUUE7OztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUFHQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7OztBQUlBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBOzs7QUE3QkE7QUE2Q0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFHQTs7O0FDaEZBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFWQTs7O0FDVEE7Ozs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFUQTs7QUNSQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQURBOztBQ1RBOzs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7QUNqQkE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFEQTs7O0FDa0RBOzs7Ozs7OztBQU9BOztBQUFBOzs7OztBQTZEQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUlBOztBQW5FQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBNERBO0FBQUE7QUE1REE7OztBQ0hBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2Fzc2lnbi5qcz9lNzk5Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy91dGlscy1jb25zdHMuanM/YzcxNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvcHJlZml4ZWQuanM/NjNkMCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvYnJvd3Nlci5qcz81NWZhIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy90b3VjaGFjdGlvbmpzL2dldC10b3VjaGFjdGlvbi1wcm9wcy5qcz8yYzQ4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0cy5qcz9iMzAzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2lucHV0LWNvbnN0cy5qcz8wNDk0Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9lYWNoLmpzPzJmMWUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2Jvb2wtb3ItZm4uanM/MDMwOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvaW4tc3RyLmpzPzY4YTgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3RvdWNoYWN0aW9uanMvY2xlYW4tdG91Y2gtYWN0aW9ucy5qcz8wMjEwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLWNvbnN0cnVjdG9yLmpzPzI3YTEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2hhcy1wYXJlbnQuanM/YTAyYiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtY2VudGVyLmpzP2MzNDkiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvc2ltcGxlLWNsb25lLWlucHV0LWRhdGEuanM/YzJhMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtZGlzdGFuY2UuanM/MDY2ZiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtYW5nbGUuanM/NzIyZCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXRqcy9nZXQtZGlyZWN0aW9uLmpzPzMwNDYiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvY29tcHV0ZS1kZWx0YS14eS5qcz9kOGZjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC12ZWxvY2l0eS5qcz83ZjBlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC1zY2FsZS5qcz8wNTEwIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2dldC1yb3RhdGlvbi5qcz8zYTA3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2NvbXB1dGUtaW50ZXJ2YWwtaW5wdXQtZGF0YS5qcz8yYTJlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2NvbXB1dGUtaW5wdXQtZGF0YS5qcz8zZWM2Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dGpzL2lucHV0LWhhbmRsZXIuanM/ZTI1MiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvc3BsaXQtc3RyLmpzP2Y5NTUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2FkZC1ldmVudC1saXN0ZW5lcnMuanM/MzA4ZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvcmVtb3ZlLWV2ZW50LWxpc3RlbmVycy5qcz9jYzJjIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9nZXQtd2luZG93LWZvci1lbGVtZW50LmpzPzZkN2IiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3IuanM/NGExOSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvaW4tYXJyYXkuanM/MzMzOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXQvcG9pbnRlcmV2ZW50LmpzP2E4NDQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3RvLWFycmF5LmpzPzk4YjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3VuaXF1ZS1hcnJheS5qcz9jNzYzIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dC90b3VjaC5qcz9kZTI3Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dC9tb3VzZS5qcz9iZjY4Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9pbnB1dC90b3VjaG1vdXNlLmpzP2Q0ZjMiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2lucHV0anMvY3JlYXRlLWlucHV0LWluc3RhbmNlLmpzPzY4MTUiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2ludm9rZS1hcnJheS1hcmcuanM/YTFkZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzLmpzP2E2ODIiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL3VuaXF1ZS1pZC5qcz8zMGJlIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVyanMvZ2V0LXJlY29nbml6ZXItYnktbmFtZS1pZi1tYW5hZ2VyLmpzPzkwOGEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJqcy9zdGF0ZS1zdHIuanM/MGRlOCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RydWN0b3IuanM/Y2JhMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvdGFwLmpzP2RkYmQiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL2F0dHJpYnV0ZS5qcz9jMzllIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVyanMvZGlyZWN0aW9uLXN0ci5qcz9jYTI1Iiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9yZWNvZ25pemVycy9wYW4uanM/YWEzMiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvc3dpcGUuanM/YzM1NiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvcGluY2guanM/ZGNmNiIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvcmVjb2duaXplcnMvcm90YXRlLmpzPzc0NjAiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3JlY29nbml6ZXJzL3ByZXNzLmpzPzNjNzgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2RlZmF1bHRzLmpzPzZjNjEiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL21hbmFnZXIuanM/YjkyZSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaW5wdXQvc2luZ2xldG91Y2guanM/MTcxNCIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvdXRpbHMvZGVwcmVjYXRlLmpzP2IxM2UiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2V4dGVuZC5qcz84MGFiIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9tZXJnZS5qcz81NjNkIiwid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy91dGlscy9pbmhlcml0LmpzPzYzM2UiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL3V0aWxzL2JpbmQtZm4uanM/ZTZmNSIsIndlYnBhY2s6Ly9ob21lLWFzc2lzdGFudC1mcm9udGVuZC8uLi9zcmMvaGFtbWVyLmpzPzFjYjgiLCJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi4vc3JjL2luZGV4LmpzPzVhNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJpdmF0ZVxuICogZXh0ZW5kIG9iamVjdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyBpbiBkZXN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIG9uZXMgaW4gc3JjLlxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHsuLi5PYmplY3R9IG9iamVjdHNfdG9fYXNzaWduXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0YXJnZXRcbiAqL1xubGV0IGFzc2lnbjtcbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiAhPT0gJ2Z1bmN0aW9uJykge1xuICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IG5leHRLZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufSBlbHNlIHtcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduOyIsIlxuY29uc3QgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG5jb25zdCBURVNUX0VMRU1FTlQgPSB0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyB7c3R5bGU6IHt9fSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG5jb25zdCBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxuY29uc3QgeyByb3VuZCwgYWJzIH0gPSBNYXRoO1xuY29uc3QgeyBub3cgfSA9IERhdGU7XG5cbmV4cG9ydCB7XG4gICAgVkVORE9SX1BSRUZJWEVTLFxuICAgIFRFU1RfRUxFTUVOVCxcbiAgICBUWVBFX0ZVTkNUSU9OLFxuICAgIHJvdW5kLFxuICAgIGFicyxcbiAgICBub3dcbn07XG4iLCJpbXBvcnQgeyBWRU5ET1JfUFJFRklYRVMgfSBmcm9tICcuL3V0aWxzLWNvbnN0cyc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gIGxldCBwcmVmaXg7XG4gIGxldCBwcm9wO1xuICBsZXQgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cblxubGV0IHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcblx0Ly8gd2luZG93IGlzIHVuZGVmaW5lZCBpbiBub2RlLmpzXG5cdHdpbiA9IHt9O1xufSBlbHNlIHtcblx0d2luID0gd2luZG93O1xufVxuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tbmVzdGVkLXRlcm5hcnkgKi9cblxuZXhwb3J0IHt3aW4gYXMgd2luZG93fTtcbiIsImltcG9ydCBwcmVmaXhlZCBmcm9tICcuLi91dGlscy9wcmVmaXhlZCc7XG5pbXBvcnQgeyBURVNUX0VMRU1FTlQgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IHt3aW5kb3d9IGZyb20gJy4uL2Jyb3dzZXInO1xuXG5leHBvcnQgY29uc3QgUFJFRklYRURfVE9VQ0hfQUNUSU9OID0gcHJlZml4ZWQoVEVTVF9FTEVNRU5ULnN0eWxlLCAndG91Y2hBY3Rpb24nKTtcbmV4cG9ydCBjb25zdCBOQVRJVkVfVE9VQ0hfQUNUSU9OID0gUFJFRklYRURfVE9VQ0hfQUNUSU9OICE9PSB1bmRlZmluZWQ7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgdG91Y2hNYXAgPSB7fTtcbiAgbGV0IGNzc1N1cHBvcnRzID0gd2luZG93LkNTUyAmJiB3aW5kb3cuQ1NTLnN1cHBvcnRzO1xuICBbJ2F1dG8nLCAnbWFuaXB1bGF0aW9uJywgJ3Bhbi15JywgJ3Bhbi14JywgJ3Bhbi14IHBhbi15JywgJ25vbmUnXS5mb3JFYWNoKCh2YWwpID0+IHtcblxuICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICByZXR1cm4gdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luZG93LkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gIH0pO1xuICByZXR1cm4gdG91Y2hNYXA7XG59XG4iLCJpbXBvcnQgZ2V0VG91Y2hBY3Rpb25Qcm9wcyBmcm9tICcuL2dldC10b3VjaGFjdGlvbi1wcm9wcyc7XG5cblxuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG5jb25zdCBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbmNvbnN0IFRPVUNIX0FDVElPTl9BVVRPID0gJ2F1dG8nO1xuY29uc3QgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbmNvbnN0IFRPVUNIX0FDVElPTl9OT05FID0gJ25vbmUnO1xuY29uc3QgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbmNvbnN0IFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG5jb25zdCBUT1VDSF9BQ1RJT05fTUFQID0gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpO1xuXG5leHBvcnQge1xuICBUT1VDSF9BQ1RJT05fQVVUTyxcbiAgVE9VQ0hfQUNUSU9OX0NPTVBVVEUsXG4gIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04sXG4gIFRPVUNIX0FDVElPTl9OT05FLFxuICBUT1VDSF9BQ1RJT05fUEFOX1gsXG4gIFRPVUNIX0FDVElPTl9QQU5fWSxcbiAgVE9VQ0hfQUNUSU9OX01BUFxufTtcbiIsImltcG9ydCBwcmVmaXhlZCBmcm9tICcuLi91dGlscy9wcmVmaXhlZCc7XG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uL2Jyb3dzZXJcIjtcblxuY29uc3QgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG5jb25zdCBTVVBQT1JUX1RPVUNIID0gKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyk7XG5jb25zdCBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luZG93LCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbmNvbnN0IFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbmNvbnN0IElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xuY29uc3QgSU5QVVRfVFlQRV9QRU4gPSAncGVuJztcbmNvbnN0IElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xuY29uc3QgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcblxuY29uc3QgQ09NUFVURV9JTlRFUlZBTCA9IDI1O1xuXG5jb25zdCBJTlBVVF9TVEFSVCA9IDE7XG5jb25zdCBJTlBVVF9NT1ZFID0gMjtcbmNvbnN0IElOUFVUX0VORCA9IDQ7XG5jb25zdCBJTlBVVF9DQU5DRUwgPSA4O1xuXG5jb25zdCBESVJFQ1RJT05fTk9ORSA9IDE7XG5jb25zdCBESVJFQ1RJT05fTEVGVCA9IDI7XG5jb25zdCBESVJFQ1RJT05fUklHSFQgPSA0O1xuY29uc3QgRElSRUNUSU9OX1VQID0gODtcbmNvbnN0IERJUkVDVElPTl9ET1dOID0gMTY7XG5cbmNvbnN0IERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG5jb25zdCBESVJFQ1RJT05fVkVSVElDQUwgPSBESVJFQ1RJT05fVVAgfCBESVJFQ1RJT05fRE9XTjtcbmNvbnN0IERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTDtcblxuY29uc3QgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xuY29uc3QgUFJPUFNfQ0xJRU5UX1hZID0gWydjbGllbnRYJywgJ2NsaWVudFknXTtcblxuZXhwb3J0IHtcbiAgICBNT0JJTEVfUkVHRVgsXG4gICAgU1VQUE9SVF9PTkxZX1RPVUNILFxuICAgIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMsXG4gICAgU1VQUE9SVF9UT1VDSCxcbiAgICBJTlBVVF9UWVBFX0tJTkVDVCxcbiAgICBJTlBVVF9UWVBFX01PVVNFLFxuICAgIElOUFVUX1RZUEVfUEVOLFxuICAgIElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgQ09NUFVURV9JTlRFUlZBTCxcbiAgICBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUwsXG4gICAgRElSRUNUSU9OX05PTkUsXG4gICAgRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgICBESVJFQ1RJT05fVkVSVElDQUwsXG4gICAgRElSRUNUSU9OX0FMTCxcbiAgICBQUk9QU19YWSxcbiAgICBQUk9QU19DTElFTlRfWFlcbn07XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICBsZXQgaTtcblxuICBpZiAoIW9iaikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IG9iai5sZW5ndGgpIHtcbiAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBUWVBFX0ZVTkNUSU9OIH0gZnJvbSAnLi91dGlscy1jb25zdHMnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gVFlQRV9GVU5DVElPTikge1xuICAgIHJldHVybiB2YWwuYXBwbHkoYXJncyA/IGFyZ3NbMF0gfHwgdW5kZWZpbmVkIDogdW5kZWZpbmVkLCBhcmdzKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cbiIsImltcG9ydCBpblN0ciBmcm9tICcuLi91dGlscy9pbi1zdHInO1xuaW1wb3J0IHtcbiAgICBUT1VDSF9BQ1RJT05fTk9ORSxcbiAgICBUT1VDSF9BQ1RJT05fUEFOX1gsXG4gICAgVE9VQ0hfQUNUSU9OX1BBTl9ZLFxuICAgIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04sXG4gICAgVE9VQ0hfQUNUSU9OX0FVVE9cbn0gZnJvbSAnLi90b3VjaGFjdGlvbi1Db25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAvLyBub25lXG4gIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gIH1cblxuICBsZXQgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gIGxldCBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTtcblxuICAvLyBpZiBib3RoIHBhbi14IGFuZCBwYW4teSBhcmUgc2V0IChkaWZmZXJlbnQgcmVjb2duaXplcnNcbiAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gIC8vIHdlIG5lZWQgbm9uZSAoYXMgb3RoZXJ3aXNlIHdpdGggcGFuLXggcGFuLXkgY29tYmluZWQgbm9uZSBvZiB0aGVzZVxuICAvLyByZWNvZ25pemVycyB3aWxsIHdvcmssIHNpbmNlIHRoZSBicm93c2VyIHdvdWxkIGhhbmRsZSBhbGwgcGFubmluZ1xuICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9XG5cbiAgLy8gcGFuLXggT1IgcGFuLXlcbiAgaWYgKGhhc1BhblggfHwgaGFzUGFuWSkge1xuICAgIHJldHVybiBoYXNQYW5YID8gVE9VQ0hfQUNUSU9OX1BBTl9YIDogVE9VQ0hfQUNUSU9OX1BBTl9ZO1xuICB9XG5cbiAgLy8gbWFuaXB1bGF0aW9uXG4gIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OKSkge1xuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICB9XG5cbiAgcmV0dXJuIFRPVUNIX0FDVElPTl9BVVRPO1xufVxuIiwiaW1wb3J0IHtcbiAgICBUT1VDSF9BQ1RJT05fQ09NUFVURSxcbiAgICBUT1VDSF9BQ1RJT05fTUFQLFxuICAgIFRPVUNIX0FDVElPTl9OT05FLFxuICAgIFRPVUNIX0FDVElPTl9QQU5fWCxcbiAgICBUT1VDSF9BQ1RJT05fUEFOX1lcbn0gZnJvbSAnLi90b3VjaGFjdGlvbi1Db25zdHMnO1xuaW1wb3J0IHtcbiAgTkFUSVZFX1RPVUNIX0FDVElPTixcbiAgUFJFRklYRURfVE9VQ0hfQUNUSU9OLFxufSBmcm9tIFwiLi9nZXQtdG91Y2hhY3Rpb24tcHJvcHNcIjtcbmltcG9ydCB7XG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9IT1JJWk9OVEFMXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcbmltcG9ydCBlYWNoIGZyb20gJy4uL3V0aWxzL2VhY2gnO1xuaW1wb3J0IGJvb2xPckZuIGZyb20gJy4uL3V0aWxzL2Jvb2wtb3ItZm4nO1xuaW1wb3J0IGluU3RyIGZyb20gJy4uL3V0aWxzL2luLXN0cic7XG5pbXBvcnQgY2xlYW5Ub3VjaEFjdGlvbnMgZnJvbSAnLi9jbGVhbi10b3VjaC1hY3Rpb25zJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3VjaEFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZSBvbiB0aGUgZWxlbWVudCBvciBlbmFibGUgdGhlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0KHZhbHVlKSB7XG4gICAgLy8gZmluZCBvdXQgdGhlIHRvdWNoLWFjdGlvbiBieSB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAodmFsdWUgPT09IFRPVUNIX0FDVElPTl9DT01QVVRFKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuY29tcHV0ZSgpO1xuICAgIH1cblxuICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuYWN0aW9ucyA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgKi9cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjb21wdXRlIHRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IGJhc2VkIG9uIHRoZSByZWNvZ25pemVyJ3Mgc2V0dGluZ3NcbiAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICovXG4gIGNvbXB1dGUoKSB7XG4gICAgbGV0IGFjdGlvbnMgPSBbXTtcbiAgICBlYWNoKHRoaXMubWFuYWdlci5yZWNvZ25pemVycywgKHJlY29nbml6ZXIpID0+IHtcbiAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgIGFjdGlvbnMgPSBhY3Rpb25zLmNvbmNhdChyZWNvZ25pemVyLmdldFRvdWNoQWN0aW9uKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjbGVhblRvdWNoQWN0aW9ucyhhY3Rpb25zLmpvaW4oJyAnKSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgcHJldmVudERlZmF1bHRzKGlucHV0KSB7XG4gICAgbGV0IHsgc3JjRXZlbnQgfSA9IGlucHV0O1xuICAgIGxldCBkaXJlY3Rpb24gPSBpbnB1dC5vZmZzZXREaXJlY3Rpb247XG5cbiAgICAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cbiAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IGFjdGlvbnMgfSA9IHRoaXM7XG4gICAgbGV0IGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIGxldCBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgIGxldCBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgaWYgKGhhc05vbmUpIHtcbiAgICAgIC8vIGRvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuICAgICAgbGV0IGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgIGxldCBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgbGV0IGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaGFzTm9uZSB8fFxuICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgKGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldmVudFNyYyhzcmNFdmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjRXZlbnRcbiAgICovXG4gIHByZXZlbnRTcmMoc3JjRXZlbnQpIHtcbiAgICB0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyByb3VuZCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENlbnRlcihwb2ludGVycykge1xuICBsZXQgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7XG5cbiAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICB9O1xuICB9XG5cbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBwb2ludGVyc0xlbmd0aCkge1xuICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICB5ICs9IHBvaW50ZXJzW2ldLmNsaWVudFk7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByb3VuZCh4IC8gcG9pbnRlcnNMZW5ndGgpLFxuICAgIHk6IHJvdW5kKHkgLyBwb2ludGVyc0xlbmd0aClcbiAgfTtcbn1cbiIsImltcG9ydCB7IG5vdyxyb3VuZCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgZ2V0Q2VudGVyIGZyb20gJy4vZ2V0LWNlbnRlcic7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gIC8vIG1ha2UgYSBzaW1wbGUgY29weSBvZiB0aGUgcG9pbnRlcnMgYmVjYXVzZSB3ZSB3aWxsIGdldCBhIHJlZmVyZW5jZSBpZiB3ZSBkb24ndFxuICAvLyB3ZSBvbmx5IG5lZWQgY2xpZW50WFkgZm9yIHRoZSBjYWxjdWxhdGlvbnNcbiAgbGV0IHBvaW50ZXJzID0gW107XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBpbnB1dC5wb2ludGVycy5sZW5ndGgpIHtcbiAgICBwb2ludGVyc1tpXSA9IHtcbiAgICAgIGNsaWVudFg6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFgpLFxuICAgICAgY2xpZW50WTogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WSlcbiAgICB9O1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdGltZVN0YW1wOiBub3coKSxcbiAgICBwb2ludGVycyxcbiAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgZGVsdGFYOiBpbnB1dC5kZWx0YVgsXG4gICAgZGVsdGFZOiBpbnB1dC5kZWx0YVlcbiAgfTtcbn1cbiIsImltcG9ydCB7IFBST1BTX1hZIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREaXN0YW5jZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG4gIGxldCB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICBsZXQgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcblxuICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbn1cbiIsImltcG9ydCB7IFBST1BTX1hZIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge09iamVjdH0gcDFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMlxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBhbmdsZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbmdsZShwMSwgcDIsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICBwcm9wcyA9IFBST1BTX1hZO1xuICB9XG4gIGxldCB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICBsZXQgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuIiwiaW1wb3J0IHsgYWJzIH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMtY29uc3RzJztcbmltcG9ydCB7IERJUkVDVElPTl9OT05FLERJUkVDVElPTl9MRUZULERJUkVDVElPTl9SSUdIVCxESVJFQ1RJT05fVVAsRElSRUNUSU9OX0RPV04gfSBmcm9tICcuL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgZGlyZWN0aW9uIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpcmVjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgfVxuXG4gIGlmIChhYnMoeCkgPj0gYWJzKHkpKSB7XG4gICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gIH1cbiAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG4iLCJpbXBvcnQgeyBJTlBVVF9TVEFSVCwgSU5QVVRfRU5EIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCkge1xuICBsZXQgeyBjZW50ZXIgfSA9IGlucHV0O1xuICAvLyBsZXQgeyBvZmZzZXREZWx0YTpvZmZzZXQgPSB7fSwgcHJldkRlbHRhID0ge30sIHByZXZJbnB1dCA9IHt9IH0gPSBzZXNzaW9uO1xuICAvLyBqc2NzIHRocm93aW5nIGVycm9yIG9uIGRlZmFsdXQgZGVzdHJ1Y3R1cmVkIHZhbHVlcyBhbmQgd2l0aG91dCBkZWZhdWx0cyB0ZXN0cyBmYWlsXG4gIGxldCBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhIHx8IHt9O1xuICBsZXQgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gIGxldCBwcmV2SW5wdXQgPSBzZXNzaW9uLnByZXZJbnB1dCB8fCB7fTtcblxuICBpZiAoaW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9TVEFSVCB8fCBwcmV2SW5wdXQuZXZlbnRUeXBlID09PSBJTlBVVF9FTkQpIHtcbiAgICBwcmV2RGVsdGEgPSBzZXNzaW9uLnByZXZEZWx0YSA9IHtcbiAgICAgIHg6IHByZXZJbnB1dC5kZWx0YVggfHwgMCxcbiAgICAgIHk6IHByZXZJbnB1dC5kZWx0YVkgfHwgMFxuICAgIH07XG5cbiAgICBvZmZzZXQgPSBzZXNzaW9uLm9mZnNldERlbHRhID0ge1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueVxuICAgIH07XG4gIH1cblxuICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgaW5wdXQuZGVsdGFZID0gcHJldkRlbHRhLnkgKyAoY2VudGVyLnkgLSBvZmZzZXQueSk7XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCAvIGRlbHRhVGltZSB8fCAwLFxuICAgIHk6IHkgLyBkZWx0YVRpbWUgfHwgMFxuICB9O1xufVxuIiwiaW1wb3J0IHsgUFJPUFNfQ0xJRU5UX1hZIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IGdldERpc3RhbmNlIGZyb20gJy4vZ2V0LWRpc3RhbmNlJztcbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0sIFBST1BTX0NMSUVOVF9YWSkgLyBnZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG4iLCJpbXBvcnQgZ2V0QW5nbGUgZnJvbSAnLi9nZXQtYW5nbGUnO1xuaW1wb3J0IHsgUFJPUFNfQ0xJRU5UX1hZIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0sIFBST1BTX0NMSUVOVF9YWSkgKyBnZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0sIFBST1BTX0NMSUVOVF9YWSk7XG59XG4iLCJpbXBvcnQgeyBJTlBVVF9DQU5DRUwsQ09NUFVURV9JTlRFUlZBTCB9IGZyb20gJy4vaW5wdXQtY29uc3RzJztcbmltcG9ydCB7IGFicyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgZ2V0VmVsb2NpdHkgZnJvbSAnLi9nZXQtdmVsb2NpdHknO1xuaW1wb3J0IGdldERpcmVjdGlvbiBmcm9tICcuL2dldC1kaXJlY3Rpb24nO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gIGxldCBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQ7XG4gIGxldCBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcDtcbiAgbGV0IHZlbG9jaXR5O1xuICBsZXQgdmVsb2NpdHlYO1xuICBsZXQgdmVsb2NpdHlZO1xuICBsZXQgZGlyZWN0aW9uO1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgbGV0IGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgIGxldCBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgIGxldCB2ID0gZ2V0VmVsb2NpdHkoZGVsdGFUaW1lLCBkZWx0YVgsIGRlbHRhWSk7XG4gICAgdmVsb2NpdHlYID0gdi54O1xuICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICB2ZWxvY2l0eSA9IChhYnModi54KSA+IGFicyh2LnkpKSA/IHYueCA6IHYueTtcbiAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgdmVsb2NpdHkgPSBsYXN0LnZlbG9jaXR5O1xuICAgIHZlbG9jaXR5WCA9IGxhc3QudmVsb2NpdHlYO1xuICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgIGRpcmVjdGlvbiA9IGxhc3QuZGlyZWN0aW9uO1xuICB9XG5cbiAgaW5wdXQudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgaW5wdXQudmVsb2NpdHlYID0gdmVsb2NpdHlYO1xuICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbn1cbiIsImltcG9ydCB7IG5vdyB9IGZyb20gJy4uL3V0aWxzL3V0aWxzLWNvbnN0cyc7XG5pbXBvcnQgeyBhYnMgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IGhhc1BhcmVudCBmcm9tICcuLi91dGlscy9oYXMtcGFyZW50JztcbmltcG9ydCBzaW1wbGVDbG9uZUlucHV0RGF0YSBmcm9tICcuL3NpbXBsZS1jbG9uZS1pbnB1dC1kYXRhJztcbmltcG9ydCBnZXRDZW50ZXIgZnJvbSAnLi9nZXQtY2VudGVyJztcbmltcG9ydCBnZXREaXN0YW5jZSBmcm9tICcuL2dldC1kaXN0YW5jZSc7XG5pbXBvcnQgZ2V0QW5nbGUgZnJvbSAnLi9nZXQtYW5nbGUnO1xuaW1wb3J0IGdldERpcmVjdGlvbiBmcm9tICcuL2dldC1kaXJlY3Rpb24nO1xuaW1wb3J0IGNvbXB1dGVEZWx0YVhZIGZyb20gJy4vY29tcHV0ZS1kZWx0YS14eSc7XG5pbXBvcnQgZ2V0VmVsb2NpdHkgZnJvbSAnLi9nZXQtdmVsb2NpdHknO1xuaW1wb3J0IGdldFNjYWxlIGZyb20gJy4vZ2V0LXNjYWxlJztcbmltcG9ydCBnZXRSb3RhdGlvbiBmcm9tICcuL2dldC1yb3RhdGlvbic7XG5pbXBvcnQgY29tcHV0ZUludGVydmFsSW5wdXREYXRhIGZyb20gJy4vY29tcHV0ZS1pbnRlcnZhbC1pbnB1dC1kYXRhJztcblxuLyoqXG4qIEBwcml2YXRlXG4gKiBleHRlbmQgdGhlIGRhdGEgd2l0aCBzb21lIHVzYWJsZSBwcm9wZXJ0aWVzIGxpa2Ugc2NhbGUsIHJvdGF0ZSwgdmVsb2NpdHkgZXRjXG4gKiBAcGFyYW0ge09iamVjdH0gbWFuYWdlclxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgbGV0IHsgc2Vzc2lvbiB9ID0gbWFuYWdlcjtcbiAgbGV0IHsgcG9pbnRlcnMgfSA9IGlucHV0O1xuICBsZXQgeyBsZW5ndGg6cG9pbnRlcnNMZW5ndGggfSA9IHBvaW50ZXJzO1xuXG4gIC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cbiAgaWYgKCFzZXNzaW9uLmZpcnN0SW5wdXQpIHtcbiAgICBzZXNzaW9uLmZpcnN0SW5wdXQgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH1cblxuICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gIGlmIChwb2ludGVyc0xlbmd0aCA+IDEgJiYgIXNlc3Npb24uZmlyc3RNdWx0aXBsZSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSBlbHNlIGlmIChwb2ludGVyc0xlbmd0aCA9PT0gMSkge1xuICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICB9XG5cbiAgbGV0IHsgZmlyc3RJbnB1dCwgZmlyc3RNdWx0aXBsZSB9ID0gc2Vzc2lvbjtcbiAgbGV0IG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuXG4gIGxldCBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICBpbnB1dC50aW1lU3RhbXAgPSBub3coKTtcbiAgaW5wdXQuZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gZmlyc3RJbnB1dC50aW1lU3RhbXA7XG5cbiAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gIGlucHV0LmRpc3RhbmNlID0gZ2V0RGlzdGFuY2Uob2Zmc2V0Q2VudGVyLCBjZW50ZXIpO1xuXG4gIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICBsZXQgb3ZlcmFsbFZlbG9jaXR5ID0gZ2V0VmVsb2NpdHkoaW5wdXQuZGVsdGFUaW1lLCBpbnB1dC5kZWx0YVgsIGlucHV0LmRlbHRhWSk7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVggPSBvdmVyYWxsVmVsb2NpdHkueDtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHkgPSAoYWJzKG92ZXJhbGxWZWxvY2l0eS54KSA+IGFicyhvdmVyYWxsVmVsb2NpdHkueSkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcblxuICBpbnB1dC5zY2FsZSA9IGZpcnN0TXVsdGlwbGUgPyBnZXRTY2FsZShmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAxO1xuICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gIGlucHV0Lm1heFBvaW50ZXJzID0gIXNlc3Npb24ucHJldklucHV0ID8gaW5wdXQucG9pbnRlcnMubGVuZ3RoIDogKChpbnB1dC5wb2ludGVycy5sZW5ndGggPlxuICBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycykgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyk7XG5cbiAgY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KTtcblxuICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICBsZXQgdGFyZ2V0ID0gbWFuYWdlci5lbGVtZW50O1xuICBjb25zdCBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICBsZXQgc3JjRXZlbnRUYXJnZXQ7XG5cbiAgaWYgKHNyY0V2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH0gZWxzZSBpZiAoc3JjRXZlbnQucGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQucGF0aFswXTtcbiAgfSBlbHNlIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnRhcmdldDtcbiAgfVxuXG4gIGlmIChoYXNQYXJlbnQoc3JjRXZlbnRUYXJnZXQsIHRhcmdldCkpIHtcbiAgICB0YXJnZXQgPSBzcmNFdmVudFRhcmdldDtcbiAgfVxuICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG4iLCJpbXBvcnQgeyBJTlBVVF9TVEFSVCxJTlBVVF9FTkQsSU5QVVRfQ0FOQ0VMIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IGNvbXB1dGVJbnB1dERhdGEgZnJvbSAnLi9jb21wdXRlLWlucHV0LWRhdGEnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBoYW5kbGUgaW5wdXQgZXZlbnRzXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICBsZXQgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gIGxldCBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICBsZXQgaXNGaXJzdCA9IChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAocG9pbnRlcnNMZW4gLSBjaGFuZ2VkUG9pbnRlcnNMZW4gPT09IDApKTtcbiAgbGV0IGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgaW5wdXQuaXNGaXJzdCA9ICEhaXNGaXJzdDtcbiAgaW5wdXQuaXNGaW5hbCA9ICEhaXNGaW5hbDtcblxuICBpZiAoaXNGaXJzdCkge1xuICAgIG1hbmFnZXIuc2Vzc2lvbiA9IHt9O1xuICB9XG5cbiAgLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG4gIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAvLyBjb21wdXRlIHNjYWxlLCByb3RhdGlvbiBldGNcbiAgY29tcHV0ZUlucHV0RGF0YShtYW5hZ2VyLCBpbnB1dCk7XG5cbiAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgbWFuYWdlci5lbWl0KCdoYW1tZXIuaW5wdXQnLCBpbnB1dCk7XG5cbiAgbWFuYWdlci5yZWNvZ25pemUoaW5wdXQpO1xuICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBzcGxpdCBzdHJpbmcgb24gd2hpdGVzcGFjZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge0FycmF5fSB3b3Jkc1xuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwbGl0U3RyKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5zcGxpdCgvXFxzKy9nKTtcbn1cbiIsImltcG9ydCBlYWNoIGZyb20gJy4vZWFjaCc7XG5pbXBvcnQgc3BsaXRTdHIgZnJvbSAnLi9zcGxpdC1zdHInO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gIGVhY2goc3BsaXRTdHIodHlwZXMpLCAodHlwZSkgPT4ge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgZWFjaCBmcm9tICcuL2VhY2gnO1xuaW1wb3J0IHNwbGl0U3RyIGZyb20gJy4vc3BsaXQtc3RyJztcbi8qKlxuICogQHByaXZhdGVcbiAqIHJlbW92ZUV2ZW50TGlzdGVuZXIgd2l0aCBtdWx0aXBsZSBldmVudHMgYXQgb25jZVxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgKHR5cGUpID0+IHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgbGV0IGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBlbGVtZW50O1xuICByZXR1cm4gKGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93IHx8IHdpbmRvdyk7XG59XG4iLCJpbXBvcnQgYm9vbE9yRm4gZnJvbSAnLi4vdXRpbHMvYm9vbC1vci1mbic7XG5pbXBvcnQgYWRkRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi4vdXRpbHMvYWRkLWV2ZW50LWxpc3RlbmVycyc7XG5pbXBvcnQgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgZnJvbSAnLi4vdXRpbHMvcmVtb3ZlLWV2ZW50LWxpc3RlbmVycyc7XG5pbXBvcnQgZ2V0V2luZG93Rm9yRWxlbWVudCBmcm9tICcuLi91dGlscy9nZXQtd2luZG93LWZvci1lbGVtZW50JztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICB0aGlzLnRhcmdldCA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dFRhcmdldDtcblxuICAgIC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cbiAgICB0aGlzLmRvbUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2hvdWxkIGhhbmRsZSB0aGUgaW5wdXRFdmVudCBkYXRhIGFuZCB0cmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgKiBAdmlydHVhbFxuICAgKi9cbiAgaGFuZGxlcigpIHsgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBiaW5kIHRoZSBldmVudHNcbiAgICovXG4gIGluaXQoKSB7XG4gICAgdGhpcy5ldkVsICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZUYXJnZXQgJiYgYWRkRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gIH1cbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seUZpbGxcbiAqIEBwYXJhbSB7QXJyYXl9IHNyY1xuICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZmluZEJ5S2V5XVxuICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGZpbmRCeUtleSkge1xuICBpZiAoc3JjLmluZGV4T2YgJiYgIWZpbmRCeUtleSkge1xuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7Ly8gZG8gbm90IHVzZSA9PT0gaGVyZSwgdGVzdCBmYWlsc1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICAgIElOUFVUX1NUQVJULFxuICAgIElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUwsXG4gICAgSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9UWVBFX1RPVUNILFxuICAgIElOUFVUX1RZUEVfTU9VU0UsXG4gICAgSU5QVVRfVFlQRV9QRU4sXG4gICAgSU5QVVRfVFlQRV9LSU5FQ1Rcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi9icm93c2VyXCI7XG5pbXBvcnQgSW5wdXQgZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgaW5BcnJheSBmcm9tICcuLi91dGlscy9pbi1hcnJheSc7XG5cbmNvbnN0IFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICBwb2ludGVyZG93bjogSU5QVVRfU1RBUlQsXG4gIHBvaW50ZXJtb3ZlOiBJTlBVVF9NT1ZFLFxuICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgcG9pbnRlcmNhbmNlbDogSU5QVVRfQ0FOQ0VMLFxuICBwb2ludGVyb3V0OiBJTlBVVF9DQU5DRUxcbn07XG5cbi8vIGluIElFMTAgdGhlIHBvaW50ZXIgdHlwZXMgaXMgZGVmaW5lZCBhcyBhbiBlbnVtXG5jb25zdCBJRTEwX1BPSU5URVJfVFlQRV9FTlVNID0ge1xuICAyOiBJTlBVVF9UWVBFX1RPVUNILFxuICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgNDogSU5QVVRfVFlQRV9NT1VTRSxcbiAgNTogSU5QVVRfVFlQRV9LSU5FQ1QgLy8gc2VlIGh0dHBzOi8vdHdpdHRlci5jb20vamFjb2Jyb3NzaS9zdGF0dXMvNDgwNTk2NDM4NDg5ODkwODE2XG59O1xuXG5sZXQgUE9JTlRFUl9FTEVNRU5UX0VWRU5UUyA9ICdwb2ludGVyZG93bic7XG5sZXQgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ3BvaW50ZXJtb3ZlIHBvaW50ZXJ1cCBwb2ludGVyY2FuY2VsJztcblxuLy8gSUUxMCBoYXMgcHJlZml4ZWQgc3VwcG9ydCwgYW5kIGNhc2Utc2Vuc2l0aXZlXG5pZiAod2luZG93Lk1TUG9pbnRlckV2ZW50ICYmICF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdNU1BvaW50ZXJNb3ZlIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBvaW50ZXIgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50ZXJFdmVudElucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvdG8gPSBQb2ludGVyRXZlbnRJbnB1dC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc3RvcmUgPSAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYW5kbGUgbW91c2UgZXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgaGFuZGxlcihldikge1xuICAgIGxldCB7IHN0b3JlIH0gPSB0aGlzO1xuICAgIGxldCByZW1vdmVQb2ludGVyID0gZmFsc2U7XG5cbiAgICBsZXQgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICBsZXQgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgbGV0IHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG5cbiAgICBsZXQgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSCk7XG5cbiAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgIGxldCBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7XG5cbiAgICAvLyBzdGFydCBhbmQgbW91c2UgbXVzdCBiZSBkb3duXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgICAgc3RvcmVJbmRleCA9IHN0b3JlLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgcmVtb3ZlUG9pbnRlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG4gICAgaWYgKHN0b3JlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcbiAgICBzdG9yZVtzdG9yZUluZGV4XSA9IGV2O1xuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcblxuICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuIiwiaW1wb3J0IGluQXJyYXkgZnJvbSAnLi9pbi1hcnJheSc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gIGxldCByZXN1bHRzID0gW107XG4gIGxldCB2YWx1ZXMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgIGxldCB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICBpZiAoaW5BcnJheSh2YWx1ZXMsIHZhbCkgPCAwKSB7XG4gICAgICByZXN1bHRzLnB1c2goc3JjW2ldKTtcbiAgICB9XG4gICAgdmFsdWVzW2ldID0gdmFsO1xuICAgIGkrKztcbiAgfVxuXG4gIGlmIChzb3J0KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJpbXBvcnQge1xuICBJTlBVVF9TVEFSVCxcbiAgSU5QVVRfTU9WRSxcbiAgSU5QVVRfRU5ELFxuICBJTlBVVF9DQU5DRUwsXG4gIElOUFVUX1RZUEVfVE9VQ0hcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3InO1xuaW1wb3J0IHRvQXJyYXkgZnJvbSAnLi4vdXRpbHMvdG8tYXJyYXknO1xuaW1wb3J0IGhhc1BhcmVudCBmcm9tICcuLi91dGlscy9oYXMtcGFyZW50JztcbmltcG9ydCB1bmlxdWVBcnJheSBmcm9tICcuLi91dGlscy91bmlxdWUtYXJyYXknO1xuXG5jb25zdCBUT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbmNvbnN0IFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBNdWx0aS11c2VyIHRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb3VjaElucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBUb3VjaElucHV0LnByb3RvdHlwZS5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuICAgIC8vIHRoaXMuZXZUYXJnZXQgPSBUT1VDSF9UQVJHRVRfRVZFTlRTO1xuICB9XG4gIGhhbmRsZXIoZXYpIHtcbiAgICBsZXQgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICBsZXQgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG4gICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICBsZXQgYWxsVG91Y2hlcyA9IHRvQXJyYXkoZXYudG91Y2hlcyk7XG4gIGxldCB7IHRhcmdldElkcyB9ID0gdGhpcztcblxuICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICBpZiAodHlwZSAmIChJTlBVVF9TVEFSVCB8IElOUFVUX01PVkUpICYmIGFsbFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgIHJldHVybiBbYWxsVG91Y2hlcywgYWxsVG91Y2hlc107XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IHRhcmdldFRvdWNoZXM7XG4gIGxldCBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuICBsZXQgY2hhbmdlZFRhcmdldFRvdWNoZXMgPSBbXTtcbiAgbGV0IHsgdGFyZ2V0IH0gPSB0aGlzO1xuXG4gIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgdGFyZ2V0VG91Y2hlcyA9IGFsbFRvdWNoZXMuZmlsdGVyKCh0b3VjaCkgPT4ge1xuICAgIHJldHVybiBoYXNQYXJlbnQodG91Y2gudGFyZ2V0LCB0YXJnZXQpO1xuICB9KTtcblxuICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgaSA9IDA7XG4gIHdoaWxlIChpIDwgY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgaWYgKHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXSkge1xuICAgICAgY2hhbmdlZFRhcmdldFRvdWNoZXMucHVzaChjaGFuZ2VkVG91Y2hlc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdO1xuICAgIH1cbiAgICBpKys7XG4gIH1cblxuICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzXG4gIF07XG59XG4iLCJpbXBvcnQge1xuICAgIElOUFVUX1NUQVJULFxuICAgIElOUFVUX01PVkUsXG4gICAgSU5QVVRfRU5ELFxuICAgIElOUFVUX1RZUEVfTU9VU0Vcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3InO1xuXG5jb25zdCBNT1VTRV9JTlBVVF9NQVAgPSB7XG4gIG1vdXNlZG93bjogSU5QVVRfU1RBUlQsXG4gIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgbW91c2V1cDogSU5QVVRfRU5EXG59O1xuXG5jb25zdCBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xuY29uc3QgTU9VU0VfV0lORE9XX0VWRU5UUyA9ICdtb3VzZW1vdmUgbW91c2V1cCc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3VzZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvdG8gPSBNb3VzZUlucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldkVsID0gTU9VU0VfRUxFTUVOVF9FVkVOVFM7XG4gICAgcHJvdG8uZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTsgLy8gbW91c2Vkb3duIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIGhhbmRsZXIoZXYpIHtcbiAgICBsZXQgZXZlbnRUeXBlID0gTU9VU0VfSU5QVVRfTUFQW2V2LnR5cGVdO1xuXG4gICAgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfTU9WRSAmJiBldi53aGljaCAhPT0gMSkge1xuICAgICAgZXZlbnRUeXBlID0gSU5QVVRfRU5EO1xuICAgIH1cblxuICAgIC8vIG1vdXNlIG11c3QgYmUgZG93blxuICAgIGlmICghdGhpcy5wcmVzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgSW5wdXQgZnJvbSBcIi4uL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3JcIjtcbmltcG9ydCBUb3VjaElucHV0IGZyb20gXCIuL3RvdWNoXCI7XG5pbXBvcnQgTW91c2VJbnB1dCBmcm9tIFwiLi9tb3VzZVwiO1xuaW1wb3J0IHtcblx0SU5QVVRfU1RBUlQsXG5cdElOUFVUX0VORCxcblx0SU5QVVRfQ0FOQ0VMLFxuXHRJTlBVVF9UWVBFX1RPVUNILFxuXHRJTlBVVF9UWVBFX01PVVNFLFxufSBmcm9tIFwiLi4vaW5wdXRqcy9pbnB1dC1jb25zdHNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbmNvbnN0IERFRFVQX1RJTUVPVVQgPSAyNTAwO1xuY29uc3QgREVEVVBfRElTVEFOQ0UgPSAyNTtcblxuZnVuY3Rpb24gc2V0TGFzdFRvdWNoKGV2ZW50RGF0YSkge1xuXHRjb25zdCB7IGNoYW5nZWRQb2ludGVyczogW3RvdWNoXSB9ID0gZXZlbnREYXRhO1xuXG5cdGlmICh0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLnByaW1hcnlUb3VjaCkge1xuXHRcdGNvbnN0IGxhc3RUb3VjaCA9IHsgeDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WSB9O1xuXHRcdGNvbnN0IGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG5cblx0XHR0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcblxuXG5cdFx0Y29uc3QgcmVtb3ZlTGFzdFRvdWNoID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBpID0gbHRzLmluZGV4T2YobGFzdFRvdWNoKTtcblxuXHRcdFx0aWYgKGkgPiAtMSkge1xuXHRcdFx0XHRsdHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzZXRUaW1lb3V0KHJlbW92ZUxhc3RUb3VjaCwgREVEVVBfVElNRU9VVCk7XG5cdH1cbn1cblxuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG5cdGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuXHRcdHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuXHRcdHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG5cdH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcblx0XHRzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuXHR9XG59XG5mdW5jdGlvbiBpc1N5bnRoZXRpY0V2ZW50KGV2ZW50RGF0YSkge1xuXHRjb25zdCB4ID0gZXZlbnREYXRhLnNyY0V2ZW50LmNsaWVudFg7XG5cdGNvbnN0IHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCB0ID0gdGhpcy5sYXN0VG91Y2hlc1tpXTtcblx0XHRjb25zdCBkeCA9IE1hdGguYWJzKHggLSB0LngpO1xuXHRcdGNvbnN0IGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG5cblx0XHRpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG91Y2hNb3VzZUlucHV0IGV4dGVuZHMgSW5wdXQge1xuXHRjb25zdHJ1Y3RvcihtYW5hZ2VyLCBjYWxsYmFjaykge1xuXHRcdHN1cGVyKG1hbmFnZXIsIGNhbGxiYWNrKTtcblxuXHRcdHRoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dCh0aGlzLm1hbmFnZXIsIHRoaXMuaGFuZGxlcik7XG5cdFx0dGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgdGhpcy5oYW5kbGVyKTtcblx0XHR0aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG5cdFx0dGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIGhhbmRsZSBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzXG5cdCAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dEV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcblx0ICovXG5cdGhhbmRsZXIgPSAobWFuYWdlciwgaW5wdXRFdmVudCwgaW5wdXREYXRhKSA9PiB7XG5cdFx0Y29uc3QgaXNUb3VjaCA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfVE9VQ0gpO1xuXHRcdGNvbnN0IGlzTW91c2UgPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09PSBJTlBVVF9UWVBFX01PVVNFKTtcblxuXHRcdGlmIChpc01vdXNlICYmIGlucHV0RGF0YS5zb3VyY2VDYXBhYmlsaXRpZXMgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcy5maXJlc1RvdWNoRXZlbnRzKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcblx0XHRpZiAoaXNUb3VjaCkge1xuXHRcdFx0cmVjb3JkVG91Y2hlcy5jYWxsKHRoaXMsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG5cdFx0fSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBpbnB1dERhdGEpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMudG91Y2guZGVzdHJveSgpO1xuXHRcdHRoaXMubW91c2UuZGVzdHJveSgpO1xuXHR9XG59XG4iLCJpbXBvcnQgeyBTVVBQT1JUX1BPSU5URVJfRVZFTlRTLFNVUFBPUlRfT05MWV9UT1VDSCxTVVBQT1JUX1RPVUNIIH0gZnJvbSAnLi9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IGlucHV0SGFuZGxlciBmcm9tICcuL2lucHV0LWhhbmRsZXInO1xuaW1wb3J0IFBvaW50ZXJFdmVudElucHV0IGZyb20gJy4uL2lucHV0L3BvaW50ZXJldmVudCc7XG5pbXBvcnQgVG91Y2hJbnB1dCBmcm9tICcuLi9pbnB1dC90b3VjaCc7XG5pbXBvcnQgTW91c2VJbnB1dCBmcm9tICcuLi9pbnB1dC9tb3VzZSc7XG5pbXBvcnQgVG91Y2hNb3VzZUlucHV0IGZyb20gJy4uL2lucHV0L3RvdWNobW91c2UnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgbGV0IFR5cGU7XG4gIC8vIGxldCBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG4gIGxldCB7IG9wdGlvbnM6eyBpbnB1dENsYXNzIH0gfSA9IG1hbmFnZXI7XG4gIGlmIChpbnB1dENsYXNzKSB7XG4gICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gIH0gZWxzZSBpZiAoU1VQUE9SVF9QT0lOVEVSX0VWRU5UUykge1xuICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgfSBlbHNlIGlmIChTVVBQT1JUX09OTFlfVE9VQ0gpIHtcbiAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgfSBlbHNlIGlmICghU1VQUE9SVF9UT1VDSCkge1xuICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICB9IGVsc2Uge1xuICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gIH1cbiAgcmV0dXJuIG5ldyAoVHlwZSkobWFuYWdlciwgaW5wdXRIYW5kbGVyKTtcbn1cbiIsImltcG9ydCBlYWNoIGZyb20gJy4vZWFjaCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImNvbnN0IFNUQVRFX1BPU1NJQkxFID0gMTtcbmNvbnN0IFNUQVRFX0JFR0FOID0gMjtcbmNvbnN0IFNUQVRFX0NIQU5HRUQgPSA0O1xuY29uc3QgU1RBVEVfRU5ERUQgPSA4O1xuY29uc3QgU1RBVEVfUkVDT0dOSVpFRCA9IFNUQVRFX0VOREVEO1xuY29uc3QgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG5jb25zdCBTVEFURV9GQUlMRUQgPSAzMjtcblxuZXhwb3J0IHtcbiAgICBTVEFURV9QT1NTSUJMRSxcbiAgICBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0VOREVELFxuICAgIFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0ZBSUxFRFxufTtcbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xubGV0IF91bmlxdWVJZCA9IDE7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuIiwiLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IGEgcmVjb2duaXplciBieSBuYW1lIGlmIGl0IGlzIGJvdW5kIHRvIGEgbWFuYWdlclxuICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gb3RoZXJSZWNvZ25pemVyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAqIEByZXR1cm5zIHtSZWNvZ25pemVyfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgcmVjb2duaXplcikge1xuICBsZXQgeyBtYW5hZ2VyIH0gPSByZWNvZ25pemVyO1xuICBpZiAobWFuYWdlcikge1xuICAgIHJldHVybiBtYW5hZ2VyLmdldChvdGhlclJlY29nbml6ZXIpO1xuICB9XG4gIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG4iLCJpbXBvcnQge1xuICAgIFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0JFR0FOXG59IGZyb20gJy4vcmVjb2duaXplci1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdGF0ZVN0cihzdGF0ZSkge1xuICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICByZXR1cm4gJ2NhbmNlbCc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgIHJldHVybiAnZW5kJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICByZXR1cm4gJ21vdmUnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfVxuICByZXR1cm4gJyc7XG59XG4iLCJpbXBvcnQge1xuICAgIFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0VOREVELFxuICAgIFNUQVRFX0ZBSUxFRCxcbiAgICBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRCxcbiAgICBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VEXG59IGZyb20gJy4vcmVjb2duaXplci1jb25zdHMnO1xuaW1wb3J0IGFzc2lnbiBmcm9tICcuLi91dGlscy9hc3NpZ24nO1xuaW1wb3J0IHVuaXF1ZUlkIGZyb20gJy4uL3V0aWxzL3VuaXF1ZS1pZCc7XG5pbXBvcnQgaW52b2tlQXJyYXlBcmcgZnJvbSAnLi4vdXRpbHMvaW52b2tlLWFycmF5LWFyZyc7XG5pbXBvcnQgaW5BcnJheSBmcm9tICcuLi91dGlscy9pbi1hcnJheSc7XG5pbXBvcnQgYm9vbE9yRm4gZnJvbSAnLi4vdXRpbHMvYm9vbC1vci1mbic7XG5pbXBvcnQgZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlciBmcm9tICcuL2dldC1yZWNvZ25pemVyLWJ5LW5hbWUtaWYtbWFuYWdlcic7XG5pbXBvcnQgc3RhdGVTdHIgZnJvbSAnLi9zdGF0ZS1zdHInO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVJZCgpO1xuXG4gICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcblxuICAgIC8vIGRlZmF1bHQgaXMgZW5hYmxlIHRydWVcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogc2V0IG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICovXG4gIHNldChvcHRpb25zKSB7XG4gICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgdG91Y2hBY3Rpb24sIGluIGNhc2Ugc29tZXRoaW5nIGNoYW5nZWQgYWJvdXQgdGhlIGRpcmVjdGlvbnMvZW5hYmxlZCBzdGF0ZVxuICAgIHRoaXMubWFuYWdlciAmJiB0aGlzLm1hbmFnZXIudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuICByZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCB7IHNpbXVsdGFuZW91cyB9ID0gdGhpcztcbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuICBkcm9wUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcob3RoZXJSZWNvZ25pemVyLCAnZHJvcFJlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGRlbGV0ZSB0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cbiAgcmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlcXVpcmVGYWlsdXJlJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxldCB7IHJlcXVpcmVGYWlsIH0gPSB0aGlzO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICBpZiAoaW5BcnJheShyZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKSA9PT0gLTEpIHtcbiAgICAgIHJlcXVpcmVGYWlsLnB1c2gob3RoZXJSZWNvZ25pemVyKTtcbiAgICAgIG90aGVyUmVjb2duaXplci5yZXF1aXJlRmFpbHVyZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cbiAgZHJvcFJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdkcm9wUmVxdWlyZUZhaWx1cmUnLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgIGxldCBpbmRleCA9IGluQXJyYXkodGhpcy5yZXF1aXJlRmFpbCwgb3RoZXJSZWNvZ25pemVyKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzUmVxdWlyZUZhaWx1cmVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVpcmVGYWlsLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY2FuUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFlvdSBzaG91bGQgdXNlIGB0cnlFbWl0YCBpbnN0ZWFkIG9mIGBlbWl0YCBkaXJlY3RseSB0byBjaGVja1xuICAgKiB0aGF0IGFsbCB0aGUgbmVlZGVkIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQgYmVmb3JlIGVtaXR0aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG4gIGVtaXQoaW5wdXQpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICBzZWxmLm1hbmFnZXIuZW1pdChldmVudCwgaW5wdXQpO1xuICAgIH1cblxuICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgIGlmIChzdGF0ZSA8IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuXG4gICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICBpZiAoaW5wdXQuYWRkaXRpb25hbEV2ZW50KSB7IC8vIGFkZGl0aW9uYWwgZXZlbnQocGFubGVmdCwgcGFucmlnaHQsIHBpbmNoaW4sIHBpbmNob3V0Li4uKVxuICAgICAgZW1pdChpbnB1dC5hZGRpdGlvbmFsRXZlbnQpO1xuICAgIH1cblxuICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgaWYgKHN0YXRlID49IFNUQVRFX0VOREVEKSB7XG4gICAgICBlbWl0KHNlbGYub3B0aW9ucy5ldmVudCArIHN0YXRlU3RyKHN0YXRlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICogaWYgdHJ1ZSwgaXQgZW1pdHMgYSBnZXN0dXJlIGV2ZW50LFxuICAgKiBvdGhlcndpc2UsIHNldHVwIHRoZSBzdGF0ZSB0byBGQUlMRUQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cbiAgdHJ5RW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgfVxuICAgIC8vIGl0J3MgZmFpbGluZyBhbnl3YXlcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGNhbiB3ZSBlbWl0P1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNhbkVtaXQoKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGgpIHtcbiAgICAgIGlmICghKHRoaXMucmVxdWlyZUZhaWxbaV0uc3RhdGUgJiAoU1RBVEVfRkFJTEVEIHwgU1RBVEVfUE9TU0lCTEUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAqL1xuICByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgIGxldCBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbih7fSwgaW5wdXREYXRhKTtcblxuICAgIC8vIGlzIGlzIGVuYWJsZWQgYW5kIGFsbG93IHJlY29nbml6aW5nP1xuICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgd2hlbiB3ZSd2ZSByZWFjaGVkIHRoZSBlbmRcbiAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpO1xuXG4gICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgLy8gc28gdHJpZ2dlciBhbiBldmVudFxuICAgIGlmICh0aGlzLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEIHwgU1RBVEVfQ0FOQ0VMTEVEKSkge1xuICAgICAgdGhpcy50cnlFbWl0KGlucHV0RGF0YUNsb25lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICogQHZpcnR1YWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKiBAcmV0dXJucyB7Y29uc3RhbnR9IFNUQVRFXG4gICAqL1xuXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgcHJvY2VzcyhpbnB1dERhdGEpIHsgfVxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICogQHZpcnR1YWxcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7IH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICogbGlrZSB3aGVuIGFub3RoZXIgaXMgYmVpbmcgcmVjb2duaXplZCBvciBpdCBpcyBkaXNhYmxlZFxuICAgKiBAdmlydHVhbFxuICAgKi9cbiAgcmVzZXQoKSB7IH1cbn0iLCJpbXBvcnQgUmVjb2duaXplciBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OIH0gZnJvbSAnLi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1Db25zdHMnO1xuaW1wb3J0IHtJTlBVVF9TVEFSVCxJTlBVVF9FTkQgfSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5pbXBvcnQge1xuICAgIFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfQkVHQU4sXG4gICAgU1RBVEVfRkFJTEVEXG59IGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cyc7XG5pbXBvcnQgZ2V0RGlzdGFuY2UgZnJvbSAnLi4vaW5wdXRqcy9nZXQtZGlzdGFuY2UnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBBIHRhcCBpcyByZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgZG9pbmcgYSBzbWFsbCB0YXAvY2xpY2suIE11bHRpcGxlIHRhcHMgYXJlIHJlY29nbml6ZWQgaWYgdGhleSBvY2N1clxuICogYmV0d2VlbiB0aGUgZ2l2ZW4gaW50ZXJ2YWwgYW5kIHBvc2l0aW9uLiBUaGUgZGVsYXkgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHJlY29nbml6ZSBtdWx0aS10YXBzIHdpdGhvdXQgZmlyaW5nXG4gKiBhIHNpbmdsZSB0YXAuXG4gKlxuICogVGhlIGV2ZW50RGF0YSBmcm9tIHRoZSBlbWl0dGVkIGV2ZW50IGNvbnRhaW5zIHRoZSBwcm9wZXJ0eSBgdGFwQ291bnRgLCB3aGljaCBjb250YWlucyB0aGUgYW1vdW50IG9mXG4gKiBtdWx0aS10YXBzIGJlaW5nIHJlY29nbml6ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFwUmVjb2duaXplciBleHRlbmRzIFJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBldmVudDogJ3RhcCcsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRhcHM6IDEsXG4gICAgICBpbnRlcnZhbDogMzAwLCAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgdGltZTogMjUwLCAvLyBtYXggdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBkb3duIChsaWtlIGZpbmdlciBvbiB0aGUgc2NyZWVuKVxuICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgcG9zVGhyZXNob2xkOiAxMCwgLy8gYSBtdWx0aS10YXAgY2FuIGJlIGEgYml0IG9mZiB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OXTtcbiAgfVxuXG4gIHByb2Nlc3MoaW5wdXQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzO1xuXG4gICAgbGV0IHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgbGV0IHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgIGxldCB2YWxpZFRvdWNoVGltZSA9IGlucHV0LmRlbHRhVGltZSA8IG9wdGlvbnMudGltZTtcblxuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICBpZiAodmFsaWRNb3ZlbWVudCAmJiB2YWxpZFRvdWNoVGltZSAmJiB2YWxpZFBvaW50ZXJzKSB7XG4gICAgICBpZiAoaW5wdXQuZXZlbnRUeXBlICE9PSBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbGlkSW50ZXJ2YWwgPSB0aGlzLnBUaW1lID8gKGlucHV0LnRpbWVTdGFtcCAtIHRoaXMucFRpbWUgPCBvcHRpb25zLmludGVydmFsKSA6IHRydWU7XG4gICAgICBsZXQgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG5cbiAgICAgIHRoaXMucFRpbWUgPSBpbnB1dC50aW1lU3RhbXA7XG4gICAgICB0aGlzLnBDZW50ZXIgPSBpbnB1dC5jZW50ZXI7XG5cbiAgICAgIGlmICghdmFsaWRNdWx0aVRhcCB8fCAhdmFsaWRJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgIGxldCB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgLy8gbm8gZmFpbGluZyByZXF1aXJlbWVudHMsIGltbWVkaWF0ZWx5IHRyaWdnZXIgdGhlIHRhcCBldmVudFxuICAgICAgICAvLyBvciB3YWl0IGFzIGxvbmcgYXMgdGhlIG11bHRpdGFwIGludGVydmFsIHRvIHRyaWdnZXJcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH1cblxuICBmYWlsVGltZW91dCgpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9XG5cbiAgZW1pdCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU1RBVEVfUkVDT0dOSVpFRCkge1xuICAgICAgdGhpcy5faW5wdXQudGFwQ291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgUmVjb2duaXplciBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQge1xuICAgIFNUQVRFX0JFR0FOLFxuICAgIFNUQVRFX0NIQU5HRUQsXG4gICAgU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0VOREVELFxuICAgIFNUQVRFX0ZBSUxFRFxufSBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMnO1xuaW1wb3J0IHtcbiAgICBJTlBVVF9DQU5DRUwsXG4gICAgSU5QVVRfRU5EXG59IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF0dHJSZWNvZ25pemVyIGV4dGVuZHMgUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBVc2VkIHRvIGNoZWNrIGlmIGl0IHRoZSByZWNvZ25pemVyIHJlY2VpdmVzIHZhbGlkIGlucHV0LCBsaWtlIGlucHV0LmRpc3RhbmNlID4gMTAuXG4gICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHJlY29nbml6ZWRcbiAgICovXG4gIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgbGV0IG9wdGlvblBvaW50ZXJzID0gdGhpcy5vcHRpb25zLnBvaW50ZXJzO1xuICAgIHJldHVybiBvcHRpb25Qb2ludGVycyA9PT0gMCB8fCBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvblBvaW50ZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgKi9cbiAgcHJvY2VzcyhpbnB1dCkge1xuICAgIGxldCB7IHN0YXRlIH0gPSB0aGlzO1xuICAgIGxldCB7IGV2ZW50VHlwZSB9ID0gaW5wdXQ7XG5cbiAgICBsZXQgaXNSZWNvZ25pemVkID0gc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEKTtcbiAgICBsZXQgaXNWYWxpZCA9IHRoaXMuYXR0clRlc3QoaW5wdXQpO1xuXG4gICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgIGlmIChpc1JlY29nbml6ZWQgJiYgKGV2ZW50VHlwZSAmIElOUFVUX0NBTkNFTCB8fCAhaXNWYWxpZCkpIHtcbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NBTkNFTExFRDtcbiAgICB9IGVsc2UgaWYgKGlzUmVjb2duaXplZCB8fCBpc1ZhbGlkKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0VOREVEO1xuICAgICAgfSBlbHNlIGlmICghKHN0YXRlICYgU1RBVEVfQkVHQU4pKSB7XG4gICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgfVxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gICAgRElSRUNUSU9OX0xFRlQsXG4gICAgRElSRUNUSU9OX1JJR0hULFxuICAgIERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTlxufSBmcm9tICcuLi9pbnB1dGpzL2lucHV0LWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGRpcmVjdGlvbiBjb25zIHRvIHN0cmluZ1xuICogQHBhcmFtIHtjb25zdGFudH0gZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXJlY3Rpb25TdHIoZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ET1dOKSB7XG4gICAgcmV0dXJuICdkb3duJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9VUCkge1xuICAgIHJldHVybiAndXAnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1JJR0hUKSB7XG4gICAgcmV0dXJuICdyaWdodCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuIiwiaW1wb3J0ICBBdHRyUmVjb2duaXplciBmcm9tICcuL2F0dHJpYnV0ZSc7XG5pbXBvcnQge1xuICAgIERJUkVDVElPTl9BTEwsXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUwsXG4gICAgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTixcbiAgICBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFRcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IHsgU1RBVEVfQkVHQU4gfSBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHMnO1xuaW1wb3J0IHsgVE9VQ0hfQUNUSU9OX1BBTl9YLFRPVUNIX0FDVElPTl9QQU5fWSB9IGZyb20gJy4uL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzJztcbmltcG9ydCBkaXJlY3Rpb25TdHIgZnJvbSAnLi4vcmVjb2duaXplcmpzL2RpcmVjdGlvbi1zdHInO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhblJlY29nbml6ZXIgZXh0ZW5kcyBBdHRyUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTCxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgdGhpcy5wWCA9IG51bGw7XG4gICAgdGhpcy5wWSA9IG51bGw7XG4gIH1cblxuICBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICBsZXQgeyBvcHRpb25zOnsgZGlyZWN0aW9uIH0gfSA9IHRoaXM7XG4gICAgbGV0IGFjdGlvbnMgPSBbXTtcbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICBhY3Rpb25zLnB1c2goVE9VQ0hfQUNUSU9OX1BBTl9YKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvbnM7XG4gIH1cblxuICBkaXJlY3Rpb25UZXN0KGlucHV0KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBsZXQgaGFzTW92ZWQgPSB0cnVlO1xuICAgIGxldCB7IGRpc3RhbmNlIH0gPSBpbnB1dDtcbiAgICBsZXQgeyBkaXJlY3Rpb24gfSA9IGlucHV0O1xuICAgIGxldCB4ID0gaW5wdXQuZGVsdGFYO1xuICAgIGxldCB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgLy8gbG9jayB0byBheGlzP1xuICAgIGlmICghKGRpcmVjdGlvbiAmIG9wdGlvbnMuZGlyZWN0aW9uKSkge1xuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gKHggPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgIGhhc01vdmVkID0geCAhPT0gdGhpcy5wWDtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgIGhhc01vdmVkID0geSAhPT0gdGhpcy5wWTtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gIH1cblxuICBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgLy8gcmVwbGFjZSB3aXRoIGEgc3VwZXIgY2FsbFxuICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICB9XG5cbiAgZW1pdChpbnB1dCkge1xuXG4gICAgdGhpcy5wWCA9IGlucHV0LmRlbHRhWDtcbiAgICB0aGlzLnBZID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgbGV0IGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgIH1cbiAgICBzdXBlci5lbWl0KGlucHV0KTtcbiAgfVxufVxuIiwiaW1wb3J0IEF0dHJSZWNvZ25pemVyIGZyb20gJy4uL3JlY29nbml6ZXJzL2F0dHJpYnV0ZSc7XG5pbXBvcnQgeyBhYnMgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IHsgRElSRUNUSU9OX0hPUklaT05UQUwsRElSRUNUSU9OX1ZFUlRJQ0FMIH0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IFBhblJlY29nbml6ZXIgZnJvbSAnLi9wYW4nO1xuaW1wb3J0IHsgSU5QVVRfRU5EIH0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IGRpcmVjdGlvblN0ciBmcm9tICcuLi9yZWNvZ25pemVyanMvZGlyZWN0aW9uLXN0cic7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFN3aXBlXG4gKiBSZWNvZ25pemVkIHdoZW4gdGhlIHBvaW50ZXIgaXMgbW92aW5nIGZhc3QgKHZlbG9jaXR5KSwgd2l0aCBlbm91Z2ggZGlzdGFuY2UgaW4gdGhlIGFsbG93ZWQgZGlyZWN0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBBdHRyUmVjb2duaXplclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZVJlY29nbml6ZXIgZXh0ZW5kcyBBdHRyUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgdGhyZXNob2xkOiAxMCxcbiAgICAgIHZlbG9jaXR5OiAwLjMsXG4gICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBhblJlY29nbml6ZXIucHJvdG90eXBlLmdldFRvdWNoQWN0aW9uLmNhbGwodGhpcyk7XG4gIH1cblxuICBhdHRyVGVzdChpbnB1dCkge1xuICAgIGxldCB7IGRpcmVjdGlvbiB9ID0gdGhpcy5vcHRpb25zO1xuICAgIGxldCB2ZWxvY2l0eTtcblxuICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuYXR0clRlc3QoaW5wdXQpICYmXG4gICAgICAgIGRpcmVjdGlvbiAmIGlucHV0Lm9mZnNldERpcmVjdGlvbiAmJlxuICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgaW5wdXQubWF4UG9pbnRlcnMgPT09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICBhYnModmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgfVxuXG4gIGVtaXQoaW5wdXQpIHtcbiAgICBsZXQgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCBpbnB1dCk7XG4gIH1cbn1cbiIsImltcG9ydCBBdHRyUmVjb2duaXplciBmcm9tICcuL2F0dHJpYnV0ZSc7XG5pbXBvcnQgeyBUT1VDSF9BQ1RJT05fTk9ORSB9IGZyb20gJy4uL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tQ29uc3RzJztcbmltcG9ydCB7IFNUQVRFX0JFR0FOIH0gZnJvbSAnLi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUGluY2hcbiAqIFJlY29nbml6ZWQgd2hlbiB0d28gb3IgbW9yZSBwb2ludGVycyBhcmUgbW92aW5nIHRvd2FyZCAoem9vbS1pbikgb3IgYXdheSBmcm9tIGVhY2ggb3RoZXIgKHpvb20tb3V0KS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGluY2hSZWNvZ25pemVyIGV4dGVuZHMgQXR0clJlY29nbml6ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBldmVudDogJ3BpbmNoJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9XG5cbiAgYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gc3VwZXIuYXR0clRlc3QoaW5wdXQpICYmXG4gICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICB9XG5cbiAgZW1pdChpbnB1dCkge1xuICAgIGlmIChpbnB1dC5zY2FsZSAhPT0gMSkge1xuICAgICAgbGV0IGluT3V0ID0gaW5wdXQuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnO1xuICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgaW5PdXQ7XG4gICAgfVxuICAgIHN1cGVyLmVtaXQoaW5wdXQpO1xuICB9XG59XG4iLCJpbXBvcnQgQXR0clJlY29nbml6ZXIgZnJvbSAnLi9hdHRyaWJ1dGUnO1xuaW1wb3J0IHsgVE9VQ0hfQUNUSU9OX05PTkUgfSBmcm9tICcuLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5pbXBvcnQgeyBTVEFURV9CRUdBTiB9IGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm90YXRlUmVjb2duaXplciBleHRlbmRzIEF0dHJSZWNvZ25pemVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoIHtcbiAgICAgIGV2ZW50OiAncm90YXRlJyxcbiAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgIHBvaW50ZXJzOiAyLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxuXG4gIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9XG5cbiAgYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gc3VwZXIuYXR0clRlc3QoaW5wdXQpICYmXG4gICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gIH1cbn0iLCJpbXBvcnQgUmVjb2duaXplciBmcm9tICcuLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQge1xuICAgIFNUQVRFX1JFQ09HTklaRUQsXG4gICAgU1RBVEVfRkFJTEVEXG59IGZyb20gJy4uL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cyc7XG5pbXBvcnQgeyBub3cgfSBmcm9tICcuLi91dGlscy91dGlscy1jb25zdHMnO1xuaW1wb3J0IHsgVE9VQ0hfQUNUSU9OX0FVVE8gfSBmcm9tICcuLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0cyc7XG5pbXBvcnQge1xuICAgIElOUFVUX1NUQVJULFxuICAgIElOUFVUX0VORCxcbiAgICBJTlBVVF9DQU5DRUxcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlc3NSZWNvZ25pemVyIGV4dGVuZHMgUmVjb2duaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIGV2ZW50OiAncHJlc3MnLFxuICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICB0aHJlc2hvbGQ6IDksIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gIH1cblxuICBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9BVVRPXTtcbiAgfVxuXG4gIHByb2Nlc3MoaW5wdXQpIHtcbiAgICBsZXQgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGxldCB2YWxpZFBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSBvcHRpb25zLnBvaW50ZXJzO1xuICAgIGxldCB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICBsZXQgdmFsaWRUaW1lID0gaW5wdXQuZGVsdGFUaW1lID4gb3B0aW9ucy50aW1lO1xuXG4gICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgLy8gYW5kIHdlJ3ZlIHJlYWNoZWQgYW4gZW5kIGV2ZW50LCBzbyBhIHRhcCBpcyBwb3NzaWJsZVxuICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCAoaW5wdXQuZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgIXZhbGlkVGltZSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgdGhpcy50cnlFbWl0KCk7XG4gICAgICB9LCBvcHRpb25zLnRpbWUpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICB9XG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH1cblxuICBlbWl0KGlucHV0KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQgJiYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkpIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KGAke3RoaXMub3B0aW9ucy5ldmVudH11cGAsIGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICB9XG4gIH1cbn1cblxuIiwiaW1wb3J0IHsgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgfSBmcm9tIFwiLi90b3VjaGFjdGlvbmpzL3RvdWNoYWN0aW9uLUNvbnN0c1wiO1xuaW1wb3J0IFRhcFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvdGFwXCI7XG5pbXBvcnQgUGFuUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9wYW5cIjtcbmltcG9ydCBTd2lwZVJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvc3dpcGVcIjtcbmltcG9ydCBQaW5jaFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcGluY2hcIjtcbmltcG9ydCBSb3RhdGVSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3JvdGF0ZVwiO1xuaW1wb3J0IFByZXNzUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9wcmVzc1wiO1xuaW1wb3J0IHtESVJFQ1RJT05fSE9SSVpPTlRBTH0gZnJvbSBcIi4vaW5wdXRqcy9pbnB1dC1jb25zdHNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cblx0ICogQnV0IHRoaXMgaXMgc2xvd2VyIGFuZCB1bnVzZWQgYnkgc2ltcGxlIGltcGxlbWVudGF0aW9ucywgc28gZGlzYWJsZWQgYnkgZGVmYXVsdC5cblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IGZhbHNlXG5cdCAqL1xuXHRkb21FdmVudHM6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBUaGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eS9mYWxsYmFjay5cblx0ICogV2hlbiBzZXQgdG8gYGNvbXB1dGVgIGl0IHdpbGwgbWFnaWNhbGx5IHNldCB0aGUgY29ycmVjdCB2YWx1ZSBiYXNlZCBvbiB0aGUgYWRkZWQgcmVjb2duaXplcnMuXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqIEBkZWZhdWx0IGNvbXB1dGVcblx0ICovXG5cdHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0IHRydWVcblx0ICovXG5cdGVuYWJsZTogdHJ1ZSxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogRVhQRVJJTUVOVEFMIEZFQVRVUkUgLS0gY2FuIGJlIHJlbW92ZWQvY2hhbmdlZFxuXHQgKiBDaGFuZ2UgdGhlIHBhcmVudCBpbnB1dCB0YXJnZXQgZWxlbWVudC5cblx0ICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cblx0ICogQHR5cGUge051bGx8RXZlbnRUYXJnZXR9XG5cdCAqIEBkZWZhdWx0IG51bGxcblx0ICovXG5cdGlucHV0VGFyZ2V0OiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuXHQgKiBAdHlwZSB7TnVsbHxGdW5jdGlvbn1cblx0ICogQGRlZmF1bHQgbnVsbFxuXHQgKi9cblx0aW5wdXRDbGFzczogbnVsbCxcblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogU29tZSBDU1MgcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBpbXByb3ZlIHRoZSB3b3JraW5nIG9mIEhhbW1lci5cblx0ICogQWRkIHRoZW0gdG8gdGhpcyBtZXRob2QgYW5kIHRoZXkgd2lsbCBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyLlxuXHQgKiBAbmFtZXNwYWNlXG5cdCAqL1xuXHRjc3NQcm9wczoge1xuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogRGlzYWJsZXMgdGV4dCBzZWxlY3Rpb24gdG8gaW1wcm92ZSB0aGUgZHJhZ2dpbmcgZ2VzdHVyZS4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgJ25vbmUnXG5cdFx0ICovXG5cdFx0dXNlclNlbGVjdDogXCJub25lXCIsXG5cblx0XHQvKipcblx0XHQgKiBAcHJpdmF0ZVxuXHRcdCAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgJ25vbmUnXG5cdFx0ICovXG5cdFx0dG91Y2hTZWxlY3Q6IFwibm9uZVwiLFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBEaXNhYmxlcyB0aGUgZGVmYXVsdCBjYWxsb3V0IHNob3duIHdoZW4geW91IHRvdWNoIGFuZCBob2xkIGEgdG91Y2ggdGFyZ2V0LlxuXHRcdCAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuXHRcdCAqIGEgY2FsbG91dCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBsaW5rLiBUaGlzIHByb3BlcnR5IGFsbG93cyB5b3UgdG8gZGlzYWJsZSB0aGF0IGNhbGxvdXQuXG5cdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHQgKiBAZGVmYXVsdCAnbm9uZSdcblx0XHQgKi9cblx0XHR0b3VjaENhbGxvdXQ6IFwibm9uZVwiLFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdub25lJ1xuXHRcdCAqL1xuXHRcdGNvbnRlbnRab29taW5nOiBcIm5vbmVcIixcblxuXHRcdC8qKlxuXHRcdCAqIEBwcml2YXRlXG5cdFx0ICogU3BlY2lmaWVzIHRoYXQgYW4gZW50aXJlIGVsZW1lbnQgc2hvdWxkIGJlIGRyYWdnYWJsZSBpbnN0ZWFkIG9mIGl0cyBjb250ZW50cy4gTWFpbmx5IGZvciBkZXNrdG9wIGJyb3dzZXJzLlxuXHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0ICogQGRlZmF1bHQgJ25vbmUnXG5cdFx0ICovXG5cdFx0dXNlckRyYWc6IFwibm9uZVwiLFxuXG5cdFx0LyoqXG5cdFx0ICogQHByaXZhdGVcblx0XHQgKiBPdmVycmlkZXMgdGhlIGhpZ2hsaWdodCBjb2xvciBzaG93biB3aGVuIHRoZSB1c2VyIHRhcHMgYSBsaW5rIG9yIGEgSmF2YVNjcmlwdFxuXHRcdCAqIGNsaWNrYWJsZSBlbGVtZW50IGluIGlPUy4gVGhpcyBwcm9wZXJ0eSBvYmV5cyB0aGUgYWxwaGEgdmFsdWUsIGlmIHNwZWNpZmllZC5cblx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdCAqIEBkZWZhdWx0ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdCAqL1xuXHRcdHRhcEhpZ2hsaWdodENvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcblx0fSxcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIERlZmF1bHQgcmVjb2duaXplciBzZXR1cCB3aGVuIGNhbGxpbmcgYEhhbW1lcigpYFxuICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAqIFRoaXMgaXMgc2VwYXJhdGVkIHdpdGggb3RoZXIgZGVmYXVsdHMgYmVjYXVzZSBvZiB0cmVlLXNoYWtpbmcuXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBwcmVzZXQgPSBbXG4gIFtSb3RhdGVSZWNvZ25pemVyLCB7IGVuYWJsZTogZmFsc2UgfV0sXG4gIFtQaW5jaFJlY29nbml6ZXIsIHsgZW5hYmxlOiBmYWxzZSB9LCBbJ3JvdGF0ZSddXSxcbiAgW1N3aXBlUmVjb2duaXplciwgeyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH1dLFxuICBbUGFuUmVjb2duaXplciwgeyBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIH0sIFsnc3dpcGUnXV0sXG4gIFtUYXBSZWNvZ25pemVyXSxcbiAgW1RhcFJlY29nbml6ZXIsIHsgZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyIH0sIFsndGFwJ11dLFxuICBbUHJlc3NSZWNvZ25pemVyXVxuXTtcbiIsImltcG9ydCBhc3NpZ24gZnJvbSBcIi4vdXRpbHMvYXNzaWduXCI7XG5pbXBvcnQgVG91Y2hBY3Rpb24gZnJvbSBcIi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IGNyZWF0ZUlucHV0SW5zdGFuY2UgZnJvbSBcIi4vaW5wdXRqcy9jcmVhdGUtaW5wdXQtaW5zdGFuY2VcIjtcbmltcG9ydCBlYWNoIGZyb20gXCIuL3V0aWxzL2VhY2hcIjtcbmltcG9ydCBpbkFycmF5IGZyb20gXCIuL3V0aWxzL2luLWFycmF5XCI7XG5pbXBvcnQgaW52b2tlQXJyYXlBcmcgZnJvbSBcIi4vdXRpbHMvaW52b2tlLWFycmF5LWFyZ1wiO1xuaW1wb3J0IHNwbGl0U3RyIGZyb20gXCIuL3V0aWxzL3NwbGl0LXN0clwiO1xuaW1wb3J0IHByZWZpeGVkIGZyb20gXCIuL3V0aWxzL3ByZWZpeGVkXCI7XG5pbXBvcnQgUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHtcbiAgU1RBVEVfQkVHQU4sXG4gIFNUQVRFX0VOREVELFxuICBTVEFURV9DSEFOR0VELFxuICBTVEFURV9SRUNPR05JWkVELFxufSBmcm9tIFwiLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHNcIjtcbmltcG9ydCBkZWZhdWx0cyBmcm9tIFwiLi9kZWZhdWx0c1wiO1xuXG5jb25zdCBTVE9QID0gMTtcbmNvbnN0IEZPUkNFRF9TVE9QID0gMjtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgY29uc3QgeyBlbGVtZW50IH0gPSBtYW5hZ2VyO1xuXG4gIGlmICghZWxlbWVudC5zdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcHJvcDtcblxuICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuICAgIGlmIChhZGQpIHtcbiAgICAgIG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gPSBlbGVtZW50LnN0eWxlW3Byb3BdO1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gbWFuYWdlci5vbGRDc3NQcm9wc1twcm9wXSB8fCBcIlwiO1xuICAgIH1cbiAgfSk7XG4gIGlmICghYWRkKSB7XG4gICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIHRyaWdnZXIgZG9tIGV2ZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSkge1xuICBjb25zdCBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuXG4gIGdlc3R1cmVFdmVudC5pbml0RXZlbnQoZXZlbnQsIHRydWUsIHRydWUpO1xuICBnZXN0dXJlRXZlbnQuZ2VzdHVyZSA9IGRhdGE7XG4gIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuXG4vKipcbiogQHByaXZhdGVcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0ID0gdGhpcy5vcHRpb25zLmlucHV0VGFyZ2V0IHx8IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcblxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dCA9IGNyZWF0ZUlucHV0SW5zdGFuY2UodGhpcyk7XG4gICAgdGhpcy50b3VjaEFjdGlvbiA9IG5ldyBUb3VjaEFjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuXG4gICAgdG9nZ2xlQ3NzUHJvcHModGhpcywgdHJ1ZSk7XG5cbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgaXRlbSA9PiB7XG4gICAgICBjb25zdCByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG5cbiAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgaXRlbVszXSAmJiByZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKGl0ZW1bM10pO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIHNldCBvcHRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuXHQgKi9cbiAgc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIE9wdGlvbnMgdGhhdCBuZWVkIGEgbGl0dGxlIG1vcmUgc2V0dXBcbiAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW5wdXRUYXJnZXQpIHtcbiAgICAgIC8vIENsZWFuIHVwIGV4aXN0aW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVpbml0aWFsaXplXG4gICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaW5wdXQudGFyZ2V0ID0gb3B0aW9ucy5pbnB1dFRhcmdldDtcbiAgICAgIHRoaXMuaW5wdXQuaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG5cdCAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG5cdCAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cblx0ICovXG4gIHN0b3AoZm9yY2UpIHtcbiAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG5cdCAqIGNhbGxlZCBieSB0aGUgaW5wdXRIYW5kbGVyIGZ1bmN0aW9uIG9uIGV2ZXJ5IG1vdmVtZW50IG9mIHRoZSBwb2ludGVycyAodG91Y2hlcylcblx0ICogaXQgd2Fsa3MgdGhyb3VnaCBhbGwgdGhlIHJlY29nbml6ZXJzIGFuZCB0cmllcyB0byBkZXRlY3QgdGhlIGdlc3R1cmUgdGhhdCBpcyBiZWluZyBtYWRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcblx0ICovXG4gIHJlY29nbml6ZShpbnB1dERhdGEpIHtcbiAgICBjb25zdCB7IHNlc3Npb24gfSA9IHRoaXM7XG5cbiAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuXG4gICAgbGV0IHJlY29nbml6ZXI7XG4gICAgY29uc3QgeyByZWNvZ25pemVycyB9ID0gdGhpcztcblxuICAgIC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgbGV0IHsgY3VyUmVjb2duaXplciB9ID0gc2Vzc2lvbjtcblxuICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgLy8gb3Igd2hlbiB3ZSdyZSBpbiBhIG5ldyBzZXNzaW9uXG4gICAgaWYgKCFjdXJSZWNvZ25pemVyIHx8IChjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSkge1xuICAgICAgc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgIGN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGxldCBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgcmVjb2duaXplcnMubGVuZ3RoKSB7XG4gICAgICByZWNvZ25pemVyID0gcmVjb2duaXplcnNbaV07XG5cbiAgICAgIC8vIGZpbmQgb3V0IGlmIHdlIGFyZSBhbGxvd2VkIHRyeSB0byByZWNvZ25pemUgdGhlIGlucHV0IGZvciB0aGlzIG9uZS5cbiAgICAgIC8vIDEuICAgYWxsb3cgaWYgdGhlIHNlc3Npb24gaXMgTk9UIGZvcmNlZCBzdG9wcGVkIChzZWUgdGhlIC5zdG9wKCkgbWV0aG9kKVxuICAgICAgLy8gMi4gICBhbGxvdyBpZiB3ZSBzdGlsbCBoYXZlbid0IHJlY29nbml6ZWQgYSBnZXN0dXJlIGluIHRoaXMgc2Vzc2lvbiwgb3IgdGhlIHRoaXMgcmVjb2duaXplciBpcyB0aGUgb25lXG4gICAgICAvLyAgICAgIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgIC8vIDMuICAgYWxsb3cgaWYgdGhlIHJlY29nbml6ZXIgaXMgYWxsb3dlZCB0byBydW4gc2ltdWx0YW5lb3VzIHdpdGggdGhlIGN1cnJlbnQgcmVjb2duaXplZCByZWNvZ25pemVyLlxuICAgICAgLy8gICAgICB0aGlzIGNhbiBiZSBzZXR1cCB3aXRoIHRoZSBgcmVjb2duaXplV2l0aCgpYCBtZXRob2Qgb24gdGhlIHJlY29nbml6ZXIuXG4gICAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkICE9PSBGT1JDRURfU1RPUCAmJiAoLy8gMVxuICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgICAgcmVjb2duaXplci5jYW5SZWNvZ25pemVXaXRoKGN1clJlY29nbml6ZXIpKSkgeyAvLyAzXG4gICAgICAgIHJlY29nbml6ZXIucmVjb2duaXplKGlucHV0RGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICBjdXJSZWNvZ25pemVyID0gcmVjb2duaXplcjtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cblx0ICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuXHQgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuXHQgKi9cbiAgZ2V0KHJlY29nbml6ZXIpIHtcbiAgICBpZiAocmVjb2duaXplciBpbnN0YW5jZW9mIFJlY29nbml6ZXIpIHtcbiAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH1cblxuICAgIGNvbnN0IHsgcmVjb2duaXplcnMgfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PT0gcmVjb2duaXplcikge1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcnNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcblx0ICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuXHQgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcblx0ICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cblx0ICovXG4gIGFkZChyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwiYWRkXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZXhpc3RpbmdcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcblxuICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGVcblx0ICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcblx0ICogQHJldHVybnMge01hbmFnZXJ9XG5cdCAqL1xuICByZW1vdmUocmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCBcInJlbW92ZVwiLCB0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0UmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgLy8gbGV0J3MgbWFrZSBzdXJlIHRoaXMgcmVjb2duaXplciBleGlzdHNcbiAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgY29uc3QgeyByZWNvZ25pemVycyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgdGFyZ2V0UmVjb2duaXplcik7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmVjb2duaXplcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBiaW5kIGV2ZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG5cdCAqL1xuICBvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQgfHwgaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCB7IGhhbmRsZXJzIH0gPSB0aGlzO1xuXG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBldmVudCA9PiB7XG4gICAgICBoYW5kbGVyc1tldmVudF0gPSBoYW5kbGVyc1tldmVudF0gfHwgW107XG4gICAgICBoYW5kbGVyc1tldmVudF0ucHVzaChoYW5kbGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cdC8qKlxuXHQgKiBAcHJpdmF0ZSB1bmJpbmQgZXZlbnQsIGxlYXZlIGVtaXQgYmxhbmsgdG8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXVxuXHQgKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSB0aGlzXG5cdCAqL1xuICBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCB7IGhhbmRsZXJzIH0gPSB0aGlzO1xuXG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBldmVudCA9PiB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXHQvKipcblx0ICogQHByaXZhdGUgZW1pdCBldmVudCB0byB0aGUgbGlzdGVuZXJzXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKi9cbiAgZW1pdChldmVudCwgZGF0YSkge1xuICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICBpZiAodGhpcy5vcHRpb25zLmRvbUV2ZW50cykge1xuICAgICAgdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKTtcbiAgICB9XG5cbiAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICBkYXRhLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgaGFuZGxlcnNbaV0oZGF0YSk7XG4gICAgICBpKys7XG4gICAgfVxuICB9XG5cblx0LyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuXHQgKiBpdCBkb2Vzbid0IHVuYmluZCBkb20gZXZlbnRzLCB0aGF0IGlzIHRoZSB1c2VyIG93biByZXNwb25zaWJpbGl0eVxuXHQgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVsZW1lbnQgJiYgdG9nZ2xlQ3NzUHJvcHModGhpcywgZmFsc2UpO1xuXG4gICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuc2Vzc2lvbiA9IHt9O1xuICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gICAgSU5QVVRfU1RBUlQsXG4gICAgSU5QVVRfTU9WRSxcbiAgICBJTlBVVF9FTkQsXG4gICAgSU5QVVRfQ0FOQ0VMLFxuICAgIElOUFVUX1RZUEVfVE9VQ0hcbn0gZnJvbSAnLi4vaW5wdXRqcy9pbnB1dC1jb25zdHMnO1xuaW1wb3J0IElucHV0IGZyb20gJy4uL2lucHV0anMvaW5wdXQtY29uc3RydWN0b3InO1xuaW1wb3J0IHRvQXJyYXkgZnJvbSAnLi4vdXRpbHMvdG8tYXJyYXknO1xuaW1wb3J0IHVuaXF1ZUFycmF5IGZyb20gJy4uL3V0aWxzL3VuaXF1ZS1hcnJheSc7XG5cbmNvbnN0IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG5cbmNvbnN0IFNJTkdMRV9UT1VDSF9UQVJHRVRfRVZFTlRTID0gJ3RvdWNoc3RhcnQnO1xuY29uc3QgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBUb3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2luZ2xlVG91Y2hJbnB1dCBleHRlbmRzIElucHV0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHByb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuXG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIoZXYpIHtcbiAgICBsZXQgdHlwZSA9IFNJTkdMRV9UT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG5cbiAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpO1xuXG4gICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgdG91Y2hlc1swXS5sZW5ndGggLSB0b3VjaGVzWzFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICBsZXQgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgbGV0IGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cbiIsIi8qKlxuICogQHByaXZhdGVcbiAqIHdyYXAgYSBtZXRob2Qgd2l0aCBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgYW5kIHN0YWNrIHRyYWNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyB0aGUgc3VwcGxpZWQgbWV0aG9kLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZXByZWNhdGUobWV0aG9kLCBuYW1lLCBtZXNzYWdlKSB7XG4gIGxldCBkZXByZWNhdGlvbk1lc3NhZ2UgPSBgREVQUkVDQVRFRCBNRVRIT0Q6ICR7bmFtZX1cXG4ke21lc3NhZ2V9IEFUIFxcbmA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBsZXQgZSA9IG5ldyBFcnJvcignZ2V0LXN0YWNrLXRyYWNlJyk7XG4gICAgbGV0IHN0YWNrID0gZSAmJiBlLnN0YWNrID8gZS5zdGFjay5yZXBsYWNlKC9eW15cXChdKz9bXFxuJF0vZ20sICcnKVxuICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAucmVwbGFjZSgvXk9iamVjdC48YW5vbnltb3VzPlxccypcXCgvZ20sICd7YW5vbnltb3VzfSgpQCcpIDogJ1Vua25vd24gU3RhY2sgVHJhY2UnO1xuXG4gICAgbGV0IGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG4gICAgaWYgKGxvZykge1xuICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCJpbXBvcnQgZGVwcmVjYXRlIGZyb20gJy4vZGVwcmVjYXRlJztcbi8qKlxuICogQHByaXZhdGVcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV1cbiAqIEByZXR1cm5zIHtPYmplY3R9IGRlc3RcbiAqL1xuY29uc3QgZXh0ZW5kID0gZGVwcmVjYXRlKChkZXN0LCBzcmMsIG1lcmdlKSA9PiB7XG4gIGxldCBrZXlzID0gT2JqZWN0LmtleXMoc3JjKTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbmV4cG9ydCBkZWZhdWx0IGV4dGVuZDtcbiIsImltcG9ydCBkZXByZWNhdGUgZnJvbSAnLi9kZXByZWNhdGUnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuL2V4dGVuZCc7XG4vKipcbiAqIEBwcml2YXRlXG4gKiBtZXJnZSB0aGUgdmFsdWVzIGZyb20gc3JjIGluIHRoZSBkZXN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIHRoYXQgZXhpc3QgaW4gZGVzdCB3aWxsIG5vdCBiZSBvdmVyd3JpdHRlbiBieSBzcmNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbmNvbnN0IG1lcmdlID0gZGVwcmVjYXRlKChkZXN0LCBzcmMpID0+IHtcbiAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCJpbXBvcnQgYXNzaWduIGZyb20gJy4vYXNzaWduJztcbi8qKlxuICogQHByaXZhdGVcbiAqIHNpbXBsZSBjbGFzcyBpbmhlcml0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2hpbGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGJhc2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc11cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5oZXJpdChjaGlsZCwgYmFzZSwgcHJvcGVydGllcykge1xuICBsZXQgYmFzZVAgPSBiYXNlLnByb3RvdHlwZTtcbiAgbGV0IGNoaWxkUDtcblxuICBjaGlsZFAgPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VQKTtcbiAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIGNoaWxkUC5fc3VwZXIgPSBiYXNlUDtcblxuICBpZiAocHJvcGVydGllcykge1xuICAgIGFzc2lnbihjaGlsZFAsIHByb3BlcnRpZXMpO1xuICB9XG59XG4iLCIvKipcbiAqIEBwcml2YXRlXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBNYW5hZ2VyIGZyb20gXCIuL21hbmFnZXJcIjtcbmltcG9ydCBkZWZhdWx0cywgeyBwcmVzZXQgfSBmcm9tIFwiLi9kZWZhdWx0c1wiO1xuaW1wb3J0IGFzc2lnbiBmcm9tICcuL3V0aWxzL2Fzc2lnbic7XG5pbXBvcnQge1xuICBJTlBVVF9TVEFSVCxcbiAgSU5QVVRfTU9WRSxcbiAgSU5QVVRfRU5ELFxuICBJTlBVVF9DQU5DRUwsXG4gIERJUkVDVElPTl9OT05FLFxuICBESVJFQ1RJT05fTEVGVCxcbiAgRElSRUNUSU9OX1JJR0hULFxuICBESVJFQ1RJT05fVVAsXG4gIERJUkVDVElPTl9ET1dOLFxuICBESVJFQ1RJT05fSE9SSVpPTlRBTCxcbiAgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICBESVJFQ1RJT05fQUxMLFxufSBmcm9tIFwiLi9pbnB1dGpzL2lucHV0LWNvbnN0c1wiO1xuaW1wb3J0IHtcbiAgU1RBVEVfUE9TU0lCTEUsXG4gIFNUQVRFX0JFR0FOLFxuICBTVEFURV9DSEFOR0VELFxuICBTVEFURV9FTkRFRCxcbiAgU1RBVEVfUkVDT0dOSVpFRCxcbiAgU1RBVEVfQ0FOQ0VMTEVELFxuICBTVEFURV9GQUlMRUQsXG59IGZyb20gXCIuL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0c1wiO1xuXG5pbXBvcnQgSW5wdXQgZnJvbSBcIi4vaW5wdXRqcy9pbnB1dC1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IFRvdWNoQWN0aW9uIGZyb20gXCIuL3RvdWNoYWN0aW9uanMvdG91Y2hhY3Rpb24tY29uc3RydWN0b3JcIjtcbmltcG9ydCBUb3VjaElucHV0IGZyb20gXCIuL2lucHV0L3RvdWNoXCI7XG5pbXBvcnQgTW91c2VJbnB1dCBmcm9tIFwiLi9pbnB1dC9tb3VzZVwiO1xuaW1wb3J0IFBvaW50ZXJFdmVudElucHV0IGZyb20gXCIuL2lucHV0L3BvaW50ZXJldmVudFwiO1xuaW1wb3J0IFNpbmdsZVRvdWNoSW5wdXQgZnJvbSBcIi4vaW5wdXQvc2luZ2xldG91Y2hcIjtcbmltcG9ydCBUb3VjaE1vdXNlSW5wdXQgZnJvbSBcIi4vaW5wdXQvdG91Y2htb3VzZVwiO1xuXG5pbXBvcnQgUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVyanMvcmVjb2duaXplci1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IEF0dHJSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL2F0dHJpYnV0ZVwiO1xuaW1wb3J0IFRhcFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvdGFwXCI7XG5pbXBvcnQgUGFuUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9wYW5cIjtcbmltcG9ydCBTd2lwZVJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvc3dpcGVcIjtcbmltcG9ydCBQaW5jaFJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcGluY2hcIjtcbmltcG9ydCBSb3RhdGVSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3JvdGF0ZVwiO1xuaW1wb3J0IFByZXNzUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9wcmVzc1wiO1xuXG5pbXBvcnQgYWRkRXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vdXRpbHMvYWRkLWV2ZW50LWxpc3RlbmVyc1wiO1xuaW1wb3J0IHJlbW92ZUV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL3V0aWxzL3JlbW92ZS1ldmVudC1saXN0ZW5lcnNcIjtcbmltcG9ydCBlYWNoIGZyb20gXCIuL3V0aWxzL2VhY2hcIjtcbmltcG9ydCBtZXJnZSBmcm9tIFwiLi91dGlscy9tZXJnZVwiO1xuaW1wb3J0IGV4dGVuZCBmcm9tIFwiLi91dGlscy9leHRlbmRcIjtcbmltcG9ydCBpbmhlcml0IGZyb20gXCIuL3V0aWxzL2luaGVyaXRcIjtcbmltcG9ydCBiaW5kRm4gZnJvbSBcIi4vdXRpbHMvYmluZC1mblwiO1xuaW1wb3J0IHByZWZpeGVkIGZyb20gXCIuL3V0aWxzL3ByZWZpeGVkXCI7XG5pbXBvcnQgdG9BcnJheSBmcm9tIFwiLi91dGlscy90by1hcnJheVwiO1xuaW1wb3J0IHVuaXF1ZUFycmF5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZS1hcnJheVwiO1xuaW1wb3J0IHNwbGl0U3RyIGZyb20gXCIuL3V0aWxzL3NwbGl0LXN0clwiO1xuaW1wb3J0IGluQXJyYXkgZnJvbSBcIi4vdXRpbHMvaW4tYXJyYXlcIjtcbmltcG9ydCBib29sT3JGbiBmcm9tIFwiLi91dGlscy9ib29sLW9yLWZuXCI7XG5pbXBvcnQgaGFzUGFyZW50IGZyb20gXCIuL3V0aWxzL2hhcy1wYXJlbnRcIjtcbi8qKlxuICogQHByaXZhdGVcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGFtbWVyIHtcblx0LyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cblx0c3RhdGljIFZFUlNJT04gPSBcIiNfX1ZFUlNJT05fXyNcIjtcblx0c3RhdGljIERJUkVDVElPTl9BTEwgPSBESVJFQ1RJT05fQUxMO1xuXHRzdGF0aWMgRElSRUNUSU9OX0RPV04gPSBESVJFQ1RJT05fRE9XTjtcblx0c3RhdGljIERJUkVDVElPTl9MRUZUID0gRElSRUNUSU9OX0xFRlQ7XG5cdHN0YXRpYyBESVJFQ1RJT05fUklHSFQgPSBESVJFQ1RJT05fUklHSFQ7XG5cdHN0YXRpYyBESVJFQ1RJT05fVVAgPSBESVJFQ1RJT05fVVA7XG5cdHN0YXRpYyBESVJFQ1RJT05fSE9SSVpPTlRBTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMO1xuXHRzdGF0aWMgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXHRzdGF0aWMgRElSRUNUSU9OX05PTkUgPSBESVJFQ1RJT05fTk9ORTtcblx0c3RhdGljIERJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG5cdHN0YXRpYyBJTlBVVF9TVEFSVCA9IElOUFVUX1NUQVJUO1xuXHRzdGF0aWMgSU5QVVRfTU9WRSA9IElOUFVUX01PVkU7XG4gIHN0YXRpYyBJTlBVVF9FTkQgPSBJTlBVVF9FTkQ7XG5cdHN0YXRpYyBJTlBVVF9DQU5DRUwgPSBJTlBVVF9DQU5DRUw7XG5cdHN0YXRpYyBTVEFURV9QT1NTSUJMRSA9IFNUQVRFX1BPU1NJQkxFO1xuXHRzdGF0aWMgU1RBVEVfQkVHQU4gPSBTVEFURV9CRUdBTjtcblx0c3RhdGljIFNUQVRFX0NIQU5HRUQgPSBTVEFURV9DSEFOR0VEO1xuXHRzdGF0aWMgU1RBVEVfRU5ERUQgPSBTVEFURV9FTkRFRDtcblx0c3RhdGljIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9SRUNPR05JWkVEO1xuXHRzdGF0aWMgU1RBVEVfQ0FOQ0VMTEVEID0gU1RBVEVfQ0FOQ0VMTEVEO1xuXHRzdGF0aWMgU1RBVEVfRkFJTEVEID0gU1RBVEVfRkFJTEVEO1xuXHRzdGF0aWMgTWFuYWdlciA9IE1hbmFnZXI7XG5cdHN0YXRpYyBJbnB1dCA9IElucHV0O1xuXHRzdGF0aWMgVG91Y2hBY3Rpb24gPSBUb3VjaEFjdGlvbjtcblx0c3RhdGljIFRvdWNoSW5wdXQgPSBUb3VjaElucHV0O1xuXHRzdGF0aWMgTW91c2VJbnB1dCA9IE1vdXNlSW5wdXQ7XG5cdHN0YXRpYyBQb2ludGVyRXZlbnRJbnB1dCA9IFBvaW50ZXJFdmVudElucHV0O1xuXHRzdGF0aWMgVG91Y2hNb3VzZUlucHV0ID0gVG91Y2hNb3VzZUlucHV0O1xuXHRzdGF0aWMgU2luZ2xlVG91Y2hJbnB1dCA9IFNpbmdsZVRvdWNoSW5wdXQ7XG5cdHN0YXRpYyBSZWNvZ25pemVyID0gUmVjb2duaXplcjtcblx0c3RhdGljIEF0dHJSZWNvZ25pemVyID0gQXR0clJlY29nbml6ZXI7XG5cdHN0YXRpYyBUYXAgPSBUYXBSZWNvZ25pemVyO1xuXHRzdGF0aWMgUGFuID0gUGFuUmVjb2duaXplcjtcblx0c3RhdGljIFN3aXBlID0gU3dpcGVSZWNvZ25pemVyO1xuXHRzdGF0aWMgUGluY2ggPSBQaW5jaFJlY29nbml6ZXI7XG5cdHN0YXRpYyBSb3RhdGUgPSBSb3RhdGVSZWNvZ25pemVyO1xuXHRzdGF0aWMgUHJlc3MgPSBQcmVzc1JlY29nbml6ZXI7XG5cdHN0YXRpYyBvbiA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuXHRzdGF0aWMgb2ZmID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG5cdHN0YXRpYyBlYWNoID0gZWFjaDtcblx0c3RhdGljIG1lcmdlID0gbWVyZ2U7XG5cdHN0YXRpYyBleHRlbmQgPSBleHRlbmQ7XG5cdHN0YXRpYyBiaW5kRm4gPSBiaW5kRm47XG5cdHN0YXRpYyBhc3NpZ24gPSBhc3NpZ247XG5cdHN0YXRpYyBpbmhlcml0ID0gaW5oZXJpdDtcblx0c3RhdGljIGJpbmRGbiA9IGJpbmRGbjtcblx0c3RhdGljIHByZWZpeGVkID0gcHJlZml4ZWQ7XG5cdHN0YXRpYyB0b0FycmF5ID0gdG9BcnJheTtcblx0c3RhdGljIGluQXJyYXkgPSBpbkFycmF5O1xuXHRzdGF0aWMgdW5pcXVlQXJyYXkgPSB1bmlxdWVBcnJheTtcblx0c3RhdGljIHNwbGl0U3RyID0gc3BsaXRTdHI7XG5cdHN0YXRpYyBib29sT3JGbiA9IGJvb2xPckZuO1xuXHRzdGF0aWMgaGFzUGFyZW50ID0gaGFzUGFyZW50O1xuXHRzdGF0aWMgYWRkRXZlbnRMaXN0ZW5lcnMgPSBhZGRFdmVudExpc3RlbmVycztcblx0c3RhdGljIHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnM7XG5cdHN0YXRpYyBkZWZhdWx0cyA9IGFzc2lnbih7fSwgZGVmYXVsdHMsIHsgcHJlc2V0IH0pO1xuXHRjb25zdHJ1Y3RvcihlbGVtZW50LCBvcHRpb25zID0ge30pIHtcblx0XHRyZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwge1xuXHRcdFx0cmVjb2duaXplcnM6IFtcbiAgICAgICAgLy8gUmVjb2duaXplckNsYXNzLCBvcHRpb25zLCBbcmVjb2duaXplV2l0aCwgLi4uXSwgW3JlcXVpcmVGYWlsdXJlLCAuLi5dXG4gICAgICAgIC4uLnByZXNldFxuXHRcdFx0XSxcblx0XHRcdC4uLm9wdGlvbnMsXG5cdFx0fSk7XG5cdH1cbn1cbiIsIlxuaW1wb3J0IEhhbW1lciBmcm9tIFwiLi9oYW1tZXJcIjtcbmltcG9ydCBhc3NpZ24gZnJvbSBcIi4vdXRpbHMvYXNzaWduXCI7XG5cbmltcG9ydCB7XG4gIElOUFVUX1NUQVJULFxuICBJTlBVVF9NT1ZFLFxuICBJTlBVVF9FTkQsXG4gIElOUFVUX0NBTkNFTCxcbiAgRElSRUNUSU9OX05PTkUsXG4gIERJUkVDVElPTl9MRUZULFxuICBESVJFQ1RJT05fUklHSFQsXG4gIERJUkVDVElPTl9VUCxcbiAgRElSRUNUSU9OX0RPV04sXG4gIERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICBESVJFQ1RJT05fVkVSVElDQUwsXG4gIERJUkVDVElPTl9BTEwsXG59IGZyb20gXCIuL2lucHV0anMvaW5wdXQtY29uc3RzXCI7XG5pbXBvcnQge1xuICBTVEFURV9QT1NTSUJMRSxcbiAgU1RBVEVfQkVHQU4sXG4gIFNUQVRFX0NIQU5HRUQsXG4gIFNUQVRFX0VOREVELFxuICBTVEFURV9SRUNPR05JWkVELFxuICBTVEFURV9DQU5DRUxMRUQsXG4gIFNUQVRFX0ZBSUxFRCxcbn0gZnJvbSBcIi4vcmVjb2duaXplcmpzL3JlY29nbml6ZXItY29uc3RzXCI7XG5cbmltcG9ydCBNYW5hZ2VyIGZyb20gXCIuL21hbmFnZXJcIjtcbmltcG9ydCBJbnB1dCBmcm9tIFwiLi9pbnB1dGpzL2lucHV0LWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgVG91Y2hBY3Rpb24gZnJvbSBcIi4vdG91Y2hhY3Rpb25qcy90b3VjaGFjdGlvbi1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IFRvdWNoSW5wdXQgZnJvbSBcIi4vaW5wdXQvdG91Y2hcIjtcbmltcG9ydCBNb3VzZUlucHV0IGZyb20gXCIuL2lucHV0L21vdXNlXCI7XG5pbXBvcnQgUG9pbnRlckV2ZW50SW5wdXQgZnJvbSBcIi4vaW5wdXQvcG9pbnRlcmV2ZW50XCI7XG5pbXBvcnQgU2luZ2xlVG91Y2hJbnB1dCBmcm9tIFwiLi9pbnB1dC9zaW5nbGV0b3VjaFwiO1xuaW1wb3J0IFRvdWNoTW91c2VJbnB1dCBmcm9tIFwiLi9pbnB1dC90b3VjaG1vdXNlXCI7XG5cbmltcG9ydCBSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJqcy9yZWNvZ25pemVyLWNvbnN0cnVjdG9yXCI7XG5pbXBvcnQgQXR0clJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvYXR0cmlidXRlXCI7XG5pbXBvcnQgVGFwUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy90YXBcIjtcbmltcG9ydCBQYW5SZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3BhblwiO1xuaW1wb3J0IFN3aXBlUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9zd2lwZVwiO1xuaW1wb3J0IFBpbmNoUmVjb2duaXplciBmcm9tIFwiLi9yZWNvZ25pemVycy9waW5jaFwiO1xuaW1wb3J0IFJvdGF0ZVJlY29nbml6ZXIgZnJvbSBcIi4vcmVjb2duaXplcnMvcm90YXRlXCI7XG5pbXBvcnQgUHJlc3NSZWNvZ25pemVyIGZyb20gXCIuL3JlY29nbml6ZXJzL3ByZXNzXCI7XG5cbmltcG9ydCBhZGRFdmVudExpc3RlbmVycyBmcm9tIFwiLi91dGlscy9hZGQtZXZlbnQtbGlzdGVuZXJzXCI7XG5pbXBvcnQgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vdXRpbHMvcmVtb3ZlLWV2ZW50LWxpc3RlbmVyc1wiO1xuaW1wb3J0IGVhY2ggZnJvbSBcIi4vdXRpbHMvZWFjaFwiO1xuaW1wb3J0IG1lcmdlIGZyb20gXCIuL3V0aWxzL21lcmdlXCI7XG5pbXBvcnQgZXh0ZW5kIGZyb20gXCIuL3V0aWxzL2V4dGVuZFwiO1xuaW1wb3J0IGluaGVyaXQgZnJvbSBcIi4vdXRpbHMvaW5oZXJpdFwiO1xuaW1wb3J0IGJpbmRGbiBmcm9tIFwiLi91dGlscy9iaW5kLWZuXCI7XG5pbXBvcnQgcHJlZml4ZWQgZnJvbSBcIi4vdXRpbHMvcHJlZml4ZWRcIjtcbmltcG9ydCB0b0FycmF5IGZyb20gXCIuL3V0aWxzL3RvLWFycmF5XCI7XG5pbXBvcnQgdW5pcXVlQXJyYXkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlLWFycmF5XCI7XG5pbXBvcnQgc3BsaXRTdHIgZnJvbSBcIi4vdXRpbHMvc3BsaXQtc3RyXCI7XG5pbXBvcnQgaW5BcnJheSBmcm9tIFwiLi91dGlscy9pbi1hcnJheVwiO1xuaW1wb3J0IGJvb2xPckZuIGZyb20gXCIuL3V0aWxzL2Jvb2wtb3ItZm5cIjtcbmltcG9ydCBoYXNQYXJlbnQgZnJvbSBcIi4vdXRpbHMvaGFzLXBhcmVudFwiO1xuXG4vLyB0aGlzIHByZXZlbnRzIGVycm9ycyB3aGVuIEhhbW1lciBpcyBsb2FkZWQgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRFxuLy8gIHN0eWxlIGxvYWRlciBidXQgYnkgc2NyaXB0IHRhZywgbm90IGJ5IHRoZSBsb2FkZXIuXG5cbmNvbnN0IGRlZmF1bHRzID0gSGFtbWVyLmRlZmF1bHRzO1xuXG5leHBvcnQge1xuICBIYW1tZXIgYXMgZGVmYXVsdCxcbiAgSU5QVVRfU1RBUlQsXG4gIElOUFVUX01PVkUsXG4gIElOUFVUX0VORCxcbiAgSU5QVVRfQ0FOQ0VMLFxuICBTVEFURV9QT1NTSUJMRSxcbiAgU1RBVEVfQkVHQU4sXG4gIFNUQVRFX0NIQU5HRUQsXG4gIFNUQVRFX0VOREVELFxuICBTVEFURV9SRUNPR05JWkVELFxuICBTVEFURV9DQU5DRUxMRUQsXG4gIFNUQVRFX0ZBSUxFRCxcblxuICBESVJFQ1RJT05fTk9ORSxcbiAgRElSRUNUSU9OX0xFRlQsXG4gIERJUkVDVElPTl9SSUdIVCxcbiAgRElSRUNUSU9OX1VQLFxuICBESVJFQ1RJT05fRE9XTixcbiAgRElSRUNUSU9OX0hPUklaT05UQUwsXG4gIERJUkVDVElPTl9WRVJUSUNBTCxcbiAgRElSRUNUSU9OX0FMTCxcbiAgTWFuYWdlcixcbiAgSW5wdXQsXG4gIFRvdWNoQWN0aW9uLFxuICBUb3VjaElucHV0LFxuICBNb3VzZUlucHV0LFxuICBQb2ludGVyRXZlbnRJbnB1dCxcbiAgVG91Y2hNb3VzZUlucHV0LFxuICBTaW5nbGVUb3VjaElucHV0LFxuICBSZWNvZ25pemVyLFxuICBBdHRyUmVjb2duaXplcixcbiAgVGFwUmVjb2duaXplciBhcyBUYXAsXG4gIFBhblJlY29nbml6ZXIgYXMgUGFuLFxuICBTd2lwZVJlY29nbml6ZXIgYXMgU3dpcGUsXG4gIFBpbmNoUmVjb2duaXplciBhcyBQaW5jaCxcbiAgUm90YXRlUmVjb2duaXplciBhcyBSb3RhdGUsXG4gIFByZXNzUmVjb2duaXplciBhcyBQcmVzcyxcbiAgYWRkRXZlbnRMaXN0ZW5lcnMgYXMgb24sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzIGFzIG9mZixcbiAgZWFjaCxcbiAgbWVyZ2UsXG4gIGV4dGVuZCxcbiAgYXNzaWduLFxuICBpbmhlcml0LFxuICBiaW5kRm4sXG4gIHByZWZpeGVkLFxuICB0b0FycmF5LFxuICBpbkFycmF5LFxuICB1bmlxdWVBcnJheSxcbiAgc3BsaXRTdHIsXG4gIGJvb2xPckZuLFxuICBoYXNQYXJlbnQsXG4gIGFkZEV2ZW50TGlzdGVuZXJzLFxuICByZW1vdmVFdmVudExpc3RlbmVycyxcbiAgZGVmYXVsdHMsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@egjs/hammerjs/dist/hammer.esm.js\n");

/***/ })

}]);