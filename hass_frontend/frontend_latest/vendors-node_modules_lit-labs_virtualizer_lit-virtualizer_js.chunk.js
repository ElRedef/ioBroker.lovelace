"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkhome_assistant_frontend"] = self["webpackChunkhome_assistant_frontend"] || []).push([["vendors-node_modules_lit-labs_virtualizer_lit-virtualizer_js"],{

/***/ "./node_modules/@lit-labs/virtualizer/node_modules/tslib/tslib.es6.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/node_modules/tslib/tslib.es6.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__values\": () => (/* binding */ __values),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault)\n/* harmony export */ });\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nfunction __exportStar(m, exports) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nfunction __values(o) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator],\n      i = 0;\n  if (m) return m.call(o);\n  return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n;\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []),\n      i,\n      q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n) {\n    if (g[n]) i[n] = function (v) {\n      return new Promise(function (a, b) {\n        q.push([n, v, a, b]) > 1 || resume(n, v);\n      });\n    };\n  }\n\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) {\n    throw e;\n  }), verb(\"return\"), i[Symbol.iterator] = function () {\n    return this;\n  }, i;\n\n  function verb(n, f) {\n    i[n] = o[n] ? function (v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === \"return\"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, \"raw\", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n\n  return cooked;\n}\n;\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result.default = mod;\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    default: mod\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTs7QUFBQTs7QUFBQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTs7QUFBQTs7QUFBQTtBQUFBOztBQUNBOztBQUNBOztBQUFBO0FBWEE7O0FBYUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7O0FBQ0E7O0FBR0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/Y2M0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXG5cblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gICAgcmV0dXJuIGFyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICAgIHZhciBpLCBwO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/Virtualizer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/Virtualizer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"virtualizerRef\": () => (/* binding */ virtualizerRef),\n/* harmony export */   \"RangeChangedEvent\": () => (/* binding */ RangeChangedEvent),\n/* harmony export */   \"VisibilityChangedEvent\": () => (/* binding */ VisibilityChangedEvent),\n/* harmony export */   \"Virtualizer\": () => (/* binding */ Virtualizer)\n/* harmony export */ });\n/* harmony import */ var _polyfillLoaders_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfillLoaders/ResizeObserver.js */ \"./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nconst virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nclass RangeChangedEvent extends Event {\n  constructor(range) {\n    super(RangeChangedEvent.eventName, {\n      bubbles: true\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n\n}\nRangeChangedEvent.eventName = 'rangeChanged';\nclass VisibilityChangedEvent extends Event {\n  constructor(range) {\n    super(VisibilityChangedEvent.eventName, {\n      bubbles: true\n    });\n    this.first = range.first;\n    this.last = range.last;\n  }\n\n}\nVisibilityChangedEvent.eventName = 'visibilityChanged';\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement, layout, and scrollTarget.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\n\nclass Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    /**\n     * Whether the layout should receive an updated viewport size on the next\n     * render.\n     */\n    // private _needsUpdateView: boolean = false;\n\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n\n    this._childrenPos = null; // TODO: (graynorton): type\n\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._mutationPromise = null;\n    this._mutationPromiseResolver = null;\n    this._mutationsObserved = false;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    }; // TODO (graynorton): Rethink, per longer comment below\n\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index and position of item to scroll to.\n     */\n\n    this._scrollToIndex = null;\n    /**\n     * Items to render. Set by items.\n     */\n\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n\n      this._schedule(this._updateLayout);\n    }\n  }\n\n  _init(config) {\n    this._isScroller = !!config.scroller;\n\n    this._initHostElement(config);\n\n    this._initLayout(config);\n  }\n\n  async _initObservers() {\n    this._mutationObserver = new MutationObserver(this._observeMutations.bind(this));\n    const ResizeObserver = await (0,_polyfillLoaders_ResizeObserver_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    this._hostElementRO = new ResizeObserver(() => this._hostElementSizeChanged());\n    this._childrenRO = new ResizeObserver(this._childrenSizeChanged.bind(this));\n  }\n\n  async _initLayout(config) {\n    if (config.layout) {\n      this.layout = config.layout;\n    } else {\n      this.layout = (await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_shared_BaseLayout_js\"), __webpack_require__.e(\"vendors-node_modules_lit-labs_virtualizer_layouts_flow_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./layouts/flow.js */ \"./node_modules/@lit-labs/virtualizer/layouts/flow.js\"))).FlowLayout;\n    }\n  }\n\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n\n    this._applyVirtualizerStyles();\n\n    hostElement[virtualizerRef] = this;\n  }\n\n  async connected() {\n    await this._initObservers();\n    const includeSelf = this._isScroller;\n    this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n\n    this._schedule(this._updateLayout);\n\n    this._observeAndListen();\n  }\n\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n\n    this._mutationPromise = new Promise(resolve => this._mutationPromiseResolver = resolve);\n\n    this._hostElementRO.observe(this._hostElement);\n\n    this._scrollEventListeners.push(window);\n\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n\n      this._scrollEventListeners.push(ancestor);\n\n      this._hostElementRO.observe(ancestor);\n    });\n\n    this._children.forEach(child => this._childrenRO.observe(child));\n\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n\n  disconnected() {\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n\n    this._mutationObserver.disconnect();\n\n    this._hostElementRO.disconnect();\n\n    this._childrenRO.disconnect();\n  }\n\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement; // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'strict';\n\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n\n  _getSizer() {\n    const hostElement = this._hostElement;\n\n    if (!this._sizer) {\n      // Use a pre-existing sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      } // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n\n\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.innerHTML = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n\n    return this._sizer;\n  } // This will always actually return a layout instance,\n  // but TypeScript wants the getter and setter types to be the same\n\n\n  get layout() {\n    return this._layout;\n  } // TODO (graynorton): Consider not allowing dynamic layout changes and\n  // instead just creating a new Virtualizer instance when a layout\n  // change is desired. Might simplify quite a bit.\n\n\n  set layout(layout) {\n    if (this._layout === layout) {\n      return;\n    }\n\n    let _layout = null;\n    let _config = {};\n\n    if (typeof layout === 'object') {\n      if (layout.type !== undefined) {\n        _layout = layout.type; // delete (layout as LayoutSpecifier).type;\n      }\n\n      _config = layout;\n    } else {\n      _layout = layout;\n    }\n\n    if (typeof _layout === 'function') {\n      if (this._layout instanceof _layout) {\n        if (_config) {\n          this._layout.config = _config;\n        }\n\n        return;\n      } else {\n        _layout = new _layout(_config);\n      }\n    }\n\n    if (this._layout) {\n      this._measureCallback = null;\n      this._measureChildOverride = null;\n\n      this._layout.removeEventListener('scrollsizechange', this);\n\n      this._layout.removeEventListener('scrollerrorchange', this);\n\n      this._layout.removeEventListener('itempositionchange', this);\n\n      this._layout.removeEventListener('rangechange', this);\n\n      this._sizeHostElement(undefined);\n\n      this._hostElement.removeEventListener('load', this._loadListener, true);\n    }\n\n    this._layout = _layout;\n\n    if (this._layout) {\n      if (this._layout.measureChildren && typeof this._layout.updateItemSizes === 'function') {\n        if (typeof this._layout.measureChildren === 'function') {\n          this._measureChildOverride = this._layout.measureChildren;\n        }\n\n        this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n      }\n\n      this._layout.addEventListener('scrollsizechange', this);\n\n      this._layout.addEventListener('scrollerrorchange', this);\n\n      this._layout.addEventListener('itempositionchange', this);\n\n      this._layout.addEventListener('rangechange', this);\n\n      if (this._layout.listenForChildLoadEvents) {\n        this._hostElement.addEventListener('load', this._loadListener, true);\n      }\n\n      this._schedule(this._updateLayout);\n    }\n  } // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n\n\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n\n    return null;\n  }\n\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]\n        /*as unknown as object*/\n        );\n      }\n    }\n\n    this._childMeasurements = mm;\n\n    this._schedule(this._updateLayout);\n\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n\n\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  /**\n   * Index and position of item to scroll to. The virtualizer will fix to that point\n   * until the user scrolls.\n   */\n\n\n  set scrollToIndex(newValue) {\n    this._scrollToIndex = newValue;\n\n    this._schedule(this._updateLayout);\n  }\n\n  async _schedule(method) {\n    if (!this._scheduled.has(method)) {\n      this._scheduled.add(method);\n\n      await Promise.resolve();\n\n      this._scheduled.delete(method);\n\n      method.call(this);\n    }\n  }\n\n  async _updateDOM() {\n    const {\n      _rangeChanged,\n      _itemsChanged\n    } = this;\n\n    if (this._visibilityChanged) {\n      this._notifyVisibility();\n\n      this._visibilityChanged = false;\n    }\n\n    if (_rangeChanged || _itemsChanged) {\n      this._notifyRange();\n\n      await this._mutationPromise;\n    }\n\n    this._children.forEach(child => this._childrenRO.observe(child));\n\n    this._positionChildren(this._childrenPos);\n\n    this._sizeHostElement(this._scrollSize);\n\n    if (this._scrollError) {\n      this._correctScrollError(this._scrollError);\n\n      this._scrollError = null;\n    }\n\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n\n  _updateLayout() {\n    if (this._layout) {\n      this._layout.totalItems = this._items.length;\n\n      if (this._scrollToIndex !== null) {\n        this._layout.scrollToIndex(this._scrollToIndex.index, this._scrollToIndex.position);\n\n        this._scrollToIndex = null;\n      }\n\n      this._updateView();\n\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n\n        this._childMeasurements = null;\n      }\n\n      this._layout.reflowIfNeeded(this._itemsChanged);\n\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n\n  _handleScrollEvent() {\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n\n      window.performance.mark('uv-start');\n    }\n\n    this._schedule(this._updateLayout);\n  }\n\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n\n        break;\n\n      case 'scrollsizechange':\n        this._scrollSize = event.detail;\n\n        this._schedule(this._updateDOM);\n\n        break;\n\n      case 'scrollerrorchange':\n        this._scrollError = event.detail;\n\n        this._schedule(this._updateDOM);\n\n        break;\n\n      case 'itempositionchange':\n        this._childrenPos = event.detail;\n\n        this._schedule(this._updateDOM);\n\n        break;\n\n      case 'rangechange':\n        this._adjustRange(event.detail);\n\n        this._schedule(this._updateDOM);\n\n        break;\n\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n\n      next = next.nextElementSibling;\n    }\n\n    return arr;\n  }\n\n  _updateView() {\n    const hostElement = this._hostElement;\n    const layout = this._layout;\n    let top, left, bottom, right, scrollTop, scrollLeft;\n    const hostElementBounds = hostElement.getBoundingClientRect();\n    top = 0;\n    left = 0;\n    bottom = window.innerHeight;\n    right = window.innerWidth;\n\n    for (let ancestor of this._clippingAncestors) {\n      const ancestorBounds = ancestor.getBoundingClientRect();\n      top = Math.max(top, ancestorBounds.top);\n      left = Math.max(left, ancestorBounds.left);\n      bottom = Math.min(bottom, ancestorBounds.bottom);\n      right = Math.min(right, ancestorBounds.right);\n    }\n\n    scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n    scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n    const height = Math.max(1, bottom - top);\n    const width = Math.max(1, right - left);\n    layout.viewportSize = {\n      width,\n      height\n    };\n    layout.viewportScroll = {\n      top: scrollTop,\n      left: scrollLeft\n    };\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n\n\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width ? Math.min(max, size.width) : 0;\n    const v = size && size.height ? Math.min(max, size.height) : 0;\n\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n\n\n  _positionChildren(pos) {\n    if (pos) {\n      const children = this._children;\n      Object.keys(pos).forEach(key => {\n        const idx = key - this._first;\n        const child = children[idx];\n\n        if (child) {\n          const {\n            top,\n            left,\n            width,\n            height,\n            xOffset,\n            yOffset\n          } = pos[key];\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n\n  async _adjustRange(range) {\n    const {\n      _first,\n      _last,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._first = range.first;\n    this._last = range.last;\n    this._firstVisible = range.firstVisible;\n    this._lastVisible = range.lastVisible;\n    this._rangeChanged = this._rangeChanged || this._first !== _first || this._last !== _last;\n    this._visibilityChanged = this._visibilityChanged || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible;\n  }\n\n  _correctScrollError(err) {\n    const target = this._clippingAncestors[0];\n\n    if (target) {\n      target.scrollTop -= err.top;\n      target.scrollLeft -= err.left;\n    } else {\n      window.scroll(window.pageXOffset - err.left, window.pageYOffset - err.top);\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n\n\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n\n\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n\n  async _observeMutations() {\n    if (!this._mutationsObserved) {\n      this._mutationsObserved = true;\n\n      this._mutationPromiseResolver();\n\n      this._mutationPromise = new Promise(resolve => this._mutationPromiseResolver = resolve);\n      this._mutationsObserved = false;\n    }\n  } // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n\n\n  _childLoaded() {// this.requestRemeasure();\n  } // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n\n\n  _childrenSizeChanged(changes) {\n    // Only measure if the layout requires it\n    if (this._layout.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n\n      this._measureChildren();\n    } // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n\n\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n\n}\n\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\n\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n} // TODO (graynorton): Deal with iframes?\n\n\nfunction getParentElement(el) {\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n\n  const parentNode = el.parentNode;\n\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n\n  return null;\n}\n\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n\n  return ancestors;\n}\n\nfunction getClippingAncestors(el, includeSelf = false) {\n  return getElementAncestors(el, includeSelf).filter(a => getComputedStyle(a).overflow !== 'visible');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL1ZpcnR1YWxpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQUVBO0FBR0E7QUFDQTtBQWlCQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBQ0E7QUFZQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQVZBO0FBQ0E7QUEwQ0E7Ozs7Ozs7QUFPQTs7QUFDQTtBQWlIQTtBQWhIQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBRUE7QUFFQTs7O0FBR0E7O0FBQ0E7QUFFQTs7O0FBR0E7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTs7QUFHQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBT0E7QUFFQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBOztBQUlBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBOzs7QUFHQTs7QUFDQTtBQUVBOztBQUVBOztBQUNBO0FBRUE7O0FBRUE7O0FBQ0E7QUFFQTs7QUFFQTs7QUFDQTtBQUVBO0FBRUE7Ozs7QUFJQTs7QUFDQTtBQUVBOztBQUdBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFFQTs7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUF2QkE7QUF5QkE7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7O0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTs7QUFFQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFFQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7O0FBbm9CQTs7QUFzb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZS1hc3Npc3RhbnQtZnJvbnRlbmQvc3JjL1ZpcnR1YWxpemVyLnRzPzc1NTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEJTRC0zLUNsYXVzZVxuICovXG5cbmltcG9ydCBnZXRSZXNpemVPYnNlcnZlciBmcm9tICcuL3BvbHlmaWxsTG9hZGVycy9SZXNpemVPYnNlcnZlci5qcyc7XG5pbXBvcnQgeyBJdGVtQm94LCBNYXJnaW5zLCBMYXlvdXQsIFBvc2l0aW9ucywgTGF5b3V0Q29uc3RydWN0b3IsIExheW91dFNwZWNpZmllciB9IGZyb20gJy4vbGF5b3V0cy9zaGFyZWQvTGF5b3V0LmpzJztcblxuZXhwb3J0IGNvbnN0IHZpcnR1YWxpemVyUmVmID0gU3ltYm9sKCd2aXJ0dWFsaXplclJlZicpO1xuY29uc3QgU0laRVJfQVRUUklCVVRFID0gJ3ZpcnR1YWxpemVyLXNpemVyJztcblxuaW50ZXJmYWNlIEludGVybmFsUmFuZ2Uge1xuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG4gIG51bTogbnVtYmVyO1xuICByZW1lYXN1cmU6IGJvb2xlYW47XG4gIHN0YWJsZTogYm9vbGVhbjtcbiAgZmlyc3RWaXNpYmxlOiBudW1iZXI7XG4gIGxhc3RWaXNpYmxlOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBSYW5nZSB7XG4gIGZpcnN0OiBudW1iZXIsXG4gIGxhc3Q6IG51bWJlclxufVxuXG5leHBvcnQgY2xhc3MgUmFuZ2VDaGFuZ2VkRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIHN0YXRpYyBldmVudE5hbWUgPSAncmFuZ2VDaGFuZ2VkJztcblxuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocmFuZ2U6IFJhbmdlKSB7XG4gICAgc3VwZXIoUmFuZ2VDaGFuZ2VkRXZlbnQuZXZlbnROYW1lLCB7YnViYmxlczogdHJ1ZX0pO1xuICAgIHRoaXMuZmlyc3QgPSByYW5nZS5maXJzdDtcbiAgICB0aGlzLmxhc3QgPSByYW5nZS5sYXN0O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICBzdGF0aWMgZXZlbnROYW1lID0gJ3Zpc2liaWxpdHlDaGFuZ2VkJztcblxuICBmaXJzdDogbnVtYmVyO1xuICBsYXN0OiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocmFuZ2U6IFJhbmdlKSB7XG4gICAgc3VwZXIoVmlzaWJpbGl0eUNoYW5nZWRFdmVudC5ldmVudE5hbWUsIHtidWJibGVzOiB0cnVlfSk7XG4gICAgdGhpcy5maXJzdCA9IHJhbmdlLmZpcnN0O1xuICAgIHRoaXMubGFzdCA9IHJhbmdlLmxhc3Q7XG4gIH1cbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRFdmVudE1hcCB7XG4gICAgJ3JhbmdlQ2hhbmdlZCc6IFJhbmdlQ2hhbmdlZEV2ZW50O1xuICAgICd2aXNpYmlsaXR5Q2hhbmdlZCc6IFZpc2liaWxpdHlDaGFuZ2VkRXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaXJ0dWFsaXplckhvc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBbdmlydHVhbGl6ZXJSZWZdPzogVmlydHVhbGl6ZXJcbn1cblxudHlwZSBWZXJ0aWNhbFNjcm9sbFNpemUgPSB7aGVpZ2h0OiBudW1iZXJ9O1xudHlwZSBIb3Jpem9udGFsU2Nyb2xsU2l6ZSA9IHt3aWR0aDogbnVtYmVyfTtcbnR5cGUgU2Nyb2xsU2l6ZSA9IFZlcnRpY2FsU2Nyb2xsU2l6ZSB8IEhvcml6b250YWxTY3JvbGxTaXplO1xuXG50eXBlIENoaWxkTWVhc3VyZW1lbnRzID0ge1trZXk6IG51bWJlcl06IEl0ZW1Cb3h9O1xuXG5leHBvcnQgdHlwZSBTY3JvbGxUb0luZGV4VmFsdWUgPSB7aW5kZXg6IG51bWJlciwgcG9zaXRpb24/OiBzdHJpbmd9IHwgbnVsbDtcblxuZXhwb3J0IGludGVyZmFjZSBWaXJ0dWFsaXplckNvbmZpZyB7XG4gIGxheW91dD86IExheW91dCB8IExheW91dENvbnN0cnVjdG9yIHwgTGF5b3V0U3BlY2lmaWVyIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHBhcmVudCBvZiBhbGwgY2hpbGQgbm9kZXMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBob3N0RWxlbWVudDogVmlydHVhbGl6ZXJIb3N0RWxlbWVudDtcblxuICBzY3JvbGxlcj86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBQcm92aWRlcyB2aXJ0dWFsIHNjcm9sbGluZyBib2lsZXJwbGF0ZS5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBzZXQgaG9zdEVsZW1lbnQsIGxheW91dCwgYW5kIHNjcm9sbFRhcmdldC5cbiAqXG4gKiBFeHRlbnNpb25zIG9mIHRoaXMgY2xhc3MgbXVzdCBhbHNvIG92ZXJyaWRlIFZpcnR1YWxSZXBlYXRlcidzIERPTVxuICogbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBWaXJ0dWFsaXplciB7XG4gIHByaXZhdGUgX2JlbmNobWFya1N0YXJ0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgcmVjZWl2ZSBhbiB1cGRhdGVkIHZpZXdwb3J0IHNpemUgb24gdGhlIG5leHRcbiAgICogcmVuZGVyLlxuICAgKi9cbiAgLy8gcHJpdmF0ZSBfbmVlZHNVcGRhdGVWaWV3OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfbGF5b3V0OiBMYXlvdXQgfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIF9jbGlwcGluZ0FuY2VzdG9yczogRWxlbWVudFtdID0gW107XG5cbiAgLyoqXG4gICAqIExheW91dCBwcm92aWRlcyB0aGVzZSB2YWx1ZXMsIHdlIHNldCB0aGVtIG9uIF9yZW5kZXIoKS5cbiAgICogVE9ETyBAc3RyYXZlcnNpOiBDYW4gd2UgZmluZCBhbiBYT1IgdHlwZSwgdXNhYmxlIGZvciB0aGUga2V5IGhlcmU/XG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxTaXplOiBTY3JvbGxTaXplIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIERpZmZlcmVuY2UgYmV0d2VlbiBzY3JvbGwgdGFyZ2V0J3MgY3VycmVudCBhbmQgcmVxdWlyZWQgc2Nyb2xsIG9mZnNldHMuXG4gICAqIFByb3ZpZGVkIGJ5IGxheW91dC5cbiAgICovXG4gIHByaXZhdGUgX3Njcm9sbEVycm9yOiB7bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcn0gfCBudWxsID0gbnVsbDtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIHRoZSBwb3NpdGlvbnMgKHRvcCwgbGVmdCkgb2YgdGhlIGNoaWxkcmVuIGluIHRoZSBjdXJyZW50IHJhbmdlLlxuICAgKi9cbiAgcHJpdmF0ZSBfY2hpbGRyZW5Qb3M6IEFycmF5PHt0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfT4gfCBudWxsID0gbnVsbDtcblxuICAvLyBUT0RPOiAoZ3JheW5vcnRvbik6IHR5cGVcbiAgcHJpdmF0ZSBfY2hpbGRNZWFzdXJlbWVudHM6IENoaWxkTWVhc3VyZW1lbnRzIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfdG9CZU1lYXN1cmVkOiBNYXA8SFRNTEVsZW1lbnQsIHVua25vd24+ID0gbmV3IE1hcCgpO1xuXG4gIHByaXZhdGUgX3JhbmdlQ2hhbmdlZCA9IHRydWU7XG5cbiAgcHJpdmF0ZSBfaXRlbXNDaGFuZ2VkID0gdHJ1ZTtcblxuICBwcml2YXRlIF92aXNpYmlsaXR5Q2hhbmdlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFRoZSBIVE1MRWxlbWVudCB0aGF0IGhvc3RzIHRoZSB2aXJ0dWFsaXplci4gU2V0IGJ5IGhvc3RFbGVtZW50LlxuICAgKi9cbiAgcHJvdGVjdGVkIF9ob3N0RWxlbWVudD86IFZpcnR1YWxpemVySG9zdEVsZW1lbnQ7XG5cbiAgcHJpdmF0ZSBfaXNTY3JvbGxlciA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3NpemVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gaG9zdEVsZW1lbnQuXG4gICAqL1xuICBwcml2YXRlIF9ob3N0RWxlbWVudFJPOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBSZXNpemUgb2JzZXJ2ZXIgYXR0YWNoZWQgdG8gY2hpbGRyZW4uXG4gICAqL1xuICBwcml2YXRlIF9jaGlsZHJlblJPOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgX211dGF0aW9uT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfbXV0YXRpb25Qcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX211dGF0aW9uUHJvbWlzZVJlc29sdmVyOiBGdW5jdGlvbiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9tdXRhdGlvbnNPYnNlcnZlZCA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3Njcm9sbEV2ZW50TGlzdGVuZXJzOiAoRWxlbWVudCB8IFdpbmRvdylbXSA9IFtdO1xuICBwcml2YXRlIF9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9uczogQWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfTtcblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUmV0aGluaywgcGVyIGxvbmdlciBjb21tZW50IGJlbG93XG5cbiAgcHJpdmF0ZSBfbG9hZExpc3RlbmVyID0gdGhpcy5fY2hpbGRMb2FkZWQuYmluZCh0aGlzKTtcblxuICAvKipcbiAgICogSW5kZXggYW5kIHBvc2l0aW9uIG9mIGl0ZW0gdG8gc2Nyb2xsIHRvLlxuICAgKi9cbiAgcHJpdmF0ZSBfc2Nyb2xsVG9JbmRleDogU2Nyb2xsVG9JbmRleFZhbHVlID0gbnVsbDtcblxuICAvKipcbiAgICogSXRlbXMgdG8gcmVuZGVyLiBTZXQgYnkgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9pdGVtczogQXJyYXk8dW5rbm93bj4gPSBbXTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGNoaWxkIGluIHRoZSByYW5nZSwgbm90IG5lY2Vzc2FyaWx5IHRoZSBmaXJzdCB2aXNpYmxlIGNoaWxkLlxuICAgKiBUT0RPIEBzdHJhdmVyc2k6IENvbnNpZGVyIHJlbmFtaW5nIHRoZXNlLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9maXJzdCA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgcmFuZ2UuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2xhc3QgPSAtMTtcblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW50ZXJzZWN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIHByaXZhdGUgX2ZpcnN0VmlzaWJsZSA9IC0xO1xuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBpdGVtIGludGVyc2VjdGluZyB0aGUgdmlld3BvcnQuXG4gICAqL1xuICBwcml2YXRlIF9sYXN0VmlzaWJsZSA9IC0xO1xuXG4gIHByb3RlY3RlZCBfc2NoZWR1bGVkID0gbmV3IFdlYWtTZXQoKTtcblxuICAvKipcbiAgICogSW52b2tlZCBhdCB0aGUgZW5kIG9mIGVhY2ggcmVuZGVyIGN5Y2xlOiBjaGlsZHJlbiBpbiB0aGUgcmFuZ2UgYXJlXG4gICAqIG1lYXN1cmVkLCBhbmQgdGhlaXIgZGltZW5zaW9ucyBwYXNzZWQgdG8gdGhpcyBjYWxsYmFjay4gVXNlIGl0IHRvIGxheW91dFxuICAgKiBjaGlsZHJlbiBhcyBuZWVkZWQuXG4gICAqL1xuICAgcHJvdGVjdGVkIF9tZWFzdXJlQ2FsbGJhY2s6ICgoc2l6ZXM6IENoaWxkTWVhc3VyZW1lbnRzKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4gICBwcm90ZWN0ZWQgX21lYXN1cmVDaGlsZE92ZXJyaWRlOiAoKGVsZW1lbnQ6IEVsZW1lbnQsIGl0ZW06IHVua25vd24pID0+IEl0ZW1Cb3gpIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWxpemVyIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGEgY29uZmlndXJhdGlvbiBvYmplY3QnKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5ob3N0RWxlbWVudCkge1xuICAgICAgdGhpcy5faW5pdChjb25maWcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmlydHVhbGl6ZXIgY29uZmlndXJhdGlvbiByZXF1aXJlcyB0aGUgXCJob3N0RWxlbWVudFwiIHByb3BlcnR5Jyk7XG4gICAgfVxuICB9XG5cbiAgc2V0IGl0ZW1zKGl0ZW1zOiBBcnJheTx1bmtub3duPiB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSAmJiBpdGVtcyAhPT0gdGhpcy5faXRlbXMpIHtcbiAgICAgIHRoaXMuX2l0ZW1zQ2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICBfaW5pdChjb25maWc6IFZpcnR1YWxpemVyQ29uZmlnKSB7XG4gICAgdGhpcy5faXNTY3JvbGxlciAgPSAhIWNvbmZpZy5zY3JvbGxlcjtcbiAgICB0aGlzLl9pbml0SG9zdEVsZW1lbnQoY29uZmlnKTtcbiAgICB0aGlzLl9pbml0TGF5b3V0KGNvbmZpZyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9pbml0T2JzZXJ2ZXJzKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vYnNlcnZlTXV0YXRpb25zLmJpbmQodGhpcykpO1xuICAgIGNvbnN0IFJlc2l6ZU9ic2VydmVyID0gYXdhaXQgZ2V0UmVzaXplT2JzZXJ2ZXIoKTtcbiAgICB0aGlzLl9ob3N0RWxlbWVudFJPID0gbmV3IFJlc2l6ZU9ic2VydmVyKFxuICAgICAgKCkgPT4gdGhpcy5faG9zdEVsZW1lbnRTaXplQ2hhbmdlZCgpXG4gICAgKTtcbiAgICB0aGlzLl9jaGlsZHJlblJPID1cbiAgICAgIG5ldyBSZXNpemVPYnNlcnZlcih0aGlzLl9jaGlsZHJlblNpemVDaGFuZ2VkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgYXN5bmMgX2luaXRMYXlvdXQoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIGlmIChjb25maWcubGF5b3V0KSB7XG4gICAgICB0aGlzLmxheW91dCA9IGNvbmZpZy5sYXlvdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5sYXlvdXQgPSAoYXdhaXQgaW1wb3J0KCcuL2xheW91dHMvZmxvdy5qcycpKS5GbG93TGF5b3V0O1xuICAgIH1cbiAgfVxuXG4gIF9pbml0SG9zdEVsZW1lbnQoY29uZmlnOiBWaXJ0dWFsaXplckNvbmZpZykge1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gKHRoaXMuX2hvc3RFbGVtZW50ID0gY29uZmlnLmhvc3RFbGVtZW50KTtcbiAgICB0aGlzLl9hcHBseVZpcnR1YWxpemVyU3R5bGVzKCk7XG4gICAgaG9zdEVsZW1lbnRbdmlydHVhbGl6ZXJSZWZdID0gdGhpcztcbiAgfVxuXG4gIGFzeW5jIGNvbm5lY3RlZCgpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2luaXRPYnNlcnZlcnMoKTtcbiAgICAgIGNvbnN0IGluY2x1ZGVTZWxmID0gdGhpcy5faXNTY3JvbGxlcjtcbiAgICAgIHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzID0gZ2V0Q2xpcHBpbmdBbmNlc3RvcnModGhpcy5faG9zdEVsZW1lbnQhLCBpbmNsdWRlU2VsZik7XG4gICAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICAgICAgdGhpcy5fb2JzZXJ2ZUFuZExpc3RlbigpO1xuICB9XG5cbiAgX29ic2VydmVBbmRMaXN0ZW4oKSB7XG4gICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlciEub2JzZXJ2ZSh0aGlzLl9ob3N0RWxlbWVudCEsIHsgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgIHRoaXMuX211dGF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5fbXV0YXRpb25Qcm9taXNlUmVzb2x2ZXIgPSByZXNvbHZlKTtcbiAgICB0aGlzLl9ob3N0RWxlbWVudFJPIS5vYnNlcnZlKHRoaXMuX2hvc3RFbGVtZW50ISk7XG4gICAgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lcnMucHVzaCh3aW5kb3cpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9ucylcbiAgICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgdGhpcy5faG9zdEVsZW1lbnRSTyEub2JzZXJ2ZShhbmNlc3Rvcik7XG4gICAgfSk7XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2NoaWxkcmVuUk8hLm9ic2VydmUoY2hpbGQpKTtcbiAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5mb3JFYWNoKHRhcmdldCA9PiB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcywgdGhpcy5fc2Nyb2xsRXZlbnRMaXN0ZW5lck9wdGlvbnMpKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVycy5mb3JFYWNoKCh0YXJnZXQpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLCB0aGlzLl9zY3JvbGxFdmVudExpc3RlbmVyT3B0aW9ucykpO1xuICAgIHRoaXMuX3Njcm9sbEV2ZW50TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMgPSBbXTtcbiAgICB0aGlzLl9tdXRhdGlvbk9ic2VydmVyIS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5faG9zdEVsZW1lbnRSTyEuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuX2NoaWxkcmVuUk8hLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5VmlydHVhbGl6ZXJTdHlsZXMoKSB7XG4gICAgY29uc3QgaG9zdEVsZW1lbnQgPSB0aGlzLl9ob3N0RWxlbWVudCE7XG4gICAgLy8gV291bGQgcmF0aGVyIHNldCB0aGVzZSBDU1MgcHJvcGVydGllcyBvbiB0aGUgaG9zdCB1c2luZyBTaGFkb3cgUm9vdFxuICAgIC8vIHN0eWxlIHNjb3BpbmcgKGFuZCBmYWxsaW5nIGJhY2sgdG8gYSBnbG9iYWwgc3R5bGVzaGVldCB3aGVyZSBuYXRpdmVcbiAgICAvLyBTaGFkb3cgRE9NIGlzIG5vdCBhdmFpbGFibGUpLCBidXQgdGhpcyBNb2JpbGUgU2FmYXJpIGJ1ZyBpcyBwcmV2ZW50aW5nXG4gICAgLy8gdGhhdCBmcm9tIHdvcmtpbmc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjYxOTVcbiAgICBjb25zdCBzdHlsZSA9IGhvc3RFbGVtZW50LnN0eWxlIGFzIENTU1N0eWxlRGVjbGFyYXRpb24gJiB7IGNvbnRhaW46IHN0cmluZyB9O1xuICAgIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gICAgc3R5bGUucG9zaXRpb24gPSBzdHlsZS5wb3NpdGlvbiB8fCAncmVsYXRpdmUnO1xuICAgIHN0eWxlLmNvbnRhaW4gPSBzdHlsZS5jb250YWluIHx8ICdzdHJpY3QnO1xuXG4gICAgaWYgKHRoaXMuX2lzU2Nyb2xsZXIpIHtcbiAgICAgIHN0eWxlLm92ZXJmbG93ID0gc3R5bGUub3ZlcmZsb3cgfHwgJ2F1dG8nO1xuICAgICAgc3R5bGUubWluSGVpZ2h0ID0gc3R5bGUubWluSGVpZ2h0IHx8ICcxNTBweCc7XG4gICAgfVxuICB9XG5cbiAgX2dldFNpemVyKCkge1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5faG9zdEVsZW1lbnQhO1xuICAgIGlmICghdGhpcy5fc2l6ZXIpIHtcbiAgICAgIC8vIFVzZSBhIHByZS1leGlzdGluZyBzaXplciBlbGVtZW50IGlmIHByb3ZpZGVkIChmb3IgYmV0dGVyIGludGVncmF0aW9uXG4gICAgICAvLyB3aXRoIHZET00gcmVuZGVyZXJzKVxuICAgICAgbGV0IHNpemVyID0gaG9zdEVsZW1lbnQucXVlcnlTZWxlY3RvcihgWyR7U0laRVJfQVRUUklCVVRFfV1gKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmICghc2l6ZXIpIHtcbiAgICAgICAgc2l6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2l6ZXIuc2V0QXR0cmlidXRlKFNJWkVSX0FUVFJJQlVURSwgJycpO1xuICAgICAgICBob3N0RWxlbWVudC5hcHBlbmRDaGlsZChzaXplcik7XG4gICAgICB9XG4gICAgICAvLyBXaGVuIHRoZSBzY3JvbGxIZWlnaHQgaXMgbGFyZ2UsIHRoZSBoZWlnaHQgb2YgdGhpcyBlbGVtZW50IG1pZ2h0IGJlXG4gICAgICAvLyBpZ25vcmVkLiBTZXR0aW5nIGNvbnRlbnQgYW5kIGZvbnQtc2l6ZSBlbnN1cmVzIHRoZSBlbGVtZW50IGhhcyBhIHNpemUuXG4gICAgICBPYmplY3QuYXNzaWduKHNpemVyLnN0eWxlLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBtYXJnaW46ICctMnB4IDAgMCAwJyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgIGZvbnRTaXplOiAnMnB4JyxcbiAgICAgIH0pO1xuICAgICAgc2l6ZXIuaW5uZXJIVE1MID0gJyZuYnNwOyc7XG4gICAgICBzaXplci5zZXRBdHRyaWJ1dGUoU0laRVJfQVRUUklCVVRFLCAnJyk7XG4gICAgICB0aGlzLl9zaXplciA9IHNpemVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2l6ZXI7XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgYWx3YXlzIGFjdHVhbGx5IHJldHVybiBhIGxheW91dCBpbnN0YW5jZSxcbiAgLy8gYnV0IFR5cGVTY3JpcHQgd2FudHMgdGhlIGdldHRlciBhbmQgc2V0dGVyIHR5cGVzIHRvIGJlIHRoZSBzYW1lXG4gIGdldCBsYXlvdXQoKTogTGF5b3V0IHwgTGF5b3V0Q29uc3RydWN0b3IgfCBMYXlvdXRTcGVjaWZpZXIgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fbGF5b3V0O1xuICB9XG5cbiAgLy8gVE9ETyAoZ3JheW5vcnRvbik6IENvbnNpZGVyIG5vdCBhbGxvd2luZyBkeW5hbWljIGxheW91dCBjaGFuZ2VzIGFuZFxuICAvLyBpbnN0ZWFkIGp1c3QgY3JlYXRpbmcgYSBuZXcgVmlydHVhbGl6ZXIgaW5zdGFuY2Ugd2hlbiBhIGxheW91dFxuICAvLyBjaGFuZ2UgaXMgZGVzaXJlZC4gTWlnaHQgc2ltcGxpZnkgcXVpdGUgYSBiaXQuXG4gIHNldCBsYXlvdXQobGF5b3V0OiBMYXlvdXQgfCBMYXlvdXRDb25zdHJ1Y3RvciB8IExheW91dFNwZWNpZmllciB8IG51bGwpIHtcbiAgICBpZiAodGhpcy5fbGF5b3V0ID09PSBsYXlvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgX2xheW91dDogTGF5b3V0Q29uc3RydWN0b3IgfCBMYXlvdXQgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgX2NvbmZpZzogb2JqZWN0ID0ge307XG5cbiAgICBpZiAodHlwZW9mIGxheW91dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICgobGF5b3V0IGFzIExheW91dFNwZWNpZmllcikudHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9sYXlvdXQgPSAobGF5b3V0IGFzIExheW91dFNwZWNpZmllcikudHlwZTtcbiAgICAgICAgLy8gZGVsZXRlIChsYXlvdXQgYXMgTGF5b3V0U3BlY2lmaWVyKS50eXBlO1xuICAgICAgfVxuICAgICAgX2NvbmZpZyA9IGxheW91dCBhcyBvYmplY3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgX2xheW91dCA9IGxheW91dDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIF9sYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLl9sYXlvdXQgaW5zdGFuY2VvZiBfbGF5b3V0KSB7XG4gICAgICAgIGlmIChfY29uZmlnKSB7XG4gICAgICAgICAgdGhpcy5fbGF5b3V0IS5jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBfbGF5b3V0ID0gbmV3IF9sYXlvdXQoX2NvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xheW91dCkge1xuICAgICAgdGhpcy5fbWVhc3VyZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuX21lYXN1cmVDaGlsZE92ZXJyaWRlID0gbnVsbDtcbiAgICAgIHRoaXMuX2xheW91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGxzaXplY2hhbmdlJywgdGhpcyk7XG4gICAgICB0aGlzLl9sYXlvdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsZXJyb3JjaGFuZ2UnLCB0aGlzKTtcbiAgICAgIHRoaXMuX2xheW91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpdGVtcG9zaXRpb25jaGFuZ2UnLCB0aGlzKTtcbiAgICAgIHRoaXMuX2xheW91dC5yZW1vdmVFdmVudExpc3RlbmVyKCdyYW5nZWNoYW5nZScsIHRoaXMpO1xuICAgICAgdGhpcy5fc2l6ZUhvc3RFbGVtZW50KHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLl9ob3N0RWxlbWVudCEucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2xvYWRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGF5b3V0ID0gX2xheW91dCBhcyBMYXlvdXQgfCBudWxsO1xuXG4gICAgaWYgKHRoaXMuX2xheW91dCkge1xuICAgICAgaWYgKHRoaXMuX2xheW91dC5tZWFzdXJlQ2hpbGRyZW4gJiYgdHlwZW9mIHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fbWVhc3VyZUNoaWxkT3ZlcnJpZGUgPSB0aGlzLl9sYXlvdXQubWVhc3VyZUNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayA9IHRoaXMuX2xheW91dC51cGRhdGVJdGVtU2l6ZXMuYmluZCh0aGlzLl9sYXlvdXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5b3V0LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbHNpemVjaGFuZ2UnLCB0aGlzKTtcbiAgICAgIHRoaXMuX2xheW91dC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxlcnJvcmNoYW5nZScsIHRoaXMpO1xuICAgICAgdGhpcy5fbGF5b3V0LmFkZEV2ZW50TGlzdGVuZXIoJ2l0ZW1wb3NpdGlvbmNoYW5nZScsIHRoaXMpO1xuICAgICAgdGhpcy5fbGF5b3V0LmFkZEV2ZW50TGlzdGVuZXIoJ3JhbmdlY2hhbmdlJywgdGhpcyk7XG4gICAgICBpZiAodGhpcy5fbGF5b3V0Lmxpc3RlbkZvckNoaWxkTG9hZEV2ZW50cykge1xuICAgICAgICB0aGlzLl9ob3N0RWxlbWVudCEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2xvYWRMaXN0ZW5lciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8gKGdyYXlub3J0b24pOiBSZXdvcmsgYmVuY2htYXJraW5nIHNvIHRoYXQgaXQgaGFzIG5vIEFQSSBhbmRcbiAgLy8gaW5zdGVhZCBpcyBhbHdheXMgb24gZXhjZXB0IGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIHN0YXJ0QmVuY2htYXJraW5nKCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcEJlbmNobWFya2luZygpIHtcbiAgICBpZiAodGhpcy5fYmVuY2htYXJrU3RhcnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vdyA9IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIGNvbnN0IHRpbWVFbGFwc2VkID0gbm93IC0gdGhpcy5fYmVuY2htYXJrU3RhcnQ7XG4gICAgICBjb25zdCBlbnRyaWVzID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgndXYtdmlydHVhbGl6aW5nJywgJ21lYXN1cmUnKTtcbiAgICAgIGNvbnN0IHZpcnR1YWxpemF0aW9uVGltZSA9IGVudHJpZXNcbiAgICAgICAgLmZpbHRlcihlID0+IGUuc3RhcnRUaW1lID49IHRoaXMuX2JlbmNobWFya1N0YXJ0ISAmJiBlLnN0YXJ0VGltZSA8IG5vdylcbiAgICAgICAgLnJlZHVjZSgodCwgbSkgPT4gdCArIG0uZHVyYXRpb24sIDApO1xuICAgICAgdGhpcy5fYmVuY2htYXJrU3RhcnQgPSBudWxsO1xuICAgICAgcmV0dXJuIHsgdGltZUVsYXBzZWQsIHZpcnR1YWxpemF0aW9uVGltZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgX21lYXN1cmVDaGlsZHJlbigpOiB2b2lkIHtcbiAgICBjb25zdCBtbTogQ2hpbGRNZWFzdXJlbWVudHMgPSB7fTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGNvbnN0IGZuID0gdGhpcy5fbWVhc3VyZUNoaWxkT3ZlcnJpZGUgfHwgdGhpcy5fbWVhc3VyZUNoaWxkO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBpZHggPSB0aGlzLl9maXJzdCArIGk7XG4gICAgICBpZiAodGhpcy5faXRlbXNDaGFuZ2VkIHx8IHRoaXMuX3RvQmVNZWFzdXJlZC5oYXMoY2hpbGQpKSB7XG4gICAgICAgIG1tW2lkeF0gPSBmbi5jYWxsKHRoaXMsIGNoaWxkLCB0aGlzLl9pdGVtc1tpZHhdIC8qYXMgdW5rbm93biBhcyBvYmplY3QqLyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkTWVhc3VyZW1lbnRzID0gbW07XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgICB0aGlzLl90b0JlTWVhc3VyZWQuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCwgaGVpZ2h0LCBhbmQgbWFyZ2lucyBvZiB0aGUgZ2l2ZW4gY2hpbGQuXG4gICAqL1xuICBfbWVhc3VyZUNoaWxkKGVsZW1lbnQ6IEVsZW1lbnQpOiBJdGVtQm94IHtcbiAgICAvLyBvZmZzZXRXaWR0aCBkb2Vzbid0IHRha2UgdHJhbnNmb3JtcyBpbiBjb25zaWRlcmF0aW9uLCBzbyB3ZSB1c2VcbiAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2hpY2ggZG9lcy5cbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt3aWR0aCwgaGVpZ2h0fSwgZ2V0TWFyZ2lucyhlbGVtZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggYW5kIHBvc2l0aW9uIG9mIGl0ZW0gdG8gc2Nyb2xsIHRvLiBUaGUgdmlydHVhbGl6ZXIgd2lsbCBmaXggdG8gdGhhdCBwb2ludFxuICAgKiB1bnRpbCB0aGUgdXNlciBzY3JvbGxzLlxuICAgKi9cbiAgc2V0IHNjcm9sbFRvSW5kZXgobmV3VmFsdWU6IFNjcm9sbFRvSW5kZXhWYWx1ZSkge1xuICAgIHRoaXMuX3Njcm9sbFRvSW5kZXggPSBuZXdWYWx1ZTtcbiAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVMYXlvdXQpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIF9zY2hlZHVsZShtZXRob2Q6IEZ1bmN0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQuaGFzKG1ldGhvZCkpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZC5hZGQobWV0aG9kKTtcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fc2NoZWR1bGVkLmRlbGV0ZShtZXRob2QpO1xuICAgICAgbWV0aG9kLmNhbGwodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX3VwZGF0ZURPTSgpIHtcbiAgICBjb25zdCB7X3JhbmdlQ2hhbmdlZCwgX2l0ZW1zQ2hhbmdlZH0gPSB0aGlzO1xuICAgIGlmICh0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCkge1xuICAgICAgdGhpcy5fbm90aWZ5VmlzaWJpbGl0eSgpO1xuICAgICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKF9yYW5nZUNoYW5nZWQgfHwgX2l0ZW1zQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fbm90aWZ5UmFuZ2UoKTtcbiAgICAgIGF3YWl0IHRoaXMuX211dGF0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2NoaWxkcmVuUk8hLm9ic2VydmUoY2hpbGQpKTtcbiAgICB0aGlzLl9wb3NpdGlvbkNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuUG9zISk7XG4gICAgdGhpcy5fc2l6ZUhvc3RFbGVtZW50KHRoaXMuX3Njcm9sbFNpemUpO1xuICAgIGlmICh0aGlzLl9zY3JvbGxFcnJvcikge1xuICAgICAgdGhpcy5fY29ycmVjdFNjcm9sbEVycm9yKHRoaXMuX3Njcm9sbEVycm9yKTtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5tYXJrKCd1di1lbmQnKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGF5b3V0KCkge1xuICAgIGlmICh0aGlzLl9sYXlvdXQpIHtcbiAgICAgIHRoaXMuX2xheW91dCEudG90YWxJdGVtcyA9IHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLl9zY3JvbGxUb0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xheW91dCEuc2Nyb2xsVG9JbmRleCh0aGlzLl9zY3JvbGxUb0luZGV4LmluZGV4LCB0aGlzLl9zY3JvbGxUb0luZGV4IS5wb3NpdGlvbiEpO1xuICAgICAgICB0aGlzLl9zY3JvbGxUb0luZGV4ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VwZGF0ZVZpZXcoKTtcbiAgICAgIGlmICh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGUgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQsIHdlIG1heSBoYXZlIG1lYXN1cmVtZW50cyBidXQgbm8gY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMuX21lYXN1cmVDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuX21lYXN1cmVDYWxsYmFjayh0aGlzLl9jaGlsZE1lYXN1cmVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hpbGRNZWFzdXJlbWVudHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGF5b3V0IS5yZWZsb3dJZk5lZWRlZCh0aGlzLl9pdGVtc0NoYW5nZWQpO1xuICAgICAgaWYgKHRoaXMuX2JlbmNobWFya1N0YXJ0ICYmICdtYXJrJyBpbiB3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm1hcmsoJ3V2LWVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVNjcm9sbEV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9iZW5jaG1hcmtTdGFydCAmJiAnbWFyaycgaW4gd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgICAgICAndXYtdmlydHVhbGl6aW5nJyxcbiAgICAgICAgICAndXYtc3RhcnQnLFxuICAgICAgICAgICd1di1lbmQnXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBtZWFzdXJpbmcgcGVyZm9ybWFuY2UgZGF0YTogJywgZSk7XG4gICAgICB9XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2UubWFyaygndXYtc3RhcnQnKTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZWR1bGUodGhpcy5fdXBkYXRlTGF5b3V0KTtcbiAgfVxuXG4gIGhhbmRsZUV2ZW50KGV2ZW50OiBDdXN0b21FdmVudCkge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IHdpbmRvdyB8fCB0aGlzLl9jbGlwcGluZ0FuY2VzdG9ycy5pbmNsdWRlcyhldmVudC5jdXJyZW50VGFyZ2V0IGFzIEVsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlU2Nyb2xsRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Njcm9sbHNpemVjaGFuZ2UnOlxuICAgICAgICB0aGlzLl9zY3JvbGxTaXplID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVET00pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Njcm9sbGVycm9yY2hhbmdlJzpcbiAgICAgICAgdGhpcy5fc2Nyb2xsRXJyb3IgPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZURPTSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaXRlbXBvc2l0aW9uY2hhbmdlJzpcbiAgICAgICAgdGhpcy5fY2hpbGRyZW5Qb3MgPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZURPTSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmFuZ2VjaGFuZ2UnOlxuICAgICAgICB0aGlzLl9hZGp1c3RSYW5nZShldmVudC5kZXRhaWwpO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSh0aGlzLl91cGRhdGVET00pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybignZXZlbnQgbm90IGhhbmRsZWQnLCBldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9jaGlsZHJlbigpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGxldCBuZXh0ID0gdGhpcy5faG9zdEVsZW1lbnQhLmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50O1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAoIW5leHQuaGFzQXR0cmlidXRlKFNJWkVSX0FUVFJJQlVURSkpIHtcbiAgICAgICAgYXJyLnB1c2gobmV4dCk7XG4gICAgICB9XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0RWxlbWVudFNpYmxpbmcgYXMgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICBwcml2YXRlIF91cGRhdGVWaWV3KCkge1xuICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5faG9zdEVsZW1lbnQhO1xuICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX2xheW91dCE7XG5cbiAgICBsZXQgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBzY3JvbGxUb3AsIHNjcm9sbExlZnQ7XG5cbiAgICBjb25zdCBob3N0RWxlbWVudEJvdW5kcyA9IGhvc3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdG9wID0gMFxuICAgIGxlZnQgPSAwO1xuICAgIGJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICByaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgZm9yIChsZXQgYW5jZXN0b3Igb2YgdGhpcy5fY2xpcHBpbmdBbmNlc3RvcnMpIHtcbiAgICAgIGNvbnN0IGFuY2VzdG9yQm91bmRzID0gYW5jZXN0b3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIGFuY2VzdG9yQm91bmRzLnRvcCk7XG4gICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgYW5jZXN0b3JCb3VuZHMubGVmdCk7XG4gICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIGFuY2VzdG9yQm91bmRzLmJvdHRvbSk7XG4gICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBhbmNlc3RvckJvdW5kcy5yaWdodCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsVG9wID0gdG9wIC0gaG9zdEVsZW1lbnRCb3VuZHMudG9wICsgaG9zdEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHNjcm9sbExlZnQgPSBsZWZ0IC0gaG9zdEVsZW1lbnRCb3VuZHMubGVmdCArIGhvc3RFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoMSwgYm90dG9tIC0gdG9wKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KDEsIHJpZ2h0IC0gbGVmdCk7XG5cbiAgICBsYXlvdXQudmlld3BvcnRTaXplID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIGxheW91dC52aWV3cG9ydFNjcm9sbCA9IHt0b3A6IHNjcm9sbFRvcCwgbGVmdDogc2Nyb2xsTGVmdH07XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBob3N0IGVsZW1lbnQgc28gdGhhdCBpdHMgc2l6ZSByZWZsZWN0cyB0aGVcbiAgICogdG90YWwgc2l6ZSBvZiBhbGwgaXRlbXMuXG4gICAqL1xuICBwcml2YXRlIF9zaXplSG9zdEVsZW1lbnQoc2l6ZT86IFNjcm9sbFNpemUgfCBudWxsKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZWVtIHRvIGNyYXAgb3V0IGlmIHRoZSBob3N0IGVsZW1lbnQgZ2V0cyBsYXJnZXIgdGhhblxuICAgIC8vIGEgY2VydGFpbiBzaXplLCBzbyB3ZSBjbGFtcCBpdCBoZXJlICh0aGlzIHZhbHVlIGJhc2VkIG9uIGFkIGhvY1xuICAgIC8vIHRlc3RpbmcgaW4gQ2hyb21lIC8gU2FmYXJpIC8gRmlyZWZveCBNYWMpXG4gICAgY29uc3QgbWF4ID0gODIwMDAwMDtcbiAgICBjb25zdCBoID0gc2l6ZSAmJiAoc2l6ZSBhcyBIb3Jpem9udGFsU2Nyb2xsU2l6ZSkud2lkdGggPyBNYXRoLm1pbihtYXgsIChzaXplIGFzIEhvcml6b250YWxTY3JvbGxTaXplKS53aWR0aCkgOiAwO1xuICAgIGNvbnN0IHYgPSBzaXplICYmIChzaXplIGFzIFZlcnRpY2FsU2Nyb2xsU2l6ZSkuaGVpZ2h0ID8gTWF0aC5taW4obWF4LCAoc2l6ZSBhcyBWZXJ0aWNhbFNjcm9sbFNpemUpLmhlaWdodCkgOiAwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2Nyb2xsZXIpIHtcbiAgICAgIHRoaXMuX2dldFNpemVyKCkuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2h9cHgsICR7dn1weClgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5faG9zdEVsZW1lbnQhLnN0eWxlO1xuICAgICAgKHN0eWxlLm1pbldpZHRoIGFzIHN0cmluZyB8IG51bGwpID0gaCA/IGAke2h9cHhgIDogJzEwMCUnO1xuICAgICAgKHN0eWxlLm1pbkhlaWdodCBhcyBzdHJpbmcgfCBudWxsKSA9IHYgPyBgJHt2fXB4YCA6ICcxMDAlJzsgIFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0b3AgYW5kIGxlZnQgdHJhbnNmb3JtIHN0eWxlIG9mIHRoZSBjaGlsZHJlbiBmcm9tIHRoZSB2YWx1ZXMgaW5cbiAgICogcG9zLlxuICAgKi9cbiAgcHJpdmF0ZSBfcG9zaXRpb25DaGlsZHJlbihwb3M6IEFycmF5PFBvc2l0aW9ucz4pIHtcbiAgICBpZiAocG9zKSB7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgICAgT2JqZWN0LmtleXMocG9zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgaWR4ID0gKGtleSBhcyB1bmtub3duIGFzIG51bWJlcikgLSB0aGlzLl9maXJzdDtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpZHhdO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBjb25zdCB7dG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0LCB4T2Zmc2V0LCB5T2Zmc2V0fSA9IHBvc1trZXkgYXMgdW5rbm93biBhcyBudW1iZXJdO1xuICAgICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICBjaGlsZC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgICAgICAgY2hpbGQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsICR7dG9wfXB4KWA7XG4gICAgICAgICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIChjaGlsZC5zdHlsZS5sZWZ0IGFzIHN0cmluZyB8IG51bGwpID0geE9mZnNldCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHhPZmZzZXQgKyAncHgnO1xuICAgICAgICAgIChjaGlsZC5zdHlsZS50b3AgYXMgc3RyaW5nIHwgbnVsbCkgPSB5T2Zmc2V0ID09PSB1bmRlZmluZWQgPyBudWxsIDogeU9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2FkanVzdFJhbmdlKHJhbmdlOiBJbnRlcm5hbFJhbmdlKSB7XG4gICAgY29uc3Qge19maXJzdCwgX2xhc3QsIF9maXJzdFZpc2libGUsIF9sYXN0VmlzaWJsZX0gPSB0aGlzO1xuICAgIHRoaXMuX2ZpcnN0ID0gcmFuZ2UuZmlyc3Q7XG4gICAgdGhpcy5fbGFzdCA9IHJhbmdlLmxhc3Q7XG4gICAgdGhpcy5fZmlyc3RWaXNpYmxlID0gcmFuZ2UuZmlyc3RWaXNpYmxlO1xuICAgIHRoaXMuX2xhc3RWaXNpYmxlID0gcmFuZ2UubGFzdFZpc2libGU7XG4gICAgdGhpcy5fcmFuZ2VDaGFuZ2VkID0gKFxuICAgICAgdGhpcy5fcmFuZ2VDaGFuZ2VkIHx8XG4gICAgICB0aGlzLl9maXJzdCAhPT0gX2ZpcnN0IHx8XG4gICAgICB0aGlzLl9sYXN0ICE9PSBfbGFzdFxuICAgICk7XG4gICAgdGhpcy5fdmlzaWJpbGl0eUNoYW5nZWQgPSAoXG4gICAgICB0aGlzLl92aXNpYmlsaXR5Q2hhbmdlZCB8fFxuICAgICAgdGhpcy5fZmlyc3RWaXNpYmxlICE9PSBfZmlyc3RWaXNpYmxlIHx8XG4gICAgICB0aGlzLl9sYXN0VmlzaWJsZSAhPT0gX2xhc3RWaXNpYmxlXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvcnJlY3RTY3JvbGxFcnJvcihlcnI6IHt0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2NsaXBwaW5nQW5jZXN0b3JzWzBdO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRhcmdldC5zY3JvbGxUb3AgLT0gZXJyLnRvcDtcbiAgICAgIHRhcmdldC5zY3JvbGxMZWZ0IC09IGVyci5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsKHdpbmRvdy5wYWdlWE9mZnNldCAtIGVyci5sZWZ0LCB3aW5kb3cucGFnZVlPZmZzZXQgLSBlcnIudG9wKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgYSByYW5nZWNoYW5nZSBldmVudCB3aXRoIHRoZSBjdXJyZW50IGZpcnN0LCBsYXN0LCBmaXJzdFZpc2libGUsIGFuZFxuICAgKiBsYXN0VmlzaWJsZS5cbiAgICovXG4gIHByaXZhdGUgX25vdGlmeVJhbmdlKCkge1xuICAgIHRoaXMuX2hvc3RFbGVtZW50IS5kaXNwYXRjaEV2ZW50KG5ldyBSYW5nZUNoYW5nZWRFdmVudCh7IGZpcnN0OiB0aGlzLl9maXJzdCwgbGFzdDogdGhpcy5fbGFzdCB9KSk7XG4gIH1cblxuICBwcml2YXRlIF9ub3RpZnlWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuX2hvc3RFbGVtZW50IS5kaXNwYXRjaEV2ZW50KG5ldyBWaXNpYmlsaXR5Q2hhbmdlZEV2ZW50KHsgZmlyc3Q6IHRoaXMuX2ZpcnN0VmlzaWJsZSwgbGFzdDogdGhpcy5fbGFzdFZpc2libGUgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhbmQgdXBkYXRlIHRoZSB2aWV3IGF0IHRoZSBuZXh0IG9wcG9ydHVuaXR5IHdpdGggdGhlIGdpdmVuXG4gICAqIGhvc3RFbGVtZW50IHNpemUuXG4gICAqL1xuICBwcml2YXRlIF9ob3N0RWxlbWVudFNpemVDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3NjaGVkdWxlKHRoaXMuX3VwZGF0ZUxheW91dCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9vYnNlcnZlTXV0YXRpb25zKCkge1xuICAgIGlmICghdGhpcy5fbXV0YXRpb25zT2JzZXJ2ZWQpIHtcbiAgICAgIHRoaXMuX211dGF0aW9uc09ic2VydmVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX211dGF0aW9uUHJvbWlzZVJlc29sdmVyISgpO1xuICAgICAgdGhpcy5fbXV0YXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLl9tdXRhdGlvblByb21pc2VSZXNvbHZlciA9IHJlc29sdmUpO1xuICAgICAgdGhpcy5fbXV0YXRpb25zT2JzZXJ2ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPIChncmF5bm9ydG9uKTogUmV0aGluayBob3cgdGhpcyB3b3Jrcy4gUHJvYmFibHkgY2hpbGQgbG9hZGluZyBpcyB0b28gc3BlY2lmaWNcbiAgLy8gdG8gaGF2ZSBkZWRpY2F0ZWQgc3VwcG9ydCBmb3I7IG1pZ2h0IHdhbnQgc29tZSBtb3JlIGdlbmVyaWMgbGlmZWN5Y2xlIGhvb2tzIGZvclxuICAvLyBsYXlvdXRzIHRvIHVzZS4gUG9zc2libHkgaGFuZGxlIG1lYXN1cmVtZW50IHRoaXMgd2F5LCB0b28sIG9yIG1heWJlIHRoYXQgcmVtYWluc1xuICAvLyBhIGZpcnN0LWNsYXNzIGZlYXR1cmU/XG5cbiAgcHJpdmF0ZSBfY2hpbGRMb2FkZWQoKSB7XG4gICAgLy8gdGhpcy5yZXF1ZXN0UmVtZWFzdXJlKCk7XG4gIH1cblxuICAvLyBUaGlzIGlzIHRoZSBjYWxsYmFjayBmb3IgdGhlIFJlc2l6ZU9ic2VydmVyIHRoYXQgd2F0Y2hlcyB0aGVcbiAgLy8gdmlydHVhbGl6ZXIncyBjaGlsZHJlbi4gV2UgbGFuZCBoZXJlIGF0IHRoZSBlbmQgb2YgZXZlcnkgdmlydHVhbGl6ZXJcbiAgLy8gdXBkYXRlIGN5Y2xlIHRoYXQgcmVzdWx0cyBpbiBjaGFuZ2VzIHRvIHBoeXNpY2FsIGl0ZW1zLCBhbmQgd2UgYWxzb1xuICAvLyBlbmQgdXAgaGVyZSBpZiBvbmUgb3IgbW9yZSBjaGlsZHJlbiBjaGFuZ2Ugc2l6ZSBpbmRlcGVuZGVudGx5IG9mXG4gIC8vIHRoZSB2aXJ0dWFsaXplciB1cGRhdGUgY3ljbGUuXG4gIHByaXZhdGUgX2NoaWxkcmVuU2l6ZUNoYW5nZWQoY2hhbmdlczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKSB7XG4gICAgLy8gT25seSBtZWFzdXJlIGlmIHRoZSBsYXlvdXQgcmVxdWlyZXMgaXRcbiAgICBpZiAodGhpcy5fbGF5b3V0IS5tZWFzdXJlQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fdG9CZU1lYXN1cmVkLnNldChjaGFuZ2UudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBjaGFuZ2UuY29udGVudFJlY3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgdGhlIGVuZCBvZiBhbiB1cGRhdGUgY3ljbGUsIHdlIG5lZWQgdG8gcmVzZXQgc29tZVxuICAgIC8vIGludGVybmFsIHN0YXRlLiBUaGlzIHNob3VsZCBiZSBhIGhhcm1sZXNzIG5vLW9wIGlmIHdlJ3JlIGhhbmRsaW5nXG4gICAgLy8gYW4gb3V0LW9mLWN5Y2xlIFJlc2l6ZU9ic2VydmVyIGNhbGxiYWNrLCBzbyB3ZSBkb24ndCBuZWVkIHRvXG4gICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgdHdvIGNhc2VzLlxuICAgIHRoaXMuX2l0ZW1zQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2hhbmdlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoZWw6IEVsZW1lbnQpOiBNYXJnaW5zIHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHJldHVybiB7XG4gICAgbWFyZ2luVG9wOiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5Ub3ApLFxuICAgIG1hcmdpblJpZ2h0OiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5SaWdodCksXG4gICAgbWFyZ2luQm90dG9tOiBnZXRNYXJnaW5WYWx1ZShzdHlsZS5tYXJnaW5Cb3R0b20pLFxuICAgIG1hcmdpbkxlZnQ6IGdldE1hcmdpblZhbHVlKHN0eWxlLm1hcmdpbkxlZnQpLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5WYWx1ZSh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgZmxvYXQgPSB2YWx1ZSA/IHBhcnNlRmxvYXQodmFsdWUpIDogTmFOO1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKGZsb2F0KSA/IDAgOiBmbG9hdDtcbn1cblxuLy8gVE9ETyAoZ3JheW5vcnRvbik6IERlYWwgd2l0aCBpZnJhbWVzP1xuZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChlbDogRWxlbWVudCkge1xuICBpZiAoZWwucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBlbC5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICByZXR1cm4gKHBhcmVudE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50QW5jZXN0b3JzKGVsOiBFbGVtZW50LCBpbmNsdWRlU2VsZj1mYWxzZSkge1xuICBjb25zdCBhbmNlc3RvcnMgPSBbXTtcbiAgbGV0IHBhcmVudCA9IGluY2x1ZGVTZWxmID8gZWwgOiBnZXRQYXJlbnRFbGVtZW50KGVsKTtcbiAgd2hpbGUocGFyZW50ICE9PSBudWxsKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KTtcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRFbGVtZW50KHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGFuY2VzdG9ycztcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdBbmNlc3RvcnMoZWw6IEVsZW1lbnQsIGluY2x1ZGVTZWxmPWZhbHNlKSB7XG4gIHJldHVybiBnZXRFbGVtZW50QW5jZXN0b3JzKGVsLCBpbmNsdWRlU2VsZilcbiAgICAuZmlsdGVyKGEgPT4gZ2V0Q29tcHV0ZWRTdHlsZShhKS5vdmVyZmxvdyAhPT0gJ3Zpc2libGUnKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/Virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/lit-virtualizer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/lit-virtualizer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LitVirtualizer\": () => (/* binding */ LitVirtualizer)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/@lit-labs/virtualizer/node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var lit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lit */ \"./node_modules/lit/index.js\");\n/* harmony import */ var lit_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lit/decorators/custom-element.js */ \"./node_modules/lit/decorators/custom-element.js\");\n/* harmony import */ var lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lit/decorators/property.js */ \"./node_modules/lit/decorators/property.js\");\n/* harmony import */ var lit_decorators_state_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lit/decorators/state.js */ \"./node_modules/lit/decorators/state.js\");\n/* harmony import */ var lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lit/directives/repeat.js */ \"./node_modules/lit/directives/repeat.js\");\n/* harmony import */ var _Virtualizer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Virtualizer.js */ \"./node_modules/@lit-labs/virtualizer/Virtualizer.js\");\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n\n\n\n\n\n\n\nconst defaultKeyFunction = item => item;\n\nconst defaultRenderItem = (item, idx) => lit__WEBPACK_IMPORTED_MODULE_1__.html`${idx}: ${JSON.stringify(item, null, 2)}`;\n/**\n * Import this module to declare the lit-virtualizer custom element.\n */\n\n\nlet LitVirtualizer = class LitVirtualizer extends lit__WEBPACK_IMPORTED_MODULE_1__.LitElement {\n  constructor() {\n    super(...arguments);\n\n    this._renderItem = (item, idx) => defaultRenderItem(item, idx + this._first);\n\n    this._providedRenderItem = defaultRenderItem;\n    this.items = [];\n    this.scroller = false;\n    this.keyFunction = defaultKeyFunction;\n    this._first = 0;\n    this._last = -1;\n  }\n\n  set renderItem(fn) {\n    this._providedRenderItem = fn;\n\n    this._renderItem = (item, idx) => fn(item, idx + this._first);\n\n    this.requestUpdate();\n  }\n\n  get renderItem() {\n    return this._providedRenderItem;\n  }\n\n  set layout(layout) {\n    this._layout = layout;\n\n    if (layout && this._virtualizer) {\n      this._virtualizer.layout = layout;\n    }\n  }\n\n  get layout() {\n    return this[_Virtualizer_js__WEBPACK_IMPORTED_MODULE_6__.virtualizerRef].layout;\n  }\n  /**\n   * Scroll to the specified index, placing that item at the given position\n   * in the scroll view.\n   */\n\n\n  scrollToIndex(index, position = 'start') {\n    this._virtualizer.scrollToIndex = {\n      index,\n      position\n    };\n  }\n\n  updated() {\n    if (this._virtualizer) {\n      if (this._layout !== undefined) {\n        this._virtualizer.layout = this._layout;\n      }\n\n      this._virtualizer.items = this.items;\n    }\n  }\n\n  firstUpdated() {\n    const hostElement = this;\n    const layout = this._layout;\n    this._virtualizer = new _Virtualizer_js__WEBPACK_IMPORTED_MODULE_6__.Virtualizer({\n      hostElement,\n      layout,\n      scroller: this.scroller\n    });\n    hostElement.addEventListener('rangeChanged', e => {\n      e.stopPropagation();\n      this._first = e.first;\n      this._last = e.last;\n    });\n\n    this._virtualizer.connected();\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (this._virtualizer) {\n      this._virtualizer.connected();\n    }\n  }\n\n  disconnectedCallback() {\n    if (this._virtualizer) {\n      this._virtualizer.disconnected();\n    }\n\n    super.disconnectedCallback();\n  }\n\n  createRenderRoot() {\n    return this;\n  }\n\n  render() {\n    const {\n      items,\n      _renderItem,\n      keyFunction\n    } = this;\n    const itemsToRender = [];\n\n    if (this._first >= 0 && this._last >= this._first) {\n      for (let i = this._first; i < this._last + 1; i++) {\n        itemsToRender.push(items[i]);\n      }\n    }\n\n    return (0,lit_directives_repeat_js__WEBPACK_IMPORTED_MODULE_5__.repeat)(itemsToRender, keyFunction || defaultKeyFunction, _renderItem);\n  }\n\n};\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)()], LitVirtualizer.prototype, \"renderItem\", null);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)({\n  attribute: false\n})], LitVirtualizer.prototype, \"items\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)({\n  reflect: true,\n  type: Boolean\n})], LitVirtualizer.prototype, \"scroller\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)()], LitVirtualizer.prototype, \"keyFunction\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_state_js__WEBPACK_IMPORTED_MODULE_4__.state)()], LitVirtualizer.prototype, \"_first\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_state_js__WEBPACK_IMPORTED_MODULE_4__.state)()], LitVirtualizer.prototype, \"_last\", void 0);\n\n(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_property_js__WEBPACK_IMPORTED_MODULE_3__.property)({\n  attribute: false\n})], LitVirtualizer.prototype, \"layout\", null);\n\nLitVirtualizer = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([(0,lit_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_2__.customElement)('lit-virtualizer')], LitVirtualizer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL2xpdC12aXJ0dWFsaXplci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBOztBQUNBO0FBRUE7O0FBRUE7OztBQUVBO0FBQUE7OztBQUNBOztBQUNBO0FBY0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQTJFQTs7QUFuR0E7QUFDQTs7QUFDQTs7QUFDQTtBQUNBOztBQUdBO0FBQ0E7QUFDQTs7QUFzQkE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7OztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQXRHQTs7QUFXQTs7QUFLQTtBQURBO0FBQUE7O0FBSUE7QUFEQTtBQUFBO0FBQUE7O0FBSUE7O0FBR0E7O0FBR0E7O0FBT0E7QUFEQTtBQUFBOztBQWxDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kL3NyYy9saXQtdmlydHVhbGl6ZXIudHM/YjI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHsgaHRtbCwgTGl0RWxlbWVudCwgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQnO1xuaW1wb3J0IHsgY3VzdG9tRWxlbWVudCB9IGZyb20gJ2xpdC9kZWNvcmF0b3JzL2N1c3RvbS1lbGVtZW50LmpzJztcbmltcG9ydCB7IHByb3BlcnR5IH0gZnJvbSAnbGl0L2RlY29yYXRvcnMvcHJvcGVydHkuanMnO1xuaW1wb3J0IHsgc3RhdGUgfSBmcm9tICdsaXQvZGVjb3JhdG9ycy9zdGF0ZS5qcyc7XG5pbXBvcnQgeyByZXBlYXQgfSBmcm9tICdsaXQvZGlyZWN0aXZlcy9yZXBlYXQuanMnO1xuaW1wb3J0IHsgVmlydHVhbGl6ZXIsIFZpcnR1YWxpemVySG9zdEVsZW1lbnQsIHZpcnR1YWxpemVyUmVmLCBSYW5nZUNoYW5nZWRFdmVudCB9IGZyb20gJy4vVmlydHVhbGl6ZXIuanMnO1xuaW1wb3J0IHsgTGF5b3V0U3BlY2lmaWVyLCBMYXlvdXQsIExheW91dENvbnN0cnVjdG9yIH0gZnJvbSAnLi9sYXlvdXRzL3NoYXJlZC9MYXlvdXQuanMnO1xuXG5cbnR5cGUgUmVuZGVySXRlbUZ1bmN0aW9uID0gKChpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IFRlbXBsYXRlUmVzdWx0KVxuY29uc3QgZGVmYXVsdEtleUZ1bmN0aW9uID0gKGl0ZW06IGFueSkgPT4gaXRlbTtcbmNvbnN0IGRlZmF1bHRSZW5kZXJJdGVtOiBSZW5kZXJJdGVtRnVuY3Rpb24gPSAoaXRlbTogYW55LCBpZHg6IG51bWJlcikgPT4gaHRtbGAke2lkeH06ICR7SlNPTi5zdHJpbmdpZnkoaXRlbSwgbnVsbCwgMil9YDtcblxuLyoqXG4gKiBJbXBvcnQgdGhpcyBtb2R1bGUgdG8gZGVjbGFyZSB0aGUgbGl0LXZpcnR1YWxpemVyIGN1c3RvbSBlbGVtZW50LlxuICovXG5AY3VzdG9tRWxlbWVudCgnbGl0LXZpcnR1YWxpemVyJylcbmV4cG9ydCBjbGFzcyBMaXRWaXJ0dWFsaXplciBleHRlbmRzIExpdEVsZW1lbnQge1xuICAgIHByaXZhdGUgX3JlbmRlckl0ZW06IFJlbmRlckl0ZW1GdW5jdGlvbiA9IChpdGVtLCBpZHgpID0+IGRlZmF1bHRSZW5kZXJJdGVtKGl0ZW0sIGlkeCArIHRoaXMuX2ZpcnN0KTtcbiAgICBwcml2YXRlIF9wcm92aWRlZFJlbmRlckl0ZW06IFJlbmRlckl0ZW1GdW5jdGlvbiA9IGRlZmF1bHRSZW5kZXJJdGVtO1xuXG4gICAgc2V0IHJlbmRlckl0ZW0oZm46IFJlbmRlckl0ZW1GdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9wcm92aWRlZFJlbmRlckl0ZW0gPSBmbjtcbiAgICAgICAgdGhpcy5fcmVuZGVySXRlbSA9IChpdGVtLCBpZHgpID0+IGZuKGl0ZW0sIGlkeCArIHRoaXMuX2ZpcnN0KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgQHByb3BlcnR5KClcbiAgICBnZXQgcmVuZGVySXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3ZpZGVkUmVuZGVySXRlbTtcbiAgICB9XG5cbiAgICBAcHJvcGVydHkoe2F0dHJpYnV0ZTogZmFsc2V9KVxuICAgIGl0ZW1zOiBBcnJheTx1bmtub3duPiA9IFtdO1xuXG4gICAgQHByb3BlcnR5KHtyZWZsZWN0OiB0cnVlLCB0eXBlOiBCb29sZWFufSlcbiAgICBzY3JvbGxlciA9IGZhbHNlO1xuXG4gICAgQHByb3BlcnR5KClcbiAgICBrZXlGdW5jdGlvbjogKChpdGVtOnVua25vd24pID0+IHVua25vd24pIHwgdW5kZWZpbmVkID0gZGVmYXVsdEtleUZ1bmN0aW9uO1xuXG4gICAgQHN0YXRlKClcbiAgICBwcml2YXRlIF9maXJzdCA9IDA7XG5cbiAgICBAc3RhdGUoKVxuICAgIHByaXZhdGUgX2xhc3QgPSAtMTtcblxuICAgIHByaXZhdGUgX2xheW91dD86IExheW91dCB8IExheW91dENvbnN0cnVjdG9yIHwgTGF5b3V0U3BlY2lmaWVyIHwgbnVsbDtcblxuICAgIHByaXZhdGUgX3ZpcnR1YWxpemVyPzogVmlydHVhbGl6ZXI7XG4gIFxuICAgIEBwcm9wZXJ0eSh7YXR0cmlidXRlOmZhbHNlfSlcbiAgICBzZXQgbGF5b3V0KGxheW91dDogTGF5b3V0IHwgTGF5b3V0Q29uc3RydWN0b3IgfCBMYXlvdXRTcGVjaWZpZXIgfCBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgaWYgKGxheW91dCAmJiB0aGlzLl92aXJ0dWFsaXplcikge1xuICAgICAgICAgICAgdGhpcy5fdmlydHVhbGl6ZXIubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxheW91dCgpOiBMYXlvdXQgfCBMYXlvdXRDb25zdHJ1Y3RvciB8IExheW91dFNwZWNpZmllciB8IG51bGwge1xuICAgICAgICByZXR1cm4gKHRoaXMgYXMgVmlydHVhbGl6ZXJIb3N0RWxlbWVudClbdmlydHVhbGl6ZXJSZWZdIS5sYXlvdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXgsIHBsYWNpbmcgdGhhdCBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvblxuICAgICAqIGluIHRoZSBzY3JvbGwgdmlldy5cbiAgICAgKi9cbiAgICBzY3JvbGxUb0luZGV4KGluZGV4OiBudW1iZXIsIHBvc2l0aW9uOiBzdHJpbmcgPSAnc3RhcnQnKSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxpemVyIS5zY3JvbGxUb0luZGV4ID0geyBpbmRleCwgcG9zaXRpb24gfTtcbiAgICB9XG5cbiAgICB1cGRhdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fdmlydHVhbGl6ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnR1YWxpemVyIS5sYXlvdXQgPSB0aGlzLl9sYXlvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92aXJ0dWFsaXplciEuaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RVcGRhdGVkKCkge1xuICAgICAgICBjb25zdCBob3N0RWxlbWVudCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX2xheW91dDtcbiAgICAgICAgdGhpcy5fdmlydHVhbGl6ZXIgPSBuZXcgVmlydHVhbGl6ZXIoeyBob3N0RWxlbWVudCwgbGF5b3V0LCBzY3JvbGxlcjogdGhpcy5zY3JvbGxlciB9KTtcbiAgICAgICAgaG9zdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmFuZ2VDaGFuZ2VkJywgKGU6IFJhbmdlQ2hhbmdlZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBlLmZpcnN0O1xuICAgICAgICAgICAgdGhpcy5fbGFzdCA9IGUubGFzdDtcbiAgICAgICAgfSk7ICAgIFxuICAgICAgICB0aGlzLl92aXJ0dWFsaXplciEuY29ubmVjdGVkKCk7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIGlmICh0aGlzLl92aXJ0dWFsaXplcikge1xuICAgICAgICAgICAgdGhpcy5fdmlydHVhbGl6ZXIuY29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpcnR1YWxpemVyKSB7XG4gICAgICAgICAgICB0aGlzLl92aXJ0dWFsaXplci5kaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGNyZWF0ZVJlbmRlclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlbmRlcigpOiBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IHsgaXRlbXMsIF9yZW5kZXJJdGVtLCBrZXlGdW5jdGlvbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXRlbXNUb1JlbmRlciA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPj0gMCAmJiB0aGlzLl9sYXN0ID49IHRoaXMuX2ZpcnN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZmlyc3Q7IGkgPCB0aGlzLl9sYXN0ICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbXNUb1JlbmRlci5wdXNoKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdChpdGVtc1RvUmVuZGVyLCBrZXlGdW5jdGlvbiB8fCBkZWZhdWx0S2V5RnVuY3Rpb24sIF9yZW5kZXJJdGVtKSBhcyBUZW1wbGF0ZVJlc3VsdDtcbiAgICB9XG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBpbnRlcmZhY2UgSFRNTEVsZW1lbnRUYWdOYW1lTWFwIHtcbiAgICAgICAgJ2xpdC12aXJ0dWFsaXplcic6IExpdFZpcnR1YWxpemVyO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/lit-virtualizer.js\n");

/***/ }),

/***/ "./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ResizeObserver)\n/* harmony export */ });\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nlet _RO;\n\nlet RO;\nasync function ResizeObserver() {\n  return RO || init();\n}\n\nasync function init() {\n  if (_RO) {\n    return (await _RO).default;\n  } else {\n    _RO = window.ResizeObserver;\n\n    try {\n      new _RO(function () {});\n    } catch (e) {\n      _RO = __webpack_require__.e(/*! import() */ \"vendors-node_modules_lit-labs_virtualizer_polyfills_resize-observer-polyfill_ResizeObserver_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../polyfills/resize-observer-polyfill/ResizeObserver.js */ \"./node_modules/@lit-labs/virtualizer/polyfills/resize-observer-polyfill/ResizeObserver.js\"));\n      _RO = (await _RO).default;\n    }\n\n    return RO = _RO;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdC1sYWJzL3ZpcnR1YWxpemVyL3BvbHlmaWxsTG9hZGVycy9SZXNpemVPYnNlcnZlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7QUFJQTtBQUtBOztBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hvbWUtYXNzaXN0YW50LWZyb250ZW5kLy4uL3NyYy9wb2x5ZmlsbExvYWRlcnMvUmVzaXplT2JzZXJ2ZXIudHM/NDNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQlNELTMtQ2xhdXNlXG4gKi9cblxuaW1wb3J0IHsgUmVzaXplT2JzZXJ2ZXJDb25zdHJ1Y3RvciB9IGZyb20gJy4uL3BvbHlmaWxscy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvUmVzaXplT2JzZXJ2ZXIuanMnO1xudHlwZSBSZXNpemVPYnNlcnZlck1vZHVsZSA9IHR5cGVvZiBpbXBvcnQoJy4uL3BvbHlmaWxscy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvUmVzaXplT2JzZXJ2ZXIuanMnKTtcblxubGV0IF9STzogUmVzaXplT2JzZXJ2ZXJNb2R1bGUgfCBSZXNpemVPYnNlcnZlckNvbnN0cnVjdG9yO1xubGV0IFJPOiBSZXNpemVPYnNlcnZlckNvbnN0cnVjdG9yO1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBSZXNpemVPYnNlcnZlcigpIHtcbiAgICByZXR1cm4gUk8gfHwgaW5pdCgpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpbml0KCkge1xuICAgIGlmIChfUk8pIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCBfUk8gYXMgUmVzaXplT2JzZXJ2ZXJNb2R1bGUpLmRlZmF1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfUk8gPSB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgX1JPKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfUk8gPSBpbXBvcnQoJy4uL3BvbHlmaWxscy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvUmVzaXplT2JzZXJ2ZXIuanMnKSBhcyB1bmtub3duIGFzIFJlc2l6ZU9ic2VydmVyTW9kdWxlO1xuICAgICAgICAgICAgX1JPID0gKGF3YWl0IF9STykuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJPID0gX1JPKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lit-labs/virtualizer/polyfillLoaders/ResizeObserver.js\n");

/***/ }),

/***/ "./node_modules/lit/decorators/custom-element.js":
/*!*******************************************************!*\
  !*** ./node_modules/lit/decorators/custom-element.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customElement": () => (/* reexport safe */ _lit_reactive_element_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_0__.customElement)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element_decorators_custom_element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element/decorators/custom-element.js */ "./node_modules/@lit/reactive-element/development/decorators/custom-element.js");


/***/ }),

/***/ "./node_modules/lit/decorators/property.js":
/*!*************************************************!*\
  !*** ./node_modules/lit/decorators/property.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "property": () => (/* reexport safe */ _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_0__.property)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element_decorators_property_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element/decorators/property.js */ "./node_modules/@lit/reactive-element/development/decorators/property.js");


/***/ }),

/***/ "./node_modules/lit/decorators/state.js":
/*!**********************************************!*\
  !*** ./node_modules/lit/decorators/state.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "state": () => (/* reexport safe */ _lit_reactive_element_decorators_state_js__WEBPACK_IMPORTED_MODULE_0__.state)
/* harmony export */ });
/* harmony import */ var _lit_reactive_element_decorators_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lit/reactive-element/decorators/state.js */ "./node_modules/@lit/reactive-element/development/decorators/state.js");


/***/ })

}]);